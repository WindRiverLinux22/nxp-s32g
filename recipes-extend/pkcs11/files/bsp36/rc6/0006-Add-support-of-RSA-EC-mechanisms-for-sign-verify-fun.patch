From 4a5bead6a11553f8172e9e89a7e25f9fabc3ce19 Mon Sep 17 00:00:00 2001
From: xuewei wang <xuewei.wang@nxp.com>
Date: Thu, 2 Mar 2023 15:43:25 +0800
Subject: [PATCH 06/11] Add support of RSA/EC mechanisms for sign/verify
 functions

Issue: ALB-9841
Upstream-Status: Pending

Signed-off-by: Xuewei Wang <xuewei.wang@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 examples/Makefile            |   4 +-
 examples/pkcs-sig/Makefile   |  16 +
 examples/pkcs-sig/pkcs-sig.c | 671 +++++++++++++++++++++++++++++++++++
 examples/pkcs-sig/readme.md  |  24 ++
 libpkcs/pkcs11.c             |  15 +-
 libpkcs/pkcs11_crypt.c       | 215 +++++++----
 libpkcs/pkcs11_util.c        |  65 +++-
 libpkcs/pkcs11_util.h        |   3 +
 8 files changed, 948 insertions(+), 65 deletions(-)
 create mode 100644 examples/pkcs-sig/Makefile
 create mode 100644 examples/pkcs-sig/pkcs-sig.c
 create mode 100644 examples/pkcs-sig/readme.md

diff --git a/examples/Makefile b/examples/Makefile
index 225d05f..6183117 100644
--- a/examples/Makefile
+++ b/examples/Makefile
@@ -2,8 +2,8 @@
 # Copyright 2021, 2023 NXP
 #
 
-examples := pkcs-keyop pkcs-key-provision hse-encrypt hse-sysimg hse-secboot trustzone-key-provision pkcs-cipher pkcs-msg-digest
-default_examples := pkcs-keyop pkcs-key-provision hse-encrypt hse-sysimg hse-secboot pkcs-cipher pkcs-msg-digest
+examples := pkcs-keyop pkcs-key-provision hse-encrypt hse-sysimg hse-secboot trustzone-key-provision pkcs-cipher pkcs-msg-digest pkcs-sig
+default_examples := pkcs-keyop pkcs-key-provision hse-encrypt hse-sysimg hse-secboot pkcs-cipher pkcs-msg-digest pkcs-sig
 clean_examples = $(addprefix clean_,$(default_examples))
 install_examples = $(addprefix install_,$(default_examples))
 
diff --git a/examples/pkcs-sig/Makefile b/examples/pkcs-sig/Makefile
new file mode 100644
index 0000000..8e5b290
--- /dev/null
+++ b/examples/pkcs-sig/Makefile
@@ -0,0 +1,16 @@
+#
+# Copyright 2023 NXP
+#
+
+include ../common.mk
+
+all: pkcs-sig
+
+pkcs-sig: pkcs-sig.c
+	$(CROSS_COMPILE)gcc $(LDFLAGS) $(INCLUDE_LIBPKCS) $(CFLAGS) $^ -o $@ $(LD_OPENSSL) -ldl
+
+clean:
+	rm -f pkcs-sig
+
+install:
+	install pkcs-sig $(EXAMPLES_INSTALLDIR)
\ No newline at end of file
diff --git a/examples/pkcs-sig/pkcs-sig.c b/examples/pkcs-sig/pkcs-sig.c
new file mode 100644
index 0000000..1d4d166
--- /dev/null
+++ b/examples/pkcs-sig/pkcs-sig.c
@@ -0,0 +1,671 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright 2023 NXP
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <dlfcn.h>
+#include <errno.h>
+#include <openssl/sha.h>
+#include "pkcs11.h"
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(array) (sizeof(array) / sizeof((array)[0]))
+#endif /* ARRAY_SIZE */
+
+#ifndef ERROR
+#define ERROR(fmt, ...) printf("[ERROR] " fmt, ##__VA_ARGS__)
+#endif
+
+#ifndef INFO
+#define INFO(fmt, ...) printf("[INFO] " fmt, ##__VA_ARGS__)
+#endif
+
+void usage(const char* progname)
+{
+	printf("\n%s - PKCS11 signature generate/verify example\n", progname);
+	printf("\n");
+	printf("\t%s /home/<user>/pkcs/libpkcs-hse.so\n", progname);
+	printf("\n");
+	printf("Usage:\n");
+	printf("%s help\n", progname);
+	printf("%s <lib>\n", progname);
+	printf("\n");
+	printf("\t<lib>         - full path to PKCS#11 shared library\n");
+	printf("\n");
+}
+
+static CK_FUNCTION_LIST_PTR util_lib_get_function_list(void *handle)
+{
+	CK_RV(*C_GetFunctionList)(CK_FUNCTION_LIST_PTR_PTR);
+	CK_FUNCTION_LIST_PTR function_list;
+	CK_RV rv;
+
+	/* first get the function symbol */
+	C_GetFunctionList = dlsym(handle, "C_GetFunctionList");
+	if (!C_GetFunctionList) 
+		return NULL;
+
+	rv = C_GetFunctionList(&function_list);
+	if (rv == CKR_OK)
+		return function_list;
+
+	return NULL;
+}
+
+static int util_lib_init(CK_FUNCTION_LIST_PTR flist)
+{
+	CK_RV rv;
+
+	rv = flist->C_Initialize(NULL);
+	if (rv != CKR_OK)
+		return -1;
+
+	return 0;
+}
+
+static CK_SLOT_ID util_lib_get_slot_list(CK_FUNCTION_LIST_PTR flist)
+{
+	CK_SLOT_ID_PTR slot_list;
+	CK_SLOT_ID slot_ret = -1;
+	CK_ULONG num_slots;
+	CK_RV rv;
+
+	rv = flist->C_GetSlotList(CK_TRUE, NULL, &num_slots);
+	if (rv != CKR_OK)
+		return -1;
+
+	slot_list = malloc(num_slots * sizeof(CK_SLOT_ID));
+	if (!slot_list)
+		return -1;
+
+	rv = flist->C_GetSlotList(CK_TRUE, slot_list, &num_slots);
+	if (rv != CKR_OK)
+		goto err_free_slot_list;
+
+	slot_ret = slot_list[0];
+
+err_free_slot_list:
+	free(slot_list);
+	return slot_ret;
+}
+
+static CK_SESSION_HANDLE util_lib_open_session(CK_FUNCTION_LIST_PTR flist, CK_SLOT_ID slot)
+{
+	CK_SESSION_HANDLE session;
+	CK_RV rv;
+
+	rv = flist->C_OpenSession(slot, CKF_SERIAL_SESSION | CKF_RW_SESSION, NULL, NULL, &session);
+	if (rv != CKR_OK)
+		return -1;
+
+	return session;
+}
+
+static CK_OBJECT_HANDLE install_ecc_private_key(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session)
+{
+	CK_OBJECT_HANDLE key = 0;
+	CK_RV rv;
+
+	/* define key template
+	 * 
+	 * key_id represent the HSE key slot in the key catalog
+	 *     - key_id[0] - slot ID
+	 *     - key_id[1] - group ID
+	 *     - key_id[2] - catalog ID
+	 */
+	CK_OBJECT_CLASS key_class = CKO_PRIVATE_KEY;
+	CK_KEY_TYPE key_type = CKK_EC;
+	CK_UTF8CHAR label[] = {"HSE-ECC-PRIV"};
+	CK_BYTE key_id[] = { 0x00, 0x03, 0x01};
+	CK_BYTE key_priv[] = {
+		0x54, 0x4d, 0x90, 0xd1, 0xbf, 0x45, 0x32, 0x9c, 0xd2, 0x39, 0x47, 0x06, 0x29, 0x3b, 0x4f, 0xc8, 
+		0x70, 0x28, 0xf7, 0xde, 0xac, 0x86, 0xb3, 0x91, 0xb6, 0x91, 0x93, 0xff, 0xe8, 0xe4, 0x2f, 0x68
+	};
+	/* DER-encoding of ANSI X9.62 ECPoint value */
+	CK_BYTE key_pub[] = {
+		0x42, 0x00, 0x04, 
+		0x5e, 0x90, 0x7e, 0xa9, 0x80, 0xf2, 0x04, 0xfb, 0x46, 0xb6, 0x82, 0x93, 0x0d, 0x6b, 0xb1, 0x72, 
+		0x9f, 0x31, 0x7a, 0x99, 0xc3, 0x4f, 0x39, 0xdc, 0x06, 0x74, 0xe4, 0x6c, 0x92, 0x54, 0x75, 0xf5, 
+		0x81, 0x74, 0x1d, 0x7d, 0x5c, 0x46, 0x7c, 0x03, 0xbb, 0xec, 0x49, 0xf0, 0x7a, 0x51, 0x7b, 0x0b, 
+		0x6b, 0xc1, 0x86, 0x86, 0x36, 0x3c, 0x89, 0x61, 0x29, 0xaa, 0x05, 0x8b, 0x4f, 0xea, 0x14, 0xdb
+	};
+	/* DER-encoding of an ANSI X9.62 Parameters value */
+	char *ec_param_oid = "\x06\x09\x2B\x24\x03\x03\x02\x08\x01\x01\x07";
+	CK_ATTRIBUTE keyTemplate[] = {
+		{ CKA_LABEL, label, sizeof(label)-1 },
+		{ CKA_CLASS, &key_class, sizeof(key_class) },
+		{ CKA_KEY_TYPE, &key_type, sizeof(key_type) },
+		{ CKA_ID, &key_id, sizeof(key_id) },
+		{CKA_EC_POINT, key_pub, sizeof(key_pub)},
+		{CKA_EC_PARAMS, (CK_BYTE_PTR)ec_param_oid, strlen(ec_param_oid)},
+		{ CKA_VALUE, key_priv, sizeof(key_priv)}
+	};
+
+	rv = flist->C_CreateObject(session, keyTemplate, ARRAY_SIZE(keyTemplate), &key);
+	if (rv != CKR_OK)
+		return -EKEYREJECTED;
+
+	return key;
+}
+
+static CK_OBJECT_HANDLE install_ecc_public_key(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session)
+{
+	CK_OBJECT_HANDLE key;
+	CK_RV rv;
+
+	/* define key template
+	 * 
+	 * key_id represent the HSE key slot in the key catalog
+	 *     - key_id[0] - slot ID
+	 *     - key_id[1] - group ID
+	 *     - key_id[2] - catalog ID
+	 */
+	CK_OBJECT_CLASS key_class = CKO_PUBLIC_KEY;
+	CK_KEY_TYPE key_type = CKK_EC;
+	CK_UTF8CHAR label[] = {"HSE-ECC-PUB"};
+	CK_BYTE key_id[] = { 0x00, 0x04, 0x01};
+	/* DER-encoding of ANSI X9.62 ECPoint value */
+	CK_BYTE key_pub[] = {
+		0x42, 0x00, 0x04, 
+		0x5e, 0x90, 0x7e, 0xa9, 0x80, 0xf2, 0x04, 0xfb, 0x46, 0xb6, 0x82, 0x93, 0x0d, 0x6b, 0xb1, 0x72, 
+		0x9f, 0x31, 0x7a, 0x99, 0xc3, 0x4f, 0x39, 0xdc, 0x06, 0x74, 0xe4, 0x6c, 0x92, 0x54, 0x75, 0xf5, 
+		0x81, 0x74, 0x1d, 0x7d, 0x5c, 0x46, 0x7c, 0x03, 0xbb, 0xec, 0x49, 0xf0, 0x7a, 0x51, 0x7b, 0x0b, 
+		0x6b, 0xc1, 0x86, 0x86, 0x36, 0x3c, 0x89, 0x61, 0x29, 0xaa, 0x05, 0x8b, 0x4f, 0xea, 0x14, 0xdb
+	};
+	/* DER-encoding of an ANSI X9.62 Parameters value */
+	char *ec_param_oid = "\x06\x09\x2B\x24\x03\x03\x02\x08\x01\x01\x07";
+	CK_ATTRIBUTE keyTemplate[] = {
+		{ CKA_LABEL, label, sizeof(label)-1 },
+		{ CKA_CLASS, &key_class, sizeof(key_class) },
+		{ CKA_KEY_TYPE, &key_type, sizeof(key_type) },
+		{ CKA_ID, &key_id, sizeof(key_id) },
+		{CKA_EC_POINT, key_pub, sizeof(key_pub)},
+		{CKA_EC_PARAMS, (CK_BYTE_PTR)ec_param_oid, strlen(ec_param_oid)}
+	};
+
+	rv = flist->C_CreateObject(session, keyTemplate, ARRAY_SIZE(keyTemplate), &key);
+	if (rv != CKR_OK)
+		return -EKEYREJECTED;
+
+	return key;
+}
+
+static CK_OBJECT_HANDLE util_lib_find_objects(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session, CK_OBJECT_CLASS class)
+{
+	CK_OBJECT_HANDLE aes_key = 0;
+	CK_ULONG num_keys;
+	CK_RV rv;
+	CK_OBJECT_CLASS key_class = class;
+	CK_ATTRIBUTE template[] = {
+		{ CKA_CLASS, &key_class, sizeof(key_class) },
+	};
+
+	rv = flist->C_FindObjectsInit(session, template, ARRAY_SIZE(template));
+	if (rv != CKR_OK)
+		return 0;
+
+	do {
+		rv = flist->C_FindObjects(session, &aes_key, 1, &num_keys);
+		/* no extra processing required, just return last key found */
+	} while (rv == CKR_OK && num_keys != 0);
+
+	rv = flist->C_FindObjectsFinal(session);
+	if (rv != CKR_OK)
+		return 0;
+
+	return aes_key;
+}
+
+static int util_lib_destroy_object(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session, CK_OBJECT_HANDLE key)
+{
+	CK_RV rv;
+
+	rv = flist->C_DestroyObject(session, key);
+	if (rv != CKR_OK)
+		return -1;
+
+	return 0;
+}
+
+static int util_lib_finalize(CK_FUNCTION_LIST_PTR flist)
+{
+	CK_RV rv;
+
+	rv = flist->C_Finalize(NULL);
+	if (rv != CKR_OK)
+		return -1;
+
+	return 0;
+}
+
+static int util_lib_rsa_sig(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session, CK_MECHANISM_PTR mechanism, CK_OBJECT_HANDLE priv_key, CK_OBJECT_HANDLE pub_key)
+{
+	CK_RV rv;
+	char *tobe_sign = "data to be sign";
+	CK_BYTE sig[256] = {0};
+	CK_ULONG sig_len = ARRAY_SIZE(sig);
+
+	INFO("\tGenerate signature ...\n");
+	rv = flist->C_SignInit(session, mechanism, priv_key);
+	if (rv != CKR_OK) {
+		ERROR("\tC_SignInit returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	rv = flist->C_Sign(session, (uint8_t *)tobe_sign, strlen(tobe_sign), sig, &sig_len);
+	if (rv != CKR_OK) {
+		ERROR("\tC_Sign returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	INFO("\tVerify signature ...\n");
+	rv = flist->C_VerifyInit(session, mechanism, pub_key);
+	if (rv != CKR_OK) {
+		ERROR("\tC_VerifyInit returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	rv = flist->C_Verify(session, (uint8_t *)tobe_sign, strlen(tobe_sign), sig, sig_len);
+	if (rv != CKR_OK) {
+		ERROR("\tC_Verify returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int util_lib_rsa_pre_hash_sig(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session, CK_MECHANISM_PTR mechanism, CK_OBJECT_HANDLE priv_key, CK_OBJECT_HANDLE pub_key)
+{
+	CK_RV rv;
+	char *tobe_sign = "data to be sign";
+	CK_BYTE sig[256] = {0};
+	CK_ULONG sig_len = ARRAY_SIZE(sig);
+	CK_BYTE digest_openssl[64];
+	CK_ULONG digest_length = 0;
+
+	/* calculate digest */
+	if (mechanism->mechanism == CKM_RSA_PKCS) {
+		SHA512((const uint8_t *)tobe_sign, strlen(tobe_sign), digest_openssl);
+		digest_length = 512 >> 3;
+	} else if (mechanism->mechanism == CKM_RSA_PKCS_PSS) {
+		switch (((CK_RSA_PKCS_PSS_PARAMS *)mechanism->pParameter)->hashAlg) {
+			case CKM_SHA_1:
+				SHA1((const uint8_t *)tobe_sign, strlen(tobe_sign), digest_openssl);
+				digest_length = 20;
+				break;
+			case CKM_SHA256:
+				SHA256((const uint8_t *)tobe_sign, strlen(tobe_sign), digest_openssl);
+				digest_length = 256 >> 3;
+				break;
+			case CKM_SHA384:
+				SHA384((const uint8_t *)tobe_sign, strlen(tobe_sign), digest_openssl);
+				digest_length = 384 >> 3;
+				break;
+			case CKM_SHA512:
+				SHA512((const uint8_t *)tobe_sign, strlen(tobe_sign), digest_openssl);
+				digest_length = 512 >> 3;
+				break;
+		}
+	}
+
+	INFO("\tGenerate signature ...\n");
+	rv = flist->C_SignInit(session, mechanism, priv_key);
+	if (rv != CKR_OK) {
+		ERROR("\tC_SignInit returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	rv = flist->C_Sign(session, digest_openssl, digest_length, sig, &sig_len);
+	if (rv != CKR_OK) {
+		ERROR("\tC_Sign returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	INFO("\tVerify signature ...\n");
+	rv = flist->C_VerifyInit(session, mechanism, pub_key);
+	if (rv != CKR_OK) {
+		ERROR("\tC_VerifyInit returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	rv = flist->C_Verify(session, digest_openssl, digest_length, sig, sig_len);
+	if (rv != CKR_OK) {
+		ERROR("\tC_Verify returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int util_lib_ec_sig(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session, CK_MECHANISM_PTR mechanism, CK_OBJECT_HANDLE priv_key, CK_OBJECT_HANDLE pub_key)
+{
+	CK_RV rv;
+	char *tobe_sign = "data to be sign";
+	CK_BYTE sig[64] = {0};
+	CK_ULONG sig_len = ARRAY_SIZE(sig);
+
+	INFO("\tGenerate signature ...\n");
+	rv = flist->C_SignInit(session, mechanism, priv_key);
+	if (rv != CKR_OK) {
+		ERROR("\tC_SignInit returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	rv = flist->C_Sign(session, (uint8_t *)tobe_sign, strlen(tobe_sign), sig, &sig_len);
+	if (rv != CKR_OK) {
+		ERROR("\tC_Sign returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	INFO("\tVerify signature ...\n");
+	rv = flist->C_VerifyInit(session, mechanism, pub_key);
+	if (rv != CKR_OK) {
+		ERROR("\tC_VerifyInit returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	rv = flist->C_Verify(session, (uint8_t *)tobe_sign, strlen(tobe_sign), sig, sig_len);
+	if (rv != CKR_OK) {
+		ERROR("\tC_Verify returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int util_lib_ec_pre_hash_sig(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session, CK_MECHANISM_PTR mechanism, CK_OBJECT_HANDLE priv_key, CK_OBJECT_HANDLE pub_key)
+{
+	CK_RV rv;
+	char *tobe_sign = "data to be sign";
+	CK_BYTE sig[256] = {0};
+	CK_ULONG sig_len = ARRAY_SIZE(sig);
+	CK_BYTE digest_openssl[64];
+	CK_ULONG digest_length = 0;
+	CK_MECHANISM_TYPE hash_alg[] = {CKM_SHA_1, CKM_SHA224, CKM_SHA384, CKM_SHA512};
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(hash_alg); i++) {
+
+		switch (hash_alg[i]) {
+			case CKM_SHA_1:
+				SHA1((const uint8_t *)tobe_sign, strlen(tobe_sign), digest_openssl);
+				digest_length = 20;
+				break;
+			case CKM_SHA224:
+				SHA224((const uint8_t *)tobe_sign, strlen(tobe_sign), digest_openssl);
+				digest_length = 224 >> 3;
+				break;
+			case CKM_SHA384:
+				SHA384((const uint8_t *)tobe_sign, strlen(tobe_sign), digest_openssl);
+				digest_length = 384 >> 3;
+				break;
+			case CKM_SHA512:
+				SHA512((const uint8_t *)tobe_sign, strlen(tobe_sign), digest_openssl);
+				digest_length = 512 >> 3;
+				break;
+		}
+
+		rv = flist->C_SignInit(session, mechanism, priv_key);
+		if (rv != CKR_OK) {
+			ERROR("\tC_SignInit returns error 0x%lx\n", rv);
+			return -1;
+		}
+
+		rv = flist->C_Sign(session, digest_openssl, digest_length, sig, &sig_len);
+		if (rv != CKR_OK) {
+			ERROR("\tC_Sign returns error 0x%lx\n", rv);
+			return -1;
+		}
+
+		rv = flist->C_VerifyInit(session, mechanism, pub_key);
+		if (rv != CKR_OK) {
+			ERROR("\tC_VerifyInit returns error 0x%lx\n", rv);
+			return -1;
+		}
+
+		rv = flist->C_Verify(session, digest_openssl, digest_length, sig, sig_len);
+		if (rv != CKR_OK) {
+			ERROR("\tC_Verify returns error 0x%lx\n", rv);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int ec_sig(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session, CK_OBJECT_HANDLE priv_key, CK_OBJECT_HANDLE pub_key)
+{
+	CK_MECHANISM mechanism;
+
+	INFO("CKM_ECDSA_SHA1 ...\n");
+	mechanism.mechanism = CKM_ECDSA_SHA1;
+	util_lib_ec_sig(flist, session, &mechanism, priv_key, pub_key);
+
+	INFO("CKM_ECDSA_SHA224 ...\n");
+	mechanism.mechanism = CKM_ECDSA_SHA224;
+	util_lib_ec_sig(flist, session, &mechanism, priv_key, pub_key);
+
+	INFO("CKM_ECDSA_SHA256 ...\n");
+	mechanism.mechanism = CKM_ECDSA_SHA256;
+	util_lib_ec_sig(flist, session, &mechanism, priv_key, pub_key);
+
+	INFO("CKM_ECDSA_SHA384 ...\n");
+	mechanism.mechanism = CKM_ECDSA_SHA384;
+	util_lib_ec_sig(flist, session, &mechanism, priv_key, pub_key);
+
+	INFO("CKM_ECDSA_SHA512 ...\n");
+	mechanism.mechanism = CKM_ECDSA_SHA512;
+	util_lib_ec_sig(flist, session, &mechanism, priv_key, pub_key);
+
+	INFO("CKM_ECDSA ...\n");
+	mechanism.mechanism = CKM_ECDSA;
+	util_lib_ec_pre_hash_sig(flist, session, &mechanism, priv_key, pub_key);
+
+	return 0;
+}
+
+static int rsa_sig(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session, CK_OBJECT_HANDLE priv_key, CK_OBJECT_HANDLE pub_key)
+{
+	CK_MECHANISM mechanism;
+	CK_RSA_PKCS_PSS_PARAMS param;
+
+	INFO("CKM_RSA_PKCS ...\n");
+	mechanism.mechanism = CKM_RSA_PKCS;
+	util_lib_rsa_pre_hash_sig(flist, session, &mechanism, priv_key, pub_key);
+
+	INFO("CKM_SHA1_RSA_PKCS ...\n");
+	mechanism.mechanism = CKM_SHA1_RSA_PKCS;
+	util_lib_rsa_sig(flist, session, &mechanism, priv_key, pub_key);
+
+	INFO("CKM_SHA256_RSA_PKCS ...\n");
+	mechanism.mechanism = CKM_SHA256_RSA_PKCS;
+	util_lib_rsa_sig(flist, session, &mechanism, priv_key, pub_key);
+
+	INFO("CKM_SHA256_RSA_PKCS ...\n");
+	mechanism.mechanism = CKM_SHA384_RSA_PKCS;
+	util_lib_rsa_sig(flist, session, &mechanism, priv_key, pub_key);
+
+	INFO("CKM_SHA512_RSA_PKCS ...\n");
+	mechanism.mechanism = CKM_SHA512_RSA_PKCS;
+	util_lib_rsa_sig(flist, session, &mechanism, priv_key, pub_key);
+
+	INFO("CKM_RSA_PKCS_PSS ...\n");
+	mechanism.mechanism = CKM_RSA_PKCS_PSS;
+	mechanism.pParameter = &param;
+	mechanism.ulParameterLen = sizeof(CK_RSA_PKCS_PSS_PARAMS);
+	param.hashAlg = CKM_SHA512;
+	param.sLen = 10;
+	util_lib_rsa_pre_hash_sig(flist, session, &mechanism, priv_key, pub_key);
+
+	INFO("CKM_SHA1_RSA_PKCS_PSS ...\n");
+	mechanism.mechanism = CKM_SHA1_RSA_PKCS_PSS;
+	mechanism.pParameter = &param;
+	mechanism.ulParameterLen = sizeof(CK_RSA_PKCS_PSS_PARAMS);
+	param.hashAlg = CKM_SHA_1;
+	param.sLen = 10;
+	util_lib_rsa_sig(flist, session, &mechanism, priv_key, pub_key);
+
+	INFO("CKM_SHA256_RSA_PKCS_PSS ...\n");
+	mechanism.mechanism = CKM_SHA256_RSA_PKCS_PSS;
+	mechanism.pParameter = &param;
+	mechanism.ulParameterLen = sizeof(CK_RSA_PKCS_PSS_PARAMS);
+	param.hashAlg = CKM_SHA256;
+	param.sLen = 10;
+	util_lib_rsa_sig(flist, session, &mechanism, priv_key, pub_key);
+
+	INFO("CKM_SHA384_RSA_PKCS_PSS ...\n");
+	mechanism.mechanism = CKM_SHA384_RSA_PKCS_PSS;
+	mechanism.pParameter = &param;
+	mechanism.ulParameterLen = sizeof(CK_RSA_PKCS_PSS_PARAMS);
+	param.hashAlg = CKM_SHA384;
+	param.sLen = 10;
+	util_lib_rsa_sig(flist, session, &mechanism, priv_key, pub_key);
+
+	INFO("CKM_SHA512_RSA_PKCS_PSS ...\n");
+	mechanism.mechanism = CKM_SHA512_RSA_PKCS_PSS;
+	mechanism.pParameter = &param;
+	mechanism.ulParameterLen = sizeof(CK_RSA_PKCS_PSS_PARAMS);
+	param.hashAlg = CKM_SHA512;
+	param.sLen = 10;
+	util_lib_rsa_sig(flist, session, &mechanism, priv_key, pub_key);
+
+	return 0;
+}
+
+int main(int argc, char *argv[])
+{
+	void *lib_handle;
+	char *libpath, *arg_help = "help";
+	int ret = 0;
+
+	CK_FUNCTION_LIST_PTR flist;
+	
+	CK_SLOT_ID slot;
+	CK_SESSION_HANDLE session;
+	CK_OBJECT_HANDLE rsa_pub_key, rsa_priv_key, ec_pub_key, ec_priv_key;
+
+	if (argc == 2 && !strncmp(argv[1], arg_help, sizeof(*arg_help))) {
+		usage(argv[0]);
+		return 0;
+	}
+
+	if (argc != 2) {
+		ERROR("Incorrect number of arguments\n");
+		usage(argv[0]);
+		return -EINVAL;
+	}
+
+	libpath = argv[1];
+
+	INFO("Loading %s shared library...\n", libpath);
+
+	lib_handle = dlopen(libpath, RTLD_LAZY);
+	if (!lib_handle) {
+		ERROR("Could not find PKCS#11 shared library %s - %s\n", libpath, dlerror());
+		return -ELIBACC;
+	}
+
+	INFO("Retrieving function list from %s...\n", libpath);
+
+	flist = util_lib_get_function_list(lib_handle);
+	if (!flist) {
+		ERROR("Failed to find C_GetFunctionList in shared library - %s", dlerror());
+		ret = -ENOSYS;
+		goto err_close_lib;
+	}
+
+	INFO("Calling C_Initialize...\n");
+
+	ret = util_lib_init(flist);
+	if (ret) {
+		ERROR("Failed call to C_Initialize\n");
+		goto err_close_lib;
+	}
+
+	INFO("Getting Slot ID...\n");
+
+	slot = util_lib_get_slot_list(flist);
+	if (slot < 0) {
+		ERROR("Failed to retrieve slot ID\n");
+		ret = -1;
+		goto err_lib_finalize;
+	}
+
+	INFO("Opening session on slot #%ld...\n", slot);
+
+	session = util_lib_open_session(flist, slot);
+	if (session < 0) {
+		ERROR("Failed to open session\n");
+		ret = -1;
+		goto err_lib_finalize;
+	}
+
+	INFO("RSA Signature operations...\n");
+	/* Find RSA keys 
+	 * We assume the RSA private & public keys are already installed.
+	 * You can do that using pkcs11-tool from OpenSC */
+	rsa_pub_key = util_lib_find_objects(flist, session, CKO_PUBLIC_KEY);
+	if (!rsa_pub_key) {
+		ERROR("Failed to find key object with Class CKO_PUBLIC_KEY\n");
+		ret = -ENOKEY;
+		goto err_lib_finalize;
+	}
+
+	INFO("Found Key Object with handle %06lx\n", rsa_pub_key);
+
+	rsa_priv_key = util_lib_find_objects(flist, session, CKO_PRIVATE_KEY);
+	if (!rsa_priv_key) {
+		ERROR("Failed to find key object with Class CKO_PRIVATE_KEY\n");
+		ret = -ENOKEY;
+		goto err_lib_finalize;
+	}
+
+	INFO("Found Key Object with handle %06lx\n", rsa_priv_key);
+
+	rsa_sig(flist, session, rsa_priv_key, rsa_pub_key);
+
+	/* Install ECC Private/Public keys */
+	INFO("Install ECC private key ...\n");
+	ec_priv_key = install_ecc_private_key(flist, session);
+	INFO("Created Key Object with handle %06lx\n", ec_priv_key);
+
+	INFO("Install ECC public key ...\n");
+	ec_pub_key = install_ecc_public_key(flist, session);
+	INFO("Created Key Object with handle %06lx\n", ec_pub_key);
+
+	ec_sig(flist, session, ec_priv_key, ec_pub_key);
+
+	/* ECC signature */
+	INFO("Deleting Key Objects ...\n");
+
+	if (ec_priv_key != (CK_OBJECT_HANDLE)(-EKEYREJECTED)) {
+		ret = util_lib_destroy_object(flist, session, ec_priv_key);
+		if (ret) {
+			ERROR("Failed to destroy key object\n");
+			goto err_lib_finalize;
+		}
+	}
+
+	if (ec_pub_key != (CK_OBJECT_HANDLE)(-EKEYREJECTED)) {
+		ret = util_lib_destroy_object(flist, session, ec_pub_key);
+		if (ret) {
+			ERROR("Failed to destroy key object\n");
+			goto err_lib_finalize;
+		}
+	}
+
+	INFO("Cleaning up and calling C_Finalize...\n");
+
+err_lib_finalize:	
+	if (util_lib_finalize(flist))
+		ERROR("Failed call to C_Finalize\n");
+err_close_lib:
+	if (dlclose(lib_handle))
+		ERROR("Failed to close shared library %s - %s\n", libpath, dlerror());
+
+	return ret;
+}
diff --git a/examples/pkcs-sig/readme.md b/examples/pkcs-sig/readme.md
new file mode 100644
index 0000000..98da483
--- /dev/null
+++ b/examples/pkcs-sig/readme.md
@@ -0,0 +1,24 @@
+This example assumes the RSA private key and public key were installed beforehand.
+Please take the below steps as referance:
+
+1. Format HSE key catalogs using the `hse-secboot` example
+
+    hse-secboot -f -o -d /dev/mmcblk0
+
+    Note: `-o` is required if the HSE SYS_IMG exist.
+
+2. Remove the objects file after re-formating HSE key catalogs
+
+    rm /etc/pkcs-hse-objs
+
+    Note: This keeps the objects file consistent with HSE key catalog
+
+3. Import RSA private and public keys using pkcs11-tool from OpenSC.
+
+    pkcs11-tool --module /usr/lib/libpkcs-hse.so --write-object rsa_priv.pem --type privkey --id 000601 --label "HSE-RSAPRIV-KEY"
+
+    pkcs11-tool --module /usr/lib/libpkcs-hse.so --write-object rsa_pub.pem --type pubkey --id 000701 --label "HSE-RSAPUB-KEY"
+
+4. Run the pkcs-cipher
+
+    pkcs-sig /usr/lib/libpkcs-hse.so
\ No newline at end of file
diff --git a/libpkcs/pkcs11.c b/libpkcs/pkcs11.c
index e4815af..6218e41 100644
--- a/libpkcs/pkcs11.c
+++ b/libpkcs/pkcs11.c
@@ -26,8 +26,21 @@ static const CK_MECHANISM_TYPE mechanismList[] = {
 	CKM_AES_CTR,
 	CKM_RSA_PKCS,
 	CKM_RSA_PKCS_OAEP,
+	CKM_SHA1_RSA_PKCS,
 	CKM_SHA256_RSA_PKCS,
+	CKM_SHA384_RSA_PKCS,
+	CKM_SHA512_RSA_PKCS,
+	CKM_RSA_PKCS_PSS,
+	CKM_SHA1_RSA_PKCS_PSS,
+	CKM_SHA256_RSA_PKCS_PSS,
+	CKM_SHA384_RSA_PKCS_PSS,
+	CKM_SHA512_RSA_PKCS_PSS,
+	CKM_ECDSA,
 	CKM_ECDSA_SHA1,
+	CKM_ECDSA_SHA224,
+	CKM_ECDSA_SHA256,
+	CKM_ECDSA_SHA384,
+	CKM_ECDSA_SHA512,
 	CKM_SHA_1, CKM_SHA224, CKM_SHA256, CKM_SHA512, CKM_SHA512_224, CKM_SHA512_256
 };
 
@@ -76,7 +89,7 @@ static CK_FUNCTION_LIST gFunctionList = {
 };
 
 /*
- * PKCS11 standard: char buffers MUST be padded with the blank character (‘ ‘).
+ * PKCS11 standard: char buffers MUST be padded with the blank character (' ').
  * MUST NOT be null-terminated.
  */
 static void strcpy_pkcs11_padding(unsigned char *dest, const char *source, size_t dest_len)
diff --git a/libpkcs/pkcs11_crypt.c b/libpkcs/pkcs11_crypt.c
index 3052a72..0c40f87 100644
--- a/libpkcs/pkcs11_crypt.c
+++ b/libpkcs/pkcs11_crypt.c
@@ -278,7 +278,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Encrypt)(
 			rsa_cipher_srv->pOutput = hse_virt_to_dma(output);
 
 			rsa_cipher_srv->rsaScheme.rsaAlgo = HSE_RSA_ALGO_RSAES_OAEP;
-			rsa_cipher_srv->rsaScheme.sch.rsaOAEP.hashAlgo = hse_get_hash_alg(oaep_params->hashAlg);
+			rsa_cipher_srv->rsaScheme.sch.rsaOAEP.hashAlgo = hse_pkcs_hash_alg_translate(oaep_params->hashAlg);
 			rsa_cipher_srv->rsaScheme.sch.rsaOAEP.labelLength = 0;
 			rsa_cipher_srv->rsaScheme.sch.rsaOAEP.pLabel = 0;
 			break;
@@ -575,7 +575,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Decrypt)(
 			rsa_cipher_srv->pOutput = hse_virt_to_dma(output);
 
 			rsa_cipher_srv->rsaScheme.rsaAlgo = HSE_RSA_ALGO_RSAES_OAEP;
-			rsa_cipher_srv->rsaScheme.sch.rsaOAEP.hashAlgo = hse_get_hash_alg(oaep_params->hashAlg);
+			rsa_cipher_srv->rsaScheme.sch.rsaOAEP.hashAlgo = hse_pkcs_hash_alg_translate(oaep_params->hashAlg);
 			rsa_cipher_srv->rsaScheme.sch.rsaOAEP.labelLength = 0;
 			rsa_cipher_srv->rsaScheme.sch.rsaOAEP.pLabel = 0;
 			break;
@@ -668,6 +668,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Sign)(
 	struct hse_keyObject *key;
 	CK_RV rc = CKR_OK;
 	int err;
+	CK_RSA_PKCS_PSS_PARAMS *rsa_pss_param;
 
 	if (gCtx->cryptokiInit == CK_FALSE)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
@@ -691,6 +692,8 @@ CK_DEFINE_FUNCTION(CK_RV, C_Sign)(
 		return CKR_OPERATION_NOT_INITIALIZED;
 
 	key = (struct hse_keyObject *)list_seek(&gCtx->object_list, &gCtx->signCtx.keyHandle);
+	if (key == NULL) 
+		return CKR_KEY_HANDLE_INVALID;
 
 	input = hse_mem_alloc(ulDataLen);
 	if (input == NULL)
@@ -702,66 +705,105 @@ CK_DEFINE_FUNCTION(CK_RV, C_Sign)(
 		rc = CKR_HOST_MEMORY;
 		goto err_free_input;
 	}
+
+	/* check the output length */
+	*(uint32_t *)output_len = sig_get_out_length(key, gCtx->signCtx.mechanism);
+	if (*(uint32_t *)output_len > *pulSignatureLen) {
+		*pulSignatureLen = *(uint32_t *)output_len;
+		rc = CKR_BUFFER_TOO_SMALL;
+		goto err_free_output_len;
+	}
 	hse_memcpy(output_len, pulSignatureLen, sizeof(uint32_t));
 
+	sign0 = hse_mem_alloc(*(uint32_t *)output_len);
+	if (sign0 == NULL) {
+		rc = CKR_HOST_MEMORY;
+		goto err_free_output_len;
+	}
+
 	sign_srv = &srv_desc.hseSrv.signReq;
 	sign_scheme = &sign_srv->signScheme;
 
 	switch (gCtx->signCtx.mechanism->mechanism) {
+		case CKM_RSA_PKCS:
+		case CKM_SHA1_RSA_PKCS:
 		case CKM_SHA256_RSA_PKCS:
+		case CKM_SHA384_RSA_PKCS:
+		case CKM_SHA512_RSA_PKCS:
+			sign_scheme->signSch = HSE_SIGN_RSASSA_PKCS1_V15;
+			sign_scheme->sch.rsaPkcs1v15.hashAlgo = hse_get_hash_alg(gCtx->signCtx.mechanism->mechanism);
+			sign_srv->pSignatureLength[0] = hse_virt_to_dma(output_len);
+			sign_srv->pSignatureLength[1] = 0u;
+			sign_srv->pSignature[0] = hse_virt_to_dma(sign0);
+			sign_srv->pSignature[1] = 0u;
+			if (CKM_RSA_PKCS == gCtx->signCtx.mechanism->mechanism) {
+				sign_srv->bInputIsHashed = 1u;
+				/* The hashing algorithm must still be provided as it is included in the signature for various schemes
+				 * But there is no input parameter for CKM_RSA_PKCS. Use the hardcode value (SHA512).  */
+				sign_scheme->sch.rsaPkcs1v15.hashAlgo = HSE_HASH_ALGO_SHA2_512;
+			} else
+				sign_srv->bInputIsHashed = 0u;
 
-			sign0 = hse_mem_alloc(*(uint32_t *)output_len);
-			if (sign0 == NULL) {
-				rc = CKR_HOST_MEMORY;
-				goto err_free_output_len;
+			break;
+		case CKM_RSA_PKCS_PSS:
+		case CKM_SHA1_RSA_PKCS_PSS:
+		case CKM_SHA256_RSA_PKCS_PSS:
+		case CKM_SHA384_RSA_PKCS_PSS:
+		case CKM_SHA512_RSA_PKCS_PSS:
+			rsa_pss_param = (CK_RSA_PKCS_PSS_PARAMS *)gCtx->signCtx.mechanism->pParameter;
+			if (rsa_pss_param == NULL) {
+				rc = CKR_ARGUMENTS_BAD;
+				goto err_free_sign0;
 			}
 
-			sign_scheme->signSch = HSE_SIGN_RSASSA_PKCS1_V15;
-			sign_scheme->sch.rsaPkcs1v15.hashAlgo = HSE_HASH_ALGO_SHA2_256;
-
+			sign_scheme->signSch = HSE_SIGN_RSASSA_PSS;
+			sign_scheme->sch.rsaPss.hashAlgo = hse_pkcs_hash_alg_translate(rsa_pss_param->hashAlg);
+			sign_scheme->sch.rsaPss.saltLength = rsa_pss_param->sLen;
 			sign_srv->pSignatureLength[0] = hse_virt_to_dma(output_len);
 			sign_srv->pSignatureLength[1] = 0u;
-			sign_srv->pSignature[0] = hse_virt_to_dma(sign0); /* rsa */
+			sign_srv->pSignature[0] = hse_virt_to_dma(sign0);
 			sign_srv->pSignature[1] = 0u;
 
+			if (CKM_RSA_PKCS_PSS == gCtx->signCtx.mechanism->mechanism)
+				sign_srv->bInputIsHashed = 1u;
+			else
+				sign_srv->bInputIsHashed = 0u;
+
 			break;
+		case CKM_ECDSA:
 		case CKM_ECDSA_SHA1:
-
+		case CKM_ECDSA_SHA224:
+		case CKM_ECDSA_SHA256:
+		case CKM_ECDSA_SHA384:
+		case CKM_ECDSA_SHA512:
 			/* we only get one output length, which has to hold (r,s)
 			 * (r,s) are both the length of the used curve in bytes - equal
 			 * as such, assume it is doubled, and halve it */
 			*(uint32_t *)output_len = *(uint32_t *)output_len / 2;
-
-			sign0 = hse_mem_alloc(*(uint32_t *)output_len);
-			if (sign0 == NULL) {
-				rc = CKR_HOST_MEMORY;
-				goto err_free_output_len;
-			}
-			sign1 = hse_mem_alloc(*(uint32_t *)output_len);
-			if (sign1 == NULL) {
-				rc = CKR_HOST_MEMORY;
-				goto err_free_sign0;
-			}
+			sign1 = (uint8_t *)sign0 + (*(uint32_t *)output_len);
 
 			sign_scheme->signSch = HSE_SIGN_ECDSA;
-			sign_scheme->sch.ecdsa.hashAlgo = HSE_HASH_ALGO_SHA_1;
-
+			sign_scheme->sch.ecdsa.hashAlgo = hse_get_hash_alg(gCtx->signCtx.mechanism->mechanism);
 			sign_srv->pSignatureLength[0] = hse_virt_to_dma(output_len);
 			sign_srv->pSignatureLength[1] = hse_virt_to_dma(output_len);
 			sign_srv->pSignature[0] = hse_virt_to_dma(sign0);
 			sign_srv->pSignature[1] = hse_virt_to_dma(sign1);
 
+			if (CKM_ECDSA == gCtx->signCtx.mechanism->mechanism)
+				sign_srv->bInputIsHashed = 1u;
+			else
+				sign_srv->bInputIsHashed = 0u;
+
 			break;
 		default:
 			rc = CKR_ARGUMENTS_BAD;
-			goto err_free_output_len;
+			goto err_free_sign0;
 	}
 
 	srv_desc.srvId = HSE_SRV_ID_SIGN;
 	sign_srv->accessMode = HSE_ACCESS_MODE_ONE_PASS;
 	sign_srv->streamId = 0u;
 	sign_srv->authDir = HSE_AUTH_DIR_GENERATE;
-	sign_srv->bInputIsHashed = 0u;
 	sign_srv->keyHandle = key->key_handle;
 	sign_srv->sgtOption = HSE_SGT_OPTION_NONE;
 	sign_srv->inputLength = ulDataLen;
@@ -770,17 +812,31 @@ CK_DEFINE_FUNCTION(CK_RV, C_Sign)(
 	err = hse_srv_req_sync(HSE_CHANNEL_ANY, &srv_desc, sizeof(srv_desc));
 	if (err) {
 		rc = CKR_FUNCTION_FAILED;
-		goto err_free_sign1;
+		goto err_free_sign0;
 	}
 
 	switch (gCtx->signCtx.mechanism->mechanism) {
+		case CKM_RSA_PKCS:
+		case CKM_SHA1_RSA_PKCS:
 		case CKM_SHA256_RSA_PKCS:
+		case CKM_SHA384_RSA_PKCS:
+		case CKM_SHA512_RSA_PKCS:
+		case CKM_RSA_PKCS_PSS:
+		case CKM_SHA1_RSA_PKCS_PSS:
+		case CKM_SHA256_RSA_PKCS_PSS:
+		case CKM_SHA384_RSA_PKCS_PSS:
+		case CKM_SHA512_RSA_PKCS_PSS:
 
 			hse_memcpy(pSignature, sign0, *(uint32_t *)output_len);
 			hse_memcpy(pulSignatureLen, output_len, sizeof(uint32_t));
 
 			break;
+		case CKM_ECDSA:
 		case CKM_ECDSA_SHA1:
+		case CKM_ECDSA_SHA224:
+		case CKM_ECDSA_SHA256:
+		case CKM_ECDSA_SHA384:
+		case CKM_ECDSA_SHA512:
 
 			hse_memcpy(pSignature, sign0, *(uint32_t *)output_len);
 			hse_memcpy(pSignature + *(uint32_t *)output_len, sign1, *(uint32_t *)output_len);
@@ -792,17 +848,18 @@ CK_DEFINE_FUNCTION(CK_RV, C_Sign)(
 			break;
 		default:
 			rc = CKR_ARGUMENTS_BAD;
-			goto err_free_sign1;
+			goto err_free_sign0;
 	}
 
-err_free_sign1:
-	hse_mem_free(sign1);
 err_free_sign0:
 	hse_mem_free(sign0);
 err_free_output_len:
 	hse_mem_free(output_len);
 err_free_input:
 	hse_mem_free(input);
+
+	gCtx->signCtx.init = CK_FALSE;
+
 	return rc;
 }
 
@@ -852,6 +909,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Verify)(
 	struct hse_keyObject *key;
 	CK_RV rc = CKR_OK;
 	int err;
+	CK_RSA_PKCS_PSS_PARAMS *rsa_pss_param;
 
 	if (gCtx->cryptokiInit == CK_FALSE)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
@@ -875,6 +933,8 @@ CK_DEFINE_FUNCTION(CK_RV, C_Verify)(
 		return CKR_OPERATION_NOT_INITIALIZED;
 
 	key = (struct hse_keyObject *)list_seek(&gCtx->object_list, &gCtx->signCtx.keyHandle);
+	if (key == NULL) 
+		return CKR_KEY_HANDLE_INVALID;
 
 	input = hse_mem_alloc(ulDataLen);
 	if (input == NULL)
@@ -888,88 +948,121 @@ CK_DEFINE_FUNCTION(CK_RV, C_Verify)(
 	}
 	hse_memcpy(output_len, &ulSignatureLen, sizeof(uint32_t));
 
+	sign0 = hse_mem_alloc(ulSignatureLen);
+	if (sign0 == NULL) {
+		rc = CKR_HOST_MEMORY;
+		goto err_free_output_len;
+	}
+	hse_memcpy(sign0, pSignature, ulSignatureLen);
+
 	sign_srv = &srv_desc.hseSrv.signReq;
 	sign_scheme = &sign_srv->signScheme;
 
 	switch (gCtx->signCtx.mechanism->mechanism) {
+		case CKM_RSA_PKCS:
+		case CKM_SHA1_RSA_PKCS:
 		case CKM_SHA256_RSA_PKCS:
+		case CKM_SHA384_RSA_PKCS:
+		case CKM_SHA512_RSA_PKCS:
+			sign_scheme->signSch = HSE_SIGN_RSASSA_PKCS1_V15;
+			sign_scheme->sch.rsaPkcs1v15.hashAlgo = hse_get_hash_alg(gCtx->signCtx.mechanism->mechanism);
+			sign_srv->pSignatureLength[0] = hse_virt_to_dma(output_len);
+			sign_srv->pSignatureLength[1] = 0u;
+			sign_srv->pSignature[0] = hse_virt_to_dma(sign0); /* rsa */
+			sign_srv->pSignature[1] = 0u;
 
-			sign0 = hse_mem_alloc(ulSignatureLen);
-			if (sign0 == NULL) {
-				rc = CKR_HOST_MEMORY;
-				goto err_free_output_len;
-			}
-			hse_memcpy(sign0, pSignature, ulSignatureLen);
+			if (CKM_RSA_PKCS == gCtx->signCtx.mechanism->mechanism) {
+				sign_srv->bInputIsHashed = 1u;
+				/* The hashing algorithm must still be provided as it is included in the signature for various schemes
+				 * But there is no input parameter for CKM_RSA_PKCS. Use the hardcode value (SHA512).  */
+				sign_scheme->sch.rsaPkcs1v15.hashAlgo = HSE_HASH_ALGO_SHA2_512;
+			} else
+				sign_srv->bInputIsHashed = 0u;
 
-			sign_scheme->signSch = HSE_SIGN_RSASSA_PKCS1_V15;
-			sign_scheme->sch.rsaPkcs1v15.hashAlgo = HSE_HASH_ALGO_SHA2_256;
+			break;
+		case CKM_RSA_PKCS_PSS:
+		case CKM_SHA1_RSA_PKCS_PSS:
+		case CKM_SHA256_RSA_PKCS_PSS:
+		case CKM_SHA384_RSA_PKCS_PSS:
+		case CKM_SHA512_RSA_PKCS_PSS:
+			rsa_pss_param = (CK_RSA_PKCS_PSS_PARAMS *)gCtx->signCtx.mechanism->pParameter;
+			if (rsa_pss_param == NULL) {
+				rc = CKR_ARGUMENTS_BAD;
+				goto err_free_sign0;
+			}
 
+			sign_scheme->signSch = HSE_SIGN_RSASSA_PSS;
+			sign_scheme->sch.rsaPss.hashAlgo = hse_pkcs_hash_alg_translate(rsa_pss_param->hashAlg);
+			sign_scheme->sch.rsaPss.saltLength = rsa_pss_param->sLen;
 			sign_srv->pSignatureLength[0] = hse_virt_to_dma(output_len);
 			sign_srv->pSignatureLength[1] = 0u;
-			sign_srv->pSignature[0] = hse_virt_to_dma(sign0); /* rsa */
+			sign_srv->pSignature[0] = hse_virt_to_dma(sign0);
 			sign_srv->pSignature[1] = 0u;
 
+			if (CKM_RSA_PKCS_PSS == gCtx->signCtx.mechanism->mechanism)
+				sign_srv->bInputIsHashed = 1u;
+			else
+				sign_srv->bInputIsHashed = 0u;
+
 			break;
+		case CKM_ECDSA:
 		case CKM_ECDSA_SHA1:
-
+		case CKM_ECDSA_SHA224:
+		case CKM_ECDSA_SHA256:
+		case CKM_ECDSA_SHA384:
+		case CKM_ECDSA_SHA512:
 			/* we only get one signature input and length
 			 * (r,s) are the same length
 			 * assume the signature contains both, one after the other */
 			*(uint32_t *)output_len = *(uint32_t *)output_len / 2;
-
-			sign0 = hse_mem_alloc(*(uint32_t *)output_len);
-			if (sign0 == NULL) {
-				rc = CKR_HOST_MEMORY;
-				goto err_free_output_len;
-			}
-			sign1 = hse_mem_alloc(*(uint32_t *)output_len);
-			if (sign1 == NULL) {
-				rc = CKR_HOST_MEMORY;
-				goto err_free_sign0;
-			}
-			hse_memcpy(sign0, pSignature, *(uint32_t *)output_len);
-			hse_memcpy(sign1, pSignature + *(uint32_t *)output_len, *(uint32_t *)output_len);
+			sign1 = (uint8_t *)sign0 + (*(uint32_t *)output_len);
 
 			sign_scheme->signSch = HSE_SIGN_ECDSA;
-			sign_scheme->sch.ecdsa.hashAlgo = HSE_HASH_ALGO_SHA_1;
+			sign_scheme->sch.ecdsa.hashAlgo = hse_get_hash_alg(gCtx->signCtx.mechanism->mechanism);
 
 			sign_srv->pSignatureLength[0] = hse_virt_to_dma(output_len);
 			sign_srv->pSignatureLength[1] = hse_virt_to_dma(output_len);
 			sign_srv->pSignature[0] = hse_virt_to_dma(sign0);
 			sign_srv->pSignature[1] = hse_virt_to_dma(sign1);
 
+			if (CKM_ECDSA == gCtx->signCtx.mechanism->mechanism)
+				sign_srv->bInputIsHashed = 1u;
+			else
+				sign_srv->bInputIsHashed = 0u;
+
+			break;
 		default:
 			rc = CKR_ARGUMENTS_BAD;
-			goto err_free_output_len;
+			goto err_free_sign0;
 	}
 
 	srv_desc.srvId = HSE_SRV_ID_SIGN;
 	sign_srv->accessMode = HSE_ACCESS_MODE_ONE_PASS;
 	sign_srv->streamId = 0u;
 	sign_srv->authDir = HSE_AUTH_DIR_VERIFY;
-	sign_srv->bInputIsHashed = 0u;
 	sign_srv->keyHandle = key->key_handle;
 	sign_srv->sgtOption = HSE_SGT_OPTION_NONE;
 	sign_srv->inputLength = ulDataLen;
 	sign_srv->pInput = hse_virt_to_dma(input);
 
 	err = hse_srv_req_sync(HSE_CHANNEL_ANY, &srv_desc, sizeof(srv_desc));
-	if (err == EBADMSG) {
+	if (!err) {
+		rc = CKR_OK;
+	} else if (err == EBADMSG) {
 		rc = CKR_SIGNATURE_INVALID;
-		goto err_free_sign1;
 	} else {
 		rc = CKR_FUNCTION_FAILED;
-		goto err_free_sign1;
 	}
 
-err_free_sign1:
-	hse_mem_free(sign1);
 err_free_sign0:
 	hse_mem_free(sign0);
 err_free_output_len:
 	hse_mem_free(output_len);
 err_free_input:
 	hse_mem_free(input);
+
+	gCtx->signCtx.init = CK_FALSE;
+
 	return rc;
 }
 
diff --git a/libpkcs/pkcs11_util.c b/libpkcs/pkcs11_util.c
index 22551ae..f824a39 100644
--- a/libpkcs/pkcs11_util.c
+++ b/libpkcs/pkcs11_util.c
@@ -109,7 +109,7 @@ uint32_t rsa_ciphering_get_out_length(uint16_t rsa_key_length_bit)
 	return rsa_key_length_bit >> 3;
 }
 
-hseHashAlgo_t hse_get_hash_alg(CK_MECHANISM_TYPE mechanism)
+hseHashAlgo_t hse_pkcs_hash_alg_translate(CK_MECHANISM_TYPE mechanism)
 {
 	hseHashAlgo_t hash = HSE_HASH_ALGO_NULL;
 
@@ -148,3 +148,66 @@ hseHashAlgo_t hse_get_hash_alg(CK_MECHANISM_TYPE mechanism)
 	return hash;
 }
 
+hseHashAlgo_t hse_get_hash_alg(CK_MECHANISM_TYPE mechanism)
+{
+	hseHashAlgo_t hash = HSE_HASH_ALGO_NULL;
+
+	switch (mechanism) {
+		case CKM_SHA1_RSA_PKCS:
+		case CKM_ECDSA_SHA1:
+			hash = HSE_HASH_ALGO_SHA_1;
+			break;
+		case CKM_ECDSA_SHA224:
+			hash = HSE_HASH_ALGO_SHA2_224;
+			break;
+		case CKM_SHA256_RSA_PKCS:
+		case CKM_SHA256_RSA_PKCS_PSS:
+		case CKM_ECDSA_SHA256:
+			hash = HSE_HASH_ALGO_SHA2_256;
+			break;
+		case CKM_SHA384_RSA_PKCS:
+		case CKM_SHA384_RSA_PKCS_PSS:
+		case CKM_ECDSA_SHA384:
+			hash = HSE_HASH_ALGO_SHA2_384;
+			break;
+		case CKM_SHA512_RSA_PKCS:
+		case CKM_SHA512_RSA_PKCS_PSS:
+		case CKM_ECDSA_SHA512:
+			hash = HSE_HASH_ALGO_SHA2_512;
+			break;
+		default:
+			break;
+	}
+
+	return hash;
+}
+
+uint32_t sig_get_out_length(struct hse_keyObject *key, CK_MECHANISM_PTR mechanism)
+{
+	CK_MECHANISM_TYPE mechanism_type = mechanism->mechanism;
+	uint32_t sig_len = 0;
+
+	switch (mechanism_type) {
+		case CKM_RSA_PKCS_OAEP:
+		case CKM_SHA256_RSA_PKCS:
+		case CKM_SHA384_RSA_PKCS:
+		case CKM_SHA512_RSA_PKCS:
+		case CKM_RSA_PKCS_PSS:
+		case CKM_SHA256_RSA_PKCS_PSS:
+		case CKM_SHA384_RSA_PKCS_PSS:
+		case CKM_SHA512_RSA_PKCS_PSS:
+			sig_len = hse_get_key_bit_length(key) >> 3;
+			break;
+		case CKM_ECDSA:
+		case CKM_ECDSA_SHA1:
+		case CKM_ECDSA_SHA224:
+		case CKM_ECDSA_SHA384:
+		case CKM_ECDSA_SHA512:
+			sig_len = (hse_get_key_bit_length(key) >> 3) * 2;
+			break;
+		default:
+			return 0;
+	}
+
+	return sig_len;
+}
diff --git a/libpkcs/pkcs11_util.h b/libpkcs/pkcs11_util.h
index 20db230..7062fb9 100644
--- a/libpkcs/pkcs11_util.h
+++ b/libpkcs/pkcs11_util.h
@@ -8,9 +8,12 @@
 
 uint16_t hse_get_key_bit_length(struct hse_keyObject *key);
 
+hseHashAlgo_t hse_pkcs_hash_alg_translate(CK_MECHANISM_TYPE mechanism);
 hseHashAlgo_t hse_get_hash_alg(CK_MECHANISM_TYPE mechanism);
 
 uint32_t rsa_ciphering_get_max_input_length(uint16_t rsa_key_length_bit, CK_MECHANISM_PTR mechanism);
 uint32_t rsa_ciphering_get_out_length(uint16_t rsa_key_length_bit);
 
+uint32_t sig_get_out_length(struct hse_keyObject *key, CK_MECHANISM_PTR mechanism);
+
 #endif
-- 
2.25.1

