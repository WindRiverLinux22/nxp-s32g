From c774373ea7e2a27a8c6d74a0245ce2f586b8d35d Mon Sep 17 00:00:00 2001
From: xuewei wang <xuewei.wang@nxp.com>
Date: Mon, 20 Mar 2023 17:00:00 +0800
Subject: [PATCH 07/11] Add support of CMAC and HMAC for sign/verify functions.

Add support of HMAC key importing via C_CreateObject.

Issue: ALB-9884
Upstream-Status: Pending

Signed-off-by: Xuewei Wang <xuewei.wang@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 examples/pkcs-sig/pkcs-sig.c | 217 ++++++++++++++++++++++++++++++++++-
 libpkcs/pkcs11.c             |   4 +-
 libpkcs/pkcs11_context.h     |  18 +++
 libpkcs/pkcs11_crypt.c       |  91 ++++++++++++---
 libpkcs/pkcs11_object.c      |  17 ++-
 libpkcs/pkcs11_util.c        |  20 ++++
 6 files changed, 345 insertions(+), 22 deletions(-)

diff --git a/examples/pkcs-sig/pkcs-sig.c b/examples/pkcs-sig/pkcs-sig.c
index 1d4d166..431c87c 100644
--- a/examples/pkcs-sig/pkcs-sig.c
+++ b/examples/pkcs-sig/pkcs-sig.c
@@ -12,6 +12,28 @@
 #include <openssl/sha.h>
 #include "pkcs11.h"
 
+/* add missing HMAC key type from pkcs11.h */
+#ifndef CKK_SHA256_HMAC
+#define CKK_SHA256_HMAC         0x0000002BUL
+#endif
+
+#ifndef CKK_SHA384_HMAC
+#define CKK_SHA384_HMAC         0x0000002CUL
+#endif
+
+#ifndef CKK_SHA512_HMAC
+#define CKK_SHA512_HMAC         0x0000002DUL
+#endif
+
+#ifndef CKK_SHA224_HMAC
+#define CKK_SHA224_HMAC         0x0000002EUL
+#endif
+
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+#endif
+
 #ifndef ARRAY_SIZE
 #define ARRAY_SIZE(array) (sizeof(array) / sizeof((array)[0]))
 #endif /* ARRAY_SIZE */
@@ -24,6 +46,24 @@
 #define INFO(fmt, ...) printf("[INFO] " fmt, ##__VA_ARGS__)
 #endif
 
+static unsigned char key_value_AES_128[] = {
+	0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF
+};
+
+/* key size should not bigger than the block size of SHA alg */
+static unsigned char key_value_HMAC_1[] = {
+	0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF,
+	0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF
+};
+
+/* key size should not bigger than the block size of SHA alg */
+static unsigned char key_value_HMAC_2[] = {
+	0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF,
+	0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF,
+	0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF,
+	0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF,
+};
+
 void usage(const char* progname)
 {
 	printf("\n%s - PKCS11 signature generate/verify example\n", progname);
@@ -105,6 +145,31 @@ static CK_SESSION_HANDLE util_lib_open_session(CK_FUNCTION_LIST_PTR flist, CK_SL
 	return session;
 }
 
+static CK_OBJECT_HANDLE install_aes_hmac_key(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session,
+					       CK_KEY_TYPE key_type, uint8_t *key_id, int key_len, uint8_t *key_value)
+{
+	CK_OBJECT_HANDLE key;
+	CK_RV rv;
+
+	/* define key template */
+	CK_OBJECT_CLASS key_class = CKO_SECRET_KEY;
+	CK_KEY_TYPE type = key_type;
+	CK_UTF8CHAR label[] = {"HSE-Sym-Key"};
+	CK_ATTRIBUTE keyTemplate[] = {
+		{ CKA_LABEL, label, sizeof(label)-1 },
+		{ CKA_CLASS, &key_class, sizeof(key_class) },
+		{ CKA_KEY_TYPE, &type, sizeof(type) },
+		{ CKA_ID, key_id, 3 },
+		{ CKA_VALUE, (CK_BYTE_PTR)key_value, key_len }
+	};
+
+	rv = flist->C_CreateObject(session, keyTemplate, ARRAY_SIZE(keyTemplate), &key);
+	if (rv != CKR_OK)
+		return -EKEYREJECTED;
+
+	return key;
+}
+
 static CK_OBJECT_HANDLE install_ecc_private_key(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session)
 {
 	CK_OBJECT_HANDLE key = 0;
@@ -536,6 +601,105 @@ static int rsa_sig(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session, CK_OBJ
 	return 0;
 }
 
+static int util_lib_hmac_sig(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session, CK_MECHANISM_PTR mechanism, CK_OBJECT_HANDLE key)
+{
+	CK_RV rv;
+	char *tobe_sign = "data to be sign";
+	CK_BYTE hmac[128] = {0};
+	CK_ULONG hmac_len = ARRAY_SIZE(hmac);
+
+	INFO("\tGenerate signature ...\n");
+	rv = flist->C_SignInit(session, mechanism, key);
+	if (rv != CKR_OK) {
+		ERROR("\tC_SignInit returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	rv = flist->C_Sign(session, (uint8_t *)tobe_sign, strlen(tobe_sign), hmac, &hmac_len);
+	if (rv != CKR_OK) {
+		ERROR("\tC_Sign returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	INFO("\tVerify signature ...\n");
+	rv = flist->C_VerifyInit(session, mechanism, key);
+	if (rv != CKR_OK) {
+		ERROR("\tC_VerifyInit returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	rv = flist->C_Verify(session, (uint8_t *)tobe_sign, strlen(tobe_sign), hmac, hmac_len);
+	if (rv != CKR_OK) {
+		ERROR("\tC_Verify returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int hmac_sig(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session, CK_OBJECT_HANDLE key)
+{
+	CK_MECHANISM mechanism;
+
+	INFO("CKM_SHA224_HMAC ...\n");
+	mechanism.mechanism = CKM_SHA224_HMAC;
+	util_lib_hmac_sig(flist, session, &mechanism, key);
+
+	INFO("CKM_SHA256_HMAC ...\n");
+	mechanism.mechanism = CKM_SHA256_HMAC;
+	util_lib_hmac_sig(flist, session, &mechanism, key);
+
+	INFO("CKM_SHA384_HMAC ...\n");
+	mechanism.mechanism = CKM_SHA384_HMAC;
+	util_lib_hmac_sig(flist, session, &mechanism, key);
+
+	INFO("CKM_SHA512_HMAC ...\n");
+	mechanism.mechanism = CKM_SHA512_HMAC;
+	util_lib_hmac_sig(flist, session, &mechanism, key);
+
+	return 0;
+}
+
+static int cmac_sig(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session, CK_OBJECT_HANDLE key)
+{
+	CK_RV rv;
+	CK_MECHANISM mechanism;
+	char *tobe_sign = "data to be sign";
+	CK_BYTE cmac[16] = {0};
+	CK_ULONG cmac_len = ARRAY_SIZE(cmac);
+
+	INFO("CKM_AES_CMAC ...\n");
+	mechanism.mechanism = CKM_AES_CMAC;
+
+	INFO("\tGenerate signature ...\n");
+	rv = flist->C_SignInit(session, &mechanism, key);
+	if (rv != CKR_OK) {
+		ERROR("\tC_SignInit returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	rv = flist->C_Sign(session, (uint8_t *)tobe_sign, strlen(tobe_sign), cmac, &cmac_len);
+	if (rv != CKR_OK) {
+		ERROR("\tC_Sign returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	INFO("\tVerify signature ...\n");
+	rv = flist->C_VerifyInit(session, &mechanism, key);
+	if (rv != CKR_OK) {
+		ERROR("\tC_VerifyInit returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	rv = flist->C_Verify(session, (uint8_t *)tobe_sign, strlen(tobe_sign), cmac, cmac_len);
+	if (rv != CKR_OK) {
+		ERROR("\tC_Verify returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	return 0;
+}
+
 int main(int argc, char *argv[])
 {
 	void *lib_handle;
@@ -546,7 +710,11 @@ int main(int argc, char *argv[])
 	
 	CK_SLOT_ID slot;
 	CK_SESSION_HANDLE session;
-	CK_OBJECT_HANDLE rsa_pub_key, rsa_priv_key, ec_pub_key, ec_priv_key;
+	CK_OBJECT_HANDLE rsa_pub_key, rsa_priv_key;
+	CK_OBJECT_HANDLE ec_pub_key = -EKEYREJECTED;
+	CK_OBJECT_HANDLE ec_priv_key = -EKEYREJECTED;
+	CK_OBJECT_HANDLE aes128_key, hmac_key_1, hmac_key_2;
+	uint8_t key_id[3];
 
 	if (argc == 2 && !strncmp(argv[1], arg_help, sizeof(*arg_help))) {
 		usage(argv[0]);
@@ -637,9 +805,54 @@ int main(int argc, char *argv[])
 	ec_pub_key = install_ecc_public_key(flist, session);
 	INFO("Created Key Object with handle %06lx\n", ec_pub_key);
 
+	/* ECC signature */
 	ec_sig(flist, session, ec_priv_key, ec_pub_key);
 
-	/* ECC signature */
+	/* CMAC */
+	INFO("Install AES key ...\n");
+	 /* key_id represent the HSE key slot in the key catalog
+	 *     - key_id[0] - slot ID
+	 *     - key_id[1] - group ID
+	 *     - key_id[2] - catalog ID
+	 */
+	key_id[0] = 0;
+	key_id[1] = 0;
+	key_id[2] = 2;	/* RAM key */
+	aes128_key = install_aes_hmac_key(flist, session, CKK_AES, key_id, sizeof(key_value_AES_128), key_value_AES_128);
+	if (!aes128_key) {
+		ERROR("Failed to create key object\n");
+		ret = -EKEYREJECTED;
+		goto err_lib_finalize;
+	}
+
+	cmac_sig(flist, session, aes128_key);
+
+	/* HMAC */
+	INFO("Install HMAC key ...\n");
+
+	key_id[0] = 0;
+	key_id[1] = 1;
+	key_id[2] = 2;	/* RAM key */
+	hmac_key_1 = install_aes_hmac_key(flist, session, CKK_SHA256_HMAC, key_id, sizeof(key_value_HMAC_1), key_value_HMAC_1);
+	if (!hmac_key_1) {
+		ERROR("Failed to create key object\n");
+		ret = -EKEYREJECTED;
+		goto err_lib_finalize;
+	}
+
+	key_id[0] = 1;
+	key_id[1] = 1;
+	key_id[2] = 2;	/* RAM key */
+	hmac_key_2 = install_aes_hmac_key(flist, session, CKK_SHA256_HMAC, key_id, sizeof(key_value_HMAC_2), key_value_HMAC_2);
+	if (!hmac_key_2) {
+		ERROR("Failed to create key object\n");
+		ret = -EKEYREJECTED;
+		goto err_lib_finalize;
+	}
+
+	hmac_sig(flist, session, hmac_key_1);
+	hmac_sig(flist, session, hmac_key_2);
+	
 	INFO("Deleting Key Objects ...\n");
 
 	if (ec_priv_key != (CK_OBJECT_HANDLE)(-EKEYREJECTED)) {
diff --git a/libpkcs/pkcs11.c b/libpkcs/pkcs11.c
index 6218e41..99a3b7f 100644
--- a/libpkcs/pkcs11.c
+++ b/libpkcs/pkcs11.c
@@ -41,7 +41,9 @@ static const CK_MECHANISM_TYPE mechanismList[] = {
 	CKM_ECDSA_SHA256,
 	CKM_ECDSA_SHA384,
 	CKM_ECDSA_SHA512,
-	CKM_SHA_1, CKM_SHA224, CKM_SHA256, CKM_SHA512, CKM_SHA512_224, CKM_SHA512_256
+	CKM_SHA_1, CKM_SHA224, CKM_SHA256, CKM_SHA512, CKM_SHA512_224, CKM_SHA512_256,
+	CKM_AES_CMAC,
+	CKM_SHA224_HMAC, CKM_SHA256_HMAC, CKM_SHA384_HMAC, CKM_SHA512_HMAC,
 };
 
 static CK_FUNCTION_LIST gFunctionList = {
diff --git a/libpkcs/pkcs11_context.h b/libpkcs/pkcs11_context.h
index f4b1655..d4aeeb5 100644
--- a/libpkcs/pkcs11_context.h
+++ b/libpkcs/pkcs11_context.h
@@ -31,6 +31,24 @@
 #define CKA_UNIQUE_ID 0x04ul
 #endif
 
+/* add missing HMAC key type from pkcs11.h */
+#ifndef CKK_SHA256_HMAC
+#define CKK_SHA256_HMAC         0x0000002BUL
+#endif
+
+#ifndef CKK_SHA384_HMAC
+#define CKK_SHA384_HMAC         0x0000002CUL
+#endif
+
+#ifndef CKK_SHA512_HMAC
+#define CKK_SHA512_HMAC         0x0000002DUL
+#endif
+
+#ifndef CKK_SHA224_HMAC
+#define CKK_SHA224_HMAC         0x0000002EUL
+#endif
+
+
 #ifndef ARRAY_SIZE
 #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
 #endif
diff --git a/libpkcs/pkcs11_crypt.c b/libpkcs/pkcs11_crypt.c
index 0c40f87..3bfcf8f 100644
--- a/libpkcs/pkcs11_crypt.c
+++ b/libpkcs/pkcs11_crypt.c
@@ -669,6 +669,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Sign)(
 	CK_RV rc = CKR_OK;
 	int err;
 	CK_RSA_PKCS_PSS_PARAMS *rsa_pss_param;
+	hseMacSrv_t *mac_srv = NULL;
 
 	if (gCtx->cryptokiInit == CK_FALSE)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
@@ -794,20 +795,46 @@ CK_DEFINE_FUNCTION(CK_RV, C_Sign)(
 			else
 				sign_srv->bInputIsHashed = 0u;
 
+			break;
+		case CKM_AES_CMAC:
+			mac_srv = &srv_desc.hseSrv.macReq;
+			mac_srv->macScheme.macAlgo = HSE_MAC_ALGO_CMAC;
+			mac_srv->macScheme.sch.cmac.cipherAlgo = HSE_CIPHER_ALGO_AES;
+			break;
+		case CKM_SHA224_HMAC:
+		case CKM_SHA256_HMAC:
+		case CKM_SHA384_HMAC:
+		case CKM_SHA512_HMAC:
+			mac_srv = &srv_desc.hseSrv.macReq;
+			mac_srv->macScheme.macAlgo = HSE_MAC_ALGO_HMAC;
+			mac_srv->macScheme.sch.hmac.hashAlgo = hse_get_hash_alg(gCtx->signCtx.mechanism->mechanism);
 			break;
 		default:
 			rc = CKR_ARGUMENTS_BAD;
 			goto err_free_sign0;
 	}
 
-	srv_desc.srvId = HSE_SRV_ID_SIGN;
-	sign_srv->accessMode = HSE_ACCESS_MODE_ONE_PASS;
-	sign_srv->streamId = 0u;
-	sign_srv->authDir = HSE_AUTH_DIR_GENERATE;
-	sign_srv->keyHandle = key->key_handle;
-	sign_srv->sgtOption = HSE_SGT_OPTION_NONE;
-	sign_srv->inputLength = ulDataLen;
-	sign_srv->pInput = hse_virt_to_dma(input);
+	if (!mac_srv) {
+		srv_desc.srvId = HSE_SRV_ID_SIGN;
+		sign_srv->accessMode = HSE_ACCESS_MODE_ONE_PASS;
+		sign_srv->streamId = 0u;
+		sign_srv->authDir = HSE_AUTH_DIR_GENERATE;
+		sign_srv->keyHandle = key->key_handle;
+		sign_srv->sgtOption = HSE_SGT_OPTION_NONE;
+		sign_srv->inputLength = ulDataLen;
+		sign_srv->pInput = hse_virt_to_dma(input);
+	} else {
+		srv_desc.srvId = HSE_SRV_ID_MAC;
+		mac_srv->accessMode = HSE_ACCESS_MODE_ONE_PASS;
+		mac_srv->streamId = 0u;
+		mac_srv->authDir = HSE_AUTH_DIR_GENERATE;
+		mac_srv->sgtOption = HSE_SGT_OPTION_NONE;
+		mac_srv->keyHandle = key->key_handle;
+		mac_srv->inputLength = ulDataLen;
+		mac_srv->pInput = hse_virt_to_dma(input);
+		mac_srv->pTagLength = hse_virt_to_dma(output_len);
+		mac_srv->pTag = hse_virt_to_dma(sign0);
+	}
 
 	err = hse_srv_req_sync(HSE_CHANNEL_ANY, &srv_desc, sizeof(srv_desc));
 	if (err) {
@@ -826,6 +853,11 @@ CK_DEFINE_FUNCTION(CK_RV, C_Sign)(
 		case CKM_SHA256_RSA_PKCS_PSS:
 		case CKM_SHA384_RSA_PKCS_PSS:
 		case CKM_SHA512_RSA_PKCS_PSS:
+		case CKM_AES_CMAC:
+		case CKM_SHA224_HMAC:
+		case CKM_SHA256_HMAC:
+		case CKM_SHA384_HMAC:
+		case CKM_SHA512_HMAC:
 
 			hse_memcpy(pSignature, sign0, *(uint32_t *)output_len);
 			hse_memcpy(pulSignatureLen, output_len, sizeof(uint32_t));
@@ -910,6 +942,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Verify)(
 	CK_RV rc = CKR_OK;
 	int err;
 	CK_RSA_PKCS_PSS_PARAMS *rsa_pss_param;
+	hseMacSrv_t *mac_srv = NULL;
 
 	if (gCtx->cryptokiInit == CK_FALSE)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
@@ -1030,20 +1063,46 @@ CK_DEFINE_FUNCTION(CK_RV, C_Verify)(
 			else
 				sign_srv->bInputIsHashed = 0u;
 
+			break;
+		case CKM_AES_CMAC:
+			mac_srv = &srv_desc.hseSrv.macReq;
+			mac_srv->macScheme.macAlgo = HSE_MAC_ALGO_CMAC;
+			mac_srv->macScheme.sch.cmac.cipherAlgo = HSE_CIPHER_ALGO_AES;
+			break;
+		case CKM_SHA224_HMAC:
+		case CKM_SHA256_HMAC:
+		case CKM_SHA384_HMAC:
+		case CKM_SHA512_HMAC:
+			mac_srv = &srv_desc.hseSrv.macReq;
+			mac_srv->macScheme.macAlgo = HSE_MAC_ALGO_HMAC;
+			mac_srv->macScheme.sch.hmac.hashAlgo = hse_get_hash_alg(gCtx->signCtx.mechanism->mechanism);
 			break;
 		default:
 			rc = CKR_ARGUMENTS_BAD;
 			goto err_free_sign0;
 	}
 
-	srv_desc.srvId = HSE_SRV_ID_SIGN;
-	sign_srv->accessMode = HSE_ACCESS_MODE_ONE_PASS;
-	sign_srv->streamId = 0u;
-	sign_srv->authDir = HSE_AUTH_DIR_VERIFY;
-	sign_srv->keyHandle = key->key_handle;
-	sign_srv->sgtOption = HSE_SGT_OPTION_NONE;
-	sign_srv->inputLength = ulDataLen;
-	sign_srv->pInput = hse_virt_to_dma(input);
+	if (!mac_srv) {
+		srv_desc.srvId = HSE_SRV_ID_SIGN;
+		sign_srv->accessMode = HSE_ACCESS_MODE_ONE_PASS;
+		sign_srv->streamId = 0u;
+		sign_srv->authDir = HSE_AUTH_DIR_VERIFY;
+		sign_srv->keyHandle = key->key_handle;
+		sign_srv->sgtOption = HSE_SGT_OPTION_NONE;
+		sign_srv->inputLength = ulDataLen;
+		sign_srv->pInput = hse_virt_to_dma(input);
+	} else {
+		srv_desc.srvId = HSE_SRV_ID_MAC;
+		mac_srv->accessMode = HSE_ACCESS_MODE_ONE_PASS;
+		mac_srv->streamId = 0u;
+		mac_srv->authDir = HSE_AUTH_DIR_VERIFY;
+		mac_srv->sgtOption = HSE_SGT_OPTION_NONE;
+		mac_srv->keyHandle = key->key_handle;
+		mac_srv->inputLength = ulDataLen;
+		mac_srv->pInput = hse_virt_to_dma(input);
+		mac_srv->pTagLength = hse_virt_to_dma(output_len);
+		mac_srv->pTag = hse_virt_to_dma(sign0);
+	}
 
 	err = hse_srv_req_sync(HSE_CHANNEL_ANY, &srv_desc, sizeof(srv_desc));
 	if (!err) {
diff --git a/libpkcs/pkcs11_object.c b/libpkcs/pkcs11_object.c
index ef56c95..68d509e 100644
--- a/libpkcs/pkcs11_object.c
+++ b/libpkcs/pkcs11_object.c
@@ -323,6 +323,10 @@ CK_DEFINE_FUNCTION(CK_RV, C_CreateObject)(
 
 			break;
 		case CKK_AES:
+		case CKK_SHA224_HMAC:
+		case CKK_SHA256_HMAC:
+		case CKK_SHA384_HMAC:
+		case CKK_SHA512_HMAC:
 
 			pkey2_len = getattr_len(pTemplate, CKA_VALUE, ulCount);
 			if (!pkey2_len) {
@@ -336,10 +340,17 @@ CK_DEFINE_FUNCTION(CK_RV, C_CreateObject)(
 			}
 			hse_memcpy(pkey2, getattr_pval(pTemplate, CKA_VALUE, ulCount), pkey2_len);
 
-			/* aes keys can only be used for encrypt/decrypt */
-			key_info->keyFlags = (HSE_KF_USAGE_ENCRYPT | HSE_KF_USAGE_DECRYPT);
+			if (key->key_type == CKK_AES) {
+				/* aes keys can only be used for encrypt/decrypt */
+				key_info->keyFlags = (HSE_KF_USAGE_ENCRYPT | HSE_KF_USAGE_DECRYPT | HSE_KF_USAGE_SIGN | HSE_KF_USAGE_VERIFY);
+				key_info->keyType = HSE_KEY_TYPE_AES;
+			} else {
+				/* HMAC key */
+				key_info->keyFlags = (HSE_KF_USAGE_SIGN | HSE_KF_USAGE_VERIFY);
+				key_info->keyType = HSE_KEY_TYPE_HMAC;
+			}
+
 			key_info->keyBitLen = pkey2_len * 8;
-			key_info->keyType = HSE_KEY_TYPE_AES;
 
 			import_key_req->pKey[0] = 0u;
 			import_key_req->pKey[1] = 0u;
diff --git a/libpkcs/pkcs11_util.c b/libpkcs/pkcs11_util.c
index f824a39..65ba80c 100644
--- a/libpkcs/pkcs11_util.c
+++ b/libpkcs/pkcs11_util.c
@@ -155,24 +155,29 @@ hseHashAlgo_t hse_get_hash_alg(CK_MECHANISM_TYPE mechanism)
 	switch (mechanism) {
 		case CKM_SHA1_RSA_PKCS:
 		case CKM_ECDSA_SHA1:
+		case CKM_SHA_1_HMAC:
 			hash = HSE_HASH_ALGO_SHA_1;
 			break;
 		case CKM_ECDSA_SHA224:
+		case CKM_SHA224_HMAC:
 			hash = HSE_HASH_ALGO_SHA2_224;
 			break;
 		case CKM_SHA256_RSA_PKCS:
 		case CKM_SHA256_RSA_PKCS_PSS:
 		case CKM_ECDSA_SHA256:
+		case CKM_SHA256_HMAC:
 			hash = HSE_HASH_ALGO_SHA2_256;
 			break;
 		case CKM_SHA384_RSA_PKCS:
 		case CKM_SHA384_RSA_PKCS_PSS:
 		case CKM_ECDSA_SHA384:
+		case CKM_SHA384_HMAC:
 			hash = HSE_HASH_ALGO_SHA2_384;
 			break;
 		case CKM_SHA512_RSA_PKCS:
 		case CKM_SHA512_RSA_PKCS_PSS:
 		case CKM_ECDSA_SHA512:
+		case CKM_SHA512_HMAC:
 			hash = HSE_HASH_ALGO_SHA2_512;
 			break;
 		default:
@@ -205,6 +210,21 @@ uint32_t sig_get_out_length(struct hse_keyObject *key, CK_MECHANISM_PTR mechanis
 		case CKM_ECDSA_SHA512:
 			sig_len = (hse_get_key_bit_length(key) >> 3) * 2;
 			break;
+		case CKM_AES_CMAC:
+			sig_len = 16;
+			break;
+		case CKM_SHA224_HMAC:
+			sig_len = 28;
+			break;
+		case CKM_SHA256_HMAC:
+			sig_len = 32;
+			break;
+		case CKM_SHA384_HMAC:
+			sig_len = 48;
+			break;
+		case CKM_SHA512_HMAC:
+			sig_len = 64;
+			break;
 		default:
 			return 0;
 	}
-- 
2.25.1

