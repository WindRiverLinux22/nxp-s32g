From 8fa680dea44eb0913112c92201706140e692f76c Mon Sep 17 00:00:00 2001
From: xuewei wang <xuewei.wang@nxp.com>
Date: Mon, 20 Feb 2023 16:42:17 +0800
Subject: [PATCH 05/11] Add support of RSA Ciphering (PKCS1 V1.5 and OAEP) for
 encrypt/decrypt functions

Issue: ALB-9826
Upstream-Status: Pending

Signed-off-by: Xuewei Wang <xuewei.wang@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 examples/pkcs-cipher/pkcs-cipher.c | 156 ++++++++++++++++++++++----
 examples/pkcs-cipher/readne.md     |  25 +++++
 libpkcs/pkcs11.c                   |   2 +
 libpkcs/pkcs11_crypt.c             | 170 ++++++++++++++++++++++++++---
 libpkcs/pkcs11_object.c            |   6 +-
 libpkcs/pkcs11_util.c              | 150 +++++++++++++++++++++++++
 libpkcs/pkcs11_util.h              |  16 +++
 7 files changed, 486 insertions(+), 39 deletions(-)
 create mode 100644 examples/pkcs-cipher/readne.md
 create mode 100644 libpkcs/pkcs11_util.c
 create mode 100644 libpkcs/pkcs11_util.h

diff --git a/examples/pkcs-cipher/pkcs-cipher.c b/examples/pkcs-cipher/pkcs-cipher.c
index 6c8f563..b2cae6b 100644
--- a/examples/pkcs-cipher/pkcs-cipher.c
+++ b/examples/pkcs-cipher/pkcs-cipher.c
@@ -144,18 +144,22 @@ static CK_OBJECT_HANDLE util_lib_create_object(CK_FUNCTION_LIST_PTR flist, CK_SE
 	return key;
 }
 
-static CK_OBJECT_HANDLE util_lib_find_objects(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session)
+static CK_OBJECT_HANDLE util_lib_find_objects(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session, CK_OBJECT_CLASS class)
 {
-	CK_OBJECT_HANDLE key_match = 0;
+	CK_OBJECT_HANDLE aes_key = 0;
 	CK_ULONG num_keys;
 	CK_RV rv;
+	CK_OBJECT_CLASS key_class = class;
+	CK_ATTRIBUTE template[] = {
+		{ CKA_CLASS, &key_class, sizeof(key_class) },
+	};
 
-	rv = flist->C_FindObjectsInit(session, NULL, 0);
+	rv = flist->C_FindObjectsInit(session, template, ARRAY_SIZE(template));
 	if (rv != CKR_OK)
 		return 0;
 
 	do {
-		rv = flist->C_FindObjects(session, &key_match, 1, &num_keys);
+		rv = flist->C_FindObjects(session, &aes_key, 1, &num_keys);
 		/* no extra processing required, just return last key found */
 	} while (rv == CKR_OK && num_keys != 0);
 
@@ -163,7 +167,7 @@ static CK_OBJECT_HANDLE util_lib_find_objects(CK_FUNCTION_LIST_PTR flist, CK_SES
 	if (rv != CKR_OK)
 		return 0;
 
-	return key_match;
+	return aes_key;
 }
 
 static int util_lib_destroy_object(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session, CK_OBJECT_HANDLE key)
@@ -188,7 +192,7 @@ static int util_lib_finalize(CK_FUNCTION_LIST_PTR flist)
 	return 0;
 }
 
-static int ciphering(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session, CK_OBJECT_HANDLE key, CK_MECHANISM_PTR p_mech)
+static int block_ciphering(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session, CK_OBJECT_HANDLE key, CK_MECHANISM_PTR p_mech)
 {
 	CK_RV rv;
 
@@ -223,14 +227,14 @@ static int ciphering(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session, CK_O
 	return memcmp(decrypted_text, plain_text, decrypt_text_len);
 }
 
-static int util_lib_ciphering(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session, CK_OBJECT_HANDLE key)
+static int util_lib_block_ciphering(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session, CK_OBJECT_HANDLE key)
 {
 	int ret;
 	CK_MECHANISM mechanism;
 
 	mechanism.mechanism = CKM_AES_ECB;
 	mechanism.pParameter = NULL;
-	ret = ciphering(flist, session, key, &mechanism);
+	ret = block_ciphering(flist, session, key, &mechanism);
 	if (ret == 0)
 		INFO("CKM_AES_ECB Done!\n");
 	else 
@@ -239,7 +243,7 @@ static int util_lib_ciphering(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE sess
 	mechanism.mechanism = CKM_AES_CBC;
 	mechanism.ulParameterLen = 16;
 	mechanism.pParameter = iv;
-	ret = ciphering(flist, session, key, &mechanism);
+	ret = block_ciphering(flist, session, key, &mechanism);
 	if (ret == 0)
 		INFO("CKM_AES_CBC Done!\n");
 	else 
@@ -248,7 +252,7 @@ static int util_lib_ciphering(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE sess
 	mechanism.mechanism = CKM_AES_CTR;
 	mechanism.ulParameterLen = 16;
 	mechanism.pParameter = iv;
-	ret = ciphering(flist, session, key, &mechanism);
+	ret = block_ciphering(flist, session, key, &mechanism);
 	if (ret == 0)
 		INFO("CKM_AES_CTR Done!\n");
 	else 
@@ -257,7 +261,7 @@ static int util_lib_ciphering(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE sess
 	mechanism.mechanism = CKM_AES_GCM;
 	mechanism.ulParameterLen = 16;
 	mechanism.pParameter = iv;
-	ret = ciphering(flist, session, key, &mechanism);
+	ret = block_ciphering(flist, session, key, &mechanism);
 	if (ret == 0)
 		INFO("CKM_AES_GCM Done!\n");
 	else 
@@ -266,6 +270,95 @@ static int util_lib_ciphering(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE sess
 	return 0;
 }
 
+static int util_lib_rsa_ciphering(CK_FUNCTION_LIST_PTR flist, CK_SESSION_HANDLE session, CK_OBJECT_HANDLE pub_key, CK_OBJECT_HANDLE priv_key)
+{
+	CK_RV rv;
+	CK_MECHANISM mechanism;
+	char *plain_text = "rsa ciphering test; rsa ciphering test; rsa ciphering test";
+	uint8_t cipher_text[256] = {0};
+	CK_ULONG cipher_text_len = ARRAY_SIZE(cipher_text);
+	uint8_t decrypted_text[64] = {0};
+	CK_ULONG decrypted_text_length = 0;
+	CK_RSA_PKCS_OAEP_PARAMS rsa_oaep_param;
+
+	mechanism.mechanism = CKM_RSA_PKCS;
+	mechanism.pParameter = NULL;
+	mechanism.ulParameterLen = 0;
+
+	INFO("CKM_RSA_PKCS encrypt/decrypt ...\n");
+	/* encrypt:  plain_text -> cipher_text */
+	rv = flist->C_EncryptInit(session, &mechanism, pub_key);
+	if (rv != CKR_OK) {
+		INFO("C_EncryptInit returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	rv = flist->C_Encrypt(session, (uint8_t *)plain_text, strlen(plain_text), cipher_text, &cipher_text_len);
+	if (rv != CKR_OK) {
+		INFO("C_Encrypt returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	/* decrypt: cipher_text -> decrypted_text */
+	rv = flist->C_DecryptInit(session, &mechanism, priv_key);
+	if (rv != CKR_OK) {
+		INFO("C_DecryptInit returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	decrypted_text_length = ARRAY_SIZE(decrypted_text);
+	rv = flist->C_Decrypt(session, (uint8_t *)cipher_text, sizeof(cipher_text), decrypted_text, &decrypted_text_length);
+	if (rv != CKR_OK) {
+		INFO("C_Decrypt returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	if (memcmp((void *)plain_text, (void *)decrypted_text, decrypted_text_length) == 0)
+		INFO("CKM_RSA_PKCS Done!\n");
+	else 
+		INFO("CKM_RSA_PKCS Fail!\n");
+
+	INFO("CKM_RSA_PKCS_OAEP encrypt/decrypt ...\n");
+	mechanism.mechanism = CKM_RSA_PKCS_OAEP;
+	mechanism.pParameter = (void *)&rsa_oaep_param;
+	mechanism.ulParameterLen = sizeof(CK_RSA_PKCS_OAEP_PARAMS);
+	rsa_oaep_param.hashAlg = CKM_SHA_1;
+
+	/* encrypt:  plain_text -> cipher_text */
+	rv = flist->C_EncryptInit(session, &mechanism, pub_key);
+	if (rv != CKR_OK) {
+		INFO("C_EncryptInit returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	rv = flist->C_Encrypt(session, (uint8_t *)plain_text, strlen(plain_text), cipher_text, &cipher_text_len);
+	if (rv != CKR_OK) {
+		INFO("C_Encrypt returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	/* decrypt: cipher_text -> decrypted_text */
+	rv = flist->C_DecryptInit(session, &mechanism, priv_key);
+	if (rv != CKR_OK) {
+		INFO("C_DecryptInit returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	decrypted_text_length = ARRAY_SIZE(decrypted_text);
+	rv = flist->C_Decrypt(session, (uint8_t *)cipher_text, sizeof(cipher_text), decrypted_text, &decrypted_text_length);
+	if (rv != CKR_OK) {
+		INFO("C_Decrypt returns error 0x%lx\n", rv);
+		return -1;
+	}
+
+	if (memcmp((void *)plain_text, (void *)decrypted_text, decrypted_text_length) == 0)
+		INFO("CKM_RSA_PKCS_OAEP Done!\n");
+	else 
+		INFO("CKM_RSA_PKCS_OAEP Fail!\n");
+
+	return 0;
+}
+
 int main(int argc, char *argv[])
 {
 	void *lib_handle;
@@ -276,7 +369,7 @@ int main(int argc, char *argv[])
 	
 	CK_SLOT_ID slot;
 	CK_SESSION_HANDLE session;
-	CK_OBJECT_HANDLE key_match, key;
+	CK_OBJECT_HANDLE aes_key, key, rsa_pub_key, rsa_priv_key;
 
 	if (argc == 2 && !strncmp(argv[1], arg_help, sizeof(*arg_help))) {
 		usage(argv[0]);
@@ -346,21 +439,44 @@ int main(int argc, char *argv[])
 
 	INFO("Calling C_FindObjects...\n");
 
-	key_match = util_lib_find_objects(flist, session);
-	if (!key_match) {
-		ERROR("Failed to find key object\n");
+	aes_key = util_lib_find_objects(flist, session, CKO_SECRET_KEY);
+	if (!aes_key) {
+		ERROR("Failed to find key object with Class CKO_SECRET_KEY\n");
+		ret = -ENOKEY;
+		goto err_lib_finalize;
+	}
+
+	INFO("Found Key Object with handle %06lx\n", aes_key);
+
+	INFO("Block ciphering...\n");
+	/* block ciphering */
+	util_lib_block_ciphering(flist, session, aes_key);
+
+	INFO("RSA ciphering...\n");
+	/* RSA ciphering */
+	rsa_pub_key = util_lib_find_objects(flist, session, CKO_PUBLIC_KEY);
+	if (!rsa_pub_key) {
+		ERROR("Failed to find key object with Class CKO_PUBLIC_KEY\n");
+		ret = -ENOKEY;
+		goto err_lib_finalize;
+	}
+
+	INFO("Found Key Object with handle %06lx\n", rsa_pub_key);
+
+	rsa_priv_key = util_lib_find_objects(flist, session, CKO_PRIVATE_KEY);
+	if (!rsa_priv_key) {
+		ERROR("Failed to find key object with Class CKO_PRIVATE_KEY\n");
 		ret = -ENOKEY;
 		goto err_lib_finalize;
 	}
 
-	INFO("Found Key Object with handle %06lx\n", key_match);
+	INFO("Found Key Object with handle %06lx\n", rsa_priv_key);
 
-	/* ciphering */
-	util_lib_ciphering(flist, session, key);
+	util_lib_rsa_ciphering(flist, session, rsa_pub_key, rsa_priv_key);
 
-	INFO("Deleting Key Object with handle %06lx\n", key_match);
+	INFO("Deleting Key Object with handle %06lx\n", aes_key);
 
-	ret = util_lib_destroy_object(flist, session, key_match);
+	ret = util_lib_destroy_object(flist, session, aes_key);
 	if (ret) {
 		ERROR("Failed to destroy key object\n");
 		goto err_lib_finalize;
diff --git a/examples/pkcs-cipher/readne.md b/examples/pkcs-cipher/readne.md
new file mode 100644
index 0000000..229671a
--- /dev/null
+++ b/examples/pkcs-cipher/readne.md
@@ -0,0 +1,25 @@
+This example assumes the RSA private key and public key were installed beforehand.
+Please take the below steps as referance:
+
+1. Format HSE key catalogs using the `hse-secboot` example
+
+    hse-secboot -f -o -d /dev/mmcblk0
+
+    Note: `-o` is required if the HSE SYS_IMG exist.
+
+2. Remove the objects file after re-formating HSE key catalogs
+
+    rm /etc/pkcs-hse-objs
+
+    Note: This keeps the objects file consistent with HSE key catalog
+
+3. Import RSA private and public keys using pkcs11-tool from OpenSC.
+
+    pkcs11-tool --module /usr/lib/libpkcs-hse.so --write-object rsa_priv.pem --type privkey --id 000601 --label "HSE-RSAPRIV-KEY"
+
+    pkcs11-tool --module /usr/lib/libpkcs-hse.so --write-object rsa_pub.pem --type pubkey --id 000701 --label "HSE-RSAPUB-KEY"
+
+4. Run the pkcs-cipher
+
+    pkcs-cipher /usr/lib/libpkcs-hse.so
+
diff --git a/libpkcs/pkcs11.c b/libpkcs/pkcs11.c
index d6d8bd0..e4815af 100644
--- a/libpkcs/pkcs11.c
+++ b/libpkcs/pkcs11.c
@@ -24,6 +24,8 @@ static const CK_MECHANISM_TYPE mechanismList[] = {
 	CKM_AES_GCM,
 	CKM_AES_CBC,
 	CKM_AES_CTR,
+	CKM_RSA_PKCS,
+	CKM_RSA_PKCS_OAEP,
 	CKM_SHA256_RSA_PKCS,
 	CKM_ECDSA_SHA1,
 	CKM_SHA_1, CKM_SHA224, CKM_SHA256, CKM_SHA512, CKM_SHA512_224, CKM_SHA512_256
diff --git a/libpkcs/pkcs11_crypt.c b/libpkcs/pkcs11_crypt.c
index 0eea797..3052a72 100644
--- a/libpkcs/pkcs11_crypt.c
+++ b/libpkcs/pkcs11_crypt.c
@@ -8,6 +8,7 @@
 #include <string.h>
 
 #include "pkcs11_context.h"
+#include "pkcs11_util.h"
 
 CK_DEFINE_FUNCTION(CK_RV, C_EncryptInit)(
 		CK_SESSION_HANDLE hSession,
@@ -33,9 +34,10 @@ CK_DEFINE_FUNCTION(CK_RV, C_EncryptInit)(
 		return CKR_KEY_HANDLE_INVALID;
 
 	/* IV is optional for AES-ECB */
-	if (pMechanism->pParameter == NULL &&
-	    pMechanism->mechanism != CKM_AES_ECB)
-		return CKR_ARGUMENTS_BAD;
+	if (pMechanism->pParameter == NULL)
+	    if ((pMechanism->mechanism != CKM_AES_ECB) &&  
+			(pMechanism->mechanism != CKM_RSA_PKCS))
+			return CKR_ARGUMENTS_BAD;
 
 	gCtx->cryptCtx.init = CK_TRUE;
 	gCtx->cryptCtx.mechanism = pMechanism;
@@ -55,12 +57,15 @@ CK_DEFINE_FUNCTION(CK_RV, C_Encrypt)(
 	struct globalCtx *gCtx = getCtx();
 	DECLARE_SET_ZERO(hseSrvDescriptor_t, srv_desc);
 	hseSymCipherSrv_t *sym_cipher_srv;
+	hseRsaCipherSrv_t *rsa_cipher_srv;
 	hseAeadSrv_t *aead_srv;
 	void *input, *output, *output_len, *pIV = NULL;
 	void *gcm_tag = NULL;
 	struct hse_keyObject *key;
 	CK_RV rc = CKR_OK;
 	int err;
+	uint16_t key_bit_length;
+	CK_RSA_PKCS_OAEP_PARAMS *oaep_params;
 
 	if (gCtx->cryptokiInit == CK_FALSE)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
@@ -85,6 +90,19 @@ CK_DEFINE_FUNCTION(CK_RV, C_Encrypt)(
 	}
 
 	key = (struct hse_keyObject *)list_seek(&gCtx->object_list, &gCtx->cryptCtx.keyHandle);
+	if (key == NULL)
+		return CKR_KEY_HANDLE_INVALID;
+
+	/* check for input length for RSA ciphering */
+	if ((gCtx->cryptCtx.mechanism->mechanism == CKM_RSA_PKCS) || 
+		(gCtx->cryptCtx.mechanism->mechanism == CKM_RSA_PKCS_OAEP)) {
+		key_bit_length = hse_get_key_bit_length(key);
+		if (key_bit_length == 0) 
+			return CKR_GENERAL_ERROR;
+
+		if (rsa_ciphering_get_max_input_length(key_bit_length, gCtx->cryptCtx.mechanism) < ulDataLen)
+			return CKR_DATA_LEN_RANGE;
+	}
 
 	input = hse_mem_alloc(ulDataLen);
 	if (input == NULL) 
@@ -97,14 +115,27 @@ CK_DEFINE_FUNCTION(CK_RV, C_Encrypt)(
 		goto err_free_input;
 	}
 
+	/* Check the output length */
 	if ((gCtx->cryptCtx.mechanism->mechanism == CKM_AES_ECB) || 
 		(gCtx->cryptCtx.mechanism->mechanism == CKM_AES_CBC) || 
 		(gCtx->cryptCtx.mechanism->mechanism == CKM_AES_CTR) || 
 		(gCtx->cryptCtx.mechanism->mechanism == CKM_AES_GCM)) {
 		/* For AES, the output length is equal to the input length  */
 		hse_memcpy(output_len, &ulDataLen, sizeof(uint32_t));
+	} else if ((gCtx->cryptCtx.mechanism->mechanism == CKM_RSA_PKCS) || 
+			   (gCtx->cryptCtx.mechanism->mechanism == CKM_RSA_PKCS_OAEP)) {
+		/* get the output length based on the RSA key length */
+		*(uint32_t *)output_len = rsa_ciphering_get_out_length(key_bit_length);
 	}
 
+	if (*pulEncryptedDataLen < *(uint32_t *)output_len) {
+		/* tell the required size */
+		*pulEncryptedDataLen = *(uint32_t *)output_len;
+
+		rc = CKR_BUFFER_TOO_SMALL;
+		goto err_free_output_len;
+	}
+	
 	output = hse_mem_alloc(*(uint32_t *)output_len);
 	if (output == NULL) {
 		rc = CKR_HOST_MEMORY;
@@ -112,12 +143,16 @@ CK_DEFINE_FUNCTION(CK_RV, C_Encrypt)(
 	}
 
 	if (gCtx->cryptCtx.mechanism->pParameter != NULL) {
-		pIV = hse_mem_alloc(gCtx->cryptCtx.mechanism->ulParameterLen);
-		if (pIV == NULL) {
-			rc = CKR_HOST_MEMORY;
-			goto err_free_output;
+		if (gCtx->cryptCtx.mechanism->mechanism == CKM_RSA_PKCS_OAEP) {
+			oaep_params = (CK_RSA_PKCS_OAEP_PARAMS *)gCtx->cryptCtx.mechanism->pParameter;
+		} else {
+			pIV = hse_mem_alloc(gCtx->cryptCtx.mechanism->ulParameterLen);
+			if (pIV == NULL) {
+				rc = CKR_HOST_MEMORY;
+				goto err_free_output;
+			}
+			hse_memcpy(pIV, gCtx->cryptCtx.mechanism->pParameter, gCtx->cryptCtx.mechanism->ulParameterLen);
 		}
-		hse_memcpy(pIV, gCtx->cryptCtx.mechanism->pParameter, gCtx->cryptCtx.mechanism->ulParameterLen);
 	}
 
 	if (gCtx->cryptCtx.mechanism->mechanism == CKM_AES_GCM) {
@@ -217,6 +252,37 @@ CK_DEFINE_FUNCTION(CK_RV, C_Encrypt)(
 
 			break;
 
+		case CKM_RSA_PKCS:
+			rsa_cipher_srv = &srv_desc.hseSrv.rsaCipherReq;
+
+			srv_desc.srvId = HSE_SRV_ID_RSA_CIPHER;
+			rsa_cipher_srv->cipherDir = HSE_CIPHER_DIR_ENCRYPT;
+			rsa_cipher_srv->keyHandle = key->key_handle;
+			rsa_cipher_srv->inputLength = ulDataLen;
+			rsa_cipher_srv->pInput = hse_virt_to_dma(input);
+			rsa_cipher_srv->pOutputLength = hse_virt_to_dma(output_len);
+			rsa_cipher_srv->pOutput = hse_virt_to_dma(output);
+
+			rsa_cipher_srv->rsaScheme.rsaAlgo = HSE_RSA_ALGO_RSAES_PKCS1_V15;
+			break;
+
+		case CKM_RSA_PKCS_OAEP:
+			rsa_cipher_srv = &srv_desc.hseSrv.rsaCipherReq;
+
+			srv_desc.srvId = HSE_SRV_ID_RSA_CIPHER;
+			rsa_cipher_srv->cipherDir = HSE_CIPHER_DIR_ENCRYPT;
+			rsa_cipher_srv->keyHandle = key->key_handle;
+			rsa_cipher_srv->inputLength = ulDataLen;
+			rsa_cipher_srv->pInput = hse_virt_to_dma(input);
+			rsa_cipher_srv->pOutputLength = hse_virt_to_dma(output_len);
+			rsa_cipher_srv->pOutput = hse_virt_to_dma(output);
+
+			rsa_cipher_srv->rsaScheme.rsaAlgo = HSE_RSA_ALGO_RSAES_OAEP;
+			rsa_cipher_srv->rsaScheme.sch.rsaOAEP.hashAlgo = hse_get_hash_alg(oaep_params->hashAlg);
+			rsa_cipher_srv->rsaScheme.sch.rsaOAEP.labelLength = 0;
+			rsa_cipher_srv->rsaScheme.sch.rsaOAEP.pLabel = 0;
+			break;
+
 		default:
 			rc = CKR_ARGUMENTS_BAD;
 			goto err_free_tag;
@@ -271,9 +337,10 @@ CK_DEFINE_FUNCTION(CK_RV, C_DecryptInit)(
 		return CKR_KEY_HANDLE_INVALID;
 
 	/* IV is optional for AES-ECB */
-	if (pMechanism->pParameter == NULL &&
-		pMechanism->mechanism != CKM_AES_ECB)
-		return CKR_ARGUMENTS_BAD;
+	if (pMechanism->pParameter == NULL)
+	    if ((pMechanism->mechanism != CKM_AES_ECB) &&  
+			(pMechanism->mechanism != CKM_RSA_PKCS))
+			return CKR_ARGUMENTS_BAD;
 
 	gCtx->cryptCtx.init = CK_TRUE;
 	gCtx->cryptCtx.mechanism = pMechanism;
@@ -293,12 +360,15 @@ CK_DEFINE_FUNCTION(CK_RV, C_Decrypt)(
 	struct globalCtx *gCtx = getCtx();
 	DECLARE_SET_ZERO(hseSrvDescriptor_t, srv_desc);
 	hseSymCipherSrv_t *sym_cipher_srv;
+	hseRsaCipherSrv_t *rsa_cipher_srv;
 	hseAeadSrv_t *aead_srv;
 	void *input, *output, *output_len, *pIV = NULL;
 	void *gcm_tag = NULL;
 	struct hse_keyObject *key;
 	CK_RV rc = CKR_OK;
 	int err;
+	uint16_t key_bit_length = 0;
+	CK_RSA_PKCS_OAEP_PARAMS *oaep_params;
 
 	if (gCtx->cryptokiInit == CK_FALSE)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
@@ -323,6 +393,16 @@ CK_DEFINE_FUNCTION(CK_RV, C_Decrypt)(
 	}
 
 	key = (struct hse_keyObject *)list_seek(&gCtx->object_list, &gCtx->cryptCtx.keyHandle);
+	if (key == NULL)
+		return CKR_KEY_HANDLE_INVALID;
+
+	if ((gCtx->cryptCtx.mechanism->mechanism == CKM_RSA_PKCS) || 
+		(gCtx->cryptCtx.mechanism->mechanism == CKM_RSA_PKCS_OAEP)) {
+		key_bit_length = hse_get_key_bit_length(key);
+		/* The input cipher text length should be equal to the key size */
+		if (ulEncryptedDataLen != (key_bit_length >> 3))
+			return CKR_ARGUMENTS_BAD;
+	}
 
 	input = hse_mem_alloc(ulEncryptedDataLen);
 	if (input == NULL)
@@ -341,6 +421,17 @@ CK_DEFINE_FUNCTION(CK_RV, C_Decrypt)(
 		(gCtx->cryptCtx.mechanism->mechanism == CKM_AES_GCM)) {
 		/* For AES, the output length is equal to the input length  */
 		hse_memcpy(output_len, &ulEncryptedDataLen, sizeof(uint32_t));
+		if (*(uint32_t *)output_len > *pulDataLen) {
+			/* tell the required size */
+			*pulDataLen = *(uint32_t *)output_len;
+
+			rc = CKR_BUFFER_TOO_SMALL;
+			goto err_free_output_len;
+		}
+	} else if ((gCtx->cryptCtx.mechanism->mechanism == CKM_RSA_PKCS) || 
+				(gCtx->cryptCtx.mechanism->mechanism == CKM_RSA_PKCS_OAEP)) {
+		/* to be safe, we allocate the max. length */
+		*(uint32_t *)output_len = rsa_ciphering_get_max_input_length(key_bit_length, gCtx->cryptCtx.mechanism);
 	}
 
 	output = hse_mem_alloc(*(uint32_t *)output_len);
@@ -350,12 +441,16 @@ CK_DEFINE_FUNCTION(CK_RV, C_Decrypt)(
 	}
 
 	if (gCtx->cryptCtx.mechanism->pParameter != NULL) {
-		pIV = hse_mem_alloc(gCtx->cryptCtx.mechanism->ulParameterLen);
-		if (pIV == NULL) {
-			rc = CKR_HOST_MEMORY;
-			goto err_free_output;
+		if (gCtx->cryptCtx.mechanism->mechanism == CKM_RSA_PKCS_OAEP) {
+			oaep_params = (CK_RSA_PKCS_OAEP_PARAMS *)gCtx->cryptCtx.mechanism->pParameter;
+		} else {
+			pIV = hse_mem_alloc(gCtx->cryptCtx.mechanism->ulParameterLen);
+			if (pIV == NULL) {
+				rc = CKR_HOST_MEMORY;
+				goto err_free_output;
+			}
+			hse_memcpy(pIV, gCtx->cryptCtx.mechanism->pParameter, gCtx->cryptCtx.mechanism->ulParameterLen);
 		}
-		hse_memcpy(pIV, gCtx->cryptCtx.mechanism->pParameter, gCtx->cryptCtx.mechanism->ulParameterLen);
 	}
 
 	if (gCtx->cryptCtx.mechanism->mechanism == CKM_AES_GCM) {
@@ -454,6 +549,37 @@ CK_DEFINE_FUNCTION(CK_RV, C_Decrypt)(
 
 			break;
 
+		case CKM_RSA_PKCS:
+			rsa_cipher_srv = &srv_desc.hseSrv.rsaCipherReq;
+
+			srv_desc.srvId = HSE_SRV_ID_RSA_CIPHER;
+			rsa_cipher_srv->cipherDir = HSE_CIPHER_DIR_DECRYPT;
+			rsa_cipher_srv->keyHandle = key->key_handle;
+			rsa_cipher_srv->inputLength = ulEncryptedDataLen;
+			rsa_cipher_srv->pInput = hse_virt_to_dma(input);
+			rsa_cipher_srv->pOutputLength = hse_virt_to_dma(output_len);
+			rsa_cipher_srv->pOutput = hse_virt_to_dma(output);
+
+			rsa_cipher_srv->rsaScheme.rsaAlgo = HSE_RSA_ALGO_RSAES_PKCS1_V15;
+			break;
+
+		case CKM_RSA_PKCS_OAEP:
+			rsa_cipher_srv = &srv_desc.hseSrv.rsaCipherReq;
+
+			srv_desc.srvId = HSE_SRV_ID_RSA_CIPHER;
+			rsa_cipher_srv->cipherDir = HSE_CIPHER_DIR_DECRYPT;
+			rsa_cipher_srv->keyHandle = key->key_handle;
+			rsa_cipher_srv->inputLength = ulEncryptedDataLen;
+			rsa_cipher_srv->pInput = hse_virt_to_dma(input);
+			rsa_cipher_srv->pOutputLength = hse_virt_to_dma(output_len);
+			rsa_cipher_srv->pOutput = hse_virt_to_dma(output);
+
+			rsa_cipher_srv->rsaScheme.rsaAlgo = HSE_RSA_ALGO_RSAES_OAEP;
+			rsa_cipher_srv->rsaScheme.sch.rsaOAEP.hashAlgo = hse_get_hash_alg(oaep_params->hashAlg);
+			rsa_cipher_srv->rsaScheme.sch.rsaOAEP.labelLength = 0;
+			rsa_cipher_srv->rsaScheme.sch.rsaOAEP.pLabel = 0;
+			break;
+
 		default:
 			rc = CKR_ARGUMENTS_BAD;
 			goto err_free_tag;
@@ -465,6 +591,18 @@ CK_DEFINE_FUNCTION(CK_RV, C_Decrypt)(
 		goto err_free_tag;
 	}
 
+	/* check for output buffer length */
+	if ((gCtx->cryptCtx.mechanism->mechanism == CKM_RSA_PKCS) || 
+		(gCtx->cryptCtx.mechanism->mechanism == CKM_RSA_PKCS_OAEP)) {
+		if (*(uint32_t *)output_len > *pulDataLen) {
+			/* tell the required size */
+			*pulDataLen = *(uint32_t *)output_len;
+
+			rc = CKR_BUFFER_TOO_SMALL;
+			goto err_free_output_len;
+		}
+	}
+
 	hse_memcpy(pData, output, *(uint32_t *)output_len);
 	hse_memcpy(pulDataLen, output_len, sizeof(uint32_t));
 
diff --git a/libpkcs/pkcs11_object.c b/libpkcs/pkcs11_object.c
index 284b79d..ef56c95 100644
--- a/libpkcs/pkcs11_object.c
+++ b/libpkcs/pkcs11_object.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: BSD-3-Clause
 /*
- * Copyright 2021-2022 NXP
+ * Copyright 2021-2023 NXP
  */
 
 #include <stdio.h>
@@ -225,7 +225,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_CreateObject)(
 			hse_memcpy(pkey1, getattr_pval(pTemplate, CKA_PUBLIC_EXPONENT, ulCount), pkey1_len);
 
 			/* rsa can be used for sign/verify */
-			key_info->keyFlags = HSE_KF_USAGE_VERIFY;
+			key_info->keyFlags = HSE_KF_USAGE_VERIFY | HSE_KF_USAGE_ENCRYPT;
 			key_info->keyBitLen = pkey0_len * 8;
 			key_info->specific.pubExponentSize = pkey1_len;
 			key_info->keyType = HSE_KEY_TYPE_RSA_PUB;
@@ -251,7 +251,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_CreateObject)(
 				}
 				hse_memcpy(pkey2, getattr_pval(pTemplate, CKA_PRIVATE_EXPONENT, ulCount), pkey2_len);
 
-				key_info->keyFlags |= HSE_KF_USAGE_SIGN;
+				key_info->keyFlags = HSE_KF_USAGE_SIGN | HSE_KF_USAGE_DECRYPT;
 				key_info->keyType = HSE_KEY_TYPE_RSA_PAIR;
 
 				import_key_req->pKey[2] = hse_virt_to_dma(pkey2); /* private exponent */
diff --git a/libpkcs/pkcs11_util.c b/libpkcs/pkcs11_util.c
new file mode 100644
index 0000000..22551ae
--- /dev/null
+++ b/libpkcs/pkcs11_util.c
@@ -0,0 +1,150 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright 2023 NXP
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+
+#include "pkcs11_context.h"
+#include "hse-internal.h"
+
+#define CEIL_MOD_8(x)		(((x) + 7) >> 3)
+
+static int hse_get_key_info(hseKeyHandle_t key_handle, hseKeyInfo_t *info)
+{
+	int err;
+	DECLARE_SET_ZERO(hseSrvDescriptor_t, srv_desc);
+	hseGetKeyInfoSrv_t *get_key_info_srv;
+
+	if (NULL == info)
+		return -1;
+	
+	get_key_info_srv = &srv_desc.hseSrv.getKeyInfoReq;
+
+	srv_desc.srvId = HSE_SRV_ID_GET_KEY_INFO;
+	get_key_info_srv->keyHandle = key_handle;
+	get_key_info_srv->pKeyInfo = hse_virt_to_dma(info);
+
+	err = hse_srv_req_sync(HSE_CHANNEL_ANY, &srv_desc, sizeof(srv_desc));
+	if (err) 
+		return -1;
+
+	return 0;
+}
+
+uint16_t hse_get_key_bit_length(struct hse_keyObject *key)
+{
+	hseKeyInfo_t *info;
+	uint16_t bit_length;
+	int err;
+
+	info = hse_mem_alloc(sizeof(hseKeyInfo_t));
+	if (info == NULL) 
+		return 0;
+
+	err = hse_get_key_info(key->key_handle, info);
+	if (err) {
+		hse_mem_free(info);
+		return 0;
+	}
+
+	bit_length = info->keyBitLen;
+
+	hse_mem_free(info);
+
+	return bit_length;
+}
+
+uint32_t rsa_ciphering_get_max_input_length(uint16_t rsa_key_length_bit, CK_MECHANISM_PTR mechanism)
+{
+	uint32_t max_input_bytes = 0;
+	uint16_t digest_size = 0;
+	CK_RSA_PKCS_OAEP_PARAMS *oaep_params;
+
+	if (mechanism->mechanism == CKM_RSA_PKCS) {
+		/* HSE FW RM: Maximum input message size (RSA encryption with PKCS1 V1.5 encoding) */
+		max_input_bytes = (uint32_t)CEIL_MOD_8(rsa_key_length_bit) - 11;
+	} else if (mechanism->mechanism == CKM_RSA_PKCS_OAEP) {
+		oaep_params = (CK_RSA_PKCS_OAEP_PARAMS *)mechanism->pParameter;
+		if (NULL != oaep_params) {
+			switch (oaep_params->hashAlg) {
+				case CKM_SHA_1:
+					digest_size = 160;
+					break;
+				case CKM_SHA256:
+				case CKM_SHA3_256:
+					digest_size = 256;
+					break;
+				case CKM_SHA224:
+				case CKM_SHA3_224:
+					digest_size = 224;
+					break;
+				case CKM_SHA384:
+				case CKM_SHA3_384:
+					digest_size = 384;
+					break;
+				case CKM_SHA512:
+				case CKM_SHA3_512:
+					digest_size = 512;
+					break;
+				default:
+					return 0;
+			}
+		}
+		/* HSE FW RM: Maximum of input message (RSA encryption with OAEP encoding) */
+		max_input_bytes = (uint32_t)(CEIL_MOD_8(rsa_key_length_bit) - 2 * CEIL_MOD_8(digest_size) - 2);
+	} else {
+		return 0;
+	}
+
+	return max_input_bytes;
+}
+
+uint32_t rsa_ciphering_get_out_length(uint16_t rsa_key_length_bit)
+{
+	/* cipher text size is equal to the key length */
+	return rsa_key_length_bit >> 3;
+}
+
+hseHashAlgo_t hse_get_hash_alg(CK_MECHANISM_TYPE mechanism)
+{
+	hseHashAlgo_t hash = HSE_HASH_ALGO_NULL;
+
+	switch (mechanism) {
+		case CKM_SHA_1:
+			hash = HSE_HASH_ALGO_SHA_1;
+			break;
+		case CKM_SHA256:
+			hash = HSE_HASH_ALGO_SHA2_256;
+			break;
+		case CKM_SHA3_256:
+			hash = HSE_HASH_ALGO_SHA3_256;
+			break;
+		case CKM_SHA224:
+			hash = HSE_HASH_ALGO_SHA2_224;
+			break;
+		case CKM_SHA3_224:
+			hash = HSE_HASH_ALGO_SHA3_224;
+			break;
+		case CKM_SHA384:
+			hash = HSE_HASH_ALGO_SHA2_384;
+			break;
+		case CKM_SHA3_384:
+			hash = HSE_HASH_ALGO_SHA3_384;
+			break;
+		case CKM_SHA512:
+			hash = HSE_HASH_ALGO_SHA2_512;
+			break;
+		case CKM_SHA3_512:
+			hash = HSE_HASH_ALGO_SHA3_512;
+			break;
+		default:
+			return HSE_HASH_ALGO_NULL;
+	}
+
+	return hash;
+}
+
diff --git a/libpkcs/pkcs11_util.h b/libpkcs/pkcs11_util.h
new file mode 100644
index 0000000..20db230
--- /dev/null
+++ b/libpkcs/pkcs11_util.h
@@ -0,0 +1,16 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright 2023 NXP
+ */
+
+#ifndef __PKCS11_UTIL_H__
+#define __PKCS11_UTIL_H__
+
+uint16_t hse_get_key_bit_length(struct hse_keyObject *key);
+
+hseHashAlgo_t hse_get_hash_alg(CK_MECHANISM_TYPE mechanism);
+
+uint32_t rsa_ciphering_get_max_input_length(uint16_t rsa_key_length_bit, CK_MECHANISM_PTR mechanism);
+uint32_t rsa_ciphering_get_out_length(uint16_t rsa_key_length_bit);
+
+#endif
-- 
2.25.1

