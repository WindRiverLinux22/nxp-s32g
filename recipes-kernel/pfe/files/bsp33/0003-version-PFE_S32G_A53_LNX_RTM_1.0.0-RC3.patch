From 7b13a54ccb5f75318ae79117a7d528d8d36c4531 Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@nxp.com>
Date: Thu, 2 Jun 2022 14:18:34 +0300
Subject: [PATCH 3/3] version PFE_S32G_A53_LNX_RTM_1.0.0 RC3

pfe.git: 865b4a28f0373c77c6e2177568cdf9f62bf10e9b

Upstream-Status: Pending 

Signed-off-by: Claudiu Manoil <claudiu.manoil@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 sw/build_env.mak                              |    9 +-
 sw/elf/public/elf.h                           |   13 +-
 sw/elf/src/elf.c                              |  453 +--
 sw/fci/src/fci.c                              |  761 ++---
 sw/fci/src/fci_connections.c                  | 1829 ++++++-----
 sw/fci/src/fci_flexible_filter.c              |  149 +-
 sw/fci/src/fci_fp.c                           |  479 +--
 sw/fci/src/fci_fp_db.c                        | 1272 ++++----
 sw/fci/src/fci_fw_features.c                  |  235 +-
 sw/fci/src/fci_interfaces.c                   | 2386 +++++++-------
 sw/fci/src/fci_l2br.c                         |   74 +-
 sw/fci/src/fci_l2br_domains.c                 |  936 +++---
 sw/fci/src/fci_mirror.c                       |  672 ++--
 sw/fci/src/fci_qos.c                          | 2348 +++++++-------
 sw/fci/src/fci_routes.c                       |  533 +--
 sw/fci/src/fci_rt_db.c                        |  370 +--
 sw/fci/src/fci_spd.c                          |  333 +-
 sw/libfci_cli/Makefile                        |    2 +-
 .../src/libfci_cli_cmds_route_and_cntk.c      |   28 +-
 sw/libfci_cli/src/libfci_cli_common.h         |    4 +-
 sw/libfci_cli/src/libfci_demo/demo_rt_ct.c    |  106 +-
 sw/libfci_cli/src/libfci_demo/demo_rt_ct.h    |   14 +-
 sw/linux-pfeng/Makefile                       |    5 -
 sw/linux-pfeng/pfeng-drv.c                    |   28 +-
 sw/linux-pfeng/pfeng-dt.c                     |   11 +-
 sw/linux-pfeng/pfeng-ethtool.c                |    2 +-
 sw/linux-pfeng/pfeng-hif.c                    |    4 +-
 sw/linux-pfeng/pfeng-hwts.c                   |   47 +-
 sw/linux-pfeng/pfeng-netif.c                  |  129 +-
 sw/linux-pfeng/pfeng-phylink.c                |   36 +-
 sw/linux-pfeng/pfeng.h                        |   30 +-
 sw/oal/src/oal_mm_linux.c                     |  104 +-
 sw/pfe_hif_drv/public/pfe_hif_drv.h           |   24 +
 sw/pfe_platform/hw/s32g/pfe_bmu_csr.c         |   89 +-
 sw/pfe_platform/hw/s32g/pfe_class_csr.c       |  471 +--
 sw/pfe_platform/hw/s32g/pfe_emac_csr.c        |  756 +++--
 sw/pfe_platform/hw/s32g/pfe_gpi_csr.c         |  143 +-
 sw/pfe_platform/hw/s32g/pfe_hif_csr.c         |  508 +--
 sw/pfe_platform/hw/s32g/pfe_hif_nocpy_csr.c   |   56 +-
 sw/pfe_platform/hw/s32g/pfe_platform_master.c | 2880 +++++++++--------
 sw/pfe_platform/hw/s32g/pfe_platform_slave.c  |   18 +-
 sw/pfe_platform/hw/s32g/pfe_tmu_csr.c         |  724 +++--
 sw/pfe_platform/hw/s32g/pfe_tmu_csr.h         |    2 +-
 sw/pfe_platform/hw/s32g/pfe_util_csr.c        |   27 +-
 sw/pfe_platform/hw/s32g/pfe_wdt_csr.c         |   50 +-
 sw/pfe_platform/public/pfe_class.h            |    4 +-
 sw/pfe_platform/public/pfe_ct.h               |   37 +-
 sw/pfe_platform/public/pfe_gpi.h              |    1 +
 sw/pfe_platform/public/pfe_hif_chnl_linux.h   |   15 +-
 sw/pfe_platform/public/pfe_hif_nocpy.h        |    4 +-
 sw/pfe_platform/public/pfe_hif_ring_linux.h   |    1 -
 sw/pfe_platform/public/pfe_platform.h         |    1 +
 sw/pfe_platform/public/pfe_platform_cfg.h     |   11 +-
 sw/pfe_platform/public/pfe_rtable.h           |    1 +
 sw/pfe_platform/src/pfe_bmu.c                 |  304 +-
 sw/pfe_platform/src/pfe_class.c               | 1497 +++++----
 sw/pfe_platform/src/pfe_emac.c                | 1290 ++++----
 sw/pfe_platform/src/pfe_feature_mgr.c         | 1337 ++++----
 sw/pfe_platform/src/pfe_flexible_filter.c     |   38 +-
 sw/pfe_platform/src/pfe_fp.c                  |   32 +-
 sw/pfe_platform/src/pfe_fw_feature.c          |  263 +-
 sw/pfe_platform/src/pfe_gpi.c                 |  274 +-
 sw/pfe_platform/src/pfe_hif_chnl_linux.c      |  922 +-----
 sw/pfe_platform/src/pfe_hif_nocpy.c           |    6 +-
 sw/pfe_platform/src/pfe_hif_ring_linux.c      |  666 +---
 sw/pfe_platform/src/pfe_hw_feature.c          |   12 +
 sw/pfe_platform/src/pfe_idex.c                |    6 +-
 sw/pfe_platform/src/pfe_pe.c                  |   37 +-
 sw/pfe_platform/src/pfe_rtable.c              |   20 +
 sw/xfci/libfci/public/fpp.h                   |   20 +-
 sw/xfci/libfci/src/libfci_linux.c             |   19 +-
 71 files changed, 13018 insertions(+), 12950 deletions(-)

diff --git a/sw/build_env.mak b/sw/build_env.mak
index 7f1e8f2..f4fa1d4 100644
--- a/sw/build_env.mak
+++ b/sw/build_env.mak
@@ -90,8 +90,6 @@ export PFE_CFG_IEEE1588_I_CLK_HZ?=0
 export PFE_CFG_IEEE1588_EMAC0_O_CLK_HZ?=0
 export PFE_CFG_IEEE1588_EMAC1_O_CLK_HZ?=0
 export PFE_CFG_IEEE1588_EMAC2_O_CLK_HZ?=0
-#enable reserved memory for the Slave driver
-export PFE_CFG_LINUX_RES_MEM_ENABLE?=0
 #PFE system buffers location
 export PFE_CFG_SYS_MEM?="pfe_ddr"
 #Buffer descriptors location
@@ -123,6 +121,8 @@ export PFE_CFG_HIF_RING_LENGTH?=256
 export PFE_CFG_SLAVE_HIF_MASTER_UP_TMOUT?=1000
 #Number of milisecs to wait by Slave until IP ready flag set by Master
 export PFE_CFG_IP_READY_MS_TMOUT?=5000
+#HIF used to process PTP traffic in bridge mode (see pfe_ct_phy_if_id_t, configuration is enabled when set to valid HIF id)
+export PFE_CFG_PTP_COMMON_HIF?=0
 
 ifeq ($(PFE_CFG_HIF_DRV_MODE),0)
   #Use multi-client HIF driver. Required when multiple logical interfaces need to
@@ -216,10 +216,6 @@ ifneq ($(PFE_CFG_MULTI_INSTANCE_SUPPORT),0)
     GLOBAL_CCFLAGS+=-DPFE_CFG_ERR051211_WORKAROUND_ENABLE
 endif
 
-ifneq ($(PFE_CFG_LINUX_RES_MEM_ENABLE),0)
-    GLOBAL_CCFLAGS+=-DPFE_CFG_LINUX_RES_MEM_ENABLE
-endif
-
 ifneq ($(PFE_CFG_PFE_MASTER),0)
     GLOBAL_CCFLAGS+=-DPFE_CFG_PFE_MASTER
 else
@@ -234,6 +230,7 @@ GLOBAL_CCFLAGS+=-DPFE_CFG_PFE2_IF=$(PFE_CFG_PFE2_IF)
 GLOBAL_CCFLAGS+=-DPFE_CFG_PFE0_PROMISC=$(PFE_CFG_PFE0_PROMISC)
 GLOBAL_CCFLAGS+=-DPFE_CFG_PFE1_PROMISC=$(PFE_CFG_PFE1_PROMISC)
 GLOBAL_CCFLAGS+=-DPFE_CFG_PFE2_PROMISC=$(PFE_CFG_PFE2_PROMISC)
+GLOBAL_CCFLAGS+=-DPFE_CFG_PTP_COMMON_HIF=$(PFE_CFG_PTP_COMMON_HIF)
 
 ifneq ($(PFE_CFG_HIF_NOCPY_SUPPORT),0)
   ifeq ($(TARGET_OS),QNX)
diff --git a/sw/elf/public/elf.h b/sw/elf/public/elf.h
index dd029f3..b70bfa3 100644
--- a/sw/elf/public/elf.h
+++ b/sw/elf/public/elf.h
@@ -63,6 +63,17 @@
 ==================================================================================================*/
 #define ELF_NIDENT                  16U
 #define ELF_NAMED_SECT_IDX_FLAG     0x80000000U
+
+/* Macros for change of endianness */
+#define ENDIAN_SW_2B(VAL) ( (((VAL)&0xFF00U)>>8U) | (((VAL)&0x00FFU)<<8U) )
+#define ENDIAN_SW_4B(VAL) ( (((VAL)&0xFF000000U)>>24U) | (((VAL)&0x000000FFU)<<24U) \
+                          | (((VAL)&0x00FF0000U)>>8U) | (((VAL)&0x0000FF00U)<<8U) \
+                          )
+#define ENDIAN_SW_8B(VAL) ( (((VAL)&0xFF00000000000000U)>>56U) | (((VAL)&0x00000000000000FFU)<<56U) \
+                          | (((VAL)&0x00FF000000000000U)>>40U) | (((VAL)&0x000000000000FF00U)<<40U) \
+                          | (((VAL)&0x0000FF0000000000U)>>24U) | (((VAL)&0x0000000000FF0000U)<<24U) \
+                          | (((VAL)&0x000000FF00000000U)>>8U ) | (((VAL)&0x00000000FF000000U)<<8U ) \
+                          )
 /*==================================================================================================
                                              ENUMS
 ==================================================================================================*/
@@ -244,7 +255,7 @@ typedef struct __attribute__((packed))
 /*==================================================================================================
                                      FUNCTION PROTOTYPES
 ==================================================================================================*/
-extern bool_t ELF_Open(ELF_File_t *pElfFile, void *pvFile, uint32_t u32FileSize);
+extern bool_t ELF_Open(ELF_File_t *pElfFile,void *pvFile, uint32_t u32FileSize);
 extern void ELF_Close(ELF_File_t *pElfFile);
 
 #if TRUE == ELF_CFG_PROGRAM_TABLE_USED
diff --git a/sw/elf/src/elf.c b/sw/elf/src/elf.c
index ef42f95..3b5d358 100644
--- a/sw/elf/src/elf.c
+++ b/sw/elf/src/elf.c
@@ -60,26 +60,9 @@
 #define ELF32_HEADER_SIZE 52U
 #define SHN_UNDEF       0U    /* Undefined/Not present */
 
-/* Macros for change of endianness */
-#define ENDIAN_SW_2B(VAL) ( (((VAL)&0xFF00U)>>8U) | (((VAL)&0x00FFU)<<8U) )
-#define ENDIAN_SW_4B(VAL) ( (((VAL)&0xFF000000U)>>24U) | (((VAL)&0x000000FFU)<<24U) \
-                          | (((VAL)&0x00FF0000U)>>8U) | (((VAL)&0x0000FF00U)<<8U) \
-                          )
-#define ENDIAN_SW_8B(VAL) ( (((VAL)&0xFF00000000000000U)>>56U) | (((VAL)&0x00000000000000FFU)<<56U) \
-                          | (((VAL)&0x00FF000000000000U)>>40U) | (((VAL)&0x000000000000FF00U)<<40U) \
-                          | (((VAL)&0x0000FF0000000000U)>>24U) | (((VAL)&0x0000000000FF0000U)<<24U) \
-                          | (((VAL)&0x000000FF00000000U)>>8U ) | (((VAL)&0x00000000FF000000U)<<8U ) \
-                          )
-
 /*==================================================================================================
                           LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
 ==================================================================================================*/
-typedef enum
-{
-    ELF_Endian_Little = 1,
-    ELF_Endian_Big    = 2,
-} ELF_Endian_t;
-
 enum
 {
     ELF_Type_Relocatable = 1U,
@@ -187,14 +170,12 @@ enum
 ==================================================================================================*/
 /* GENERAL */
 static bool_t LoadFileData(const ELF_File_t *pElfFile, uint32_t u32Offset, uint32_t u32Size, void *pvDestMem);
-static inline ELF_Endian_t GetLocalEndian(void);
 /* ELF64 */
 #if TRUE == ELF_CFG_ELF64_SUPPORTED
-    static bool_t ELF64_LoadTables(ELF_File_t *pElfFile, bool_t bIsCrosEndian);
+    static bool_t ELF64_LoadTables(ELF_File_t *pElfFile);
     static void ELF64_HeaderSwitchEndianness(Elf64_Ehdr *prElf64Header);
-    static bool_t ELF64_Load(bool_t bIsCrosEndian,ELF_File_t *pElfFile,uint32_t *u32NamesSectionOffset,uint32_t *u32NamesSectionSize);
-    static void ELF64_ProgTabSwitchEndianness(Elf64_Phdr *arProgHead64, uint32_t u32NumItems);
-    static void ELF64_SectTabSwitchEndianness(Elf64_Shdr *arSectHead64, uint32_t u32NumItems);
+    static bool_t ELF64_Load(ELF_File_t *pElfFile,uint32_t *u32NamesSectionOffset,uint32_t *u32NamesSectionSize);
+
     #if TRUE == ELF_CFG_PROGRAM_TABLE_USED
         static bool_t ELF64_ProgSectFindNext( ELF_File_t *pElfFile, uint32_t *pu32ProgIdx,
                                                uint64_t *pu64LoadVAddr, uint64_t *pu64LoadPAddr, uint64_t *pu64Length
@@ -217,11 +198,10 @@ static inline ELF_Endian_t GetLocalEndian(void);
 #endif /* ELF_CFG_ELF64_SUPPORTED */
 /* ELF32 */
 #if TRUE == ELF_CFG_ELF32_SUPPORTED
-    static bool_t ELF32_LoadTables(ELF_File_t *pElfFile, bool_t bIsCrosEndian);
+    static bool_t ELF32_LoadTables(ELF_File_t *pElfFile);
     static void ELF32_HeaderSwitchEndianness(Elf32_Ehdr *prElf32Header);
-    static bool_t ELF32_Load(bool_t bIsCrosEndian,ELF_File_t *pElfFile,uint32_t *u32NamesSectionOffset,uint32_t *u32NamesSectionSize);
-    static void ELF32_ProgTabSwitchEndianness(Elf32_Phdr *arProgHead32, uint32_t u32NumItems);
-    static void ELF32_SectTabSwitchEndianness(Elf32_Shdr *arSectHead32, uint32_t u32NumItems);
+    static bool_t ELF32_Load(ELF_File_t *pElfFile,uint32_t *u32NamesSectionOffset,uint32_t *u32NamesSectionSize);
+
     #if TRUE == ELF_CFG_PROGRAM_TABLE_USED
         static bool_t ELF32_ProgSectFindNext( ELF_File_t *pElfFile, uint32_t *pu32ProgIdx,
                                                uint64_t *pu64LoadVAddr, uint64_t *pu64LoadPAddr, uint64_t *pu64Length
@@ -243,7 +223,7 @@ static inline ELF_Endian_t GetLocalEndian(void);
     #endif /* ELF_CFG_SECTION_PRINT_ENABLED */
 #endif /* ELF_CFG_ELF32_SUPPORTED */
 
-static uint32_t buf_read(void *src_buf, uint32_t u32FileSize, uint32_t u32Offset, void *dst_buf, uint32_t nbytes);
+static uint32_t buf_read(const void *src_buf, uint32_t u32FileSize, uint32_t u32Offset, void *dst_buf, uint32_t nbytes);
 static void ELF_FreePtr(ELF_File_t *pElfFile);
 static bool_t ELF_LoadTables(ELF_File_t *pElfFile, uint32_t *u32NamesSectionOffset, uint32_t *u32NamesSectionSize);
 
@@ -292,31 +272,10 @@ static bool_t LoadFileData(const ELF_File_t *pElfFile, uint32_t u32Offset, uint3
     return bSuccess;
 }
 
-/*================================================================================================*/
-/**
-* @brief        Determines endianess of the machine it is running on.
-* @return       The endianness.
-*/
-static inline ELF_Endian_t GetLocalEndian(void)
-{
-    ELF_Endian_t RetEndian = ELF_Endian_Big;
-    union
-    {
-        uint32_t u32Value;
-        uint8_t  au8Values[4U];
-    } TheUnion;
-    TheUnion.u32Value = 1U;
-    if(TheUnion.au8Values[0U] == 1U)
-    {
-        RetEndian = ELF_Endian_Little;
-    }
-    return RetEndian;
-}
-
 
 #if TRUE == ELF_CFG_ELF32_SUPPORTED
 /*================================================================================================*/
-static bool_t ELF32_LoadTables(ELF_File_t *pElfFile, bool_t bIsCrosEndian)
+static bool_t ELF32_LoadTables(ELF_File_t *pElfFile)
 {
     bool_t bProgStatus = TRUE;
     bool_t bSectStatus = FALSE;
@@ -348,12 +307,6 @@ static bool_t ELF32_LoadTables(ELF_File_t *pElfFile, bool_t bIsCrosEndian)
     {
         /* Save the pointer */
         pElfFile->arProgHead32 = (Elf32_Phdr *)(((uint8_t*)pElfFile->pvData) + pElfFile->Header.r32.e_phoff);
-
-        /* Now handle endianness */
-        if (bIsCrosEndian)
-        {
-            ELF32_ProgTabSwitchEndianness(pElfFile->arProgHead32, pElfFile->Header.r32.e_phnum);
-        }
         bProgStatus = TRUE;
     }
   #endif /* ELF_CFG_PROGRAM_TABLE_USED */
@@ -380,11 +333,6 @@ static bool_t ELF32_LoadTables(ELF_File_t *pElfFile, bool_t bIsCrosEndian)
     {
         /* Save the pointer */
         pElfFile->arSectHead32 = (Elf32_Shdr *)(((uint8_t*)pElfFile->pvData) + pElfFile->Header.r32.e_shoff);
-        /* Now handle endianness */
-        if (bIsCrosEndian)
-        {
-            ELF32_SectTabSwitchEndianness(pElfFile->arSectHead32, pElfFile->Header.r32.e_shnum);
-        }
         bSectStatus = TRUE;
     }
   #else /* ELF_CFG_SECTION_TABLE_USED */
@@ -419,40 +367,40 @@ static void ELF32_HeaderSwitchEndianness(Elf32_Ehdr *prElf32Header)
     prElf32Header->e_shstrndx   = ENDIAN_SW_2B(prElf32Header->e_shstrndx);
 }
 
-static bool_t ELF32_Load(bool_t bIsCrosEndian,ELF_File_t *pElfFile,uint32_t *u32NamesSectionOffset,uint32_t *u32NamesSectionSize)
+static bool_t ELF32_Load(ELF_File_t *pElfFile,uint32_t *u32NamesSectionOffset,uint32_t *u32NamesSectionSize)
 {
     bool_t    bRetVal = FALSE;
 
-    if (bIsCrosEndian)
-    {
-        ELF32_HeaderSwitchEndianness(&(pElfFile->Header.r32));
-    }
+    ELF32_HeaderSwitchEndianness(&(pElfFile->Header.r32));
+
     if ((uint16_t)ELF_Type_Executable != pElfFile->Header.r32.e_type)
     {
         NXP_LOG_ERROR("ELF_Open: Only executable ELFs are supported\n");
     }
-    else if (FALSE == ELF32_LoadTables(pElfFile, bIsCrosEndian))
+    else if (FALSE == ELF32_LoadTables(pElfFile))
     {
         NXP_LOG_ERROR("ELF_Open: Failed to load tables\n");
     }
-    /* Endianness is now solved in all tables */
-#if TRUE == ELF_CFG_SECTION_TABLE_USED
-    /* Look for section names section */
-    else if ((pElfFile->Header.r32.e_shstrndx == SHN_UNDEF)
-          || (pElfFile->Header.r32.e_shstrndx >= pElfFile->Header.r32.e_shnum)
-          || (0U == pElfFile->arSectHead32[pElfFile->Header.r32.e_shstrndx].sh_size)
-           )
-    {
-        NXP_LOG_ERROR("ELF_Open: Section names not found\n");
-    }
     else
+#if TRUE == ELF_CFG_SECTION_TABLE_USED
     {
-        *u32NamesSectionOffset = pElfFile->arSectHead32[pElfFile->Header.r32.e_shstrndx].sh_offset;
-        *u32NamesSectionSize = pElfFile->arSectHead32[pElfFile->Header.r32.e_shstrndx].sh_size;
-        bRetVal = TRUE;
+        /* Look for section names section */
+        if ((pElfFile->Header.r32.e_shstrndx == SHN_UNDEF)
+            || (pElfFile->Header.r32.e_shstrndx >= pElfFile->Header.r32.e_shnum)
+            || (0U == ENDIAN_SW_4B(pElfFile->arSectHead32[pElfFile->Header.r32.e_shstrndx].sh_size))
+            )
+        {
+            NXP_LOG_ERROR("ELF_Open: Section names not found\n");
+        }
+        else
+        {
+
+            *u32NamesSectionOffset = ENDIAN_SW_4B(pElfFile->arSectHead32[pElfFile->Header.r32.e_shstrndx].sh_offset);
+            *u32NamesSectionSize = ENDIAN_SW_4B(pElfFile->arSectHead32[pElfFile->Header.r32.e_shstrndx].sh_size);
+			bRetVal = TRUE;
+        }
     }
 #else  /* ELF_CFG_SECTION_TABLE_USED */
-    else
     {
         bRetVal = TRUE;
     }
@@ -461,60 +409,6 @@ static bool_t ELF32_Load(bool_t bIsCrosEndian,ELF_File_t *pElfFile,uint32_t *u32
     return bRetVal;
 }
 
-/*================================================================================================*/
-static void ELF32_ProgTabSwitchEndianness(Elf32_Phdr *arProgHead32, uint32_t u32NumItems)
-{
-    uint32_t u32Idx;
-
-#if defined(PFE_CFG_NULL_ARG_CHECK)
-    if (unlikely(NULL == arProgHead32))
-    {
-        NXP_LOG_ERROR("NULL argument received\n");
-        return;
-    }
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-    for(u32Idx=0U; u32Idx<u32NumItems; u32Idx++)
-    {
-        arProgHead32[u32Idx].p_type   = ENDIAN_SW_4B(arProgHead32[u32Idx].p_type);
-        arProgHead32[u32Idx].p_offset = ENDIAN_SW_4B(arProgHead32[u32Idx].p_offset);
-        arProgHead32[u32Idx].p_vaddr  = ENDIAN_SW_4B(arProgHead32[u32Idx].p_vaddr);
-        arProgHead32[u32Idx].p_paddr  = ENDIAN_SW_4B(arProgHead32[u32Idx].p_paddr);
-        arProgHead32[u32Idx].p_filesz = ENDIAN_SW_4B(arProgHead32[u32Idx].p_filesz);
-        arProgHead32[u32Idx].p_memsz  = ENDIAN_SW_4B(arProgHead32[u32Idx].p_memsz);
-        arProgHead32[u32Idx].p_flags  = ENDIAN_SW_4B(arProgHead32[u32Idx].p_flags);
-        arProgHead32[u32Idx].p_align  = ENDIAN_SW_4B(arProgHead32[u32Idx].p_align);
-    }
-}
-
-/*================================================================================================*/
-static void ELF32_SectTabSwitchEndianness(Elf32_Shdr *arSectHead32, uint32_t u32NumItems)
-{
-    uint32_t u32Idx;
-
-#if defined(PFE_CFG_NULL_ARG_CHECK)
-    if (unlikely(NULL == arSectHead32))
-    {
-        NXP_LOG_ERROR("NULL argument received\n");
-        return;
-    }
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-    for(u32Idx=0U; u32Idx<u32NumItems; u32Idx++)
-    {
-        arSectHead32[u32Idx].sh_name      = ENDIAN_SW_4B(arSectHead32[u32Idx].sh_name);
-        arSectHead32[u32Idx].sh_type      = ENDIAN_SW_4B(arSectHead32[u32Idx].sh_type);
-        arSectHead32[u32Idx].sh_flags     = ENDIAN_SW_4B(arSectHead32[u32Idx].sh_flags);
-        arSectHead32[u32Idx].sh_addr      = ENDIAN_SW_4B(arSectHead32[u32Idx].sh_addr);
-        arSectHead32[u32Idx].sh_offset    = ENDIAN_SW_4B(arSectHead32[u32Idx].sh_offset);
-        arSectHead32[u32Idx].sh_size      = ENDIAN_SW_4B(arSectHead32[u32Idx].sh_size);
-        arSectHead32[u32Idx].sh_link      = ENDIAN_SW_4B(arSectHead32[u32Idx].sh_link);
-        arSectHead32[u32Idx].sh_info      = ENDIAN_SW_4B(arSectHead32[u32Idx].sh_info);
-        arSectHead32[u32Idx].sh_addralign = ENDIAN_SW_4B(arSectHead32[u32Idx].sh_addralign);
-        arSectHead32[u32Idx].sh_entsize   = ENDIAN_SW_4B(arSectHead32[u32Idx].sh_entsize);
-    }
-}
-
   #if TRUE == ELF_CFG_PROGRAM_TABLE_USED
 /*================================================================================================*/
 static bool_t ELF32_ProgSectFindNext( ELF_File_t *pElfFile, uint32_t *pu32ProgIdx,
@@ -535,8 +429,8 @@ static bool_t ELF32_ProgSectFindNext( ELF_File_t *pElfFile, uint32_t *pu32ProgId
         /* Find a record having RAM area */
         while (pElfFile->u32ProgScanIdx < pElfFile->Header.r32.e_phnum)
         {
-            if (((uint32_t)PT_LOAD == pElfFile->arProgHead32[pElfFile->u32ProgScanIdx].p_type) /* Has RAM area */
-                && (0U != pElfFile->arProgHead32[pElfFile->u32ProgScanIdx].p_memsz)      /* Size != 0 */
+            if (((uint32_t)PT_LOAD == ENDIAN_SW_4B(pElfFile->arProgHead32[pElfFile->u32ProgScanIdx].p_type)) /* Has RAM area */
+                && (0U != ENDIAN_SW_4B(pElfFile->arProgHead32[pElfFile->u32ProgScanIdx].p_memsz))      /* Size != 0 */
                 )
             {   /* Match found */
                 /* Set returned values */
@@ -546,15 +440,15 @@ static bool_t ELF32_ProgSectFindNext( ELF_File_t *pElfFile, uint32_t *pu32ProgId
                 }
                 if (NULL != pu64LoadVAddr)
                 {
-                    *pu64LoadVAddr = pElfFile->arProgHead32[pElfFile->u32ProgScanIdx].p_vaddr;
+                    *pu64LoadVAddr = ENDIAN_SW_4B((uint64_t)pElfFile->arProgHead32[pElfFile->u32ProgScanIdx].p_vaddr);
                 }
                 if (NULL != pu64LoadPAddr)
                 {
-                    *pu64LoadPAddr = pElfFile->arProgHead32[pElfFile->u32ProgScanIdx].p_paddr;
+                    *pu64LoadPAddr = ENDIAN_SW_4B((uint64_t)pElfFile->arProgHead32[pElfFile->u32ProgScanIdx].p_paddr);
                 }
                 if (NULL != pu64Length)
                 {
-                    *pu64Length = pElfFile->arProgHead32[pElfFile->u32ProgScanIdx].p_memsz;
+                    *pu64Length = ENDIAN_SW_4B((uint64_t)pElfFile->arProgHead32[pElfFile->u32ProgScanIdx].p_memsz);
                 }
                 bRetVal = TRUE;
                 pElfFile->u32ProgScanIdx++;
@@ -589,15 +483,15 @@ static bool_t ELF32_ProgSectLoad(const ELF_File_t *pElfFile, uint32_t u32ProgIdx
     {
         NXP_LOG_ERROR("ELF32_ProgSectLoad: Invalid program index: %u\n", (uint_t)u32ProgIdx);
     }
-    else if ((uint32_t)PT_LOAD != pElfFile->arProgHead32[u32ProgIdx].p_type)
+    else if ((uint32_t)PT_LOAD != ENDIAN_SW_4B(pElfFile->arProgHead32[u32ProgIdx].p_type))
     {
         NXP_LOG_ERROR("ELF32_ProgSectLoad: This section has no associated RAM area\n");
     }
-    else if (AllocSize < pElfFile->arProgHead32[u32ProgIdx].p_memsz)
+    else if (AllocSize < ENDIAN_SW_4B(pElfFile->arProgHead32[u32ProgIdx].p_memsz))
     {
         NXP_LOG_ERROR("ELF32_ProgSectLoad: Section does not fit to allocated memory\n");
     }
-    else if (pElfFile->arProgHead32[u32ProgIdx].p_filesz > pElfFile->arProgHead32[u32ProgIdx].p_memsz)
+    else if (ENDIAN_SW_4B(pElfFile->arProgHead32[u32ProgIdx].p_filesz) > ENDIAN_SW_4B(pElfFile->arProgHead32[u32ProgIdx].p_memsz))
     {
         NXP_LOG_ERROR("ELF32_ProgSectLoad: Section size mismatch.\n");
     }
@@ -607,11 +501,11 @@ static bool_t ELF32_ProgSectLoad(const ELF_File_t *pElfFile, uint32_t u32ProgIdx
         /* p_filesz bytes of data at the beginning of the memory area shall be copied from file
            the rest up to p_memsz bytes shal be set to 0
         */
-        if (0U != pElfFile->arProgHead32[u32ProgIdx].p_filesz)
+        if (0U != ENDIAN_SW_4B(pElfFile->arProgHead32[u32ProgIdx].p_filesz))
         {   /* Read from file */
             if (FALSE == LoadFileData(pElfFile, /* pElfFile, */
-                pElfFile->arProgHead32[u32ProgIdx].p_offset, /* u32Offset, */
-                pElfFile->arProgHead32[u32ProgIdx].p_filesz, /* u32Size, */
+                ENDIAN_SW_4B(pElfFile->arProgHead32[u32ProgIdx].p_offset), /* u32Offset, */
+                ENDIAN_SW_4B(pElfFile->arProgHead32[u32ProgIdx].p_filesz), /* u32Size, */
                 (void *)AccessAddr /* pvDestMem */
             )
                 )
@@ -630,12 +524,12 @@ static bool_t ELF32_ProgSectLoad(const ELF_File_t *pElfFile, uint32_t u32ProgIdx
 
         /* Pad rest with zeros */
         if ((TRUE == bSuccess)
-         && (pElfFile->arProgHead32[u32ProgIdx].p_memsz > pElfFile->arProgHead32[u32ProgIdx].p_filesz)
+         && (ENDIAN_SW_4B(pElfFile->arProgHead32[u32ProgIdx].p_memsz) > ENDIAN_SW_4B(pElfFile->arProgHead32[u32ProgIdx].p_filesz))
             )
         {
-            (void)memset((void *)(AccessAddr + pElfFile->arProgHead32[u32ProgIdx].p_filesz),
+            (void)memset((void *)(AccessAddr + ENDIAN_SW_4B(pElfFile->arProgHead32[u32ProgIdx].p_filesz)),
                     0,
-                    pElfFile->arProgHead32[u32ProgIdx].p_memsz - pElfFile->arProgHead32[u32ProgIdx].p_filesz
+                    ENDIAN_SW_4B(pElfFile->arProgHead32[u32ProgIdx].p_memsz) - ENDIAN_SW_4B(pElfFile->arProgHead32[u32ProgIdx].p_filesz)
                   );
         }
     }
@@ -666,7 +560,7 @@ static bool_t ELF32_SectFindName( const ELF_File_t *pElfFile, const char_t *szSe
         /* Search section table */
         for (SectIdx = 0U; SectIdx < pElfFile->Header.r32.e_shnum; SectIdx++)
         {
-            if (0 == strcmp((char_t *)(pElfFile->acSectNames + pElfFile->arSectHead32[SectIdx].sh_name), szSectionName))
+            if (0 == strcmp((char_t *)(pElfFile->acSectNames + ENDIAN_SW_4B(pElfFile->arSectHead32[SectIdx].sh_name)), szSectionName))
             {   /* Found */
                 if (NULL != pu32SectIdx)
                 {
@@ -674,11 +568,11 @@ static bool_t ELF32_SectFindName( const ELF_File_t *pElfFile, const char_t *szSe
                 }
                 if (NULL != pu64Length)
                 {
-                    *pu64Length = pElfFile->arSectHead32[SectIdx].sh_size;
+                    *pu64Length = ENDIAN_SW_4B((uint64_t)pElfFile->arSectHead32[SectIdx].sh_size);
                 }
                 if (NULL != pu64LoadAddr)
                 {
-                    *pu64LoadAddr = pElfFile->arSectHead32[SectIdx].sh_addr;
+                    *pu64LoadAddr = ENDIAN_SW_4B((uint64_t)pElfFile->arSectHead32[SectIdx].sh_addr);
                 }
                 bFound = TRUE;
                 bRetVal = TRUE;
@@ -711,23 +605,23 @@ static bool_t ELF32_SectLoad(const ELF_File_t *pElfFile, uint32_t u32SectIdx, ad
     {
         NXP_LOG_ERROR("ELF32_SectLoad: Invalid section index: %u\n", (uint_t)u32SectIdx);
     }
-    else if (AllocSize < pElfFile->arSectHead32[u32SectIdx].sh_size)
+    else if (AllocSize < ENDIAN_SW_4B(pElfFile->arSectHead32[u32SectIdx].sh_size))
     {
         NXP_LOG_ERROR("ELF32_SectLoad: Section does not fit to allocated memory\n");
     }
     /* LOAD */
     else
     {   /* All OK */
-        if ((uint32_t)SHT_NOBITS == pElfFile->arSectHead32[u32SectIdx].sh_type)
+        if ((uint32_t)SHT_NOBITS == ENDIAN_SW_4B(pElfFile->arSectHead32[u32SectIdx].sh_type))
         {   /* Fill with zeros */
-            (void)memset((void *)AccessAddr, 0, pElfFile->arSectHead32[u32SectIdx].sh_size);
+            (void)memset((void *)AccessAddr, 0, ENDIAN_SW_4B(pElfFile->arSectHead32[u32SectIdx].sh_size));
             bSuccess = TRUE;
         }
         else
         {   /* Copy from file */
             if (FALSE == LoadFileData(pElfFile, /* pElfFile, */
-                                      pElfFile->arSectHead32[u32SectIdx].sh_offset, /* u32Offset, */
-                                      pElfFile->arSectHead32[u32SectIdx].sh_size, /* u32Size, */
+                                      ENDIAN_SW_4B(pElfFile->arSectHead32[u32SectIdx].sh_offset), /* u32Offset, */
+                                      ENDIAN_SW_4B(pElfFile->arSectHead32[u32SectIdx].sh_size), /* u32Size, */
                                       (void *)AccessAddr /* pvDestMem */
                                       )
             )
@@ -776,24 +670,24 @@ static void ELF32_PrintSections(const ELF_File_t *pElfFile)
         NXP_LOG_INFO("     SectionName    Type        FileOffset    FileSize      LoadAddress   Flags\n");
         for (SectIdx = 0U; SectIdx < pElfFile->Header.r32.e_shnum; SectIdx++)
         {
-            uint32_t u32Type = pElfFile->arSectHead32[SectIdx].sh_type;
+            uint32_t u32Type = ENDIAN_SW_4B(pElfFile->arSectHead32[SectIdx].sh_type);
             uint32_t u32FlagIdx;
 
             if (u32Type >= 16U)
             {
                 u32Type = 16U; /* Undefined */
             }
-            NXP_LOG_INFO("%16s", pElfFile->acSectNames + pElfFile->arSectHead32[SectIdx].sh_name);
+            NXP_LOG_INFO("%16s", pElfFile->acSectNames + ENDIAN_SW_4B(pElfFile->arSectHead32[SectIdx].sh_name));
             NXP_LOG_INFO("%12s    0x%08x    0x%08x    0x%08x    ",
                         aacSTypes[u32Type],
-                        (uint_t)pElfFile->arSectHead32[SectIdx].sh_offset,
-                        (uint_t)pElfFile->arSectHead32[SectIdx].sh_size,
-                        (uint_t)pElfFile->arSectHead32[SectIdx].sh_addr
+                        (uint_t)ENDIAN_SW_4B(pElfFile->arSectHead32[SectIdx].sh_offset),
+                        (uint_t)ENDIAN_SW_4B(pElfFile->arSectHead32[SectIdx].sh_size),
+                        (uint_t)ENDIAN_SW_4B(pElfFile->arSectHead32[SectIdx].sh_addr)
                       );
             /* Now print flags on separate line: */
             for (u32FlagIdx = 0U; u32FlagIdx<u32ShT_Flags_Strings_Count; u32FlagIdx++)
             {
-                if (0U != (ShT_Flags_Strings[u32FlagIdx].u32Flag & pElfFile->arSectHead32[SectIdx].sh_flags))
+                if (0U != (ShT_Flags_Strings[u32FlagIdx].u32Flag & ENDIAN_SW_4B(pElfFile->arSectHead32[SectIdx].sh_flags)))
                 {
                     NXP_LOG_INFO("%s, ", ShT_Flags_Strings[u32FlagIdx].szString);
                 }
@@ -811,7 +705,7 @@ static void ELF32_PrintSections(const ELF_File_t *pElfFile)
         for (ProgIdx = 0U; ProgIdx < pElfFile->Header.r32.e_phnum; ProgIdx++)
         {
             /* Try to find the name of the section in section header */
-            uint32_t u32Type = pElfFile->arProgHead32[ProgIdx].p_type;
+            uint32_t u32Type = ENDIAN_SW_4B(pElfFile->arProgHead32[ProgIdx].p_type);
 
             if (u32Type >= 10U)
             {
@@ -822,11 +716,11 @@ static void ELF32_PrintSections(const ELF_File_t *pElfFile)
             NXP_LOG_INFO("%3u %s   0x%08x         0x%08x         0x%08x         0x%08x         0x%08x",
                         (uint_t)ProgIdx,
                         aacPTypes[u32Type],
-                        (uint_t)pElfFile->arProgHead32[ProgIdx].p_offset,
-                        (uint_t)pElfFile->arProgHead32[ProgIdx].p_filesz,
-                        (uint_t)pElfFile->arProgHead32[ProgIdx].p_vaddr,
-                        (uint_t)pElfFile->arProgHead32[ProgIdx].p_paddr,
-                        (uint_t)pElfFile->arProgHead32[ProgIdx].p_memsz
+                        (uint_t)ENDIAN_SW_4B(pElfFile->arProgHead32[ProgIdx].p_offset),
+                        (uint_t)ENDIAN_SW_4B(pElfFile->arProgHead32[ProgIdx].p_filesz),
+                        (uint_t)ENDIAN_SW_4B(pElfFile->arProgHead32[ProgIdx].p_vaddr),
+                        (uint_t)ENDIAN_SW_4B(pElfFile->arProgHead32[ProgIdx].p_paddr),
+                        (uint_t)ENDIAN_SW_4B(pElfFile->arProgHead32[ProgIdx].p_memsz)
                       );
             NXP_LOG_INFO("\n");
         }
@@ -844,7 +738,7 @@ static void ELF32_PrintSections(const ELF_File_t *pElfFile)
 
 #if TRUE == ELF_CFG_ELF64_SUPPORTED
 /*================================================================================================*/
-static bool_t ELF64_LoadTables(ELF_File_t *pElfFile, bool_t bIsCrosEndian)
+static bool_t ELF64_LoadTables(ELF_File_t *pElfFile)
 {
     bool_t bProgStatus = TRUE;
     bool_t bSectStatus = FALSE;
@@ -873,11 +767,6 @@ static bool_t ELF64_LoadTables(ELF_File_t *pElfFile, bool_t bIsCrosEndian)
     {
         /* Save the pointer */
         pElfFile->arProgHead64 = (Elf64_Phdr *)(((uint8_t*)pElfFile->pvData) + pElfFile->Header.r64.e_phoff);
-        /* Now handle endianness */
-        if (bIsCrosEndian)
-        {
-            ELF64_ProgTabSwitchEndianness(pElfFile->arProgHead64, pElfFile->Header.r64.e_phnum);
-        }
         bProgStatus = TRUE;
     }
   #endif /* ELF_CFG_PROGRAM_TABLE_USED */
@@ -900,11 +789,6 @@ static bool_t ELF64_LoadTables(ELF_File_t *pElfFile, bool_t bIsCrosEndian)
     {
         /* Save the pointer */
         pElfFile->arSectHead64 = (Elf64_Shdr *)(((uint8_t*)pElfFile->pvData) + pElfFile->Header.r64.e_shoff);
-        /* Now handle endianness */
-        if (bIsCrosEndian)
-        {
-            ELF64_SectTabSwitchEndianness(pElfFile->arSectHead64, pElfFile->Header.r64.e_shnum);
-        }
         bSectStatus = TRUE;
     }
   #else /* ELF_CFG_SECTION_TABLE_USED */
@@ -939,40 +823,39 @@ static void ELF64_HeaderSwitchEndianness(Elf64_Ehdr *prElf64Header)
     prElf64Header->e_shstrndx   = ENDIAN_SW_2B(prElf64Header->e_shstrndx);
 }
 
-static bool_t ELF64_Load(bool_t bIsCrosEndian,ELF_File_t *pElfFile,uint32_t *u32NamesSectionOffset,uint32_t *u32NamesSectionSize)
+static bool_t ELF64_Load(ELF_File_t *pElfFile,uint32_t *u32NamesSectionOffset,uint32_t *u32NamesSectionSize)
 {
     bool_t    bRetVal = FALSE;
 
-    if (bIsCrosEndian)
-    {
-        ELF64_HeaderSwitchEndianness(&(pElfFile->Header.r64));
-    }
+    ELF64_HeaderSwitchEndianness(&(pElfFile->Header.r64));
+    
     if ((uint16_t)ELF_Type_Executable != pElfFile->Header.r64.e_type)
     {
         NXP_LOG_ERROR("ELF_Open: Only executable ELFs are supported\n");
     }
-    else if (FALSE == ELF64_LoadTables(pElfFile, bIsCrosEndian))
+    else if (FALSE == ELF64_LoadTables(pElfFile))
     {
         NXP_LOG_ERROR("ELF_Open: Failed to load tables\n");
     }
-    /* Endianness is now solved in all tables */
-#if TRUE == ELF_CFG_SECTION_TABLE_USED
-    /* Look for section names section */
-    else if ((pElfFile->Header.r64.e_shstrndx == SHN_UNDEF)
-          || (pElfFile->Header.r64.e_shstrndx >= pElfFile->Header.r64.e_shnum)
-          || (0U == pElfFile->arSectHead64[pElfFile->Header.r64.e_shstrndx].sh_size)
-           )
-    {
-        NXP_LOG_ERROR("ELF_Open: Section names not found\n");
-    }
     else
+#if TRUE == ELF_CFG_SECTION_TABLE_USED
     {
-        *u32NamesSectionOffset = (uint32_t)pElfFile->arSectHead64[pElfFile->Header.r64.e_shstrndx].sh_offset;
-        *u32NamesSectionSize = (uint32_t)pElfFile->arSectHead64[pElfFile->Header.r64.e_shstrndx].sh_size;
-        bRetVal = TRUE;
+        /* Look for section names section */
+        if ((pElfFile->Header.r64.e_shstrndx == SHN_UNDEF)
+            || (pElfFile->Header.r64.e_shstrndx >= pElfFile->Header.r64.e_shnum)
+            || (0U == ENDIAN_SW_8B(pElfFile->arSectHead64[pElfFile->Header.r64.e_shstrndx].sh_size))
+            )
+        {
+            NXP_LOG_ERROR("ELF_Open: Section names not found\n");
+        }
+        else
+        {
+            *u32NamesSectionOffset = (uint32_t)ENDIAN_SW_8B(pElfFile->arSectHead64[pElfFile->Header.r64.e_shstrndx].sh_offset);
+            *u32NamesSectionSize = (uint32_t)ENDIAN_SW_8B(pElfFile->arSectHead64[pElfFile->Header.r64.e_shstrndx].sh_size);
+			bRetVal = TRUE;
+        }
     }
 #else  /* ELF_CFG_SECTION_TABLE_USED */
-    else
     {
         bRetVal = TRUE;
     }
@@ -981,60 +864,6 @@ static bool_t ELF64_Load(bool_t bIsCrosEndian,ELF_File_t *pElfFile,uint32_t *u32
     return bRetVal;
 }
 
-/*================================================================================================*/
-static void ELF64_ProgTabSwitchEndianness(Elf64_Phdr *arProgHead64, uint32_t u32NumItems)
-{
-    uint32_t u32Idx;
-
-#if defined(PFE_CFG_NULL_ARG_CHECK)
-    if (unlikely(NULL == arProgHead64))
-    {
-        NXP_LOG_ERROR("NULL argument received\n");
-        return;
-    }
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-    for(u32Idx=0U; u32Idx<u32NumItems; u32Idx++)
-    {
-        arProgHead64[u32Idx].p_type   = ENDIAN_SW_4B(arProgHead64[u32Idx].p_type);
-        arProgHead64[u32Idx].p_flags  = ENDIAN_SW_4B(arProgHead64[u32Idx].p_flags);
-        arProgHead64[u32Idx].p_offset = ENDIAN_SW_8B(arProgHead64[u32Idx].p_offset);
-        arProgHead64[u32Idx].p_vaddr  = ENDIAN_SW_8B(arProgHead64[u32Idx].p_vaddr);
-        arProgHead64[u32Idx].p_paddr  = ENDIAN_SW_8B(arProgHead64[u32Idx].p_paddr);
-        arProgHead64[u32Idx].p_filesz = ENDIAN_SW_8B(arProgHead64[u32Idx].p_filesz);
-        arProgHead64[u32Idx].p_memsz  = ENDIAN_SW_8B(arProgHead64[u32Idx].p_memsz);
-        arProgHead64[u32Idx].p_align  = ENDIAN_SW_8B(arProgHead64[u32Idx].p_align);
-    }
-}
-
-/*================================================================================================*/
-static void ELF64_SectTabSwitchEndianness(Elf64_Shdr *arSectHead64, uint32_t u32NumItems)
-{
-    uint32_t u32Idx;
-
-#if defined(PFE_CFG_NULL_ARG_CHECK)
-    if (unlikely(NULL == arSectHead64))
-    {
-        NXP_LOG_ERROR("NULL argument received\n");
-        return;
-    }
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-    for(u32Idx=0U; u32Idx<u32NumItems; u32Idx++)
-    {
-        arSectHead64[u32Idx].sh_name      = ENDIAN_SW_4B(arSectHead64[u32Idx].sh_name);
-        arSectHead64[u32Idx].sh_type      = ENDIAN_SW_4B(arSectHead64[u32Idx].sh_type);
-        arSectHead64[u32Idx].sh_flags     = ENDIAN_SW_8B(arSectHead64[u32Idx].sh_flags);
-        arSectHead64[u32Idx].sh_addr      = ENDIAN_SW_8B(arSectHead64[u32Idx].sh_addr);
-        arSectHead64[u32Idx].sh_offset    = ENDIAN_SW_8B(arSectHead64[u32Idx].sh_offset);
-        arSectHead64[u32Idx].sh_size      = ENDIAN_SW_8B(arSectHead64[u32Idx].sh_size);
-        arSectHead64[u32Idx].sh_link      = ENDIAN_SW_4B(arSectHead64[u32Idx].sh_link);
-        arSectHead64[u32Idx].sh_info      = ENDIAN_SW_4B(arSectHead64[u32Idx].sh_info);
-        arSectHead64[u32Idx].sh_addralign = ENDIAN_SW_8B(arSectHead64[u32Idx].sh_addralign);
-        arSectHead64[u32Idx].sh_entsize   = ENDIAN_SW_8B(arSectHead64[u32Idx].sh_entsize);
-    }
-}
-
 #if TRUE == ELF_CFG_PROGRAM_TABLE_USED
 /*================================================================================================*/
 static bool_t ELF64_ProgSectFindNext( ELF_File_t *pElfFile, uint32_t *pu32ProgIdx,
@@ -1055,8 +884,8 @@ static bool_t ELF64_ProgSectFindNext( ELF_File_t *pElfFile, uint32_t *pu32ProgId
         /* Find a record having RAM area */
         while (pElfFile->u32ProgScanIdx < pElfFile->Header.r64.e_phnum)
         {
-            if (((uint32_t)PT_LOAD == pElfFile->arProgHead64[pElfFile->u32ProgScanIdx].p_type) /* Has RAM area */
-                 && (0U != pElfFile->arProgHead64[pElfFile->u32ProgScanIdx].p_memsz)      /* Size != 0 */
+            if (((uint32_t)PT_LOAD == ENDIAN_SW_4B(pElfFile->arProgHead64[pElfFile->u32ProgScanIdx].p_type)) /* Has RAM area */
+                 && (0U != ENDIAN_SW_8B(pElfFile->arProgHead64[pElfFile->u32ProgScanIdx].p_memsz))      /* Size != 0 */
                 )
             {   /* Match found */
                 /* Set returned values */
@@ -1066,15 +895,15 @@ static bool_t ELF64_ProgSectFindNext( ELF_File_t *pElfFile, uint32_t *pu32ProgId
                 }
                 if (NULL != pu64LoadVAddr)
                 {
-                    *pu64LoadVAddr = pElfFile->arProgHead64[pElfFile->u32ProgScanIdx].p_vaddr;
+                    *pu64LoadVAddr = ENDIAN_SW_8B(pElfFile->arProgHead64[pElfFile->u32ProgScanIdx].p_vaddr);
                 }
                 if (NULL != pu64LoadPAddr)
                 {
-                    *pu64LoadPAddr = pElfFile->arProgHead64[pElfFile->u32ProgScanIdx].p_paddr;
+                    *pu64LoadPAddr = ENDIAN_SW_8B(pElfFile->arProgHead64[pElfFile->u32ProgScanIdx].p_paddr);
                 }
                 if (NULL != pu64Length)
                 {
-                    *pu64Length = pElfFile->arProgHead64[pElfFile->u32ProgScanIdx].p_memsz;
+                    *pu64Length = ENDIAN_SW_8B(pElfFile->arProgHead64[pElfFile->u32ProgScanIdx].p_memsz);
                 }
                 bRetVal = TRUE;
                 pElfFile->u32ProgScanIdx++;
@@ -1109,15 +938,15 @@ static bool_t ELF64_ProgSectLoad(const ELF_File_t *pElfFile, uint32_t u32ProgIdx
     {
         NXP_LOG_ERROR("ELF64_ProgSectLoad: Invalid program index: %u\n", (uint_t)u32ProgIdx);
     }
-    else if ((uint32_t)PT_LOAD != pElfFile->arProgHead64[u32ProgIdx].p_type)
+    else if ((uint32_t)PT_LOAD != ENDIAN_SW_4B(pElfFile->arProgHead64[u32ProgIdx].p_type))
     {
         NXP_LOG_ERROR("ELF64_ProgSectLoad: This section has no associated RAM area\n");
     }
-    else if (AllocSize < pElfFile->arProgHead64[u32ProgIdx].p_memsz)
+    else if (AllocSize < ENDIAN_SW_8B(pElfFile->arProgHead64[u32ProgIdx].p_memsz))
     {
         NXP_LOG_ERROR("ELF64_ProgSectLoad: Section does not fit to allocated memory\n");
     }
-    else if (pElfFile->arProgHead64[u32ProgIdx].p_filesz > pElfFile->arProgHead64[u32ProgIdx].p_memsz)
+    else if (ENDIAN_SW_8B(pElfFile->arProgHead64[u32ProgIdx].p_filesz) > ENDIAN_SW_8B(pElfFile->arProgHead64[u32ProgIdx].p_memsz))
     {
         NXP_LOG_ERROR("ELF64_ProgSectLoad: Section size mishmash.\n");
     }
@@ -1127,11 +956,11 @@ static bool_t ELF64_ProgSectLoad(const ELF_File_t *pElfFile, uint32_t u32ProgIdx
         /* p_filesz bytes of data at the beginning of the memory area shall be copied from file
         the rest up to p_memsz bytes shall be set to 0
         */
-        if (0U != pElfFile->arProgHead64[u32ProgIdx].p_filesz)
+        if (0U != ENDIAN_SW_8B(pElfFile->arProgHead64[u32ProgIdx].p_filesz))
         {   /* Read from file */
             if (FALSE == LoadFileData(pElfFile, /* pElfFile, */
-                (uint32_t)pElfFile->arProgHead64[u32ProgIdx].p_offset, /* u32Offset, */
-                (uint32_t)pElfFile->arProgHead64[u32ProgIdx].p_filesz, /* u32Size, */
+                (uint32_t)ENDIAN_SW_8B(pElfFile->arProgHead64[u32ProgIdx].p_offset), /* u32Offset, */
+                (uint32_t)ENDIAN_SW_8B(pElfFile->arProgHead64[u32ProgIdx].p_filesz), /* u32Size, */
                 (void *)AccessAddr /* pvDestMem */
                                       )
                 )
@@ -1150,7 +979,7 @@ static bool_t ELF64_ProgSectLoad(const ELF_File_t *pElfFile, uint32_t u32ProgIdx
 
         /* Pad rest with zeros */
         if ((TRUE == bSuccess)
-            && (pElfFile->arProgHead64[u32ProgIdx].p_memsz > pElfFile->arProgHead64[u32ProgIdx].p_filesz)
+            && (ENDIAN_SW_8B(pElfFile->arProgHead64[u32ProgIdx].p_memsz) > ENDIAN_SW_8B(pElfFile->arProgHead64[u32ProgIdx].p_filesz))
             )
         {
             if (sizeof(addr_t) < sizeof(uint64_t))
@@ -1158,9 +987,9 @@ static bool_t ELF64_ProgSectLoad(const ELF_File_t *pElfFile, uint32_t u32ProgIdx
                     NXP_LOG_WARNING("ELF64_ProgSectLoad: addr_t size is not sufficient (%u < %u)", (uint_t)sizeof(addr_t), (uint_t)sizeof(uint64_t));
             }
 
-            (void)memset((void *)(AccessAddr + (addr_t)pElfFile->arProgHead64[u32ProgIdx].p_filesz),
+            (void)memset((void *)(AccessAddr + (addr_t)ENDIAN_SW_8B(pElfFile->arProgHead64[u32ProgIdx].p_filesz)),
                 0,
-                (uint32_t)pElfFile->arProgHead64[u32ProgIdx].p_memsz - (uint32_t)pElfFile->arProgHead64[u32ProgIdx].p_filesz
+                (uint32_t)ENDIAN_SW_8B(pElfFile->arProgHead64[u32ProgIdx].p_memsz) - (uint32_t)ENDIAN_SW_8B(pElfFile->arProgHead64[u32ProgIdx].p_filesz)
             );
         }
     }
@@ -1190,7 +1019,7 @@ static bool_t ELF64_SectFindName(const ELF_File_t *pElfFile, const char_t *szSec
         /* Search section table */
         for (SectIdx = 0U; SectIdx < pElfFile->Header.r64.e_shnum; SectIdx++)
         {
-            if (0 == strcmp((char_t *)(pElfFile->acSectNames + pElfFile->arSectHead64[SectIdx].sh_name), szSectionName))
+            if (0 == strcmp((char_t *)(pElfFile->acSectNames + ENDIAN_SW_4B(pElfFile->arSectHead64[SectIdx].sh_name)), szSectionName))
             {   /* Found */
                 if (NULL != pu32SectIdx)
                 {
@@ -1198,11 +1027,11 @@ static bool_t ELF64_SectFindName(const ELF_File_t *pElfFile, const char_t *szSec
                 }
                 if (NULL != pu64Length)
                 {
-                    *pu64Length = pElfFile->arSectHead64[SectIdx].sh_size;
+                    *pu64Length = ENDIAN_SW_8B(pElfFile->arSectHead64[SectIdx].sh_size);
                 }
                 if (NULL != pu64LoadAddr)
                 {
-                    *pu64LoadAddr = pElfFile->arSectHead64[SectIdx].sh_addr;
+                    *pu64LoadAddr = ENDIAN_SW_8B(pElfFile->arSectHead64[SectIdx].sh_addr);
                 }
                 bFound = TRUE;
                 bRetVal = TRUE;
@@ -1235,23 +1064,23 @@ static bool_t ELF64_SectLoad(const ELF_File_t *pElfFile, uint32_t u32SectIdx, ad
     {
         NXP_LOG_ERROR("ELF64_SectLoad: Invalid section index: %u\n", (uint_t)u32SectIdx);
     }
-    else if (AllocSize < pElfFile->arSectHead64[u32SectIdx].sh_size)
+    else if (AllocSize < ENDIAN_SW_8B(pElfFile->arSectHead64[u32SectIdx].sh_size))
     {
         NXP_LOG_ERROR("ELF64_SectLoad: Section does not fit to allocated memory\n");
     }
     /* LOAD */
     else
     {   /* All OK */
-        if ((uint32_t)SHT_NOBITS == pElfFile->arSectHead64[u32SectIdx].sh_type)
+        if ((uint32_t)SHT_NOBITS == ENDIAN_SW_4B(pElfFile->arSectHead64[u32SectIdx].sh_type))
         {   /* Fill with zeros */
-            (void)memset((void *)AccessAddr, 0, (uint32_t)pElfFile->arSectHead64[u32SectIdx].sh_size);
+            (void)memset((void *)AccessAddr, 0, (uint32_t)ENDIAN_SW_8B(pElfFile->arSectHead64[u32SectIdx].sh_size));
             bSuccess = TRUE;
         }
         else
         {   /* Copy from file */
             if (FALSE == LoadFileData(pElfFile, /* pElfFile, */
-                                       (uint32_t)pElfFile->arSectHead64[u32SectIdx].sh_offset, /* u32Offset, */
-                                       (uint32_t)pElfFile->arSectHead64[u32SectIdx].sh_size, /* u32Size, */
+                                       (uint32_t)ENDIAN_SW_8B(pElfFile->arSectHead64[u32SectIdx].sh_offset), /* u32Offset, */
+                                       (uint32_t)ENDIAN_SW_8B(pElfFile->arSectHead64[u32SectIdx].sh_size), /* u32Size, */
                                        (void *)AccessAddr /* pvDestMem */
                                       )
                 )
@@ -1300,24 +1129,24 @@ static void ELF64_PrintSections(const ELF_File_t *pElfFile)
         NXP_LOG_INFO("     SectionName Type     FileOffset         FileSize           LoadAddress        Flags\n");
         for (SectIdx = 0U; SectIdx < pElfFile->Header.r64.e_shnum; SectIdx++)
         {
-            uint32_t u32Type = pElfFile->arSectHead64[SectIdx].sh_type;
+            uint32_t u32Type = ENDIAN_SW_4B(pElfFile->arSectHead64[SectIdx].sh_type);
             uint32_t u32FlagIdx;
 
             if (u32Type >= 16U)
             {
                 u32Type = 16U; /* Undefined */
             }
-            NXP_LOG_INFO("%16s ", pElfFile->acSectNames + pElfFile->arSectHead64[SectIdx].sh_name);
+            NXP_LOG_INFO("%16s ", pElfFile->acSectNames + ENDIAN_SW_4B(pElfFile->arSectHead64[SectIdx].sh_name));
             NXP_LOG_INFO("%s 0x%016"PRINT64"x 0x%016"PRINT64"x 0x%016"PRINT64"x ",
                         aacSTypes[u32Type],
-                        pElfFile->arSectHead64[SectIdx].sh_offset,
-                        pElfFile->arSectHead64[SectIdx].sh_size,
-                        pElfFile->arSectHead64[SectIdx].sh_addr
+                        ENDIAN_SW_8B(pElfFile->arSectHead64[SectIdx].sh_offset),
+                        ENDIAN_SW_8B(pElfFile->arSectHead64[SectIdx].sh_size),
+                        ENDIAN_SW_8B(pElfFile->arSectHead64[SectIdx].sh_addr)
             );
             /* Now print flags on separate line: */
             for (u32FlagIdx = 0U; u32FlagIdx<u32ShT_Flags_Strings_Count; u32FlagIdx++)
             {
-                if (0U != (ShT_Flags_Strings[u32FlagIdx].u32Flag & pElfFile->arSectHead64[SectIdx].sh_flags))
+                if (0U != (ShT_Flags_Strings[u32FlagIdx].u32Flag & ENDIAN_SW_8B(pElfFile->arSectHead64[SectIdx].sh_flags)))
                 {
                     NXP_LOG_INFO("%s, ", ShT_Flags_Strings[u32FlagIdx].szString);
                 }
@@ -1335,7 +1164,7 @@ static void ELF64_PrintSections(const ELF_File_t *pElfFile)
         for (ProgIdx = 0U; ProgIdx < pElfFile->Header.r64.e_phnum; ProgIdx++)
         {
             /* Try to find the name of the section in section header */
-            uint32_t u32Type = pElfFile->arProgHead64[ProgIdx].p_type;
+            uint32_t u32Type = ENDIAN_SW_4B(pElfFile->arProgHead64[ProgIdx].p_type);
 
             if (u32Type >= 10U)
             {
@@ -1346,11 +1175,11 @@ static void ELF64_PrintSections(const ELF_File_t *pElfFile)
             NXP_LOG_INFO("%u %s 0x%016"PRINT64"x 0x%016"PRINT64"x 0x%016"PRINT64"x 0x%016"PRINT64"x 0x%016"PRINT64"x",
                 (uint_t)ProgIdx,
                         aacPTypes[u32Type],
-                        pElfFile->arProgHead64[ProgIdx].p_offset,
-                        pElfFile->arProgHead64[ProgIdx].p_filesz,
-                        pElfFile->arProgHead64[ProgIdx].p_vaddr,
-                        pElfFile->arProgHead64[ProgIdx].p_paddr,
-                        pElfFile->arProgHead64[ProgIdx].p_memsz
+                        ENDIAN_SW_8B(pElfFile->arProgHead64[ProgIdx].p_offset),
+                        ENDIAN_SW_8B(pElfFile->arProgHead64[ProgIdx].p_filesz),
+                        ENDIAN_SW_8B(pElfFile->arProgHead64[ProgIdx].p_vaddr),
+                        ENDIAN_SW_8B(pElfFile->arProgHead64[ProgIdx].p_paddr),
+                        ENDIAN_SW_8B(pElfFile->arProgHead64[ProgIdx].p_memsz)
                       );
             NXP_LOG_INFO("\n");
         }
@@ -1367,7 +1196,7 @@ static void ELF64_PrintSections(const ELF_File_t *pElfFile)
 #endif /* ELF_CFG_ELF64_SUPPORTED */
 
 /*================================================================================================*/
-static uint32_t buf_read(void *src_buf, uint32_t u32FileSize, uint32_t u32Offset, void *dst_buf, uint32_t nbytes)
+static uint32_t buf_read(const void *src_buf, uint32_t u32FileSize, uint32_t u32Offset, void *dst_buf, uint32_t nbytes)
 {
     uint32_t u32i = 0;
     const uint8_t *pu8src = (uint8_t *)((addr_t)src_buf + u32Offset);
@@ -1399,23 +1228,11 @@ static uint32_t buf_read(void *src_buf, uint32_t u32FileSize, uint32_t u32Offset
 static bool_t ELF_LoadTables(ELF_File_t *pElfFile, uint32_t *u32NamesSectionOffset, uint32_t *u32NamesSectionSize)
 {
     bool_t bRetVal = FALSE;
-    bool_t    bIsCrosEndian;
-    ELF_Endian_t NativeEndian = GetLocalEndian();
-    ELF_Endian_t BinaryEndian;
-
-    /* Check Endianness */
-    BinaryEndian = ELF_IsLittleEndian(pElfFile) ? ELF_Endian_Little : ELF_Endian_Big;
-    bIsCrosEndian = (BinaryEndian == NativeEndian) ? FALSE : TRUE;
-    NXP_LOG_INFO("ELF_Open: File format: %s\n", pElfFile->bIs64Bit ? "Elf64" : "Elf32");
-    NXP_LOG_INFO("ELF_Open: File endian: %s (%s)\n",
-              bIsCrosEndian ? "Alien" : "Native",
-              (BinaryEndian==ELF_Endian_Little) ? "Little" : "Big"
-            );
 
     if (TRUE == pElfFile->bIs64Bit)
     {   /* Loading 64-bit ELF */
 #if TRUE == ELF_CFG_ELF64_SUPPORTED
-        bRetVal = ELF64_Load(bIsCrosEndian, pElfFile, u32NamesSectionOffset, u32NamesSectionSize);
+        bRetVal = ELF64_Load(pElfFile, u32NamesSectionOffset, u32NamesSectionSize);
 #else /* ELF_CFG_ELF64_SUPPORTED */
         NXP_LOG_ERROR("Support for Elf64 was not compiled\n");
 #endif /* ELF_CFG_ELF64_SUPPORTED */
@@ -1423,7 +1240,7 @@ static bool_t ELF_LoadTables(ELF_File_t *pElfFile, uint32_t *u32NamesSectionOffs
     else
     {   /* Loading 32-bit ELF */
 #if TRUE == ELF_CFG_ELF32_SUPPORTED
-        bRetVal = ELF32_Load(bIsCrosEndian, pElfFile, u32NamesSectionOffset, u32NamesSectionSize);
+        bRetVal = ELF32_Load(pElfFile, u32NamesSectionOffset, u32NamesSectionSize);
 #else /* ELF_CFG_ELF32_SUPPORTED */
         NXP_LOG_ERROR("Support for Elf32 was not compiled\n");
 #endif /* ELF_CFG_ELF32_SUPPORTED */
@@ -1472,7 +1289,7 @@ static void ELF_FreePtr(ELF_File_t *pElfFile)
 * @retval       TRUE Succeeded
 * @retval       FALSE Failed
 */
-bool_t ELF_Open(ELF_File_t *pElfFile, void *pvFile, uint32_t u32FileSize)
+bool_t ELF_Open(ELF_File_t *pElfFile,void *pvFile, uint32_t u32FileSize)
 {
     bool_t    bRetVal = FALSE;
     uint32_t     u32NamesSectionOffset = 0U;
@@ -1554,9 +1371,6 @@ bool_t ELF_Open(ELF_File_t *pElfFile, void *pvFile, uint32_t u32FileSize)
 */
 void ELF_Close(ELF_File_t *pElfFile)
 {
-    bool_t    bIsCrosEndian;
-    ELF_Endian_t NativeEndian = GetLocalEndian();
-    ELF_Endian_t BinaryEndian;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
     if (unlikely(NULL == pElfFile))
@@ -1565,33 +1379,6 @@ void ELF_Close(ELF_File_t *pElfFile)
         return;
     }
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-    /* Check Endianness */
-    BinaryEndian = ELF_IsLittleEndian(pElfFile) ? ELF_Endian_Little : ELF_Endian_Big;
-    bIsCrosEndian = (BinaryEndian == NativeEndian) ? FALSE : TRUE;
-        
-    /* If cross endian, swap the header bytes again to revert the elf file to original,
-       so it can be used again in the next call of Eth_43_PFE_Init()  */
-    if (bIsCrosEndian)
-    {
-        if (TRUE == pElfFile->bIs64Bit)
-        {   
-            /* Loading 64-bit ELF */
-            #if TRUE == ELF_CFG_ELF64_SUPPORTED
-                /* Handle endianness */
-                ELF64_ProgTabSwitchEndianness(pElfFile->arProgHead64, pElfFile->Header.r64.e_phnum);
-                ELF64_SectTabSwitchEndianness(pElfFile->arSectHead64, pElfFile->Header.r64.e_shnum);
-            #endif  /* ELF_CFG_ELF64_SUPPORTED */
-        }
-        else
-        {
-            #if TRUE == ELF_CFG_ELF32_SUPPORTED
-                /* Handle endianness */
-                ELF32_ProgTabSwitchEndianness(pElfFile->arProgHead32, pElfFile->Header.r32.e_phnum);
-                ELF32_SectTabSwitchEndianness(pElfFile->arSectHead32, pElfFile->Header.r32.e_shnum);
-            #endif  /* ELF_CFG_ELF32_SUPPORTED */
-        }
-    }
     
     ELF_FreePtr(pElfFile);
 }
diff --git a/sw/fci/src/fci.c b/sw/fci/src/fci.c
index 594034d..4cf6587 100644
--- a/sw/fci/src/fci.c
+++ b/sw/fci/src/fci.c
@@ -46,13 +46,15 @@ errno_t fci_process_ipc_message(fci_msg_t *msg, fci_msg_t *rep_msg)
 	if (unlikely((NULL == msg) || (NULL == rep_msg)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	NXP_LOG_DEBUG("Send FCI proxy message (type=0x%02x, code=0x%02x)\n", (uint_t)msg->type, (uint_t)msg->msg_cmd.code);
-	ret = pfe_idex_master_rpc(PFE_PLATFORM_RPC_PFE_FCI_PROXY, &proxy_cmd, sizeof(proxy_cmd), &proxy_rep, sizeof(proxy_rep));
-	rep_msg->msg_cmd = proxy_rep.msg_cmd;
+	{
+		NXP_LOG_DEBUG("Send FCI proxy message (type=0x%02x, code=0x%02x)\n", (uint_t)msg->type, (uint_t)msg->msg_cmd.code);
+		ret = pfe_idex_master_rpc(PFE_PLATFORM_RPC_PFE_FCI_PROXY, &proxy_cmd, sizeof(proxy_cmd), &proxy_rep, sizeof(proxy_rep));
+		rep_msg->msg_cmd = proxy_rep.msg_cmd;
+	}
 
 #else
 	/* Normal FCI processing */
@@ -68,298 +70,299 @@ errno_t fci_process_ipc_message(fci_msg_t *msg, fci_msg_t *rep_msg)
 	if (unlikely((NULL == fci_context) || (NULL == msg) || (NULL == rep_msg)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-#if (FALSE == FCI_CFG_FORCE_LEGACY_API)
-	/*	Allocate space for return value ( + padding) by skipping first 4 bytes */
-	reply_buf_ptr = ((uint32_t *)&rep_msg->msg_cmd.payload[4]);
-	reply_buf_len_ptr = &rep_msg->msg_cmd.length;
-
-	/*	Available reply buffer is 4 bytes less than maximum FCI message payload length */
-	*reply_buf_len_ptr = FCI_CFG_MAX_CMD_PAYLOAD_LEN - 4U;
-#else
-	/*	Don't allocate space for return value. First 4 bytes of payload buffer will be overwritten... */
-	reply_buf_ptr = rep_msg->msg_cmd.payload;
-	reply_buf_len_ptr = &rep_msg->msg_cmd.length;
-	*reply_buf_len_ptr = FCI_CFG_MAX_CMD_PAYLOAD_LEN;
-#endif /* FCI_CFG_FORCE_LEGACY_API */
-
-	NXP_LOG_DEBUG("Process FCI message (type=0x%02x, code=0x%02x)\n", (uint_t)msg->type, (uint_t)msg->msg_cmd.code);
-	switch (msg->type)
 	{
-		case FCI_MSG_CMD:
+	#if (FALSE == FCI_CFG_FORCE_LEGACY_API)
+		/*	Allocate space for return value ( + padding) by skipping first 4 bytes */
+		reply_buf_ptr = ((uint32_t *)&rep_msg->msg_cmd.payload[4]);
+		reply_buf_len_ptr = &rep_msg->msg_cmd.length;
+
+		/*	Available reply buffer is 4 bytes less than maximum FCI message payload length */
+		*reply_buf_len_ptr = FCI_CFG_MAX_CMD_PAYLOAD_LEN - 4U;
+	#else
+		/*	Don't allocate space for return value. First 4 bytes of payload buffer will be overwritten... */
+		reply_buf_ptr = rep_msg->msg_cmd.payload;
+		reply_buf_len_ptr = &rep_msg->msg_cmd.length;
+		*reply_buf_len_ptr = FCI_CFG_MAX_CMD_PAYLOAD_LEN;
+	#endif /* FCI_CFG_FORCE_LEGACY_API */
+
+		NXP_LOG_DEBUG("Process FCI message (type=0x%02x, code=0x%02x)\n", (uint_t)msg->type, (uint_t)msg->msg_cmd.code);
+		switch (msg->type)
 		{
-			switch (msg->msg_cmd.code)
+			case FCI_MSG_CMD:
 			{
-				case FPP_CMD_DATA_BUF_PUT:
+				switch (msg->msg_cmd.code)
 				{
-					pfe_ct_buffer_t buf;
-					fpp_buf_cmd_t *fci_buf = (fpp_buf_cmd_t *)msg->msg_cmd.payload;
-
-					if (sizeof(buf.payload) < fci_buf->len)
-					{
-						NXP_LOG_ERROR("Put buffer is too small\n");
-						ret = EINVAL;
-						fci_ret = FPP_ERR_INTERNAL_FAILURE;
-					}
-					else
+					case FPP_CMD_DATA_BUF_PUT:
 					{
-						buf.flags = 1;
-						buf.len = fci_buf->len;
-						(void)memcpy(&buf.payload, fci_buf->payload, fci_buf->len);
+						pfe_ct_buffer_t buf;
+						fpp_buf_cmd_t *fci_buf = (fpp_buf_cmd_t *)msg->msg_cmd.payload;
 
-						ret = pfe_class_put_data(fci_context->class, &buf);
-						if (EOK != ret)
+						if (sizeof(buf.payload) < fci_buf->len)
 						{
-							NXP_LOG_DEBUG("pfe_class_buf_put() failed: %d\n", ret);
+							NXP_LOG_ERROR("Put buffer is too small\n");
+							ret = EINVAL;
 							fci_ret = FPP_ERR_INTERNAL_FAILURE;
 						}
-					}
-
-					break;
-				}
+						else
+						{
+							buf.flags = 1;
+							buf.len = fci_buf->len;
+							(void)memcpy(&buf.payload, fci_buf->payload, fci_buf->len);
+
+							ret = pfe_class_put_data(fci_context->class, &buf);
+							if (EOK != ret)
+							{
+								NXP_LOG_DEBUG("pfe_class_buf_put() failed: %d\n", ret);
+								fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							}
+						}
 
-				case FPP_CMD_IF_LOCK_SESSION:
-				case FPP_CMD_IF_UNLOCK_SESSION:
-				{
-					ret = fci_interfaces_session_cmd(msg->msg_cmd.code, &fci_ret);
-					break;
-				}
+						break;
+					}
 
-				case FPP_CMD_LOG_IF:
-				{
-					/*	Process 'interface' commands (add/del/update/query/...) */
-					ret = fci_interfaces_log_cmd(msg, &fci_ret, (fpp_log_if_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-					break;
-				}
+					case FPP_CMD_IF_LOCK_SESSION:
+					case FPP_CMD_IF_UNLOCK_SESSION:
+					{
+						ret = fci_interfaces_session_cmd(msg->msg_cmd.code, &fci_ret);
+						break;
+					}
 
-				case FPP_CMD_PHY_IF:
-				{
-					/*	Process 'interface' commands (add/del/update/query/...) */
-					ret = fci_interfaces_phy_cmd(msg, &fci_ret, (fpp_phy_if_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-					break;
-				}
+					case FPP_CMD_LOG_IF:
+					{
+						/*	Process 'interface' commands (add/del/update/query/...) */
+						ret = fci_interfaces_log_cmd(msg, &fci_ret, (fpp_log_if_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+						break;
+					}
 
-				case FPP_CMD_IF_MAC:
-				{
-					/*	Process 'MAC address of interface' commands (add/del/query) */
-					ret = fci_interfaces_mac_cmd(msg, &fci_ret, (fpp_if_mac_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-					break;
-				}
+					case FPP_CMD_PHY_IF:
+					{
+						/*	Process 'interface' commands (add/del/update/query/...) */
+						ret = fci_interfaces_phy_cmd(msg, &fci_ret, (fpp_phy_if_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+						break;
+					}
 
-				case FPP_CMD_IP_ROUTE:
-				{
-					/*	Process 'route' commands (add/del/update/query/...) */
-					ret = oal_mutex_lock(&fci_context->db_mutex);
-					if (EOK == ret)
+					case FPP_CMD_IF_MAC:
 					{
-						ret = fci_routes_cmd(msg, &fci_ret, (fpp_rt_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-						(void)oal_mutex_unlock(&fci_context->db_mutex);
+						/*	Process 'MAC address of interface' commands (add/del/query) */
+						ret = fci_interfaces_mac_cmd(msg, &fci_ret, (fpp_if_mac_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+						break;
 					}
 
-					break;
-				}
+					case FPP_CMD_IP_ROUTE:
+					{
+						/*	Process 'route' commands (add/del/update/query/...) */
+						ret = oal_mutex_lock(&fci_context->db_mutex);
+						if (EOK == ret)
+						{
+							ret = fci_routes_cmd(msg, &fci_ret, (fpp_rt_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+							(void)oal_mutex_unlock(&fci_context->db_mutex);
+						}
 
-				case FPP_CMD_IPV4_SET_TIMEOUT:
-				{
-					/*	Update default timeouts for connections */
+						break;
+					}
 
-					ret = oal_mutex_lock(&fci_context->db_mutex);
-					if (EOK == ret)
+					case FPP_CMD_IPV4_SET_TIMEOUT:
 					{
-						ret = fci_connections_ipv4_timeout_cmd(msg, &fci_ret, (fpp_timeout_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-						(void)oal_mutex_unlock(&fci_context->db_mutex);
-					}
+						/*	Update default timeouts for connections */
 
-					break;
-				}
+						ret = oal_mutex_lock(&fci_context->db_mutex);
+						if (EOK == ret)
+						{
+							ret = fci_connections_ipv4_timeout_cmd(msg, &fci_ret, (fpp_timeout_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+							(void)oal_mutex_unlock(&fci_context->db_mutex);
+						}
 
-				case FPP_CMD_IPV4_CONNTRACK:
-				{
-					/*	Process 'ipv4 connection' commands (add/del/updated/query/...) */
-					ret = oal_mutex_lock(&fci_context->db_mutex);
-					if (EOK == ret)
-					{
-						ret = fci_connections_ipv4_ct_cmd(msg, &fci_ret, (fpp_ct_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-						(void)oal_mutex_unlock(&fci_context->db_mutex);
+						break;
 					}
 
-					break;
-				}
-
-				case FPP_CMD_IPV6_CONNTRACK:
-				{
-					/*	Process 'ipv6 connection' commands (add/del/updated/query/...) */
-					ret = oal_mutex_lock(&fci_context->db_mutex);
-					if (EOK == ret)
+					case FPP_CMD_IPV4_CONNTRACK:
 					{
-						ret = fci_connections_ipv6_ct_cmd(msg, &fci_ret, (fpp_ct6_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-						(void)oal_mutex_unlock(&fci_context->db_mutex);
-					}
+						/*	Process 'ipv4 connection' commands (add/del/updated/query/...) */
+						ret = oal_mutex_lock(&fci_context->db_mutex);
+						if (EOK == ret)
+						{
+							ret = fci_connections_ipv4_ct_cmd(msg, &fci_ret, (fpp_ct_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+							(void)oal_mutex_unlock(&fci_context->db_mutex);
+						}
 
-					break;
-				}
+						break;
+					}
 
-				case FPP_CMD_IPV4_RESET:
-				{
-					/*	Remove all IPv4 routes, including connections */
-					ret = oal_mutex_lock(&fci_context->db_mutex);
-					if (EOK == ret)
+					case FPP_CMD_IPV6_CONNTRACK:
 					{
-						fci_routes_drop_all_ipv4();
-						(void)oal_mutex_unlock(&fci_context->db_mutex);
+						/*	Process 'ipv6 connection' commands (add/del/updated/query/...) */
+						ret = oal_mutex_lock(&fci_context->db_mutex);
+						if (EOK == ret)
+						{
+							ret = fci_connections_ipv6_ct_cmd(msg, &fci_ret, (fpp_ct6_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+							(void)oal_mutex_unlock(&fci_context->db_mutex);
+						}
+
+						break;
 					}
 
-					break;
-				}
+					case FPP_CMD_IPV4_RESET:
+					{
+						/*	Remove all IPv4 routes, including connections */
+						ret = oal_mutex_lock(&fci_context->db_mutex);
+						if (EOK == ret)
+						{
+							fci_routes_drop_all_ipv4();
+							(void)oal_mutex_unlock(&fci_context->db_mutex);
+						}
 
-				case FPP_CMD_IPV6_RESET:
-				{
-					/*	Remove all IPv6 routes, including connections */
-					ret = oal_mutex_lock(&fci_context->db_mutex);
-					if (EOK == ret)
+						break;
+					}
+
+					case FPP_CMD_IPV6_RESET:
 					{
-						fci_routes_drop_all_ipv6();
-						(void)oal_mutex_unlock(&fci_context->db_mutex);
+						/*	Remove all IPv6 routes, including connections */
+						ret = oal_mutex_lock(&fci_context->db_mutex);
+						if (EOK == ret)
+						{
+							fci_routes_drop_all_ipv6();
+							(void)oal_mutex_unlock(&fci_context->db_mutex);
+						}
+
+						break;
 					}
 
-					break;
-				}
+					case FPP_CMD_L2_BD:
+					{
+						/*	Manage L2 bridge domains */
+						ret = fci_l2br_domain_cmd(msg, &fci_ret, (fpp_l2_bd_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+						break;
+					}
 
-				case FPP_CMD_L2_BD:
-				{
-					/*	Manage L2 bridge domains */
-					ret = fci_l2br_domain_cmd(msg, &fci_ret, (fpp_l2_bd_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-					break;
-				}
+					case FPP_CMD_L2_STATIC_ENT:
+					{
+						/*	Manage L2 bridge domains */
+						ret = fci_l2br_static_entry_cmd(msg, &fci_ret, (fpp_l2_static_ent_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+						break;
+					}
 
-				case FPP_CMD_L2_STATIC_ENT:
-				{
-					/*	Manage L2 bridge domains */
-					ret = fci_l2br_static_entry_cmd(msg, &fci_ret, (fpp_l2_static_ent_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-					break;
-				}
+					case FPP_CMD_FP_TABLE:
+					{
+						ret = fci_fp_table_cmd(msg, &fci_ret, (fpp_fp_table_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+						break;
+					}
 
-				case FPP_CMD_FP_TABLE:
-				{
-					ret = fci_fp_table_cmd(msg, &fci_ret, (fpp_fp_table_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-					break;
-				}
+					case FPP_CMD_FP_RULE:
+					{
+						ret = fci_fp_rule_cmd(msg, &fci_ret, (fpp_fp_rule_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+						break;
+					}
 
-				case FPP_CMD_FP_RULE:
-				{
-					ret = fci_fp_rule_cmd(msg, &fci_ret, (fpp_fp_rule_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-					break;
-				}
+					case FPP_CMD_FP_FLEXIBLE_FILTER:
+					{
+						/* Configure Flexible filter */
+						ret = fci_flexible_filter_cmd(msg, &fci_ret, (fpp_flexible_filter_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+						break;
+					}
 
-				case FPP_CMD_FP_FLEXIBLE_FILTER:
-				{
-					/* Configure Flexible filter */
-					ret = fci_flexible_filter_cmd(msg, &fci_ret, (fpp_flexible_filter_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-					break;
-				}
+					case FPP_CMD_FW_FEATURE:
+					{
+						ret = fci_fw_features_cmd(msg, &fci_ret, (fpp_fw_features_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+						break;
+					}
 
-				case FPP_CMD_FW_FEATURE:
-				{
-					ret = fci_fw_features_cmd(msg, &fci_ret, (fpp_fw_features_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-					break;
-				}
+					case FPP_CMD_SPD:
+					{
+						ret = fci_spd_cmd(msg, &fci_ret, (fpp_spd_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+						break;
+					}
 
-				case FPP_CMD_SPD:
-				{
-					ret = fci_spd_cmd(msg, &fci_ret, (fpp_spd_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-					break;
-				}
+					case FPP_CMD_QOS_QUEUE:
+					{
+						ret = fci_qos_queue_cmd(msg, &fci_ret, (fpp_qos_queue_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+						break;
+					}
 
-				case FPP_CMD_QOS_QUEUE:
-				{
-					ret = fci_qos_queue_cmd(msg, &fci_ret, (fpp_qos_queue_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-					break;
-				}
+					case FPP_CMD_QOS_SCHEDULER:
+					{
+						ret = fci_qos_scheduler_cmd(msg, &fci_ret, (fpp_qos_scheduler_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+						break;
+					}
 
-				case FPP_CMD_QOS_SCHEDULER:
-				{
-					ret = fci_qos_scheduler_cmd(msg, &fci_ret, (fpp_qos_scheduler_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-					break;
-				}
+					case FPP_CMD_QOS_SHAPER:
+					{
+						ret = fci_qos_shaper_cmd(msg, &fci_ret, (fpp_qos_shaper_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+						break;
+					}
 
-				case FPP_CMD_QOS_SHAPER:
-				{
-					ret = fci_qos_shaper_cmd(msg, &fci_ret, (fpp_qos_shaper_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-					break;
-				}
+					case FPP_CMD_MIRROR:
+					{
+						ret = fci_mirror_cmd(msg, &fci_ret, (fpp_mirror_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+						break;
+					}
+					case FPP_CMD_QOS_POLICER:
+					{
+						ret = fci_qos_policer_cmd(msg, &fci_ret, (fpp_qos_policer_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+						break;
+					}
 
-				case FPP_CMD_MIRROR:
-				{
-					ret = fci_mirror_cmd(msg, &fci_ret, (fpp_mirror_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-					break;
-				}
-				case FPP_CMD_QOS_POLICER:
-				{
-					ret = fci_qos_policer_cmd(msg, &fci_ret, (fpp_qos_policer_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-					break;
-				}
+					case FPP_CMD_QOS_POLICER_FLOW:
+					{
+						ret = fci_qos_policer_flow_cmd(msg, &fci_ret, (fpp_qos_policer_flow_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+						break;
+					}
 
-				case FPP_CMD_QOS_POLICER_FLOW:
-				{
-					ret = fci_qos_policer_flow_cmd(msg, &fci_ret, (fpp_qos_policer_flow_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-					break;
-				}
+					case FPP_CMD_QOS_POLICER_WRED:
+					{
+						ret = fci_qos_policer_wred_cmd(msg, &fci_ret, (fpp_qos_policer_wred_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+						break;
+					}
 
-				case FPP_CMD_QOS_POLICER_WRED:
-				{
-					ret = fci_qos_policer_wred_cmd(msg, &fci_ret, (fpp_qos_policer_wred_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-					break;
-				}
+					case FPP_CMD_QOS_POLICER_SHP:
+					{
+						ret = fci_qos_policer_shp_cmd(msg, &fci_ret, (fpp_qos_policer_shp_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+						break;
+					}
 
-				case FPP_CMD_QOS_POLICER_SHP:
-				{
-					ret = fci_qos_policer_shp_cmd(msg, &fci_ret, (fpp_qos_policer_shp_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
-					break;
-				}
+					case FPP_CMD_L2_FLUSH_ALL:
+					case FPP_CMD_L2_FLUSH_LEARNED:
+					case FPP_CMD_L2_FLUSH_STATIC:
+					{
+						ret = fci_l2br_flush_cmd(msg->msg_cmd.code, &fci_ret);
+						break;
+					}
 
-				case FPP_CMD_L2_FLUSH_ALL:
-				case FPP_CMD_L2_FLUSH_LEARNED:
-				case FPP_CMD_L2_FLUSH_STATIC:
-				{
-					ret = fci_l2br_flush_cmd(msg->msg_cmd.code, &fci_ret);
-					break;
+					default:
+					{
+						NXP_LOG_WARNING("Unknown CMD code received: 0x%x\n", (uint_t)msg->msg_cmd.code);
+						ret = EINVAL;
+						fci_ret = FPP_ERR_UNKNOWN_COMMAND;
+						break;
+					}
 				}
 
-				default:
-				{
-					NXP_LOG_WARNING("Unknown CMD code received: 0x%x\n", (uint_t)msg->msg_cmd.code);
-					ret = EINVAL;
-					fci_ret = FPP_ERR_UNKNOWN_COMMAND;
-					break;
-				}
+				/*	Inform client about command execution status */
+	#if (FALSE == FCI_CFG_FORCE_LEGACY_API)
+				/*	We're adding another 4 bytes at the beginning of the FCI message payload area */
+				rep_msg->msg_cmd.length = *reply_buf_len_ptr + 4U;
+	#else
+				/*	Pass reply buffer length as is. First 4 bytes will be overwritten by the return value. */
+				rep_msg->msg_cmd.length = *reply_buf_len_ptr;
+	#endif /* FCI_CFG_FORCE_LEGACY_API */
+				reply_retval_ptr = (uint16_t *)rep_msg->msg_cmd.payload;
+				*reply_retval_ptr = (uint16_t)fci_ret;
+
+				break;
 			}
 
-			/*	Inform client about command execution status */
-#if (FALSE == FCI_CFG_FORCE_LEGACY_API)
-			/*	We're adding another 4 bytes at the beginning of the FCI message payload area */
-			rep_msg->msg_cmd.length = *reply_buf_len_ptr + 4U;
-#else
-			/*	Pass reply buffer length as is. First 4 bytes will be overwritten by the return value. */
-			rep_msg->msg_cmd.length = *reply_buf_len_ptr;
-#endif /* FCI_CFG_FORCE_LEGACY_API */
-			reply_retval_ptr = (uint16_t *)rep_msg->msg_cmd.payload;
-			*reply_retval_ptr = (uint16_t)fci_ret;
-
-			break;
-		}
-
-		default:
-		{
-			NXP_LOG_WARNING("Unknown message type\n");
-			ret = EINVAL;
-			break;
+			default:
+			{
+				NXP_LOG_WARNING("Unknown message type\n");
+				ret = EINVAL;
+				break;
+			}
 		}
 	}
 #endif /* PFE_CFG_PFE_MASTER */
-
 	return ret;
 }
 
@@ -381,118 +384,122 @@ errno_t fci_init(fci_init_info_t *info, const char_t *const identifier)
 	if (unlikely(NULL == identifier))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		err = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if(TRUE == fci_context->fci_initialized)
 	{
-		NXP_LOG_ERROR("FCI has already been initialized!\n");
-		return EINVAL;
-	}
-
-	(void)memset(fci_context, 0, sizeof(fci_t));
+		if(TRUE == fci_context->fci_initialized)
+		{
+			NXP_LOG_ERROR("FCI has already been initialized!\n");
+			err = EINVAL;
+		}
+		else
+		{
+			(void)memset(fci_context, 0, sizeof(fci_t));
 
-	fci_context->db_mutex_initialized = FALSE;
-	fci_context->log_if_db_initialized = FALSE;
-	fci_context->phy_if_db_initialized = FALSE;
-	fci_context->rt_db_initialized = FALSE;
-	fci_context->rtable_initialized = FALSE;
-	fci_context->tmu_initialized = FALSE;
+			fci_context->db_mutex_initialized = FALSE;
+			fci_context->log_if_db_initialized = FALSE;
+			fci_context->phy_if_db_initialized = FALSE;
+			fci_context->rt_db_initialized = FALSE;
+			fci_context->rtable_initialized = FALSE;
+			fci_context->tmu_initialized = FALSE;
 
-	/*	Sanity check */
-	if (6U != sizeof(pfe_mac_addr_t))
-	{
-		err = EINVAL;
-		goto free_and_fail;
-	}
+			/*	Sanity check */
+			if (6U != sizeof(pfe_mac_addr_t))
+			{
+				err = EINVAL;
+				goto free_and_fail;
+			}
 
-	/*	Create communication core */
-	err = fci_core_init(identifier);
-	if (err != EOK)
-	{
-		NXP_LOG_ERROR("Could not create FCI core\n");
-		goto free_and_fail;
-	}
+			/*	Create communication core */
+			err = fci_core_init(identifier);
+			if (err != EOK)
+			{
+				NXP_LOG_ERROR("Could not create FCI core\n");
+				goto free_and_fail;
+			}
 
-#ifdef PFE_CFG_PFE_MASTER
-	err = oal_mutex_init(&fci_context->db_mutex);
-	if (EOK != err)
-	{
-		goto free_and_fail;
-	}
-	else
-	{
-		fci_context->db_mutex_initialized = TRUE;
-	}
+		#ifdef PFE_CFG_PFE_MASTER
+			err = oal_mutex_init(&fci_context->db_mutex);
+			if (EOK != err)
+			{
+				goto free_and_fail;
+			}
+			else
+			{
+				fci_context->db_mutex_initialized = TRUE;
+			}
 
-	/*	Initialize the Flexible Parser databases */
-	fci_fp_db_init();
-	if (NULL != info)
-	{
-		fci_context->class = info->class;
-	}
+			/*	Initialize the Flexible Parser databases */
+			fci_fp_db_init();
+			if (NULL != info)
+			{
+				fci_context->class = info->class;
+			}
 
-	/*	Initialize the physical interface database */
-	if (NULL != info)
-	{
-		fci_context->phy_if_db = info->phy_if_db;
-	}
+			/*	Initialize the physical interface database */
+			if (NULL != info)
+			{
+				fci_context->phy_if_db = info->phy_if_db;
+			}
 
-	if(NULL != fci_context->log_if_db)
-	{
-		fci_context->phy_if_db_initialized = TRUE;
-	}
+			if(NULL != fci_context->log_if_db)
+			{
+				fci_context->phy_if_db_initialized = TRUE;
+			}
 
-	/*	Initialize the logical interface database */
-	if (NULL != info)
-	{
-		fci_context->log_if_db = info->log_if_db;
-	}
+			/*	Initialize the logical interface database */
+			if (NULL != info)
+			{
+				fci_context->log_if_db = info->log_if_db;
+			}
 
-	if(NULL != fci_context->log_if_db)
-	{
-		fci_context->log_if_db_initialized = TRUE;
-	}
+			if(NULL != fci_context->log_if_db)
+			{
+				fci_context->log_if_db_initialized = TRUE;
+			}
 
-	/*	Initialize the route database */
-	fci_rt_db_init(&fci_context->route_db);
-	fci_context->rt_db_initialized = TRUE;
+			/*	Initialize the route database */
+			fci_rt_db_init(&fci_context->route_db);
+			fci_context->rt_db_initialized = TRUE;
 
-	/*	Store the routing table and bridge reference */
-	if (NULL != info)
-	{
-		if (NULL != info->rtable)
-		{
-			fci_context->rtable = info->rtable;
-			fci_context->rtable_initialized = TRUE;
-		}
+			/*	Store the routing table and bridge reference */
+			if (NULL != info)
+			{
+				if (NULL != info->rtable)
+				{
+					fci_context->rtable = info->rtable;
+					fci_context->rtable_initialized = TRUE;
+				}
 
-		if (NULL != info->l2_bridge)
-		{
-			fci_context->l2_bridge = info->l2_bridge;
-			fci_context->l2_bridge_initialized = TRUE;
-		}
-	}
+				if (NULL != info->l2_bridge)
+				{
+					fci_context->l2_bridge = info->l2_bridge;
+					fci_context->l2_bridge_initialized = TRUE;
+				}
+			}
 
-	if (NULL != info)
-	{
-		/*	Initialize the TMU  */
-		fci_context->tmu = info->tmu;
-	}
+			if (NULL != info)
+			{
+				/*	Initialize the TMU  */
+				fci_context->tmu = info->tmu;
+			}
 
-	if(NULL != fci_context->tmu)
-	{
-		fci_context->tmu_initialized = TRUE;
+			if(NULL != fci_context->tmu)
+			{
+				fci_context->tmu_initialized = TRUE;
+			}
+		#else
+			(void)info;
+		#endif /* PFE_CFG_PFE_MASTER */
+
+			fci_context->default_timeouts.timeout_tcp = 5U * 24U * 60U * 60U; 	/* 5 days */
+			fci_context->default_timeouts.timeout_udp = 300U; 					/* 5 min */
+			fci_context->default_timeouts.timeout_other = 240U; 				/* 4 min */
+			fci_context->fci_initialized = TRUE;
+		}
 	}
-#else
-	(void)info;
-#endif /* PFE_CFG_PFE_MASTER */
-
-	fci_context->default_timeouts.timeout_tcp = 5U * 24U * 60U * 60U; 	/* 5 days */
-	fci_context->default_timeouts.timeout_udp = 300U; 					/* 5 min */
-	fci_context->default_timeouts.timeout_other = 240U; 				/* 4 min */
-	fci_context->fci_initialized = TRUE;
 	return err;
 
 free_and_fail:
@@ -512,60 +519,62 @@ void fci_fini(void)
 
 	if (FALSE == fci_context->fci_initialized)
 	{
-		return;
-	}
 
-	/*	Shut down the endpoint */
-	if (NULL != fci_context->core)
-	{
-		fci_core_fini();
-		fci_context->core = NULL;
 	}
-
-#ifdef PFE_CFG_PFE_MASTER
-	(void)pfe_if_db_lock(&session_id);
-	/*	Shutdown the logical IF DB */
-	if (TRUE == fci_context->log_if_db_initialized)
+	else
 	{
-		/* Freeing of the DB is handled by platfrom driver*/
-		fci_context->log_if_db = NULL;
-		fci_context->log_if_db_initialized = FALSE;
-	}
+		/*	Shut down the endpoint */
+		if (NULL != fci_context->core)
+		{
+			fci_core_fini();
+			fci_context->core = NULL;
+		}
 
-	/*  Shutdown the physical IF DB */
-	if (TRUE == fci_context->phy_if_db_initialized)
-	{
-		/* Freeing of the DB is handled by platfrom driver*/
-		fci_context->phy_if_db = NULL;
-		fci_context->phy_if_db_initialized = FALSE;
-	}
-	(void)pfe_if_db_unlock(session_id);
+	#ifdef PFE_CFG_PFE_MASTER
+		(void)pfe_if_db_lock(&session_id);
+		/*	Shutdown the logical IF DB */
+		if (TRUE == fci_context->log_if_db_initialized)
+		{
+			/* Freeing of the DB is handled by platfrom driver*/
+			fci_context->log_if_db = NULL;
+			fci_context->log_if_db_initialized = FALSE;
+		}
 
-	/*	Shutdown the RT DB */
-	if (TRUE == fci_context->rt_db_initialized)
-	{
-		if (TRUE == fci_context->db_mutex_initialized)
+		/*  Shutdown the physical IF DB */
+		if (TRUE == fci_context->phy_if_db_initialized)
 		{
-			(void)oal_mutex_lock(&fci_context->db_mutex);
-			fci_routes_drop_all();
-			(void)oal_mutex_unlock(&fci_context->db_mutex);
+			/* Freeing of the DB is handled by platfrom driver*/
+			fci_context->phy_if_db = NULL;
+			fci_context->phy_if_db_initialized = FALSE;
 		}
+		(void)pfe_if_db_unlock(session_id);
 
-		fci_context->rt_db_initialized = FALSE;
-	}
+		/*	Shutdown the RT DB */
+		if (TRUE == fci_context->rt_db_initialized)
+		{
+			if (TRUE == fci_context->db_mutex_initialized)
+			{
+				(void)oal_mutex_lock(&fci_context->db_mutex);
+				fci_routes_drop_all();
+				(void)oal_mutex_unlock(&fci_context->db_mutex);
+			}
 
-	/*	Invalidate the routing table */
-	fci_context->rtable = NULL;
-	fci_context->rtable_initialized = FALSE;
+			fci_context->rt_db_initialized = FALSE;
+		}
 
-	if (TRUE == fci_context->db_mutex_initialized)
-	{
-		(void)oal_mutex_destroy(&fci_context->db_mutex);
-	}
-#endif /* PFE_CFG_PFE_MASTER */
+		/*	Invalidate the routing table */
+		fci_context->rtable = NULL;
+		fci_context->rtable_initialized = FALSE;
 
-	(void)memset(fci_context, 0, sizeof(fci_t));
-	fci_context->fci_initialized = FALSE;
+		if (TRUE == fci_context->db_mutex_initialized)
+		{
+			(void)oal_mutex_destroy(&fci_context->db_mutex);
+		}
+	#endif /* PFE_CFG_PFE_MASTER */
+
+		(void)memset(fci_context, 0, sizeof(fci_t));
+		fci_context->fci_initialized = FALSE;
+	}
 }
 
 #endif /* PFE_CFG_FCI_ENABLE */
diff --git a/sw/fci/src/fci_connections.c b/sw/fci/src/fci_connections.c
index 3a34fc4..dfe8e5d 100644
--- a/sw/fci/src/fci_connections.c
+++ b/sw/fci/src/fci_connections.c
@@ -303,19 +303,20 @@ static void fci_connections_ipv4_cmd_to_5t(const fpp_ct_cmd_t *ct_cmd, pfe_5_tup
 	if (unlikely((NULL == ct_cmd) || (NULL == tuple)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		(void)memset(tuple, 0, sizeof(pfe_5_tuple_t));
 
-	(void)memset(tuple, 0, sizeof(pfe_5_tuple_t));
-
-	(void)memcpy(&tuple->src_ip.v4, &ct_cmd->saddr, 4);
-	(void)memcpy(&tuple->dst_ip.v4, &ct_cmd->daddr, 4);
-	tuple->src_ip.is_ipv4 = TRUE;
-	tuple->dst_ip.is_ipv4 = TRUE;
-	tuple->sport = oal_ntohs(ct_cmd->sport);
-	tuple->dport = oal_ntohs(ct_cmd->dport);
-	tuple->proto = (uint8_t)oal_ntohs(ct_cmd->protocol);
+		(void)memcpy(&tuple->src_ip.v4, &ct_cmd->saddr, 4);
+		(void)memcpy(&tuple->dst_ip.v4, &ct_cmd->daddr, 4);
+		tuple->src_ip.is_ipv4 = TRUE;
+		tuple->dst_ip.is_ipv4 = TRUE;
+		tuple->sport = oal_ntohs(ct_cmd->sport);
+		tuple->dport = oal_ntohs(ct_cmd->dport);
+		tuple->proto = (uint8_t)oal_ntohs(ct_cmd->protocol);
+	}
 }
 
 /**
@@ -329,19 +330,20 @@ static void fci_connections_ipv4_cmd_to_5t_rep(const fpp_ct_cmd_t *ct_cmd, pfe_5
 	if (unlikely((NULL == ct_cmd) || (NULL == tuple)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		(void)memset(tuple, 0, sizeof(pfe_5_tuple_t));
 
-	(void)memset(tuple, 0, sizeof(pfe_5_tuple_t));
-
-	(void)memcpy(&tuple->src_ip.v4, &ct_cmd->saddr_reply, 4);
-	(void)memcpy(&tuple->dst_ip.v4, &ct_cmd->daddr_reply, 4);
-	tuple->src_ip.is_ipv4 = TRUE;
-	tuple->dst_ip.is_ipv4 = TRUE;
-	tuple->sport = oal_ntohs(ct_cmd->sport_reply);
-	tuple->dport = oal_ntohs(ct_cmd->dport_reply);
-	tuple->proto = (uint8_t)oal_ntohs(ct_cmd->protocol);
+		(void)memcpy(&tuple->src_ip.v4, &ct_cmd->saddr_reply, 4);
+		(void)memcpy(&tuple->dst_ip.v4, &ct_cmd->daddr_reply, 4);
+		tuple->src_ip.is_ipv4 = TRUE;
+		tuple->dst_ip.is_ipv4 = TRUE;
+		tuple->sport = oal_ntohs(ct_cmd->sport_reply);
+		tuple->dport = oal_ntohs(ct_cmd->dport_reply);
+		tuple->proto = (uint8_t)oal_ntohs(ct_cmd->protocol);
+	}
 }
 
 /**
@@ -355,19 +357,20 @@ static void fci_connections_ipv6_cmd_to_5t(const fpp_ct6_cmd_t *ct6_cmd, pfe_5_t
 	if (unlikely((NULL == ct6_cmd) || (NULL == tuple)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		(void)memset(tuple, 0, sizeof(pfe_5_tuple_t));
 
-	(void)memset(tuple, 0, sizeof(pfe_5_tuple_t));
-
-	(void)memcpy(&tuple->src_ip.v6, &ct6_cmd->saddr[0], 16);
-	(void)memcpy(&tuple->dst_ip.v6, &ct6_cmd->daddr[0], 16);
-	tuple->src_ip.is_ipv4 = FALSE;
-	tuple->dst_ip.is_ipv4 = FALSE;
-	tuple->sport = oal_ntohs(ct6_cmd->sport);
-	tuple->dport = oal_ntohs(ct6_cmd->dport);
-	tuple->proto = (uint8_t)oal_ntohs(ct6_cmd->protocol);
+		(void)memcpy(&tuple->src_ip.v6, &ct6_cmd->saddr[0], 16);
+		(void)memcpy(&tuple->dst_ip.v6, &ct6_cmd->daddr[0], 16);
+		tuple->src_ip.is_ipv4 = FALSE;
+		tuple->dst_ip.is_ipv4 = FALSE;
+		tuple->sport = oal_ntohs(ct6_cmd->sport);
+		tuple->dport = oal_ntohs(ct6_cmd->dport);
+		tuple->proto = (uint8_t)oal_ntohs(ct6_cmd->protocol);
+	}
 }
 
 /**
@@ -381,19 +384,20 @@ static void fci_connections_ipv6_cmd_to_5t_rep(const fpp_ct6_cmd_t *ct6_cmd, pfe
 	if (unlikely((NULL == ct6_cmd) || (NULL == tuple)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		(void)memset(tuple, 0, sizeof(pfe_5_tuple_t));
 
-	(void)memset(tuple, 0, sizeof(pfe_5_tuple_t));
-
-	(void)memcpy(&tuple->src_ip.v6, &ct6_cmd->saddr_reply[0], 16);
-	(void)memcpy(&tuple->dst_ip.v6, &ct6_cmd->daddr_reply[0], 16);
-	tuple->src_ip.is_ipv4 = FALSE;
-	tuple->dst_ip.is_ipv4 = FALSE;
-	tuple->sport = oal_ntohs(ct6_cmd->sport_reply);
-	tuple->dport = oal_ntohs(ct6_cmd->dport_reply);
-	tuple->proto = (uint8_t)oal_ntohs(ct6_cmd->protocol);
+		(void)memcpy(&tuple->src_ip.v6, &ct6_cmd->saddr_reply[0], 16);
+		(void)memcpy(&tuple->dst_ip.v6, &ct6_cmd->daddr_reply[0], 16);
+		tuple->src_ip.is_ipv4 = FALSE;
+		tuple->dst_ip.is_ipv4 = FALSE;
+		tuple->sport = oal_ntohs(ct6_cmd->sport_reply);
+		tuple->dport = oal_ntohs(ct6_cmd->dport_reply);
+		tuple->proto = (uint8_t)oal_ntohs(ct6_cmd->protocol);
+	}
 }
 
 /**
@@ -417,82 +421,93 @@ static pfe_rtable_entry_t *fci_connections_create_entry(const fci_rt_db_entry_t
 	if (unlikely((NULL == route) || (NULL == tuple)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return NULL;
+		new_entry = NULL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	/*	Create new entry */
-	new_entry = pfe_rtable_entry_create();
-	if (NULL == new_entry)
-	{
-		NXP_LOG_ERROR("Couldn't create routing table entry\n");
-		return NULL;
-	}
-
-	/*	Set 5-tuple */
-	if (EOK != pfe_rtable_entry_set_5t(new_entry, tuple))
-	{
-		NXP_LOG_ERROR("Can't set 5 tuple\n");
-		pfe_rtable_entry_free(new_entry);
-		return NULL;
-	}
-
-	/*	Set properties */
-	(void)pfe_rtable_entry_set_dstif(new_entry, route->iface);
-	pfe_rtable_entry_set_timeout(new_entry, fci_connections_get_default_timeout(tuple->proto));
-	/*	Set route ID (network endian) */
-	pfe_rtable_entry_set_route_id(new_entry, route->id);
-	/*	Set ttl decrement by default */
-	pfe_rtable_entry_set_ttl_decrement(new_entry);
-
-	/*	Change MAC addresses */
-	pfe_rtable_entry_set_out_mac_addrs(new_entry, route->src_mac, route->dst_mac);
-
-	if (NULL != tuple_rep)
 	{
-		/*	Check if SRC IP NAT is requested */
-		if (0 != memcmp(&tuple->src_ip, &tuple_rep->dst_ip, sizeof(pfe_ip_addr_t)))
+		/*	Create new entry */
+		new_entry = pfe_rtable_entry_create();
+		if (NULL == new_entry)
 		{
-			/*	SADDR need to be changed to DADDR_REPLY */
-			if (EOK != pfe_rtable_entry_set_out_sip(new_entry, &tuple_rep->dst_ip))
-			{
-				NXP_LOG_ERROR("Couldn't set output SIP\n");
-				pfe_rtable_entry_free(new_entry);
-				return NULL;
-			}
+			NXP_LOG_ERROR("Couldn't create routing table entry\n");
 		}
-
-		/*	Check if DST IP NAT is requested */
-		if (0 != memcmp(&tuple->dst_ip, &tuple_rep->src_ip, sizeof(pfe_ip_addr_t)))
+		else
 		{
-			/*	DADDR need to be changed to SADDR_REPLY */
-			if (EOK != pfe_rtable_entry_set_out_dip(new_entry, &tuple_rep->src_ip))
+			/*	Set 5-tuple */
+			if (EOK != pfe_rtable_entry_set_5t(new_entry, tuple))
 			{
-				NXP_LOG_ERROR("Couldn't set output DIP\n");
+				NXP_LOG_ERROR("Can't set 5 tuple\n");
 				pfe_rtable_entry_free(new_entry);
-				return NULL;
+				new_entry = NULL;
 			}
-		}
-
-		/*	Check if SRC PORT translation is requested */
-		if (tuple->sport != tuple_rep->dport)
-		{
-			/*	SPORT need to be changed to DPORT_REPLY */
-			pfe_rtable_entry_set_out_sport(new_entry, tuple_rep->dport);
-		}
+			else
+			{
+				/*	Set properties */
+				(void)pfe_rtable_entry_set_dstif(new_entry, route->iface);
+				pfe_rtable_entry_set_timeout(new_entry, fci_connections_get_default_timeout(tuple->proto));
+				/*	Set route ID (network endian) */
+				pfe_rtable_entry_set_route_id(new_entry, route->id);
+				/*	Set ttl decrement by default */
+				pfe_rtable_entry_set_ttl_decrement(new_entry);
+
+				/*	Change MAC addresses */
+				pfe_rtable_entry_set_out_mac_addrs(new_entry, route->src_mac, route->dst_mac);
+
+				if (NULL != tuple_rep)
+				{
+					/*	Check if SRC IP NAT is requested */
+					if (0 != memcmp(&tuple->src_ip, &tuple_rep->dst_ip, sizeof(pfe_ip_addr_t)))
+					{
+						/*	SADDR need to be changed to DADDR_REPLY */
+						if (EOK != pfe_rtable_entry_set_out_sip(new_entry, &tuple_rep->dst_ip))
+						{
+							NXP_LOG_ERROR("Couldn't set output SIP\n");
+							pfe_rtable_entry_free(new_entry);
+							new_entry = NULL;
+						}
+					}
 
-		/*	Check if DST PORT translation is requested */
-		if (tuple->dport != tuple_rep->sport)
-		{
-			/*	DPORT need to be changed to SPORT_REPLY */
-			pfe_rtable_entry_set_out_dport(new_entry, tuple_rep->sport);
+					if(NULL != new_entry)
+					{
+						/*	Check if DST IP NAT is requested */
+						if (0 != memcmp(&tuple->dst_ip, &tuple_rep->src_ip, sizeof(pfe_ip_addr_t)))
+						{
+							/*	DADDR need to be changed to SADDR_REPLY */
+							if (EOK != pfe_rtable_entry_set_out_dip(new_entry, &tuple_rep->src_ip))
+							{
+								NXP_LOG_ERROR("Couldn't set output DIP\n");
+								pfe_rtable_entry_free(new_entry);
+								new_entry = NULL;
+							}
+						}
+
+						if(NULL != new_entry)
+						{
+							/*	Check if SRC PORT translation is requested */
+							if (tuple->sport != tuple_rep->dport)
+							{
+								/*	SPORT need to be changed to DPORT_REPLY */
+								pfe_rtable_entry_set_out_sport(new_entry, tuple_rep->dport);
+							}
+
+							/*	Check if DST PORT translation is requested */
+							if (tuple->dport != tuple_rep->sport)
+							{
+								/*	DPORT need to be changed to SPORT_REPLY */
+								pfe_rtable_entry_set_out_dport(new_entry, tuple_rep->sport);
+							}
+						}
+					}
+				}
+				else
+				{
+					/*	No reply direction defined = no NAT */
+					;
+				}
+			}
 		}
 	}
-	else
-	{
-		/*	No reply direction defined = no NAT */
-		;
-	}
 
 	return new_entry;
 }
@@ -510,59 +525,68 @@ static errno_t fci_connections_ipv4_cmd_to_entry(const fpp_ct_cmd_t *ct_cmd, pfe
 	fci_rt_db_entry_t *route;
 	pfe_5_tuple_t tuple_buf, tuple_rep_buf;
 	pfe_5_tuple_t *tuple = &tuple_buf, *tuple_rep = &tuple_rep_buf;
+	errno_t ret;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == ct_cmd) || (NULL == entry)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-    if (unlikely(FALSE == fci_context->fci_initialized))
+    else if (unlikely(FALSE == fci_context->fci_initialized))
 	{
     	NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
+		ret = EPERM;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	/*	Check if original direction is enabled */
-	if (0U != (oal_ntohs(ct_cmd->flags) & CTCMD_FLAGS_ORIG_DISABLED))
-	{
-		/*	Original direction is disabled */
-		*entry = NULL;
-		*iface = NULL;
-		return EOK;
-	}
-
-	/*	Get route */
-	route = fci_rt_db_get_first(&fci_context->route_db, RT_DB_CRIT_BY_ID, (const void *)&ct_cmd->route_id);
-	if (NULL == route)
 	{
-		NXP_LOG_ERROR("No such route (0x%x)\n", (uint_t)ct_cmd->route_id);
-		return EINVAL;
-	}
-
-	/*	Get 5 tuples */
-	fci_connections_ipv4_cmd_to_5t(ct_cmd, tuple);
-	fci_connections_ipv4_cmd_to_5t_rep(ct_cmd, tuple_rep);
+		/* Check if original direction is enabled */
+		if (0U != (oal_ntohs(ct_cmd->flags) & CTCMD_FLAGS_ORIG_DISABLED))
+		{
+			/*	Original direction is disabled */
+			*entry = NULL;
+			*iface = NULL;
+			ret = EOK;
+		}
+		else
+		{
+			/*	Get route */
+			route = fci_rt_db_get_first(&fci_context->route_db, RT_DB_CRIT_BY_ID, (const void *)&ct_cmd->route_id);
+			if (NULL == route)
+			{
+				NXP_LOG_ERROR("No such route (0x%x)\n", (uint_t)ct_cmd->route_id);
+				ret = EINVAL;
+			}
+			else
+			{
+				/*	Get 5 tuples */
+				fci_connections_ipv4_cmd_to_5t(ct_cmd, tuple);
+				fci_connections_ipv4_cmd_to_5t_rep(ct_cmd, tuple_rep);
 
-	/*	Create new entry for flow given by the 'tuple' */
-	*entry = fci_connections_create_entry(route, tuple, tuple_rep);
-	if (NULL == *entry)
-	{
-		NXP_LOG_ERROR("Couldn't create routing rule\n");
-		return EINVAL;
-	}
+				/*	Create new entry for flow given by the 'tuple' */
+				*entry = fci_connections_create_entry(route, tuple, tuple_rep);
+				if (NULL == *entry)
+				{
+					NXP_LOG_ERROR("Couldn't create routing rule\n");
+					ret = EINVAL;
+				}
+				else
+				{
+					if (0U != ct_cmd->vlan)
+					{
+						pfe_rtable_entry_set_out_vlan(*entry, oal_ntohs(ct_cmd->vlan), TRUE);
+					}
 
-	if (0U != ct_cmd->vlan)
-	{
-		pfe_rtable_entry_set_out_vlan(*entry, oal_ntohs(ct_cmd->vlan), TRUE);
+					/*	Return interface */
+					*iface = route->iface;
+					ret = EOK;
+				}
+			}
+		}
 	}
 
-	/*	Return interface */
-	*iface = route->iface;
-
-	return EOK;
+	return ret;
 }
 
 /**
@@ -580,59 +604,68 @@ static errno_t fci_connections_ipv4_cmd_to_rep_entry(const fpp_ct_cmd_t *ct_cmd,
 	fci_rt_db_entry_t *route;
 	pfe_5_tuple_t tuple_buf, tuple_rep_buf;
 	pfe_5_tuple_t *tuple = &tuple_buf, *tuple_rep = &tuple_rep_buf;
+	errno_t ret;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == ct_cmd) || (NULL == entry) || (NULL == iface)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-    if (unlikely(FALSE == fci_context->fci_initialized))
+	else if (unlikely(FALSE == fci_context->fci_initialized))
 	{
     	NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
+		ret = EPERM;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	/*	Check if reply direction is enabled */
-	if (0U != (oal_ntohs(ct_cmd->flags) & CTCMD_FLAGS_REP_DISABLED))
-	{
-		/*	Reply direction is disabled */
-		*entry = NULL;
-		*iface = NULL;
-		return EOK;
-	}
-
-	/*	Get route */
-	route = fci_rt_db_get_first(&fci_context->route_db, RT_DB_CRIT_BY_ID, (const void *)&ct_cmd->route_id_reply);
-	if (NULL == route)
 	{
-		NXP_LOG_ERROR("No such route (0x%x)\n", (uint_t)oal_ntohl(ct_cmd->route_id_reply));
-		return EINVAL;
-	}
-
-	/*	Get 5 tuples. Reply entries are created using 'reply' values of CT commands. */
-	fci_connections_ipv4_cmd_to_5t(ct_cmd, tuple_rep);
-	fci_connections_ipv4_cmd_to_5t_rep(ct_cmd, tuple);
+		/* Check if reply direction is enabled */
+		if (0U != (oal_ntohs(ct_cmd->flags) & CTCMD_FLAGS_REP_DISABLED))
+		{
+			/*	Reply direction is disabled */
+			*entry = NULL;
+			*iface = NULL;
+			ret = EOK;
+		}
+		else
+		{
+			/*	Get route */
+			route = fci_rt_db_get_first(&fci_context->route_db, RT_DB_CRIT_BY_ID, (const void *)&ct_cmd->route_id_reply);
+			if (NULL == route)
+			{
+				NXP_LOG_ERROR("No such route (0x%x)\n", (uint_t)oal_ntohl(ct_cmd->route_id_reply));
+				ret = EINVAL;
+			}
+			else
+			{
+				/*	Get 5 tuples. Reply entries are created using 'reply' values of CT commands. */
+				fci_connections_ipv4_cmd_to_5t(ct_cmd, tuple_rep);
+				fci_connections_ipv4_cmd_to_5t_rep(ct_cmd, tuple);
 
-	/*	Create new entry for flow given by the 'tuple' */
-	*entry = fci_connections_create_entry(route, tuple, tuple_rep);
-	if (NULL == *entry)
-	{
-		NXP_LOG_ERROR("Couldn't create 'reply' routing rule\n");
-		return EINVAL;
-	}
+				/*	Create new entry for flow given by the 'tuple' */
+				*entry = fci_connections_create_entry(route, tuple, tuple_rep);
+				if (NULL == *entry)
+				{
+					NXP_LOG_ERROR("Couldn't create 'reply' routing rule\n");
+					ret = EINVAL;
+				}
+				else
+				{
+					if (0U != ct_cmd->vlan_reply)
+					{
+						pfe_rtable_entry_set_out_vlan(*entry, oal_ntohs(ct_cmd->vlan_reply), TRUE);
+					}
 
-	if (0U != ct_cmd->vlan_reply)
-	{
-		pfe_rtable_entry_set_out_vlan(*entry, oal_ntohs(ct_cmd->vlan_reply), TRUE);
+					/*	Return interface */
+					*iface = route->iface;
+					ret = EOK;
+				}
+			}
+		}
 	}
 
-	/*	Return interface */
-	*iface = route->iface;
-
-	return EOK;
+	return ret;
 }
 
 /**
@@ -648,58 +681,66 @@ static errno_t fci_connections_ipv6_cmd_to_entry(const fpp_ct6_cmd_t *ct6_cmd, p
 	fci_rt_db_entry_t *route;
 	pfe_5_tuple_t tuple_buf, tuple_rep_buf;
 	pfe_5_tuple_t *tuple = &tuple_buf, *tuple_rep = &tuple_rep_buf;
+	errno_t ret;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == ct6_cmd) || (NULL == entry) || (NULL == iface)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-    if (unlikely(FALSE == fci_context->fci_initialized))
+    else if (unlikely(FALSE == fci_context->fci_initialized))
 	{
     	NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
+		ret = EPERM;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	/*	Check if original direction is enabled */
-	if (0U != (oal_ntohs(ct6_cmd->flags) & CTCMD_FLAGS_ORIG_DISABLED))
-	{
-		/*	Original direction is disabled */
-		*entry = NULL;
-		return EOK;
-	}
-
-	/*	Get route */
-	route = fci_rt_db_get_first(&fci_context->route_db, RT_DB_CRIT_BY_ID, (const void *)&ct6_cmd->route_id);
-	if (NULL == route)
 	{
-		NXP_LOG_ERROR("No such route (0x%x)\n", (uint_t)ct6_cmd->route_id);
-		return EINVAL;
-	}
-
-	/*	Get 5 tuples */
-	fci_connections_ipv6_cmd_to_5t(ct6_cmd, tuple);
-	fci_connections_ipv6_cmd_to_5t_rep(ct6_cmd, tuple_rep);
+		/*	Check if original direction is enabled */
+		if (0U != (oal_ntohs(ct6_cmd->flags) & CTCMD_FLAGS_ORIG_DISABLED))
+		{
+			/*	Original direction is disabled */
+			*entry = NULL;
+			ret = EOK;
+		}
+		else
+		{
+			/*	Get route */
+			route = fci_rt_db_get_first(&fci_context->route_db, RT_DB_CRIT_BY_ID, (const void *)&ct6_cmd->route_id);
+			if (NULL == route)
+			{
+				NXP_LOG_ERROR("No such route (0x%x)\n", (uint_t)ct6_cmd->route_id);
+				ret = EINVAL;
+			}
+			else
+			{
+				/*	Get 5 tuples */
+				fci_connections_ipv6_cmd_to_5t(ct6_cmd, tuple);
+				fci_connections_ipv6_cmd_to_5t_rep(ct6_cmd, tuple_rep);
 
-	/*	Create new entry for flow given by the 'tuple' */
-	*entry = fci_connections_create_entry(route, tuple, tuple_rep);
-	if (NULL == *entry)
-	{
-		NXP_LOG_ERROR("Couldn't create routing rule\n");
-		return EINVAL;
-	}
+				/*	Create new entry for flow given by the 'tuple' */
+				*entry = fci_connections_create_entry(route, tuple, tuple_rep);
+				if (NULL == *entry)
+				{
+					NXP_LOG_ERROR("Couldn't create routing rule\n");
+					ret =  EINVAL;
+				}
+				else
+				{
+					if (0U != ct6_cmd->vlan)
+					{
+						pfe_rtable_entry_set_out_vlan(*entry, oal_ntohs(ct6_cmd->vlan), TRUE);
+					}
 
-	if (0U != ct6_cmd->vlan)
-	{
-		pfe_rtable_entry_set_out_vlan(*entry, oal_ntohs(ct6_cmd->vlan), TRUE);
+					/*	Return interface */
+					*iface = route->iface;
+					ret = EOK;
+				}
+			}
+		}
 	}
-
-	/*	Return interface */
-	*iface = route->iface;
-
-	return EOK;
+	return ret;
 }
 
 /**
@@ -717,59 +758,68 @@ static errno_t fci_connections_ipv6_cmd_to_rep_entry(const fpp_ct6_cmd_t *ct6_cm
 	fci_rt_db_entry_t *route;
 	pfe_5_tuple_t tuple_buf, tuple_rep_buf;
 	pfe_5_tuple_t *tuple = &tuple_buf, *tuple_rep = &tuple_rep_buf;
+	errno_t ret;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == ct6_cmd) || (NULL == entry)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-    if (unlikely(FALSE == fci_context->fci_initialized))
+	else if (unlikely(FALSE == fci_context->fci_initialized))
 	{
     	NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
+		ret = EPERM;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	/*	Check if reply direction is enabled */
-	if (0U != (oal_ntohs(ct6_cmd->flags) & CTCMD_FLAGS_REP_DISABLED))
-	{
-		/*	Reply direction is disabled */
-		*entry = NULL;
-		*iface = NULL;
-		return EOK;
-	}
-
-	/*	Get route */
-	route = fci_rt_db_get_first(&fci_context->route_db, RT_DB_CRIT_BY_ID, (const void *)&ct6_cmd->route_id_reply);
-	if (NULL == route)
 	{
-		NXP_LOG_ERROR("No such route (0x%x)\n", (uint_t)oal_ntohl(ct6_cmd->route_id_reply));
-		return EINVAL;
-	}
-
-	/*	Get 5 tuples. Reply entries are created using 'reply' values of CT commands. */
-	fci_connections_ipv6_cmd_to_5t(ct6_cmd, tuple_rep);
-	fci_connections_ipv6_cmd_to_5t_rep(ct6_cmd, tuple);
+		/*	Check if reply direction is enabled */
+		if (0U != (oal_ntohs(ct6_cmd->flags) & CTCMD_FLAGS_REP_DISABLED))
+		{
+			/*	Reply direction is disabled */
+			*entry = NULL;
+			*iface = NULL;
+			ret = EOK;
+		}
+		else
+		{
+			/*	Get route */
+			route = fci_rt_db_get_first(&fci_context->route_db, RT_DB_CRIT_BY_ID, (const void *)&ct6_cmd->route_id_reply);
+			if (NULL == route)
+			{
+				NXP_LOG_ERROR("No such route (0x%x)\n", (uint_t)oal_ntohl(ct6_cmd->route_id_reply));
+				ret = EINVAL;
+			}
+			else
+			{
+				/*	Get 5 tuples. Reply entries are created using 'reply' values of CT commands. */
+				fci_connections_ipv6_cmd_to_5t(ct6_cmd, tuple_rep);
+				fci_connections_ipv6_cmd_to_5t_rep(ct6_cmd, tuple);
 
-	/*	Create new entry for flow given by the 'tuple' */
-	*entry = fci_connections_create_entry(route, tuple, tuple_rep);
-	if (NULL == *entry)
-	{
-		NXP_LOG_ERROR("Couldn't create 'reply' routing rule\n");
-		return EINVAL;
-	}
+				/*	Create new entry for flow given by the 'tuple' */
+				*entry = fci_connections_create_entry(route, tuple, tuple_rep);
+				if (NULL == *entry)
+				{
+					NXP_LOG_ERROR("Couldn't create 'reply' routing rule\n");
+					ret = EINVAL;
+				}
+				else
+				{
+					if (0U != ct6_cmd->vlan_reply)
+					{
+						pfe_rtable_entry_set_out_vlan(*entry, oal_ntohs(ct6_cmd->vlan_reply), TRUE);
+					}
 
-	if (0U != ct6_cmd->vlan_reply)
-	{
-		pfe_rtable_entry_set_out_vlan(*entry, oal_ntohs(ct6_cmd->vlan_reply), TRUE);
+					/*	Return interface */
+					*iface = route->iface;
+					ret = EOK;
+				}
+			}
+		}
 	}
 
-	/*	Return interface */
-	*iface = route->iface;
-
-	return EOK;
+	return ret;
 }
 
 /**
@@ -796,531 +846,554 @@ static errno_t fci_connections_ipvx_ct_cmd(bool_t ipv6, const fci_msg_t *msg, ui
 	pfe_ct_route_actions_t actions;
 	pfe_phy_if_t *phy_if = NULL, *phy_if_reply = NULL;
 	uint16_t vlan;
+	pfe_ct_conntrack_stats_t stats = {0U};
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
-	}
-
-    if (unlikely(FALSE == fci_context->fci_initialized))
-	{
-    	NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if ((*reply_len < sizeof(fpp_ct_cmd_t)) || (*reply_len < sizeof(fpp_ct6_cmd_t)))
-	{
-		NXP_LOG_DEBUG("Buffer length does not match expected value (fpp_ct_cmd_t or fpp_ct6_cmd_t)\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-	else
-	{
-		/*	No data written to reply buffer (yet) */
-		*reply_len = 0U;
-	}
-
-	/*	Initialize the reply buffer */
-	if (sizeof(fpp_ct_cmd_t) > sizeof(fpp_ct6_cmd_t))
+	else if (unlikely(FALSE == fci_context->fci_initialized))
 	{
-		(void)memset(reply_buf, 0, sizeof(fpp_ct_cmd_t));
+		NXP_LOG_ERROR("Context not initialized\n");
+		ret = EPERM;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		(void)memset(reply_buf, 0, sizeof(fpp_ct6_cmd_t));
-	}
-
-	ct_cmd = (fpp_ct_cmd_t *)(msg->msg_cmd.payload);
-	ct6_cmd = (fpp_ct6_cmd_t *)(msg->msg_cmd.payload);
-
-	switch (ct_cmd->action)
-	{
-		case FPP_ACTION_REGISTER:
+		if ((*reply_len < sizeof(fpp_ct_cmd_t)) || (*reply_len < sizeof(fpp_ct6_cmd_t)))
 		{
-#if (PFE_CFG_VERBOSITY_LEVEL >= 8)
-			if (TRUE == ipv6)
-			{
-				NXP_LOG_DEBUG("Attempt to register IPv6 connection:\n%s\n", fci_connections_ipv6_cmd_to_str(ct6_cmd));
-			}
-			else
-			{
-				NXP_LOG_DEBUG("Attempt to register IPv4 connection:\n%s\n", fci_connections_ipv4_cmd_to_str(ct_cmd));
-			}
-#endif /* PFE_CFG_VERBOSITY_LEVEL */
-
-			/*	Get new routing table entry in forward direction */
-			if (TRUE == ipv6)
-			{
-				ret = fci_connections_ipv6_cmd_to_entry(ct6_cmd, &entry, &phy_if);
-			}
-			else
-			{
-				ret = fci_connections_ipv4_cmd_to_entry(ct_cmd, &entry, &phy_if);
-			}
-
-			if (EINVAL == ret)
-			{
-				NXP_LOG_DEBUG("FPP_CMD_IPVx_CONNTRACK: Couldn't convert command to valid entry\n");
-				*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-				ret = EOK;
-				break;
-			}
-			else if (EOK != ret)
+			NXP_LOG_DEBUG("Buffer length does not match expected value (fpp_ct_cmd_t or fpp_ct6_cmd_t)\n");
+			ret = EINVAL;
+		}
+		else
+		{
+			/*	No data written to reply buffer (yet) */
+			*reply_len = 0U;
+			/*	Initialize the reply buffer */
+			if (sizeof(fpp_ct_cmd_t) > sizeof(fpp_ct6_cmd_t))
 			{
-				break;
+				(void)memset(reply_buf, 0, sizeof(fpp_ct_cmd_t));
 			}
 			else
 			{
-                /* Empty else is required by MISRA */
-				;
+				(void)memset(reply_buf, 0, sizeof(fpp_ct6_cmd_t));
 			}
 
-			/*	Get new routing table entry in reply direction */
-			if (TRUE == ipv6)
-			{
-				ret = fci_connections_ipv6_cmd_to_rep_entry(ct6_cmd, &rep_entry, &phy_if_reply);
-			}
-			else
-			{
-				ret = fci_connections_ipv4_cmd_to_rep_entry(ct_cmd, &rep_entry, &phy_if_reply);
-			}
+			ct_cmd = (fpp_ct_cmd_t *)(msg->msg_cmd.payload);
+			ct6_cmd = (fpp_ct6_cmd_t *)(msg->msg_cmd.payload);
 
-			if (EINVAL == ret)
-			{
-				NXP_LOG_DEBUG("FPP_CMD_IPVx_CONNTRACK: Couldn't convert command to valid entry (reply direction)\n");
-				*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-				ret = EOK;
-				break;
-			}
-			else if (EOK != ret)
-			{
-				break;
-			}
-			else
+			switch (ct_cmd->action)
 			{
-                /* Empty else is required by MISRA */
-				;
-			}
+				case FPP_ACTION_REGISTER:
+				{
+		#if (PFE_CFG_VERBOSITY_LEVEL >= 8)
+					if (TRUE == ipv6)
+					{
+						NXP_LOG_DEBUG("Attempt to register IPv6 connection:\n%s\n", fci_connections_ipv6_cmd_to_str(ct6_cmd));
+					}
+					else
+					{
+						NXP_LOG_DEBUG("Attempt to register IPv4 connection:\n%s\n", fci_connections_ipv4_cmd_to_str(ct_cmd));
+					}
+		#endif /* PFE_CFG_VERBOSITY_LEVEL */
 
-			/*	Add entry into the routing table */
-			if (NULL != entry)
-			{
-				/*	Remember that there is an associated entry */
-				pfe_rtable_entry_set_child(entry, rep_entry);
-				pfe_rtable_entry_set_refptr(entry, msg->client);
+					/*	Get new routing table entry in forward direction */
+					if (TRUE == ipv6)
+					{
+						ret = fci_connections_ipv6_cmd_to_entry(ct6_cmd, &entry, &phy_if);
+					}
+					else
+					{
+						ret = fci_connections_ipv4_cmd_to_entry(ct_cmd, &entry, &phy_if);
+					}
 
-				ret = pfe_rtable_add_entry(fci_context->rtable, entry);
-				if (EEXIST == ret)
-				{
-					NXP_LOG_WARNING("FPP_CMD_IPVx_CONNTRACK: Entry already added\n");
-					*fci_ret = FPP_ERR_RT_ENTRY_ALREADY_REGISTERED;
-					goto free_and_fail;
-				}
-				else if (EOK != ret)
-				{
-					NXP_LOG_ERROR("FPP_CMD_IPVx_CONNTRACK: Can't add entry: %d\n", ret);
-					*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-					goto free_and_fail;
-				}
-				else
-				{
-					NXP_LOG_DEBUG("FPP_CMD_IPVx_CONNTRACK: Entry added\n");
-					*fci_ret = FPP_ERR_OK;
-				}
-			}
-
-			/*	Add entry also for reply direction if requested */
-			if (NULL != rep_entry)
-			{
-				ret = pfe_rtable_add_entry(fci_context->rtable, rep_entry);
-				if (EEXIST == ret)
-				{
-					NXP_LOG_WARNING("FPP_CMD_IPVx_CONNTRACK: Reply entry already added\n");
-				}
-				else if (EOK != ret)
-				{
-					NXP_LOG_ERROR("FPP_CMD_IPVx_CONNTRACK: Can't add reply entry: %d\n", ret);
-					*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-					goto free_and_fail;
-				}
-				else
-				{
-					NXP_LOG_DEBUG("FPP_CMD_IPVx_CONNTRACK: Entry added (reply direction)\n");
-					*fci_ret = FPP_ERR_OK;
-				}
-			}
-
-			break;
+					if (EINVAL == ret)
+					{
+						NXP_LOG_DEBUG("FPP_CMD_IPVx_CONNTRACK: Couldn't convert command to valid entry\n");
+						*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+						ret = EOK;
+						break;
+					}
+					else if (EOK != ret)
+					{
+						break;
+					}
+					else
+					{
+						/* Empty else is required by MISRA */
+						;
+					}
 
-free_and_fail:
-			/*	The 'ret' and '*fci_ret' values are already set */
+					/*	Get new routing table entry in reply direction */
+					if (TRUE == ipv6)
+					{
+						ret = fci_connections_ipv6_cmd_to_rep_entry(ct6_cmd, &rep_entry, &phy_if_reply);
+					}
+					else
+					{
+						ret = fci_connections_ipv4_cmd_to_rep_entry(ct_cmd, &rep_entry, &phy_if_reply);
+					}
 
-			if (NULL != entry)
-			{
-				if (EOK != pfe_rtable_del_entry(fci_context->rtable, entry))
-				{
-					NXP_LOG_ERROR("Can't remove route entry\n");
-				}
+					if (EINVAL == ret)
+					{
+						NXP_LOG_DEBUG("FPP_CMD_IPVx_CONNTRACK: Couldn't convert command to valid entry (reply direction)\n");
+						*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+						ret = EOK;
+						break;
+					}
+					else if (EOK != ret)
+					{
+						break;
+					}
+					else
+					{
+						/* Empty else is required by MISRA */
+						;
+					}
 
-				pfe_rtable_entry_free(entry);
-				entry = NULL;
-			}
+					/*	Add entry into the routing table */
+					if (NULL != entry)
+					{
+						/*	Remember that there is an associated entry */
+						pfe_rtable_entry_set_child(entry, rep_entry);
+						pfe_rtable_entry_set_refptr(entry, msg->client);
+
+						ret = pfe_rtable_add_entry(fci_context->rtable, entry);
+						if (EEXIST == ret)
+						{
+							NXP_LOG_WARNING("FPP_CMD_IPVx_CONNTRACK: Entry already added\n");
+							*fci_ret = FPP_ERR_RT_ENTRY_ALREADY_REGISTERED;
+							goto free_and_fail;
+						}
+						else if (EOK != ret)
+						{
+							NXP_LOG_ERROR("FPP_CMD_IPVx_CONNTRACK: Can't add entry: %d\n", ret);
+							*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+							goto free_and_fail;
+						}
+						else
+						{
+							NXP_LOG_DEBUG("FPP_CMD_IPVx_CONNTRACK: Entry added\n");
+							*fci_ret = FPP_ERR_OK;
+						}
+					}
 
-			if (NULL != rep_entry)
-			{
-				if (EOK != pfe_rtable_del_entry(fci_context->rtable, rep_entry))
-				{
-					NXP_LOG_ERROR("Can't remove route entry\n");
-				}
+					/*	Add entry also for reply direction if requested */
+					if (NULL != rep_entry)
+					{
+						ret = pfe_rtable_add_entry(fci_context->rtable, rep_entry);
+						if (EEXIST == ret)
+						{
+							NXP_LOG_WARNING("FPP_CMD_IPVx_CONNTRACK: Reply entry already added\n");
+						}
+						else if (EOK != ret)
+						{
+							NXP_LOG_ERROR("FPP_CMD_IPVx_CONNTRACK: Can't add reply entry: %d\n", ret);
+							*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+							goto free_and_fail;
+						}
+						else
+						{
+							NXP_LOG_DEBUG("FPP_CMD_IPVx_CONNTRACK: Entry added (reply direction)\n");
+							*fci_ret = FPP_ERR_OK;
+						}
+					}
 
-				pfe_rtable_entry_free(rep_entry);
-				rep_entry = NULL;
-			}
+					break;
 
-			break;
-		}
+		free_and_fail:
+					/*	The 'ret' and '*fci_ret' values are already set */
 
-		case FPP_ACTION_DEREGISTER:
-		{
-#if (PFE_CFG_VERBOSITY_LEVEL >= 8)
-			if (TRUE == ipv6)
-			{
-				NXP_LOG_DEBUG("Attempt to unregister IPv6 connection:\n%s\n", fci_connections_ipv6_cmd_to_str(ct6_cmd));
-			}
-			else
-			{
-				NXP_LOG_DEBUG("Attempt to unregister IPv4 connection:\n%s\n", fci_connections_ipv4_cmd_to_str(ct_cmd));
-			}
-#endif /* PFE_CFG_VERBOSITY_LEVEL */
+					if (NULL != entry)
+					{
+						if (EOK != pfe_rtable_del_entry(fci_context->rtable, entry))
+						{
+							NXP_LOG_ERROR("Can't remove route entry\n");
+						}
 
-			/*	Get entry by 5-tuple */
-			if (TRUE == ipv6)
-			{
-				fci_connections_ipv6_cmd_to_5t(ct6_cmd, &tuple);
-			}
-			else
-			{
-				fci_connections_ipv4_cmd_to_5t(ct_cmd, &tuple);
-			}
+						pfe_rtable_entry_free(entry);
+						entry = NULL;
+					}
 
-			entry = pfe_rtable_get_first(fci_context->rtable, RTABLE_CRIT_BY_5_TUPLE, (void *)&tuple);
+					if (NULL != rep_entry)
+					{
+						if (EOK != pfe_rtable_del_entry(fci_context->rtable, rep_entry))
+						{
+							NXP_LOG_ERROR("Can't remove route entry\n");
+						}
 
-			/*	Delete the entries from table */
-			if (NULL != entry)
-			{
-				/*	Get associated entry */
-				rep_entry = pfe_rtable_entry_get_child(entry);
+						pfe_rtable_entry_free(rep_entry);
+						rep_entry = NULL;
+					}
 
-				ret = pfe_rtable_del_entry(fci_context->rtable, entry);
-				if (EOK != ret)
-				{
-					NXP_LOG_ERROR("Can't remove route entry: %d\n", ret);
-					*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
 					break;
 				}
-				else
-				{
-					/*	Release all entry-related resources */
-					NXP_LOG_DEBUG("FPP_CMD_IPVx_CONNTRACK: Entry removed\n");
-					pfe_rtable_entry_free(entry);
-					entry = NULL;
-					*fci_ret = FPP_ERR_OK;
-				}
-			}
-			else
-			{
-				NXP_LOG_DEBUG("FPP_CMD_IPVx_CONNTRACK: Entry not found\n");
-				*fci_ret = FPP_ERR_CT_ENTRY_NOT_FOUND;
-				break;
-			}
 
-			/*	Delete also the reply direction */
-			if (NULL != rep_entry)
-			{
-				ret = pfe_rtable_del_entry(fci_context->rtable, rep_entry);
-				if (EOK != ret)
+				case FPP_ACTION_DEREGISTER:
 				{
-					NXP_LOG_ERROR("Can't remove reply route entry: %d\n", ret);
-					*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-					break;
-				}
-				else
-				{
-					/*	Release all entry-related resources */
-					NXP_LOG_DEBUG("FPP_CMD_IPVx_CONNTRACK: Entry removed (reply direction)\n");
-					pfe_rtable_entry_free(rep_entry);
-					rep_entry = NULL;
-					*fci_ret = FPP_ERR_OK;
-				}
-			}
-			else
-			{
-				/*	TODO: Reply entry not found. Should be there or not? */
-				;
-			}
-
-			break;
-		}
+		#if (PFE_CFG_VERBOSITY_LEVEL >= 8)
+					if (TRUE == ipv6)
+					{
+						NXP_LOG_DEBUG("Attempt to unregister IPv6 connection:\n%s\n", fci_connections_ipv6_cmd_to_str(ct6_cmd));
+					}
+					else
+					{
+						NXP_LOG_DEBUG("Attempt to unregister IPv4 connection:\n%s\n", fci_connections_ipv4_cmd_to_str(ct_cmd));
+					}
+		#endif /* PFE_CFG_VERBOSITY_LEVEL */
 
-		case FPP_ACTION_UPDATE:
-		{
-#if (PFE_CFG_VERBOSITY_LEVEL >= 8)
-			if (TRUE == ipv6)
-			{
-				NXP_LOG_DEBUG("Attempt to update IPv6 connection:\n%s\n", fci_connections_ipv6_cmd_to_str(ct6_cmd));
-			}
-			else
-			{
-				NXP_LOG_DEBUG("Attempt to update IPv4 connection:\n%s\n", fci_connections_ipv4_cmd_to_str(ct_cmd));
-			}
-#endif /* PFE_CFG_VERBOSITY_LEVEL */
+					/*	Get entry by 5-tuple */
+					if (TRUE == ipv6)
+					{
+						fci_connections_ipv6_cmd_to_5t(ct6_cmd, &tuple);
+					}
+					else
+					{
+						fci_connections_ipv4_cmd_to_5t(ct_cmd, &tuple);
+					}
 
-			NXP_LOG_INFO("UPDATED conntrack, only TTL decrement flag will be updated\n");
+					entry = pfe_rtable_get_first(fci_context->rtable, RTABLE_CRIT_BY_5_TUPLE, (void *)&tuple);
 
-			/*      Get entry by 5-tuple */
-			if (TRUE == ipv6)
- 			{
-				fci_connections_ipv6_cmd_to_5t(ct6_cmd, &tuple);
-			}
-			else
-			{
-				fci_connections_ipv4_cmd_to_5t(ct_cmd, &tuple);
-			}
+					/*	Delete the entries from table */
+					if (NULL != entry)
+					{
+						/*	Get associated entry */
+						rep_entry = pfe_rtable_entry_get_child(entry);
+
+						ret = pfe_rtable_del_entry(fci_context->rtable, entry);
+						if (EOK != ret)
+						{
+							NXP_LOG_ERROR("Can't remove route entry: %d\n", ret);
+							*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+							break;
+						}
+						else
+						{
+							/*	Release all entry-related resources */
+							NXP_LOG_DEBUG("FPP_CMD_IPVx_CONNTRACK: Entry removed\n");
+							pfe_rtable_entry_free(entry);
+							entry = NULL;
+							*fci_ret = FPP_ERR_OK;
+						}
+					}
+					else
+					{
+						NXP_LOG_DEBUG("FPP_CMD_IPVx_CONNTRACK: Entry not found\n");
+						*fci_ret = FPP_ERR_CT_ENTRY_NOT_FOUND;
+						break;
+					}
 
-			entry = pfe_rtable_get_first(fci_context->rtable, RTABLE_CRIT_BY_5_TUPLE, (void *)&tuple);
+					/*	Delete also the reply direction */
+					if (NULL != rep_entry)
+					{
+						ret = pfe_rtable_del_entry(fci_context->rtable, rep_entry);
+						if (EOK != ret)
+						{
+							NXP_LOG_ERROR("Can't remove reply route entry: %d\n", ret);
+							*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+							break;
+						}
+						else
+						{
+							/*	Release all entry-related resources */
+							NXP_LOG_DEBUG("FPP_CMD_IPVx_CONNTRACK: Entry removed (reply direction)\n");
+							pfe_rtable_entry_free(rep_entry);
+							rep_entry = NULL;
+							*fci_ret = FPP_ERR_OK;
+						}
+					}
+					else
+					{
+						/*	TODO: Reply entry not found. Should be there or not? */
+						;
+					}
 
-			if (NULL != entry)
-			{
+					break;
+				}
 
-				if (TRUE == ipv6)
+				case FPP_ACTION_UPDATE:
 				{
-					if ((oal_ntohs(ct6_cmd->flags) & CTCMD_FLAGS_TTL_DECREMENT) != 0U)
+		#if (PFE_CFG_VERBOSITY_LEVEL >= 8)
+					if (TRUE == ipv6)
 					{
-						pfe_rtable_entry_set_ttl_decrement(entry);
+						NXP_LOG_DEBUG("Attempt to update IPv6 connection:\n%s\n", fci_connections_ipv6_cmd_to_str(ct6_cmd));
 					}
 					else
 					{
-						pfe_rtable_entry_remove_ttl_decrement(entry);
+						NXP_LOG_DEBUG("Attempt to update IPv4 connection:\n%s\n", fci_connections_ipv4_cmd_to_str(ct_cmd));
 					}
-				}
-				else
-				{
-					if ((oal_ntohs(ct_cmd->flags) & CTCMD_FLAGS_TTL_DECREMENT) != 0U)
+		#endif /* PFE_CFG_VERBOSITY_LEVEL */
+
+					NXP_LOG_INFO("UPDATED conntrack, only TTL decrement flag will be updated\n");
+
+					/*      Get entry by 5-tuple */
+					if (TRUE == ipv6)
 					{
-						pfe_rtable_entry_set_ttl_decrement(entry);
+						fci_connections_ipv6_cmd_to_5t(ct6_cmd, &tuple);
 					}
 					else
 					{
-						pfe_rtable_entry_remove_ttl_decrement(entry);
+						fci_connections_ipv4_cmd_to_5t(ct_cmd, &tuple);
 					}
-				}
 
-				*fci_ret = FPP_ERR_OK;
-				ret = EOK;
+					entry = pfe_rtable_get_first(fci_context->rtable, RTABLE_CRIT_BY_5_TUPLE, (void *)&tuple);
 
-			}
-			else
-			{
-				NXP_LOG_DEBUG("FPP_CMD_IPVx_CONNTRACK: Entry not found\n");
-				*fci_ret = FPP_ERR_CT_ENTRY_NOT_FOUND;
-				ret = EEXIST;
-			}
+					if (NULL != entry)
+					{
 
+						if (TRUE == ipv6)
+						{
+							if ((oal_ntohs(ct6_cmd->flags) & CTCMD_FLAGS_TTL_DECREMENT) != 0U)
+							{
+								pfe_rtable_entry_set_ttl_decrement(entry);
+							}
+							else
+							{
+								pfe_rtable_entry_remove_ttl_decrement(entry);
+							}
+						}
+						else
+						{
+							if ((oal_ntohs(ct_cmd->flags) & CTCMD_FLAGS_TTL_DECREMENT) != 0U)
+							{
+								pfe_rtable_entry_set_ttl_decrement(entry);
+							}
+							else
+							{
+								pfe_rtable_entry_remove_ttl_decrement(entry);
+							}
+						}
+
+						*fci_ret = FPP_ERR_OK;
+						ret = EOK;
 
-			break;
-		}
+					}
+					else
+					{
+						NXP_LOG_DEBUG("FPP_CMD_IPVx_CONNTRACK: Entry not found\n");
+						*fci_ret = FPP_ERR_CT_ENTRY_NOT_FOUND;
+						ret = EEXIST;
+					}
 
-		case FPP_ACTION_QUERY:
-		{
-			pfe_rtable_get_criterion_t crit = (TRUE == ipv6) ? RTABLE_CRIT_ALL_IPV6 : RTABLE_CRIT_ALL_IPV4;
 
-			entry = pfe_rtable_get_first(fci_context->rtable, crit, NULL);
-			if (NULL == entry)
-			{
-				ret = EOK;
-				*fci_ret = FPP_ERR_CT_ENTRY_NOT_FOUND;
-				break;
-			}
-		}
-		/* FALLTHRU */
+					break;
+				}
 
-		case FPP_ACTION_QUERY_CONT:
-		{
-			if (NULL == entry)
-			{
-				entry = pfe_rtable_get_next(fci_context->rtable);
-				if (NULL == entry)
+				case FPP_ACTION_QUERY:
 				{
-					ret = EOK;
-					*fci_ret = FPP_ERR_CT_ENTRY_NOT_FOUND;
-					break;
+					pfe_rtable_get_criterion_t crit = (TRUE == ipv6) ? RTABLE_CRIT_ALL_IPV6 : RTABLE_CRIT_ALL_IPV4;
+
+					entry = pfe_rtable_get_first(fci_context->rtable, crit, NULL);
+					if (NULL == entry)
+					{
+						ret = EOK;
+						*fci_ret = FPP_ERR_CT_ENTRY_NOT_FOUND;
+						break;
+					}
 				}
-			}
+				/* FALLTHRU */
 
-			ct6_reply = (fpp_ct6_cmd_t *)(reply_buf);
-			ct_reply = (fpp_ct_cmd_t *)(reply_buf);
+				case FPP_ACTION_QUERY_CONT:
+				{
+					if (NULL == entry)
+					{
+						entry = pfe_rtable_get_next(fci_context->rtable);
+						if (NULL == entry)
+						{
+							ret = EOK;
+							*fci_ret = FPP_ERR_CT_ENTRY_NOT_FOUND;
+							break;
+						}
+					}
 
-			/*	Set the reply length */
-			if (TRUE == ipv6)
-			{
-				*reply_len = sizeof(fpp_ct6_cmd_t);
-			}
-			else
-			{
-				*reply_len = sizeof(fpp_ct_cmd_t);
-			}
+					ct6_reply = (fpp_ct6_cmd_t *)(reply_buf);
+					ct_reply = (fpp_ct_cmd_t *)(reply_buf);
 
-			/*	Build reply structure */
-			pfe_rtable_entry_get_sip(entry, &sip);
-			pfe_rtable_entry_get_dip(entry, &dip);
-			(void)pfe_rtable_entry_get_route_id(entry, &route_id);
-			vlan = pfe_rtable_entry_get_out_vlan(entry);
+					/*	Set the reply length */
+					if (TRUE == ipv6)
+					{
+						*reply_len = sizeof(fpp_ct6_cmd_t);
+					}
+					else
+					{
+						*reply_len = sizeof(fpp_ct_cmd_t);
+					}
 
-			if (TRUE == ipv6)
-			{
-				(void)memcpy(ct6_reply->saddr, &sip.v6, 16);
-				(void)memcpy(ct6_reply->daddr, &dip.v6, 16);
-				ct6_reply->sport = oal_htons(pfe_rtable_entry_get_sport(entry));
-				ct6_reply->dport = oal_htons(pfe_rtable_entry_get_dport(entry));
-				ct6_reply->vlan = oal_htons(vlan);
-				(void)memcpy(ct6_reply->saddr_reply, ct6_reply->daddr, 16);
-				(void)memcpy(ct6_reply->daddr_reply, ct6_reply->saddr, 16);
-				ct6_reply->sport_reply = ct6_reply->dport;
-				ct6_reply->dport_reply = ct6_reply->sport;
-				ct6_reply->protocol = oal_ntohs(pfe_rtable_entry_get_proto(entry));
-				ct6_reply->flags = 0U;
-				ct6_reply->route_id = route_id;
-			}
-			else
-			{
-				(void)memcpy(&ct_reply->saddr, &sip.v4, 4);
-				(void)memcpy(&ct_reply->daddr, &dip.v4, 4);
-				ct_reply->sport = oal_htons(pfe_rtable_entry_get_sport(entry));
-				ct_reply->dport = oal_htons(pfe_rtable_entry_get_dport(entry));
-				ct_reply->vlan = oal_htons(vlan);
-				(void)memcpy(&ct_reply->saddr_reply, &ct_reply->daddr, 4);
-				(void)memcpy(&ct_reply->daddr_reply, &ct_reply->saddr, 4);
-				ct_reply->sport_reply = ct_reply->dport;
-				ct_reply->dport_reply = ct_reply->sport;
-				ct_reply->protocol = oal_ntohs(pfe_rtable_entry_get_proto(entry));
-				ct_reply->flags = 0U;
-				ct_reply->route_id = route_id;
-			}
+					/*	Prepare statistics data */
+					ret = pfe_rtable_get_stats(fci_context->rtable, &stats, pfe_rtable_entry_get_stats_index(entry));
+					if (EOK != ret)
+					{
+						NXP_LOG_ERROR("Failed to get routing entry statistics: %d", ret);
+					}
 
-			/*	Check if reply direction does exist */
-			rep_entry =  pfe_rtable_entry_get_child(entry);
-			if (NULL == rep_entry)
-			{
-				/*	This means that entry in 'reply' direction has not been requested
-				 	so the appropriate flag shall be set to indicate that. */
-				if (TRUE == ipv6)
-				{
-					ct6_reply->flags |= oal_htons(CTCMD_FLAGS_REP_DISABLED);
-				}
-				else
-				{
-					ct_reply->flags |= oal_htons(CTCMD_FLAGS_REP_DISABLED);
-				}
-			}
-			else
-			{
-				/*	Associated entry for reply direction does exist */
-				vlan = pfe_rtable_entry_get_out_vlan(rep_entry);
-				if (TRUE == ipv6)
-				{
-					ct6_reply->vlan_reply = oal_htons(vlan);
-				}
-				else
-				{
-					ct_reply->vlan_reply = oal_htons(vlan);
-				}
-			}
+					/*	Build reply structure */
+					pfe_rtable_entry_get_sip(entry, &sip);
+					pfe_rtable_entry_get_dip(entry, &dip);
+					(void)pfe_rtable_entry_get_route_id(entry, &route_id);
+					vlan = pfe_rtable_entry_get_out_vlan(entry);
 
-			/*
-				Check if some modifications (NAT) are enabled. If so, update the
-			 	'reply' direction values as defined by the FCI API. Note that
-				modification are enabled when entry is being added. See
-				FPP_ACTION_REGISTER and fci_connections_create_entry().
-			*/
-			actions = pfe_rtable_entry_get_action_flags(entry);
-			if (EOK != pfe_rtable_entry_to_5t_out(entry, &tuple))
-			{
-				NXP_LOG_ERROR("Couldn't get output tuple\n");
-			}
+					if (TRUE == ipv6)
+					{
+						(void)memcpy(ct6_reply->saddr, &sip.v6, 16);
+						(void)memcpy(ct6_reply->daddr, &dip.v6, 16);
+						ct6_reply->sport = oal_htons(pfe_rtable_entry_get_sport(entry));
+						ct6_reply->dport = oal_htons(pfe_rtable_entry_get_dport(entry));
+						ct6_reply->vlan = oal_htons(vlan);
+						(void)memcpy(ct6_reply->saddr_reply, ct6_reply->daddr, 16);
+						(void)memcpy(ct6_reply->daddr_reply, ct6_reply->saddr, 16);
+						ct6_reply->sport_reply = ct6_reply->dport;
+						ct6_reply->dport_reply = ct6_reply->sport;
+						ct6_reply->protocol = oal_ntohs(pfe_rtable_entry_get_proto(entry));
+						ct6_reply->flags = 0U;
+						ct6_reply->route_id = route_id;
+						ct6_reply->stats.hit = oal_htonl(stats.hit);
+						ct6_reply->stats.hit_bytes = oal_htonl(stats.hit_bytes);
+					}
+					else
+					{
+						(void)memcpy(&ct_reply->saddr, &sip.v4, 4);
+						(void)memcpy(&ct_reply->daddr, &dip.v4, 4);
+						ct_reply->sport = oal_htons(pfe_rtable_entry_get_sport(entry));
+						ct_reply->dport = oal_htons(pfe_rtable_entry_get_dport(entry));
+						ct_reply->vlan = oal_htons(vlan);
+						(void)memcpy(&ct_reply->saddr_reply, &ct_reply->daddr, 4);
+						(void)memcpy(&ct_reply->daddr_reply, &ct_reply->saddr, 4);
+						ct_reply->sport_reply = ct_reply->dport;
+						ct_reply->dport_reply = ct_reply->sport;
+						ct_reply->protocol = oal_ntohs(pfe_rtable_entry_get_proto(entry));
+						ct_reply->flags = 0U;
+						ct_reply->route_id = route_id;
+						ct_reply->stats.hit = oal_htonl(stats.hit);
+						ct_reply->stats.hit_bytes = oal_htonl(stats.hit_bytes);
+					}
 
-			if (0U != ((uint32_t)actions & (uint32_t)RT_ACT_DEC_TTL))
-			{
-				if (TRUE == ipv6)
-				{
-					ct6_reply->flags |= oal_htons(CTCMD_FLAGS_TTL_DECREMENT);
-				}
-				else
-				{
-					ct_reply->flags |= oal_htons(CTCMD_FLAGS_TTL_DECREMENT);
-				}
-			}
+					/*	Check if reply direction does exist */
+					rep_entry =  pfe_rtable_entry_get_child(entry);
+					if (NULL == rep_entry)
+					{
+						/*	This means that entry in 'reply' direction has not been requested
+							so the appropriate flag shall be set to indicate that. */
+						if (TRUE == ipv6)
+						{
+							ct6_reply->flags |= oal_htons(CTCMD_FLAGS_REP_DISABLED);
+						}
+						else
+						{
+							ct_reply->flags |= oal_htons(CTCMD_FLAGS_REP_DISABLED);
+						}
+					}
+					else
+					{
+						/*	Prepare reply direction statistics data */
+						ret = pfe_rtable_get_stats(fci_context->rtable, &stats, pfe_rtable_entry_get_stats_index(rep_entry));
+						if (EOK != ret)
+						{
+							NXP_LOG_ERROR("Failed to get reply routing entry statistics: %d", ret);
+						}
+
+						/*	Prepare reply direction vlan data */
+						vlan = pfe_rtable_entry_get_out_vlan(rep_entry);
+						if (TRUE == ipv6)
+						{
+							ct6_reply->vlan_reply = oal_htons(vlan);
+							ct6_reply->stats_reply.hit = oal_htonl(stats.hit);
+							ct6_reply->stats_reply.hit_bytes = oal_htonl(stats.hit_bytes);
+						}
+						else
+						{
+							ct_reply->vlan_reply = oal_htons(vlan);
+							ct_reply->stats_reply.hit = oal_htonl(stats.hit);
+							ct_reply->stats_reply.hit_bytes = oal_htonl(stats.hit_bytes);
+						}
+					}
 
-			if (0U != ((uint32_t)actions & (uint32_t)RT_ACT_CHANGE_SIP_ADDR))
-			{
-				if (TRUE == ipv6)
-				{
-					(void)memcpy(ct6_reply->daddr_reply, &tuple.src_ip.v6, 16);
-				}
-				else
-				{
-					(void)memcpy(&ct_reply->daddr_reply, &tuple.src_ip.v4, 4);
-				}
-			}
+					/*
+						Check if some modifications (NAT) are enabled. If so, update the
+						'reply' direction values as defined by the FCI API. Note that
+						modification are enabled when entry is being added. See
+						FPP_ACTION_REGISTER and fci_connections_create_entry().
+					*/
+					actions = pfe_rtable_entry_get_action_flags(entry);
+					if (EOK != pfe_rtable_entry_to_5t_out(entry, &tuple))
+					{
+						NXP_LOG_ERROR("Couldn't get output tuple\n");
+					}
 
-			if (0U != ((uint32_t)actions & (uint32_t)RT_ACT_CHANGE_DIP_ADDR))
-			{
-				if (TRUE == ipv6)
-				{
-					(void)memcpy(ct6_reply->saddr_reply, &tuple.dst_ip.v6, 16);
-				}
-				else
-				{
-					(void)memcpy(&ct_reply->saddr_reply, &tuple.dst_ip.v4, 4);
-				}
-			}
+					if (0U != ((uint32_t)actions & (uint32_t)RT_ACT_DEC_TTL))
+					{
+						if (TRUE == ipv6)
+						{
+							ct6_reply->flags |= oal_htons(CTCMD_FLAGS_TTL_DECREMENT);
+						}
+						else
+						{
+							ct_reply->flags |= oal_htons(CTCMD_FLAGS_TTL_DECREMENT);
+						}
+					}
 
-			if (0U != ((uint32_t)actions & (uint32_t)RT_ACT_CHANGE_SPORT))
-			{
-				if (TRUE == ipv6)
-				{
-					ct6_reply->dport_reply = oal_htons(tuple.sport);
-				}
-				else
-				{
-					ct_reply->dport_reply = oal_htons(tuple.sport);
-				}
-			}
+					if (0U != ((uint32_t)actions & (uint32_t)RT_ACT_CHANGE_SIP_ADDR))
+					{
+						if (TRUE == ipv6)
+						{
+							(void)memcpy(ct6_reply->daddr_reply, &tuple.src_ip.v6, 16);
+						}
+						else
+						{
+							(void)memcpy(&ct_reply->daddr_reply, &tuple.src_ip.v4, 4);
+						}
+					}
 
-			if (0U != ((uint32_t)actions & (uint32_t)RT_ACT_CHANGE_DPORT))
-			{
-				if (TRUE == ipv6)
-				{
-					ct6_reply->sport_reply = oal_htons(tuple.dport);
+					if (0U != ((uint32_t)actions & (uint32_t)RT_ACT_CHANGE_DIP_ADDR))
+					{
+						if (TRUE == ipv6)
+						{
+							(void)memcpy(ct6_reply->saddr_reply, &tuple.dst_ip.v6, 16);
+						}
+						else
+						{
+							(void)memcpy(&ct_reply->saddr_reply, &tuple.dst_ip.v4, 4);
+						}
+					}
+
+					if (0U != ((uint32_t)actions & (uint32_t)RT_ACT_CHANGE_SPORT))
+					{
+						if (TRUE == ipv6)
+						{
+							ct6_reply->dport_reply = oal_htons(tuple.sport);
+						}
+						else
+						{
+							ct_reply->dport_reply = oal_htons(tuple.sport);
+						}
+					}
+
+					if (0U != ((uint32_t)actions & (uint32_t)RT_ACT_CHANGE_DPORT))
+					{
+						if (TRUE == ipv6)
+						{
+							ct6_reply->sport_reply = oal_htons(tuple.dport);
+						}
+						else
+						{
+							ct_reply->sport_reply = oal_htons(tuple.dport);
+						}
+					}
+
+					*fci_ret = FPP_ERR_OK;
+					ret = EOK;
+
+					break;
 				}
-				else
+
+				default:
 				{
-					ct_reply->sport_reply = oal_htons(tuple.dport);
+					NXP_LOG_ERROR("Connection Command: Unknown action received: 0x%x\n", ct_cmd->action);
+					*fci_ret = FPP_ERR_UNKNOWN_ACTION;
+					break;
 				}
 			}
-
-			*fci_ret = FPP_ERR_OK;
-			ret = EOK;
-
-			break;
-		}
-
-		default:
-		{
-			NXP_LOG_ERROR("Connection Command: Unknown action received: 0x%x\n", ct_cmd->action);
-			*fci_ret = FPP_ERR_UNKNOWN_ACTION;
-			break;
 		}
 	}
 
@@ -1340,15 +1413,19 @@ free_and_fail:
  */
 errno_t fci_connections_ipv4_ct_cmd(const fci_msg_t *msg, uint16_t *fci_ret, fpp_ct_cmd_t *reply_buf, uint32_t *reply_len)
 {
+	errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	return fci_connections_ipvx_ct_cmd(FALSE, msg, fci_ret, (void *)reply_buf, reply_len);
+	{
+		ret = fci_connections_ipvx_ct_cmd(FALSE, msg, fci_ret, (void *)reply_buf, reply_len);
+	}
+	return ret;
 }
 
 /**
@@ -1364,15 +1441,19 @@ errno_t fci_connections_ipv4_ct_cmd(const fci_msg_t *msg, uint16_t *fci_ret, fpp
  */
 errno_t fci_connections_ipv6_ct_cmd(const fci_msg_t *msg, uint16_t *fci_ret, fpp_ct6_cmd_t *reply_buf, uint32_t *reply_len)
 {
+	errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	return fci_connections_ipvx_ct_cmd(TRUE, msg, fci_ret, (void *)reply_buf, reply_len);
+	{
+		ret = fci_connections_ipvx_ct_cmd(TRUE, msg, fci_ret, (void *)reply_buf, reply_len);
+	}
+	return ret;
 }
 
 /**
@@ -1395,60 +1476,62 @@ errno_t fci_connections_ipv4_timeout_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_
 	pfe_rtable_entry_t *entry = NULL;
 	uint8_t proto;
 	uint32_t timeout;
+	errno_t ret;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-    if (unlikely(FALSE == fci_context->fci_initialized))
+	else if (unlikely(FALSE == fci_context->fci_initialized))
 	{
     	NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (*reply_len < sizeof(fpp_timeout_cmd_t))
-	{
-		NXP_LOG_ERROR("Buffer length does not match expected value (fpp_timeout_cmd_t)\n");
-		return EINVAL;
+		ret = EPERM;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		/*	No data written to reply buffer (yet) */
-		*reply_len = 0U;
-	}
+		if (*reply_len < sizeof(fpp_timeout_cmd_t))
+		{
+			NXP_LOG_ERROR("Buffer length does not match expected value (fpp_timeout_cmd_t)\n");
+			ret = EINVAL;
+		}
+		else
+		{
+			/*	No data written to reply buffer (yet) */
+			*reply_len = 0U;
+			/*	Initialize the reply buffer */
+			(void)memset(reply_buf, 0, sizeof(fpp_timeout_cmd_t));
 
-	/*	Initialize the reply buffer */
-	(void)memset(reply_buf, 0, sizeof(fpp_timeout_cmd_t));
+			timeout_cmd = (fpp_timeout_cmd_t *)(msg->msg_cmd.payload);
 
-	timeout_cmd = (fpp_timeout_cmd_t *)(msg->msg_cmd.payload);
+			/*	Update FCI-wide defaults applicable for new connections */
+			if (EOK != fci_connections_set_default_timeout((uint8_t)oal_ntohs(timeout_cmd->protocol), oal_ntohl(timeout_cmd->timeout_value1)))
+			{
+				NXP_LOG_WARNING("Can't set default timeout\n");
+			}
+			else
+			{
+				NXP_LOG_DEBUG("Default timeout for protocol %u set to %u seconds\n", (uint_t)oal_ntohs(timeout_cmd->protocol), (uint_t)oal_ntohl(timeout_cmd->timeout_value1));
+			}
 
-	/*	Update FCI-wide defaults applicable for new connections */
-	if (EOK != fci_connections_set_default_timeout((uint8_t)oal_ntohs(timeout_cmd->protocol), oal_ntohl(timeout_cmd->timeout_value1)))
-	{
-		NXP_LOG_WARNING("Can't set default timeout\n");
-	}
-	else
-	{
-		NXP_LOG_DEBUG("Default timeout for protocol %u set to %u seconds\n", (uint_t)oal_ntohs(timeout_cmd->protocol), (uint_t)oal_ntohl(timeout_cmd->timeout_value1));
-	}
+			/*	Update existing connections */
+			entry = pfe_rtable_get_first(fci_context->rtable, RTABLE_CRIT_ALL, NULL);
+			while (NULL != entry)
+			{
+				proto = pfe_rtable_entry_get_proto(entry);
+				timeout = fci_connections_get_default_timeout(proto);
+				pfe_rtable_entry_set_timeout(entry, timeout);
+				entry = pfe_rtable_get_next(fci_context->rtable);
+			}
 
-	/*	Update existing connections */
-	entry = pfe_rtable_get_first(fci_context->rtable, RTABLE_CRIT_ALL, NULL);
-	while (NULL != entry)
-	{
-		proto = pfe_rtable_entry_get_proto(entry);
-		timeout = fci_connections_get_default_timeout(proto);
-		pfe_rtable_entry_set_timeout(entry, timeout);
-		entry = pfe_rtable_get_next(fci_context->rtable);
+			*fci_ret = FPP_ERR_OK;
+			ret = EOK;
+		}
 	}
 
-	*fci_ret = FPP_ERR_OK;
-
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1471,101 +1554,103 @@ errno_t fci_connections_drop_one(pfe_rtable_entry_t *entry)
 	if (unlikely((NULL == entry)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-    if (unlikely(FALSE == fci_context->fci_initialized))
+	else if (unlikely(FALSE == fci_context->fci_initialized))
 	{
     	NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
+		ret = EPERM;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	ret = pfe_rtable_entry_to_5t(entry, &tuple);
-	if (EOK != ret)
 	{
-		NXP_LOG_ERROR("Can't convert entry to 5 tuple: %d\n", ret);
-		return ret;
-	}
-
-	(void)memset(&msg, 0, sizeof(fci_msg_t));
-	msg.type = FCI_MSG_CMD;
-
-	if (TRUE == tuple.src_ip.is_ipv4)
-	{
-#if (PFE_CFG_VERBOSITY_LEVEL >= 8)
-		/*	IPv4 */
-		NXP_LOG_DEBUG("Removing IPv4 connection:\n%s\n", fci_connections_entry_to_str(entry));
-#endif /* PFE_CFG_VERBOSITY_LEVEL */
-
-		client = (fci_core_client_t *)pfe_rtable_entry_get_refptr(entry);
-		if (NULL != client)
+		ret = pfe_rtable_entry_to_5t(entry, &tuple);
+		if (EOK != ret)
 		{
-			msg.msg_cmd.code = FPP_CMD_IPV4_CONNTRACK;
-			ct_cmd = (fpp_ct_cmd_t *)msg.msg_cmd.payload;
-			ct_cmd->action = FPP_ACTION_REMOVED;
-
-			(void)memcpy(&ct_cmd->saddr, &tuple.src_ip.v4, 4);
-			(void)memcpy(&ct_cmd->daddr, &tuple.dst_ip.v4, 4);
-			ct_cmd->sport = oal_htons(tuple.sport);
-			ct_cmd->dport = oal_htons(tuple.dport);
-			ct_cmd->protocol = oal_htons(tuple.proto);
-
-			ret = fci_core_client_send(client, &msg, NULL);
-			if (EOK != ret)
-			{
-				NXP_LOG_ERROR("Could not notify FCI client\n");
-			}
+			NXP_LOG_ERROR("Can't convert entry to 5 tuple: %d\n", ret);
 		}
 		else
 		{
-			; /*	No client ID, notification not required */
-		}
-	}
-	else
-	{
-#if (PFE_CFG_VERBOSITY_LEVEL >= 8)
-		/*	IPv6 */
-		NXP_LOG_DEBUG("Removing IPv6 connection:\n%s\n", fci_connections_entry_to_str(entry));
-#endif /* PFE_CFG_VERBOSITY_LEVEL */
+			(void)memset(&msg, 0, sizeof(fci_msg_t));
+			msg.type = FCI_MSG_CMD;
 
-		client = (fci_core_client_t *)pfe_rtable_entry_get_refptr(entry);
-		if (NULL != client)
-		{
-			msg.msg_cmd.code = FPP_CMD_IPV6_CONNTRACK;
-			ct6_cmd = (fpp_ct6_cmd_t *)msg.msg_cmd.payload;
-			ct6_cmd->action = FPP_ACTION_REMOVED;
+			if (TRUE == tuple.src_ip.is_ipv4)
+			{
+		#if (PFE_CFG_VERBOSITY_LEVEL >= 8)
+				/*	IPv4 */
+				NXP_LOG_DEBUG("Removing IPv4 connection:\n%s\n", fci_connections_entry_to_str(entry));
+		#endif /* PFE_CFG_VERBOSITY_LEVEL */
+
+				client = (fci_core_client_t *)pfe_rtable_entry_get_refptr(entry);
+				if (NULL != client)
+				{
+					msg.msg_cmd.code = FPP_CMD_IPV4_CONNTRACK;
+					ct_cmd = (fpp_ct_cmd_t *)msg.msg_cmd.payload;
+					ct_cmd->action = FPP_ACTION_REMOVED;
+
+					(void)memcpy(&ct_cmd->saddr, &tuple.src_ip.v4, 4);
+					(void)memcpy(&ct_cmd->daddr, &tuple.dst_ip.v4, 4);
+					ct_cmd->sport = oal_htons(tuple.sport);
+					ct_cmd->dport = oal_htons(tuple.dport);
+					ct_cmd->protocol = oal_htons(tuple.proto);
+
+					ret = fci_core_client_send(client, &msg, NULL);
+					if (EOK != ret)
+					{
+						NXP_LOG_ERROR("Could not notify FCI client\n");
+					}
+				}
+				else
+				{
+					; /*	No client ID, notification not required */
+				}
+			}
+			else
+			{
+		#if (PFE_CFG_VERBOSITY_LEVEL >= 8)
+				/*	IPv6 */
+				NXP_LOG_DEBUG("Removing IPv6 connection:\n%s\n", fci_connections_entry_to_str(entry));
+		#endif /* PFE_CFG_VERBOSITY_LEVEL */
 
-			(void)memcpy(&ct6_cmd->saddr[0], &tuple.src_ip.v6, 16);
-			(void)memcpy(&ct6_cmd->daddr[0], &tuple.dst_ip.v6, 16);
-			ct6_cmd->sport = oal_htons(tuple.sport);
-			ct6_cmd->dport = oal_htons(tuple.dport);
-			ct6_cmd->protocol = oal_htons(tuple.proto);
+				client = (fci_core_client_t *)pfe_rtable_entry_get_refptr(entry);
+				if (NULL != client)
+				{
+					msg.msg_cmd.code = FPP_CMD_IPV6_CONNTRACK;
+					ct6_cmd = (fpp_ct6_cmd_t *)msg.msg_cmd.payload;
+					ct6_cmd->action = FPP_ACTION_REMOVED;
+
+					(void)memcpy(&ct6_cmd->saddr[0], &tuple.src_ip.v6, 16);
+					(void)memcpy(&ct6_cmd->daddr[0], &tuple.dst_ip.v6, 16);
+					ct6_cmd->sport = oal_htons(tuple.sport);
+					ct6_cmd->dport = oal_htons(tuple.dport);
+					ct6_cmd->protocol = oal_htons(tuple.proto);
+
+					ret = fci_core_client_send(client, &msg, NULL);
+					if (EOK != ret)
+					{
+						NXP_LOG_ERROR("Could not notify FCI client\n");
+					}
+				}
+				else
+				{
+					; /*	No client ID, notification not required */
+				}
+			}
 
-			ret = fci_core_client_send(client, &msg, NULL);
+			/*	Remove entry from the routing table */
+			ret = pfe_rtable_del_entry(fci_context->rtable, entry);
 			if (EOK != ret)
 			{
-				NXP_LOG_ERROR("Could not notify FCI client\n");
+				NXP_LOG_ERROR("Fatal: Can't remove rtable entry = memory leak\n");
+			}
+			else
+			{
+				/*	Release the entry */
+				pfe_rtable_entry_free(entry);
 			}
-		}
-		else
-		{
-			; /*	No client ID, notification not required */
 		}
 	}
 
-	/*	Remove entry from the routing table */
-	ret = pfe_rtable_del_entry(fci_context->rtable, entry);
-	if (EOK != ret)
-	{
-		NXP_LOG_ERROR("Fatal: Can't remove rtable entry = memory leak\n");
-	}
-	else
-	{
-		/*	Release the entry */
-		pfe_rtable_entry_free(entry);
-	}
-
 	return ret;
 }
 
@@ -1584,22 +1669,23 @@ void fci_connections_drop_all(void)
     if (unlikely(FALSE == fci_context->fci_initialized))
 	{
     	NXP_LOG_ERROR("Context not initialized\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	NXP_LOG_DEBUG("Removing all connections\n");
-
-	entry = pfe_rtable_get_first(fci_context->rtable, RTABLE_CRIT_ALL, NULL);
-	while (NULL != entry)
 	{
-		ret = fci_connections_drop_one(entry);
-		if (EOK != ret)
+		NXP_LOG_DEBUG("Removing all connections\n");
+
+		entry = pfe_rtable_get_first(fci_context->rtable, RTABLE_CRIT_ALL, NULL);
+		while (NULL != entry)
 		{
-			NXP_LOG_WARNING("Couldn't properly drop a connection: %d\n", ret);
-		}
+			ret = fci_connections_drop_one(entry);
+			if (EOK != ret)
+			{
+				NXP_LOG_WARNING("Couldn't properly drop a connection: %d\n", ret);
+			}
 
-		entry = pfe_rtable_get_next(fci_context->rtable);
+			entry = pfe_rtable_get_next(fci_context->rtable);
+		}
 	}
 }
 
@@ -1612,37 +1698,40 @@ void fci_connections_drop_all(void)
 errno_t fci_connections_set_default_timeout(uint8_t ip_proto, uint32_t timeout)
 {
 	fci_t *fci_context = (fci_t *)&__context;
-
+	errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
     if (unlikely(FALSE == fci_context->fci_initialized))
 	{
     	NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
+		ret = EPERM;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	switch (ip_proto)
 	{
-		case 6U:
+		switch (ip_proto)
 		{
-			fci_context->default_timeouts.timeout_tcp = timeout;
-			break;
-		}
+			case 6U:
+			{
+				fci_context->default_timeouts.timeout_tcp = timeout;
+				break;
+			}
 
-		case 17U:
-		{
-			fci_context->default_timeouts.timeout_udp = timeout;
-			break;
-		}
+			case 17U:
+			{
+				fci_context->default_timeouts.timeout_udp = timeout;
+				break;
+			}
 
-		default:
-		{
-			fci_context->default_timeouts.timeout_other = timeout;
-			break;
+			default:
+			{
+				fci_context->default_timeouts.timeout_other = timeout;
+				break;
+			}
 		}
+		ret = EOK;
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1653,34 +1742,36 @@ errno_t fci_connections_set_default_timeout(uint8_t ip_proto, uint32_t timeout)
 uint32_t fci_connections_get_default_timeout(uint8_t ip_proto)
 {
 	const fci_t *fci_context = (fci_t *)&__context;
-	uint32_t ret = 0U;
+	uint32_t ret;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
     if (unlikely(FALSE == fci_context->fci_initialized))
 	{
     	NXP_LOG_ERROR("Context not initialized\n");
-		return 0U;
+		ret = 0U;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	switch (ip_proto)
 	{
-		case 6U:
+		switch (ip_proto)
 		{
-			ret = fci_context->default_timeouts.timeout_tcp;
-			break;
-		}
+			case 6U:
+			{
+				ret = fci_context->default_timeouts.timeout_tcp;
+				break;
+			}
 
-		case 17U:
-		{
-			ret = fci_context->default_timeouts.timeout_udp;
-			break;
-		}
+			case 17U:
+			{
+				ret = fci_context->default_timeouts.timeout_udp;
+				break;
+			}
 
-		default:
-		{
-			ret = fci_context->default_timeouts.timeout_other;
-			break;
+			default:
+			{
+				ret = fci_context->default_timeouts.timeout_other;
+				break;
+			}
 		}
 	}
 
diff --git a/sw/fci/src/fci_flexible_filter.c b/sw/fci/src/fci_flexible_filter.c
index f76d825..193ea64 100644
--- a/sw/fci/src/fci_flexible_filter.c
+++ b/sw/fci/src/fci_flexible_filter.c
@@ -41,97 +41,100 @@ errno_t fci_flexible_filter_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_flexible_
 	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-    if (unlikely(FALSE == fci_context->fci_initialized))
+    else if (unlikely(FALSE == fci_context->fci_initialized))
 	{
     	NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
+		ret = EPERM;
 	}
+    else
 #else
 	(void)reply_buf;
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-    fp_cmd = (fpp_flexible_filter_cmd_t *)(msg->msg_cmd.payload);
-    /* Important to initialize to avoid buffer overflows */
-	if (*reply_len < sizeof(fpp_flexible_filter_cmd_t))
-	{
-		NXP_LOG_ERROR("Buffer length does not match expected value (fpp_flexible_filter_cmd_t)\n");
-		return EINVAL;
-	}
-	else
-	{
-		/*	No data written to reply buffer (yet) */
-		*reply_len = 0U;
-	}
-
-	/*	Check that the FW feature is available (enabled) in FW */
-	if (FALSE == pfe_feature_mgr_is_available("g_flex_filter"))
-	{
-		/* Unavailable feature. Respond with FCI error code. */
-		NXP_LOG_ERROR("Feature 'g_flex_filter' is not available (not enabled in FW).\n");
-		*fci_ret = FPP_ERR_FW_FEATURE_NOT_AVAILABLE;
-		return EOK;
-	}
-
-    switch (fp_cmd->action)
-	{
-		case FPP_ACTION_REGISTER:
+    {
+        fp_cmd = (fpp_flexible_filter_cmd_t *)(msg->msg_cmd.payload);
+        /* Important to initialize to avoid buffer overflows */
+        if (*reply_len < sizeof(fpp_flexible_filter_cmd_t))
         {
-            uint32_t addr;
-            /* Write the finished table into the DMEM */
-            ret = fci_fp_db_push_table_to_hw(fci_context->class, (char_t *)fp_cmd->table_name);
-            if(EOK == ret)
-            {
-                /* Get the DMEM address */
-                addr = fci_fp_db_get_table_dmem_addr((char_t *)fp_cmd->table_name);
-                if(0U != addr)
-                {
-                    /* Let the classifier use the address of the table as flexible filter */
-                    ret = pfe_flexible_filter_set(fci_context->class, oal_htonl(addr));
-                }
-                else
-                {
-                    ret = ENOMEM;
-                }
-            }
-            if(EOK == ret)
-            {
-                *fci_ret = FPP_ERR_OK;
-            }
-            else
-            {
-                *fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-            }
-            break;
+            NXP_LOG_ERROR("Buffer length does not match expected value (fpp_flexible_filter_cmd_t)\n");
+            ret = EINVAL;
         }
-
-		case FPP_ACTION_DEREGISTER:
+        else
         {
-            /* Write zero (NULL) into the classifier to prevent table being used */
-            ret = pfe_flexible_filter_set(fci_context->class, 0U);
-            if(EOK == ret)
+            /*	No data written to reply buffer (yet) */
+            *reply_len = 0U;
+            /*	Check that the FW feature is available (enabled) in FW */
+            if (FALSE == pfe_feature_mgr_is_available("g_flex_filter"))
             {
-                /* Delete the table from DMEM - no longer in use, copy is in database */
-                (void)fci_fp_db_pop_table_from_hw((char_t *)fp_cmd->table_name);
-                *fci_ret = FPP_ERR_OK;
+                /* Unavailable feature. Respond with FCI error code. */
+                NXP_LOG_ERROR("Feature 'g_flex_filter' is not available (not enabled in FW).\n");
+                *fci_ret = FPP_ERR_FW_FEATURE_NOT_AVAILABLE;
+                ret = EOK;
             }
             else
             {
-                *fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+                switch (fp_cmd->action)
+                {
+                    case FPP_ACTION_REGISTER:
+                    {
+                        uint32_t addr;
+                        /* Write the finished table into the DMEM */
+                        ret = fci_fp_db_push_table_to_hw(fci_context->class, (char_t *)fp_cmd->table_name);
+                        if(EOK == ret)
+                        {
+                            /* Get the DMEM address */
+                            addr = fci_fp_db_get_table_dmem_addr((char_t *)fp_cmd->table_name);
+                            if(0U != addr)
+                            {
+                                /* Let the classifier use the address of the table as flexible filter */
+                                ret = pfe_flexible_filter_set(fci_context->class, oal_htonl(addr));
+                            }
+                            else
+                            {
+                                ret = ENOMEM;
+                            }
+                        }
+                        if(EOK == ret)
+                        {
+                            *fci_ret = FPP_ERR_OK;
+                        }
+                        else
+                        {
+                            *fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+                        }
+                        break;
+                    }
+
+                    case FPP_ACTION_DEREGISTER:
+                    {
+                        /* Write zero (NULL) into the classifier to prevent table being used */
+                        ret = pfe_flexible_filter_set(fci_context->class, 0U);
+                        if(EOK == ret)
+                        {
+                            /* Delete the table from DMEM - no longer in use, copy is in database */
+                            (void)fci_fp_db_pop_table_from_hw((char_t *)fp_cmd->table_name);
+                            *fci_ret = FPP_ERR_OK;
+                        }
+                        else
+                        {
+                            *fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+                        }
+                        break;
+                    }
+
+                    default:
+                    {
+                        NXP_LOG_ERROR("FPP_CMD_L2_BD: Unknown action received: 0x%x\n", fp_cmd->action);
+                        *fci_ret = FPP_ERR_UNKNOWN_ACTION;
+                        break;
+                    }
+                }
             }
-            break;
         }
-
-		default:
-		{
-			NXP_LOG_ERROR("FPP_CMD_L2_BD: Unknown action received: 0x%x\n", fp_cmd->action);
-			*fci_ret = FPP_ERR_UNKNOWN_ACTION;
-			break;
-		}
     }
-    return ret;
 
+    return ret;
 }
 
 #endif /* PFE_CFG_FCI_ENABLE */
diff --git a/sw/fci/src/fci_fp.c b/sw/fci/src/fci_fp.c
index 3758635..a3a32aa 100644
--- a/sw/fci/src/fci_fp.c
+++ b/sw/fci/src/fci_fp.c
@@ -32,7 +32,7 @@
 */
 static void fci_fp_construct_rule_reply(fpp_fp_rule_props_t *r, char *rule_name, char *next_rule,
                                    uint32_t data, uint32_t mask, uint16_t offset, pfe_ct_fp_flags_t flags)
-{
+{ 
     (void)strncpy((char_t *)r->rule_name, rule_name, 15);
     r->data = data;
     r->mask = mask;
@@ -99,130 +99,133 @@ errno_t fci_fp_table_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_fp_table_cmd_t *
 	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-    if (unlikely(FALSE == fci_context->fci_initialized))
+    else if (unlikely(FALSE == fci_context->fci_initialized))
 	{
     	NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
+		ret = EPERM;
 	}
+    else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-    /* Important to initialize to avoid buffer overflows */
-	if (*reply_len < sizeof(fpp_fp_table_cmd_t))
-	{
-		NXP_LOG_ERROR("Buffer length does not match expected value (fpp_fp_table_cmd_t)\n");
-		return EINVAL;
-	}
-	else
-	{
-		/*	No data written to reply buffer (yet) */
-		*reply_len = 0U;
-	}
-    fp_cmd = (fpp_fp_table_cmd_t *)(msg->msg_cmd.payload);
-    switch (fp_cmd->action)
-	{
-		case FPP_ACTION_REGISTER:
-        {
-            ret = fci_fp_db_create_table((char_t *)fp_cmd->table_info.t.table_name);
-            if(EOK == ret)
-            {
-                *fci_ret = FPP_ERR_OK;
-            }
-            else
-            {
-                *fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-            }
-            break;
-        }
-		case FPP_ACTION_DEREGISTER:
-        {
-            ret = fci_fp_db_destroy_table((char_t *)fp_cmd->table_info.t.table_name, FALSE);
-            if(EOK == ret)
-            {
-                *fci_ret = FPP_ERR_OK;
-            }
-            else
-            {
-                *fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-            }
-            break;
-        }
-        case FPP_ACTION_USE_RULE:
+    {
+        /* Important to initialize to avoid buffer overflows */
+        if (*reply_len < sizeof(fpp_fp_table_cmd_t))
         {
-            ret = fci_fp_db_add_rule_to_table((char_t *)fp_cmd->table_info.t.table_name, (char_t *)fp_cmd->table_info.t.rule_name, oal_ntohs(fp_cmd->table_info.t.position));
-            if(EOK == ret)
-            {
-                *fci_ret = FPP_ERR_OK;
-            }
-            else
-            {
-                *fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-            }
-            break;
+            NXP_LOG_ERROR("Buffer length does not match expected value (fpp_fp_table_cmd_t)\n");
+            ret = EINVAL;
         }
-        case FPP_ACTION_UNUSE_RULE:
+        else
         {
-            ret = fci_fp_db_remove_rule_from_table((char_t *)fp_cmd->table_info.t.rule_name);
-            if(EOK == ret)
+            /*	No data written to reply buffer (yet) */
+            *reply_len = 0U;
+            fp_cmd = (fpp_fp_table_cmd_t *)(msg->msg_cmd.payload);
+            switch (fp_cmd->action)
             {
-                *fci_ret = FPP_ERR_OK;
-            }
-            else
-            {
-                *fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-            }
-            break;
-        }
-        case FPP_ACTION_QUERY:
-        {
-            char *rule_name = NULL;
-            char *next_rule = NULL;
-            uint32_t data, mask;
-            uint16_t offset;
-            pfe_ct_fp_flags_t flags;
+                case FPP_ACTION_REGISTER:
+                {
+                    ret = fci_fp_db_create_table((char_t *)fp_cmd->table_info.t.table_name);
+                    if(EOK == ret)
+                    {
+                        *fci_ret = FPP_ERR_OK;
+                    }
+                    else
+                    {
+                        *fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+                    }
+                    break;
+                }
+                case FPP_ACTION_DEREGISTER:
+                {
+                    ret = fci_fp_db_destroy_table((char_t *)fp_cmd->table_info.t.table_name, FALSE);
+                    if(EOK == ret)
+                    {
+                        *fci_ret = FPP_ERR_OK;
+                    }
+                    else
+                    {
+                        *fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+                    }
+                    break;
+                }
+                case FPP_ACTION_USE_RULE:
+                {
+                    ret = fci_fp_db_add_rule_to_table((char_t *)fp_cmd->table_info.t.table_name, (char_t *)fp_cmd->table_info.t.rule_name, oal_ntohs(fp_cmd->table_info.t.position));
+                    if(EOK == ret)
+                    {
+                        *fci_ret = FPP_ERR_OK;
+                    }
+                    else
+                    {
+                        *fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+                    }
+                    break;
+                }
+                case FPP_ACTION_UNUSE_RULE:
+                {
+                    ret = fci_fp_db_remove_rule_from_table((char_t *)fp_cmd->table_info.t.rule_name);
+                    if(EOK == ret)
+                    {
+                        *fci_ret = FPP_ERR_OK;
+                    }
+                    else
+                    {
+                        *fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+                    }
+                    break;
+                }
+                case FPP_ACTION_QUERY:
+                {
+                    char *rule_name = NULL;
+                    char *next_rule = NULL;
+                    uint32_t data, mask;
+                    uint16_t offset;
+                    pfe_ct_fp_flags_t flags;
 
-            ret = fci_fp_db_get_table_first_rule((char_t *)fp_cmd->table_info.t.table_name, &rule_name, &data, &mask, &offset, &flags, &next_rule);
-            if(EOK == ret)
-            {
-            	fci_fp_construct_rule_reply(&reply_buf->table_info.r, rule_name, next_rule, data, mask, offset, flags);
-                *fci_ret = FPP_ERR_OK;
-                *reply_len = sizeof(fpp_fp_table_cmd_t);
-            }
-            else
-            {
-                *fci_ret = FPP_ERR_FP_RULE_NOT_FOUND;
-            }
-            break;
-        }
-        case FPP_ACTION_QUERY_CONT:
-        {
-            char *rule_name;
-            char *next_rule;
-            uint32_t data, mask;
-            uint16_t offset;
-            pfe_ct_fp_flags_t flags;
+                    ret = fci_fp_db_get_table_first_rule((char_t *)fp_cmd->table_info.t.table_name, &rule_name, &data, &mask, &offset, &flags, &next_rule);
+                    if(EOK == ret)
+                    {
+                        fci_fp_construct_rule_reply(&reply_buf->table_info.r, rule_name, next_rule, data, mask, offset, flags);
+                        *fci_ret = FPP_ERR_OK;
+                        *reply_len = sizeof(fpp_fp_table_cmd_t);
+                    }
+                    else
+                    {
+                        *fci_ret = FPP_ERR_FP_RULE_NOT_FOUND;
+                    }
+                    break;
+                }
+                case FPP_ACTION_QUERY_CONT:
+                {
+                    char *rule_name;
+                    char *next_rule;
+                    uint32_t data, mask;
+                    uint16_t offset;
+                    pfe_ct_fp_flags_t flags;
 
-            ret = fci_fp_db_get_table_next_rule((char_t *)fp_cmd->table_info.t.table_name, &rule_name, &data, &mask, &offset, &flags, &next_rule);
-            if(EOK == ret)
-            {
-            	fci_fp_construct_rule_reply(&reply_buf->table_info.r, rule_name, next_rule, data, mask, offset, flags);
-                *fci_ret = FPP_ERR_OK;
-                *reply_len = sizeof(fpp_fp_table_cmd_t);
-            }
-            else
-            {
-                *fci_ret = FPP_ERR_FP_RULE_NOT_FOUND;
+                    ret = fci_fp_db_get_table_next_rule((char_t *)fp_cmd->table_info.t.table_name, &rule_name, &data, &mask, &offset, &flags, &next_rule);
+                    if(EOK == ret)
+                    {
+                        fci_fp_construct_rule_reply(&reply_buf->table_info.r, rule_name, next_rule, data, mask, offset, flags);
+                        *fci_ret = FPP_ERR_OK;
+                        *reply_len = sizeof(fpp_fp_table_cmd_t);
+                    }
+                    else
+                    {
+                        *fci_ret = FPP_ERR_FP_RULE_NOT_FOUND;
+                    }
+                    break;
+                }
+                default:
+                {
+                    NXP_LOG_ERROR("FPP_CMD_L2_BD: Unknown action received: 0x%x\n", fp_cmd->action);
+                    *fci_ret = FPP_ERR_UNKNOWN_ACTION;
+                    break;
+                }
             }
-            break;
         }
-		default:
-		{
-			NXP_LOG_ERROR("FPP_CMD_L2_BD: Unknown action received: 0x%x\n", fp_cmd->action);
-			*fci_ret = FPP_ERR_UNKNOWN_ACTION;
-			break;
-		}
     }
+
     return ret;
 }
 
@@ -248,144 +251,152 @@ errno_t fci_fp_rule_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_fp_rule_cmd_t *re
 	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-    if (unlikely(FALSE == fci_context->fci_initialized))
+    else if (unlikely(FALSE == fci_context->fci_initialized))
 	{
     	NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
+		ret = EPERM;
 	}
+    else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-    if (*reply_len < sizeof(fpp_fp_rule_cmd_t))
-	{
-		NXP_LOG_ERROR("Buffer length does not match expected value (fpp_fp_rule_cmd_t)\n");
-		return EINVAL;
-	}
-	else
-	{
-		/*	No data written to reply buffer (yet) */
-		*reply_len = 0U;
-	}
-
-    fp_cmd = (fpp_fp_rule_cmd_t *)(msg->msg_cmd.payload);
-    switch (fp_cmd->action)
-	{
-		case FPP_ACTION_REGISTER:
+    {
+        if (*reply_len < sizeof(fpp_fp_rule_cmd_t))
         {
-            pfe_ct_fp_flags_t flags = FP_FL_NONE;
-            switch(fp_cmd->r.match_action)
-            {
-                case FP_ACCEPT:
-                    flags |= FP_FL_ACCEPT;
-                    break;
-                case FP_REJECT:
-                    flags |= FP_FL_REJECT;
-                    break;
-                case FP_NEXT_RULE:
-                    break;
-                default:
-                    NXP_LOG_ERROR("Impossible happened\n");
-                    *fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-                    return EINVAL;
-            }
-            switch(fp_cmd->r.offset_from)
+            NXP_LOG_ERROR("Buffer length does not match expected value (fpp_fp_rule_cmd_t)\n");
+            ret = EINVAL;
+        }
+        else
+        {
+            /*	No data written to reply buffer (yet) */
+            *reply_len = 0U;
+
+            fp_cmd = (fpp_fp_rule_cmd_t *)(msg->msg_cmd.payload);
+            switch (fp_cmd->action)
             {
-                case FP_OFFSET_FROM_L2_HEADER:
-                    break;
-                case FP_OFFSET_FROM_L3_HEADER:
-                    flags |= FP_FL_L3_OFFSET;
+                case FPP_ACTION_REGISTER:
+                {
+                    pfe_ct_fp_flags_t flags = FP_FL_NONE;
+                    switch(fp_cmd->r.match_action)
+                    {
+                        case FP_ACCEPT:
+                            flags |= FP_FL_ACCEPT;
+                            break;
+                        case FP_REJECT:
+                            flags |= FP_FL_REJECT;
+                            break;
+                        case FP_NEXT_RULE:
+                            break;
+                        default:
+                            NXP_LOG_ERROR("Impossible happened\n");
+                            *fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+                            ret = EINVAL;
+                    }
+                    if(EOK == ret)
+                    {
+                        switch(fp_cmd->r.offset_from)
+                        {
+                            case FP_OFFSET_FROM_L2_HEADER:
+                                break;
+                            case FP_OFFSET_FROM_L3_HEADER:
+                                flags |= FP_FL_L3_OFFSET;
+                                break;
+                            case FP_OFFSET_FROM_L4_HEADER:
+                                flags |= FP_FL_L4_OFFSET;
+                                break;
+                            default:
+                                NXP_LOG_ERROR("Impossible happened\n");
+                                *fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+                                ret = EINVAL;
+                        }
+                        if(EOK == ret)
+                        {
+                            if((uint8_t)TRUE == fp_cmd->r.invert)
+                            {
+                                flags |= FP_FL_INVERT;
+                            }
+
+                            ret = fci_fp_db_create_rule((char_t *)fp_cmd->r.rule_name, fp_cmd->r.data, fp_cmd->r.mask,
+                                                    fp_cmd->r.offset, flags,
+                                                    (char_t *)fp_cmd->r.next_rule_name);
+                            if(EOK == ret)
+                            {
+                                *fci_ret = FPP_ERR_OK;
+                            }
+                            else
+                            {
+                                *fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+                            }
+                        }
+                    }
                     break;
-                case FP_OFFSET_FROM_L4_HEADER:
-                    flags |= FP_FL_L4_OFFSET;
+                }
+                case FPP_ACTION_DEREGISTER:
+                {
+                    ret = fci_fp_db_destroy_rule((char_t*)fp_cmd->r.rule_name);
+                    if(EOK == ret)
+                    {
+                        *fci_ret = FPP_ERR_OK;
+                    }
+                    else
+                    {
+                        *fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+                    }
                     break;
-                default:
-                    NXP_LOG_ERROR("Impossible happened\n");
-                    *fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-                    return EINVAL;
-            }
-            if((uint8_t)TRUE == fp_cmd->r.invert)
-            {
-                flags |= FP_FL_INVERT;
-            }
+                }
+                case FPP_ACTION_QUERY:
+                {
+                    char *rule_name;
+                    char *next_rule;
+                    uint32_t data, mask;
+                    uint16_t offset;
+                    pfe_ct_fp_flags_t flags;
 
-            ret = fci_fp_db_create_rule((char_t *)fp_cmd->r.rule_name, fp_cmd->r.data, fp_cmd->r.mask,
-                                     fp_cmd->r.offset, flags,
-                                     (char_t *)fp_cmd->r.next_rule_name);
-            if(EOK == ret)
-            {
-                *fci_ret = FPP_ERR_OK;
-            }
-            else
-            {
-                *fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-            }
-            break;
-        }
-        case FPP_ACTION_DEREGISTER:
-        {
-            ret = fci_fp_db_destroy_rule((char_t*)fp_cmd->r.rule_name);
-            if(EOK == ret)
-            {
-                *fci_ret = FPP_ERR_OK;
-            }
-            else
-            {
-                *fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-            }
-            break;
-        }
-        case FPP_ACTION_QUERY:
-        {
-            char *rule_name;
-            char *next_rule;
-            uint32_t data, mask;
-            uint16_t offset;
-            pfe_ct_fp_flags_t flags;
+                    ret = fci_fp_db_get_first_rule(&rule_name, &data, &mask, &offset, &flags, &next_rule);
+                    if(EOK == ret)
+                    {
+                        fci_fp_construct_rule_reply(&reply_buf->r, rule_name, next_rule, data, mask, offset, flags);
+                        *fci_ret = FPP_ERR_OK;
+                        *reply_len = sizeof(fpp_fp_rule_cmd_t);
+                    }
+                    else
+                    {
+                        *fci_ret = FPP_ERR_FP_RULE_NOT_FOUND;
+                    }
+                    break;
+                }
+                case FPP_ACTION_QUERY_CONT:
+                {
+                    char *rule_name;
+                    char *next_rule;
+                    uint32_t data, mask;
+                    uint16_t offset;
+                    pfe_ct_fp_flags_t flags;
 
-            ret = fci_fp_db_get_first_rule(&rule_name, &data, &mask, &offset, &flags, &next_rule);
-            if(EOK == ret)
-            {
-                fci_fp_construct_rule_reply(&reply_buf->r, rule_name, next_rule, data, mask, offset, flags);
-                *fci_ret = FPP_ERR_OK;
-                *reply_len = sizeof(fpp_fp_rule_cmd_t);
-            }
-            else
-            {
-                *fci_ret = FPP_ERR_FP_RULE_NOT_FOUND;
-            }
-            break;
-        }
-        case FPP_ACTION_QUERY_CONT:
-        {
-            char *rule_name;
-            char *next_rule;
-            uint32_t data, mask;
-            uint16_t offset;
-            pfe_ct_fp_flags_t flags;
+                    ret = fci_fp_db_get_next_rule(&rule_name, &data, &mask, &offset, &flags, &next_rule);
+                    if(EOK == ret)
+                    {
+                        fci_fp_construct_rule_reply(&reply_buf->r, rule_name, next_rule, data, mask, offset, flags);
+                        *fci_ret = FPP_ERR_OK;
+                        *reply_len = sizeof(fpp_fp_rule_cmd_t);
+                    }
+                    else
+                    {
+                        *fci_ret = FPP_ERR_FP_RULE_NOT_FOUND;
+                    }
+                    break;
+                }
 
-            ret = fci_fp_db_get_next_rule(&rule_name, &data, &mask, &offset, &flags, &next_rule);
-            if(EOK == ret)
-            {
-                fci_fp_construct_rule_reply(&reply_buf->r, rule_name, next_rule, data, mask, offset, flags);
-                *fci_ret = FPP_ERR_OK;
-                *reply_len = sizeof(fpp_fp_rule_cmd_t);
-            }
-            else
-            {
-                *fci_ret = FPP_ERR_FP_RULE_NOT_FOUND;
+                default:
+                {
+                    NXP_LOG_ERROR("FPP_CMD_L2_BD: Unknown action received: 0x%x\n", fp_cmd->action);
+                    *fci_ret = FPP_ERR_UNKNOWN_ACTION;
+                    break;
+                }
             }
-            break;
         }
-
-		default:
-		{
-			NXP_LOG_ERROR("FPP_CMD_L2_BD: Unknown action received: 0x%x\n", fp_cmd->action);
-			*fci_ret = FPP_ERR_UNKNOWN_ACTION;
-			break;
-		}
     }
+
     return ret;
 }
 
diff --git a/sw/fci/src/fci_fp_db.c b/sw/fci/src/fci_fp_db.c
index 0c4c9cd..21a2a98 100644
--- a/sw/fci/src/fci_fp_db.c
+++ b/sw/fci/src/fci_fp_db.c
@@ -128,33 +128,36 @@ static bool_t fci_fp_match_rule_by_criterion(fci_fp_rule_criterion_t crit, const
     if (unlikely((NULL == rule) || (NULL == arg)))
     {
         NXP_LOG_ERROR("NULL argument received\n");
-        return FALSE;
+        match = FALSE;
     }
+    else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-    switch (crit)
     {
-        case FP_RULE_CRIT_ALL:
-        {
-            match = TRUE;
-            break;
-        }
-        case FP_RULE_CRIT_NAME:
+        switch (crit)
         {
-            if(0 == strcmp(arg->name, rule->name))
+            case FP_RULE_CRIT_ALL:
             {
                 match = TRUE;
+                break;
             }
-            else
+            case FP_RULE_CRIT_NAME:
+            {
+                if(0 == strcmp(arg->name, rule->name))
+                {
+                    match = TRUE;
+                }
+                else
+                {
+                    match = FALSE;
+                }
+                break;
+            }
+            default:
             {
+                NXP_LOG_ERROR("Unknown criterion\n");
                 match = FALSE;
+                break;
             }
-            break;
-        }
-        default:
-        {
-            NXP_LOG_ERROR("Unknown criterion\n");
-            match = FALSE;
-			break;
         }
     }
     return match;
@@ -173,94 +176,99 @@ static fci_fp_rule_t *fci_fp_rule_get_first(fci_fp_rule_db_t *db, fci_fp_rule_cr
     LLIST_t *item;
     fci_fp_rule_t *rule;
     bool_t match = FALSE;
+    bool_t cur_crit_remember_success = TRUE;
+
 #if defined(PFE_CFG_NULL_ARG_CHECK)
     if (unlikely(NULL == db))
     {
         NXP_LOG_ERROR("NULL argument received\n");
-        return NULL;
     }
-    if (unlikely((FP_RULE_CRIT_ALL != crit) && (NULL == arg)))
+    else if (unlikely((FP_RULE_CRIT_ALL != crit) && (NULL == arg)))
     {
         /*  All criterions except FP_RULE_CRIT_ALL require non-NULL argument */
         NXP_LOG_ERROR("NULL argument received\n");
-        return NULL;
     }
+    else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-    /* Free memory allocated by previous search (if any) */
-    if(FP_RULE_CRIT_NAME == db->cur_crit)
-    {
-        if(NULL != db->cur_crit_arg.name)
-        {
-            oal_mm_free(db->cur_crit_arg.name);
-            db->cur_crit_arg.name = NULL;
-        }
-    }
-    /*    Remember criterion and argument for possible subsequent fci_fp_rule_get_next() calls */
-    db->cur_crit = crit;
-    switch(db->cur_crit)
     {
-        case FP_RULE_CRIT_ALL:
-        {
-            break;
-        }
-        case FP_RULE_CRIT_NAME:
+        /* Free memory allocated by previous search (if any) */
+        if(FP_RULE_CRIT_NAME == db->cur_crit)
         {
-            char_t *mem;
-            /* Allocate string memory */
-            mem = oal_mm_malloc(strlen((char_t *)arg) + 1U);
-            if(NULL == mem)
+            if(NULL != db->cur_crit_arg.name)
             {
-                return NULL;
+                oal_mm_free(db->cur_crit_arg.name);
+                db->cur_crit_arg.name = NULL;
             }
-            db->cur_crit_arg.name = mem;
-            /* Copy the string */
-            (void)strcpy(mem, (char_t *)arg);
-            break;
         }
-        default:
+        /*    Remember criterion and argument for possible subsequent fci_fp_rule_get_next() calls */
+        db->cur_crit = crit;
+        switch(db->cur_crit)
         {
-            NXP_LOG_ERROR("Unknown criterion\n");
-            return NULL;
-        }
-    }
-
-    /*    Search for first matching rule */
-    if (FALSE == LLIST_IsEmpty(&db->rules))
-    {
-        /*    Get first matching rule */
-        LLIST_ForEach(item, &db->rules)
-        {
-            /*    Get data */
-            if(COMMON == dbase)
+            case FP_RULE_CRIT_ALL:
             {
-                rule = LLIST_Data(item, fci_fp_rule_t, db_entry);
+                break;
             }
-            else
+            case FP_RULE_CRIT_NAME:
             {
-                rule = LLIST_Data(item, fci_fp_rule_t, table_entry);
+                char_t *mem;
+                /* Allocate string memory */
+                mem = oal_mm_malloc(strlen((char_t *)arg) + 1U);
+                if(NULL == mem)
+                {
+                    cur_crit_remember_success = FALSE;
+                }
+                else
+                {
+                    db->cur_crit_arg.name = mem;
+                    /* Copy the string */
+                    (void)strcpy(mem, (char_t *)arg);
+                }
+                break;
             }
-
-            /*    Remember current item to know where to start later */
-            db->cur_item = item->prNext;
-            if (NULL != rule)
+            default:
+            {
+                NXP_LOG_ERROR("Unknown criterion\n");
+                cur_crit_remember_success = FALSE;
+            }
+        }
+        if (TRUE == cur_crit_remember_success)
+        {
+            /*    Search for first matching rule */
+            if (FALSE == LLIST_IsEmpty(&db->rules))
             {
-                if (TRUE == fci_fp_match_rule_by_criterion(db->cur_crit, &db->cur_crit_arg, rule))
+                /*    Get first matching rule */
+                LLIST_ForEach(item, &db->rules)
                 {
-                    match = TRUE;
-                    break;
+                    /*    Get data */
+                    if(COMMON == dbase)
+                    {
+                        rule = LLIST_Data(item, fci_fp_rule_t, db_entry);
+                    }
+                    else
+                    {
+                        rule = LLIST_Data(item, fci_fp_rule_t, table_entry);
+                    }
+
+                    /*    Remember current item to know where to start later */
+                    db->cur_item = item->prNext;
+                    if (NULL != rule)
+                    {
+                        if (TRUE == fci_fp_match_rule_by_criterion(db->cur_crit, &db->cur_crit_arg, rule))
+                        {
+                            match = TRUE;
+                            break;
+                        }
+                    }
                 }
             }
         }
     }
 
-    if (TRUE == match)
-    {
-        return rule;
-    }
-    else
+    if (TRUE != match)
     {
-        return NULL;
+        rule = NULL;
     }
+    return rule;
 }
 /**
  * @brief        Get next rule from the database
@@ -272,56 +280,50 @@ static fci_fp_rule_t *fci_fp_rule_get_first(fci_fp_rule_db_t *db, fci_fp_rule_cr
 static fci_fp_rule_t *fci_fp_rule_get_next(fci_fp_rule_db_t *db, dbase_t dbase)
 {
     fci_fp_rule_t *rule;
-    bool_t match = FALSE;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
     if (unlikely(NULL == db))
     {
         NXP_LOG_ERROR("NULL argument received\n");
-        return NULL;
-    }
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-    if (db->cur_item == &db->rules)
-    {
-        /*    No more entries */
         rule = NULL;
     }
     else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
     {
-        while (db->cur_item != &db->rules)
+        if (db->cur_item == &db->rules)
         {
-            /*    Get data */
-            if(COMMON == dbase)
-            {
-                rule = LLIST_Data(db->cur_item, fci_fp_rule_t, db_entry);
-            }
-            else
+            /*    No more entries */
+            rule = NULL;
+        }
+        else
+        {
+            while (db->cur_item != &db->rules)
             {
-                rule = LLIST_Data(db->cur_item, fci_fp_rule_t, table_entry);
-            }
+                /*    Get data */
+                if(COMMON == dbase)
+                {
+                    rule = LLIST_Data(db->cur_item, fci_fp_rule_t, db_entry);
+                }
+                else
+                {
+                    rule = LLIST_Data(db->cur_item, fci_fp_rule_t, table_entry);
+                }
 
-            /*    Remember current item to know where to start later */
-            db->cur_item = db->cur_item->prNext;
+                /*    Remember current item to know where to start later */
+                db->cur_item = db->cur_item->prNext;
 
-            if (NULL != rule)
-            {
-                if (TRUE == fci_fp_match_rule_by_criterion(db->cur_crit, &db->cur_crit_arg, rule))
+                if (NULL != rule)
                 {
-                    match = TRUE;
-                    break;
+                    if (TRUE == fci_fp_match_rule_by_criterion(db->cur_crit, &db->cur_crit_arg, rule))
+                    {
+                        break;
+                    }
                 }
             }
         }
     }
 
-    if (TRUE == match)
-    {
-        return rule;
-    }
-    else
-    {
-        return NULL;
-    }
+    return rule;
 }
 /**
  * @brief        Match table using given criterion
@@ -338,44 +340,47 @@ static bool_t fci_fp_match_table_by_criterion(fci_fp_table_criterion_t crit, con
     if (unlikely((NULL == fp_table) || (NULL == arg)))
     {
         NXP_LOG_ERROR("NULL argument received\n");
-        return FALSE;
+        match = FALSE;
     }
+    else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-    switch (crit)
     {
-        case FP_TABLE_CRIT_ALL:
+        switch (crit)
         {
-            match = TRUE;
-            break;
-        }
-        case FP_TABLE_CRIT_NAME:
-        {
-            if(0 == strcmp(arg->name, fp_table->name))
+            case FP_TABLE_CRIT_ALL:
             {
                 match = TRUE;
+                break;
             }
-            else
+            case FP_TABLE_CRIT_NAME:
             {
-                match = FALSE;
+                if(0 == strcmp(arg->name, fp_table->name))
+                {
+                    match = TRUE;
+                }
+                else
+                {
+                    match = FALSE;
+                }
+                break;
             }
-            break;
-        }
-        case FP_TABLE_CRIT_ADDRESS:
-        {
-            if(arg->address == fp_table->dmem_addr)
+            case FP_TABLE_CRIT_ADDRESS:
             {
-                match = TRUE;
+                if(arg->address == fp_table->dmem_addr)
+                {
+                    match = TRUE;
+                }
+                else
+                {
+                    match = FALSE;
+                }
+                break;
             }
-            else
+            default:
             {
+                NXP_LOG_ERROR("Unknown criterion\n");
                 match = FALSE;
             }
-            break;
-        }
-        default:
-        {
-            NXP_LOG_ERROR("Unknown criterion\n");
-            match = FALSE;
         }
     }
     return match;
@@ -393,92 +398,98 @@ static fci_fp_table_t *fci_fp_table_get_first(fci_fp_table_db_t *db, fci_fp_tabl
     LLIST_t *item;
     fci_fp_table_t *fp_table;
     bool_t match = FALSE;
+    bool_t cur_crit_remember_success = TRUE;
+
 #if defined(PFE_CFG_NULL_ARG_CHECK)
     if (unlikely(NULL == db))
     {
         NXP_LOG_ERROR("NULL argument received\n");
-        return NULL;
     }
-    if (unlikely((FP_TABLE_CRIT_ALL != crit) && (NULL == arg)))
+    else if (unlikely((FP_TABLE_CRIT_ALL != crit) && (NULL == arg)))
     {
         /*  All criterions except FP_TABLE_CRIT_ALL require non-NULL argument */
         NXP_LOG_ERROR("NULL argument received\n");
-        return NULL;
     }
+    else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-    /* Free memory allocated by previous search (if any) */
-    if(FP_TABLE_CRIT_NAME == db->cur_crit)
-    {
-        if(NULL != db->cur_crit_arg.name)
-        {
-            oal_mm_free(db->cur_crit_arg.name);
-            db->cur_crit_arg.name = NULL;
-        }
-    }
-    /*    Remember criterion and argument for possible subsequent fci_fp_table_get_next() calls */
-    db->cur_crit = crit;
-    switch(db->cur_crit)
     {
-        case FP_TABLE_CRIT_ALL:
+        /* Free memory allocated by previous search (if any) */
+        if(FP_TABLE_CRIT_NAME == db->cur_crit)
         {
-            break;
-        }
-        case FP_TABLE_CRIT_NAME:
-        {
-            char_t *mem;
-            /* Allocate string memory */
-            mem = oal_mm_malloc(strlen((char_t *)arg) + 1U);
-            if(NULL == mem)
+            if(NULL != db->cur_crit_arg.name)
             {
-                return NULL;
+                oal_mm_free(db->cur_crit_arg.name);
+                db->cur_crit_arg.name = NULL;
             }
-            db->cur_crit_arg.name = mem;
-            /* Copy the string */
-            (void)strcpy(mem, (char_t *)arg);
-            break;
-        }
-        case FP_TABLE_CRIT_ADDRESS:
-        {
-            db->cur_crit_arg.address = *(uint32_t *)arg;
-            break;
         }
-        default:
+        /*    Remember criterion and argument for possible subsequent fci_fp_table_get_next() calls */
+        db->cur_crit = crit;
+        switch(db->cur_crit)
         {
-            NXP_LOG_ERROR("Unknown criterion\n");
-            return NULL;
+            case FP_TABLE_CRIT_ALL:
+            {
+                break;
+            }
+            case FP_TABLE_CRIT_NAME:
+            {
+                char_t *mem;
+                /* Allocate string memory */
+                mem = oal_mm_malloc(strlen((char_t *)arg) + 1U);
+                if(NULL == mem)
+                {
+                    cur_crit_remember_success = FALSE;
+                }
+                else
+                {
+                    db->cur_crit_arg.name = mem;
+                    /* Copy the string */
+                    (void)strcpy(mem, (char_t *)arg);
+                }
+                break;
+            }
+            case FP_TABLE_CRIT_ADDRESS:
+            {
+                db->cur_crit_arg.address = *(uint32_t *)arg;
+                break;
+            }
+            default:
+            {
+                NXP_LOG_ERROR("Unknown criterion\n");
+                cur_crit_remember_success = FALSE;
+            }
         }
-    }
 
-    /*    Search for first matching table */
-    if (FALSE == LLIST_IsEmpty(&db->tables))
-    {
-        /*    Get first matching table */
-        LLIST_ForEach(item, &db->tables)
+        if (TRUE == cur_crit_remember_success)
         {
-            /*    Get data */
-            fp_table = LLIST_Data(item, fci_fp_table_t, db_entry);
-
-            /*    Remember current item to know where to start later */
-            db->cur_item = item->prNext;
-            if (NULL != fp_table)
+            /*    Search for first matching table */
+            if (FALSE == LLIST_IsEmpty(&db->tables))
             {
-                if (TRUE == fci_fp_match_table_by_criterion(db->cur_crit, &db->cur_crit_arg, fp_table))
+                /*    Get first matching table */
+                LLIST_ForEach(item, &db->tables)
                 {
-                    match = TRUE;
-                    break;
+                    /*    Get data */
+                    fp_table = LLIST_Data(item, fci_fp_table_t, db_entry);
+
+                    /*    Remember current item to know where to start later */
+                    db->cur_item = item->prNext;
+                    if (NULL != fp_table)
+                    {
+                        if (TRUE == fci_fp_match_table_by_criterion(db->cur_crit, &db->cur_crit_arg, fp_table))
+                        {
+                            match = TRUE;
+                            break;
+                        }
+                    }
                 }
             }
         }
     }
 
-    if (TRUE == match)
-    {
-        return fp_table;
-    }
-    else
+    if(TRUE != match)
     {
-        return NULL;
+        fp_table = NULL;
     }
+    return fp_table;
 }
 
 #if 0 /* Function prepared for future */
@@ -548,6 +559,7 @@ static errno_t fci_fp_get_rule_pos_in_table(const fci_fp_table_t *fp_table, fci_
     uint8_t i = 0U;
     fci_fp_rule_t *rule_item;
     LLIST_t *item;
+    errno_t ret = ENOENT;
 
     LLIST_ForEach(item, &fp_table->rules_db.rules)
     {
@@ -555,11 +567,12 @@ static errno_t fci_fp_get_rule_pos_in_table(const fci_fp_table_t *fp_table, fci_
         if(rule_item == rule)
         {
             *pos = i;
-            return EOK;
+            ret = EOK;
+            break;
         }
         i++;
     }
-    return ENOENT;
+    return ret ;
 }
 
 /**
@@ -590,75 +603,86 @@ errno_t fci_fp_db_create_rule(char_t *name, uint32_t data, uint32_t mask, uint16
     uint32_t mem_size;
     fci_fp_rule_t *rule = NULL;
     bool_t ignore_next_rule = FALSE;
+    errno_t ret;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
     if(NULL == name)
     {
         NXP_LOG_ERROR("NULL argument received\n");
-        return EINVAL;
-    }
-#endif
-    if((0U == ((uint8_t)flags & ((uint8_t)FP_FL_ACCEPT | (uint8_t)FP_FL_REJECT))) && (NULL == next_rule))
-    {   /* If flags are not FP_FL_REJECT and not FP_FL_ACCEPT we need the next rule name */
-        NXP_LOG_ERROR("Flags FP_FL_ACCEPT and FP_FL_REJECT are not set but next rule is not defined (NULL)\n");
-        return EINVAL;
-    }
-    if(((uint8_t)FP_FL_ACCEPT | (uint8_t)FP_FL_REJECT) == ((uint8_t)flags & ((uint8_t)FP_FL_ACCEPT | (uint8_t)FP_FL_REJECT)))
-    {   /* Cannot do both Accept and Reject action */
-        NXP_LOG_ERROR("Both flags FP_FL_ACCEPT and FP_FL_REJECT are set\n");
-        return EINVAL;
-    }
-    if((0U != ((uint8_t)flags & ((uint8_t)FP_FL_ACCEPT | (uint8_t)FP_FL_REJECT))) && (NULL != next_rule))
-    {   /* Ignored argument */
-        NXP_LOG_WARNING("Next rule is ignored with these flags: 0x%x\n", flags);
-        ignore_next_rule = TRUE;
-    }
-    /* Check that the name is unique in our database */
-    if(NULL != fci_fp_rule_get_first(&fci_fp_rule_db, FP_RULE_CRIT_NAME, name, COMMON))
-    {   /* Rule with same name found in database */
-        NXP_LOG_ERROR("Rule with name \"%s\" already exists\n", name);
-        return EEXIST;
-    }
-
-    /* Calculate needed memory size */
-    mem_size = sizeof(fci_fp_rule_t) + strlen(name) + 1U; /* Structure + name string */
-    if((NULL != next_rule) && (FALSE == ignore_next_rule))
-    {
-        mem_size += strlen(next_rule) + 1U; /* Add next rule name string space */
-    }
-    /* Allocate memory for the rule */
-    rule = oal_mm_malloc(mem_size);
-    if(NULL == rule)
-    {   /* Failed */
-        NXP_LOG_ERROR("No memory for rule\n");
-        return ENOMEM;
+        ret = EINVAL;
     }
     else
+#endif
     {
-        /* Initialize */
-        (void)memset(rule, 0, mem_size);
-        LLIST_Init(&rule->db_entry);
-        LLIST_Init(&rule->table_entry);
-        /* Store the input parameters */
-        rule->name = (char_t *)&rule[1];
-        (void)strcpy(rule->name, name);
-        rule->data = data;
-        rule->mask = mask;
-        rule->offset = offset;
-        if((NULL != next_rule) && (FALSE == ignore_next_rule))
-        {   /* Just store the next rule name, no validation yet because rule may be added later */
-            rule->next_rule = rule->name + strlen(name) + 1U;
-            (void)strcpy(rule->next_rule, next_rule);
+        if((0U == ((uint8_t)flags & ((uint8_t)FP_FL_ACCEPT | (uint8_t)FP_FL_REJECT))) && (NULL == next_rule))
+        {   /* If flags are not FP_FL_REJECT and not FP_FL_ACCEPT we need the next rule name */
+            NXP_LOG_ERROR("Flags FP_FL_ACCEPT and FP_FL_REJECT are not set but next rule is not defined (NULL)\n");
+            ret = EINVAL;
+        }
+        else if(((uint8_t)FP_FL_ACCEPT | (uint8_t)FP_FL_REJECT) == ((uint8_t)flags & ((uint8_t)FP_FL_ACCEPT | (uint8_t)FP_FL_REJECT)))
+        {   /* Cannot do both Accept and Reject action */
+            NXP_LOG_ERROR("Both flags FP_FL_ACCEPT and FP_FL_REJECT are set\n");
+            ret = EINVAL;
         }
         else
         {
-            rule->next_rule = NULL;
+            if((0U != ((uint8_t)flags & ((uint8_t)FP_FL_ACCEPT | (uint8_t)FP_FL_REJECT))) && (NULL != next_rule))
+            {   /* Ignored argument */
+                NXP_LOG_WARNING("Next rule is ignored with these flags: 0x%x\n", flags);
+                ignore_next_rule = TRUE;
+            }
+            /* Check that the name is unique in our database */
+            if(NULL != fci_fp_rule_get_first(&fci_fp_rule_db, FP_RULE_CRIT_NAME, name, COMMON))
+            {   /* Rule with same name found in database */
+                NXP_LOG_ERROR("Rule with name \"%s\" already exists\n", name);
+                ret = EEXIST;
+            }
+            else
+            {
+
+                /* Calculate needed memory size */
+                mem_size = sizeof(fci_fp_rule_t) + strlen(name) + 1U; /* Structure + name string */
+                if((NULL != next_rule) && (FALSE == ignore_next_rule))
+                {
+                    mem_size += strlen(next_rule) + 1U; /* Add next rule name string space */
+                }
+                /* Allocate memory for the rule */
+                rule = oal_mm_malloc(mem_size);
+                if(NULL == rule)
+                {   /* Failed */
+                    NXP_LOG_ERROR("No memory for rule\n");
+                    ret = ENOMEM;
+                }
+                else
+                {
+                    /* Initialize */
+                    (void)memset(rule, 0, mem_size);
+                    LLIST_Init(&rule->db_entry);
+                    LLIST_Init(&rule->table_entry);
+                    /* Store the input parameters */
+                    rule->name = (char_t *)&rule[1];
+                    (void)strcpy(rule->name, name);
+                    rule->data = data;
+                    rule->mask = mask;
+                    rule->offset = offset;
+                    if((NULL != next_rule) && (FALSE == ignore_next_rule))
+                    {   /* Just store the next rule name, no validation yet because rule may be added later */
+                        rule->next_rule = rule->name + strlen(name) + 1U;
+                        (void)strcpy(rule->next_rule, next_rule);
+                    }
+                    else
+                    {
+                        rule->next_rule = NULL;
+                    }
+                    rule->flags = flags;
+                    /* Add the rule into the global database */
+                    LLIST_AddAtEnd(&rule->db_entry, &fci_fp_rule_db.rules);
+                    ret = EOK;
+                }
+            }
         }
-        rule->flags = flags;
-        /* Add the rule into the global database */
-        LLIST_AddAtEnd(&rule->db_entry, &fci_fp_rule_db.rules);
     }
-    return EOK;
+    return ret;
 }
 
 /**
@@ -669,32 +693,43 @@ errno_t fci_fp_db_create_rule(char_t *name, uint32_t data, uint32_t mask, uint16
 errno_t fci_fp_db_destroy_rule(char_t *name)
 {
   fci_fp_rule_t *rule = NULL;
+  errno_t ret;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
     if(NULL == name)
     {
         NXP_LOG_ERROR("NULL argument received\n");
-        return EINVAL;
+        ret = EINVAL;
     }
+    else
 #endif
-    /* Find the rule */
-    rule = fci_fp_rule_get_first(&fci_fp_rule_db, FP_RULE_CRIT_NAME, name, COMMON);
-    if(NULL == rule)
-    {   /* No such rule */
-        NXP_LOG_ERROR("Rule with name \"%s\" does not exist\n", name);
-        return ENOENT;
-    }
-    /* Check that the rule is not in use */
-    if(NULL != rule->table)
-    {   /* Still in use */
-        NXP_LOG_ERROR("Rule \"%s\" is in use in table \"%s\"\n", name, rule->table->name);
-        return EACCES;
+    {
+        /* Find the rule */
+        rule = fci_fp_rule_get_first(&fci_fp_rule_db, FP_RULE_CRIT_NAME, name, COMMON);
+        if(NULL == rule)
+        {   /* No such rule */
+            NXP_LOG_ERROR("Rule with name \"%s\" does not exist\n", name);
+            ret = ENOENT;
+        }
+        else
+        {
+            /* Check that the rule is not in use */
+            if(NULL != rule->table)
+            {   /* Still in use */
+                NXP_LOG_ERROR("Rule \"%s\" is in use in table \"%s\"\n", name, rule->table->name);
+                ret = EACCES;
+            }
+            else
+            {
+                /* Remove rule from the database */
+                LLIST_Remove(&rule->db_entry);
+                /* Free the memory */
+                oal_mm_free(rule);
+                ret = EOK;
+            }
+        }
     }
-    /* Remove rule from the database */
-    LLIST_Remove(&rule->db_entry);
-    /* Free the memory */
-    oal_mm_free(rule);
-    return EOK;
+    return ret;
 }
 
 /**
@@ -706,41 +741,48 @@ errno_t fci_fp_db_create_table(char_t *name)
 {
     uint32_t mem_size;
     fci_fp_table_t *fp_table;
+    errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
     if(NULL == name)
     {
         NXP_LOG_ERROR("NULL argument received\n");
-        return EINVAL;
-    }
-#endif
-    /* Check that the name is unique in our database */
-    if(NULL != fci_fp_table_get_first(&fci_fp_table_db, FP_TABLE_CRIT_NAME, name))
-    {   /* Rule with same name found in database */
-        NXP_LOG_ERROR("Table with name \"%s\" already exists\n", name);
-        return EEXIST;
-    }
-
-    /* Allocate memory for the table */
-    mem_size = sizeof(fci_fp_table_t) + strlen(name) + 1U;
-    fp_table = oal_mm_malloc(mem_size);
-    if(NULL == fp_table)
-    {
-        NXP_LOG_ERROR("No memory for the table\n");
-        return ENOMEM;
+        ret =  EINVAL;
     }
     else
+#endif
     {
-        /* Initialize */
-        (void)memset(fp_table, 0, mem_size);
-        LLIST_Init(&fp_table->db_entry);
-        LLIST_Init(&fp_table->rules_db.rules);
-        /* Store the input parameters */
-        fp_table->name = (char_t *)&fp_table[1];
-        (void)strcpy(fp_table->name, name);
-        /* Add the table into the global database */
-        LLIST_AddAtEnd(&fp_table->db_entry, &fci_fp_table_db.tables);
+        /* Check that the name is unique in our database */
+        if(NULL != fci_fp_table_get_first(&fci_fp_table_db, FP_TABLE_CRIT_NAME, name))
+        {   /* Rule with same name found in database */
+            NXP_LOG_ERROR("Table with name \"%s\" already exists\n", name);
+            ret = EEXIST;
+        }
+        else
+        {
+            /* Allocate memory for the table */
+            mem_size = sizeof(fci_fp_table_t) + strlen(name) + 1U;
+            fp_table = oal_mm_malloc(mem_size);
+            if(NULL == fp_table)
+            {
+                NXP_LOG_ERROR("No memory for the table\n");
+                ret = ENOMEM;
+            }
+            else
+            {
+                /* Initialize */
+                (void)memset(fp_table, 0, mem_size);
+                LLIST_Init(&fp_table->db_entry);
+                LLIST_Init(&fp_table->rules_db.rules);
+                /* Store the input parameters */
+                fp_table->name = (char_t *)&fp_table[1];
+                (void)strcpy(fp_table->name, name);
+                /* Add the table into the global database */
+                LLIST_AddAtEnd(&fp_table->db_entry, &fci_fp_table_db.tables);
+                ret = EOK;
+            }
+        }
     }
-    return EOK;
+    return ret;
 
 }
 
@@ -755,51 +797,60 @@ errno_t fci_fp_db_destroy_table(char_t *name, bool_t force)
     fci_fp_table_t *fp_table;
     fci_fp_rule_t *rule;
     LLIST_t *item, *aux;
+    errno_t ret = EOK;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
     if(NULL == name)
     {
         NXP_LOG_ERROR("NULL argument received\n");
-        return EINVAL;
+        ret = EINVAL;
     }
+    else
 #endif
-    /* Find the table */
-    fp_table = fci_fp_table_get_first(&fci_fp_table_db, FP_TABLE_CRIT_NAME, name);
-    if(NULL == fp_table)
     {
-        NXP_LOG_ERROR("Table with name \"%s\" does not exist\n", name);
-        return ENOENT;
-    }
-    /* Check that the table is not in use */
-    if(0U != fp_table->dmem_addr)
-    {   /* Table is still in use */
-        if(FALSE == force)
-        {   /* No override */
-            NXP_LOG_ERROR("Table \"%s\" is in use\n", name);
-            return EACCES;
+        /* Find the table */
+        fp_table = fci_fp_table_get_first(&fci_fp_table_db, FP_TABLE_CRIT_NAME, name);
+        if(NULL == fp_table)
+        {
+            NXP_LOG_ERROR("Table with name \"%s\" does not exist\n", name);
+            ret = ENOENT;
         }
         else
-        {   /* Override (and ride to hell) */
-            NXP_LOG_WARNING("Table \"%s\" is in use\n", name);
-            fp_table->dmem_addr = 0U;
-        }
-    }
-
-    /* Unlink all rules in the table if there are any */
-    if(FALSE == LLIST_IsEmpty(&fp_table->rules_db.rules))
-    {
-        LLIST_ForEachRemovable(item, aux, &fp_table->rules_db.rules)
         {
-            rule = LLIST_Data(item, fci_fp_rule_t, table_entry);
-            LLIST_Remove(item);
-            fp_table->rule_count -= 1U;
-            rule->table = NULL;
+            /* Check that the table is not in use */
+            if(0U != fp_table->dmem_addr)
+            {   /* Table is still in use */
+                if(FALSE == force)
+                {   /* No override */
+                    NXP_LOG_ERROR("Table \"%s\" is in use\n", name);
+                    ret = EACCES;
+                }
+                else
+                {   /* Override (and ride to hell) */
+                    NXP_LOG_WARNING("Table \"%s\" is in use\n", name);
+                    fp_table->dmem_addr = 0U;
+                }
+            }
+            if(EOK == ret)
+            {
+                /* Unlink all rules in the table if there are any */
+                if(FALSE == LLIST_IsEmpty(&fp_table->rules_db.rules))
+                {
+                    LLIST_ForEachRemovable(item, aux, &fp_table->rules_db.rules)
+                    {
+                        rule = LLIST_Data(item, fci_fp_rule_t, table_entry);
+                        LLIST_Remove(item);
+                        fp_table->rule_count -= 1U;
+                        rule->table = NULL;
+                    }
+                }
+                /* Remove table from the database */
+                LLIST_Remove(&fp_table->db_entry);
+                /* Free the memory */
+                oal_mm_free(fp_table);
+            }
         }
     }
-    /* Remove table from the database */
-    LLIST_Remove(&fp_table->db_entry);
-    /* Free the memory */
-    oal_mm_free(fp_table);
-    return EOK;
+    return ret;
 }
 
 
@@ -818,90 +869,106 @@ errno_t fci_fp_db_add_rule_to_table(char_t *table_name, char_t *rule_name, uint1
     fci_fp_rule_t *rule;
     LLIST_t *item;
     uint32_t i = 0U; /* Start search from position 0 */
+    errno_t ret;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
     if((NULL == table_name)||(NULL == rule_name))
     {
         NXP_LOG_ERROR("NULL argument received\n");
-        return EINVAL;
+        ret = EINVAL;
     }
+    else
 #endif
-    /* Check that the rule does exist */
-    rule = fci_fp_rule_get_first(&fci_fp_rule_db, FP_RULE_CRIT_NAME, rule_name, COMMON);
-    if(NULL == rule)
-    {
-        NXP_LOG_ERROR("Rule \"%s\" does not exist\n", rule_name);
-        return ENOENT;
-    }
-    /* Check that the rule does not belong to any other table */
-    if(NULL != rule->table)
-    {
-        NXP_LOG_ERROR("Rule \"%s\" is already part of the table \"%s\"\n", rule_name, rule->table->name);
-        return EACCES;
-    }
-    /* Check that the table does exist */
-    fp_table = fci_fp_table_get_first(&fci_fp_table_db, FP_TABLE_CRIT_NAME, table_name);
-    if(NULL == fp_table)
     {
-        NXP_LOG_ERROR("Table \"%s\" does not exist\n", table_name);
-        return ENOENT;
-    }
-
-    /* Add rule into the table */
-    if(LLIST_IsEmpty(&fp_table->rules_db.rules))
-    {   /* Empty list - ignore position */
-        if((position != FCI_FP_RULE_POSITION_FIRST) && (position != FCI_FP_RULE_POSITION_LAST))
+        /* Check that the rule does exist */
+        rule = fci_fp_rule_get_first(&fci_fp_rule_db, FP_RULE_CRIT_NAME, rule_name, COMMON);
+        if(NULL == rule)
         {
-            NXP_LOG_WARNING("Adding into an empty table position %u ignored\n", position);
-        }
-        LLIST_AddAtBegin(&rule->table_entry, &fp_table->rules_db.rules);
-        rule->table = fp_table;
-        fp_table->rule_count = 1U; /* 1st rule in table */
-    }
-    else
-    {   /* Table not empty - need to handle position request */
-        if(position == FCI_FP_RULE_POSITION_FIRST)
-        {   /* Insert as the first one */
-            LLIST_AddAtBegin(&rule->table_entry, &fp_table->rules_db.rules);
-            rule->table = fp_table;
-            fp_table->rule_count += 1U;
+            NXP_LOG_ERROR("Rule \"%s\" does not exist\n", rule_name);
+            ret = ENOENT;
         }
-        else if(position >= FCI_FP_RULE_POSITION_LAST)
-        {   /* Add as the last one */
-            LLIST_AddAtEnd(&rule->table_entry, &fp_table->rules_db.rules);
-            rule->table = fp_table;
-            fp_table->rule_count += 1U;
-        }
-        else if(position > FCI_FP_RULE_POSITION_FIRST)
-        {   /* Insert at specified position */
-            bool_t added = FALSE;
-            LLIST_ForEach(item, &fp_table->rules_db.rules)
+        else
+        {
+            /* Check that the rule does not belong to any other table */
+            if(NULL != rule->table)
             {
-                if(position == i)
-                {   /* This is the right position - put rule before the item */
-                    LLIST_Insert(&rule->table_entry, item);
-                    rule->table = fp_table;
-                    fp_table->rule_count += 1U;
-                    added = TRUE;
-                    break;
-                }
-                i++;
+                NXP_LOG_ERROR("Rule \"%s\" is already part of the table \"%s\"\n", rule_name, rule->table->name);
+                ret = EACCES;
             }
-            if(FALSE == added)
-            {   /* The requested position has not been found - add at the end */
-                NXP_LOG_WARNING("Position %u does not exist, adding at %u\n", (uint_t)position, (uint_t)i);
-                LLIST_AddAtEnd(&rule->table_entry, &fp_table->rules_db.rules);
-                rule->table = fp_table;
-                fp_table->rule_count += 1U;
+            else
+            {
+                /* Check that the table does exist */
+                fp_table = fci_fp_table_get_first(&fci_fp_table_db, FP_TABLE_CRIT_NAME, table_name);
+                if(NULL == fp_table)
+                {
+                    NXP_LOG_ERROR("Table \"%s\" does not exist\n", table_name);
+                    ret = ENOENT;
+                }
+                else
+                {
+                    /* Add rule into the table */
+                    if(LLIST_IsEmpty(&fp_table->rules_db.rules))
+                    {   /* Empty list - ignore position */
+                        if((position != FCI_FP_RULE_POSITION_FIRST) && (position != FCI_FP_RULE_POSITION_LAST))
+                        {
+                            NXP_LOG_WARNING("Adding into an empty table position %u ignored\n", position);
+                        }
+                        LLIST_AddAtBegin(&rule->table_entry, &fp_table->rules_db.rules);
+                        rule->table = fp_table;
+                        fp_table->rule_count = 1U; /* 1st rule in table */
+                        ret = EOK;
+                    }
+                    else
+                    {   /* Table not empty - need to handle position request */
+                        if(position == FCI_FP_RULE_POSITION_FIRST)
+                        {   /* Insert as the first one */
+                            LLIST_AddAtBegin(&rule->table_entry, &fp_table->rules_db.rules);
+                            rule->table = fp_table;
+                            fp_table->rule_count += 1U;
+                            ret = EOK;
+                        }
+                        else if(position >= FCI_FP_RULE_POSITION_LAST)
+                        {   /* Add as the last one */
+                            LLIST_AddAtEnd(&rule->table_entry, &fp_table->rules_db.rules);
+                            rule->table = fp_table;
+                            fp_table->rule_count += 1U;
+                            ret = EOK;
+                        }
+                        else if(position > FCI_FP_RULE_POSITION_FIRST)
+                        {   /* Insert at specified position */
+                            bool_t added = FALSE;
+                            LLIST_ForEach(item, &fp_table->rules_db.rules)
+                            {
+                                if(position == i)
+                                {   /* This is the right position - put rule before the item */
+                                    LLIST_Insert(&rule->table_entry, item);
+                                    rule->table = fp_table;
+                                    fp_table->rule_count += 1U;
+                                    added = TRUE;
+                                    break;
+                                }
+                                i++;
+                            }
+                            if(FALSE == added)
+                            {   /* The requested position has not been found - add at the end */
+                                NXP_LOG_WARNING("Position %u does not exist, adding at %u\n", (uint_t)position, (uint_t)i);
+                                LLIST_AddAtEnd(&rule->table_entry, &fp_table->rules_db.rules);
+                                rule->table = fp_table;
+                                fp_table->rule_count += 1U;
+                            }
+                            ret = EOK;
+                        }
+                        else
+                        {   /* Invalid value */
+                            NXP_LOG_ERROR("Invalid value of position %u\n", position);
+                            ret = EINVAL;
+                        }
+                    }
+                }
             }
         }
-        else
-        {   /* Invalid value */
-            NXP_LOG_ERROR("Invalid value of position %u\n", position);
-            return EINVAL;
-        }
-     }
-    return EOK;
+    }
+    return ret;
 }
 
 /**
@@ -913,33 +980,41 @@ errno_t fci_fp_db_add_rule_to_table(char_t *table_name, char_t *rule_name, uint1
 errno_t fci_fp_db_remove_rule_from_table(char_t *rule_name)
 {
     fci_fp_rule_t *rule;
+    errno_t ret;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
     if((NULL == rule_name))
     {
         NXP_LOG_ERROR("NULL argument received\n");
-        return EINVAL;
+        ret = EINVAL;
     }
+    else
 #endif
-    /* Check that the rule does exist */
-    rule = fci_fp_rule_get_first(&fci_fp_rule_db, FP_RULE_CRIT_NAME, rule_name, COMMON);
-    if(NULL == rule)
     {
-        NXP_LOG_ERROR("Rule \"%s\" does not exist\n", rule_name);
-        return ENOENT;
-    }
-    /* Check that the rule is in a table */
-    if(NULL != rule->table)
-    {   /* Rule in a table - remove it */
-        LLIST_Remove(&rule->table_entry);
-        rule->table->rule_count--;
-        rule->table = NULL;
-    }
-    else
-    {   /* Rule not in a table */
-        NXP_LOG_WARNING("Rule \"%s\" is not part of any table\n", rule_name);
+        /* Check that the rule does exist */
+        rule = fci_fp_rule_get_first(&fci_fp_rule_db, FP_RULE_CRIT_NAME, rule_name, COMMON);
+        if(NULL == rule)
+        {
+            NXP_LOG_ERROR("Rule \"%s\" does not exist\n", rule_name);
+            ret = ENOENT;
+        }
+        else
+        {
+            /* Check that the rule is in a table */
+            if(NULL != rule->table)
+            {   /* Rule in a table - remove it */
+                LLIST_Remove(&rule->table_entry);
+                rule->table->rule_count--;
+                rule->table = NULL;
+            }
+            else
+            {   /* Rule not in a table */
+                NXP_LOG_WARNING("Rule \"%s\" is not part of any table\n", rule_name);
+            }
+            ret = EOK;
+        }
     }
-    return EOK;
+    return ret;
 }
 
 /**
@@ -956,19 +1031,21 @@ uint32_t fci_fp_db_get_table_dmem_addr(char_t *table_name)
     if(NULL == table_name)
     {
         NXP_LOG_ERROR("NULL argument received\n");
-        return EINVAL;
-    }
-#endif
-
-    fp_table = fci_fp_table_get_first(&fci_fp_table_db, FP_TABLE_CRIT_NAME, table_name);
-    if(NULL == fp_table)
-    {
-        NXP_LOG_WARNING("Table \"%s\" not found\n", table_name);
         retval = 0U;
     }
     else
+#endif
     {
-        retval = fp_table->dmem_addr;
+        fp_table = fci_fp_table_get_first(&fci_fp_table_db, FP_TABLE_CRIT_NAME, table_name);
+        if(NULL == fp_table)
+        {
+            NXP_LOG_WARNING("Table \"%s\" not found\n", table_name);
+            retval = 0U;
+        }
+        else
+        {
+            retval = fp_table->dmem_addr;
+        }
     }
     return retval;
 }
@@ -991,69 +1068,80 @@ errno_t fci_fp_db_push_table_to_hw(pfe_class_t *class, char_t *table_name)
     fci_fp_rule_t *rule;
     uint16_t i = 0U;
     uint8_t pos;
+    errno_t ret = EOK;
 
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
     if((NULL == class)||(NULL == table_name))
     {
         NXP_LOG_ERROR("NULL argument received\n");
-        return EINVAL;
+        ret = EINVAL;
     }
+    else
 #endif
-    /* Get the table */
-    fp_table = fci_fp_table_get_first(&fci_fp_table_db, FP_TABLE_CRIT_NAME, table_name);
-    if(NULL == fp_table)
     {
-        NXP_LOG_WARNING("Table \"%s\" not found\n", table_name);
-        return ENOENT;
-    }
-
-    fp_table->dmem_addr = pfe_fp_create_table(class, fp_table->rule_count);
-    fp_table->class = class;
-    if(0U == fp_table->dmem_addr)
-    {
-        NXP_LOG_ERROR("Cannot write the table");
-        return EFAULT;
-    }
+        /* Get the table */
+        fp_table = fci_fp_table_get_first(&fci_fp_table_db, FP_TABLE_CRIT_NAME, table_name);
+        if(NULL == fp_table)
+        {
+            NXP_LOG_WARNING("Table \"%s\" not found\n", table_name);
+            ret = ENOENT;
+        }
+        else
+        {
 
-    /* Write rules into the table */
-    LLIST_ForEach(item, &fp_table->rules_db.rules)
-    {
-        rule = LLIST_Data(item, fci_fp_rule_t, table_entry);
-        rule_buf.data = rule->data;
-        rule_buf.mask = rule->mask;
-        rule_buf.offset = rule->offset;
-        rule_buf.flags = rule->flags;
-        if(NULL != rule->next_rule)
-        {   /* Next rule is specified */
-            /* Convert next_rule name to position in the table */
-            next_rule = fci_fp_rule_get_first(&fp_table->rules_db, FP_RULE_CRIT_NAME, rule->next_rule, TABLE);
-            if(NULL == next_rule)
-            {   /* Failed - cannot proceed */
-                NXP_LOG_ERROR("Referenced rule \"%s\" is not part of the table \"%s\"\n", rule->next_rule, table_name);
-                pfe_fp_destroy_table(class, fp_table->dmem_addr);
-                fp_table->dmem_addr = 0U;
-                return ENOENT;
+            fp_table->dmem_addr = pfe_fp_create_table(class, fp_table->rule_count);
+            fp_table->class = class;
+            if(0U == fp_table->dmem_addr)
+            {
+                NXP_LOG_ERROR("Cannot write the table");
+                ret = EFAULT;
             }
-            if(EOK != fci_fp_get_rule_pos_in_table(fp_table, next_rule, &pos))
-            {   /* Failed - cannot proceed */
-                NXP_LOG_ERROR("Referenced rule \"%s\" is not part of the table \"%s\"\n", rule->next_rule, table_name);
-                pfe_fp_destroy_table(class, fp_table->dmem_addr);
-                fp_table->dmem_addr = 0U;
-                return ENOENT;
+            else
+            {
+
+                /* Write rules into the table */
+                LLIST_ForEach(item, &fp_table->rules_db.rules)
+                {
+                    rule = LLIST_Data(item, fci_fp_rule_t, table_entry);
+                    rule_buf.data = rule->data;
+                    rule_buf.mask = rule->mask;
+                    rule_buf.offset = rule->offset;
+                    rule_buf.flags = rule->flags;
+                    if(NULL != rule->next_rule)
+                    {   /* Next rule is specified */
+                        /* Convert next_rule name to position in the table */
+                        next_rule = fci_fp_rule_get_first(&fp_table->rules_db, FP_RULE_CRIT_NAME, rule->next_rule, TABLE);
+                        if(NULL == next_rule)
+                        {   /* Failed - cannot proceed */
+                            NXP_LOG_ERROR("Referenced rule \"%s\" is not part of the table \"%s\"\n", rule->next_rule, table_name);
+                            pfe_fp_destroy_table(class, fp_table->dmem_addr);
+                            fp_table->dmem_addr = 0U;
+                            ret = ENOENT;
+                            break;
+                        }
+                        if(EOK != fci_fp_get_rule_pos_in_table(fp_table, next_rule, &pos))
+                        {   /* Failed - cannot proceed */
+                            NXP_LOG_ERROR("Referenced rule \"%s\" is not part of the table \"%s\"\n", rule->next_rule, table_name);
+                            pfe_fp_destroy_table(class, fp_table->dmem_addr);
+                            fp_table->dmem_addr = 0U;
+                            ret = ENOENT;
+                            break;
+                        }
+                        rule_buf.next_idx = pos;
+                    }
+                    else
+                    {   /* Next rule is not used */
+                        rule_buf.next_idx = 0xFFU; /* If used it will cause FW internal check to detect it */
+                    }
+                    (void)pfe_fp_table_write_rule(class, fp_table->dmem_addr, &rule_buf, i);
+
+                    i++;
+                }
             }
-            rule_buf.next_idx = pos;
-        }
-        else
-        {   /* Next rule is not used */
-            rule_buf.next_idx = 0xFFU; /* If used it will cause FW internal check to detect it */
         }
-        (void)pfe_fp_table_write_rule(class, fp_table->dmem_addr, &rule_buf, i);
-
-        i++;
     }
-
-    return EOK;
+    return ret;
 }
 
 /**
@@ -1067,27 +1155,35 @@ errno_t fci_fp_db_push_table_to_hw(pfe_class_t *class, char_t *table_name)
 errno_t fci_fp_db_pop_table_from_hw(char_t *table_name)
 {
     fci_fp_table_t *fp_table;
+    errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
     if(NULL == table_name)
     {
         NXP_LOG_ERROR("NULL argument received\n");
-        return EINVAL;
+        ret = EINVAL;
     }
+    else
 #endif
-    /* Get the table */
-    fp_table = fci_fp_table_get_first(&fci_fp_table_db, FP_TABLE_CRIT_NAME, table_name);
-    if(NULL == fp_table)
     {
-        NXP_LOG_WARNING("Table \"%s\" not found\n", table_name);
-        return ENOENT;
-    }
+        /* Get the table */
+        fp_table = fci_fp_table_get_first(&fci_fp_table_db, FP_TABLE_CRIT_NAME, table_name);
+        if(NULL == fp_table)
+        {
+            NXP_LOG_WARNING("Table \"%s\" not found\n", table_name);
+            ret = ENOENT;
+        }
+        else
+        {
 
-    /* Free the DMEM */
-    pfe_fp_destroy_table(fp_table->class, fp_table->dmem_addr);
-    /* Clear the references to DMEM */
-    fp_table->dmem_addr = 0U;
-    fp_table->class = NULL;
-    return EOK;
+            /* Free the DMEM */
+            pfe_fp_destroy_table(fp_table->class, fp_table->dmem_addr);
+            /* Clear the references to DMEM */
+            fp_table->dmem_addr = 0U;
+            fp_table->class = NULL;
+            ret = EOK;
+        }
+    }
+    return ret;
 }
 
 /**
@@ -1099,26 +1195,36 @@ errno_t fci_fp_db_pop_table_from_hw(char_t *table_name)
 errno_t fci_fp_db_get_table_from_addr(uint32_t addr, char_t **table_name)
 {
     const fci_fp_table_t *fp_table;
+    errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
     if(NULL == table_name)
     {
         NXP_LOG_ERROR("NULL argument received\n");
-        return EINVAL;
+        ret = EINVAL;
     }
+    else
 #endif
-    if(0U == addr)
-    {   /* 0 is not valid table address, used as no-address */
-        return EINVAL;
-    }
-
-    fp_table = fci_fp_table_get_first(&fci_fp_table_db, FP_TABLE_CRIT_ADDRESS, &addr);
-    if(NULL == fp_table)
     {
-        NXP_LOG_WARNING("Table with address 0x%x not found\n", (uint_t)addr);
-        return ENOENT;
+        if(0U == addr)
+        {   /* 0 is not valid table address, used as no-address */
+            ret = EINVAL;
+        }
+        else
+        {
+            fp_table = fci_fp_table_get_first(&fci_fp_table_db, FP_TABLE_CRIT_ADDRESS, &addr);
+            if(NULL == fp_table)
+            {
+                NXP_LOG_WARNING("Table with address 0x%x not found\n", (uint_t)addr);
+                ret = ENOENT;
+            }
+            else
+            {
+                *table_name = fp_table->name;
+                ret = EOK;
+            }
+        }
     }
-    *table_name = fp_table->name;
-    return EOK;
+    return ret;
 }
 
 /**
@@ -1146,29 +1252,33 @@ fci_fp_table_t *fci_fp_db_get_first(fci_fp_table_criterion_t crit, void *arg)
 errno_t fci_fp_db_get_first_rule(char_t **rule_name, uint32_t *data, uint32_t *mask, uint16_t *offset, pfe_ct_fp_flags_t *flags, char_t **next_rule)
 {
     fci_fp_rule_t *rule;
+    errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
     if((NULL == rule_name) || (NULL == data) || (NULL == mask) || (NULL == offset) || (NULL == flags) || (NULL == next_rule))
     {
         NXP_LOG_ERROR("NULL argument received\n");
-        return EINVAL;
-    }
-#endif
-
-    rule = fci_fp_rule_get_first(&fci_fp_rule_db, FP_RULE_CRIT_ALL, NULL, COMMON);
-    if(NULL == rule)
-    {
-        return ENOENT;
+        ret = EINVAL;
     }
     else
+#endif
     {
-        *rule_name = rule->name;
-        *data = rule->data;
-        *mask = rule->mask;
-        *offset = rule->offset;
-        *flags = rule->flags;
-        *next_rule = rule->next_rule;
-        return EOK;
+        rule = fci_fp_rule_get_first(&fci_fp_rule_db, FP_RULE_CRIT_ALL, NULL, COMMON);
+        if(NULL == rule)
+        {
+            ret = ENOENT;
+        }
+        else
+        {
+            *rule_name = rule->name;
+            *data = rule->data;
+            *mask = rule->mask;
+            *offset = rule->offset;
+            *flags = rule->flags;
+            *next_rule = rule->next_rule;
+            ret = EOK;
+        }
     }
+    return ret;
 }
 
 /**
@@ -1185,29 +1295,33 @@ errno_t fci_fp_db_get_first_rule(char_t **rule_name, uint32_t *data, uint32_t *m
 errno_t fci_fp_db_get_next_rule(char_t **rule_name, uint32_t *data, uint32_t *mask, uint16_t *offset, pfe_ct_fp_flags_t *flags, char_t **next_rule)
 {
     fci_fp_rule_t *rule;
+    errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
     if((NULL == rule_name) || (NULL == data) || (NULL == mask) || (NULL == offset) || (NULL == flags) || (NULL == next_rule))
     {
         NXP_LOG_ERROR("NULL argument received\n");
-        return EINVAL;
-    }
-#endif
-
-    rule = fci_fp_rule_get_next(&fci_fp_rule_db, COMMON);
-    if(NULL == rule)
-    {
-        return ENOENT;
+        ret = EINVAL;
     }
     else
+#endif
     {
-        *rule_name = rule->name;
-        *data = rule->data;
-        *mask = rule->mask;
-        *offset = rule->offset;
-        *flags = rule->flags;
-        *next_rule = rule->next_rule;
-        return EOK;
+        rule = fci_fp_rule_get_next(&fci_fp_rule_db, COMMON);
+        if(NULL == rule)
+        {
+            ret = ENOENT;
+        }
+        else
+        {
+            *rule_name = rule->name;
+            *data = rule->data;
+            *mask = rule->mask;
+            *offset = rule->offset;
+            *flags = rule->flags;
+            *next_rule = rule->next_rule;
+            ret = EOK;
+        }
     }
+    return ret;
 }
 
 /**
@@ -1226,36 +1340,44 @@ errno_t fci_fp_db_get_table_first_rule(char_t *table_name, char_t **rule_name, u
 {
     fci_fp_table_t *fp_table;
     fci_fp_rule_t *rule;
+    errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
     if((NULL == table_name) || (NULL == rule_name) || (NULL == data) || (NULL == mask) || (NULL == offset) || (NULL == flags) || (NULL == next_rule))
     {
         NXP_LOG_ERROR("NULL argument received\n");
-        return EINVAL;
-    }
-#endif
-    /* Get the table */
-    fp_table = fci_fp_table_get_first(&fci_fp_table_db, FP_TABLE_CRIT_NAME, table_name);
-    if(NULL == fp_table)
-    {
-        NXP_LOG_WARNING("Table \"%s\" not found\n", table_name);
-        return ENOENT;
-    }
-    /* Get the first rule */
-    rule = fci_fp_rule_get_first(&fp_table->rules_db, FP_RULE_CRIT_ALL, NULL, TABLE);
-    if(NULL == rule)
-    {
-        return ENOENT;
+        ret = EINVAL;
     }
     else
+#endif
     {
-        *rule_name = rule->name;
-        *data = rule->data;
-        *mask = rule->mask;
-        *offset = rule->offset;
-        *flags = rule->flags;
-        *next_rule = rule->next_rule;
-        return EOK;
+        /* Get the table */
+        fp_table = fci_fp_table_get_first(&fci_fp_table_db, FP_TABLE_CRIT_NAME, table_name);
+        if(NULL == fp_table)
+        {
+            NXP_LOG_WARNING("Table \"%s\" not found\n", table_name);
+            ret = ENOENT;
+        }
+        else
+        {
+            /* Get the first rule */
+            rule = fci_fp_rule_get_first(&fp_table->rules_db, FP_RULE_CRIT_ALL, NULL, TABLE);
+            if(NULL == rule)
+            {
+                ret = ENOENT;
+            }
+            else
+            {
+                *rule_name = rule->name;
+                *data = rule->data;
+                *mask = rule->mask;
+                *offset = rule->offset;
+                *flags = rule->flags;
+                *next_rule = rule->next_rule;
+                ret = EOK;
+            }
+        }
     }
+    return ret;
 }
 
 /**
@@ -1274,36 +1396,44 @@ errno_t fci_fp_db_get_table_next_rule(char_t *table_name, char_t **rule_name, ui
 {
     fci_fp_table_t *fp_table;
     fci_fp_rule_t *rule;
+    errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
     if((NULL == table_name) || (NULL == rule_name) || (NULL == data) || (NULL == mask) || (NULL == offset) || (NULL == flags) || (NULL == next_rule))
     {
         NXP_LOG_ERROR("NULL argument received\n");
-        return EINVAL;
-    }
-#endif
-    /* Get the table */
-    fp_table = fci_fp_table_get_first(&fci_fp_table_db, FP_TABLE_CRIT_NAME, table_name);
-    if(NULL == fp_table)
-    {
-        NXP_LOG_WARNING("Table \"%s\" not found\n", table_name);
-        return ENOENT;
-    }
-    /* Get the rule */
-    rule = fci_fp_rule_get_next(&fp_table->rules_db, TABLE);
-    if(NULL == rule)
-    {
-        return ENOENT;
+        ret = EINVAL;
     }
     else
+#endif
     {
-        *rule_name = rule->name;
-        *data = rule->data;
-        *mask = rule->mask;
-        *offset = rule->offset;
-        *flags = rule->flags;
-        *next_rule = rule->next_rule;
-        return EOK;
+        /* Get the table */
+        fp_table = fci_fp_table_get_first(&fci_fp_table_db, FP_TABLE_CRIT_NAME, table_name);
+        if(NULL == fp_table)
+        {
+            NXP_LOG_WARNING("Table \"%s\" not found\n", table_name);
+            ret = ENOENT;
+        }
+        else
+        {
+            /* Get the rule */
+            rule = fci_fp_rule_get_next(&fp_table->rules_db, TABLE);
+            if(NULL == rule)
+            {
+                ret = ENOENT;
+            }
+            else
+            {
+                *rule_name = rule->name;
+                *data = rule->data;
+                *mask = rule->mask;
+                *offset = rule->offset;
+                *flags = rule->flags;
+                *next_rule = rule->next_rule;
+                ret = EOK;
+            }
+        }
     }
+    return ret;
 }
 
 /**
@@ -1422,7 +1552,7 @@ uint32_t pfe_fp_get_text_statistics(pfe_fp_t *temp, char_t *buf, uint32_t buf_le
             {
                 NXP_LOG_ERROR("Memory allocation failed\n");
                 oal_mm_free(c_stats);
-                return len;
+                break;
             }
 
             (void)memset(c_stats, 0, sizeof(pfe_ct_class_flexi_parser_stats_t) * (pfe_class_get_num_of_pes(fp_table->class) + 1U));
diff --git a/sw/fci/src/fci_fw_features.c b/sw/fci/src/fci_fw_features.c
index b41f95f..38f89cc 100644
--- a/sw/fci/src/fci_fw_features.c
+++ b/sw/fci/src/fci_fw_features.c
@@ -37,146 +37,157 @@ errno_t fci_fw_features_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_fw_features_c
 	fpp_fw_features_cmd_t *fp_cmd;
 	const char *str;
 	const char *feature_name;
-	errno_t ret = EOK;
+	errno_t ret;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)	
 	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	if (unlikely(FALSE == __context.fci_initialized))
+	else if (unlikely(FALSE == __context.fci_initialized))
 	{
 		NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-	
-	*fci_ret = FPP_ERR_OK;
-	
-	/* Important to initialize to avoid buffer overflows */
-	if (*reply_len < sizeof(fpp_fw_features_cmd_t))
-	{
-		/*	Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-		NXP_LOG_ERROR("Buffer length does not match expected value (fpp_fw_features_cmd_t)\n");
-		*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-		return EINVAL;
+		ret = EPERM;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		/*	No data written to reply buffer (yet) */
-		*reply_len = 0U;
-	}
-	(void)memset(reply_buf, 0, sizeof(fpp_fw_features_cmd_t));
-	fp_cmd = (fpp_fw_features_cmd_t *)(msg->msg_cmd.payload);
-
-	switch (fp_cmd->action)
-	{
-		case FPP_ACTION_UPDATE:
+		
+		*fci_ret = FPP_ERR_OK;
+		
+		/* Important to initialize to avoid buffer overflows */
+		if (*reply_len < sizeof(fpp_fw_features_cmd_t))
 		{
-			ret = pfe_feature_mgr_set_val(fp_cmd->name, fp_cmd->val);
-			if(EOK != ret)
-			{
-				/*	FCI command requested nonexistent entity. Respond with FCI error code. */
-				*fci_ret = FPP_ERR_FW_FEATURE_NOT_FOUND;
-				ret = EOK;
-			}
 
-			break;
+			/*	Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+			NXP_LOG_ERROR("Buffer length does not match expected value (fpp_fw_features_cmd_t)\n");
+			*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+			ret = EINVAL;
 		}
-
-		case FPP_ACTION_QUERY:
+		else
 		{
-			ret = pfe_feature_mgr_get_first(&feature_name);
-			if(ret != EOK)
-			{
-				/*	End of the query process (no more entities to report). Respond with FCI error code. */
-				*fci_ret = FPP_ERR_FW_FEATURE_NOT_FOUND;
-				ret = EOK;
-			}
-			else
+			/*	No data written to reply buffer (yet) */
+			*reply_len = 0U;
+			(void)memset(reply_buf, 0, sizeof(fpp_fw_features_cmd_t));
+			fp_cmd = (fpp_fw_features_cmd_t *)(msg->msg_cmd.payload);
+
+			switch (fp_cmd->action)
 			{
-				ret = pfe_feature_mgr_get_val(feature_name, &reply_buf->val);
-				if(EOK == ret)
+				case FPP_ACTION_UPDATE:
 				{
-					ret = pfe_feature_mgr_get_def_val(feature_name, &reply_buf->def_val);
-				}
-				if(EOK == ret)
-				{
-					ret = pfe_feature_mgr_get_variant(feature_name, &reply_buf->flags);
-				}
-				if(EOK == ret)
-				{
-					(void)strncpy(reply_buf->name, feature_name, FPP_FEATURE_NAME_SIZE);
-					ret = pfe_feature_mgr_get_desc(feature_name, &str);
-				}
+					ret = pfe_feature_mgr_set_val(fp_cmd->name, fp_cmd->val);
+					if(EOK != ret)
+					{
+						if (EFAULT == ret)
+						{
+							/*  FCI command try to change value of an ignore state feature. Respond with FCI error code. */
+							*fci_ret = FPP_ERR_FW_FEATURE_NOT_AVAILABLE;
+						}
+						else
+						{
+							/*	FCI command requested nonexistent entity. Respond with FCI error code. */
+							*fci_ret = FPP_ERR_FW_FEATURE_NOT_FOUND;
+						}
+						ret = EOK;
+					}
 
-				if(EOK == ret)
-				{
-					(void)strncpy(reply_buf->desc, str, FPP_FEATURE_DESC_SIZE);
-					*reply_len = sizeof(fpp_fw_features_cmd_t);
-					*fci_ret = FPP_ERR_OK;
-				}
-				else
-				{
-					/*	Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-					*reply_len = sizeof(fpp_fw_features_cmd_t);
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+					break;
 				}
-			}
-			break;
 
-		}
-		case FPP_ACTION_QUERY_CONT:
-		{
-			ret = pfe_feature_mgr_get_next(&feature_name);
-			if(ret != EOK)
-			{
-				/*	End of the query process (no more entities to report). Respond with FCI error code. */
-				*fci_ret = FPP_ERR_FW_FEATURE_NOT_FOUND;
-				ret = EOK;
-			}
-			else
-			{
-				ret = pfe_feature_mgr_get_val(feature_name, &reply_buf->val);
-				if(EOK == ret)
+				case FPP_ACTION_QUERY:
 				{
-					ret = pfe_feature_mgr_get_def_val(feature_name, &reply_buf->def_val);
-				}
-				if(EOK == ret)
-				{
-					ret = pfe_feature_mgr_get_variant(feature_name, &reply_buf->flags);
+					ret = pfe_feature_mgr_get_first(&feature_name);
+					if(ret != EOK)
+					{
+						/*	End of the query process (no more entities to report). Respond with FCI error code. */
+						*fci_ret = FPP_ERR_FW_FEATURE_NOT_FOUND;
+						ret = EOK;
+					}
+					else
+					{
+						ret = pfe_feature_mgr_get_val(feature_name, &reply_buf->val);
+						if(EOK == ret)
+						{
+							ret = pfe_feature_mgr_get_def_val(feature_name, &reply_buf->def_val);
+						}
+						if(EOK == ret)
+						{
+							ret = pfe_feature_mgr_get_variant(feature_name, &reply_buf->flags);
+						}
+						if(EOK == ret)
+						{
+							(void)strncpy(reply_buf->name, feature_name, FPP_FEATURE_NAME_SIZE);
+							ret = pfe_feature_mgr_get_desc(feature_name, &str);
+						}
+
+						if(EOK == ret)
+						{
+							(void)strncpy(reply_buf->desc, str, FPP_FEATURE_DESC_SIZE);
+							*reply_len = sizeof(fpp_fw_features_cmd_t);
+							*fci_ret = FPP_ERR_OK;
+						}
+						else
+						{
+							/*	Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+							*reply_len = sizeof(fpp_fw_features_cmd_t);
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+						}
+					}
+					break;
+
 				}
-				if(EOK == ret)
+				case FPP_ACTION_QUERY_CONT:
 				{
-					(void)strncpy(reply_buf->name, feature_name, FPP_FEATURE_NAME_SIZE);
-					ret = pfe_feature_mgr_get_desc(feature_name, &str);
-				}
+					ret = pfe_feature_mgr_get_next(&feature_name);
+					if(ret != EOK)
+					{
+						/*	End of the query process (no more entities to report). Respond with FCI error code. */
+						*fci_ret = FPP_ERR_FW_FEATURE_NOT_FOUND;
+						ret = EOK;
+					}
+					else
+					{
+						ret = pfe_feature_mgr_get_val(feature_name, &reply_buf->val);
+						if(EOK == ret)
+						{
+							ret = pfe_feature_mgr_get_def_val(feature_name, &reply_buf->def_val);
+						}
+						if(EOK == ret)
+						{
+							ret = pfe_feature_mgr_get_variant(feature_name, &reply_buf->flags);
+						}
+						if(EOK == ret)
+						{
+							(void)strncpy(reply_buf->name, feature_name, FPP_FEATURE_NAME_SIZE);
+							ret = pfe_feature_mgr_get_desc(feature_name, &str);
+						}
 
-				if(EOK == ret)
-				{
-					(void)strncpy(reply_buf->desc, str, FPP_FEATURE_DESC_SIZE);
-					*reply_len = sizeof(fpp_fw_features_cmd_t);
-					*fci_ret = FPP_ERR_OK;
+						if(EOK == ret)
+						{
+							(void)strncpy(reply_buf->desc, str, FPP_FEATURE_DESC_SIZE);
+							*reply_len = sizeof(fpp_fw_features_cmd_t);
+							*fci_ret = FPP_ERR_OK;
+						}
+						else
+						{
+							/*	Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+							*reply_len = sizeof(fpp_fw_features_cmd_t);
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+						}
+					}
+					break;
 				}
-				else
+
+				default:
 				{
-					/*	Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-					*reply_len = sizeof(fpp_fw_features_cmd_t);
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+					/*	Unknown action. Respond with FCI error code. */
+					NXP_LOG_ERROR("FPP_CMD_FW_FEATURE: Unknown action received: 0x%x\n", fp_cmd->action);
+					*fci_ret = FPP_ERR_UNKNOWN_ACTION;
+					ret = EOK;
+					break;
 				}
 			}
-			break;
-		}
-
-		default:
-		{
-			/*	Unknown action. Respond with FCI error code. */
-			NXP_LOG_ERROR("FPP_CMD_FW_FEATURE: Unknown action received: 0x%x\n", fp_cmd->action);
-			*fci_ret = FPP_ERR_UNKNOWN_ACTION;
-			ret = EOK;
-			break;
 		}
 	}
 
diff --git a/sw/fci/src/fci_interfaces.c b/sw/fci/src/fci_interfaces.c
index 2bffcae..0fbb06f 100644
--- a/sw/fci/src/fci_interfaces.c
+++ b/sw/fci/src/fci_interfaces.c
@@ -50,129 +50,131 @@ static errno_t fci_interfaces_get_arg_info(fpp_if_m_args_t *m_arg, pfe_ct_if_m_r
 	if (unlikely((NULL == m_arg) || (NULL == offset) || (NULL == size)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		retval = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	switch (rule)
 	{
-		case IF_MATCH_VLAN:
+		switch (rule)
 		{
-			*size = sizeof(m_arg->vlan);
-			*offset = &m_arg->vlan;
-			break;
-		}
+			case IF_MATCH_VLAN:
+			{
+				*size = sizeof(m_arg->vlan);
+				*offset = &m_arg->vlan;
+				break;
+			}
 
-		case IF_MATCH_PROTO:
-		{
-			*size = sizeof(m_arg->proto);
-			*offset = &m_arg->proto;
-			break;
-		}
+			case IF_MATCH_PROTO:
+			{
+				*size = sizeof(m_arg->proto);
+				*offset = &m_arg->proto;
+				break;
+			}
 
-		case IF_MATCH_SPORT:
-		{
-			*size = sizeof(m_arg->sport);
-			*offset = &m_arg->sport;
-			break;
-		}
+			case IF_MATCH_SPORT:
+			{
+				*size = sizeof(m_arg->sport);
+				*offset = &m_arg->sport;
+				break;
+			}
 
-		case IF_MATCH_DPORT:
-		{
-			*size = sizeof(m_arg->dport);
-			*offset = &m_arg->dport;
-			break;
-		}
+			case IF_MATCH_DPORT:
+			{
+				*size = sizeof(m_arg->dport);
+				*offset = &m_arg->dport;
+				break;
+			}
 
-		case IF_MATCH_SIP6:
-		{
-			*size = sizeof(m_arg->ipv.v6.sip);
-			*offset = &m_arg->ipv.v6.sip;
-			break;
-		}
+			case IF_MATCH_SIP6:
+			{
+				*size = sizeof(m_arg->ipv.v6.sip);
+				*offset = &m_arg->ipv.v6.sip;
+				break;
+			}
 
-		case IF_MATCH_DIP6:
-		{
-			*size = sizeof(m_arg->ipv.v6.dip);
-			*offset = &m_arg->ipv.v6.dip;
-			break;
-		}
+			case IF_MATCH_DIP6:
+			{
+				*size = sizeof(m_arg->ipv.v6.dip);
+				*offset = &m_arg->ipv.v6.dip;
+				break;
+			}
 
-		case IF_MATCH_SIP:
-		{
-			*size = sizeof(m_arg->ipv.v4.sip);
-			*offset = &m_arg->ipv.v4.sip;
-			break;
-		}
+			case IF_MATCH_SIP:
+			{
+				*size = sizeof(m_arg->ipv.v4.sip);
+				*offset = &m_arg->ipv.v4.sip;
+				break;
+			}
 
-		case IF_MATCH_DIP:
-		{
-			*size = sizeof(m_arg->ipv.v4.dip);
-			*offset = &m_arg->ipv.v4.dip;
-			break;
-		}
+			case IF_MATCH_DIP:
+			{
+				*size = sizeof(m_arg->ipv.v4.dip);
+				*offset = &m_arg->ipv.v4.dip;
+				break;
+			}
 
-		case IF_MATCH_ETHTYPE:
-		{
-			*size = sizeof(m_arg->ethtype);
-			*offset = &m_arg->ethtype;
-			break;
-		}
+			case IF_MATCH_ETHTYPE:
+			{
+				*size = sizeof(m_arg->ethtype);
+				*offset = &m_arg->ethtype;
+				break;
+			}
 
-		case IF_MATCH_FP0:
-		{
-			/* Get the table address in the HW */
-			table_addr = fci_fp_db_get_table_dmem_addr(m_arg->fp_table0);
-			*fp_table_addr = oal_htonl(table_addr);
-			if(0U == *fp_table_addr)
+			case IF_MATCH_FP0:
 			{
-				retval = ENOENT;
+				/* Get the table address in the HW */
+				table_addr = fci_fp_db_get_table_dmem_addr(m_arg->fp_table0);
+				*fp_table_addr = oal_htonl(table_addr);
+				if(0U == *fp_table_addr)
+				{
+					retval = ENOENT;
+				}
+				*offset = fp_table_addr;
+				*size = sizeof(uint32_t);
+				break;
 			}
-			*offset = fp_table_addr;
-			*size = sizeof(uint32_t);
-			break;
-		}
 
-		case IF_MATCH_FP1:
-		{
-			/* Get the table address in the HW */
-			table_addr = fci_fp_db_get_table_dmem_addr(m_arg->fp_table1);
-			*fp_table_addr = oal_htonl(table_addr);
-			if(0U == *fp_table_addr)
+			case IF_MATCH_FP1:
 			{
-				retval = ENOENT;
+				/* Get the table address in the HW */
+				table_addr = fci_fp_db_get_table_dmem_addr(m_arg->fp_table1);
+				*fp_table_addr = oal_htonl(table_addr);
+				if(0U == *fp_table_addr)
+				{
+					retval = ENOENT;
+				}
+				*offset = fp_table_addr;
+				*size = sizeof(uint32_t);
+				break;
 			}
-			*offset = fp_table_addr;
-			*size = sizeof(uint32_t);
-			break;
-		}
 
-		case IF_MATCH_SMAC:
-		{
-			*size = sizeof(m_arg->smac);
-			*offset = &m_arg->smac;
-			break;
-		}
+			case IF_MATCH_SMAC:
+			{
+				*size = sizeof(m_arg->smac);
+				*offset = &m_arg->smac;
+				break;
+			}
 
-		case IF_MATCH_DMAC:
-		{
-			*size = sizeof(m_arg->dmac);
-			*offset = &m_arg->dmac;
-			break;
-		}
+			case IF_MATCH_DMAC:
+			{
+				*size = sizeof(m_arg->dmac);
+				*offset = &m_arg->dmac;
+				break;
+			}
 
-		case IF_MATCH_HIF_COOKIE:
-		{
-			*size = sizeof(m_arg->hif_cookie);
-			*offset = &m_arg->hif_cookie;
-			break;
-		}
+			case IF_MATCH_HIF_COOKIE:
+			{
+				*size = sizeof(m_arg->hif_cookie);
+				*offset = &m_arg->hif_cookie;
+				break;
+			}
 
-		default:
-		{
-			*size = 0U;
-			*offset = NULL;
-			break;
+			default:
+			{
+				*size = 0U;
+				*offset = NULL;
+				break;
+			}
 		}
 	}
 	return retval;
@@ -187,34 +189,37 @@ static errno_t fci_interfaces_get_arg_info(fpp_if_m_args_t *m_arg, pfe_ct_if_m_r
  */
 static errno_t fci_interfaces_destroy_fptables(const fpp_if_m_rules_t match, const pfe_ct_if_m_args_t* args)
 {
+	errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (NULL == args)
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		char_t *table_name = NULL;
 
-	char_t *table_name = NULL;
-
-	if((uint32_t)FPP_IF_MATCH_FP0 == ((uint32_t)match & (uint32_t)FPP_IF_MATCH_FP0))
-	{	/* A flexible parser table was dropped - it needs to be destroyed if it existed */
-		if(0U != args->fp0_table)
-		{	/* Table existed */
-			(void)fci_fp_db_get_table_from_addr(args->fp0_table, &table_name);
-			(void)fci_fp_db_pop_table_from_hw(table_name);
+		if((uint32_t)FPP_IF_MATCH_FP0 == ((uint32_t)match & (uint32_t)FPP_IF_MATCH_FP0))
+		{	/* A flexible parser table was dropped - it needs to be destroyed if it existed */
+			if(0U != args->fp0_table)
+			{	/* Table existed */
+				(void)fci_fp_db_get_table_from_addr(args->fp0_table, &table_name);
+				(void)fci_fp_db_pop_table_from_hw(table_name);
+			}
 		}
-	}
-	if((uint32_t)FPP_IF_MATCH_FP1 == ((uint32_t)match & (uint32_t)FPP_IF_MATCH_FP1))
-	{	/* A flexible parser table was dropped - it needs to be destroyed if it existed */
-		if(0U != args->fp1_table)
-		{	/* Table existed */
-			(void)fci_fp_db_get_table_from_addr(args->fp1_table, &table_name);
-			(void)fci_fp_db_pop_table_from_hw(table_name);
+		if((uint32_t)FPP_IF_MATCH_FP1 == ((uint32_t)match & (uint32_t)FPP_IF_MATCH_FP1))
+		{	/* A flexible parser table was dropped - it needs to be destroyed if it existed */
+			if(0U != args->fp1_table)
+			{	/* Table existed */
+				(void)fci_fp_db_get_table_from_addr(args->fp1_table, &table_name);
+				(void)fci_fp_db_pop_table_from_hw(table_name);
+			}
 		}
+		ret = EOK;
 	}
-
-	return EOK;
+	return ret;
 }
 
 /**
@@ -232,37 +237,39 @@ errno_t fci_interfaces_session_cmd(uint32_t code, uint16_t *fci_ret)
 	if (unlikely(NULL == fci_ret))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	switch(code)
 	{
-		case FPP_CMD_IF_LOCK_SESSION:
+		switch(code)
 		{
-			*fci_ret = FPP_ERR_OK;
-			if (EOK != pfe_if_db_lock(&fci_context->if_session_id))
+			case FPP_CMD_IF_LOCK_SESSION:
 			{
-				*fci_ret = FPP_ERR_IF_RESOURCE_ALREADY_LOCKED;
-				NXP_LOG_DEBUG("DB lock failed\n");
+				*fci_ret = FPP_ERR_OK;
+				if (EOK != pfe_if_db_lock(&fci_context->if_session_id))
+				{
+					*fci_ret = FPP_ERR_IF_RESOURCE_ALREADY_LOCKED;
+					NXP_LOG_DEBUG("DB lock failed\n");
+				}
+				break;
 			}
-			break;
-		}
-		case FPP_CMD_IF_UNLOCK_SESSION:
-		{
-			*fci_ret = FPP_ERR_OK;
-			if (EOK != pfe_if_db_unlock(fci_context->if_session_id))
+			case FPP_CMD_IF_UNLOCK_SESSION:
+			{
+				*fci_ret = FPP_ERR_OK;
+				if (EOK != pfe_if_db_unlock(fci_context->if_session_id))
+				{
+					*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
+					NXP_LOG_DEBUG("DB unlock failed due to incorrect session ID\n");
+				}
+				break;
+			}
+			default:
 			{
-				*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
-				NXP_LOG_DEBUG("DB unlock failed due to incorrect session ID\n");
+				NXP_LOG_ERROR("Unknown Interface Session Command Received\n");
+				*fci_ret = FPP_ERR_UNKNOWN_ACTION;
+				break;
 			}
-			break;
-		}
-		default:
-		{
-			NXP_LOG_ERROR("Unknown Interface Session Command Received\n");
-			*fci_ret = FPP_ERR_UNKNOWN_ACTION;
-			break;
 		}
 	}
 	return ret;
@@ -300,576 +307,576 @@ errno_t fci_interfaces_log_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_log_if_cmd
 	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	if (unlikely(FALSE == fci_context->fci_initialized))
+	else if (unlikely(FALSE == fci_context->fci_initialized))
 	{
 		NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (*reply_len < sizeof(fpp_log_if_cmd_t))
-	{
-		NXP_LOG_ERROR("Buffer length does not match expected value (fpp_if_cmd_t)\n");
-		return EINVAL;
+		ret = EPERM;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		/*	No data written to reply buffer (yet) */
-		*reply_len = 0U;
-	}
-
-	/*	Initialize the reply buffer */
-	(void)memset(reply_buf, 0, sizeof(fpp_log_if_cmd_t));
-
-	if_cmd = (fpp_log_if_cmd_t *)msg->msg_cmd.payload;
-
-	switch(if_cmd->action)
-	{
-		case FPP_ACTION_REGISTER:
+		if (*reply_len < sizeof(fpp_log_if_cmd_t))
 		{
-			/* Get the intended parent physical interface */
-			ret = pfe_if_db_get_first(fci_context->phy_if_db, fci_context->if_session_id, IF_DB_CRIT_BY_NAME, if_cmd->parent_name, &entry);
-			if(EOK != ret)
-			{
-				*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-				break;
-			}
-			phy_if = pfe_if_db_entry_get_phy_if(entry);
-			if(NULL == phy_if)
-			{
-				*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-				ret = ENOENT;
-				break;
-			}
-			/* Create the logical interface */
-			log_if = pfe_log_if_create(phy_if, if_cmd->name);
-			if(NULL == log_if)
-			{
-				*fci_ret = FPP_ERR_IF_OP_CANNOT_CREATE;
-				ret = ENOENT;
-				break;
-			}
-			/* Add the interface into the database */
-			ret = pfe_if_db_add(fci_context->log_if_db, fci_context->if_session_id, log_if, pfe_phy_if_get_id(phy_if));
-			if(EOK != ret)
-			{
-				pfe_log_if_destroy(log_if);
-				*fci_ret = FPP_ERR_IF_OP_CANNOT_CREATE;
-				break;
-			}
-			NXP_LOG_INFO("Added logical interface %s to physical interface %s\n", if_cmd->name, if_cmd->parent_name);
-			break;
-		}
-
-		case FPP_ACTION_DEREGISTER:
-		{
-			ret = pfe_if_db_get_first(fci_context->log_if_db, fci_context->if_session_id, IF_DB_CRIT_BY_NAME, if_cmd->name, &entry);
-
-			if(EOK != ret)
-			{
-				NXP_LOG_ERROR("Incorrect session ID detected\n");
-				*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
-				break;
-			}
-
-			/* Check if entry is not NULL and get logical interface */
-			if(NULL != entry)
-			{
-				log_if = pfe_if_db_entry_get_log_if(entry);
-			}
-
-			/* Check if the entry exists */
-			if((NULL == entry) || (NULL == log_if))
-			{
-				/* Interface doesn't exist or couldn't be extracted from the entry */
-				*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-				ret = ENOENT;
-				break;
-			}
-
-			/* Destroy FP tables if they were used by this interface. */
-			if(EOK == pfe_log_if_get_match_rules(log_if, &rules, &args))
-			{
-				/* Fix endians of FP tables */
-				args.fp0_table = oal_ntohl(args.fp0_table);
-				args.fp1_table = oal_ntohl(args.fp1_table);
-
-				/* Destroy FP tables */
-				(void)fci_interfaces_destroy_fptables((fpp_if_m_rules_t)rules, &args);
-			}
-
-			/* Remove interface from the database */
-			(void)pfe_if_db_remove(fci_context->log_if_db, fci_context->if_session_id, entry);
-			/* Destroy the interface */
-			pfe_log_if_destroy(log_if);
-			break;
+			NXP_LOG_ERROR("Buffer length does not match expected value (fpp_if_cmd_t)\n");
+			ret = EINVAL;
 		}
-
-		case FPP_ACTION_UPDATE:
+		else
 		{
-			*fci_ret = FPP_ERR_OK;
-			*reply_len = sizeof(fpp_log_if_cmd_t);
-
-			ret = pfe_if_db_get_first(fci_context->log_if_db, fci_context->if_session_id, IF_DB_CRIT_BY_NAME, if_cmd->name, &entry);
-
-			if(EOK != ret)
-			{
-				NXP_LOG_ERROR("Incorrect session ID detected\n");
-				*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
-				break;
-			}
-
-			/* Check if entry is not NULL and get logical interface */
-			if(NULL != entry)
-			{
-				log_if = pfe_if_db_entry_get_log_if(entry);
-			}
-
-			/* Check if the entry exists */
-			if((NULL == entry) || (NULL == log_if))
-			{
-				/* Interface doesn't exist or couldn't be extracted from the entry */
-				*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-				break;
-			}
-
-			/* Get the currently set rules */
-			ret = pfe_log_if_get_match_rules(log_if, &rules, &args);
-			if(ret != EOK)
-			{
-				*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-				break;
-			}
+			/*	No data written to reply buffer (yet) */
+			*reply_len = 0U;
+			/*	Initialize the reply buffer */
+			(void)memset(reply_buf, 0, sizeof(fpp_log_if_cmd_t));
 
-			/* Fix endians of FP tables */
-			args.fp0_table = oal_ntohl(args.fp0_table);
-			args.fp1_table = oal_ntohl(args.fp1_table);
+			if_cmd = (fpp_log_if_cmd_t *)msg->msg_cmd.payload;
 
-			rules = (pfe_ct_if_m_rules_t)(~oal_ntohl(if_cmd->match));
-
-			/* Drop all unset rules (if any) */
-			ret = pfe_log_if_del_match_rule(log_if, rules);
-
-			/* Destroy FP tables if they are not used by new rules */
-			(void)fci_interfaces_destroy_fptables((fpp_if_m_rules_t)rules, &args);
-
-			if(EOK == ret)
-			{
-				NXP_LOG_INFO("All match rules were dropped on %s before match rule update.\n",  pfe_log_if_get_name(log_if));
-			}
-			else
-			{
-				NXP_LOG_ERROR("Dropping of all match rules on logical interface %s failed !!\n",  pfe_log_if_get_name(log_if));
-				*fci_ret = FPP_ERR_IF_MATCH_UPDATE_FAILED;
-			}
-			/* Clear the storage for queues to be destroyed */
-			fp_table_destroy[0] = 0U;
-			fp_table_destroy[1] = 0U;
-			/* We are going to configure Flexible parser - prepare table(s) */
-			if((uint32_t)FPP_IF_MATCH_FP0 == (oal_ntohl(if_cmd->match) & (uint32_t)FPP_IF_MATCH_FP0))
+			switch(if_cmd->action)
 			{
-				/* Get the newly configured table address */
-				fp_table_addr = fci_fp_db_get_table_dmem_addr(if_cmd->arguments.fp_table0);
-				if(0U == fp_table_addr)
-				{   /* Table has not been created yet */
-					ret = fci_fp_db_push_table_to_hw(fci_context->class, if_cmd->arguments.fp_table0);
+				case FPP_ACTION_REGISTER:
+				{
+					/* Get the intended parent physical interface */
+					ret = pfe_if_db_get_first(fci_context->phy_if_db, fci_context->if_session_id, IF_DB_CRIT_BY_NAME, if_cmd->parent_name, &entry);
 					if(EOK != ret)
-					{   /* Failed to write */
-						*fci_ret = FPP_ERR_IF_MATCH_UPDATE_FAILED;
+					{
+						*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
 						break;
 					}
-					/* We have just created the table therefore the existing one must be different
-					   and it needs to be destroyed before we overwrite the reference */
-					if(0U != args.fp0_table)
+					phy_if = pfe_if_db_entry_get_phy_if(entry);
+					if(NULL == phy_if)
 					{
-						/* Table is still in use therefore it cannot be destroyed,
-						   just remember it */
-						fp_table_destroy[0] = args.fp0_table;
+						*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
+						ret = ENOENT;
+						break;
 					}
-				}
-				else
-				{   /* Table does exist */
-					/* Check whether it is already configured */
-					if(fp_table_addr != args.fp0_table)
-					{   /* Different table is configured thus the new one must be in use
-						   somewhere else (because it does have the address) and cannot be
-						   used here */
-						NXP_LOG_ERROR("Table %s already in use.\n", if_cmd->arguments.fp_table0);
-						*fci_ret = FPP_ERR_IF_MATCH_UPDATE_FAILED;
+					/* Create the logical interface */
+					log_if = pfe_log_if_create(phy_if, if_cmd->name);
+					if(NULL == log_if)
+					{
+						*fci_ret = FPP_ERR_IF_OP_CANNOT_CREATE;
+						ret = ENOENT;
 						break;
 					}
-
-				}
-			}
-			if((uint32_t)FPP_IF_MATCH_FP1 == (oal_ntohl(if_cmd->match) & (uint32_t)FPP_IF_MATCH_FP1))
-			{
-				/* Get the newly configured table address */
-				fp_table_addr = fci_fp_db_get_table_dmem_addr(if_cmd->arguments.fp_table1);
-				if(0U == fp_table_addr)
-				{   /* Table has not been created yet */
-					ret = fci_fp_db_push_table_to_hw(fci_context->class, if_cmd->arguments.fp_table1);
+					/* Add the interface into the database */
+					ret = pfe_if_db_add(fci_context->log_if_db, fci_context->if_session_id, log_if, pfe_phy_if_get_id(phy_if));
 					if(EOK != ret)
-					{   /* Failed to write */
-						*fci_ret = FPP_ERR_IF_MATCH_UPDATE_FAILED;
+					{
+						pfe_log_if_destroy(log_if);
+						*fci_ret = FPP_ERR_IF_OP_CANNOT_CREATE;
 						break;
 					}
-					/* We have just created the table therefore the existing one must be different
-					   and it needs to be destroyed before we overwrite the reference */
-					if(0U != args.fp1_table)
+					NXP_LOG_INFO("Added logical interface %s to physical interface %s\n", if_cmd->name, if_cmd->parent_name);
+					break;
+				}
+
+				case FPP_ACTION_DEREGISTER:
+				{
+					ret = pfe_if_db_get_first(fci_context->log_if_db, fci_context->if_session_id, IF_DB_CRIT_BY_NAME, if_cmd->name, &entry);
+
+					if(EOK != ret)
 					{
-						/* Table is still in use therefore it cannot be destroyed,
-						   just remember it */
-						*fci_ret = FPP_ERR_IF_MATCH_UPDATE_FAILED;
+						NXP_LOG_ERROR("Incorrect session ID detected\n");
+						*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
 						break;
 					}
-				}
-				else
-				{   /* Table does exist */
-					/* Check whether it is already configured */
-					if(fp_table_addr != args.fp1_table)
-					{   /* Different table is configured thus the new one must be in use
-						   somewhere else (because it does have the address) and cannot be
-						   used here */
-						NXP_LOG_ERROR("Table %s already in use.\n", if_cmd->arguments.fp_table1);
-						*fci_ret = FPP_ERR_IF_MATCH_UPDATE_FAILED;
+
+					/* Check if entry is not NULL and get logical interface */
+					if(NULL != entry)
+					{
+						log_if = pfe_if_db_entry_get_log_if(entry);
+					}
+
+					/* Check if the entry exists */
+					if((NULL == entry) || (NULL == log_if))
+					{
+						/* Interface doesn't exist or couldn't be extracted from the entry */
+						*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
+						ret = ENOENT;
 						break;
 					}
 
+					/* Destroy FP tables if they were used by this interface. */
+					if(EOK == pfe_log_if_get_match_rules(log_if, &rules, &args))
+					{
+						/* Fix endians of FP tables */
+						args.fp0_table = oal_ntohl(args.fp0_table);
+						args.fp1_table = oal_ntohl(args.fp1_table);
+
+						/* Destroy FP tables */
+						(void)fci_interfaces_destroy_fptables((fpp_if_m_rules_t)rules, &args);
+					}
+
+					/* Remove interface from the database */
+					(void)pfe_if_db_remove(fci_context->log_if_db, fci_context->if_session_id, entry);
+					/* Destroy the interface */
+					pfe_log_if_destroy(log_if);
+					break;
 				}
-			}
 
-			/* Update each rule one by one */
-			for(index = 0U; (8U * sizeof(if_cmd->match)) > index;  ++index)
-			{
-				if(0U != (oal_ntohl(if_cmd->match) & (1U << index)))
+				case FPP_ACTION_UPDATE:
 				{
-					/* Resolve position of data and size */
-					ret = fci_interfaces_get_arg_info(&if_cmd->arguments, (pfe_ct_if_m_rules_t)(oal_ntohl(if_cmd->match) & (1U << index)), &offset, &size, &fp_table_addr);
+					*fci_ret = FPP_ERR_OK;
+					*reply_len = sizeof(fpp_log_if_cmd_t);
+
+					ret = pfe_if_db_get_first(fci_context->log_if_db, fci_context->if_session_id, IF_DB_CRIT_BY_NAME, if_cmd->name, &entry);
+
 					if(EOK != ret)
 					{
-						NXP_LOG_ERROR("Failed to get update argument\n");
-						*fci_ret = FPP_ERR_IF_MATCH_UPDATE_FAILED;
+						NXP_LOG_ERROR("Incorrect session ID detected\n");
+						*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
+						break;
 					}
 
-					/* Add match rule and arguments */
-					ret = pfe_log_if_add_match_rule(log_if, (pfe_ct_if_m_rules_t)(oal_ntohl(if_cmd->match) & (1U << index)), offset, size);
+					/* Check if entry is not NULL and get logical interface */
+					if(NULL != entry)
+					{
+						log_if = pfe_if_db_entry_get_log_if(entry);
+					}
 
-					if(EOK != ret)
+					/* Check if the entry exists */
+					if((NULL == entry) || (NULL == log_if))
 					{
-						NXP_LOG_ERROR("Updating single rule on logical interface %s failed !!\n",  pfe_log_if_get_name(log_if));
-						*fci_ret = FPP_ERR_IF_MATCH_UPDATE_FAILED;
+						/* Interface doesn't exist or couldn't be extracted from the entry */
+						*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
+						break;
 					}
-				}
-			}
 
-			/* Now is the time to destroy Flexible Parser tables no longer in use */
-			if(0U != fp_table_destroy[0])
-			{
-				(void)fci_fp_db_get_table_from_addr(fp_table_destroy[0], &table_name);
-				(void)fci_fp_db_pop_table_from_hw(table_name);
-			}
-			if(0U != fp_table_destroy[1])
-			{
-				(void)fci_fp_db_get_table_from_addr(fp_table_destroy[1], &table_name);
-				(void)fci_fp_db_pop_table_from_hw(table_name);
-			}
+					/* Get the currently set rules */
+					ret = pfe_log_if_get_match_rules(log_if, &rules, &args);
+					if(ret != EOK)
+					{
+						*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
+						break;
+					}
 
-			/* Update egress in case at least one is set (old egress is dropped) */
-			if(0U != if_cmd->egress)
-			{
-				NXP_LOG_INFO("Updating egress interfaces on %s (0x%x)\n",  pfe_log_if_get_name(log_if), (uint_t)oal_ntohl(if_cmd->egress));
-				for(index = 0U; (uint32_t)PFE_PHY_IF_ID_INVALID > index;  ++index)
-				{
+					/* Fix endians of FP tables */
+					args.fp0_table = oal_ntohl(args.fp0_table);
+					args.fp1_table = oal_ntohl(args.fp1_table);
+
+					rules = (pfe_ct_if_m_rules_t)(~oal_ntohl(if_cmd->match));
+
+					/* Drop all unset rules (if any) */
+					ret = pfe_log_if_del_match_rule(log_if, rules);
+
+					/* Destroy FP tables if they are not used by new rules */
+					(void)fci_interfaces_destroy_fptables((fpp_if_m_rules_t)rules, &args);
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-					if((uint32_t)PFE_PHY_IF_ID_HIF == index)
+					if(EOK == ret)
 					{
-						/* Skip currently not used interfaces */
-						continue;
+						NXP_LOG_INFO("All match rules were dropped on %s before match rule update.\n",  pfe_log_if_get_name(log_if));
 					}
-#else
-					if(((uint32_t)PFE_PHY_IF_ID_HIF == index) || ((uint32_t)PFE_PHY_IF_ID_HIF_NOCPY == index))
+					else
 					{
-						/* Skip currently not used interfaces */
-						continue;
+						NXP_LOG_ERROR("Dropping of all match rules on logical interface %s failed !!\n",  pfe_log_if_get_name(log_if));
+						*fci_ret = FPP_ERR_IF_MATCH_UPDATE_FAILED;
 					}
-#endif
-
-					/* For each bit in egress mask search if the phy if exists */
-					ret = pfe_if_db_get_first(fci_context->phy_if_db, fci_context->if_session_id, IF_DB_CRIT_BY_ID, (void *)(addr_t)index, &entry);
-					if((EOK == ret) && (NULL != entry))
-					{   /* phy if does exist */
-						phy_if = pfe_if_db_entry_get_phy_if(entry);
-
-						/* Check whether the phy if shall be added
-						   We are getting inputs in network order thus conversion is needed */
-						if(0U != (oal_ntohl(if_cmd->egress) & (1U << index)))
-						{   /* Add */
-							/* If the ID exits add corresponding phy_if as egress to log_if*/
-							if (EOK != pfe_log_if_add_egress_if(log_if, phy_if))
+					/* Clear the storage for queues to be destroyed */
+					fp_table_destroy[0] = 0U;
+					fp_table_destroy[1] = 0U;
+					/* We are going to configure Flexible parser - prepare table(s) */
+					if((uint32_t)FPP_IF_MATCH_FP0 == (oal_ntohl(if_cmd->match) & (uint32_t)FPP_IF_MATCH_FP0))
+					{
+						/* Get the newly configured table address */
+						fp_table_addr = fci_fp_db_get_table_dmem_addr(if_cmd->arguments.fp_table0);
+						if(0U == fp_table_addr)
+						{   /* Table has not been created yet */
+							ret = fci_fp_db_push_table_to_hw(fci_context->class, if_cmd->arguments.fp_table0);
+							if(EOK != ret)
+							{   /* Failed to write */
+								*fci_ret = FPP_ERR_IF_MATCH_UPDATE_FAILED;
+								break;
+							}
+							/* We have just created the table therefore the existing one must be different
+							and it needs to be destroyed before we overwrite the reference */
+							if(0U != args.fp0_table)
 							{
-								NXP_LOG_ERROR("Could not set egress interface for %s\n", pfe_log_if_get_name(log_if));
-								*fci_ret = FPP_ERR_IF_EGRESS_UPDATE_FAILED;
+								/* Table is still in use therefore it cannot be destroyed,
+								just remember it */
+								fp_table_destroy[0] = args.fp0_table;
 							}
 						}
 						else
-						{   /* Do not add (drop from the list if already on the list) */
-							/* Get current egress interfaces */
-							ret = pfe_log_if_get_egress_ifs(log_if, &egress);
-							if(EOK == ret)
-							{
-								if(0U != (egress & ((uint32_t)1U << index)))
-								{   /* Interface is on the current list but not on the requested list - drop it */
-									ret = pfe_log_if_del_egress_if(log_if, phy_if);
-								}
+						{   /* Table does exist */
+							/* Check whether it is already configured */
+							if(fp_table_addr != args.fp0_table)
+							{   /* Different table is configured thus the new one must be in use
+								somewhere else (because it does have the address) and cannot be
+								used here */
+								NXP_LOG_ERROR("Table %s already in use.\n", if_cmd->arguments.fp_table0);
+								*fci_ret = FPP_ERR_IF_MATCH_UPDATE_FAILED;
+								break;
 							}
 
-							if (EOK != ret)
-							{
-								NXP_LOG_ERROR("Could not get and clear egress interface for %s\n", pfe_log_if_get_name(log_if));
-								*fci_ret = FPP_ERR_IF_EGRESS_UPDATE_FAILED;
-							}
 						}
 					}
-					else
+					if((uint32_t)FPP_IF_MATCH_FP1 == (oal_ntohl(if_cmd->match) & (uint32_t)FPP_IF_MATCH_FP1))
 					{
-						NXP_LOG_ERROR("Egress %u on %s is not set because it doesn't exist\n", (uint_t)index,  pfe_log_if_get_name(log_if));
+						/* Get the newly configured table address */
+						fp_table_addr = fci_fp_db_get_table_dmem_addr(if_cmd->arguments.fp_table1);
+						if(0U == fp_table_addr)
+						{   /* Table has not been created yet */
+							ret = fci_fp_db_push_table_to_hw(fci_context->class, if_cmd->arguments.fp_table1);
+							if(EOK != ret)
+							{   /* Failed to write */
+								*fci_ret = FPP_ERR_IF_MATCH_UPDATE_FAILED;
+								break;
+							}
+							/* We have just created the table therefore the existing one must be different
+							and it needs to be destroyed before we overwrite the reference */
+							if(0U != args.fp1_table)
+							{
+								/* Table is still in use therefore it cannot be destroyed,
+								just remember it */
+								*fci_ret = FPP_ERR_IF_MATCH_UPDATE_FAILED;
+								break;
+							}
+						}
+						else
+						{   /* Table does exist */
+							/* Check whether it is already configured */
+							if(fp_table_addr != args.fp1_table)
+							{   /* Different table is configured thus the new one must be in use
+								somewhere else (because it does have the address) and cannot be
+								used here */
+								NXP_LOG_ERROR("Table %s already in use.\n", if_cmd->arguments.fp_table1);
+								*fci_ret = FPP_ERR_IF_MATCH_UPDATE_FAILED;
+								break;
+							}
 
-						/* Error in input do not continue */
-						*fci_ret = FPP_ERR_IF_EGRESS_DOESNT_EXIST;
+						}
 					}
-				}
-			}
 
-			/* AND/OR rules */
-			if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_MATCH_OR))
-			{
-				ret = pfe_log_if_set_match_or(log_if);
-			}
-			else
-			{
-				ret = pfe_log_if_set_match_and(log_if);
-			}
+					/* Update each rule one by one */
+					for(index = 0U; (8U * sizeof(if_cmd->match)) > index;  ++index)
+					{
+						if(0U != (oal_ntohl(if_cmd->match) & (1U << index)))
+						{
+							/* Resolve position of data and size */
+							ret = fci_interfaces_get_arg_info(&if_cmd->arguments, (pfe_ct_if_m_rules_t)(oal_ntohl(if_cmd->match) & (1U << index)), &offset, &size, &fp_table_addr);
+							if(EOK != ret)
+							{
+								NXP_LOG_ERROR("Failed to get update argument\n");
+								*fci_ret = FPP_ERR_IF_MATCH_UPDATE_FAILED;
+							}
 
-			if(EOK != ret)
-			{
-				NXP_LOG_ERROR("AND/OR flag wasn't updated correctly on %s\n",  pfe_log_if_get_name(log_if));
-				*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
-			}
+							/* Add match rule and arguments */
+							ret = pfe_log_if_add_match_rule(log_if, (pfe_ct_if_m_rules_t)(oal_ntohl(if_cmd->match) & (1U << index)), offset, size);
 
-			/* enable/disable */
-			if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_ENABLED))
-			{
-				ret = pfe_log_if_enable(log_if);
-			}
-			else
-			{
-				ret = pfe_log_if_disable(log_if);
-			}
+							if(EOK != ret)
+							{
+								NXP_LOG_ERROR("Updating single rule on logical interface %s failed !!\n",  pfe_log_if_get_name(log_if));
+								*fci_ret = FPP_ERR_IF_MATCH_UPDATE_FAILED;
+							}
+						}
+					}
 
-			if(EOK != ret)
-			{
-				NXP_LOG_ERROR("ENABLE flag wasn't updated correctly on %s\n",  pfe_log_if_get_name(log_if));
-				*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
-			}
+					/* Now is the time to destroy Flexible Parser tables no longer in use */
+					if(0U != fp_table_destroy[0])
+					{
+						(void)fci_fp_db_get_table_from_addr(fp_table_destroy[0], &table_name);
+						(void)fci_fp_db_pop_table_from_hw(table_name);
+					}
+					if(0U != fp_table_destroy[1])
+					{
+						(void)fci_fp_db_get_table_from_addr(fp_table_destroy[1], &table_name);
+						(void)fci_fp_db_pop_table_from_hw(table_name);
+					}
 
-			/* loopback */
-			if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_LOOPBACK))
-			{
-				ret = pfe_log_if_loopback_enable(log_if);
-			}
-			else
-			{
-				ret = pfe_log_if_loopback_disable(log_if);
-			}
+					/* Update egress in case at least one is set (old egress is dropped) */
+					if(0U != if_cmd->egress)
+					{
+						NXP_LOG_INFO("Updating egress interfaces on %s (0x%x)\n",  pfe_log_if_get_name(log_if), (uint_t)oal_ntohl(if_cmd->egress));
+						for(index = 0U; (uint32_t)PFE_PHY_IF_ID_INVALID > index;  ++index)
+						{
 
-			if(EOK != ret)
-			{
-				NXP_LOG_ERROR("ENABLE flag wasn't updated correctly on %s\n",  pfe_log_if_get_name(log_if));
-				*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
-			}
+		#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
+							if((uint32_t)PFE_PHY_IF_ID_HIF == index)
+							{
+								/* Skip currently not used interfaces */
+								continue;
+							}
+		#else
+							if(((uint32_t)PFE_PHY_IF_ID_HIF == index) || ((uint32_t)PFE_PHY_IF_ID_HIF_NOCPY == index))
+							{
+								/* Skip currently not used interfaces */
+								continue;
+							}
+		#endif
+
+							/* For each bit in egress mask search if the phy if exists */
+							ret = pfe_if_db_get_first(fci_context->phy_if_db, fci_context->if_session_id, IF_DB_CRIT_BY_ID, (void *)(addr_t)index, &entry);
+							if((EOK == ret) && (NULL != entry))
+							{   /* phy if does exist */
+								phy_if = pfe_if_db_entry_get_phy_if(entry);
+
+								/* Check whether the phy if shall be added
+								We are getting inputs in network order thus conversion is needed */
+								if(0U != (oal_ntohl(if_cmd->egress) & (1U << index)))
+								{   /* Add */
+									/* If the ID exits add corresponding phy_if as egress to log_if*/
+									if (EOK != pfe_log_if_add_egress_if(log_if, phy_if))
+									{
+										NXP_LOG_ERROR("Could not set egress interface for %s\n", pfe_log_if_get_name(log_if));
+										*fci_ret = FPP_ERR_IF_EGRESS_UPDATE_FAILED;
+									}
+								}
+								else
+								{   /* Do not add (drop from the list if already on the list) */
+									/* Get current egress interfaces */
+									ret = pfe_log_if_get_egress_ifs(log_if, &egress);
+									if(EOK == ret)
+									{
+										if(0U != (egress & ((uint32_t)1U << index)))
+										{   /* Interface is on the current list but not on the requested list - drop it */
+											ret = pfe_log_if_del_egress_if(log_if, phy_if);
+										}
+									}
+
+									if (EOK != ret)
+									{
+										NXP_LOG_ERROR("Could not get and clear egress interface for %s\n", pfe_log_if_get_name(log_if));
+										*fci_ret = FPP_ERR_IF_EGRESS_UPDATE_FAILED;
+									}
+								}
+							}
+							else
+							{
+								NXP_LOG_ERROR("Egress %u on %s is not set because it doesn't exist\n", (uint_t)index,  pfe_log_if_get_name(log_if));
 
-			/* promisc */
-			if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_PROMISC))
-			{
-				ret = pfe_log_if_promisc_enable(log_if);
-			}
-			else
-			{
-				ret = pfe_log_if_promisc_disable(log_if);
-			}
+								/* Error in input do not continue */
+								*fci_ret = FPP_ERR_IF_EGRESS_DOESNT_EXIST;
+							}
+						}
+					}
 
-			if(EOK != ret)
-			{
-				NXP_LOG_ERROR("PROMISC flag wasn't updated correctly on %s\n",  pfe_log_if_get_name(log_if));
-				*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
-			}
+					/* AND/OR rules */
+					if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_MATCH_OR))
+					{
+						ret = pfe_log_if_set_match_or(log_if);
+					}
+					else
+					{
+						ret = pfe_log_if_set_match_and(log_if);
+					}
 
-			/* discard */
-			if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_DISCARD))
-			{
-				ret = pfe_log_if_discard_enable(log_if);
-			}
-			else
-			{
-				ret = pfe_log_if_discard_disable(log_if);
-			}
+					if(EOK != ret)
+					{
+						NXP_LOG_ERROR("AND/OR flag wasn't updated correctly on %s\n",  pfe_log_if_get_name(log_if));
+						*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
+					}
 
-			if(EOK != ret)
-			{
-				NXP_LOG_ERROR("DISCARD flag wasn't updated correctly on %s\n",  pfe_log_if_get_name(log_if));
-				*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
-			}
+					/* enable/disable */
+					if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_ENABLED))
+					{
+						ret = pfe_log_if_enable(log_if);
+					}
+					else
+					{
+						ret = pfe_log_if_disable(log_if);
+					}
 
-			break;
-		}
-		case FPP_ACTION_QUERY:
-		{
-			ret = pfe_if_db_get_first(fci_context->log_if_db, fci_context->if_session_id, IF_DB_CRIT_ALL, NULL, &entry);
-			if (NULL == entry)
-			{
-				*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-				if(EOK != ret)
-				{
-					NXP_LOG_ERROR("Incorrect session ID detected\n");
-					*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
-				}
-				ret = EOK;
-				break;
-			}
-		}
-		/* FALLTHRU */
-		case FPP_ACTION_QUERY_CONT:
-		{
-			if (NULL == entry)
-			{
-				ret = pfe_if_db_get_next(fci_context->log_if_db, fci_context->if_session_id, &entry);
-				if (NULL == entry)
-				{
-					*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
 					if(EOK != ret)
 					{
-						NXP_LOG_ERROR("Incorrect session ID detected\n");
-						*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
+						NXP_LOG_ERROR("ENABLE flag wasn't updated correctly on %s\n",  pfe_log_if_get_name(log_if));
+						*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
 					}
-					ret = EOK;
+
+					/* loopback */
+					if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_LOOPBACK))
+					{
+						ret = pfe_log_if_loopback_enable(log_if);
+					}
+					else
+					{
+						ret = pfe_log_if_loopback_disable(log_if);
+					}
+
+					if(EOK != ret)
+					{
+						NXP_LOG_ERROR("ENABLE flag wasn't updated correctly on %s\n",  pfe_log_if_get_name(log_if));
+						*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
+					}
+
+					/* promisc */
+					if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_PROMISC))
+					{
+						ret = pfe_log_if_promisc_enable(log_if);
+					}
+					else
+					{
+						ret = pfe_log_if_promisc_disable(log_if);
+					}
+
+					if(EOK != ret)
+					{
+						NXP_LOG_ERROR("PROMISC flag wasn't updated correctly on %s\n",  pfe_log_if_get_name(log_if));
+						*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
+					}
+
+					/* discard */
+					if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_DISCARD))
+					{
+						ret = pfe_log_if_discard_enable(log_if);
+					}
+					else
+					{
+						ret = pfe_log_if_discard_disable(log_if);
+					}
+
+					if(EOK != ret)
+					{
+						NXP_LOG_ERROR("DISCARD flag wasn't updated correctly on %s\n",  pfe_log_if_get_name(log_if));
+						*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
+					}
+
 					break;
 				}
-			}
+				case FPP_ACTION_QUERY:
+				{
+					ret = pfe_if_db_get_first(fci_context->log_if_db, fci_context->if_session_id, IF_DB_CRIT_ALL, NULL, &entry);
+					if (NULL == entry)
+					{
+						*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
+						if(EOK != ret)
+						{
+							NXP_LOG_ERROR("Incorrect session ID detected\n");
+							*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
+						}
+						ret = EOK;
+						break;
+					}
+				}
+				/* FALLTHRU */
+				case FPP_ACTION_QUERY_CONT:
+				{
+					if (NULL == entry)
+					{
+						ret = pfe_if_db_get_next(fci_context->log_if_db, fci_context->if_session_id, &entry);
+						if (NULL == entry)
+						{
+							*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
+							if(EOK != ret)
+							{
+								NXP_LOG_ERROR("Incorrect session ID detected\n");
+								*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
+							}
+							ret = EOK;
+							break;
+						}
+					}
 
-			log_if = pfe_if_db_entry_get_log_if(entry);
+					log_if = pfe_if_db_entry_get_log_if(entry);
 
-			if(NULL != log_if)
-			{
-				phy_if = pfe_log_if_get_parent(log_if);
-			}
-			/* Store names */
-			if(NULL != phy_if)
-			{
-				(void)strncpy(reply_buf->name, pfe_log_if_get_name(log_if), (uint32_t)IFNAMSIZ-1U);
-				(void)strncpy(reply_buf->parent_name, pfe_phy_if_get_name(phy_if), (uint32_t)IFNAMSIZ-1U);
-			}
-			else
-			{
-				NXP_LOG_DEBUG("Was not possible to resolve DB entry to log_if or parent phy_if");
-				*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-				break;
-			}
-			ret = pfe_log_if_get_stats(log_if,&stats);
-			if(EOK != ret)
-			{
-				NXP_LOG_ERROR("Could not get interface statistics\n");
-				break;
-			}
+					if(NULL != log_if)
+					{
+						phy_if = pfe_log_if_get_parent(log_if);
+					}
+					/* Store names */
+					if(NULL != phy_if)
+					{
+						(void)strncpy(reply_buf->name, pfe_log_if_get_name(log_if), (uint32_t)IFNAMSIZ-1U);
+						(void)strncpy(reply_buf->parent_name, pfe_phy_if_get_name(phy_if), (uint32_t)IFNAMSIZ-1U);
+					}
+					else
+					{
+						NXP_LOG_DEBUG("Was not possible to resolve DB entry to log_if or parent phy_if");
+						*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
+						break;
+					}
+					ret = pfe_log_if_get_stats(log_if,&stats);
+					if(EOK != ret)
+					{
+						NXP_LOG_ERROR("Could not get interface statistics\n");
+						break;
+					}
 
-			/* Copy the log if statistics to reply */
-			(void)memcpy(&reply_buf->stats, &stats, sizeof(reply_buf->stats));
+					/* Copy the log if statistics to reply */
+					(void)memcpy(&reply_buf->stats, &stats, sizeof(reply_buf->stats));
 
-			/* Get important flag values */
-			(void)memset(&reply_buf->flags, 0, sizeof(reply_buf->flags));
-			if(pfe_log_if_is_enabled(log_if))
-			{
-				reply_buf->flags |= oal_htonl(FPP_IF_ENABLED);
-			}
+					/* Get important flag values */
+					(void)memset(&reply_buf->flags, 0, sizeof(reply_buf->flags));
+					if(pfe_log_if_is_enabled(log_if))
+					{
+						reply_buf->flags |= oal_htonl(FPP_IF_ENABLED);
+					}
 
-			if(pfe_log_if_is_loopback(log_if))
-			{
-				reply_buf->flags |= oal_htonl(FPP_IF_LOOPBACK);
-			}
+					if(pfe_log_if_is_loopback(log_if))
+					{
+						reply_buf->flags |= oal_htonl(FPP_IF_LOOPBACK);
+					}
 
-			if(pfe_log_if_is_promisc(log_if))
-			{
-				reply_buf->flags |= oal_htonl(FPP_IF_PROMISC);
-			}
+					if(pfe_log_if_is_promisc(log_if))
+					{
+						reply_buf->flags |= oal_htonl(FPP_IF_PROMISC);
+					}
 
-			if(pfe_log_if_is_discard(log_if))
-			{
-				reply_buf->flags |= oal_htonl(FPP_IF_DISCARD);
-			}
+					if(pfe_log_if_is_discard(log_if))
+					{
+						reply_buf->flags |= oal_htonl(FPP_IF_DISCARD);
+					}
 
-			if(pfe_log_if_is_match_or(log_if))
-			{
-				reply_buf->flags |= oal_htonl(FPP_IF_MATCH_OR);
-			}
+					if(pfe_log_if_is_match_or(log_if))
+					{
+						reply_buf->flags |= oal_htonl(FPP_IF_MATCH_OR);
+					}
 
-			/* Store egress interfaces */
-			if(EOK != pfe_log_if_get_egress_ifs(log_if, &egress))
-			{
-				NXP_LOG_DEBUG("Was not possible to get egress interfaces\n");
-			}
-			reply_buf->egress = oal_htonl(egress);
+					/* Store egress interfaces */
+					if(EOK != pfe_log_if_get_egress_ifs(log_if, &egress))
+					{
+						NXP_LOG_DEBUG("Was not possible to get egress interfaces\n");
+					}
+					reply_buf->egress = oal_htonl(egress);
 
-            (void)memset(&rules, 0, sizeof(pfe_ct_if_m_rules_t));
-            (void)memset(&args, 0, sizeof(pfe_ct_if_m_args_t));
-			/* Store rules for FCI */
-			if(EOK != pfe_log_if_get_match_rules(log_if, &rules, &args))
-			{
-				NXP_LOG_DEBUG("Was not possible to get match rules and arguments\n");
-			}
+					(void)memset(&rules, 0, sizeof(pfe_ct_if_m_rules_t));
+					(void)memset(&args, 0, sizeof(pfe_ct_if_m_args_t));
+					/* Store rules for FCI */
+					if(EOK != pfe_log_if_get_match_rules(log_if, &rules, &args))
+					{
+						NXP_LOG_DEBUG("Was not possible to get match rules and arguments\n");
+					}
 
-			/* Fix endians of FP tables */
-			args.fp0_table = oal_ntohl(args.fp0_table);
-			args.fp1_table = oal_ntohl(args.fp1_table);
-			reply_buf->match = (fpp_if_m_rules_t)(oal_htonl(rules));
-
-			/* Store match rule arguments for FCI */
-			reply_buf->arguments.vlan = args.vlan;
-			reply_buf->arguments.ethtype = args.ethtype;
-			reply_buf->arguments.sport = args.sport;
-			reply_buf->arguments.dport = args.dport;
-			reply_buf->arguments.proto = args.proto;
-			reply_buf->arguments.hif_cookie = args.hif_cookie;
-			(void)memcpy(&reply_buf->arguments.ipv, &args.ipv, sizeof(reply_buf->arguments.ipv));
-			(void)memcpy(reply_buf->arguments.smac, args.smac, 6U);
-			(void)memcpy(reply_buf->arguments.dmac, args.dmac, 6U);
-
-			/* Translate names of flexible parser tables from addresses to strings. */
-			(void)memset(reply_buf->arguments.fp_table0, 0, IFNAMSIZ);
-			(void)memset(reply_buf->arguments.fp_table1, 0, IFNAMSIZ);
-			if(EOK == fci_fp_db_get_table_from_addr(args.fp0_table, &table_name))
-			{
-				(void)strcpy(reply_buf->arguments.fp_table0, table_name);
-			}
-			if(EOK == fci_fp_db_get_table_from_addr(args.fp1_table, &table_name))
-			{
-				(void)strcpy(reply_buf->arguments.fp_table1, table_name);
-			}
+					/* Fix endians of FP tables */
+					args.fp0_table = oal_ntohl(args.fp0_table);
+					args.fp1_table = oal_ntohl(args.fp1_table);
+					reply_buf->match = (fpp_if_m_rules_t)(oal_htonl(rules));
+
+					/* Store match rule arguments for FCI */
+					reply_buf->arguments.vlan = args.vlan;
+					reply_buf->arguments.ethtype = args.ethtype;
+					reply_buf->arguments.sport = args.sport;
+					reply_buf->arguments.dport = args.dport;
+					reply_buf->arguments.proto = args.proto;
+					reply_buf->arguments.hif_cookie = args.hif_cookie;
+					(void)memcpy(&reply_buf->arguments.ipv, &args.ipv, sizeof(reply_buf->arguments.ipv));
+					(void)memcpy(reply_buf->arguments.smac, args.smac, 6U);
+					(void)memcpy(reply_buf->arguments.dmac, args.dmac, 6U);
+
+					/* Translate names of flexible parser tables from addresses to strings. */
+					(void)memset(reply_buf->arguments.fp_table0, 0, IFNAMSIZ);
+					(void)memset(reply_buf->arguments.fp_table1, 0, IFNAMSIZ);
+					if(EOK == fci_fp_db_get_table_from_addr(args.fp0_table, &table_name))
+					{
+						(void)strcpy(reply_buf->arguments.fp_table0, table_name);
+					}
+					if(EOK == fci_fp_db_get_table_from_addr(args.fp1_table, &table_name))
+					{
+						(void)strcpy(reply_buf->arguments.fp_table1, table_name);
+					}
 
-			/* Set ids */
-			reply_buf->id = oal_htonl(pfe_log_if_get_id(log_if));
-			reply_buf->parent_id = oal_htonl(pfe_phy_if_get_id(pfe_log_if_get_parent(log_if)));
+					/* Set ids */
+					reply_buf->id = oal_htonl(pfe_log_if_get_id(log_if));
+					reply_buf->parent_id = oal_htonl(pfe_phy_if_get_id(pfe_log_if_get_parent(log_if)));
 
-			*reply_len = sizeof(fpp_log_if_cmd_t);
-			*fci_ret = FPP_ERR_OK;
-			break;
-		}
-		default:
-		{
-			/*Do Nothing*/
-			break;
+					*reply_len = sizeof(fpp_log_if_cmd_t);
+					*fci_ret = FPP_ERR_OK;
+					break;
+				}
+				default:
+				{
+					/*Do Nothing*/
+					break;
+				}
+			}
 		}
 	}
 
@@ -907,507 +914,506 @@ errno_t fci_interfaces_phy_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_phy_if_cmd
 	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	if (unlikely(FALSE == fci_context->fci_initialized))
+	else if (unlikely(FALSE == fci_context->fci_initialized))
 	{
 		NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (*reply_len < sizeof(fpp_phy_if_cmd_t))
-	{
-		NXP_LOG_ERROR("Buffer length does not match expected value (fpp_if_cmd_t)\n");
-		return EINVAL;
+		ret = EPERM;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		/*	No data written to reply buffer (yet) */
-		*reply_len = 0U;
-	}
-
-	/*	Initialize the reply buffer */
-	(void)memset(reply_buf, 0, sizeof(fpp_phy_if_cmd_t));
-
-	if_cmd = (fpp_phy_if_cmd_t *)msg->msg_cmd.payload;
-
-	switch (if_cmd->action)
-	{
-		case FPP_ACTION_UPDATE:
+		if (*reply_len < sizeof(fpp_phy_if_cmd_t))
 		{
-			/* Get the requested interface */
-			ret = pfe_if_db_get_first(fci_context->phy_if_db, fci_context->if_session_id, IF_DB_CRIT_BY_NAME, if_cmd->name, &entry);
-
-			if(EOK != ret)
-			{
-				NXP_LOG_ERROR("Incorrect session ID detected\n");
-				*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
-				break;
-			}
-
-			/* Check if entry is not NULL and get physical interface */
-			if(NULL != entry)
-			{
-				phy_if = pfe_if_db_entry_get_phy_if(entry);
-			}
-
-			/* Check if the entry exits*/
-			if((NULL == entry) || (NULL == phy_if))
-			{
-				/* Interface doesn't exist or couldn't be extracted from the entry */
-				*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-				break;
-			}
+			NXP_LOG_ERROR("Buffer length does not match expected value (fpp_if_cmd_t)\n");
+			ret = EINVAL;
+		}
+		else
+		{
+			/*	No data written to reply buffer (yet) */
+			*reply_len = 0U;
+			/*	Initialize the reply buffer */
+			(void)memset(reply_buf, 0, sizeof(fpp_phy_if_cmd_t));
 
-			/*	Set the interface block state - use the fact the enumerations
-				have same values */
-			ret = pfe_phy_if_set_block_state(phy_if, (pfe_ct_block_state_t)if_cmd->block_state);
-			if(EOK != ret)
-			{
-				*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
-				break;
-			}
+			if_cmd = (fpp_phy_if_cmd_t *)msg->msg_cmd.payload;
 
-			/* Set the interface mode */
-			ret = pfe_phy_if_set_op_mode(phy_if, (pfe_ct_if_op_mode_t)(if_cmd->mode));
-			if(EOK != ret)
+			switch (if_cmd->action)
 			{
-				*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
-				break;
-			}
+				case FPP_ACTION_UPDATE:
+				{
+					/* Get the requested interface */
+					ret = pfe_if_db_get_first(fci_context->phy_if_db, fci_context->if_session_id, IF_DB_CRIT_BY_NAME, if_cmd->name, &entry);
 
-			for(i = 0U; i < (uint32_t)FPP_MIRRORS_CNT; i++)
-			{
-				/* RX */
-				if('\0' == if_cmd->rx_mirrors[i][0])
-				{	/* Mirror is disabled */
-					if (EOK != pfe_phy_if_set_rx_mirror(phy_if, i, NULL))
+					if(EOK != ret)
 					{
-						NXP_LOG_ERROR("Configures the selected RX mirror failed\n");
-						*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
+						NXP_LOG_ERROR("Incorrect session ID detected\n");
+						*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
 						break;
 					}
-				}
-				else
-				{	/* Mirror is enabled and to be configured */
-					/* Get requested mirror handle */
-					mirror = pfe_mirror_get_first(MIRROR_BY_NAME, if_cmd->rx_mirrors[i]);
-					if(NULL == mirror)
+
+					/* Check if entry is not NULL and get physical interface */
+					if(NULL != entry)
 					{
-						/* FCI command requested nonexistent entity. Respond with FCI error code. */
-						NXP_LOG_ERROR("Mirror %s cannot be found\n", if_cmd->rx_mirrors[i]);
-						*fci_ret = FPP_ERR_MIRROR_NOT_FOUND;
-						ret = EOK;
-						break;
+						phy_if = pfe_if_db_entry_get_phy_if(entry);
 					}
-					/* Set the mirror */
-					if (EOK != pfe_phy_if_set_rx_mirror(phy_if, i, mirror))
+
+					/* Check if the entry exits*/
+					if((NULL == entry) || (NULL == phy_if))
 					{
-						NXP_LOG_ERROR("Configures the selected RX mirror failed\n");
-						*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
+						/* Interface doesn't exist or couldn't be extracted from the entry */
+						*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
 						break;
 					}
 
-				}
-				/* TX */
-				if('\0' == if_cmd->tx_mirrors[i][0])
-				{	/* Mirror is disabled */
-					if (EOK != pfe_phy_if_set_tx_mirror(phy_if, i, NULL))
+					/*	Set the interface block state - use the fact the enumerations
+						have same values */
+					ret = pfe_phy_if_set_block_state(phy_if, (pfe_ct_block_state_t)if_cmd->block_state);
+					if(EOK != ret)
 					{
-						NXP_LOG_ERROR("Configures the selected TX mirror failed\n");
 						*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
 						break;
 					}
-				}
-				else
-				{	/* Mirror is enabled and to be configured */
-					/* Get requested mirror handle */
-					mirror = pfe_mirror_get_first(MIRROR_BY_NAME, if_cmd->tx_mirrors[i]);
-					if(NULL == mirror)
-					{
-						/* FCI command requested nonexistent entity. Respond with FCI error code. */
-						NXP_LOG_ERROR("Mirror %s cannot be found\n", if_cmd->rx_mirrors[i]);
-						*fci_ret = FPP_ERR_MIRROR_NOT_FOUND;
-						ret = EOK;
-						break;
-					}
-					/* Set the mirror */
-					if (EOK != pfe_phy_if_set_tx_mirror(phy_if, i, mirror))
+
+					/* Set the interface mode */
+					ret = pfe_phy_if_set_op_mode(phy_if, (pfe_ct_if_op_mode_t)(if_cmd->mode));
+					if(EOK != ret)
 					{
-						NXP_LOG_ERROR("Configures the selected TX mirror failed\n");
 						*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
 						break;
 					}
 
-				}
-			}
+					for(i = 0U; i < (uint32_t)FPP_MIRRORS_CNT; i++)
+					{
+						/* RX */
+						if('\0' == if_cmd->rx_mirrors[i][0])
+						{	/* Mirror is disabled */
+							if (EOK != pfe_phy_if_set_rx_mirror(phy_if, i, NULL))
+							{
+								NXP_LOG_ERROR("Configures the selected RX mirror failed\n");
+								*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
+								break;
+							}
+						}
+						else
+						{	/* Mirror is enabled and to be configured */
+							/* Get requested mirror handle */
+							mirror = pfe_mirror_get_first(MIRROR_BY_NAME, if_cmd->rx_mirrors[i]);
+							if(NULL == mirror)
+							{
+								/* FCI command requested nonexistent entity. Respond with FCI error code. */
+								NXP_LOG_ERROR("Mirror %s cannot be found\n", if_cmd->rx_mirrors[i]);
+								*fci_ret = FPP_ERR_MIRROR_NOT_FOUND;
+								ret = EOK;
+								break;
+							}
+							/* Set the mirror */
+							if (EOK != pfe_phy_if_set_rx_mirror(phy_if, i, mirror))
+							{
+								NXP_LOG_ERROR("Configures the selected RX mirror failed\n");
+								*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
+								break;
+							}
 
-			/*	Enable/Disable */
-			if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_ENABLED))
-			{
-				ret = pfe_phy_if_enable(phy_if);
-			}
-			else
-			{
-				ret = pfe_phy_if_disable(phy_if);
-			}
+						}
+						/* TX */
+						if('\0' == if_cmd->tx_mirrors[i][0])
+						{	/* Mirror is disabled */
+							if (EOK != pfe_phy_if_set_tx_mirror(phy_if, i, NULL))
+							{
+								NXP_LOG_ERROR("Configures the selected TX mirror failed\n");
+								*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
+								break;
+							}
+						}
+						else
+						{	/* Mirror is enabled and to be configured */
+							/* Get requested mirror handle */
+							mirror = pfe_mirror_get_first(MIRROR_BY_NAME, if_cmd->tx_mirrors[i]);
+							if(NULL == mirror)
+							{
+								/* FCI command requested nonexistent entity. Respond with FCI error code. */
+								NXP_LOG_ERROR("Mirror %s cannot be found\n", if_cmd->rx_mirrors[i]);
+								*fci_ret = FPP_ERR_MIRROR_NOT_FOUND;
+								ret = EOK;
+								break;
+							}
+							/* Set the mirror */
+							if (EOK != pfe_phy_if_set_tx_mirror(phy_if, i, mirror))
+							{
+								NXP_LOG_ERROR("Configures the selected TX mirror failed\n");
+								*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
+								break;
+							}
 
-			if(EOK != ret)
-			{
-				NXP_LOG_ERROR("ENABLE flag wasn't updated correctly on %s\n",  pfe_phy_if_get_name(phy_if));
-				*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
-			}
+						}
+					}
 
-			/* promisc */
-			if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_PROMISC))
-			{
-				ret = pfe_phy_if_promisc_enable(phy_if);
-			}
-			else
-			{
-				ret = pfe_phy_if_promisc_disable(phy_if);
-			}
+					/*	Enable/Disable */
+					if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_ENABLED))
+					{
+						ret = pfe_phy_if_enable(phy_if);
+					}
+					else
+					{
+						ret = pfe_phy_if_disable(phy_if);
+					}
 
-			if(EOK != ret)
-			{
-				NXP_LOG_ERROR("PROMISC flag wasn't updated correctly on %s\n",  pfe_phy_if_get_name(phy_if));
-				*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
-			}
+					if(EOK != ret)
+					{
+						NXP_LOG_ERROR("ENABLE flag wasn't updated correctly on %s\n",  pfe_phy_if_get_name(phy_if));
+						*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
+					}
 
-			/*	VLAN conformance check */
-			if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_VLAN_CONF_CHECK))
-			{
-				flag_in_cmd = true;
-				ret = pfe_phy_if_set_flag(phy_if, IF_FL_VLAN_CONF_CHECK);
-			}
-			else
-			{
-				flag_in_cmd = false;
-				ret = pfe_phy_if_clear_flag(phy_if, IF_FL_VLAN_CONF_CHECK);
-			}
+					/* promisc */
+					if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_PROMISC))
+					{
+						ret = pfe_phy_if_promisc_enable(phy_if);
+					}
+					else
+					{
+						ret = pfe_phy_if_promisc_disable(phy_if);
+					}
 
-			if(EOK != ret)
-			{
-				flag_in_drv = (IF_FL_NONE != pfe_phy_if_get_flag(phy_if, IF_FL_VLAN_CONF_CHECK));
+					if(EOK != ret)
+					{
+						NXP_LOG_ERROR("PROMISC flag wasn't updated correctly on %s\n",  pfe_phy_if_get_name(phy_if));
+						*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
+					}
 
-				if (EPERM == ret)
-				{
-					if(flag_in_cmd == flag_in_drv)
+					/*	VLAN conformance check */
+					if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_VLAN_CONF_CHECK))
 					{
-						/* Unavailable feature and FCI command didn't modify it. Continue through. */
-						ret = EOK;
+						flag_in_cmd = true;
+						ret = pfe_phy_if_set_flag(phy_if, IF_FL_VLAN_CONF_CHECK);
 					}
 					else
 					{
-						/* Unavailable feature and FCI command tried to modify it. Respond with FCI error code. */
-						*fci_ret = FPP_ERR_FW_FEATURE_NOT_AVAILABLE;
-						ret = EOK;
-						break;
+						flag_in_cmd = false;
+						ret = pfe_phy_if_clear_flag(phy_if, IF_FL_VLAN_CONF_CHECK);
 					}
-				}
-				else
-				{
-					/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-					NXP_LOG_ERROR("VLAN_CONF_CHECK flag wasn't updated correctly on %s\n",  pfe_phy_if_get_name(phy_if));
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-					break;
-				}
-			}
 
-			/*	PTP conformance check */
-			if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_PTP_CONF_CHECK))
-			{
-				flag_in_cmd = true;
-				ret = pfe_phy_if_set_flag(phy_if, IF_FL_PTP_CONF_CHECK);
-			}
-			else
-			{
-				flag_in_cmd = false;
-				ret = pfe_phy_if_clear_flag(phy_if, IF_FL_PTP_CONF_CHECK);
-			}
+					if(EOK != ret)
+					{
+						flag_in_drv = (IF_FL_NONE != pfe_phy_if_get_flag(phy_if, IF_FL_VLAN_CONF_CHECK));
 
-			if(EOK != ret)
-			{
-				flag_in_drv = (IF_FL_NONE != pfe_phy_if_get_flag(phy_if, IF_FL_PTP_CONF_CHECK));
+						if (EPERM == ret)
+						{
+							if(flag_in_cmd == flag_in_drv)
+							{
+								/* Unavailable feature and FCI command didn't modify it. Continue through. */
+								ret = EOK;
+							}
+							else
+							{
+								/* Unavailable feature and FCI command tried to modify it. Respond with FCI error code. */
+								*fci_ret = FPP_ERR_FW_FEATURE_NOT_AVAILABLE;
+								ret = EOK;
+								break;
+							}
+						}
+						else
+						{
+							/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+							NXP_LOG_ERROR("VLAN_CONF_CHECK flag wasn't updated correctly on %s\n",  pfe_phy_if_get_name(phy_if));
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							break;
+						}
+					}
 
-				if (EPERM == ret)
-				{
-					if(flag_in_cmd == flag_in_drv)
+					/*	PTP conformance check */
+					if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_PTP_CONF_CHECK))
 					{
-						/* Unavailable feature and FCI command didn't modify it. Continue through. */
-						ret = EOK;
+						flag_in_cmd = true;
+						ret = pfe_phy_if_set_flag(phy_if, IF_FL_PTP_CONF_CHECK);
 					}
 					else
 					{
-						/* Unavailable feature and FCI command tried to modify it. Respond with FCI error code. */
-						*fci_ret = FPP_ERR_FW_FEATURE_NOT_AVAILABLE;
-						ret = EOK;
-						break;
+						flag_in_cmd = false;
+						ret = pfe_phy_if_clear_flag(phy_if, IF_FL_PTP_CONF_CHECK);
 					}
-				}
-				else
-				{
-					/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-					NXP_LOG_ERROR("PTP_CONF_CHECK flag wasn't updated correctly on %s\n",  pfe_phy_if_get_name(phy_if));
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-					break;
-				}
-			}
-
-			/*	PTP promiscuous mode */
-			if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_PTP_PROMISC))
-			{
-				ret = pfe_phy_if_set_flag(phy_if, IF_FL_PTP_PROMISC);
-			}
-			else
-			{
-				ret = pfe_phy_if_clear_flag(phy_if, IF_FL_PTP_PROMISC);
-			}
-
-			if(EOK != ret)
-			{
-				/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-				NXP_LOG_ERROR("PTP_PROMISC flag wasn't updated correctly on %s\n",  pfe_phy_if_get_name(phy_if));
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				break;
-			}
 
-			/*	QinQ support control */
-			if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_ALLOW_Q_IN_Q))
-			{
-				ret = pfe_phy_if_set_flag(phy_if, IF_FL_ALLOW_Q_IN_Q);
-			}
-			else
-			{
-				ret = pfe_phy_if_clear_flag(phy_if, IF_FL_ALLOW_Q_IN_Q);
-			}
+					if(EOK != ret)
+					{
+						flag_in_drv = (IF_FL_NONE != pfe_phy_if_get_flag(phy_if, IF_FL_PTP_CONF_CHECK));
 
-			if(EOK != ret)
-			{
-				NXP_LOG_ERROR("ALLOW_Q_IN_Q flag wasn't updated correctly on %s\n",  pfe_phy_if_get_name(phy_if));
-				*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
-			}
+						if (EPERM == ret)
+						{
+							if(flag_in_cmd == flag_in_drv)
+							{
+								/* Unavailable feature and FCI command didn't modify it. Continue through. */
+								ret = EOK;
+							}
+							else
+							{
+								/* Unavailable feature and FCI command tried to modify it. Respond with FCI error code. */
+								*fci_ret = FPP_ERR_FW_FEATURE_NOT_AVAILABLE;
+								ret = EOK;
+								break;
+							}
+						}
+						else
+						{
+							/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+							NXP_LOG_ERROR("PTP_CONF_CHECK flag wasn't updated correctly on %s\n",  pfe_phy_if_get_name(phy_if));
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							break;
+						}
+					}
 
-			/*	TTL discard control */
-			if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_DISCARD_TTL))
-			{
-				ret = pfe_phy_if_set_flag(phy_if, IF_FL_DISCARD_TTL);
-			}
-			else
-			{
-				ret = pfe_phy_if_clear_flag(phy_if, IF_FL_DISCARD_TTL);
-			}
+					/*	PTP promiscuous mode */
+					if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_PTP_PROMISC))
+					{
+						ret = pfe_phy_if_set_flag(phy_if, IF_FL_PTP_PROMISC);
+					}
+					else
+					{
+						ret = pfe_phy_if_clear_flag(phy_if, IF_FL_PTP_PROMISC);
+					}
 
-			if(EOK != ret)
-			{
-				NXP_LOG_ERROR("DISCARD_TTL flag wasn't updated correctly on %s\n",  pfe_phy_if_get_name(phy_if));
-				*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
-			}
+					if(EOK != ret)
+					{
+						/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+						NXP_LOG_ERROR("PTP_PROMISC flag wasn't updated correctly on %s\n",  pfe_phy_if_get_name(phy_if));
+						*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+						break;
+					}
 
-			/*	Flexible Filter */
-			if (0U != strlen((char_t *)if_cmd->ftable))
-			{
-				/*	Validate table */
-				if (NULL == fci_fp_db_get_first(FP_TABLE_CRIT_NAME, (void *)if_cmd->ftable))
-				{
-					/*	Table not found */
-					NXP_LOG_ERROR("%s: FP table %s not found\n",
-							pfe_phy_if_get_name(phy_if), if_cmd->ftable);
-				}
-				else
-				{
-					/*	If not already done, write the table to HW */
-					addr = fci_fp_db_get_table_dmem_addr((char_t *)if_cmd->ftable);
-					if (0U == addr)
+					/*	QinQ support control */
+					if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_ALLOW_Q_IN_Q))
+					{
+						ret = pfe_phy_if_set_flag(phy_if, IF_FL_ALLOW_Q_IN_Q);
+					}
+					else
 					{
-						(void)fci_fp_db_push_table_to_hw(fci_context->class, (char_t *)if_cmd->ftable);
-						addr = fci_fp_db_get_table_dmem_addr((char_t *)if_cmd->ftable);
+						ret = pfe_phy_if_clear_flag(phy_if, IF_FL_ALLOW_Q_IN_Q);
 					}
 
-					/*	Assign the table to the physical interface */
-					/*	TODO: Temporary way. Pass table instance or name but not the DMEM address :( */
-					ret = pfe_phy_if_set_ftable(phy_if, addr);
-					if (EOK != ret)
+					if(EOK != ret)
 					{
-						NXP_LOG_ERROR("%s: Could not set filter table: %d\n", pfe_phy_if_get_name(phy_if), ret);
+						NXP_LOG_ERROR("ALLOW_Q_IN_Q flag wasn't updated correctly on %s\n",  pfe_phy_if_get_name(phy_if));
 						*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
 					}
-				}
-			}
-			else
-			{
-				/*	Disable the filter. Get table entry from DB first. */
-				addr = pfe_phy_if_get_ftable(phy_if);
-				if (EOK == fci_fp_db_get_table_from_addr(addr, &name))
-				{
-					/* Delete the table from DMEM - no longer in use, copy is in database */
-					(void)fci_fp_db_pop_table_from_hw(name);
-				}
 
-				/*	Assign NULL-table to the physical interface */
-				/*	TODO: Temporary way. Pass table instance or name but not the DMEM address :( */
-				ret = pfe_phy_if_set_ftable(phy_if, 0U);
-				if (EOK != ret)
-				{
-					NXP_LOG_ERROR("%s: Could not set filter table: %d\n", pfe_phy_if_get_name(phy_if), ret);
-					*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
-				}
-			}
+					/*	TTL discard control */
+					if(0U != (oal_ntohl(if_cmd->flags) & (uint32_t)FPP_IF_DISCARD_TTL))
+					{
+						ret = pfe_phy_if_set_flag(phy_if, IF_FL_DISCARD_TTL);
+					}
+					else
+					{
+						ret = pfe_phy_if_clear_flag(phy_if, IF_FL_DISCARD_TTL);
+					}
 
-			break;
-		}
+					if(EOK != ret)
+					{
+						NXP_LOG_ERROR("DISCARD_TTL flag wasn't updated correctly on %s\n",  pfe_phy_if_get_name(phy_if));
+						*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
+					}
 
-		case FPP_ACTION_QUERY:
-		{
-			ret = pfe_if_db_get_first(fci_context->phy_if_db, fci_context->if_session_id, IF_DB_CRIT_ALL, NULL, &entry);
+					/*	Flexible Filter */
+					if (0U != strlen((char_t *)if_cmd->ftable))
+					{
+						/*	Validate table */
+						if (NULL == fci_fp_db_get_first(FP_TABLE_CRIT_NAME, (void *)if_cmd->ftable))
+						{
+							/*	Table not found */
+							NXP_LOG_ERROR("%s: FP table %s not found\n",
+									pfe_phy_if_get_name(phy_if), if_cmd->ftable);
+						}
+						else
+						{
+							/*	If not already done, write the table to HW */
+							addr = fci_fp_db_get_table_dmem_addr((char_t *)if_cmd->ftable);
+							if (0U == addr)
+							{
+								(void)fci_fp_db_push_table_to_hw(fci_context->class, (char_t *)if_cmd->ftable);
+								addr = fci_fp_db_get_table_dmem_addr((char_t *)if_cmd->ftable);
+							}
 
-			if(EOK != ret)
-			{
-				NXP_LOG_ERROR("Incorrect session ID detected\n");
-				*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
-				break;
-			}
+							/*	Assign the table to the physical interface */
+							/*	TODO: Temporary way. Pass table instance or name but not the DMEM address :( */
+							ret = pfe_phy_if_set_ftable(phy_if, addr);
+							if (EOK != ret)
+							{
+								NXP_LOG_ERROR("%s: Could not set filter table: %d\n", pfe_phy_if_get_name(phy_if), ret);
+								*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
+							}
+						}
+					}
+					else
+					{
+						/*	Disable the filter. Get table entry from DB first. */
+						addr = pfe_phy_if_get_ftable(phy_if);
+						if (EOK == fci_fp_db_get_table_from_addr(addr, &name))
+						{
+							/* Delete the table from DMEM - no longer in use, copy is in database */
+							(void)fci_fp_db_pop_table_from_hw(name);
+						}
 
-			if (NULL == entry)
-			{
-				ret = EOK;
-				*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-				break;
-			}
-		} /* FALLTHRU */
+						/*	Assign NULL-table to the physical interface */
+						/*	TODO: Temporary way. Pass table instance or name but not the DMEM address :( */
+						ret = pfe_phy_if_set_ftable(phy_if, 0U);
+						if (EOK != ret)
+						{
+							NXP_LOG_ERROR("%s: Could not set filter table: %d\n", pfe_phy_if_get_name(phy_if), ret);
+							*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
+						}
+					}
 
-		case FPP_ACTION_QUERY_CONT:
-		{
-			if (NULL == entry)
-			{
-				ret = pfe_if_db_get_next(fci_context->phy_if_db, fci_context->if_session_id, &entry);
-				if(EOK != ret)
-				{
-					ret = EOK;
-					*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
 					break;
 				}
 
-				if (NULL == entry)
+				case FPP_ACTION_QUERY:
 				{
-					ret = EOK;
-					*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-					break;
-				}
-			}
-
-			phy_if = pfe_if_db_entry_get_phy_if(entry);
-			if (NULL == phy_if)
-			{
-				NXP_LOG_DEBUG("Was not possible to resolve DB entry to phy_if");
-				*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-				break;
-			}
-			ret = pfe_phy_if_get_stats(phy_if, &stats);
-			if(EOK != ret)
-			{
-				NXP_LOG_ERROR("Could not get interface statistics\n");
-				break;
-			}
-			/* Copy the phy if statistics to reply */
-			(void)memcpy(&reply_buf->stats, &stats, sizeof(reply_buf->stats));
-
-			/* Store phy_if name */
-			(void)strncpy(reply_buf->name, pfe_phy_if_get_name(phy_if), (uint32_t)IFNAMSIZ-1U);
+					ret = pfe_if_db_get_first(fci_context->phy_if_db, fci_context->if_session_id, IF_DB_CRIT_ALL, NULL, &entry);
 
-			/* Store phy_if id */
-			reply_buf->id = oal_htonl(pfe_phy_if_get_id(phy_if));
+					if(EOK != ret)
+					{
+						NXP_LOG_ERROR("Incorrect session ID detected\n");
+						*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
+						break;
+					}
 
-			reply_buf->flags |= (TRUE == pfe_phy_if_is_promisc(phy_if)) ? oal_htonl(FPP_IF_PROMISC) : 0U;
-			reply_buf->flags |= (TRUE == pfe_phy_if_is_enabled(phy_if)) ? oal_htonl(FPP_IF_ENABLED) : 0U;
-			reply_buf->flags |= ((uint32_t)IF_FL_NONE != (uint32_t)pfe_phy_if_get_flag(phy_if, IF_FL_VLAN_CONF_CHECK)) ? oal_htonl(FPP_IF_VLAN_CONF_CHECK) : 0U;
-			reply_buf->flags |= ((uint32_t)IF_FL_NONE != (uint32_t)pfe_phy_if_get_flag(phy_if, IF_FL_PTP_CONF_CHECK)) ? oal_htonl(FPP_IF_PTP_CONF_CHECK) : 0U;
-			reply_buf->flags |= ((uint32_t)IF_FL_NONE != (uint32_t)pfe_phy_if_get_flag(phy_if, IF_FL_PTP_PROMISC)) ? oal_htonl(FPP_IF_PTP_PROMISC) : 0U;
-			reply_buf->flags |= ((uint32_t)IF_FL_NONE != (uint32_t)pfe_phy_if_get_flag(phy_if, IF_FL_ALLOW_Q_IN_Q)) ? oal_htonl(FPP_IF_ALLOW_Q_IN_Q) : 0U;
-			reply_buf->flags |= ((uint32_t)IF_FL_NONE != (uint32_t)pfe_phy_if_get_flag(phy_if, IF_FL_DISCARD_TTL)) ? oal_htonl(FPP_IF_DISCARD_TTL) : 0U;
+					if (NULL == entry)
+					{
+						ret = EOK;
+						*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
+						break;
+					}
+				} /* FALLTHRU */
 
-			/* Get the mode - use the fact enums have same values */
-			reply_buf->mode = (fpp_phy_if_op_mode_t) pfe_phy_if_get_op_mode(phy_if);
+				case FPP_ACTION_QUERY_CONT:
+				{
+					if (NULL == entry)
+					{
+						ret = pfe_if_db_get_next(fci_context->phy_if_db, fci_context->if_session_id, &entry);
+						if(EOK != ret)
+						{
+							ret = EOK;
+							*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
+							break;
+						}
 
-			/* Get the block state */
-			(void)pfe_phy_if_get_block_state(phy_if, &block_state);
-			/* Use the fact that the enums have same values */
-			reply_buf->block_state = (fpp_phy_if_block_state_t)block_state;
+						if (NULL == entry)
+						{
+							ret = EOK;
+							*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
+							break;
+						}
+					}
 
-			for(i = 0U; i < (uint32_t)FPP_MIRRORS_CNT; i++)
-			{
-				/* RX */
-				mirror = pfe_phy_if_get_rx_mirror(phy_if, i);
-				if(NULL != mirror)
-				{
-					str = pfe_mirror_get_name(mirror);
-					if(NULL != str)
+					phy_if = pfe_if_db_entry_get_phy_if(entry);
+					if (NULL == phy_if)
 					{
-						(void)strncpy(&reply_buf->rx_mirrors[i][0], str, 16);
-						reply_buf->rx_mirrors[i][15] = '\0'; /* Ensure correct string end */
+						NXP_LOG_DEBUG("Was not possible to resolve DB entry to phy_if");
+						*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
+						break;
 					}
-					else
+					ret = pfe_phy_if_get_stats(phy_if, &stats);
+					if(EOK != ret)
 					{
-						NXP_LOG_WARNING("Could not obtain mirror name for %u\n", (uint_t)addr);
+						NXP_LOG_ERROR("Could not get interface statistics\n");
+						break;
 					}
-				}
+					/* Copy the phy if statistics to reply */
+					(void)memcpy(&reply_buf->stats, &stats, sizeof(reply_buf->stats));
 
-				/* TX */
-				mirror = pfe_phy_if_get_tx_mirror(phy_if, i);
-				if(NULL != mirror)
-				{
-					str = pfe_mirror_get_name(mirror);
-					if(NULL != str)
+					/* Store phy_if name */
+					(void)strncpy(reply_buf->name, pfe_phy_if_get_name(phy_if), (uint32_t)IFNAMSIZ-1U);
+
+					/* Store phy_if id */
+					reply_buf->id = oal_htonl(pfe_phy_if_get_id(phy_if));
+
+					reply_buf->flags |= (TRUE == pfe_phy_if_is_promisc(phy_if)) ? oal_htonl(FPP_IF_PROMISC) : 0U;
+					reply_buf->flags |= (TRUE == pfe_phy_if_is_enabled(phy_if)) ? oal_htonl(FPP_IF_ENABLED) : 0U;
+					reply_buf->flags |= ((uint32_t)IF_FL_NONE != (uint32_t)pfe_phy_if_get_flag(phy_if, IF_FL_VLAN_CONF_CHECK)) ? oal_htonl(FPP_IF_VLAN_CONF_CHECK) : 0U;
+					reply_buf->flags |= ((uint32_t)IF_FL_NONE != (uint32_t)pfe_phy_if_get_flag(phy_if, IF_FL_PTP_CONF_CHECK)) ? oal_htonl(FPP_IF_PTP_CONF_CHECK) : 0U;
+					reply_buf->flags |= ((uint32_t)IF_FL_NONE != (uint32_t)pfe_phy_if_get_flag(phy_if, IF_FL_PTP_PROMISC)) ? oal_htonl(FPP_IF_PTP_PROMISC) : 0U;
+					reply_buf->flags |= ((uint32_t)IF_FL_NONE != (uint32_t)pfe_phy_if_get_flag(phy_if, IF_FL_ALLOW_Q_IN_Q)) ? oal_htonl(FPP_IF_ALLOW_Q_IN_Q) : 0U;
+					reply_buf->flags |= ((uint32_t)IF_FL_NONE != (uint32_t)pfe_phy_if_get_flag(phy_if, IF_FL_DISCARD_TTL)) ? oal_htonl(FPP_IF_DISCARD_TTL) : 0U;
+
+					/* Get the mode - use the fact enums have same values */
+					reply_buf->mode = (fpp_phy_if_op_mode_t) pfe_phy_if_get_op_mode(phy_if);
+
+					/* Get the block state */
+					(void)pfe_phy_if_get_block_state(phy_if, &block_state);
+					/* Use the fact that the enums have same values */
+					reply_buf->block_state = (fpp_phy_if_block_state_t)block_state;
+
+					for(i = 0U; i < (uint32_t)FPP_MIRRORS_CNT; i++)
+					{
+						/* RX */
+						mirror = pfe_phy_if_get_rx_mirror(phy_if, i);
+						if(NULL != mirror)
+						{
+							str = pfe_mirror_get_name(mirror);
+							if(NULL != str)
+							{
+								(void)strncpy(&reply_buf->rx_mirrors[i][0], str, 16);
+								reply_buf->rx_mirrors[i][15] = '\0'; /* Ensure correct string end */
+							}
+							else
+							{
+								NXP_LOG_WARNING("Could not obtain mirror name for %u\n", (uint_t)addr);
+							}
+						}
+
+						/* TX */
+						mirror = pfe_phy_if_get_tx_mirror(phy_if, i);
+						if(NULL != mirror)
+						{
+							str = pfe_mirror_get_name(mirror);
+							if(NULL != str)
+							{
+								(void)strncpy(&reply_buf->tx_mirrors[i][0], str, 16);
+								reply_buf->tx_mirrors[i][15] = '\0'; /* Ensure correct string end */
+							}
+							else
+							{
+								NXP_LOG_WARNING("Could not obtain mirror name for %u\n", (uint_t)addr);
+							}
+						}
+					}
+
+					/*	Get filter info */
+					addr = pfe_phy_if_get_ftable(phy_if);
+					if (0U != addr)
 					{
-						(void)strncpy(&reply_buf->tx_mirrors[i][0], str, 16);
-						reply_buf->tx_mirrors[i][15] = '\0'; /* Ensure correct string end */
+						ret = fci_fp_db_get_table_from_addr(addr, &name);
+						if (EOK == ret)
+						{
+							(void)strncpy(reply_buf->ftable, name, sizeof(reply_buf->ftable) - 1U);
+						}
+						else
+						{
+							/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+							NXP_LOG_ERROR("Can't get table name from DB: %d\n", ret);
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							break;
+						}
 					}
 					else
 					{
-						NXP_LOG_WARNING("Could not obtain mirror name for %u\n", (uint_t)addr);
+						(void)memset(reply_buf->ftable, 0, sizeof(reply_buf->ftable));
 					}
-				}
-			}
 
-			/*	Get filter info */
-			addr = pfe_phy_if_get_ftable(phy_if);
-			if (0U != addr)
-			{
-				ret = fci_fp_db_get_table_from_addr(addr, &name);
-				if (EOK == ret)
-				{
-					(void)strncpy(reply_buf->ftable, name, sizeof(reply_buf->ftable) - 1U);
+					/* Set reply length end return OK */
+					*reply_len = sizeof(fpp_phy_if_cmd_t);
+					*fci_ret = FPP_ERR_OK;
+					ret = EOK;
+					break;
 				}
-				else
+
+				default:
 				{
-					/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-					NXP_LOG_ERROR("Can't get table name from DB: %d\n", ret);
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+					NXP_LOG_ERROR("Interface Command: Unknown action received: 0x%x\n", if_cmd->action);
+					*fci_ret = FPP_ERR_UNKNOWN_ACTION;
 					break;
 				}
 			}
-			else
-			{
-				(void)memset(reply_buf->ftable, 0, sizeof(reply_buf->ftable));
-			}
-
-			/* Set reply length end return OK */
-			*reply_len = sizeof(fpp_phy_if_cmd_t);
-			*fci_ret = FPP_ERR_OK;
-			ret = EOK;
-			break;
-		}
-
-		default:
-		{
-			NXP_LOG_ERROR("Interface Command: Unknown action received: 0x%x\n", if_cmd->action);
-			*fci_ret = FPP_ERR_UNKNOWN_ACTION;
-			break;
 		}
 	}
-
 	return ret;
 }
 
@@ -1434,189 +1440,191 @@ errno_t fci_interfaces_mac_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_if_mac_cmd
 	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	if (unlikely(FALSE == fci_context->fci_initialized))
+	else if (unlikely(FALSE == fci_context->fci_initialized))
 	{
 		NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	*fci_ret = FPP_ERR_OK;
-
-	if (*reply_len < sizeof(fpp_if_mac_cmd_t))
-	{
-		/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-		NXP_LOG_ERROR("Buffer length does not match expected value (fpp_if_mac_cmd_t)\n");
-		*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-		return EINVAL;
+		ret = EPERM;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		/* No data written to reply buffer (yet) */
-		*reply_len = 0U;
-	}
-
-	/* Initialize the reply buffer */
-	(void)memset(reply_buf, 0, sizeof(fpp_if_mac_cmd_t));
-
-	/* Initialize pointer to the command data */
-	if_mac_cmd = (fpp_if_mac_cmd_t *)msg->msg_cmd.payload;
-
-	/*	Preparation: get the requested interface */
-	{
-		ret = pfe_if_db_get_single(fci_context->phy_if_db, fci_context->if_session_id, IF_DB_CRIT_BY_NAME, if_mac_cmd->name, &entry);
+		*fci_ret = FPP_ERR_OK;
 
-		if(EOK != ret)
+		if (*reply_len < sizeof(fpp_if_mac_cmd_t))
 		{
-			/* DB not locked or locked by some other FCI user.*/
-			/* FCI command requested unfulfillable action. Respond with FCI error code. */
-			NXP_LOG_ERROR("Incorrect session ID detected\n");
-			*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
-			ret = EOK;
-			return ret;
+			/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+			NXP_LOG_ERROR("Buffer length does not match expected value (fpp_if_mac_cmd_t)\n");
+			*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+			ret = EINVAL;
 		}
-
-		/* Check if entry is not NULL and get physical interface */
-		if(NULL != entry)
+		else
 		{
-			phy_if = pfe_if_db_entry_get_phy_if(entry);
-		}
+			/* No data written to reply buffer (yet) */
+			*reply_len = 0U;
+			/* Initialize the reply buffer */
+			(void)memset(reply_buf, 0, sizeof(fpp_if_mac_cmd_t));
 
-		/* Check if the entry exists*/
-		if((NULL == entry) || (NULL == phy_if))
-		{
-			/* Parent physical interface doesn't exist or cannot be extracted from the entry. */
-			/* FCI command requested nonexistent entity. Respond with FCI error code. */
-			*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-			ret = EOK;
-			return ret;
-		}
-	}
+			/* Initialize pointer to the command data */
+			if_mac_cmd = (fpp_if_mac_cmd_t *)msg->msg_cmd.payload;
 
-	/* Process the command */
-	switch (if_mac_cmd->action)
-	{
-		case FPP_ACTION_REGISTER:
-		{
-			ret = pfe_phy_if_add_mac_addr(phy_if, if_mac_cmd->mac, PFE_CFG_LOCAL_IF);
-			if (EOK != ret)
+			/*	Preparation: get the requested interface */
 			{
-				if (EEXIST == ret)
-				{
-					/* FCI command attempted to register already registered entity. Respond with FCI error code. */
-					*fci_ret = FPP_ERR_IF_MAC_ALREADY_REGISTERED;
-					ret = EOK;
-					break;
-				}
-				if (EINVAL == ret)
+				ret = pfe_if_db_get_single(fci_context->phy_if_db, fci_context->if_session_id, IF_DB_CRIT_BY_NAME, if_mac_cmd->name, &entry);
+
+				if (EOK != ret)
 				{
+					/* DB not locked or locked by some other FCI user.*/
 					/* FCI command requested unfulfillable action. Respond with FCI error code. */
-					*fci_ret = FPP_ERR_IF_NOT_SUPPORTED;
+					NXP_LOG_ERROR("Incorrect session ID detected\n");
+					*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
 					ret = EOK;
-					break;
 				}
-			}
+				else
+				{
 
-			/* No further actions. */
-			break;
-		}
+					/* Check if entry is not NULL and get physical interface */
+					if (NULL != entry)
+					{
+						phy_if = pfe_if_db_entry_get_phy_if(entry);
+					}
 
-		case FPP_ACTION_DEREGISTER:
-		{
-			ret = pfe_phy_if_del_mac_addr(phy_if, if_mac_cmd->mac, PFE_CFG_LOCAL_IF);
-			if (EOK != ret)
-			{
-				if (ENOENT == ret)
-				{
-					/* FCI command requested nonexistent entity. Respond with FCI error code. */
-					*fci_ret = FPP_ERR_IF_MAC_NOT_FOUND;
-					ret = EOK;
-					break;
-				}
-				if (EINVAL == ret)
-				{
-					/* FCI command requested unfulfillable action. Respond with FCI error code. */
-					*fci_ret = FPP_ERR_IF_NOT_SUPPORTED;
-					ret = EOK;
-					break;
+					/* Check if the entry exists*/
+					if ((NULL == entry) || (NULL == phy_if))
+					{
+						/* Parent physical interface doesn't exist or cannot be extracted from the entry. */
+						/* FCI command requested nonexistent entity. Respond with FCI error code. */
+						*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
+						ret = EOK;
+					}
 				}
 			}
 
-			/*	No further actions. */
-			break;
-		}
-
-		case FPP_ACTION_QUERY:
-		{
-			ret = pfe_phy_if_get_mac_addr_first(phy_if, reply_buf->mac, MAC_DB_CRIT_ALL, PFE_TYPE_ANY, PFE_CFG_LOCAL_IF);
-			if (EOK != ret)
+			if (FPP_ERR_OK == *fci_ret)
 			{
-				if (ENOENT == ret)
-				{
-					/* End of the query process (no more entities to report). Respond with FCI error code. */
-					*fci_ret = FPP_ERR_IF_MAC_NOT_FOUND;
-					ret = EOK;
-					break;
-				}
-				if (EINVAL == ret)
+				/* Process the command */
+				switch (if_mac_cmd->action)
 				{
-					/* FCI command requested unfulfillable action. Respond with FCI error code. */
-					*fci_ret = FPP_ERR_IF_NOT_SUPPORTED;
-					ret = EOK;
-					break;
-				}
-			}
+					case FPP_ACTION_REGISTER:
+					{
+						ret = pfe_phy_if_add_mac_addr(phy_if, if_mac_cmd->mac, PFE_CFG_LOCAL_IF);
+						if (EOK != ret)
+						{
+							if (EEXIST == ret)
+							{
+								/* FCI command attempted to register already registered entity. Respond with FCI error code. */
+								*fci_ret = FPP_ERR_IF_MAC_ALREADY_REGISTERED;
+								ret = EOK;
+							}
+							if (EINVAL == ret)
+							{
+								/* FCI command requested unfulfillable action. Respond with FCI error code. */
+								*fci_ret = FPP_ERR_IF_NOT_SUPPORTED;
+								ret = EOK;
+							}
+						}
 
-			/* Store phy_if name into reply message */
-			(void)strncpy(reply_buf->name, pfe_phy_if_get_name(phy_if), (uint32_t)IFNAMSIZ-1U);
+						/* No further actions. */
+						break;
+					}
 
-			/* Set reply length and return OK */
-			*reply_len = sizeof(fpp_if_mac_cmd_t);
-			*fci_ret = FPP_ERR_OK;
-			ret = EOK;
-			break;
-		}
+					case FPP_ACTION_DEREGISTER:
+					{
+						ret = pfe_phy_if_del_mac_addr(phy_if, if_mac_cmd->mac, PFE_CFG_LOCAL_IF);
+						if (EOK != ret)
+						{
+							if (ENOENT == ret)
+							{
+								/* FCI command requested nonexistent entity. Respond with FCI error code. */
+								*fci_ret = FPP_ERR_IF_MAC_NOT_FOUND;
+								ret = EOK;
+							}
+							if (EINVAL == ret)
+							{
+								/* FCI command requested unfulfillable action. Respond with FCI error code. */
+								*fci_ret = FPP_ERR_IF_NOT_SUPPORTED;
+								ret = EOK;
+							}
+						}
 
-		case FPP_ACTION_QUERY_CONT:
-		{
-			ret = pfe_phy_if_get_mac_addr_next(phy_if, reply_buf->mac);
-			if (EOK != ret)
-			{
-				if (ENOENT == ret)
-				{
-					/* End of the query process (no more entities to report). Respond with FCI error code. */
-					*fci_ret = FPP_ERR_IF_MAC_NOT_FOUND;
-					ret = EOK;
-					break;
-				}
-				if (EINVAL == ret)
-				{
-					/* FCI command requested unfulfillable action. Respond with FCI error code. */
-					*fci_ret = FPP_ERR_IF_NOT_SUPPORTED;
-					ret = EOK;
-					break;
+						/*	No further actions. */
+						break;
+					}
+
+					case FPP_ACTION_QUERY:
+					{
+						ret = pfe_phy_if_get_mac_addr_first(phy_if, reply_buf->mac, MAC_DB_CRIT_ALL, PFE_TYPE_ANY, PFE_CFG_LOCAL_IF);
+						if (EOK != ret)
+						{
+							if (ENOENT == ret)
+							{
+								/* End of the query process (no more entities to report). Respond with FCI error code. */
+								*fci_ret = FPP_ERR_IF_MAC_NOT_FOUND;
+								ret = EOK;
+							}
+							if (EINVAL == ret)
+							{
+								/* FCI command requested unfulfillable action. Respond with FCI error code. */
+								*fci_ret = FPP_ERR_IF_NOT_SUPPORTED;
+								ret = EOK;
+							}
+						}
+
+						if (FPP_ERR_OK == *fci_ret)
+						{
+							/* Store phy_if name into reply message */
+							(void)strncpy(reply_buf->name, pfe_phy_if_get_name(phy_if), (uint32_t)IFNAMSIZ - 1U);
+
+							/* Set reply length and return OK */
+							*reply_len = sizeof(fpp_if_mac_cmd_t);
+							*fci_ret = FPP_ERR_OK;
+							ret = EOK;
+						}
+						break;
+					}
+
+					case FPP_ACTION_QUERY_CONT:
+					{
+						ret = pfe_phy_if_get_mac_addr_next(phy_if, reply_buf->mac);
+						if (EOK != ret)
+						{
+							if (ENOENT == ret)
+							{
+								/* End of the query process (no more entities to report). Respond with FCI error code. */
+								*fci_ret = FPP_ERR_IF_MAC_NOT_FOUND;
+								ret = EOK;
+							}
+							if (EINVAL == ret)
+							{
+								/* FCI command requested unfulfillable action. Respond with FCI error code. */
+								*fci_ret = FPP_ERR_IF_NOT_SUPPORTED;
+								ret = EOK;
+							}
+						}
+
+						if (FPP_ERR_OK == *fci_ret)
+						{ /* Store phy_if name into reply message */
+							(void)strncpy(reply_buf->name, pfe_phy_if_get_name(phy_if), (uint32_t)IFNAMSIZ - 1U);
+
+							/* Set reply length and return OK */
+							*reply_len = sizeof(fpp_if_mac_cmd_t);
+							*fci_ret = FPP_ERR_OK;
+							ret = EOK;
+						}
+						break;
+					}
+
+					default: 
+					{
+						/* Unknown action. Respond with FCI error code. */
+						NXP_LOG_ERROR("FPP_CMD_IF_MAC: Unknown action received: 0x%x\n", if_mac_cmd->action);
+						*fci_ret = FPP_ERR_UNKNOWN_ACTION;
+						ret = EOK;
+						break;
+					}
 				}
 			}
-			/* Store phy_if name into reply message */
-			(void)strncpy(reply_buf->name, pfe_phy_if_get_name(phy_if), (uint32_t)IFNAMSIZ-1U);
-
-			/* Set reply length and return OK */
-			*reply_len = sizeof(fpp_if_mac_cmd_t);
-			*fci_ret = FPP_ERR_OK;
-			ret = EOK;
-			break;
-		}
-
-		default:
-		{
-			/* Unknown action. Respond with FCI error code. */
-			NXP_LOG_ERROR("FPP_CMD_IF_MAC: Unknown action received: 0x%x\n", if_mac_cmd->action);
-			*fci_ret = FPP_ERR_UNKNOWN_ACTION;
-			ret = EOK;
-			break;
 		}
 	}
 
diff --git a/sw/fci/src/fci_l2br.c b/sw/fci/src/fci_l2br.c
index c2234c5..27d41b5 100644
--- a/sw/fci/src/fci_l2br.c
+++ b/sw/fci/src/fci_l2br.c
@@ -43,55 +43,57 @@ errno_t fci_l2br_flush_cmd(uint32_t code, uint16_t *fci_ret)
 	if (unlikely(NULL == fci_ret))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	*fci_ret = FPP_ERR_OK;
-
-	switch (code)
 	{
-		case FPP_CMD_L2_FLUSH_ALL:
+		*fci_ret = FPP_ERR_OK;
+
+		switch (code)
 		{
-			ret = pfe_l2br_flush_all(fci_context->l2_bridge);
-			if (EOK != ret)
+			case FPP_CMD_L2_FLUSH_ALL:
 			{
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				NXP_LOG_DEBUG("Can't flush MAC table entries: %d\n", ret);
+				ret = pfe_l2br_flush_all(fci_context->l2_bridge);
+				if (EOK != ret)
+				{
+					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+					NXP_LOG_DEBUG("Can't flush MAC table entries: %d\n", ret);
+				}
+
+				break;
 			}
 
-			break;
-		}
-
-		case FPP_CMD_L2_FLUSH_LEARNED:
-		{
-			ret = pfe_l2br_flush_learned(fci_context->l2_bridge);
-			if (EOK != ret)
+			case FPP_CMD_L2_FLUSH_LEARNED:
 			{
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				NXP_LOG_DEBUG("Can't flush learned MAC table entries: %d\n", ret);
+				ret = pfe_l2br_flush_learned(fci_context->l2_bridge);
+				if (EOK != ret)
+				{
+					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+					NXP_LOG_DEBUG("Can't flush learned MAC table entries: %d\n", ret);
+				}
+
+				break;
 			}
 
-			break;
-		}
-
-		case FPP_CMD_L2_FLUSH_STATIC:
-		{
-			ret = pfe_l2br_flush_static(fci_context->l2_bridge);
-			if (EOK != ret)
+			case FPP_CMD_L2_FLUSH_STATIC:
 			{
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				NXP_LOG_DEBUG("Can't flush static MAC table entries: %d\n", ret);
+				ret = pfe_l2br_flush_static(fci_context->l2_bridge);
+				if (EOK != ret)
+				{
+					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+					NXP_LOG_DEBUG("Can't flush static MAC table entries: %d\n", ret);
+				}
+
+				break;
 			}
 
-			break;
-		}
-
-		default:
-		{
-			NXP_LOG_ERROR("Unknown L2 bridge command: 0x%x\n", (uint_t)code);
-			*fci_ret = FPP_ERR_UNKNOWN_ACTION;
-			break;
+			default:
+			{
+				NXP_LOG_ERROR("Unknown L2 bridge command: 0x%x\n", (uint_t)code);
+				*fci_ret = FPP_ERR_UNKNOWN_ACTION;
+				break;
+			}
 		}
 	}
 
diff --git a/sw/fci/src/fci_l2br_domains.c b/sw/fci/src/fci_l2br_domains.c
index 2da2d32..3d2cfd5 100644
--- a/sw/fci/src/fci_l2br_domains.c
+++ b/sw/fci/src/fci_l2br_domains.c
@@ -59,359 +59,361 @@ errno_t fci_l2br_domain_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_l2_bd_cmd_t *
 	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-    if (unlikely(FALSE == fci_context->fci_initialized))
+	else if (unlikely(FALSE == fci_context->fci_initialized))
 	{
     	NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (*reply_len < sizeof(fpp_l2_bd_cmd_t))
-	{
-		NXP_LOG_ERROR("Buffer length does not match expected value (fpp_l2_bd_cmd_t)\n");
-		return EINVAL;
+		ret = EPERM;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		/*	No data written to reply buffer (yet) */
-		*reply_len = 0U;
-	}
-
-	bd_cmd = (fpp_l2_bd_cmd_t *)(msg->msg_cmd.payload);
-
-	/*	Initialize the reply buffer */
-	(void)memset(reply_buf, 0, sizeof(fpp_l2_bd_cmd_t));
-
-	ret = pfe_if_db_lock(&session_id);
-
-	if(EOK != ret)
-	{
-		*fci_ret = FPP_ERR_IF_RESOURCE_ALREADY_LOCKED;
-		return EOK;
-	}
-
-	switch (bd_cmd->action)
-	{
-		case FPP_ACTION_REGISTER:
+		if (*reply_len < sizeof(fpp_l2_bd_cmd_t))
 		{
-			/*	Check input values. We need to translate integer to pfe_ct_l2br_action_t therefore
-			 	some validation needs to be performed first. */
-			if ((bd_cmd->ucast_hit > 3U) || (bd_cmd->ucast_miss > 3U)
-					|| (bd_cmd->mcast_hit > 3U) || (bd_cmd->mcast_miss > 3U))
-			{
-				NXP_LOG_ERROR("Unsupported action code received\n");
-				*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-				ret = EOK;
-				break;
-			}
-
-			if (oal_ntohs(bd_cmd->vlan) <= 1U)
-			{
-				/*	0 - fall-back, 1 - default */
-				NXP_LOG_ERROR("VLAN %d is reserved\n", oal_ntohs(bd_cmd->vlan));
-				*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-				ret = EOK;
-				break;
-			}
-
-			/*	Add new bridge domain */
-			ret = pfe_l2br_domain_create(fci_context->l2_bridge, oal_ntohs(bd_cmd->vlan));
-			if (EPERM == ret)
-			{
-				NXP_LOG_ERROR("Domain %d already created\n", oal_ntohs(bd_cmd->vlan));
-				*fci_ret = FPP_ERR_L2_BD_ALREADY_REGISTERED;
-				ret = EOK;
-				break;
-			}
-			else if (EOK != ret)
-			{
-				NXP_LOG_ERROR("Domain creation failed: %d\n", ret);
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				break;
-			}
-			else
-			{
-				NXP_LOG_DEBUG("Bridge domain %d created\n", oal_ntohs(bd_cmd->vlan));
-			}
+			NXP_LOG_ERROR("Buffer length does not match expected value (fpp_l2_bd_cmd_t)\n");
+			ret = EINVAL;
 		}
-		/* FALLTHRU */
-
-		case FPP_ACTION_UPDATE:
+		else
 		{
-			/*	Check input values. We need to translate integer to pfe_ct_l2br_action_t therefore
-				some validation needs to be performed first. */
-			if ((bd_cmd->ucast_hit > 3U) || (bd_cmd->ucast_miss > 3U)
-					|| (bd_cmd->mcast_hit > 3U) || (bd_cmd->mcast_miss > 3U))
-			{
-				NXP_LOG_ERROR("Unsupported action code received\n");
-				*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-				ret = EOK;
-				break;
-			}
+			/*	No data written to reply buffer (yet) */
+			*reply_len = 0U;
+			bd_cmd = (fpp_l2_bd_cmd_t *)(msg->msg_cmd.payload);
 
-			/*	Get the domain instance (by VLAN) */
-			domain = pfe_l2br_get_first_domain(fci_context->l2_bridge, L2BD_CRIT_BY_VLAN, (void *)(addr_t)oal_ntohs(bd_cmd->vlan));
-			if (NULL == domain)
-			{
-				/*	This shall never happen */
-				NXP_LOG_DEBUG("New domain not found\n");
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				ret = ENOENT;
-				goto finalize_domain_registration;
-			}
+			/*	Initialize the reply buffer */
+			(void)memset(reply_buf, 0, sizeof(fpp_l2_bd_cmd_t));
 
-			/*	Set hit/miss actions */
-			ret = pfe_l2br_domain_set_ucast_action(domain, fci_to_l2br_action[bd_cmd->ucast_hit], fci_to_l2br_action[bd_cmd->ucast_miss]);
-			if (EOK != ret)
-			{
-				NXP_LOG_DEBUG("Could not set uni-cast actions: %d\n", ret);
-				goto finalize_domain_registration;
-			}
+			ret = pfe_if_db_lock(&session_id);
 
-			ret = pfe_l2br_domain_set_mcast_action(domain, fci_to_l2br_action[bd_cmd->mcast_hit], fci_to_l2br_action[bd_cmd->mcast_miss]);
-			if (EOK != ret)
+			if(EOK != ret)
 			{
-				NXP_LOG_DEBUG("Could not set multi-cast actions: %d\n", ret);
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				goto finalize_domain_registration;
+				*fci_ret = FPP_ERR_IF_RESOURCE_ALREADY_LOCKED;
+				ret = EOK;
 			}
-
-			*fci_ret = FPP_ERR_OK;
-
-			/*	Review if_list and untag_if_list and verify if contains valid interfaces. Valid interfaces
-			 	are interfaces, which are known to the internal FCI database. Note that FCI API is using
-			 	integer indexes to identify the physical interfaces but rest of SW works with pfe_phy_if_t
-			 	instances. */
-			for (ii=0U; ((ii < (8U * sizeof(bd_cmd->if_list))) && (ii <= (uint32_t)PFE_PHY_IF_ID_MAX)); ii++)
+			else
 			{
-				/*	Check if interface shall be added or removed */
-				if (0U != (oal_ntohl(bd_cmd->if_list) & (1U << ii)))
+				switch (bd_cmd->action)
 				{
-					/*	Only add interfaces which are known to platform interface database */
-					ret = pfe_if_db_get_first(fci_context->phy_if_db, session_id, IF_DB_CRIT_BY_ID, (void *)(addr_t)ii, &if_db_entry);
-
-					if(EOK != ret)
+					case FPP_ACTION_REGISTER:
 					{
-						NXP_LOG_DEBUG("DB was locked in different session, entry wasn't retrieved from DB\n");
-						*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
-						break;
+						/*	Check input values. We need to translate integer to pfe_ct_l2br_action_t therefore
+							some validation needs to be performed first. */
+						if ((bd_cmd->ucast_hit > 3U) || (bd_cmd->ucast_miss > 3U)
+								|| (bd_cmd->mcast_hit > 3U) || (bd_cmd->mcast_miss > 3U))
+						{
+							NXP_LOG_ERROR("Unsupported action code received\n");
+							*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+							ret = EOK;
+							break;
+						}
+
+						if (oal_ntohs(bd_cmd->vlan) <= 1U)
+						{
+							/*	0 - fall-back, 1 - default */
+							NXP_LOG_ERROR("VLAN %d is reserved\n", oal_ntohs(bd_cmd->vlan));
+							*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+							ret = EOK;
+							break;
+						}
+
+						/*	Add new bridge domain */
+						ret = pfe_l2br_domain_create(fci_context->l2_bridge, oal_ntohs(bd_cmd->vlan));
+						if (EPERM == ret)
+						{
+							NXP_LOG_ERROR("Domain %d already created\n", oal_ntohs(bd_cmd->vlan));
+							*fci_ret = FPP_ERR_L2_BD_ALREADY_REGISTERED;
+							ret = EOK;
+							break;
+						}
+						else if (EOK != ret)
+						{
+							NXP_LOG_ERROR("Domain creation failed: %d\n", ret);
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							break;
+						}
+						else
+						{
+							NXP_LOG_DEBUG("Bridge domain %d created\n", oal_ntohs(bd_cmd->vlan));
+						}
 					}
+					/* FALLTHRU */
 
-					if (NULL != if_db_entry)
+					case FPP_ACTION_UPDATE:
 					{
-						/*	Got valid physical interface */
-						tag = (0U == (oal_ntohl(bd_cmd->untag_if_list) & (1U << ii)));
+						/*	Check input values. We need to translate integer to pfe_ct_l2br_action_t therefore
+							some validation needs to be performed first. */
+						if ((bd_cmd->ucast_hit > 3U) || (bd_cmd->ucast_miss > 3U)
+								|| (bd_cmd->mcast_hit > 3U) || (bd_cmd->mcast_miss > 3U))
+						{
+							NXP_LOG_ERROR("Unsupported action code received\n");
+							*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+							ret = EOK;
+							break;
+						}
 
-						/* Get physical interface */
-						phy_if = pfe_if_db_entry_get_phy_if(if_db_entry);
+						/*	Get the domain instance (by VLAN) */
+						domain = pfe_l2br_get_first_domain(fci_context->l2_bridge, L2BD_CRIT_BY_VLAN, (void *)(addr_t)oal_ntohs(bd_cmd->vlan));
+						if (NULL == domain)
+						{
+							/*	This shall never happen */
+							NXP_LOG_DEBUG("New domain not found\n");
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							ret = ENOENT;
+							goto finalize_domain_registration;
+						}
 
-						/*	Add it to domain */
-						ret = pfe_l2br_domain_add_if(domain, phy_if, tag);
-						if (EEXIST == ret)
+						/*	Set hit/miss actions */
+						ret = pfe_l2br_domain_set_ucast_action(domain, fci_to_l2br_action[bd_cmd->ucast_hit], fci_to_l2br_action[bd_cmd->ucast_miss]);
+						if (EOK != ret)
 						{
-							/*	Already added. Update = remove old -> add new. Update is only due
-							 	to tag/untag flag. */
-							ret = pfe_l2br_domain_del_if(domain, phy_if);
-							if (EOK != ret)
-							{
-								NXP_LOG_ERROR("Could not update interface within bridge domain: %d\n", ret);
-								break; /* break the 'for' loop */
-							}
+							NXP_LOG_DEBUG("Could not set uni-cast actions: %d\n", ret);
+							goto finalize_domain_registration;
+						}
 
-							ret = pfe_l2br_domain_add_if(domain, phy_if, tag);
-							if (EOK != ret)
+						ret = pfe_l2br_domain_set_mcast_action(domain, fci_to_l2br_action[bd_cmd->mcast_hit], fci_to_l2br_action[bd_cmd->mcast_miss]);
+						if (EOK != ret)
+						{
+							NXP_LOG_DEBUG("Could not set multi-cast actions: %d\n", ret);
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							goto finalize_domain_registration;
+						}
+
+						*fci_ret = FPP_ERR_OK;
+
+						/*	Review if_list and untag_if_list and verify if contains valid interfaces. Valid interfaces
+							are interfaces, which are known to the internal FCI database. Note that FCI API is using
+							integer indexes to identify the physical interfaces but rest of SW works with pfe_phy_if_t
+							instances. */
+						for (ii=0U; ((ii < (8U * sizeof(bd_cmd->if_list))) && (ii <= (uint32_t)PFE_PHY_IF_ID_MAX)); ii++)
+						{
+							/*	Check if interface shall be added or removed */
+							if (0U != (oal_ntohl(bd_cmd->if_list) & (1U << ii)))
 							{
-								NXP_LOG_ERROR("Could not update interface within bridge domain: %d\n", ret);
-								break; /* break the 'for' loop */
+								/*	Only add interfaces which are known to platform interface database */
+								ret = pfe_if_db_get_first(fci_context->phy_if_db, session_id, IF_DB_CRIT_BY_ID, (void *)(addr_t)ii, &if_db_entry);
+
+								if(EOK != ret)
+								{
+									NXP_LOG_DEBUG("DB was locked in different session, entry wasn't retrieved from DB\n");
+									*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
+									break;
+								}
+
+								if (NULL != if_db_entry)
+								{
+									/*	Got valid physical interface */
+									tag = (0U == (oal_ntohl(bd_cmd->untag_if_list) & (1U << ii)));
+
+									/* Get physical interface */
+									phy_if = pfe_if_db_entry_get_phy_if(if_db_entry);
+
+									/*	Add it to domain */
+									ret = pfe_l2br_domain_add_if(domain, phy_if, tag);
+									if (EEXIST == ret)
+									{
+										/*	Already added. Update = remove old -> add new. Update is only due
+											to tag/untag flag. */
+										ret = pfe_l2br_domain_del_if(domain, phy_if);
+										if (EOK != ret)
+										{
+											NXP_LOG_ERROR("Could not update interface within bridge domain: %d\n", ret);
+											break; /* break the 'for' loop */
+										}
+
+										ret = pfe_l2br_domain_add_if(domain, phy_if, tag);
+										if (EOK != ret)
+										{
+											NXP_LOG_ERROR("Could not update interface within bridge domain: %d\n", ret);
+											break; /* break the 'for' loop */
+										}
+										else
+										{
+											NXP_LOG_INFO("Domain %d: Interface %d updated\n", (int_t)oal_ntohs(bd_cmd->vlan), (int_t)ii);
+										}
+									}
+									else if (EOK != ret)
+									{
+										NXP_LOG_ERROR("Could not add interface to bridge domain: %d\n", ret);
+										break; /* break the 'for' loop */
+									}
+									else
+									{
+										/*	Added */
+										NXP_LOG_INFO("Domain %d: Interface %d added\n", (int_t)oal_ntohs(bd_cmd->vlan), (int_t)ii);
+									}
+								}
+								else
+								{
+									/*	Interface list contains interface not found in FCI database */
+									NXP_LOG_ERROR("Interface %d not found\n", (int_t)ii);
+									*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+									ret = EOK;
+									break; /* break the 'for' loop */
+								}
 							}
 							else
 							{
-								NXP_LOG_INFO("Domain %d: Interface %d updated\n", (int_t)oal_ntohs(bd_cmd->vlan), (int_t)ii);
+								/*	Remove the interface if domain does contain it */
+								phy_if = pfe_l2br_domain_get_first_if(domain, L2BD_IF_BY_PHY_IF_ID, (void *)(addr_t)ii);
+								if (NULL != phy_if)
+								{
+									ret = fci_l2br_domain_remove_if(domain, phy_if);
+									if (EOK != ret)
+									{
+										*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+										NXP_LOG_ERROR("Domain %d: Failed to remove interface %d\n", (int_t)oal_ntohs(bd_cmd->vlan), (int_t)ii);
+										break;
+									}
+									else
+									{
+										NXP_LOG_INFO("Domain %d: Interface %d removed\n", (int_t)oal_ntohs(bd_cmd->vlan), (int_t)ii);
+									}
+								}
 							}
 						}
-						else if (EOK != ret)
+
+			finalize_domain_registration:
+						if ((EOK != ret) && (FPP_ACTION_REGISTER == bd_cmd->action))
+						{
+							/*	New domain has not been properly created. Gracefully revert here. */
+							if (EOK != fci_l2br_domain_remove(domain))
+							{
+								NXP_LOG_ERROR("Could not revert domain creation\n");
+							}
+
+							/*	Report failure */
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+						}
+
+						break;
+					}
+
+					case FPP_ACTION_DEREGISTER:
+					{
+						if (oal_ntohs(bd_cmd->vlan) <= 1U)
 						{
-							NXP_LOG_ERROR("Could not add interface to bridge domain: %d\n", ret);
-							break; /* break the 'for' loop */
+							/*	0 - fall-back, 1 - default */
+							NXP_LOG_ERROR("VLAN %d is reserved\n", oal_ntohs(bd_cmd->vlan));
+							*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+							ret = EOK;
+							break;
+						}
+
+						/*	Get and delete bridge domain */
+						domain = pfe_l2br_get_first_domain(fci_context->l2_bridge, L2BD_CRIT_BY_VLAN, (void *)(addr_t)oal_ntohs(bd_cmd->vlan));
+						if (NULL == domain)
+						{
+							NXP_LOG_ERROR("Domain %d not found\n", oal_ntohs(bd_cmd->vlan));
+							*fci_ret = FPP_ERR_L2_BD_NOT_FOUND;
+							ret = EOK;
 						}
 						else
 						{
-							/*	Added */
-							NXP_LOG_INFO("Domain %d: Interface %d added\n", (int_t)oal_ntohs(bd_cmd->vlan), (int_t)ii);
+							/*	Remove domain, release interfaces */
+							ret = fci_l2br_domain_remove(domain);
+							if (EOK != ret)
+							{
+								NXP_LOG_ERROR("Could not destroy bridge domain: %d\n", ret);
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							}
+							else
+							{
+								NXP_LOG_DEBUG("Bridge domain %d removed\n", oal_ntohs(bd_cmd->vlan));
+							}
 						}
+
+						break;
 					}
-					else
+
+					case FPP_ACTION_QUERY:
 					{
-						/*	Interface list contains interface not found in FCI database */
-						NXP_LOG_ERROR("Interface %d not found\n", (int_t)ii);
-						*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-						ret = EOK;
-						break; /* break the 'for' loop */
+						domain = pfe_l2br_get_first_domain(fci_context->l2_bridge, L2BD_CRIT_ALL, NULL);
+						if (NULL == domain)
+						{
+							ret = EOK;
+							*fci_ret = FPP_ERR_L2_BD_NOT_FOUND;
+							break;
+						}
 					}
-				}
-				else
-				{
-					/*	Remove the interface if domain does contain it */
-					phy_if = pfe_l2br_domain_get_first_if(domain, L2BD_IF_BY_PHY_IF_ID, (void *)(addr_t)ii);
-					if (NULL != phy_if)
+					/* FALLTHRU */
+
+					case FPP_ACTION_QUERY_CONT:
 					{
-						ret = fci_l2br_domain_remove_if(domain, phy_if);
-						if (EOK != ret)
+						if (NULL == domain)
+						{
+							domain = pfe_l2br_get_next_domain(fci_context->l2_bridge);
+							if (NULL == domain)
+							{
+								ret = EOK;
+								*fci_ret = FPP_ERR_L2_BD_NOT_FOUND;
+								break;
+							}
+						}
+
+						/*	Write the reply buffer */
+						bd_cmd = reply_buf;
+						*reply_len = sizeof(fpp_l2_bd_cmd_t);
+
+						/*	Build reply structure */
+						if (EOK != pfe_l2br_domain_get_vlan(domain, &bd_cmd->vlan))
 						{
 							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-							NXP_LOG_ERROR("Domain %d: Failed to remove interface %d\n", (int_t)oal_ntohs(bd_cmd->vlan), (int_t)ii);
 							break;
 						}
 						else
 						{
-							NXP_LOG_INFO("Domain %d: Interface %d removed\n", (int_t)oal_ntohs(bd_cmd->vlan), (int_t)ii);
+							/*	Endian... */
+							bd_cmd->vlan = oal_htons(bd_cmd->vlan);
 						}
-					}
-				}
-			}
 
-finalize_domain_registration:
-			if ((EOK != ret) && (FPP_ACTION_REGISTER == bd_cmd->action))
-			{
-				/*	New domain has not been properly created. Gracefully revert here. */
-				if (EOK != fci_l2br_domain_remove(domain))
-				{
-					NXP_LOG_ERROR("Could not revert domain creation\n");
-				}
+						if (EOK != pfe_l2br_domain_get_ucast_action(domain, (pfe_ct_l2br_action_t *)&bd_cmd->ucast_hit, (pfe_ct_l2br_action_t *)&bd_cmd->ucast_miss))
+						{
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							break;
+						}
 
-				/*	Report failure */
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-			}
+						if (EOK != pfe_l2br_domain_get_mcast_action(domain, (pfe_ct_l2br_action_t *)&bd_cmd->mcast_hit, (pfe_ct_l2br_action_t *)&bd_cmd->mcast_miss))
+						{
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							break;
+						}
 
-			break;
-		}
+						if (TRUE == pfe_l2br_domain_is_default(domain))
+						{
+							bd_cmd->flags |= FPP_L2_BD_DEFAULT;
+						}
 
-		case FPP_ACTION_DEREGISTER:
-		{
-			if (oal_ntohs(bd_cmd->vlan) <= 1U)
-			{
-				/*	0 - fall-back, 1 - default */
-				NXP_LOG_ERROR("VLAN %d is reserved\n", oal_ntohs(bd_cmd->vlan));
-				*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-				ret = EOK;
-				break;
-			}
+						if (TRUE == pfe_l2br_domain_is_fallback(domain))
+						{
+							bd_cmd->flags |= FPP_L2_BD_FALLBACK;
+						}
 
-			/*	Get and delete bridge domain */
-			domain = pfe_l2br_get_first_domain(fci_context->l2_bridge, L2BD_CRIT_BY_VLAN, (void *)(addr_t)oal_ntohs(bd_cmd->vlan));
-			if (NULL == domain)
-			{
-				NXP_LOG_ERROR("Domain %d not found\n", oal_ntohs(bd_cmd->vlan));
-				*fci_ret = FPP_ERR_L2_BD_NOT_FOUND;
-				ret = EOK;
-			}
-			else
-			{
-				/*	Remove domain, release interfaces */
-				ret = fci_l2br_domain_remove(domain);
-				if (EOK != ret)
-				{
-					NXP_LOG_ERROR("Could not destroy bridge domain: %d\n", ret);
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				}
-				else
-				{
-					NXP_LOG_DEBUG("Bridge domain %d removed\n", oal_ntohs(bd_cmd->vlan));
-				}
-			}
+						bd_cmd->if_list = oal_htonl(pfe_l2br_domain_get_if_list(domain));
+						bd_cmd->untag_if_list = oal_htonl(pfe_l2br_domain_get_untag_if_list(domain));
 
-			break;
-		}
+						*fci_ret = FPP_ERR_OK;
+						ret = EOK;
 
-		case FPP_ACTION_QUERY:
-		{
-			domain = pfe_l2br_get_first_domain(fci_context->l2_bridge, L2BD_CRIT_ALL, NULL);
-			if (NULL == domain)
-			{
-				ret = EOK;
-				*fci_ret = FPP_ERR_L2_BD_NOT_FOUND;
-				break;
-			}
-		}
-		/* FALLTHRU */
+						break;
+					}
 
-		case FPP_ACTION_QUERY_CONT:
-		{
-			if (NULL == domain)
-			{
-				domain = pfe_l2br_get_next_domain(fci_context->l2_bridge);
-				if (NULL == domain)
-				{
-					ret = EOK;
-					*fci_ret = FPP_ERR_L2_BD_NOT_FOUND;
-					break;
+					default:
+					{
+						NXP_LOG_ERROR("FPP_CMD_L2_BD: Unknown action received: 0x%x\n", bd_cmd->action);
+						*fci_ret = FPP_ERR_UNKNOWN_ACTION;
+						break;
+					}
 				}
-			}
-
-			/*	Write the reply buffer */
-			bd_cmd = reply_buf;
-			*reply_len = sizeof(fpp_l2_bd_cmd_t);
-
-			/*	Build reply structure */
-			if (EOK != pfe_l2br_domain_get_vlan(domain, &bd_cmd->vlan))
-			{
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				break;
-			}
-			else
-			{
-				/*	Endian... */
-				bd_cmd->vlan = oal_htons(bd_cmd->vlan);
-			}
-
-			if (EOK != pfe_l2br_domain_get_ucast_action(domain, (pfe_ct_l2br_action_t *)&bd_cmd->ucast_hit, (pfe_ct_l2br_action_t *)&bd_cmd->ucast_miss))
-			{
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				break;
-			}
-
-			if (EOK != pfe_l2br_domain_get_mcast_action(domain, (pfe_ct_l2br_action_t *)&bd_cmd->mcast_hit, (pfe_ct_l2br_action_t *)&bd_cmd->mcast_miss))
-			{
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				break;
-			}
 
-			if (TRUE == pfe_l2br_domain_is_default(domain))
-			{
-				bd_cmd->flags |= FPP_L2_BD_DEFAULT;
-			}
-
-			if (TRUE == pfe_l2br_domain_is_fallback(domain))
-			{
-				bd_cmd->flags |= FPP_L2_BD_FALLBACK;
+				if (EOK != pfe_if_db_unlock(session_id))
+				{
+					*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
+					NXP_LOG_DEBUG("DB unlock failed\n");
+				}
 			}
 
-			bd_cmd->if_list = oal_htonl(pfe_l2br_domain_get_if_list(domain));
-			bd_cmd->untag_if_list = oal_htonl(pfe_l2br_domain_get_untag_if_list(domain));
-
-			*fci_ret = FPP_ERR_OK;
-			ret = EOK;
-
-			break;
-		}
-
-		default:
-		{
-			NXP_LOG_ERROR("FPP_CMD_L2_BD: Unknown action received: 0x%x\n", bd_cmd->action);
-			*fci_ret = FPP_ERR_UNKNOWN_ACTION;
-			break;
 		}
 	}
-
-	if (EOK != pfe_if_db_unlock(session_id))
-	{
-		*fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
-		NXP_LOG_DEBUG("DB unlock failed\n");
-	}
-
 	return ret;
 }
 
@@ -437,170 +439,175 @@ errno_t fci_l2br_static_entry_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_l2_stat
 	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-    if (unlikely(FALSE == fci_context->fci_initialized))
+	else if (unlikely(FALSE == fci_context->fci_initialized))
 	{
     	NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (*reply_len < sizeof(fpp_l2_static_ent_cmd_t))
-	{
-		NXP_LOG_ERROR("Buffer length does not match expected value (fpp_l2_static_ent_cmd_t)\n");
-		return EINVAL;
+		ret = EPERM;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		/*	No data written to reply buffer (yet) */
-		*reply_len = 0U;
-	}
-
-	br_ent_cmd = (fpp_l2_static_ent_cmd_t *)(msg->msg_cmd.payload);
-
-	/*	Initialize the reply buffer */
-	(void)memset(reply_buf, 0, sizeof(fpp_l2_static_ent_cmd_t));
-
-	switch (br_ent_cmd->action)
-	{
-		case FPP_ACTION_REGISTER:
+		if (*reply_len < sizeof(fpp_l2_static_ent_cmd_t))
 		{
-			valid_if_list = fci_l2br_static_entry_get_valid_fw_list();
-			/* Check if valid logical interfaces are requested */
-			if (oal_ntohl(br_ent_cmd->forward_list) != (oal_ntohl(br_ent_cmd->forward_list) & valid_if_list))
-			{
-				NXP_LOG_ERROR("Invalid interfaces in forward list\n");
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				return EOK;
-			}
-
-			(void)memcpy(mac, br_ent_cmd->mac, sizeof(pfe_mac_addr_t));
-			ret = pfe_l2br_static_entry_create(fci_context->l2_bridge, oal_ntohs(br_ent_cmd->vlan), mac, oal_ntohl(br_ent_cmd->forward_list));
-			if (EOK == ret) {
-				NXP_LOG_DEBUG("Static entry %02x:%02x:%02x:%02x:%02x:%02x added to vlan %d\n", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5], oal_ntohs(br_ent_cmd->vlan));
-				*fci_ret = FPP_ERR_OK;
-			}
-			else if (EPERM == ret)
-			{
-				NXP_LOG_WARNING("Duplicit static entry %02x:%02x:%02x:%02x:%02x:%02x wasn't added to vlan %d\n", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5], oal_ntohs(br_ent_cmd->vlan));
-				*fci_ret = FPP_ERR_L2_STATIC_ENT_ALREADY_REGISTERED;
-			}
-			else
-			{
-				NXP_LOG_ERROR("Static entry %02x:%02x:%02x:%02x:%02x:%02x wasn't added to vlan %d\n", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5], oal_ntohs(br_ent_cmd->vlan));
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-			}
-			break;
+			NXP_LOG_ERROR("Buffer length does not match expected value (fpp_l2_static_ent_cmd_t)\n");
+			ret = EINVAL;
 		}
-		case FPP_ACTION_UPDATE:
+		else
 		{
-			valid_if_list = fci_l2br_static_entry_get_valid_fw_list();
-			/* Check if valid logical interfaces are requested */
-			if (oal_ntohl(br_ent_cmd->forward_list) != (oal_ntohl(br_ent_cmd->forward_list) & valid_if_list))
-			{
-				NXP_LOG_ERROR("Invalid interfaces in forward list\n");
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				return EOK;
-			}
+			/*	No data written to reply buffer (yet) */
+			*reply_len = 0U;
+			br_ent_cmd = (fpp_l2_static_ent_cmd_t *)(msg->msg_cmd.payload);
 
-			/* search for entry update fw list */
-			entry = pfe_l2br_static_entry_get_first(fci_context->l2_bridge, L2SENT_CRIT_BY_MAC_VLAN, (void*)(addr_t)oal_ntohs(br_ent_cmd->vlan), (void*)br_ent_cmd->mac);
-			if (NULL == entry)
-			{
-				*fci_ret = FPP_ERR_L2_STATIC_EN_NOT_FOUND;
-			}
-			else
-			{
-				*fci_ret = FPP_ERR_OK;
+			/*	Initialize the reply buffer */
+			(void)memset(reply_buf, 0, sizeof(fpp_l2_static_ent_cmd_t));
 
-				if (EOK != pfe_l2br_static_entry_replace_fw_list(fci_context->l2_bridge, entry, oal_ntohl(br_ent_cmd->forward_list)))
+			switch (br_ent_cmd->action)
+			{
+				case FPP_ACTION_REGISTER:
 				{
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+					valid_if_list = fci_l2br_static_entry_get_valid_fw_list();
+					/* Check if valid logical interfaces are requested */
+					if (oal_ntohl(br_ent_cmd->forward_list) != (oal_ntohl(br_ent_cmd->forward_list) & valid_if_list))
+					{
+						NXP_LOG_ERROR("Invalid interfaces in forward list\n");
+						*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+						ret = EOK;
+					}
+					else
+					{
+						(void)memcpy(mac, br_ent_cmd->mac, sizeof(pfe_mac_addr_t));
+						ret = pfe_l2br_static_entry_create(fci_context->l2_bridge, oal_ntohs(br_ent_cmd->vlan), mac, oal_ntohl(br_ent_cmd->forward_list));
+						if (EOK == ret) {
+							NXP_LOG_DEBUG("Static entry %02x:%02x:%02x:%02x:%02x:%02x added to vlan %d\n", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5], oal_ntohs(br_ent_cmd->vlan));
+							*fci_ret = FPP_ERR_OK;
+						}
+						else if (EPERM == ret)
+						{
+							NXP_LOG_WARNING("Duplicit static entry %02x:%02x:%02x:%02x:%02x:%02x wasn't added to vlan %d\n", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5], oal_ntohs(br_ent_cmd->vlan));
+							*fci_ret = FPP_ERR_L2_STATIC_ENT_ALREADY_REGISTERED;
+						}
+						else
+						{
+							NXP_LOG_ERROR("Static entry %02x:%02x:%02x:%02x:%02x:%02x wasn't added to vlan %d\n", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5], oal_ntohs(br_ent_cmd->vlan));
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+						}
+					}
+					break;
 				}
-				if (EOK != pfe_l2br_static_entry_set_local_flag(fci_context->l2_bridge, entry, br_ent_cmd->local))
+				case FPP_ACTION_UPDATE:
 				{
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+					valid_if_list = fci_l2br_static_entry_get_valid_fw_list();
+					/* Check if valid logical interfaces are requested */
+					if (oal_ntohl(br_ent_cmd->forward_list) != (oal_ntohl(br_ent_cmd->forward_list) & valid_if_list))
+					{
+						NXP_LOG_ERROR("Invalid interfaces in forward list\n");
+						*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+						ret = EOK;
+					}
+					else
+					{
+						/* search for entry update fw list */
+						entry = pfe_l2br_static_entry_get_first(fci_context->l2_bridge, L2SENT_CRIT_BY_MAC_VLAN, (void*)(addr_t)oal_ntohs(br_ent_cmd->vlan), (void*)br_ent_cmd->mac);
+						if (NULL == entry)
+						{
+							*fci_ret = FPP_ERR_L2_STATIC_EN_NOT_FOUND;
+						}
+						else
+						{
+							*fci_ret = FPP_ERR_OK;
+
+							if (EOK != pfe_l2br_static_entry_replace_fw_list(fci_context->l2_bridge, entry, oal_ntohl(br_ent_cmd->forward_list)))
+							{
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							}
+							if (EOK != pfe_l2br_static_entry_set_local_flag(fci_context->l2_bridge, entry, br_ent_cmd->local))
+							{
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							}
+							if (EOK != pfe_l2br_static_entry_set_src_discard_flag(fci_context->l2_bridge, entry, br_ent_cmd->src_discard))
+							{
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							}
+							if (EOK != pfe_l2br_static_entry_set_dst_discard_flag(fci_context->l2_bridge, entry, br_ent_cmd->dst_discard))
+							{
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							}
+						}
+					}
+					break;
 				}
-				if (EOK != pfe_l2br_static_entry_set_src_discard_flag(fci_context->l2_bridge, entry, br_ent_cmd->src_discard))
+				case FPP_ACTION_DEREGISTER:
 				{
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+					/* search for entry and delete if the entery exists */
+					entry = pfe_l2br_static_entry_get_first(fci_context->l2_bridge, L2SENT_CRIT_BY_MAC_VLAN, (void*)(addr_t)oal_ntohs(br_ent_cmd->vlan), (void*)br_ent_cmd->mac);
+					if (NULL == entry)
+					{
+						*fci_ret = FPP_ERR_L2_STATIC_EN_NOT_FOUND;
+					}
+					else
+					{
+						*fci_ret = FPP_ERR_OK;
+
+						if (EOK != pfe_l2br_static_entry_destroy(fci_context->l2_bridge, entry))
+						{
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+						}
+					}
+					break;
 				}
-				if (EOK != pfe_l2br_static_entry_set_dst_discard_flag(fci_context->l2_bridge, entry, br_ent_cmd->dst_discard))
+				case FPP_ACTION_QUERY:
 				{
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+					entry = pfe_l2br_static_entry_get_first(fci_context->l2_bridge, L2SENT_CRIT_ALL, NULL, NULL);
+					if (NULL == entry)
+					{
+						ret = EOK;
+						*fci_ret = FPP_ERR_L2_STATIC_EN_NOT_FOUND;
+						break;
+					}
 				}
-			}
-			break;
-		}
-		case FPP_ACTION_DEREGISTER:
-		{
-			/* search for entry and delete if the entery exists */
-			entry = pfe_l2br_static_entry_get_first(fci_context->l2_bridge, L2SENT_CRIT_BY_MAC_VLAN, (void*)(addr_t)oal_ntohs(br_ent_cmd->vlan), (void*)br_ent_cmd->mac);
-			if (NULL == entry)
-			{
-				*fci_ret = FPP_ERR_L2_STATIC_EN_NOT_FOUND;
-			}
-			else
-			{
-				*fci_ret = FPP_ERR_OK;
-
-				if (EOK != pfe_l2br_static_entry_destroy(fci_context->l2_bridge, entry))
+				/* FALLTHRU */
+				case FPP_ACTION_QUERY_CONT:
 				{
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+					if (NULL == entry)
+					{
+						entry = pfe_l2br_static_entry_get_next(fci_context->l2_bridge);
+						if (NULL == entry)
+						{
+							ret = EOK;
+							*fci_ret = FPP_ERR_L2_STATIC_EN_NOT_FOUND;
+							break;
+						}
+					}
+
+					/*	Write the reply buffer */
+					br_ent_cmd = reply_buf;
+					*reply_len = sizeof(fpp_l2_static_ent_cmd_t);
+
+					/*	Build reply structure */
+					/* VLAN */
+					br_ent_cmd->vlan = pfe_l2br_static_entry_get_vlan(entry);
+					br_ent_cmd->vlan = oal_htons(br_ent_cmd->vlan);
+					/* MAC */
+					pfe_l2br_static_entry_get_mac(entry, br_ent_cmd->mac);
+					/* FW list */
+					br_ent_cmd->forward_list = oal_htonl(pfe_l2br_static_entry_get_fw_list(entry));
+					/* misc flags */
+					(void)pfe_l2br_static_entry_get_local_flag(fci_context->l2_bridge, entry, (bool_t *)&br_ent_cmd->local);
+					(void)pfe_l2br_static_entry_get_src_discard_flag(fci_context->l2_bridge, entry, (bool_t *)&br_ent_cmd->src_discard);
+					(void)pfe_l2br_static_entry_get_dst_discard_flag(fci_context->l2_bridge, entry, (bool_t *)&br_ent_cmd->dst_discard);
+					*fci_ret = FPP_ERR_OK;
+					break;
 				}
-			}
-			break;
-		}
-		case FPP_ACTION_QUERY:
-		{
-			entry = pfe_l2br_static_entry_get_first(fci_context->l2_bridge, L2SENT_CRIT_ALL, NULL, NULL);
-			if (NULL == entry)
-			{
-				ret = EOK;
-				*fci_ret = FPP_ERR_L2_STATIC_EN_NOT_FOUND;
-				break;
-			}
-		}
-		/* FALLTHRU */
-		case FPP_ACTION_QUERY_CONT:
-		{
-			if (NULL == entry)
-			{
-				entry = pfe_l2br_static_entry_get_next(fci_context->l2_bridge);
-				if (NULL == entry)
+				default:
 				{
-					ret = EOK;
-					*fci_ret = FPP_ERR_L2_STATIC_EN_NOT_FOUND;
+					NXP_LOG_ERROR("FPP_CMD_L2_STATIC_ENT: Unknown action received: 0x%x\n", br_ent_cmd->action);
+					*fci_ret = FPP_ERR_UNKNOWN_ACTION;
 					break;
 				}
 			}
-
-			/*	Write the reply buffer */
-			br_ent_cmd = reply_buf;
-			*reply_len = sizeof(fpp_l2_static_ent_cmd_t);
-
-			/*	Build reply structure */
-			/* VLAN */
-			br_ent_cmd->vlan = pfe_l2br_static_entry_get_vlan(entry);
-			br_ent_cmd->vlan = oal_htons(br_ent_cmd->vlan);
-			/* MAC */
-			pfe_l2br_static_entry_get_mac(entry, br_ent_cmd->mac);
-			/* FW list */
-			br_ent_cmd->forward_list = oal_htonl(pfe_l2br_static_entry_get_fw_list(entry));
-			/* misc flags */
-			(void)pfe_l2br_static_entry_get_local_flag(fci_context->l2_bridge, entry, (bool_t *)&br_ent_cmd->local);
-			(void)pfe_l2br_static_entry_get_src_discard_flag(fci_context->l2_bridge, entry, (bool_t *)&br_ent_cmd->src_discard);
-			(void)pfe_l2br_static_entry_get_dst_discard_flag(fci_context->l2_bridge, entry, (bool_t *)&br_ent_cmd->dst_discard);
-			*fci_ret = FPP_ERR_OK;
-			break;
-		}
-		default:
-		{
-			NXP_LOG_ERROR("FPP_CMD_L2_STATIC_ENT: Unknown action received: 0x%x\n", br_ent_cmd->action);
-			*fci_ret = FPP_ERR_UNKNOWN_ACTION;
-			break;
+	
 		}
 	}
 	return ret;
@@ -622,29 +629,31 @@ uint32_t fci_l2br_static_entry_get_valid_fw_list(void)
 	if(EOK != ret)
 	{
 		NXP_LOG_DEBUG("DB lock failed\n");
-		return 0;
+		valid_if_list = 0;
 	}
-
-	for (ii=0U; ((ii < (8U * sizeof(uint32_t))) && (ii <= (uint32_t)PFE_PHY_IF_ID_MAX)); ii++)
+	else
 	{
-			/*	Only add interfaces which are known to platform interface database */
-			if_db_entry = NULL;
-			ret = pfe_if_db_get_first(fci_context->phy_if_db, session_id, IF_DB_CRIT_BY_ID, (void *)(addr_t)ii, &if_db_entry);
-			if (EOK != ret)
-			{
-				valid_if_list = 0;
-				break;
-			}
-			if (NULL != if_db_entry)
-			{
-				valid_if_list |= ((uint32_t)1U << ii);
-			}
-	}
+		for (ii=0U; ((ii < (8U * sizeof(uint32_t))) && (ii <= (uint32_t)PFE_PHY_IF_ID_MAX)); ii++)
+		{
+				/*	Only add interfaces which are known to platform interface database */
+				if_db_entry = NULL;
+				ret = pfe_if_db_get_first(fci_context->phy_if_db, session_id, IF_DB_CRIT_BY_ID, (void *)(addr_t)ii, &if_db_entry);
+				if (EOK != ret)
+				{
+					valid_if_list = 0;
+					break;
+				}
+				if (NULL != if_db_entry)
+				{
+					valid_if_list |= ((uint32_t)1U << ii);
+				}
+		}
 
-	if (EOK != pfe_if_db_unlock(session_id))
-	{
-		NXP_LOG_DEBUG("DB unlock failed\n");
-		return 0;
+		if (EOK != pfe_if_db_unlock(session_id))
+		{
+			NXP_LOG_DEBUG("DB unlock failed\n");
+			valid_if_list = 0;
+		}
 	}
 
 	return valid_if_list;
@@ -665,21 +674,22 @@ static errno_t fci_l2br_domain_remove_if(pfe_l2br_domain_t *domain, const pfe_ph
 	if (unlikely((NULL == domain)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (NULL != phy_if)
 	{
-		ret = pfe_l2br_domain_del_if(domain, phy_if);
-		if (EOK != ret)
+		if (NULL != phy_if)
 		{
-			NXP_LOG_ERROR("Could not remove interface from domain\n");
-			return ret;
-		}
-		else
-		{
-			ret = pfe_l2br_domain_flush_by_if(domain, phy_if);
+			ret = pfe_l2br_domain_del_if(domain, phy_if);
+			if (EOK != ret)
+			{
+				NXP_LOG_ERROR("Could not remove interface from domain\n");
+			}
+			else
+			{
+				ret = pfe_l2br_domain_flush_by_if(domain, phy_if);
+			}
 		}
 	}
 
diff --git a/sw/fci/src/fci_mirror.c b/sw/fci/src/fci_mirror.c
index a7e7362..f7d3091 100644
--- a/sw/fci/src/fci_mirror.c
+++ b/sw/fci/src/fci_mirror.c
@@ -48,407 +48,407 @@ errno_t fci_mirror_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_mirror_cmd_t *repl
 	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	if (unlikely(FALSE == fci_context->fci_initialized))
+	else if (unlikely(FALSE == fci_context->fci_initialized))
 	{
 		NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	*fci_ret = FPP_ERR_OK;
-
-	/* Important to initialize to avoid buffer overflows */
-	if (*reply_len < sizeof(fpp_mirror_cmd_t))
-	{
-		/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-		NXP_LOG_ERROR("Buffer length does not match expected value (fpp_mirror_cmd_t)\n");
-		*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-		return EINVAL;
+		ret = EPERM;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		/* No data written to reply buffer (yet) */
-		*reply_len = 0U;
-	}
-
-	(void)memset(reply_buf, 0, sizeof(fpp_mirror_cmd_t));
-	mirror_cmd = (fpp_mirror_cmd_t *)(msg->msg_cmd.payload);
+		*fci_ret = FPP_ERR_OK;
 
-	switch (mirror_cmd->action)
-	{
-		case FPP_ACTION_REGISTER:
+		/* Important to initialize to avoid buffer overflows */
+		if (*reply_len < sizeof(fpp_mirror_cmd_t))
 		{
-			/* Check that the requested mirror name is not already registered */
-			mirror = pfe_mirror_get_first(MIRROR_BY_NAME, mirror_cmd->name);
-			if (NULL != mirror)
-			{
-				/* FCI command attempted to register already registered entity. Respond with FCI error code. */
-				NXP_LOG_DEBUG("Mirror '%s' is already registered.\n", mirror_cmd->name);
-				*fci_ret = FPP_ERR_MIRROR_ALREADY_REGISTERED;
-				ret = EOK;
-				break;
-			}
-
-			/* Create mirror */
-			mirror = pfe_mirror_create(mirror_cmd->name);
-			if (NULL == mirror)
-			{
-				/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-				NXP_LOG_ERROR("Cannot create mirror '%s'\n", mirror_cmd->name);
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				ret = EPERM;
-				break;
-			}
+			/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+			NXP_LOG_ERROR("Buffer length does not match expected value (fpp_mirror_cmd_t)\n");
+			*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+			ret = EINVAL;
 		}
-		/* FALLTHRU */
-
-		case FPP_ACTION_UPDATE:
+		else
 		{
-			if(NULL == mirror)
-			{	/* Not the FALLTHRU case - obtain the mirror */
-				/* Get mirror */
-				mirror = pfe_mirror_get_first(MIRROR_BY_NAME, mirror_cmd->name);
-				if(NULL == mirror)
-				{
-					/* FCI command requested nonexistent entity. Respond with FCI error code. */
-					NXP_LOG_DEBUG("No mirror with name '%s'\n", mirror_cmd->name);
-					*fci_ret = FPP_ERR_MIRROR_NOT_FOUND;
-					ret = EINVAL;
-					break;
-				}
-			}
-
-			/* 1) Set egress port */
-
-			/* Lock interface db and get the requested interface */
-			ret = pfe_if_db_lock(&fci_context->if_session_id);
-			if(EOK != ret)
-			{
-				/* FCI command requested unfulfillable action. Respond with FCI error code. */
-				*fci_ret = FPP_ERR_IF_RESOURCE_ALREADY_LOCKED;
-				ret = EOK;
-				break;
-			}
-
-			(void)pfe_if_db_get_first(fci_context->phy_if_db, fci_context->if_session_id, IF_DB_CRIT_BY_NAME, mirror_cmd->egress_phy_if, &entry);
-			if (NULL != entry)
-			{
-				phy_if = pfe_if_db_entry_get_phy_if(entry);
-			}
+			/* No data written to reply buffer (yet) */
+			*reply_len = 0U;
+			
+			(void)memset(reply_buf, 0, sizeof(fpp_mirror_cmd_t));
+			mirror_cmd = (fpp_mirror_cmd_t *)(msg->msg_cmd.payload);
 
-			if((NULL == entry) || (NULL == phy_if))
+			switch (mirror_cmd->action)
 			{
-				/* FCI command requested nonexistent entity. Respond with FCI error code. */
-				(void)pfe_if_db_unlock(fci_context->if_session_id);
-				NXP_LOG_DEBUG("No interface '%s'\n", mirror_cmd->egress_phy_if);
-				*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-				ret = EOK;
-				break;
-			}
-
-			/* Set the interface as mirror's egress port */
-			egress_id = pfe_phy_if_get_id(phy_if);
-			ret = pfe_mirror_set_egress_port(mirror, egress_id);
-			if(EOK != ret)
-			{
-				/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-				(void)pfe_if_db_unlock(fci_context->if_session_id);
-				NXP_LOG_DEBUG("Cannot set egress port for '%s'\n", mirror_cmd->name);
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				break;
-			}
-
-			(void)pfe_if_db_unlock(fci_context->if_session_id);
-
-			/* 2) Set filter to select frames */
-
-			if('\0' == mirror_cmd->filter_table_name[0U])
-			{	/* FCI command requests that the filter shall be disabled */
+				case FPP_ACTION_REGISTER:
+				{
+					/* Check that the requested mirror name is not already registered */
+					mirror = pfe_mirror_get_first(MIRROR_BY_NAME, mirror_cmd->name);
+					if (NULL != mirror)
+					{
+						/* FCI command attempted to register already registered entity. Respond with FCI error code. */
+						NXP_LOG_DEBUG("Mirror '%s' is already registered.\n", mirror_cmd->name);
+						*fci_ret = FPP_ERR_MIRROR_ALREADY_REGISTERED;
+						ret = EOK;
+						break;
+					}
 
-				/* Check if the mirror currently uses some filter. */
-				addr = pfe_mirror_get_filter(mirror);
-				if(0U != addr)
-				{	/* Some filter (Flexible Parser table) is used. Get it and remove it from DMEM. */
-                    ret = fci_fp_db_get_table_from_addr(addr, (char **)&str);
-					if(EOK != ret)
+					/* Create mirror */
+					mirror = pfe_mirror_create(mirror_cmd->name);
+					if (NULL == mirror)
 					{
 						/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-						NXP_LOG_ERROR("Cannot obtain filter name.\n");
+						NXP_LOG_ERROR("Cannot create mirror '%s'\n", mirror_cmd->name);
 						*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+						ret = EPERM;
 						break;
 					}
-					else
-					{
-						(void)fci_fp_db_pop_table_from_hw((char *)str);
-					}
 				}
+				/* FALLTHRU */
 
-				/* Disable the filter */
-				ret = pfe_mirror_set_filter(mirror, 0U);
-				if(EOK != ret)
+				case FPP_ACTION_UPDATE:
 				{
-					/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-					NXP_LOG_WARNING("Failed to disable filter on mirror '%s'.\n", mirror_cmd->name);
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-					ret = EOK;
-					break;
-				}
-			}
-			else
-			{	/* FCI command requests that the filter shall be enabled or replaced by another one. */
+					if(NULL == mirror)
+					{	/* Not the FALLTHRU case - obtain the mirror */
+						/* Get mirror */
+						mirror = pfe_mirror_get_first(MIRROR_BY_NAME, mirror_cmd->name);
+						if(NULL == mirror)
+						{
+							/* FCI command requested nonexistent entity. Respond with FCI error code. */
+							NXP_LOG_DEBUG("No mirror with name '%s'\n", mirror_cmd->name);
+							*fci_ret = FPP_ERR_MIRROR_NOT_FOUND;
+							ret = EINVAL;
+							break;
+						}
+					}
 
-				/* Check that the newly requested filter exists */
-				if (NULL == fci_fp_db_get_first(FP_TABLE_CRIT_NAME, mirror_cmd->filter_table_name))
-				{
-					/* FCI command requested nonexistent entity. Respond with FCI error code. */
-					NXP_LOG_ERROR("Requested filter table '%s' does not exist.\n", mirror_cmd->filter_table_name);
-					*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;  /* TODO_BOB: Replace this with FPP_ERR_FP_TABLE_NOT_FOUND after AAVB-3369 gets implemented. */
-					ret = EOK;
-					break;
-				}
+					/* 1) Set egress port */
 
-				/* Check if the mirror currently uses some filter. */
-				addr = pfe_mirror_get_filter(mirror);
-				if(0U != addr)
-				{	/* Some filter (Flexible Parser table) is used. Get it and remove it from DMEM. */
-					ret = fci_fp_db_get_table_from_addr(addr, (char **)&str);
+					/* Lock interface db and get the requested interface */
+					ret = pfe_if_db_lock(&fci_context->if_session_id);
 					if(EOK != ret)
 					{
-						/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-						NXP_LOG_ERROR("Cannot obtain filter name.\n");
-						*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+						/* FCI command requested unfulfillable action. Respond with FCI error code. */
+						*fci_ret = FPP_ERR_IF_RESOURCE_ALREADY_LOCKED;
+						ret = EOK;
 						break;
 					}
-					else
+
+					(void)pfe_if_db_get_first(fci_context->phy_if_db, fci_context->if_session_id, IF_DB_CRIT_BY_NAME, mirror_cmd->egress_phy_if, &entry);
+					if (NULL != entry)
 					{
-						(void)fci_fp_db_pop_table_from_hw((char *)str);
+						phy_if = pfe_if_db_entry_get_phy_if(entry);
 					}
-				}
-
-				/* Set the filter */
-				addr = fci_fp_db_get_table_dmem_addr((char_t *)mirror_cmd->filter_table_name);
-				if(0U == addr)
-				{	/* Requested filter table (from FCI command) is not used anywhere yet. Good. Use it as filter. */
 
-                    /* Add filter table to HW */
-					ret = fci_fp_db_push_table_to_hw(fci_context->class, (char_t *)mirror_cmd->filter_table_name);
-					addr = fci_fp_db_get_table_dmem_addr((char_t *)mirror_cmd->filter_table_name);
+					if((NULL == entry) || (NULL == phy_if))
+					{
+						/* FCI command requested nonexistent entity. Respond with FCI error code. */
+						(void)pfe_if_db_unlock(fci_context->if_session_id);
+						NXP_LOG_DEBUG("No interface '%s'\n", mirror_cmd->egress_phy_if);
+						*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
+						ret = EOK;
+						break;
+					}
 
-                    /* Update filter address of mirror */
-					ret = pfe_mirror_set_filter(mirror, addr);
+					/* Set the interface as mirror's egress port */
+					egress_id = pfe_phy_if_get_id(phy_if);
+					ret = pfe_mirror_set_egress_port(mirror, egress_id);
 					if(EOK != ret)
 					{
 						/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-						NXP_LOG_ERROR("Failed to set filter %s to mirror %s\n", mirror_cmd->filter_table_name, mirror_cmd->name);
+						(void)pfe_if_db_unlock(fci_context->if_session_id);
+						NXP_LOG_DEBUG("Cannot set egress port for '%s'\n", mirror_cmd->name);
 						*fci_ret = FPP_ERR_INTERNAL_FAILURE;
 						break;
 					}
-				}
-				else
-				{	/* Requested filter table (from FCI command) is already used somewhere and cannot be used here. */
 
-                    /* FCI command requested unfulfillable action. Respond with FCI error code. */
-					NXP_LOG_ERROR("Filter '%s' already in use, but it should not be!\n", mirror_cmd->filter_table_name);
-					*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;  /* TODO_BOB: Replace this with FPP_ERR_FP_TABLE_ALREADY_IN_USE after AAVB-3369 gets implemented. */
-					ret = EOK;
+					(void)pfe_if_db_unlock(fci_context->if_session_id);
+
+					/* 2) Set filter to select frames */
+
+					if('\0' == mirror_cmd->filter_table_name[0U])
+					{	/* FCI command requests that the filter shall be disabled */
+
+						/* Check if the mirror currently uses some filter. */
+						addr = pfe_mirror_get_filter(mirror);
+						if(0U != addr)
+						{	/* Some filter (Flexible Parser table) is used. Get it and remove it from DMEM. */
+							ret = fci_fp_db_get_table_from_addr(addr, (char **)&str);
+							if(EOK != ret)
+							{
+								/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+								NXP_LOG_ERROR("Cannot obtain filter name.\n");
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+								break;
+							}
+							else
+							{
+								(void)fci_fp_db_pop_table_from_hw((char *)str);
+							}
+						}
+
+						/* Disable the filter */
+						ret = pfe_mirror_set_filter(mirror, 0U);
+						if(EOK != ret)
+						{
+							/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+							NXP_LOG_WARNING("Failed to disable filter on mirror '%s'.\n", mirror_cmd->name);
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							ret = EOK;
+							break;
+						}
+					}
+					else
+					{	/* FCI command requests that the filter shall be enabled or replaced by another one. */
+
+						/* Check that the newly requested filter exists */
+						if (NULL == fci_fp_db_get_first(FP_TABLE_CRIT_NAME, mirror_cmd->filter_table_name))
+						{
+							/* FCI command requested nonexistent entity. Respond with FCI error code. */
+							NXP_LOG_ERROR("Requested filter table '%s' does not exist.\n", mirror_cmd->filter_table_name);
+							*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;  /* TODO_BOB: Replace this with FPP_ERR_FP_TABLE_NOT_FOUND after AAVB-3369 gets implemented. */
+							ret = EOK;
+							break;
+						}
+
+						/* Check if the mirror currently uses some filter. */
+						addr = pfe_mirror_get_filter(mirror);
+						if(0U != addr)
+						{	/* Some filter (Flexible Parser table) is used. Get it and remove it from DMEM. */
+							ret = fci_fp_db_get_table_from_addr(addr, (char **)&str);
+							if(EOK != ret)
+							{
+								/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+								NXP_LOG_ERROR("Cannot obtain filter name.\n");
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+								break;
+							}
+							else
+							{
+								(void)fci_fp_db_pop_table_from_hw((char *)str);
+							}
+						}
+
+						/* Set the filter */
+						addr = fci_fp_db_get_table_dmem_addr((char_t *)mirror_cmd->filter_table_name);
+						if(0U == addr)
+						{	/* Requested filter table (from FCI command) is not used anywhere yet. Good. Use it as filter. */
+
+							/* Add filter table to HW */
+							ret = fci_fp_db_push_table_to_hw(fci_context->class, (char_t *)mirror_cmd->filter_table_name);
+							addr = fci_fp_db_get_table_dmem_addr((char_t *)mirror_cmd->filter_table_name);
+
+							/* Update filter address of mirror */
+							ret = pfe_mirror_set_filter(mirror, addr);
+							if(EOK != ret)
+							{
+								/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+								NXP_LOG_ERROR("Failed to set filter %s to mirror %s\n", mirror_cmd->filter_table_name, mirror_cmd->name);
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+								break;
+							}
+						}
+						else
+						{	/* Requested filter table (from FCI command) is already used somewhere and cannot be used here. */
+
+							/* FCI command requested unfulfillable action. Respond with FCI error code. */
+							NXP_LOG_ERROR("Filter '%s' already in use, but it should not be!\n", mirror_cmd->filter_table_name);
+							*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;  /* TODO_BOB: Replace this with FPP_ERR_FP_TABLE_ALREADY_IN_USE after AAVB-3369 gets implemented. */
+							ret = EOK;
+							break;
+						}
+					}
+
+					/* 3) Set modification actions */
+
+					mirror_cmd->m_actions = (fpp_modify_actions_t)oal_ntohl(mirror_cmd->m_actions);
+					if(MODIFY_ACT_NONE == mirror_cmd->m_actions)
+					{	/* No modifications */
+						ret = pfe_mirror_set_actions(mirror, RT_ACT_NONE, NULL);
+						if(EOK != ret)
+						{
+							NXP_LOG_ERROR("Failed to set modification action: MODIFY_ACT_NONE.\n");
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							break;
+						}
+					}
+					else
+					{	/* Some actions to be set - add one by one */
+
+						/* Initialize */
+						(void)memset(&m_args, 0, sizeof(pfe_ct_route_actions_args_t));
+						m_actions = RT_ACT_NONE;
+
+						/* Start adding */
+						if(0U != ((uint32_t)mirror_cmd->m_actions & (uint32_t)MODIFY_ACT_ADD_VLAN_HDR))
+						{	/* VLAN header add/replace */
+							m_args.vlan = mirror_cmd->m_args.vlan;
+							m_actions |= RT_ACT_ADD_VLAN_HDR;
+						}
+
+						/* Apply */
+						m_actions = (pfe_ct_route_actions_t) oal_htonl(m_actions);  /* PFE has modification actions in big endian. */
+						ret = pfe_mirror_set_actions(mirror, m_actions, &m_args);
+						if(EOK != ret)
+						{
+							NXP_LOG_ERROR("Failed to set modification actions.\n");
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							break;
+						}
+					}
+
 					break;
 				}
-			}
 
-			/* 3) Set modification actions */
-
-			mirror_cmd->m_actions = (fpp_modify_actions_t)oal_ntohl(mirror_cmd->m_actions);
-			if(MODIFY_ACT_NONE == mirror_cmd->m_actions)
-			{	/* No modifications */
-				ret = pfe_mirror_set_actions(mirror, RT_ACT_NONE, NULL);
-                if(EOK != ret)
-                {
-                    NXP_LOG_ERROR("Failed to set modification action: MODIFY_ACT_NONE.\n");
-                    *fci_ret = FPP_ERR_INTERNAL_FAILURE;
-                    break;
-                }
-			}
-			else
-			{	/* Some actions to be set - add one by one */
-
-				/* Initialize */
-				(void)memset(&m_args, 0, sizeof(pfe_ct_route_actions_args_t));
-				m_actions = RT_ACT_NONE;
-
-				/* Start adding */
-				if(0U != ((uint32_t)mirror_cmd->m_actions & (uint32_t)MODIFY_ACT_ADD_VLAN_HDR))
-				{	/* VLAN header add/replace */
-					m_args.vlan = mirror_cmd->m_args.vlan;
-					m_actions |= RT_ACT_ADD_VLAN_HDR;
-				}
+				case FPP_ACTION_DEREGISTER:
+				{
+					/* Get mirror */
+					mirror = pfe_mirror_get_first(MIRROR_BY_NAME, mirror_cmd->name);
+					if(NULL == mirror)
+					{
+						/* FCI command requested nonexistent entity. Respond with FCI error code. */
+						NXP_LOG_DEBUG("No mirror with name '%s'\n", mirror_cmd->name);
+						*fci_ret = FPP_ERR_MIRROR_NOT_FOUND;
+						ret = EOK;
+						break;
+					}
 
-				/* Apply */
-				m_actions = (pfe_ct_route_actions_t) oal_htonl(m_actions);  /* PFE has modification actions in big endian. */
-				ret = pfe_mirror_set_actions(mirror, m_actions, &m_args);
-                if(EOK != ret)
-                {
-                    NXP_LOG_ERROR("Failed to set modification actions.\n");
-                    *fci_ret = FPP_ERR_INTERNAL_FAILURE;
-                    break;
-                }
-			}
+					/* Check if the mirror currently uses some filter. */
+					addr = pfe_mirror_get_filter(mirror);
+					if(0U != addr)
+					{	/* Some filter (Flexible Parser table) is used. Get it and remove it from DMEM. */
+						ret = fci_fp_db_get_table_from_addr(addr, (char **)&str);
+						if(EOK != ret)
+						{
+							/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+							NXP_LOG_ERROR("Cannot obtain filter name.\n");
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							break;
+						}
+						else
+						{
+							(void)fci_fp_db_pop_table_from_hw((char *)str);
+						}
+					}
 
-			break;
-		}
+					/* No need to call pfe_mirror_set_filter(mirror, 0) because the mirror will be destroyed anyway */
 
-		case FPP_ACTION_DEREGISTER:
-		{
-			/* Get mirror */
-			mirror = pfe_mirror_get_first(MIRROR_BY_NAME, mirror_cmd->name);
-			if(NULL == mirror)
-			{
-				/* FCI command requested nonexistent entity. Respond with FCI error code. */
-				NXP_LOG_DEBUG("No mirror with name '%s'\n", mirror_cmd->name);
-				*fci_ret = FPP_ERR_MIRROR_NOT_FOUND;
-				ret = EOK;
-				break;
-			}
+					/* Destroy the mirror */
+					pfe_mirror_destroy(mirror);
 
-			/* Check if the mirror currently uses some filter. */
-			addr = pfe_mirror_get_filter(mirror);
-			if(0U != addr)
-			{	/* Some filter (Flexible Parser table) is used. Get it and remove it from DMEM. */
-				ret = fci_fp_db_get_table_from_addr(addr, (char **)&str);
-				if(EOK != ret)
-				{
-					/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-					NXP_LOG_ERROR("Cannot obtain filter name.\n");
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
 					break;
 				}
-				else
+
+				case FPP_ACTION_QUERY:
 				{
-					(void)fci_fp_db_pop_table_from_hw((char *)str);
+					/* Get the first mirror */
+					mirror = pfe_mirror_get_first(MIRROR_ANY, NULL);
+					if(NULL == mirror)
+					{
+						/* End of the query process (no more entities to report). Respond with FCI error code. */
+						*fci_ret = FPP_ERR_MIRROR_NOT_FOUND;
+						ret = EOK;
+						break;
+					}
 				}
-			}
+				/* FALLTHRU */
 
-			/* No need to call pfe_mirror_set_filter(mirror, 0) because the mirror will be destroyed anyway */
+				case FPP_ACTION_QUERY_CONT:
+				{
+					/* If not fallthrough, then get the next mirror */
+					if(NULL == mirror)
+					{
+						mirror = pfe_mirror_get_next();
+						if(NULL == mirror)
+						{
+							/* End of the query process (no more entities to report). Respond with FCI error code. */
+							*fci_ret = FPP_ERR_MIRROR_NOT_FOUND;
+							ret = EOK;
+							break;
+						}
+					}
 
-			/* Destroy the mirror */
-			pfe_mirror_destroy(mirror);
+					/* Get mirror name */
+					str = pfe_mirror_get_name(mirror);
+					(void)strncpy(reply_buf->name, str, sizeof(reply_buf->name) - 1U);
 
-			break;
-		}
+					/* Get egress port name, step #1 - find the egress interface in the interface db */
+					egress_id = pfe_mirror_get_egress_port(mirror);
+					ret = pfe_if_db_lock(&fci_context->if_session_id);
+					if(EOK != ret)
+					{
+						/* FCI command requested unfulfillable action. Respond with FCI error code. */
+						*fci_ret = FPP_ERR_IF_RESOURCE_ALREADY_LOCKED;
+						ret = EOK;
+						break;
+					}
 
-		case FPP_ACTION_QUERY:
-		{
-			/* Get the first mirror */
-			mirror = pfe_mirror_get_first(MIRROR_ANY, NULL);
-			if(NULL == mirror)
-			{
-				/* End of the query process (no more entities to report). Respond with FCI error code. */
-				*fci_ret = FPP_ERR_MIRROR_NOT_FOUND;
-				ret = EOK;
-				break;
-			}
-		}
-		/* FALLTHRU */
+					(void)pfe_if_db_get_single(fci_context->phy_if_db, fci_context->if_session_id, IF_DB_CRIT_BY_ID, (void *)(addr_t)egress_id, &entry);
+					if (NULL != entry)
+					{
+						phy_if = pfe_if_db_entry_get_phy_if(entry);
+					}
 
-		case FPP_ACTION_QUERY_CONT:
-		{
-			/* If not fallthrough, then get the next mirror */
-			if(NULL == mirror)
-			{
-				mirror = pfe_mirror_get_next();
-				if(NULL == mirror)
-				{
-					/* End of the query process (no more entities to report). Respond with FCI error code. */
-					*fci_ret = FPP_ERR_MIRROR_NOT_FOUND;
-					ret = EOK;
-					break;
-				}
-			}
+					if((NULL == entry) || (NULL == phy_if))
+					{
+						/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+						(void)pfe_if_db_unlock(fci_context->if_session_id);
+						NXP_LOG_DEBUG("Cannot get egress interface of the mirror '%s'.\n", pfe_mirror_get_name(mirror));
+						*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+						ret = ENOENT;
+						break;
+					}
 
-			/* Get mirror name */
-			str = pfe_mirror_get_name(mirror);
-			(void)strncpy(reply_buf->name, str, sizeof(reply_buf->name) - 1U);
+					/* Get egress port name, step #2 - get name of the egress interface */
+					str = pfe_phy_if_get_name(phy_if);
+					(void)strncpy(reply_buf->egress_phy_if, str, (uint32_t)IFNAMSIZ - 1U);
+					reply_buf->egress_phy_if[(uint32_t)IFNAMSIZ - 1U] = '\0';  /* Ensure termination */
+					(void)pfe_if_db_unlock(fci_context->if_session_id);
 
-			/* Get egress port name, step #1 - find the egress interface in the interface db */
-			egress_id = pfe_mirror_get_egress_port(mirror);
-			ret = pfe_if_db_lock(&fci_context->if_session_id);
-			if(EOK != ret)
-			{
-				/* FCI command requested unfulfillable action. Respond with FCI error code. */
-				*fci_ret = FPP_ERR_IF_RESOURCE_ALREADY_LOCKED;
-				ret = EOK;
-				break;
-			}
+					/* Get filter name */
+					(void)memset(reply_buf->filter_table_name, 0, IFNAMSIZ);
+					addr = pfe_mirror_get_filter(mirror);
+					if(0U != addr)
+					{
+						ret = fci_fp_db_get_table_from_addr(addr, (char **)&str);
+						if(EOK == ret)
+						{
+							(void)strncpy(reply_buf->filter_table_name, str, 15);
+							reply_buf->filter_table_name[15] = '\0';  /* Ensure termination */
+						}
+					}
 
-            (void)pfe_if_db_get_single(fci_context->phy_if_db, fci_context->if_session_id, IF_DB_CRIT_BY_ID, (void *)(addr_t)egress_id, &entry);
-			if (NULL != entry)
-			{
-				phy_if = pfe_if_db_entry_get_phy_if(entry);
-			}
+					/* Initialize */
+					(void)memset(&m_args, 0, sizeof(pfe_ct_route_actions_args_t));
+					m_actions = RT_ACT_NONE;
 
-            if((NULL == entry) || (NULL == phy_if))
-			{
-				/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-				(void)pfe_if_db_unlock(fci_context->if_session_id);
-				NXP_LOG_DEBUG("Cannot get egress interface of the mirror '%s'.\n", pfe_mirror_get_name(mirror));
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				ret = ENOENT;
-				break;
-			}
+					/* Get modification actions */
+					reply_buf->m_actions = MODIFY_ACT_NONE;
+					(void)pfe_mirror_get_actions(mirror, &m_actions, &m_args);
+					m_actions = (pfe_ct_route_actions_t) oal_ntohl(m_actions);  /* PFE has modification actions in big endian. */
+					if(0U != ((uint32_t)m_actions & (uint32_t)RT_ACT_ADD_VLAN_HDR))
+					{
+						reply_buf->m_actions |= MODIFY_ACT_ADD_VLAN_HDR;
+						reply_buf->m_args.vlan = m_args.vlan;
+					}
+					reply_buf->m_actions = (fpp_modify_actions_t)oal_htonl(reply_buf->m_actions);
 
-            /* Get egress port name, step #2 - get name of the egress interface */
-			str = pfe_phy_if_get_name(phy_if);
-			(void)strncpy(reply_buf->egress_phy_if, str, (uint32_t)IFNAMSIZ - 1U);
-			reply_buf->egress_phy_if[(uint32_t)IFNAMSIZ - 1U] = '\0';  /* Ensure termination */
-			(void)pfe_if_db_unlock(fci_context->if_session_id);
+					/* Set reply length end return OK */
+					*reply_len = sizeof(fpp_mirror_cmd_t);
+					ret = EOK;
 
-			/* Get filter name */
-			(void)memset(reply_buf->filter_table_name, 0, IFNAMSIZ);
-			addr = pfe_mirror_get_filter(mirror);
-			if(0U != addr)
-			{
-				ret = fci_fp_db_get_table_from_addr(addr, (char **)&str);
-				if(EOK == ret)
-				{
-					(void)strncpy(reply_buf->filter_table_name, str, 15);
-					reply_buf->filter_table_name[15] = '\0';  /* Ensure termination */
+					break;
 				}
-			}
 
-			/* Initialize */
-			(void)memset(&m_args, 0, sizeof(pfe_ct_route_actions_args_t));
-			m_actions = RT_ACT_NONE;
-
-			/* Get modification actions */
-			reply_buf->m_actions = MODIFY_ACT_NONE;
-			(void)pfe_mirror_get_actions(mirror, &m_actions, &m_args);
-			m_actions = (pfe_ct_route_actions_t) oal_ntohl(m_actions);  /* PFE has modification actions in big endian. */
-			if(0U != ((uint32_t)m_actions & (uint32_t)RT_ACT_ADD_VLAN_HDR))
-			{
-				reply_buf->m_actions |= MODIFY_ACT_ADD_VLAN_HDR;
-				reply_buf->m_args.vlan = m_args.vlan;
+				default:
+				{
+					/* Unknown command. Respond with FCI error code. */
+					NXP_LOG_ERROR("FPP_CMD_MIRROR command: Unknown action received: 0x%x\n", mirror_cmd->action);
+					*fci_ret = FPP_ERR_UNKNOWN_ACTION;
+					ret = EOK;
+					break;
+				}
 			}
-			reply_buf->m_actions = (fpp_modify_actions_t)oal_htonl(reply_buf->m_actions);
-
-			/* Set reply length end return OK */
-			*reply_len = sizeof(fpp_mirror_cmd_t);
-			ret = EOK;
-
-			break;
-		}
-
-		default:
-		{
-			/* Unknown command. Respond with FCI error code. */
-			NXP_LOG_ERROR("FPP_CMD_MIRROR command: Unknown action received: 0x%x\n", mirror_cmd->action);
-			*fci_ret = FPP_ERR_UNKNOWN_ACTION;
-			ret = EOK;
-			break;
 		}
 	}
-
 	return ret;
 }
 
diff --git a/sw/fci/src/fci_qos.c b/sw/fci/src/fci_qos.c
index 9d583ed..5f14684 100644
--- a/sw/fci/src/fci_qos.c
+++ b/sw/fci/src/fci_qos.c
@@ -46,24 +46,25 @@ static pfe_phy_if_t *fci_get_phy_if_by_name(char_t *name)
 	if (EOK != ret)
 	{
 		NXP_LOG_ERROR("Could not lock interface DB: %d\n", ret);
-		return NULL;
 	}
-
-	ret = pfe_if_db_get_first(fci->phy_if_db, sid, IF_DB_CRIT_BY_NAME, name, &entry);
-	if (EOK != ret)
+	else
 	{
-		NXP_LOG_ERROR("Interface DB query failed: %d\n", ret);
-	}
+		ret = pfe_if_db_get_first(fci->phy_if_db, sid, IF_DB_CRIT_BY_NAME, name, &entry);
+		if (EOK != ret)
+		{
+			NXP_LOG_ERROR("Interface DB query failed: %d\n", ret);
+		}
 
-	if(NULL != entry)
-	{
-		phy_if = pfe_if_db_entry_get_phy_if(entry);
-	}
+		if(NULL != entry)
+		{
+			phy_if = pfe_if_db_entry_get_phy_if(entry);
+		}
 
-	ret = pfe_if_db_unlock(sid);
-	if (EOK != ret)
-	{
-		NXP_LOG_ERROR("Interface DB unlock failed: %d\n", ret);
+		ret = pfe_if_db_unlock(sid);
+		if (EOK != ret)
+		{
+			NXP_LOG_ERROR("Interface DB unlock failed: %d\n", ret);
+		}
 	}
 
 	return phy_if;
@@ -92,249 +93,249 @@ errno_t fci_qos_queue_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_queue_cmd_t
 	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	if (unlikely(FALSE == __context.fci_initialized))
+	else if (unlikely(FALSE == __context.fci_initialized))
 	{
 		NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (*reply_len < sizeof(fpp_qos_queue_cmd_t))
-	{
-		NXP_LOG_ERROR("Buffer length does not match expected value (fpp_qos_queue_cmd_t)\n");
-		return EINVAL;
+		ret = EPERM;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		/*	No data written to reply buffer (yet) */
-		*reply_len = 0U;
-	}
-
-	/*	Initialize the reply buffer */
-	(void)memset(reply_buf, 0, sizeof(fpp_qos_queue_cmd_t));
-	q = (fpp_qos_queue_cmd_t *)msg->msg_cmd.payload;
-
-	switch(q->action)
-	{
-		case FPP_ACTION_UPDATE:
+		if (*reply_len < sizeof(fpp_qos_queue_cmd_t))
 		{
-			*fci_ret = FPP_ERR_OK;
-
-			/*	Get physical interface ID */
-			phy_if = fci_get_phy_if_by_name(q->if_name);
-			if (NULL == phy_if)
-			{
-				/* FCI command requested nonexistent entity. Respond with FCI error code. */
-				*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-				ret = EOK;
-				break;
-			}
-
-			/*	Check queue ID */
-			cnt = pfe_tmu_queue_get_cnt(fci->tmu, pfe_phy_if_get_id(phy_if));
-			if (q->id > cnt)
-			{
-				/* FCI command requested nonexistent entity. Respond with FCI error code. */
-				NXP_LOG_ERROR("Queue ID %d out of range. Interface %s implements %d queues\n",
-						(int_t)q->id, q->if_name, (int_t)cnt);
-				*fci_ret = FPP_ERR_QOS_QUEUE_NOT_FOUND;
-				ret = EOK;
-				break;
-			}
-
-			NXP_LOG_DEBUG("Setting queue %d mode: %d (min: %d, max: %d)\n",
-					(int_t)q->id, (int_t)q->mode, (int_t)oal_ntohl(q->min), (int_t)oal_ntohl(q->max));
+			NXP_LOG_ERROR("Buffer length does not match expected value (fpp_qos_queue_cmd_t)\n");
+			ret = EINVAL;
+		}
+		else
+		{
+			/*	No data written to reply buffer (yet) */
+			*reply_len = 0U;
+			/*	Initialize the reply buffer */
+			(void)memset(reply_buf, 0, sizeof(fpp_qos_queue_cmd_t));
+			q = (fpp_qos_queue_cmd_t *)msg->msg_cmd.payload;
 
-			if (q->mode > 3U)
-			{
-				/* FCI command has wrong data. Respond with FCI error code. */
-				NXP_LOG_ERROR("Unsupported queue mode: %d\n", q->mode);
-				*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-				ret = EOK;
-				break;
-			}
-			else
+			switch(q->action)
 			{
-				if (q->mode == 0U)
-				{
-					/*	Disable the queue to drop all packets */
-					ret = pfe_tmu_queue_set_mode(fci->tmu, pfe_phy_if_get_id(phy_if), q->id,
-							TMU_Q_MODE_TAIL_DROP, 0U, 0U);
-				}
-				else
+				case FPP_ACTION_UPDATE:
 				{
-					ret = pfe_tmu_queue_set_mode(fci->tmu, pfe_phy_if_get_id(phy_if), q->id,
-						fci_qmode_to_qmode[q->mode], oal_ntohl(q->min), oal_ntohl(q->max));
-				}
+					*fci_ret = FPP_ERR_OK;
 
-				if (EOK != ret)
-				{
-					if (ENOSPC == ret)
+					/*	Get physical interface ID */
+					phy_if = fci_get_phy_if_by_name(q->if_name);
+					if (NULL == phy_if)
 					{
-						/* FCI command requested unfulfillable action. Respond with FCI error code. */
-						NXP_LOG_ERROR("Refused to set max length of %s queue %d to %u, because then the sum of %s queue lengths would exceed allowed total limit.\n", pfe_phy_if_get_name(phy_if), q->id, (uint_t)oal_ntohl(q->max), pfe_phy_if_get_name(phy_if));
-						*fci_ret = FPP_ERR_QOS_QUEUE_SUM_OF_LENGTHS_EXCEEDED;
+						/* FCI command requested nonexistent entity. Respond with FCI error code. */
+						*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
 						ret = EOK;
+						break;
 					}
-					else
+
+					/*	Check queue ID */
+					cnt = pfe_tmu_queue_get_cnt(fci->tmu, pfe_phy_if_get_id(phy_if));
+					if (q->id > cnt)
 					{
-						/* FCI command has wrong data. Respond with FCI error code. */
-						NXP_LOG_ERROR("Could not set queue %d mode %d: %d\n", q->id, q->mode, ret);
-						*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+						/* FCI command requested nonexistent entity. Respond with FCI error code. */
+						NXP_LOG_ERROR("Queue ID %d out of range. Interface %s implements %d queues\n",
+								(int_t)q->id, q->if_name, (int_t)cnt);
+						*fci_ret = FPP_ERR_QOS_QUEUE_NOT_FOUND;
 						ret = EOK;
+						break;
 					}
-					break;
-				}
-
-				if (q->mode == 3U)
-				{
-					NXP_LOG_DEBUG("Setting WRED zones probabilities\n");
 
-					cnt = pfe_tmu_queue_get_cnt(fci->tmu, pfe_phy_if_get_id(phy_if));
+					NXP_LOG_DEBUG("Setting queue %d mode: %d (min: %d, max: %d)\n",
+							(int_t)q->id, (int_t)q->mode, (int_t)oal_ntohl(q->min), (int_t)oal_ntohl(q->max));
 
-					if (cnt > 32U)
+					if (q->mode > 3U)
 					{
-						/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-						NXP_LOG_DEBUG("Invalid zones count...\n");
-						*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-						ret = EINVAL;
+						/* FCI command has wrong data. Respond with FCI error code. */
+						NXP_LOG_ERROR("Unsupported queue mode: %d\n", q->mode);
+						*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+						ret = EOK;
 						break;
 					}
-
-					for (ii=0U; ii<cnt; ii++)
+					else
 					{
-						NXP_LOG_DEBUG("Setting queue %d zone %d probability %d%%\n",
-								(int_t)q->id, (int_t)ii, (int_t)q->zprob[ii]);
-						ret = pfe_tmu_queue_set_wred_prob(fci->tmu,
-								pfe_phy_if_get_id(phy_if), q->id, ii, q->zprob[ii]);
+						if (q->mode == 0U)
+						{
+							/*	Disable the queue to drop all packets */
+							ret = pfe_tmu_queue_set_mode(fci->tmu, pfe_phy_if_get_id(phy_if), q->id,
+									TMU_Q_MODE_TAIL_DROP, 0U, 0U);
+						}
+						else
+						{
+							ret = pfe_tmu_queue_set_mode(fci->tmu, pfe_phy_if_get_id(phy_if), q->id,
+								fci_qmode_to_qmode[q->mode], oal_ntohl(q->min), oal_ntohl(q->max));
+						}
+
 						if (EOK != ret)
 						{
-							/* FCI command has wrong data. Respond with FCI error code. */
-							NXP_LOG_ERROR("Could not set queue %d zone %d probability %d: %d\n",
-									(int_t)q->id, (int_t)ii, (int_t)q->zprob[ii], (int_t)ret);
-							*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-							ret = EOK;
-							break; /* for */
+							if (ENOSPC == ret)
+							{
+								/* FCI command requested unfulfillable action. Respond with FCI error code. */
+								NXP_LOG_ERROR("Refused to set max length of %s queue %d to %u, because then the sum of %s queue lengths would exceed allowed total limit.\n", pfe_phy_if_get_name(phy_if), q->id, (uint_t)oal_ntohl(q->max), pfe_phy_if_get_name(phy_if));
+								*fci_ret = FPP_ERR_QOS_QUEUE_SUM_OF_LENGTHS_EXCEEDED;
+								ret = EOK;
+							}
+							else
+							{
+								/* FCI command has wrong data. Respond with FCI error code. */
+								NXP_LOG_ERROR("Could not set queue %d mode %d: %d\n", q->id, q->mode, ret);
+								*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+								ret = EOK;
+							}
+							break;
 						}
-					}
-				}
-			}
 
-			break;
-		}
+						if (q->mode == 3U)
+						{
+							NXP_LOG_DEBUG("Setting WRED zones probabilities\n");
 
-		case FPP_ACTION_QUERY:
-		{
-			*fci_ret = FPP_ERR_OK;
+							cnt = pfe_tmu_queue_get_cnt(fci->tmu, pfe_phy_if_get_id(phy_if));
 
-			/*	Get physical interface ID */
-			phy_if = fci_get_phy_if_by_name(q->if_name);
-			if (NULL == phy_if)
-			{
-				/* FCI command requested nonexistent entity. Respond with FCI error code. */
-				*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-				ret = EOK;
-				break;
-			}
+							if (cnt > 32U)
+							{
+								/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+								NXP_LOG_DEBUG("Invalid zones count...\n");
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+								ret = EINVAL;
+								break;
+							}
 
-			/*	Check queue */
-			ret = pfe_tmu_check_queue(fci->tmu, pfe_phy_if_get_id(phy_if), q->id);
-			if (EOK != ret)
-			{
-				/* FCI command requested nonexistent entity. Respond with FCI error code. */
-				*fci_ret = FPP_ERR_QOS_QUEUE_NOT_FOUND;
-				ret = EOK;
-				break;
-			}
+							for (ii=0U; ii<cnt; ii++)
+							{
+								NXP_LOG_DEBUG("Setting queue %d zone %d probability %d%%\n",
+										(int_t)q->id, (int_t)ii, (int_t)q->zprob[ii]);
+								ret = pfe_tmu_queue_set_wred_prob(fci->tmu,
+										pfe_phy_if_get_id(phy_if), q->id, ii, q->zprob[ii]);
+								if (EOK != ret)
+								{
+									/* FCI command has wrong data. Respond with FCI error code. */
+									NXP_LOG_ERROR("Could not set queue %d zone %d probability %d: %d\n",
+											(int_t)q->id, (int_t)ii, (int_t)q->zprob[ii], (int_t)ret);
+									*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+									ret = EOK;
+									break; /* for */
+								}
+							}
+						}
+					}
 
-			/*	Copy original command properties into reply structure */
-			reply_buf->action = q->action;
-			reply_buf->id = q->id;
-			(void)strncpy(reply_buf->if_name, q->if_name, sizeof(reply_buf->if_name));
-			reply_buf->if_name[sizeof(reply_buf->if_name) - 1U] = '\0';
+					break;
+				}
 
-			/*	Get queue mode */
-			switch (pfe_tmu_queue_get_mode(fci->tmu, pfe_phy_if_get_id(phy_if),
-					q->id, &reply_buf->min, &reply_buf->max))
-			{
-				case TMU_Q_MODE_TAIL_DROP:
+				case FPP_ACTION_QUERY:
 				{
-					if (reply_buf->max == 0U)
+					*fci_ret = FPP_ERR_OK;
+
+					/*	Get physical interface ID */
+					phy_if = fci_get_phy_if_by_name(q->if_name);
+					if (NULL == phy_if)
 					{
-						reply_buf->mode = 0U; /* Disabled */
-						reply_buf->max = 0U;
-						reply_buf->min = 0U;
+						/* FCI command requested nonexistent entity. Respond with FCI error code. */
+						*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
+						ret = EOK;
+						break;
 					}
-					else
+
+					/*	Check queue */
+					ret = pfe_tmu_check_queue(fci->tmu, pfe_phy_if_get_id(phy_if), q->id);
+					if (EOK != ret)
 					{
-						reply_buf->mode = 2U; /* Tail Drop */
-						reply_buf->max = oal_htonl(reply_buf->max);
-						reply_buf->min = 0U;
+						/* FCI command requested nonexistent entity. Respond with FCI error code. */
+						*fci_ret = FPP_ERR_QOS_QUEUE_NOT_FOUND;
+						ret = EOK;
+						break;
 					}
 
-					break;
-				}
+					/*	Copy original command properties into reply structure */
+					reply_buf->action = q->action;
+					reply_buf->id = q->id;
+					(void)strncpy(reply_buf->if_name, q->if_name, sizeof(reply_buf->if_name));
+					reply_buf->if_name[sizeof(reply_buf->if_name) - 1U] = '\0';
 
-				case TMU_Q_MODE_DEFAULT:
-				{
-					reply_buf->mode = 1U; /* Default */
-					reply_buf->max = oal_htonl(reply_buf->max);
-					reply_buf->max = oal_htonl(reply_buf->min);
-					break;
-				}
+					/*	Get queue mode */
+					switch (pfe_tmu_queue_get_mode(fci->tmu, pfe_phy_if_get_id(phy_if),
+							q->id, &reply_buf->min, &reply_buf->max))
+					{
+						case TMU_Q_MODE_TAIL_DROP:
+						{
+							if (reply_buf->max == 0U)
+							{
+								reply_buf->mode = 0U; /* Disabled */
+								reply_buf->max = 0U;
+								reply_buf->min = 0U;
+							}
+							else
+							{
+								reply_buf->mode = 2U; /* Tail Drop */
+								reply_buf->max = oal_htonl(reply_buf->max);
+								reply_buf->min = 0U;
+							}
 
-				case TMU_Q_MODE_WRED:
-				{
-					reply_buf->mode = 3U; /* WRED */
-					reply_buf->max = oal_htonl(reply_buf->max);
-					reply_buf->min = oal_htonl(reply_buf->min);
+							break;
+						}
 
-					/*	Get zone probabilities */
-					cnt = pfe_tmu_queue_get_wred_zones(fci->tmu, pfe_phy_if_get_id(phy_if), q->id);
-					for (ii=0U; ii<32U; ii++)
-					{
-						if (ii < cnt)
+						case TMU_Q_MODE_DEFAULT:
 						{
-							ret = pfe_tmu_queue_get_wred_prob(
-									fci->tmu, pfe_phy_if_get_id(phy_if), q->id, ii, &reply_buf->zprob[ii]);
-							if (EOK != ret)
+							reply_buf->mode = 1U; /* Default */
+							reply_buf->max = oal_htonl(reply_buf->max);
+							reply_buf->max = oal_htonl(reply_buf->min);
+							break;
+						}
+
+						case TMU_Q_MODE_WRED:
+						{
+							reply_buf->mode = 3U; /* WRED */
+							reply_buf->max = oal_htonl(reply_buf->max);
+							reply_buf->min = oal_htonl(reply_buf->min);
+
+							/*	Get zone probabilities */
+							cnt = pfe_tmu_queue_get_wred_zones(fci->tmu, pfe_phy_if_get_id(phy_if), q->id);
+							for (ii=0U; ii<32U; ii++)
 							{
-								/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-								NXP_LOG_ERROR("Could not get queue %d zone %d probability: %d\n", (int_t)q->id, (int_t)ii, (int_t)ret);
-								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-								break; /* for */
+								if (ii < cnt)
+								{
+									ret = pfe_tmu_queue_get_wred_prob(
+											fci->tmu, pfe_phy_if_get_id(phy_if), q->id, ii, &reply_buf->zprob[ii]);
+									if (EOK != ret)
+									{
+										/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+										NXP_LOG_ERROR("Could not get queue %d zone %d probability: %d\n", (int_t)q->id, (int_t)ii, (int_t)ret);
+										*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+										break; /* for */
+									}
+								}
+								else
+								{
+									reply_buf->zprob[ii] = 255; /* Invalid */
+								}
 							}
+
+							break;
 						}
-						else
+
+						default:
 						{
-							reply_buf->zprob[ii] = 255; /* Invalid */
+							/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+							NXP_LOG_ERROR("Can't get queue %d mode\n", q->id);
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							break;
 						}
 					}
 
+					*reply_len = sizeof(fpp_qos_queue_cmd_t);
 					break;
 				}
 
 				default:
 				{
-					/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-					NXP_LOG_ERROR("Can't get queue %d mode\n", q->id);
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+					NXP_LOG_ERROR("FPP_CMD_QOS_QUEUE: Unknown action received: 0x%x\n", q->action);
+					*fci_ret = FPP_ERR_UNKNOWN_ACTION;
 					break;
 				}
 			}
-
-			*reply_len = sizeof(fpp_qos_queue_cmd_t);
-			break;
-		}
-
-		default:
-		{
-			NXP_LOG_ERROR("FPP_CMD_QOS_QUEUE: Unknown action received: 0x%x\n", q->action);
-			*fci_ret = FPP_ERR_UNKNOWN_ACTION;
-			break;
 		}
 	}
 
@@ -364,310 +365,310 @@ errno_t fci_qos_scheduler_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_schedul
 	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	if (unlikely(FALSE == __context.fci_initialized))
+	else if (unlikely(FALSE == __context.fci_initialized))
 	{
 		NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (*reply_len < sizeof(fpp_qos_scheduler_cmd_t))
-	{
-		NXP_LOG_ERROR("Buffer length does not match expected value (fpp_qos_scheduler_cmd_t)\n");
-		return EINVAL;
+		ret = EPERM;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		/*	No data written to reply buffer (yet) */
-		*reply_len = 0U;
-	}
-
-	/*	Initialize the reply buffer */
-	(void)memset(reply_buf, 0, sizeof(fpp_qos_scheduler_cmd_t));
-	sch = (fpp_qos_scheduler_cmd_t *)msg->msg_cmd.payload;
-
-	switch(sch->action)
-	{
-		case FPP_ACTION_UPDATE:
+		if (*reply_len < sizeof(fpp_qos_scheduler_cmd_t))
 		{
-			*fci_ret = FPP_ERR_OK;
-
-			/*	Get physical interface ID */
-			phy_if = fci_get_phy_if_by_name(sch->if_name);
-			if (NULL == phy_if)
-			{
-				/* FCI command requested nonexistent entity. Respond with FCI error code. */
-				*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-				ret = EOK;
-				break;
-			}
-
-			/*	Check scheduler */
-			ret = pfe_tmu_check_scheduler(fci->tmu, pfe_phy_if_get_id(phy_if), sch->id);
-			if (EOK != ret)
-			{
-				/* FCI command requested nonexistent entity. Respond with FCI error code. */
-				*fci_ret = FPP_ERR_QOS_SCHEDULER_NOT_FOUND;
-				ret = EOK;
-				break;
-			}
-
-			/*	Set scheduler mode */
-			if (0U == sch->mode)
-			{
-				NXP_LOG_INFO("Disabling all scheduler %d inputs\n", sch->id);
-				/*	Mark all inputs as disabled. Change will be applied below. */
-				sch->input_en = 0U;
-				ret = EOK;
-			}
-			else if (1U == sch->mode)
-			{
-				NXP_LOG_INFO("Setting scheduler %d mode: Data rate\n", sch->id);
-				ret = pfe_tmu_sch_set_rate_mode(fci->tmu,
-						pfe_phy_if_get_id(phy_if), sch->id, RATE_MODE_DATA_RATE);
-			}
-			else if (2U == sch->mode)
-			{
-				NXP_LOG_INFO("Setting scheduler %d mode: Packet rate\n", sch->id);
-				ret = pfe_tmu_sch_set_rate_mode(fci->tmu,
-						pfe_phy_if_get_id(phy_if), sch->id, RATE_MODE_PACKET_RATE);
-			}
-			else
-			{
-				NXP_LOG_ERROR("Unsupported scheduler mode: 0x%x\n", sch->mode);
-				ret = EINVAL;
-			}
-
-			if (EOK != ret)
-			{
-				/* FCI command has wrong data. Respond with FCI error code. */
-				NXP_LOG_WARNING("Scheduler mode not set: %d\n", ret);
-				*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-				ret = EOK;
-				break;
-			}
+			NXP_LOG_ERROR("Buffer length does not match expected value (fpp_qos_scheduler_cmd_t)\n");
+			ret = EINVAL;
+		}
+		else
+		{
+			/*	No data written to reply buffer (yet) */
+			*reply_len = 0U;
+			/*	Initialize the reply buffer */
+			(void)memset(reply_buf, 0, sizeof(fpp_qos_scheduler_cmd_t));
+			sch = (fpp_qos_scheduler_cmd_t *)msg->msg_cmd.payload;
 
-			/*	Set scheduler algorithm */
-			if (sch->algo > 3U)
+			switch(sch->action)
 			{
-				/* FCI command has wrong data. Respond with FCI error code. */
-				NXP_LOG_ERROR("Unsupported scheduler algorithm: 0x%x\n", sch->algo);
-				*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-				ret = EOK;
-				break;
-			}
+				case FPP_ACTION_UPDATE:
+				{
+					*fci_ret = FPP_ERR_OK;
 
-			NXP_LOG_INFO("Setting scheduler %d algorithm: %s\n",
-					sch->id, sch_algos_str[sch->algo]);
-			ret = pfe_tmu_sch_set_algo(fci->tmu, pfe_phy_if_get_id(phy_if),
-					sch->id, sch_algos[sch->algo]);
-			if (EOK != ret)
-			{
-				/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-				NXP_LOG_WARNING("Scheduler algorithm not set: %d\n", ret);
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				break;
-			}
+					/*	Get physical interface ID */
+					phy_if = fci_get_phy_if_by_name(sch->if_name);
+					if (NULL == phy_if)
+					{
+						/* FCI command requested nonexistent entity. Respond with FCI error code. */
+						*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
+						ret = EOK;
+						break;
+					}
 
-			/*	Configure scheduler inputs */
-			cnt = pfe_tmu_sch_get_input_cnt(fci->tmu, pfe_phy_if_get_id(phy_if), sch->id);
-			sch->input_en = oal_ntohl(sch->input_en);
-			for (ii=0U; ii<cnt; ii++)
-			{
-				if ((0U == (((uint32_t)1U << ii) & sch->input_en)) || (sch->input_src[ii] == 255U))
-				{
-					NXP_LOG_DEBUG("Disabling scheduler %d input %d\n", (int_t)sch->id, (int_t)ii);
-					ret = pfe_tmu_sch_bind_queue(fci->tmu, pfe_phy_if_get_id(phy_if),
-								sch->id, ii, PFE_TMU_INVALID_QUEUE);
+					/*	Check scheduler */
+					ret = pfe_tmu_check_scheduler(fci->tmu, pfe_phy_if_get_id(phy_if), sch->id);
 					if (EOK != ret)
 					{
-						/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-						NXP_LOG_ERROR("Could not invalidate scheduler input %d: %d\n", (int_t)ii, (int_t)ret);
-						*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-						break; /* for */
+						/* FCI command requested nonexistent entity. Respond with FCI error code. */
+						*fci_ret = FPP_ERR_QOS_SCHEDULER_NOT_FOUND;
+						ret = EOK;
+						break;
 					}
-				}
-				else
-				{
-					if (sch->input_src[ii] < 8U)
+
+					/*	Set scheduler mode */
+					if (0U == sch->mode)
 					{
-						NXP_LOG_DEBUG("Connecting source %d to scheduler %d input %d\n",
-								(int_t)sch->input_src[ii], (int_t)sch->id, (int_t)ii);
-						ret = pfe_tmu_sch_bind_queue(fci->tmu, pfe_phy_if_get_id(phy_if),
-								sch->id, ii, sch->input_src[ii]);
-						if (EOK != ret)
-						{
-							/* FCI command has wrong data. Respond with FCI error code. */
-							NXP_LOG_ERROR("Could not connect source %d to scheduler input %d\n",
-									(int_t)sch->input_src[ii], (int_t)ii);
-							*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-							ret = EOK;
-							break; /* for */
-						}
+						NXP_LOG_INFO("Disabling all scheduler %d inputs\n", sch->id);
+						/*	Mark all inputs as disabled. Change will be applied below. */
+						sch->input_en = 0U;
+						ret = EOK;
 					}
-					else if (sch->input_src[ii] == 8U)
+					else if (1U == sch->mode)
 					{
-						NXP_LOG_DEBUG("Connecting scheduler %d output to scheduler %d input %d\n",
-								(int_t)(sch->id-1U), (int_t)sch->id, (int_t)ii);
-						ret = pfe_tmu_sch_bind_sch_output(fci->tmu, pfe_phy_if_get_id(phy_if),
-								sch->id-1U, sch->id, ii);
-						if (EOK != ret)
-						{
-							/* FCI command has wrong data. Respond with FCI error code. */
-							NXP_LOG_ERROR("Could not connect scheduler %d output to scheduler %d input %d: %d\n",
-									(int_t)(sch->id-1U), (int_t)sch->id, (int_t)ii, (int_t)ret);
-							*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-							ret = EOK;
-							break; /* for */
-						}
+						NXP_LOG_INFO("Setting scheduler %d mode: Data rate\n", sch->id);
+						ret = pfe_tmu_sch_set_rate_mode(fci->tmu,
+								pfe_phy_if_get_id(phy_if), sch->id, RATE_MODE_DATA_RATE);
+					}
+					else if (2U == sch->mode)
+					{
+						NXP_LOG_INFO("Setting scheduler %d mode: Packet rate\n", sch->id);
+						ret = pfe_tmu_sch_set_rate_mode(fci->tmu,
+								pfe_phy_if_get_id(phy_if), sch->id, RATE_MODE_PACKET_RATE);
 					}
 					else
+					{
+						NXP_LOG_ERROR("Unsupported scheduler mode: 0x%x\n", sch->mode);
+						ret = EINVAL;
+					}
+
+					if (EOK != ret)
 					{
 						/* FCI command has wrong data. Respond with FCI error code. */
-						NXP_LOG_ERROR("Unsupported scheduler input %d source: %d\n", (int_t)ii, (int_t)sch->input_src[ii]);
+						NXP_LOG_WARNING("Scheduler mode not set: %d\n", ret);
 						*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
 						ret = EOK;
-						break; /* for */
+						break;
 					}
 
-					NXP_LOG_DEBUG("Setting scheduler %d input %d weight: %d\n",
-							(int_t)sch->id, (int_t)ii, (int_t)oal_ntohl(sch->input_w[ii]));
-					ret = pfe_tmu_sch_set_input_weight(fci->tmu, pfe_phy_if_get_id(phy_if),
-							sch->id, ii, oal_ntohl(sch->input_w[ii]));
-					if (EOK != ret)
+					/*	Set scheduler algorithm */
+					if (sch->algo > 3U)
 					{
 						/* FCI command has wrong data. Respond with FCI error code. */
-						NXP_LOG_ERROR("Could not set scheduler %d input %d weight %d: %d\n",
-								(int_t)sch->id, (int_t)ii, (int_t)oal_ntohl(sch->input_w[ii]), (int_t)ret);
+						NXP_LOG_ERROR("Unsupported scheduler algorithm: 0x%x\n", sch->algo);
 						*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
 						ret = EOK;
-						break; /* for */
+						break;
 					}
-				}
-			}
-
-			break;
-		}
-
-		case FPP_ACTION_QUERY:
-		{
-			*fci_ret = FPP_ERR_OK;
 
-			/*	Get physical interface ID */
-			phy_if = fci_get_phy_if_by_name(sch->if_name);
-			if (NULL == phy_if)
-			{
-				/* FCI command requested nonexistent entity. Respond with FCI error code. */
-				*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-				ret = EOK;
-				break;
-			}
+					NXP_LOG_INFO("Setting scheduler %d algorithm: %s\n",
+							sch->id, sch_algos_str[sch->algo]);
+					ret = pfe_tmu_sch_set_algo(fci->tmu, pfe_phy_if_get_id(phy_if),
+							sch->id, sch_algos[sch->algo]);
+					if (EOK != ret)
+					{
+						/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+						NXP_LOG_WARNING("Scheduler algorithm not set: %d\n", ret);
+						*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+						break;
+					}
 
-			/*	Check scheduler */
-			ret = pfe_tmu_check_scheduler(fci->tmu, pfe_phy_if_get_id(phy_if), sch->id);
-			if (EOK != ret)
-			{
-				/* FCI command requested nonexistent entity. Respond with FCI error code. */
-				*fci_ret = FPP_ERR_QOS_SCHEDULER_NOT_FOUND;
-				ret = EOK;
-				break;
-			}
+					/*	Configure scheduler inputs */
+					cnt = pfe_tmu_sch_get_input_cnt(fci->tmu, pfe_phy_if_get_id(phy_if), sch->id);
+					sch->input_en = oal_ntohl(sch->input_en);
+					for (ii=0U; ii<cnt; ii++)
+					{
+						if ((0U == (((uint32_t)1U << ii) & sch->input_en)) || (sch->input_src[ii] == 255U))
+						{
+							NXP_LOG_DEBUG("Disabling scheduler %d input %d\n", (int_t)sch->id, (int_t)ii);
+							ret = pfe_tmu_sch_bind_queue(fci->tmu, pfe_phy_if_get_id(phy_if),
+										sch->id, ii, PFE_TMU_INVALID_QUEUE);
+							if (EOK != ret)
+							{
+								/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+								NXP_LOG_ERROR("Could not invalidate scheduler input %d: %d\n", (int_t)ii, (int_t)ret);
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+								break; /* for */
+							}
+						}
+						else
+						{
+							if (sch->input_src[ii] < 8U)
+							{
+								NXP_LOG_DEBUG("Connecting source %d to scheduler %d input %d\n",
+										(int_t)sch->input_src[ii], (int_t)sch->id, (int_t)ii);
+								ret = pfe_tmu_sch_bind_queue(fci->tmu, pfe_phy_if_get_id(phy_if),
+										sch->id, ii, sch->input_src[ii]);
+								if (EOK != ret)
+								{
+									/* FCI command has wrong data. Respond with FCI error code. */
+									NXP_LOG_ERROR("Could not connect source %d to scheduler input %d\n",
+											(int_t)sch->input_src[ii], (int_t)ii);
+									*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+									ret = EOK;
+									break; /* for */
+								}
+							}
+							else if (sch->input_src[ii] == 8U)
+							{
+								NXP_LOG_DEBUG("Connecting scheduler %d output to scheduler %d input %d\n",
+										(int_t)(sch->id-1U), (int_t)sch->id, (int_t)ii);
+								ret = pfe_tmu_sch_bind_sch_output(fci->tmu, pfe_phy_if_get_id(phy_if),
+										sch->id-1U, sch->id, ii);
+								if (EOK != ret)
+								{
+									/* FCI command has wrong data. Respond with FCI error code. */
+									NXP_LOG_ERROR("Could not connect scheduler %d output to scheduler %d input %d: %d\n",
+											(int_t)(sch->id-1U), (int_t)sch->id, (int_t)ii, (int_t)ret);
+									*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+									ret = EOK;
+									break; /* for */
+								}
+							}
+							else
+							{
+								/* FCI command has wrong data. Respond with FCI error code. */
+								NXP_LOG_ERROR("Unsupported scheduler input %d source: %d\n", (int_t)ii, (int_t)sch->input_src[ii]);
+								*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+								ret = EOK;
+								break; /* for */
+							}
 
-			/*	Copy original command properties into reply structure */
-			reply_buf->action = sch->action;
-			reply_buf->id = sch->id;
-			(void)strncpy(reply_buf->if_name, sch->if_name, sizeof(reply_buf->if_name));
-			reply_buf->if_name[sizeof(reply_buf->if_name) - 1U] = '\0';
+							NXP_LOG_DEBUG("Setting scheduler %d input %d weight: %d\n",
+									(int_t)sch->id, (int_t)ii, (int_t)oal_ntohl(sch->input_w[ii]));
+							ret = pfe_tmu_sch_set_input_weight(fci->tmu, pfe_phy_if_get_id(phy_if),
+									sch->id, ii, oal_ntohl(sch->input_w[ii]));
+							if (EOK != ret)
+							{
+								/* FCI command has wrong data. Respond with FCI error code. */
+								NXP_LOG_ERROR("Could not set scheduler %d input %d weight %d: %d\n",
+										(int_t)sch->id, (int_t)ii, (int_t)oal_ntohl(sch->input_w[ii]), (int_t)ret);
+								*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+								ret = EOK;
+								break; /* for */
+							}
+						}
+					}
 
-			/*	Get scheduler mode */
-			switch (pfe_tmu_sch_get_rate_mode(fci->tmu, pfe_phy_if_get_id(phy_if), sch->id))
-			{
-				case RATE_MODE_DATA_RATE:
-				{
-					reply_buf->mode = 1U;
 					break;
 				}
 
-				case RATE_MODE_PACKET_RATE:
+				case FPP_ACTION_QUERY:
 				{
-					reply_buf->mode = 2U;
-					break;
-				}
+					*fci_ret = FPP_ERR_OK;
 
-				default:
-				{
-					/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-					NXP_LOG_ERROR("Can't get scheduler %d mode or the mode is invalid\n", sch->id);
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-					ret = EINVAL;
-					break;
-				}
-			}
+					/*	Get physical interface ID */
+					phy_if = fci_get_phy_if_by_name(sch->if_name);
+					if (NULL == phy_if)
+					{
+						/* FCI command requested nonexistent entity. Respond with FCI error code. */
+						*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
+						ret = EOK;
+						break;
+					}
 
-			/*	Get scheduler algo */
-			reply_buf->algo = (uint8_t)pfe_tmu_sch_get_algo(fci->tmu,
-					pfe_phy_if_get_id(phy_if), sch->id);
-			if (reply_buf->algo == (uint8_t)SCHED_ALGO_INVALID)
-			{
-				/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-				NXP_LOG_ERROR("Can't get scheduler %d algo or the algo is invalid\n", sch->id);
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				ret = EINVAL;
-				break;
-			}
+					/*	Check scheduler */
+					ret = pfe_tmu_check_scheduler(fci->tmu, pfe_phy_if_get_id(phy_if), sch->id);
+					if (EOK != ret)
+					{
+						/* FCI command requested nonexistent entity. Respond with FCI error code. */
+						*fci_ret = FPP_ERR_QOS_SCHEDULER_NOT_FOUND;
+						ret = EOK;
+						break;
+					}
 
-			/*	Get enabled inputs and associated sources. See the Egress QoS chapter in FCI doc. */
-			cnt = pfe_tmu_sch_get_input_cnt(fci->tmu, pfe_phy_if_get_id(phy_if), sch->id);
-			reply_buf->input_en = 0U;
-			for (ii=0U; ii<cnt; ii++)
-			{
-				queue = pfe_tmu_sch_get_bound_queue(fci->tmu, pfe_phy_if_get_id(phy_if),
-						sch->id, ii);
-				if (PFE_TMU_INVALID_QUEUE == queue)
-				{
-					if (PFE_TMU_INVALID_SCHEDULER == pfe_tmu_sch_get_bound_sch_output(fci->tmu,
-							pfe_phy_if_get_id(phy_if), sch->id, ii))
+					/*	Copy original command properties into reply structure */
+					reply_buf->action = sch->action;
+					reply_buf->id = sch->id;
+					(void)strncpy(reply_buf->if_name, sch->if_name, sizeof(reply_buf->if_name));
+					reply_buf->if_name[sizeof(reply_buf->if_name) - 1U] = '\0';
+
+					/*	Get scheduler mode */
+					switch (pfe_tmu_sch_get_rate_mode(fci->tmu, pfe_phy_if_get_id(phy_if), sch->id))
 					{
-						/*	Scheduler input 'ii' is not connected */
-						reply_buf->input_src[ii] = 255U;
+						case RATE_MODE_DATA_RATE:
+						{
+							reply_buf->mode = 1U;
+							break;
+						}
+
+						case RATE_MODE_PACKET_RATE:
+						{
+							reply_buf->mode = 2U;
+							break;
+						}
+
+						default:
+						{
+							/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+							NXP_LOG_ERROR("Can't get scheduler %d mode or the mode is invalid\n", sch->id);
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							ret = EINVAL;
+							break;
+						}
 					}
-					else
+
+					/*	Get scheduler algo */
+					reply_buf->algo = (uint8_t)pfe_tmu_sch_get_algo(fci->tmu,
+							pfe_phy_if_get_id(phy_if), sch->id);
+					if (reply_buf->algo == (uint8_t)SCHED_ALGO_INVALID)
+					{
+						/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+						NXP_LOG_ERROR("Can't get scheduler %d algo or the algo is invalid\n", sch->id);
+						*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+						ret = EINVAL;
+						break;
+					}
+
+					/*	Get enabled inputs and associated sources. See the Egress QoS chapter in FCI doc. */
+					cnt = pfe_tmu_sch_get_input_cnt(fci->tmu, pfe_phy_if_get_id(phy_if), sch->id);
+					reply_buf->input_en = 0U;
+					for (ii=0U; ii<cnt; ii++)
 					{
-						/*	Scheduler input 'ii' is connected to prepend scheduler output */
-						weight = pfe_tmu_sch_get_input_weight(fci->tmu, pfe_phy_if_get_id(phy_if), sch->id, ii);
-						reply_buf->input_w[ii] = oal_htonl(weight);
-						reply_buf->input_src[ii] = 8U;
-						reply_buf->input_en |= ((uint32_t)1U << ii);
+						queue = pfe_tmu_sch_get_bound_queue(fci->tmu, pfe_phy_if_get_id(phy_if),
+								sch->id, ii);
+						if (PFE_TMU_INVALID_QUEUE == queue)
+						{
+							if (PFE_TMU_INVALID_SCHEDULER == pfe_tmu_sch_get_bound_sch_output(fci->tmu,
+									pfe_phy_if_get_id(phy_if), sch->id, ii))
+							{
+								/*	Scheduler input 'ii' is not connected */
+								reply_buf->input_src[ii] = 255U;
+							}
+							else
+							{
+								/*	Scheduler input 'ii' is connected to prepend scheduler output */
+								weight = pfe_tmu_sch_get_input_weight(fci->tmu, pfe_phy_if_get_id(phy_if), sch->id, ii);
+								reply_buf->input_w[ii] = oal_htonl(weight);
+								reply_buf->input_src[ii] = 8U;
+								reply_buf->input_en |= ((uint32_t)1U << ii);
+							}
+						}
+						else
+						{
+							/*	Scheduler input 'ii' is connected to queue */
+							weight = pfe_tmu_sch_get_input_weight(fci->tmu, pfe_phy_if_get_id(phy_if), sch->id, ii);
+							reply_buf->input_w[ii] = oal_htonl(weight);
+							reply_buf->input_src[ii] = queue;
+							reply_buf->input_en |= ((uint32_t)1U << ii);
+						}
 					}
+
+					/*	Maintain endianness as given by FCI doc */
+					reply_buf->input_en = oal_htonl(reply_buf->input_en);
+
+					*reply_len = sizeof(fpp_qos_scheduler_cmd_t);
+					break;
 				}
-				else
+
+				default:
 				{
-					/*	Scheduler input 'ii' is connected to queue */
-					weight = pfe_tmu_sch_get_input_weight(fci->tmu, pfe_phy_if_get_id(phy_if), sch->id, ii);
-					reply_buf->input_w[ii] = oal_htonl(weight);
-					reply_buf->input_src[ii] = queue;
-					reply_buf->input_en |= ((uint32_t)1U << ii);
+					NXP_LOG_ERROR("FPP_CMD_QOS_SCHEDULER: Unknown action received: 0x%x\n", sch->action);
+					*fci_ret = FPP_ERR_UNKNOWN_ACTION;
+					break;
 				}
 			}
 
-			/*	Maintain endianness as given by FCI doc */
-			reply_buf->input_en = oal_htonl(reply_buf->input_en);
-
-			*reply_len = sizeof(fpp_qos_scheduler_cmd_t);
-			break;
-		}
-
-		default:
-		{
-			NXP_LOG_ERROR("FPP_CMD_QOS_SCHEDULER: Unknown action received: 0x%x\n", sch->action);
-			*fci_ret = FPP_ERR_UNKNOWN_ACTION;
-			break;
 		}
 	}
-
 	return ret;
 }
 
@@ -692,255 +693,255 @@ errno_t fci_qos_shaper_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_shaper_cmd
 	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	if (unlikely(FALSE == __context.fci_initialized))
+	else if (unlikely(FALSE == __context.fci_initialized))
 	{
 		NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (*reply_len < sizeof(fpp_qos_shaper_cmd_t))
-	{
-		NXP_LOG_ERROR("Buffer length does not match expected value (fpp_qos_shaper_cmd_t)\n");
-		return EINVAL;
+		ret = EPERM;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		/*	No data written to reply buffer (yet) */
-		*reply_len = 0U;
-	}
-
-	/*	Initialize the reply buffer */
-	(void)memset(reply_buf, 0, sizeof(fpp_qos_shaper_cmd_t));
-	shp = (fpp_qos_shaper_cmd_t *)msg->msg_cmd.payload;
-
-	switch(shp->action)
-	{
-		case FPP_ACTION_UPDATE:
+		if (*reply_len < sizeof(fpp_qos_shaper_cmd_t))
 		{
-			*fci_ret = FPP_ERR_OK;
-
-			/*	Get physical interface ID */
-			phy_if = fci_get_phy_if_by_name(shp->if_name);
-			if (NULL == phy_if)
+			NXP_LOG_ERROR("Buffer length does not match expected value (fpp_qos_shaper_cmd_t)\n");
+			ret = EINVAL;
+		}
+		else
+		{
+			/*	No data written to reply buffer (yet) */
+			*reply_len = 0U;
+			
+			/*	Initialize the reply buffer */
+			(void)memset(reply_buf, 0, sizeof(fpp_qos_shaper_cmd_t));
+			shp = (fpp_qos_shaper_cmd_t *)msg->msg_cmd.payload;
+
+			switch(shp->action)
 			{
-				/* FCI command requested nonexistent entity. Respond with FCI error code. */
-				*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-				ret = EOK;
-				break;
-			}
+				case FPP_ACTION_UPDATE:
+				{
+					*fci_ret = FPP_ERR_OK;
 
-			/*	Check shaper */
-			ret = pfe_tmu_check_shaper(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id);
-			if (EOK != ret)
-			{
-				/* FCI command requested nonexistent entity. Respond with FCI error code. */
-				*fci_ret = FPP_ERR_QOS_SHAPER_NOT_FOUND;
-				ret = EOK;
-				break;
-			}
+					/*	Get physical interface ID */
+					phy_if = fci_get_phy_if_by_name(shp->if_name);
+					if (NULL == phy_if)
+					{
+						/* FCI command requested nonexistent entity. Respond with FCI error code. */
+						*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
+						ret = EOK;
+						break;
+					}
 
-			if (0U == shp->mode)
-			{
-				if (255U == shp->position)
-				{
-					NXP_LOG_DEBUG("Disconnecting shaper %d\n", shp->id);
-					ret = pfe_tmu_shp_set_position(fci->tmu, pfe_phy_if_get_id(phy_if),
-							shp->id, PFE_TMU_INVALID_POSITION);
+					/*	Check shaper */
+					ret = pfe_tmu_check_shaper(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id);
 					if (EOK != ret)
 					{
-						/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-						NXP_LOG_ERROR("Could not disconnect shaper %d: %d\n", shp->id, ret);
-						*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+						/* FCI command requested nonexistent entity. Respond with FCI error code. */
+						*fci_ret = FPP_ERR_QOS_SHAPER_NOT_FOUND;
+						ret = EOK;
 						break;
 					}
-				}
 
-				NXP_LOG_DEBUG("Disabling shaper %d\n", shp->id);
-				ret = pfe_tmu_shp_disable(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id);
-				if (EOK != ret)
-				{
-					/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-					NXP_LOG_ERROR("Could not disable shaper %d: %d\n", shp->id, ret);
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-					break;
-				}
-			}
-			else
-			{
-				NXP_LOG_DEBUG("Enabling shaper %d\n", shp->id);
-				ret = pfe_tmu_shp_enable(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id);
-				if (EOK != ret)
-				{
-					/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-					NXP_LOG_ERROR("Could not enable shaper %d: %d\n", shp->id, ret);
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-					break;
-				}
+					if (0U == shp->mode)
+					{
+						if (255U == shp->position)
+						{
+							NXP_LOG_DEBUG("Disconnecting shaper %d\n", shp->id);
+							ret = pfe_tmu_shp_set_position(fci->tmu, pfe_phy_if_get_id(phy_if),
+									shp->id, PFE_TMU_INVALID_POSITION);
+							if (EOK != ret)
+							{
+								/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+								NXP_LOG_ERROR("Could not disconnect shaper %d: %d\n", shp->id, ret);
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+								break;
+							}
+						}
 
-				NXP_LOG_DEBUG("Setting shaper %d rate mode %d\n", shp->id, shp->mode);
-				if (1U == shp->mode)
-				{
-					ret = pfe_tmu_shp_set_rate_mode(fci->tmu, pfe_phy_if_get_id(phy_if),
-						shp->id, RATE_MODE_DATA_RATE);
-				}
-				else if (2U == shp->mode)
-				{
-					ret = pfe_tmu_shp_set_rate_mode(fci->tmu, pfe_phy_if_get_id(phy_if),
-						shp->id, RATE_MODE_PACKET_RATE);
-				}
-				else
-				{
-					/* FCI command has wrong data. Respond with FCI error code. */
-					NXP_LOG_ERROR("Invalid shaper rate mode value: %d\n", shp->mode);
-					*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-					ret = EOK;
-					break;
-				}
+						NXP_LOG_DEBUG("Disabling shaper %d\n", shp->id);
+						ret = pfe_tmu_shp_disable(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id);
+						if (EOK != ret)
+						{
+							/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+							NXP_LOG_ERROR("Could not disable shaper %d: %d\n", shp->id, ret);
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							break;
+						}
+					}
+					else
+					{
+						NXP_LOG_DEBUG("Enabling shaper %d\n", shp->id);
+						ret = pfe_tmu_shp_enable(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id);
+						if (EOK != ret)
+						{
+							/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+							NXP_LOG_ERROR("Could not enable shaper %d: %d\n", shp->id, ret);
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							break;
+						}
 
-				if (EOK != ret)
-				{
-					/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
-					NXP_LOG_ERROR("Unable to set shaper %d rate mode %d: %d\n",
-							shp->id, shp->mode, ret);
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-					break;
-				}
+						NXP_LOG_DEBUG("Setting shaper %d rate mode %d\n", shp->id, shp->mode);
+						if (1U == shp->mode)
+						{
+							ret = pfe_tmu_shp_set_rate_mode(fci->tmu, pfe_phy_if_get_id(phy_if),
+								shp->id, RATE_MODE_DATA_RATE);
+						}
+						else if (2U == shp->mode)
+						{
+							ret = pfe_tmu_shp_set_rate_mode(fci->tmu, pfe_phy_if_get_id(phy_if),
+								shp->id, RATE_MODE_PACKET_RATE);
+						}
+						else
+						{
+							/* FCI command has wrong data. Respond with FCI error code. */
+							NXP_LOG_ERROR("Invalid shaper rate mode value: %d\n", shp->mode);
+							*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+							ret = EOK;
+							break;
+						}
 
-				NXP_LOG_DEBUG("Setting shaper %d credit limits %d-%d\n",
-						(int_t)shp->id, (int_t)oal_ntohl(shp->max_credit), (int_t)oal_ntohl(shp->min_credit));
-				ret = pfe_tmu_shp_set_limits(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id,
-						(int32_t)oal_ntohl(shp->max_credit), (int32_t)oal_ntohl(shp->min_credit));
-				if (EOK != ret)
-				{
-					/* FCI command has wrong data. Respond with FCI error code. */
-					NXP_LOG_ERROR("Unable to set shaper %d limits: %d\n", shp->id, ret);
-					*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-					ret = EOK;
-					break;
-				}
+						if (EOK != ret)
+						{
+							/* Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+							NXP_LOG_ERROR("Unable to set shaper %d rate mode %d: %d\n",
+									shp->id, shp->mode, ret);
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							break;
+						}
+
+						NXP_LOG_DEBUG("Setting shaper %d credit limits %d-%d\n",
+								(int_t)shp->id, (int_t)oal_ntohl(shp->max_credit), (int_t)oal_ntohl(shp->min_credit));
+						ret = pfe_tmu_shp_set_limits(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id,
+								(int32_t)oal_ntohl(shp->max_credit), (int32_t)oal_ntohl(shp->min_credit));
+						if (EOK != ret)
+						{
+							/* FCI command has wrong data. Respond with FCI error code. */
+							NXP_LOG_ERROR("Unable to set shaper %d limits: %d\n", shp->id, ret);
+							*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+							ret = EOK;
+							break;
+						}
+
+						NXP_LOG_DEBUG("Setting shaper %d position to %d\n", shp->id, shp->position);
+						ret = pfe_tmu_shp_set_position(fci->tmu, pfe_phy_if_get_id(phy_if),
+								shp->id, shp->position);
+						if (EOK != ret)
+						{
+							/* FCI command has wrong data. Respond with FCI error code. */
+							NXP_LOG_ERROR("Can't set shaper %d at position %d: %d\n",
+									shp->id, shp->position, ret);
+							*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+							ret = EOK;
+							break;
+						}
+
+						NXP_LOG_DEBUG("Setting shaper %d idle slope: %d\n",
+								(int_t)shp->id, (int_t)oal_ntohl(shp->isl));
+						ret = pfe_tmu_shp_set_idle_slope(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id,
+								oal_ntohl(shp->isl));
+						if (EOK != ret)
+						{
+							/* FCI command has wrong data. Respond with FCI error code. */
+							NXP_LOG_ERROR("Can't set shaper %d idle slope %d: %d\n",
+									(int_t)shp->id, (int_t)oal_ntohl(shp->isl), (int_t)ret);
+							*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+							ret = EOK;
+							break;
+						}
+					}
 
-				NXP_LOG_DEBUG("Setting shaper %d position to %d\n", shp->id, shp->position);
-				ret = pfe_tmu_shp_set_position(fci->tmu, pfe_phy_if_get_id(phy_if),
-						shp->id, shp->position);
-				if (EOK != ret)
-				{
-					/* FCI command has wrong data. Respond with FCI error code. */
-					NXP_LOG_ERROR("Can't set shaper %d at position %d: %d\n",
-							shp->id, shp->position, ret);
-					*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-					ret = EOK;
 					break;
 				}
 
-				NXP_LOG_DEBUG("Setting shaper %d idle slope: %d\n",
-						(int_t)shp->id, (int_t)oal_ntohl(shp->isl));
-				ret = pfe_tmu_shp_set_idle_slope(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id,
-						oal_ntohl(shp->isl));
-				if (EOK != ret)
+				case FPP_ACTION_QUERY:
 				{
-					/* FCI command has wrong data. Respond with FCI error code. */
-					NXP_LOG_ERROR("Can't set shaper %d idle slope %d: %d\n",
-							(int_t)shp->id, (int_t)oal_ntohl(shp->isl), (int_t)ret);
-					*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-					ret = EOK;
-					break;
-				}
-			}
+					*fci_ret = FPP_ERR_OK;
 
-			break;
-		}
+					/*	Get physical interface ID */
+					phy_if = fci_get_phy_if_by_name(shp->if_name);
+					if (NULL == phy_if)
+					{
+						/* FCI command requested nonexistent entity. Respond with FCI error code. */
+						*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
+						ret = EOK;
+						break;
+					}
 
-		case FPP_ACTION_QUERY:
-		{
-			*fci_ret = FPP_ERR_OK;
+					/*	Check shaper */
+					ret = pfe_tmu_check_shaper(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id);
+					if (EOK != ret)
+					{
+						/* FCI command requested nonexistent entity. Respond with FCI error code. */
+						*fci_ret = FPP_ERR_QOS_SHAPER_NOT_FOUND;
+						ret = EOK;
+						break;
+					}
 
-			/*	Get physical interface ID */
-			phy_if = fci_get_phy_if_by_name(shp->if_name);
-			if (NULL == phy_if)
-			{
-				/* FCI command requested nonexistent entity. Respond with FCI error code. */
-				*fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-				ret = EOK;
-				break;
-			}
+					/*	Copy original command properties into reply structure */
+					reply_buf->action = shp->action;
+					reply_buf->id = shp->id;
+					(void)strncpy(reply_buf->if_name, shp->if_name, sizeof(reply_buf->if_name));
+					reply_buf->if_name[sizeof(reply_buf->if_name) - 1U] = '\0';
 
-			/*	Check shaper */
-			ret = pfe_tmu_check_shaper(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id);
-			if (EOK != ret)
-			{
-				/* FCI command requested nonexistent entity. Respond with FCI error code. */
-				*fci_ret = FPP_ERR_QOS_SHAPER_NOT_FOUND;
-				ret = EOK;
-				break;
-			}
+					/*	Get shaper mode */
+					switch (pfe_tmu_shp_get_rate_mode(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id))
+					{
+						case RATE_MODE_DATA_RATE:
+						{
+							reply_buf->mode = 1U;
+							break;
+						}
 
-			/*	Copy original command properties into reply structure */
-			reply_buf->action = shp->action;
-			reply_buf->id = shp->id;
-			(void)strncpy(reply_buf->if_name, shp->if_name, sizeof(reply_buf->if_name));
-			reply_buf->if_name[sizeof(reply_buf->if_name) - 1U] = '\0';
+						case RATE_MODE_PACKET_RATE:
+						{
+							reply_buf->mode = 2U;
+							break;
+						}
 
-			/*	Get shaper mode */
-			switch (pfe_tmu_shp_get_rate_mode(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id))
-			{
-				case RATE_MODE_DATA_RATE:
-				{
-					reply_buf->mode = 1U;
-					break;
-				}
+						default:
+						{
+							/*	Shaper is disabled or the query failed */
+							reply_buf->mode = 0U;
+							break;
+						}
+					}
 
-				case RATE_MODE_PACKET_RATE:
-				{
-					reply_buf->mode = 2U;
+					/*	Get credit limits */
+					ret = pfe_tmu_shp_get_limits(fci->tmu, pfe_phy_if_get_id(phy_if),
+							shp->id, &reply_buf->max_credit, &reply_buf->min_credit);
+					if (ret != EOK)
+					{
+						NXP_LOG_ERROR("Could not get shaper %d limits: %d\n", shp->id, ret);
+					}
+					else
+					{
+						/*	Ensure expected endianness */
+						reply_buf->max_credit = (int32_t)oal_htonl(reply_buf->max_credit);
+						reply_buf->min_credit = (int32_t)oal_htonl(reply_buf->min_credit);
+					}
+
+					/*	Get idle slope */
+					isl = pfe_tmu_shp_get_idle_slope(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id);
+					reply_buf->isl = oal_htonl(isl);
+
+					/*	Get shaper position */
+					reply_buf->position =
+							pfe_tmu_shp_get_position(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id);
+
+					*reply_len = sizeof(fpp_qos_shaper_cmd_t);
 					break;
 				}
 
 				default:
 				{
-					/*	Shaper is disabled or the query failed */
-					reply_buf->mode = 0U;
+					NXP_LOG_ERROR("FPP_CMD_QOS_SHAPER: Unknown action received: 0x%x\n", shp->action);
+					*fci_ret = FPP_ERR_UNKNOWN_ACTION;
 					break;
 				}
 			}
-
-			/*	Get credit limits */
-			ret = pfe_tmu_shp_get_limits(fci->tmu, pfe_phy_if_get_id(phy_if),
-					shp->id, &reply_buf->max_credit, &reply_buf->min_credit);
-			if (ret != EOK)
-			{
-				NXP_LOG_ERROR("Could not get shaper %d limits: %d\n", shp->id, ret);
-			}
-			else
-			{
-				/*	Ensure expected endianness */
-				reply_buf->max_credit = (int32_t)oal_htonl(reply_buf->max_credit);
-				reply_buf->min_credit = (int32_t)oal_htonl(reply_buf->min_credit);
-			}
-
-			/*	Get idle slope */
-			isl = pfe_tmu_shp_get_idle_slope(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id);
-			reply_buf->isl = oal_htonl(isl);
-
-			/*	Get shaper position */
-			reply_buf->position =
-					pfe_tmu_shp_get_position(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id);
-
-			*reply_len = sizeof(fpp_qos_shaper_cmd_t);
-			break;
-		}
-
-		default:
-		{
-			NXP_LOG_ERROR("FPP_CMD_QOS_SHAPER: Unknown action received: 0x%x\n", shp->action);
-			*fci_ret = FPP_ERR_UNKNOWN_ACTION;
-			break;
 		}
 	}
-
 	return ret;
 }
 
@@ -959,30 +960,31 @@ static pfe_gpi_t *fci_qos_get_gpi(const pfe_phy_if_t *phy_if)
 
 static errno_t fci_validate_cmd_params(const fci_msg_t *msg, uint16_t *fci_ret, void *reply_buf, uint32_t *reply_len, uint32_t cmd_len)
 {
+	errno_t ret = EOK;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	if (unlikely(FALSE == __context.fci_initialized))
+	else if (unlikely(FALSE == __context.fci_initialized))
 	{
 		NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
+		ret = EPERM;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-    (void)msg;
-    (void)fci_ret;
-    (void)reply_buf;
-	if (*reply_len < cmd_len)
-	{
-		NXP_LOG_ERROR("Buffer length does not match command lenght\n");
-		return EINVAL;
+	{		
+		(void)msg;
+		(void)fci_ret;
+		(void)reply_buf;
+		if (*reply_len < cmd_len)
+		{
+			NXP_LOG_ERROR("Buffer length does not match command lenght\n");
+			ret = EINVAL;
+		}
 	}
-
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1001,159 +1003,180 @@ errno_t fci_qos_policer_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_policer_c
 	errno_t ret = EOK;
 
 	ret = fci_validate_cmd_params(msg, fci_ret, reply_buf, reply_len, sizeof(*pol_cmd));
-	if (EOK != ret)
-	{
-		return ret;
-	}
-	else
+	if (EOK == ret)
 	{
 		/*	No data written to reply buffer (yet) */
 		*reply_len = 0U;
-	}
-	/*	Initialize the reply buffer */
-	(void)memset(reply_buf, 0, sizeof(*reply_buf));
-
-	pol_cmd = (fpp_qos_policer_cmd_t *)msg->msg_cmd.payload;
-
-	/* get from phy_if to gpi */
-	phy_if = fci_get_phy_if_by_name(pol_cmd->if_name);
-	if (NULL == phy_if)
-	{
-		*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-		return ENOENT;
-	}
 
-	gpi = fci_qos_get_gpi(phy_if);
-	if (NULL == gpi)
-	{
-		*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-		return ENOENT;
-	}
+		/*	Initialize the reply buffer */
+		(void)memset(reply_buf, 0, sizeof(*reply_buf));
 
-	*fci_ret = FPP_ERR_OK;
+		pol_cmd = (fpp_qos_policer_cmd_t *)msg->msg_cmd.payload;
 
-	switch(pol_cmd->action)
-	{
-		case FPP_ACTION_UPDATE:
+		/* get from phy_if to gpi */
+		phy_if = fci_get_phy_if_by_name(pol_cmd->if_name);
+		if (NULL == phy_if)
 		{
-			if (0U != pol_cmd->enable)
+			*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+			ret = ENOENT;
+		}
+		else
+		{
+			gpi = fci_qos_get_gpi(phy_if);
+			if (NULL == gpi)
 			{
-				ret = pfe_gpi_qos_enable(gpi);
+				*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+				ret = ENOENT;
 			}
 			else
 			{
-				ret = pfe_gpi_qos_disable(gpi);
-			}
-
-			if (EOK != ret)
-			{
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-			}
-
-			break;
-		}
-
-		case FPP_ACTION_QUERY:
-		{
-			/*	Copy original command properties into reply structure */
-			reply_buf->action = pol_cmd->action;
-			(void)strncpy(reply_buf->if_name, pol_cmd->if_name, sizeof(reply_buf->if_name));
-			reply_buf->if_name[sizeof(reply_buf->if_name) - 1U] = '\0';
-
-			/*	get policer data */
-			reply_buf->enable = pfe_gpi_qos_is_enabled(gpi);
-			*reply_len = sizeof(*pol_cmd);
-			break;
-		}
+				*fci_ret = FPP_ERR_OK;
 
-		default:
-		{
-			NXP_LOG_ERROR("FPP_CMD_QOS_POLICER: Unknown action received: 0x%x\n", pol_cmd->action);
-			*fci_ret = FPP_ERR_UNKNOWN_ACTION;
-			break;
+				switch(pol_cmd->action)
+				{
+					case FPP_ACTION_UPDATE:
+					{
+						if (0U != pol_cmd->enable)
+						{
+							ret = pfe_gpi_qos_enable(gpi);
+						}
+						else
+						{
+							ret = pfe_gpi_qos_disable(gpi);
+						}
+
+						if (EOK != ret)
+						{
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+						}
+
+						break;
+					}
+
+					case FPP_ACTION_QUERY:
+					{
+						/*	Copy original command properties into reply structure */
+						reply_buf->action = pol_cmd->action;
+						(void)strncpy(reply_buf->if_name, pol_cmd->if_name, sizeof(reply_buf->if_name));
+						reply_buf->if_name[sizeof(reply_buf->if_name) - 1U] = '\0';
+
+						/*	get policer data */
+						reply_buf->enable = pfe_gpi_qos_is_enabled(gpi);
+						*reply_len = sizeof(*pol_cmd);
+						break;
+					}
+
+					default:
+					{
+						NXP_LOG_ERROR("FPP_CMD_QOS_POLICER: Unknown action received: 0x%x\n", pol_cmd->action);
+						*fci_ret = FPP_ERR_UNKNOWN_ACTION;
+						break;
+					}
+				}
+			}
 		}
 	}
+	
 	return ret;
 }
 
 static errno_t fci_qos_flow_entry_validate_and_fixup_masks(pfe_iqos_flow_spec_t *flow)
 {
 	pfe_iqos_flow_args_t *args = &flow->args;
+	errno_t ret = EOK;
 
 	if (((uint16_t)flow->type_mask >= ((uint16_t)PFE_IQOS_FLOW_TYPE_MAX << 1)) ||
 	    ((uint16_t)flow->arg_type_mask >= ((uint16_t)PFE_IQOS_ARG_MAX << 1)) ||
 	    (flow->action >= PFE_IQOS_FLOW_COUNT))
 	{
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	if (((uint16_t)flow->arg_type_mask & (uint16_t)PFE_IQOS_ARG_VLAN) != 0U)
+	else
 	{
-		if ((args->vlan > PFE_IQOS_VLAN_ID_MASK) || (args->vlan_m > PFE_IQOS_VLAN_ID_MASK))
-		{
-			return EINVAL;
-		}
-		/* fixup */
-		if (args->vlan_m == 0U)
-		{
-			/* mask not specified */
-			args->vlan_m = PFE_IQOS_VLAN_ID_MASK;
-		}
-	}
 
-	if (((uint16_t)flow->arg_type_mask & (uint16_t)PFE_IQOS_ARG_TOS) != 0U)
-	{
-		/* fixup */
-		if (args->tos_m == 0U)
+		if (((uint16_t)flow->arg_type_mask & (uint16_t)PFE_IQOS_ARG_VLAN) != 0U)
 		{
-			/* mask not specified */
-			args->tos_m = PFE_IQOS_TOS_MASK;
+			if ((args->vlan > PFE_IQOS_VLAN_ID_MASK) || (args->vlan_m > PFE_IQOS_VLAN_ID_MASK))
+			{
+				ret = EINVAL;
+			}
+			else
+			{
+				/* fixup */
+				if (args->vlan_m == 0U)
+				{
+					/* mask not specified */
+					args->vlan_m = PFE_IQOS_VLAN_ID_MASK;
+				}
+			}
 		}
-	}
-
-	if (((uint16_t)flow->arg_type_mask & (uint16_t)PFE_IQOS_ARG_L4PROTO) != 0U)
-	{
-		/* fixup */
-		if (args->l4proto_m == 0U)
+	
+		if (EOK == ret)
 		{
-			/* mask not specified */
-			args->l4proto_m = PFE_IQOS_L4PROTO_MASK;
-		}
-	}
+			if (((uint16_t)flow->arg_type_mask & (uint16_t)PFE_IQOS_ARG_TOS) != 0U)
+			{
+				/* fixup */
+				if (args->tos_m == 0U)
+				{
+					/* mask not specified */
+					args->tos_m = PFE_IQOS_TOS_MASK;
+				}
+			}
 
-	if (((uint16_t)flow->arg_type_mask & (uint16_t)PFE_IQOS_ARG_SIP) != 0U)
-	{
-		if (args->sip_m > PFE_IQOS_SDIP_MASK)
-		{
-			return EINVAL;
+			if (((uint16_t)flow->arg_type_mask & (uint16_t)PFE_IQOS_ARG_L4PROTO) != 0U)
+			{
+				/* fixup */
+				if (args->l4proto_m == 0U)
+				{
+					/* mask not specified */
+					args->l4proto_m = PFE_IQOS_L4PROTO_MASK;
+				}
+			}
+		
+			if (((uint16_t)flow->arg_type_mask & (uint16_t)PFE_IQOS_ARG_SIP) != 0U)
+			{
+				if (args->sip_m > PFE_IQOS_SDIP_MASK)
+				{
+					ret = EINVAL;
+				}
+			}
 		}
-	}
 
-	if (((uint16_t)flow->arg_type_mask & (uint16_t)PFE_IQOS_ARG_DIP) != 0U)
-	{
-		if (args->dip_m > PFE_IQOS_SDIP_MASK)
+		if (EOK == ret)
 		{
-			return EINVAL;
+			if (((uint16_t)flow->arg_type_mask & (uint16_t)PFE_IQOS_ARG_DIP) != 0U)
+			{
+				if (args->dip_m > PFE_IQOS_SDIP_MASK)
+				{
+					ret = EINVAL;
+				}
+			}
 		}
-	}
 
-	if (((uint16_t)flow->arg_type_mask & (uint16_t)PFE_IQOS_ARG_SPORT) != 0U)
-	{
-		if (args->sport_min > args->sport_max)
+		if (EOK == ret)
 		{
-			return EINVAL;
+			if (((uint16_t)flow->arg_type_mask & (uint16_t)PFE_IQOS_ARG_SPORT) != 0U)
+			{
+				if (args->sport_min > args->sport_max)
+				{
+					ret = EINVAL;
+				}
+			}
 		}
-	}
 
-	if (((uint16_t)flow->arg_type_mask & (uint16_t)PFE_IQOS_ARG_DPORT) != 0U)
-	{
-		if (args->dport_min > args->dport_max)
+		if (EOK == ret)
 		{
-			return EINVAL;
+			if (((uint16_t)flow->arg_type_mask & (uint16_t)PFE_IQOS_ARG_DPORT) != 0U)
+			{
+				if (args->dport_min > args->dport_max)
+				{
+					ret = EINVAL;
+				}
+			}
 		}
 	}
 
-	return EOK;
+	return ret;
 }
 
 static void fci_qos_flow_entry_convert_to_gpi(const fpp_iqos_flow_spec_t *flow, pfe_iqos_flow_spec_t *gpi_flow)
@@ -1222,140 +1245,140 @@ errno_t fci_qos_policer_flow_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_poli
 
     (void)memset(&gpi_flow, 0, sizeof(pfe_iqos_flow_spec_t));
 	ret = fci_validate_cmd_params(msg, fci_ret, reply_buf, reply_len, sizeof(*flow_cmd));
-	if (EOK != ret)
-	{
-		return ret;
-	}
-	else
+	if (EOK == ret)
 	{
 		/*	No data written to reply buffer (yet) */
 		*reply_len = 0U;
-	}
-	/*	Initialize the reply buffer */
-	(void)memset(reply_buf, 0, sizeof(*reply_buf));
+		/*	Initialize the reply buffer */
+		(void)memset(reply_buf, 0, sizeof(*reply_buf));
 
-	flow_cmd = (fpp_qos_policer_flow_cmd_t *)msg->msg_cmd.payload;
+		flow_cmd = (fpp_qos_policer_flow_cmd_t *)msg->msg_cmd.payload;
 
-	/* get from phy_if to gpi */
-	phy_if = fci_get_phy_if_by_name(flow_cmd->if_name);
-	if (NULL == phy_if)
-	{
-		*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-		return ENOENT;
-	}
-
-	gpi = fci_qos_get_gpi(phy_if);
-	if (NULL == gpi)
-	{
-		*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-		return ENOENT;
-	}
-
-	*fci_ret = FPP_ERR_OK;
-
-	switch(flow_cmd->action)
-	{
-		case FPP_ACTION_REGISTER:
+		/* get from phy_if to gpi */
+		phy_if = fci_get_phy_if_by_name(flow_cmd->if_name);
+		if (NULL == phy_if)
 		{
-			/* populate gpi flow struct */
-			fci_qos_flow_entry_convert_to_gpi(&flow_cmd->flow, &gpi_flow);
-
-			ret = fci_qos_flow_entry_validate_and_fixup_masks(&gpi_flow);
-			if (EOK != ret)
-			{
-				*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-				break;
-			}
-
-			/* id == 0xFF means the driver chooses the entry position */
-			if ((flow_cmd->id >= PFE_IQOS_FLOW_TABLE_SIZE) && (flow_cmd->id != 0xFFU))
-			{
-				*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-				break;
-			}
-
-			/* commit configuration to H/W */
-			ret = pfe_gpi_qos_add_flow(gpi, flow_cmd->id, &gpi_flow);
-			if (EOVERFLOW == ret)
-			{
-				*fci_ret = FPP_ERR_QOS_POLICER_FLOW_TABLE_FULL;
-				break;
-			}
-			else if (EOK != ret)
-			{
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				break;
-			}
-			else
-			{
-				;/* Required by Misra */
-			}
-			break;
+			*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+			ret = ENOENT;
 		}
-		case FPP_ACTION_DEREGISTER:
+		else
 		{
-			if (flow_cmd->id >= PFE_IQOS_FLOW_TABLE_SIZE)
+			gpi = fci_qos_get_gpi(phy_if);
+			if (NULL == gpi)
 			{
 				*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-				break;
+				ret = ENOENT;
 			}
+			else
+			{				
+				*fci_ret = FPP_ERR_OK;
 
-			ret = pfe_gpi_qos_rem_flow(gpi, flow_cmd->id);
-			if (ret != EOK)
-			{
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-			}
+				switch(flow_cmd->action)
+				{
+					case FPP_ACTION_REGISTER:
+					{
+						/* populate gpi flow struct */
+						fci_qos_flow_entry_convert_to_gpi(&flow_cmd->flow, &gpi_flow);
 
-			break;
-		}
-		case FPP_ACTION_QUERY:
-		{
-			/*	Copy original command properties into reply structure */
-			reply_buf->action = flow_cmd->action;
-			(void)strncpy(reply_buf->if_name, flow_cmd->if_name, sizeof(reply_buf->if_name));
-			reply_buf->if_name[sizeof(reply_buf->if_name) - 1U] = '\0';
+						ret = fci_qos_flow_entry_validate_and_fixup_masks(&gpi_flow);
+						if (EOK != ret)
+						{
+							*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+							break;
+						}
 
-			ret = pfe_gpi_qos_get_first_flow(gpi, &reply_buf->id, &gpi_flow);
-			if (ret != EOK)
-			{
-				*fci_ret = FPP_ERR_QOS_POLICER_FLOW_NOT_FOUND;
-				ret = EOK;
-				break;
-			}
+						/* id == 0xFF means the driver chooses the entry position */
+						if ((flow_cmd->id >= PFE_IQOS_FLOW_TABLE_SIZE) && (flow_cmd->id != 0xFFU))
+						{
+							*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+							break;
+						}
+
+						/* commit configuration to H/W */
+						ret = pfe_gpi_qos_add_flow(gpi, flow_cmd->id, &gpi_flow);
+						if (EOVERFLOW == ret)
+						{
+							*fci_ret = FPP_ERR_QOS_POLICER_FLOW_TABLE_FULL;
+							break;
+						}
+						else if (EOK != ret)
+						{
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+							break;
+						}
+						else
+						{
+							;/* Required by Misra */
+						}
+						break;
+					}
+					case FPP_ACTION_DEREGISTER:
+					{
+						if (flow_cmd->id >= PFE_IQOS_FLOW_TABLE_SIZE)
+						{
+							*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+							break;
+						}
 
-			/* populate fci flow struct */
-			fci_qos_flow_entry_convert_from_gpi(&gpi_flow, &reply_buf->flow);
+						ret = pfe_gpi_qos_rem_flow(gpi, flow_cmd->id);
+						if (ret != EOK)
+						{
+							*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+						}
 
-			*reply_len = sizeof(*flow_cmd);
-			break;
-		}
+						break;
+					}
+					case FPP_ACTION_QUERY:
+					{
+						/*	Copy original command properties into reply structure */
+						reply_buf->action = flow_cmd->action;
+						(void)strncpy(reply_buf->if_name, flow_cmd->if_name, sizeof(reply_buf->if_name));
+						reply_buf->if_name[sizeof(reply_buf->if_name) - 1U] = '\0';
 
-		case FPP_ACTION_QUERY_CONT:
-		{
-			/*	Copy original command properties into reply structure */
-			reply_buf->action = flow_cmd->action;
-			(void)strncpy(reply_buf->if_name, flow_cmd->if_name, sizeof(reply_buf->if_name));
-			reply_buf->if_name[sizeof(reply_buf->if_name) - 1U] = '\0';
+						ret = pfe_gpi_qos_get_first_flow(gpi, &reply_buf->id, &gpi_flow);
+						if (ret != EOK)
+						{
+							*fci_ret = FPP_ERR_QOS_POLICER_FLOW_NOT_FOUND;
+							ret = EOK;
+							break;
+						}
 
-			ret = pfe_gpi_qos_get_next_flow(gpi, &reply_buf->id, &gpi_flow);
-			if (ret != EOK)
-			{
-				*fci_ret = FPP_ERR_QOS_POLICER_FLOW_NOT_FOUND;
-				ret = EOK;
-				break;
-			}
+						/* populate fci flow struct */
+						fci_qos_flow_entry_convert_from_gpi(&gpi_flow, &reply_buf->flow);
 
-			/* populate fci flow struct */
-			fci_qos_flow_entry_convert_from_gpi(&gpi_flow, &reply_buf->flow);
+						*reply_len = sizeof(*flow_cmd);
+						break;
+					}
 
-			*reply_len = sizeof(*flow_cmd);
-			break;
-		}
-		default:
-		{
-			NXP_LOG_ERROR("FPP_CMD_QOS_POLICER_FLOW: Unknown action received: 0x%x\n", flow_cmd->action);
-			*fci_ret = FPP_ERR_UNKNOWN_ACTION;
-			break;
+					case FPP_ACTION_QUERY_CONT:
+					{
+						/*	Copy original command properties into reply structure */
+						reply_buf->action = flow_cmd->action;
+						(void)strncpy(reply_buf->if_name, flow_cmd->if_name, sizeof(reply_buf->if_name));
+						reply_buf->if_name[sizeof(reply_buf->if_name) - 1U] = '\0';
+
+						ret = pfe_gpi_qos_get_next_flow(gpi, &reply_buf->id, &gpi_flow);
+						if (ret != EOK)
+						{
+							*fci_ret = FPP_ERR_QOS_POLICER_FLOW_NOT_FOUND;
+							ret = EOK;
+							break;
+						}
+
+						/* populate fci flow struct */
+						fci_qos_flow_entry_convert_from_gpi(&gpi_flow, &reply_buf->flow);
+
+						*reply_len = sizeof(*flow_cmd);
+						break;
+					}
+					default:
+					{
+						NXP_LOG_ERROR("FPP_CMD_QOS_POLICER_FLOW: Unknown action received: 0x%x\n", flow_cmd->action);
+						*fci_ret = FPP_ERR_UNKNOWN_ACTION;
+						break;
+					}
+				}
+			}
 		}
 	}
 
@@ -1373,162 +1396,166 @@ errno_t fci_qos_policer_wred_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_poli
 	uint32_t i;
 
 	ret = fci_validate_cmd_params(msg, fci_ret, reply_buf, reply_len, sizeof(*wred_cmd));
-	if (EOK != ret)
-	{
-		return ret;
-	}
-	else
+	if (EOK == ret)
 	{
 		/* no data written to reply buffer (yet) */
 		*reply_len = 0U;
-	}
-	/* initialize the reply buffer */
-	(void)memset(reply_buf, 0, sizeof(*reply_buf));
 
-	/* map command structure to message payload (requires casting) */
-	wred_cmd = (fpp_qos_policer_wred_cmd_t *)msg->msg_cmd.payload;
+		/* initialize the reply buffer */
+		(void)memset(reply_buf, 0, sizeof(*reply_buf));
 
-	/* get from phy_if to gpi */
-	phy_if = fci_get_phy_if_by_name(wred_cmd->if_name);
-	if (NULL == phy_if)
-	{
-		*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-		return ENOENT;
-	}
+		/* map command structure to message payload (requires casting) */
+		wred_cmd = (fpp_qos_policer_wred_cmd_t *)msg->msg_cmd.payload;
 
-	gpi = fci_qos_get_gpi(phy_if);
-	if (NULL == gpi)
-	{
-		*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-		return ENOENT;
-	}
-
-	/* basic command validations */
-	queue = wred_cmd->queue;
-	if (queue >= FPP_IQOS_Q_COUNT)
-	{
-		*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-		return EINVAL;
-	}
-
-	*fci_ret = FPP_ERR_OK;
-
-	switch(wred_cmd->action)
-	{
-		case FPP_ACTION_UPDATE:
+		/* get from phy_if to gpi */
+		phy_if = fci_get_phy_if_by_name(wred_cmd->if_name);
+		if (NULL == phy_if)
 		{
-			if (0U != wred_cmd->enable)
+			*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+			ret = ENOENT;
+		}
+		else
+		{
+			gpi = fci_qos_get_gpi(phy_if);
+			if (NULL == gpi)
 			{
-				ret = pfe_gpi_wred_enable(gpi, (pfe_iqos_queue_t)queue);
+				*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+				ret = ENOENT;
 			}
 			else
 			{
-				/* exit configuration update on disable */
-				ret = pfe_gpi_wred_disable(gpi, (pfe_iqos_queue_t)queue);
-				if (EOK != ret)
+				/* basic command validations */
+				queue = wred_cmd->queue;
+				if (queue >= FPP_IQOS_Q_COUNT)
 				{
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				}
-				break;
-			}
-
-			if (EOK != ret)
-			{
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				break;
-			}
-
-			for (i = 0; i < (uint32_t)FPP_IQOS_WRED_THR_COUNT; i++)
-			{
-				wred_thr = oal_ntohs(wred_cmd->thr[i]);
-				if (PFE_IQOS_WRED_THR_SKIP == wred_thr)
-				{
-					/* continue to next thr */
+					*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+					ret = EINVAL;
 				}
 				else
 				{
-					ret = pfe_gpi_wred_set_thr(gpi, (pfe_iqos_queue_t)queue, (pfe_iqos_wred_thr_t)i, wred_thr);
-					if (EOK != ret)
+					*fci_ret = FPP_ERR_OK;
+
+					switch(wred_cmd->action)
 					{
-						break;
-					}
-				}
-			}
+						case FPP_ACTION_UPDATE:
+						{
+							if (0U != wred_cmd->enable)
+							{
+								ret = pfe_gpi_wred_enable(gpi, (pfe_iqos_queue_t)queue);
+							}
+							else
+							{
+								/* exit configuration update on disable */
+								ret = pfe_gpi_wred_disable(gpi, (pfe_iqos_queue_t)queue);
+								if (EOK != ret)
+								{
+									*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+								}
+								break;
+							}
 
-			if (EOK != ret)
-			{
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				break;
-			}
+							if (EOK != ret)
+							{
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+								break;
+							}
 
-			for (i = 0; i < (uint32_t)FPP_IQOS_WRED_ZONES_COUNT; i++)
-			{
-				if (PFE_IQOS_WRED_ZONE_PROB_SKIP == wred_cmd->zprob[i])
-				{
-					/* continue to next prob zone */
-				}
-				else
-				{
-					ret = pfe_gpi_wred_set_prob(gpi, (pfe_iqos_queue_t)queue, (pfe_iqos_wred_zone_t)i, wred_cmd->zprob[i]);
-					if (EOK != ret)
-					{
-						break;
-					}
-				}
-			}
+							for (i = 0; i < (uint32_t)FPP_IQOS_WRED_THR_COUNT; i++)
+							{
+								wred_thr = oal_ntohs(wred_cmd->thr[i]);
+								if (PFE_IQOS_WRED_THR_SKIP == wred_thr)
+								{
+									/* continue to next thr */
+								}
+								else
+								{
+									ret = pfe_gpi_wred_set_thr(gpi, (pfe_iqos_queue_t)queue, (pfe_iqos_wred_thr_t)i, wred_thr);
+									if (EOK != ret)
+									{
+										break;
+									}
+								}
+							}
 
-			if (EOK != ret)
-			{
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				break;
-			}
+							if (EOK != ret)
+							{
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+								break;
+							}
 
-			break;
-		}
+							for (i = 0; i < (uint32_t)FPP_IQOS_WRED_ZONES_COUNT; i++)
+							{
+								if (PFE_IQOS_WRED_ZONE_PROB_SKIP == wred_cmd->zprob[i])
+								{
+									/* continue to next prob zone */
+								}
+								else
+								{
+									ret = pfe_gpi_wred_set_prob(gpi, (pfe_iqos_queue_t)queue, (pfe_iqos_wred_zone_t)i, wred_cmd->zprob[i]);
+									if (EOK != ret)
+									{
+										break;
+									}
+								}
+							}
 
-		case FPP_ACTION_QUERY:
-		{
-			/* copy original command properties into reply structure */
-			reply_buf->action = wred_cmd->action;
-			(void)strncpy(reply_buf->if_name, wred_cmd->if_name, sizeof(reply_buf->if_name));
-			reply_buf->if_name[sizeof(reply_buf->if_name) - 1U] = '\0';
-			reply_buf->queue = queue;
+							if (EOK != ret)
+							{
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+								break;
+							}
 
-			/* get WRED data */
-			reply_buf->enable = pfe_gpi_wred_is_enabled(gpi, (pfe_iqos_queue_t)queue);
+							break;
+						}
 
-			for (i = 0; i < (uint32_t)FPP_IQOS_WRED_THR_COUNT; i++)
-			{
-				ret = pfe_gpi_wred_get_thr(gpi, (pfe_iqos_queue_t)queue, (pfe_iqos_wred_thr_t)i, &wred_thr);
-				if (EOK != ret)
-				{
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-					break;
-				}
-				reply_buf->thr[i] = oal_htons(wred_thr);
-			}
+						case FPP_ACTION_QUERY:
+						{
+							/* copy original command properties into reply structure */
+							reply_buf->action = wred_cmd->action;
+							(void)strncpy(reply_buf->if_name, wred_cmd->if_name, sizeof(reply_buf->if_name));
+							reply_buf->if_name[sizeof(reply_buf->if_name) - 1U] = '\0';
+							reply_buf->queue = queue;
 
-			for (i = 0; i < (uint32_t)FPP_IQOS_WRED_ZONES_COUNT; i++)
-			{
-				ret = pfe_gpi_wred_get_prob(gpi, (pfe_iqos_queue_t)queue, (pfe_iqos_wred_zone_t)i, &reply_buf->zprob[i]);
-				if (EOK != ret)
-				{
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-					break;
-				}
-			}
+							/* get WRED data */
+							reply_buf->enable = pfe_gpi_wred_is_enabled(gpi, (pfe_iqos_queue_t)queue);
 
-			*reply_len = sizeof(*wred_cmd);
-			break;
-		}
+							for (i = 0; i < (uint32_t)FPP_IQOS_WRED_THR_COUNT; i++)
+							{
+								ret = pfe_gpi_wred_get_thr(gpi, (pfe_iqos_queue_t)queue, (pfe_iqos_wred_thr_t)i, &wred_thr);
+								if (EOK != ret)
+								{
+									*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+									break;
+								}
+								reply_buf->thr[i] = oal_htons(wred_thr);
+							}
 
-		default:
-		{
-			NXP_LOG_ERROR("FPP_CMD_QOS_POLICER_WRED: Unknown action received: 0x%x\n", wred_cmd->action);
-			*fci_ret = FPP_ERR_UNKNOWN_ACTION;
-			break;
+							for (i = 0; i < (uint32_t)FPP_IQOS_WRED_ZONES_COUNT; i++)
+							{
+								ret = pfe_gpi_wred_get_prob(gpi, (pfe_iqos_queue_t)queue, (pfe_iqos_wred_zone_t)i, &reply_buf->zprob[i]);
+								if (EOK != ret)
+								{
+									*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+									break;
+								}
+							}
+
+							*reply_len = sizeof(*wred_cmd);
+							break;
+						}
+
+						default:
+						{
+							NXP_LOG_ERROR("FPP_CMD_QOS_POLICER_WRED: Unknown action received: 0x%x\n", wred_cmd->action);
+							*fci_ret = FPP_ERR_UNKNOWN_ACTION;
+							break;
+						}
+					}
+				}
+			}
 		}
 	}
+	
 	return ret;
 }
 
@@ -1548,168 +1575,171 @@ errno_t fci_qos_policer_shp_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_polic
     (void)memset(&shp_type, 0, sizeof(fpp_iqos_shp_type_t));
     (void)memset(&shp_mode, 0, sizeof(fpp_iqos_shp_rate_mode_t));
 	ret = fci_validate_cmd_params(msg, fci_ret, reply_buf, reply_len, sizeof(*shp_cmd));
-	if (EOK != ret)
-	{
-		return ret;
-	}
-	else
+	if (EOK == ret)
 	{
 		/* no data written to reply buffer (yet) */
 		*reply_len = 0U;
-	}
-	/* initialize the reply buffer */
-	(void)memset(reply_buf, 0, sizeof(*reply_buf));
-
-	/* map command structure to message payload (requires casting) */
-	shp_cmd = (fpp_qos_policer_shp_cmd_t *)msg->msg_cmd.payload;
+		/* initialize the reply buffer */
+		(void)memset(reply_buf, 0, sizeof(*reply_buf));
 
-	/* get from phy_if to gpi */
-	phy_if = fci_get_phy_if_by_name(shp_cmd->if_name);
-	if (NULL == phy_if)
-	{
-		*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-		return ENOENT;
-	}
-
-	gpi = fci_qos_get_gpi(phy_if);
-	if (NULL == gpi)
-	{
-		*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-		return ENOENT;
-	}
-
-	/* basic command validations */
-	shp_id = shp_cmd->id;
-	if (shp_id >= PFE_IQOS_SHP_COUNT)
-	{
-		*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-		return EINVAL;
-	}
-
-	*fci_ret = FPP_ERR_OK;
+		/* map command structure to message payload (requires casting) */
+		shp_cmd = (fpp_qos_policer_shp_cmd_t *)msg->msg_cmd.payload;
 
-	switch(shp_cmd->action)
-	{
-		case FPP_ACTION_UPDATE:
+		/* get from phy_if to gpi */
+		phy_if = fci_get_phy_if_by_name(shp_cmd->if_name);
+		if (NULL == phy_if)
+		{
+			*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+			ret = ENOENT;
+		}
+		else
 		{
-			if (0U != shp_cmd->enable)
+			gpi = fci_qos_get_gpi(phy_if);
+			if (NULL == gpi)
 			{
-				ret = pfe_gpi_shp_enable(gpi, shp_id);
+				*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+				ret = ENOENT;
 			}
 			else
 			{
-				/* exit configuration update on disable */
-				ret = pfe_gpi_shp_disable(gpi, shp_id);
-				if (EOK != ret)
+				/* basic command validations */
+				shp_id = shp_cmd->id;
+				if (shp_id >= PFE_IQOS_SHP_COUNT)
 				{
-					*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+					*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+					ret = EINVAL;
 				}
-				break;
-			}
+				else
+				{
+					*fci_ret = FPP_ERR_OK;
 
-			if (EOK != ret)
-			{
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				break;
-			}
+					switch(shp_cmd->action)
+					{
+						case FPP_ACTION_UPDATE:
+						{
+							if (0U != shp_cmd->enable)
+							{
+								ret = pfe_gpi_shp_enable(gpi, shp_id);
+							}
+							else
+							{
+								/* exit configuration update on disable */
+								ret = pfe_gpi_shp_disable(gpi, shp_id);
+								if (EOK != ret)
+								{
+									*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+								}
+								break;
+							}
 
-			shp_type = shp_cmd->type;
-			shp_mode = shp_cmd->mode;
-			shp_isl = oal_ntohl(shp_cmd->isl);
-			shp_max_credit = (int32_t)oal_ntohl(shp_cmd->max_credit);
-			shp_min_credit = (int32_t)oal_ntohl(shp_cmd->min_credit);
+							if (EOK != ret)
+							{
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+								break;
+							}
 
-			/* commit command to h/w */
-			ret = pfe_gpi_shp_set_type(gpi, shp_id, (pfe_iqos_shp_type_t)shp_type);
-			if (EOK != ret)
-			{
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				break;
-			}
+							shp_type = shp_cmd->type;
+							shp_mode = shp_cmd->mode;
+							shp_isl = oal_ntohl(shp_cmd->isl);
+							shp_max_credit = (int32_t)oal_ntohl(shp_cmd->max_credit);
+							shp_min_credit = (int32_t)oal_ntohl(shp_cmd->min_credit);
 
-			ret = pfe_gpi_shp_set_mode(gpi, shp_id, (pfe_iqos_shp_rate_mode_t)shp_mode);
-			if (EOK != ret)
-			{
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				break;
-			}
+							/* commit command to h/w */
+							ret = pfe_gpi_shp_set_type(gpi, shp_id, (pfe_iqos_shp_type_t)shp_type);
+							if (EOK != ret)
+							{
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+								break;
+							}
 
-			NXP_LOG_DEBUG("Setting shaper %d idle slope: %u\n", shp_id, (uint_t)shp_isl);
-			ret = pfe_gpi_shp_set_idle_slope(gpi, shp_id, shp_isl);
-			if (EOK != ret)
-			{
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				break;
-			}
+							ret = pfe_gpi_shp_set_mode(gpi, shp_id, (pfe_iqos_shp_rate_mode_t)shp_mode);
+							if (EOK != ret)
+							{
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+								break;
+							}
 
-			NXP_LOG_DEBUG("Setting shaper %d credit limits: [%d, %d]\n",
-				      shp_id, (int_t)shp_min_credit, (int_t)shp_max_credit);
-			ret = pfe_gpi_shp_set_limits(gpi, shp_id, shp_max_credit, shp_min_credit);
-			if (EOK != ret)
-			{
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				break;
-			}
+							NXP_LOG_DEBUG("Setting shaper %d idle slope: %u\n", shp_id, (uint_t)shp_isl);
+							ret = pfe_gpi_shp_set_idle_slope(gpi, shp_id, shp_isl);
+							if (EOK != ret)
+							{
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+								break;
+							}
 
-			break;
-		}
+							NXP_LOG_DEBUG("Setting shaper %d credit limits: [%d, %d]\n",
+									shp_id, (int_t)shp_min_credit, (int_t)shp_max_credit);
+							ret = pfe_gpi_shp_set_limits(gpi, shp_id, shp_max_credit, shp_min_credit);
+							if (EOK != ret)
+							{
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+								break;
+							}
 
-		case FPP_ACTION_QUERY:
-		{
-			/* copy original command properties into reply structure */
-			reply_buf->action = shp_cmd->action;
-			(void)strncpy(reply_buf->if_name, shp_cmd->if_name, sizeof(reply_buf->if_name));
-			reply_buf->if_name[sizeof(reply_buf->if_name) - 1U] = '\0';
-			reply_buf->id = shp_id;
+							break;
+						}
 
-			/* get shaper data */
-			reply_buf->enable = pfe_gpi_shp_is_enabled(gpi, shp_id);
+						case FPP_ACTION_QUERY:
+						{
+							/* copy original command properties into reply structure */
+							reply_buf->action = shp_cmd->action;
+							(void)strncpy(reply_buf->if_name, shp_cmd->if_name, sizeof(reply_buf->if_name));
+							reply_buf->if_name[sizeof(reply_buf->if_name) - 1U] = '\0';
+							reply_buf->id = shp_id;
 
-			ret = pfe_gpi_shp_get_type(gpi, shp_id, (pfe_iqos_shp_type_t *)&shp_type);
-			if (EOK != ret)
-			{
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				break;
-			}
+							/* get shaper data */
+							reply_buf->enable = pfe_gpi_shp_is_enabled(gpi, shp_id);
 
-			ret = pfe_gpi_shp_get_mode(gpi, shp_id, (pfe_iqos_shp_rate_mode_t *)&shp_mode);
-			if (EOK != ret)
-			{
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				break;
-			}
+							ret = pfe_gpi_shp_get_type(gpi, shp_id, (pfe_iqos_shp_type_t *)&shp_type);
+							if (EOK != ret)
+							{
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+								break;
+							}
 
-			ret = pfe_gpi_shp_get_idle_slope(gpi, shp_id, &shp_isl);
-			if (EOK != ret)
-			{
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				break;
-			}
+							ret = pfe_gpi_shp_get_mode(gpi, shp_id, (pfe_iqos_shp_rate_mode_t *)&shp_mode);
+							if (EOK != ret)
+							{
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+								break;
+							}
 
-			ret = pfe_gpi_shp_get_limits(gpi, shp_id, &shp_max_credit, &shp_min_credit);
-			if (EOK != ret)
-			{
-				*fci_ret = FPP_ERR_INTERNAL_FAILURE;
-				break;
-			}
+							ret = pfe_gpi_shp_get_idle_slope(gpi, shp_id, &shp_isl);
+							if (EOK != ret)
+							{
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+								break;
+							}
 
-			reply_buf->type = shp_type;
-			reply_buf->mode = shp_mode;
-			reply_buf->isl = oal_htonl(shp_isl);
-			reply_buf->max_credit = (int32_t)oal_htonl(shp_max_credit);
-			reply_buf->min_credit = (int32_t)oal_htonl(shp_min_credit);
+							ret = pfe_gpi_shp_get_limits(gpi, shp_id, &shp_max_credit, &shp_min_credit);
+							if (EOK != ret)
+							{
+								*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+								break;
+							}
 
-			*reply_len = sizeof(*shp_cmd);
-			break;
-		}
+							reply_buf->type = shp_type;
+							reply_buf->mode = shp_mode;
+							reply_buf->isl = oal_htonl(shp_isl);
+							reply_buf->max_credit = (int32_t)oal_htonl(shp_max_credit);
+							reply_buf->min_credit = (int32_t)oal_htonl(shp_min_credit);
 
-		default:
-		{
-			NXP_LOG_ERROR("FPP_CMD_QOS_POLICER_SHP: Unknown action received: 0x%x\n", shp_cmd->action);
-			*fci_ret = FPP_ERR_UNKNOWN_ACTION;
-			break;
-		}
+							*reply_len = sizeof(*shp_cmd);
+							break;
+						}
+
+						default:
+						{
+							NXP_LOG_ERROR("FPP_CMD_QOS_POLICER_SHP: Unknown action received: 0x%x\n", shp_cmd->action);
+							*fci_ret = FPP_ERR_UNKNOWN_ACTION;
+							break;
+						}
+					}
+				}
+			}
+		}	
 	}
+	
 	return ret;
 }
 
diff --git a/sw/fci/src/fci_routes.c b/sw/fci/src/fci_routes.c
index 5ca5a65..7f14da6 100644
--- a/sw/fci/src/fci_routes.c
+++ b/sw/fci/src/fci_routes.c
@@ -48,26 +48,25 @@ static void fci_routes_remove_related_connections(fci_rt_db_entry_t *route)
 	if (unlikely((NULL == route)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
-
-    if (unlikely(FALSE == fci_context->fci_initialized))
+	else if (unlikely(FALSE == fci_context->fci_initialized))
 	{
     	NXP_LOG_ERROR("Context not initialized\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	entry = pfe_rtable_get_first(fci_context->rtable, RTABLE_CRIT_BY_ROUTE_ID, &route->id);
-	while (NULL != entry)
 	{
-		ret = fci_connections_drop_one(entry);
-		if (EOK != ret)
+		entry = pfe_rtable_get_first(fci_context->rtable, RTABLE_CRIT_BY_ROUTE_ID, &route->id);
+		while (NULL != entry)
 		{
-			NXP_LOG_WARNING("Couldn't properly drop a connection: %d\n", ret);
-		}
+			ret = fci_connections_drop_one(entry);
+			if (EOK != ret)
+			{
+				NXP_LOG_WARNING("Couldn't properly drop a connection: %d\n", ret);
+			}
 
-		entry = pfe_rtable_get_next(fci_context->rtable);
+			entry = pfe_rtable_get_next(fci_context->rtable);
+		}
 	}
 }
 
@@ -99,229 +98,230 @@ errno_t fci_routes_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_rt_cmd_t *reply_bu
 	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-    if (unlikely(FALSE == fci_context->fci_initialized))
+    else if (unlikely(FALSE == fci_context->fci_initialized))
 	{
     	NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (*reply_len < sizeof(fpp_rt_cmd_t))
-	{
-		NXP_LOG_ERROR("Buffer length does not match expected value (fpp_rt_cmd_t)\n");
-		return EINVAL;
+		ret = EPERM;
 	}
 	else
-	{
-		/*	No data written to reply buffer (yet) */
-		*reply_len = 0U;
-	}
-
-	/*	Initialize the reply buffer */
-	(void)memset(reply_buf, 0, sizeof(fpp_rt_cmd_t));
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 
-	rt_cmd = (fpp_rt_cmd_t *)(msg->msg_cmd.payload);
-	is_ipv6 = (oal_ntohl(rt_cmd->flags) == 2U) ? TRUE : FALSE;
+	{		
+		if (*reply_len < sizeof(fpp_rt_cmd_t))
+		{
+			NXP_LOG_ERROR("Buffer length does not match expected value (fpp_rt_cmd_t)\n");
+			ret = EINVAL;
+		}
+		else
+		{
+			/*	No data written to reply buffer (yet) */
+			*reply_len = 0U;
+			/*	Initialize the reply buffer */
+			(void)memset(reply_buf, 0, sizeof(fpp_rt_cmd_t));
 
-	/*	Prepare MAC and IP destination address */
-	(void)memcpy(dst_mac, rt_cmd->dst_mac, sizeof(pfe_mac_addr_t));
-	(void)memset(&ip, 0, sizeof(pfe_ip_addr_t));
+			rt_cmd = (fpp_rt_cmd_t *)(msg->msg_cmd.payload);
+			is_ipv6 = (oal_ntohl(rt_cmd->flags) == 2U) ? TRUE : FALSE;
 
-	if (is_ipv6)
-	{
-		/*	Convert to 'known' IPv6 address format */
-		(void)memcpy(&ip.v6, &rt_cmd->dst_addr[0], 16);
-		ip.is_ipv4 = FALSE;
-	}
-	else
-	{
-		/*	Convert to 'known' IPv4 address format */
-		(void)memcpy(&ip.v4, &rt_cmd->dst_addr[0], 4);
-		ip.is_ipv4 = TRUE;
-	}
+			/*	Prepare MAC and IP destination address */
+			(void)memcpy(dst_mac, rt_cmd->dst_mac, sizeof(pfe_mac_addr_t));
+			(void)memset(&ip, 0, sizeof(pfe_ip_addr_t));
 
-	switch (rt_cmd->action)
-	{
-		case FPP_ACTION_REGISTER:
-		{
-			ret = pfe_if_db_lock(&session_id);
-			if (EOK == ret)
+			if (is_ipv6)
 			{
-				/*	Validate the interface */
-				ret = pfe_if_db_get_first(fci_context->phy_if_db, session_id, IF_DB_CRIT_BY_NAME, (void *)rt_cmd->output_device, &if_entry);
-				if(EOK != ret)
-				{
-					NXP_LOG_DEBUG("FPP_CMD_IP_ROUTE: DB is locked in different session, entry was not retrieved from DB\n");
-				}
+				/*	Convert to 'known' IPv6 address format */
+				(void)memcpy(&ip.v6, &rt_cmd->dst_addr[0], 16);
+				ip.is_ipv4 = FALSE;
 			}
 			else
 			{
-				NXP_LOG_ERROR("FPP_CMD_IP_ROUTE: DB lock failed\n");
+				/*	Convert to 'known' IPv4 address format */
+				(void)memcpy(&ip.v4, &rt_cmd->dst_addr[0], 4);
+				ip.is_ipv4 = TRUE;
 			}
 
-			if (NULL == if_entry)
+			switch (rt_cmd->action)
 			{
-				/*	No such interface */
-				NXP_LOG_DEBUG("FPP_CMD_IP_ROUTE: Interface %s not found\n", rt_cmd->output_device);
-				*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-				break;
-			}
+				case FPP_ACTION_REGISTER:
+				{
+					ret = pfe_if_db_lock(&session_id);
+					if (EOK == ret)
+					{
+						/*	Validate the interface */
+						ret = pfe_if_db_get_first(fci_context->phy_if_db, session_id, IF_DB_CRIT_BY_NAME, (void *)rt_cmd->output_device, &if_entry);
+						if(EOK != ret)
+						{
+							NXP_LOG_DEBUG("FPP_CMD_IP_ROUTE: DB is locked in different session, entry was not retrieved from DB\n");
+						}
+					}
+					else
+					{
+						NXP_LOG_ERROR("FPP_CMD_IP_ROUTE: DB lock failed\n");
+					}
+
+					if (NULL == if_entry)
+					{
+						/*	No such interface */
+						NXP_LOG_DEBUG("FPP_CMD_IP_ROUTE: Interface %s not found\n", rt_cmd->output_device);
+						*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+						break;
+					}
+
+					phy_if = pfe_if_db_entry_get_phy_if(if_entry);
+
+					/*	Prepare MAC source address */
+					{
+						const pfe_mac_addr_t zero_mac = {0u};
+						(void)memset(src_mac, 0, sizeof(pfe_mac_addr_t));
+						if (0 == memcmp(rt_cmd->src_mac, zero_mac, sizeof(pfe_mac_addr_t)))
+						{
+							if(EOK != pfe_phy_if_get_mac_addr_first(phy_if, src_mac, MAC_DB_CRIT_ALL, PFE_TYPE_ANY, PFE_CFG_LOCAL_IF))
+							{
+								NXP_LOG_ERROR("FPP_CMD_IP_ROUTE: Get the first MAC address from mac addr db failed\n");
+							}
+						}
+						else
+						{
+							(void)memcpy(src_mac, rt_cmd->src_mac, sizeof(pfe_mac_addr_t));
+						}
+					}
+
+					/*	Add entry to database (values in network endian) */
+					ret = fci_rt_db_add(&fci_context->route_db,	&ip, &src_mac, &dst_mac,
+										phy_if,
+										rt_cmd->id,
+										msg->client,
+										FALSE);
+
+					if (EPERM == ret)
+					{
+						NXP_LOG_DEBUG("FPP_CMD_IP_ROUTE: Already registered\n");
+						*fci_ret = FPP_ERR_RT_ENTRY_ALREADY_REGISTERED;
+						break;
+					}
+					else if (EOK != ret)
+					{
+						NXP_LOG_ERROR("FPP_CMD_IP_ROUTE: Can't add route entry: %d\n", ret);
+						*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+						break;
+					}
+					else
+					{
+						NXP_LOG_DEBUG("FPP_CMD_IP_ROUTE: Route (ID: %d, IF: %s) added\n", (int_t)oal_ntohl(rt_cmd->id), rt_cmd->output_device);
+						*fci_ret = FPP_ERR_OK;
+					}
 
-			phy_if = pfe_if_db_entry_get_phy_if(if_entry);
+					break;
+				}
 
-			/*	Prepare MAC source address */
-			{
-				const pfe_mac_addr_t zero_mac = {0u};
-				(void)memset(src_mac, 0, sizeof(pfe_mac_addr_t));
-				if (0 == memcmp(rt_cmd->src_mac, zero_mac, sizeof(pfe_mac_addr_t)))
+				case FPP_ACTION_DEREGISTER:
 				{
-					if(EOK != pfe_phy_if_get_mac_addr_first(phy_if, src_mac, MAC_DB_CRIT_ALL, PFE_TYPE_ANY, PFE_CFG_LOCAL_IF))
-                    {
-                        NXP_LOG_ERROR("FPP_CMD_IP_ROUTE: Get the first MAC address from mac addr db failed\n");
-                    }
+					/*	Validate the route */
+					rt_entry = fci_rt_db_get_first(&fci_context->route_db, RT_DB_CRIT_BY_ID, (void *)&rt_cmd->id);
+					if (NULL == rt_entry)
+					{
+						NXP_LOG_DEBUG("FPP_CMD_IP_ROUTE: Requested route %d not found\n", (int_t)oal_ntohl(rt_cmd->id));
+						*fci_ret = FPP_ERR_RT_ENTRY_NOT_FOUND;
+						break;
+					}
+
+					/*	Remove related connections, then the route, and disable the interface if needed */
+					ret = fci_routes_drop_one(rt_entry);
+					if (EOK != ret)
+					{
+						NXP_LOG_ERROR("FPP_CMD_IP_ROUTE: Can't remove route entry: %d\n", ret);
+						*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
+						break;
+					}
+					else
+					{
+						NXP_LOG_DEBUG("FPP_CMD_IP_ROUTE: Route %d removed\n", (int_t)oal_ntohl(rt_cmd->id));
+					}
+
+					break;
 				}
-				else
+
+				case FPP_ACTION_UPDATE:
 				{
-					(void)memcpy(src_mac, rt_cmd->src_mac, sizeof(pfe_mac_addr_t));
+					/*	Not supported yet */
+					NXP_LOG_DEBUG("FPP_CMD_IP_ROUTE: FPP_ACTION_UPDATE not supported (yet)\n");
+					*fci_ret = FPP_ERR_UNKNOWN_COMMAND;
+					break;
 				}
-			}
-
-			/*	Add entry to database (values in network endian) */
-			ret = fci_rt_db_add(&fci_context->route_db,	&ip, &src_mac, &dst_mac,
-								phy_if,
-								rt_cmd->id,
-								msg->client,
-								FALSE);
-
-			if (EPERM == ret)
-			{
-				NXP_LOG_DEBUG("FPP_CMD_IP_ROUTE: Already registered\n");
-				*fci_ret = FPP_ERR_RT_ENTRY_ALREADY_REGISTERED;
-				break;
-			}
-			else if (EOK != ret)
-			{
-				NXP_LOG_ERROR("FPP_CMD_IP_ROUTE: Can't add route entry: %d\n", ret);
-				*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-				break;
-			}
-			else
-			{
-				NXP_LOG_DEBUG("FPP_CMD_IP_ROUTE: Route (ID: %d, IF: %s) added\n", (int_t)oal_ntohl(rt_cmd->id), rt_cmd->output_device);
-				*fci_ret = FPP_ERR_OK;
-			}
-
-			break;
-		}
-
-		case FPP_ACTION_DEREGISTER:
-		{
-			/*	Validate the route */
-			rt_entry = fci_rt_db_get_first(&fci_context->route_db, RT_DB_CRIT_BY_ID, (void *)&rt_cmd->id);
-			if (NULL == rt_entry)
-			{
-				NXP_LOG_DEBUG("FPP_CMD_IP_ROUTE: Requested route %d not found\n", (int_t)oal_ntohl(rt_cmd->id));
-				*fci_ret = FPP_ERR_RT_ENTRY_NOT_FOUND;
-				break;
-			}
-
-			/*	Remove related connections, then the route, and disable the interface if needed */
-			ret = fci_routes_drop_one(rt_entry);
-			if (EOK != ret)
-			{
-				NXP_LOG_ERROR("FPP_CMD_IP_ROUTE: Can't remove route entry: %d\n", ret);
-				*fci_ret = FPP_ERR_WRONG_COMMAND_PARAM;
-				break;
-			}
-			else
-			{
-				NXP_LOG_DEBUG("FPP_CMD_IP_ROUTE: Route %d removed\n", (int_t)oal_ntohl(rt_cmd->id));
-			}
 
-			break;
-		}
+				case FPP_ACTION_QUERY:
+				{
+					rt_entry = fci_rt_db_get_first(&fci_context->route_db, RT_DB_CRIT_ALL, NULL);
+					if (NULL == rt_entry)
+					{
+						ret = EOK;
+						*fci_ret = FPP_ERR_RT_ENTRY_NOT_FOUND;
+						break;
+					}
+				}
+				/* FALLTHRU */
 
-		case FPP_ACTION_UPDATE:
-		{
-			/*	Not supported yet */
-			NXP_LOG_DEBUG("FPP_CMD_IP_ROUTE: FPP_ACTION_UPDATE not supported (yet)\n");
-			*fci_ret = FPP_ERR_UNKNOWN_COMMAND;
-			break;
-		}
+				case FPP_ACTION_QUERY_CONT:
+				{
+					if (NULL == rt_entry)
+					{
+						rt_entry = fci_rt_db_get_next(&fci_context->route_db);
+						if (NULL == rt_entry)
+						{
+							ret = EOK;
+							*fci_ret = FPP_ERR_RT_ENTRY_NOT_FOUND;
+							break;
+						}
+					}
+
+					/*	Write the reply buffer */
+					*reply_len = sizeof(fpp_rt_cmd_t);
+
+					/*	Build reply structure */
+					reply_buf->mtu = rt_entry->mtu;
+					(void)memcpy(reply_buf->src_mac, rt_entry->src_mac, sizeof(pfe_mac_addr_t));
+					(void)memcpy(reply_buf->dst_mac, rt_entry->dst_mac, sizeof(pfe_mac_addr_t));
+
+					if (rt_entry->dst_ip.is_ipv4)
+					{
+						/*	IPv4 */
+						(void)memcpy(&reply_buf->dst_addr[0], &rt_entry->dst_ip.v4, 4);
+						reply_buf->flags = oal_htonl(1U); /* TODO: This is weird (see FCI doc). Some macro should be used instead. */
+					}
+					else
+					{
+						/*	IPv6 */
+						(void)memcpy(&reply_buf->dst_addr[0], &rt_entry->dst_ip.v6, 16);
+						reply_buf->flags = oal_htonl(2U); /* TODO: This is weird (see FCI doc). Some macro should be used instead. */
+					}
+
+					reply_buf->id = rt_entry->id;
+					(void)strncpy(reply_buf->output_device, pfe_phy_if_get_name(rt_entry->iface), (uint32_t)IFNAMSIZ-1U);
+
+					*fci_ret = FPP_ERR_OK;
+					ret = EOK;
 
-		case FPP_ACTION_QUERY:
-		{
-			rt_entry = fci_rt_db_get_first(&fci_context->route_db, RT_DB_CRIT_ALL, NULL);
-			if (NULL == rt_entry)
-			{
-				ret = EOK;
-				*fci_ret = FPP_ERR_RT_ENTRY_NOT_FOUND;
-				break;
-			}
-		}
-		/* FALLTHRU */
+					break;
+				}
 
-		case FPP_ACTION_QUERY_CONT:
-		{
-			if (NULL == rt_entry)
-			{
-				rt_entry = fci_rt_db_get_next(&fci_context->route_db);
-				if (NULL == rt_entry)
+				default:
 				{
-					ret = EOK;
-					*fci_ret = FPP_ERR_RT_ENTRY_NOT_FOUND;
+					NXP_LOG_ERROR("FPP_CMD_IP_ROUTE: Unknown action received: 0x%x\n", reply_buf->action);
+					*fci_ret = FPP_ERR_UNKNOWN_ACTION;
 					break;
 				}
 			}
 
-			/*	Write the reply buffer */
-			*reply_len = sizeof(fpp_rt_cmd_t);
-
-			/*	Build reply structure */
-			reply_buf->mtu = rt_entry->mtu;
-			(void)memcpy(reply_buf->src_mac, rt_entry->src_mac, sizeof(pfe_mac_addr_t));
-			(void)memcpy(reply_buf->dst_mac, rt_entry->dst_mac, sizeof(pfe_mac_addr_t));
-
-			if (rt_entry->dst_ip.is_ipv4)
-			{
-				/*	IPv4 */
-				(void)memcpy(&reply_buf->dst_addr[0], &rt_entry->dst_ip.v4, 4);
-				reply_buf->flags = oal_htonl(1U); /* TODO: This is weird (see FCI doc). Some macro should be used instead. */
-			}
-			else
+			/* Unlock interfaces for required actions */
+			if(FPP_ACTION_REGISTER == rt_cmd->action)
 			{
-				/*	IPv6 */
-				(void)memcpy(&reply_buf->dst_addr[0], &rt_entry->dst_ip.v6, 16);
-				reply_buf->flags = oal_htonl(2U); /* TODO: This is weird (see FCI doc). Some macro should be used instead. */
+				ret = pfe_if_db_unlock(session_id);
+				if(EOK != ret)
+				{
+					NXP_LOG_ERROR("FPP_CMD_IP_ROUTE: DB unlock failed\n");
+				}
 			}
-
-			reply_buf->id = rt_entry->id;
-			(void)strncpy(reply_buf->output_device, pfe_phy_if_get_name(rt_entry->iface), (uint32_t)IFNAMSIZ-1U);
-
-			*fci_ret = FPP_ERR_OK;
-			ret = EOK;
-
-			break;
-		}
-
-		default:
-		{
-			NXP_LOG_ERROR("FPP_CMD_IP_ROUTE: Unknown action received: 0x%x\n", reply_buf->action);
-			*fci_ret = FPP_ERR_UNKNOWN_ACTION;
-			break;
-		}
-	}
-
-	/* Unlock interfaces for required actions */
-	if(FPP_ACTION_REGISTER == rt_cmd->action)
-	{
-		ret = pfe_if_db_unlock(session_id);
-		if(EOK != ret)
-		{
-			NXP_LOG_ERROR("FPP_CMD_IP_ROUTE: DB unlock failed\n");
 		}
 	}
 
@@ -345,47 +345,47 @@ errno_t fci_routes_drop_one(fci_rt_db_entry_t *route)
 	if (unlikely((NULL == route)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	if (unlikely(FALSE == fci_context->fci_initialized))
+	else if (unlikely(FALSE == fci_context->fci_initialized))
 	{
 		NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
+		ret = EPERM;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	(void)memset(&msg, 0, sizeof(fci_msg_t));
-	msg.type = FCI_MSG_CMD;
-	msg.msg_cmd.code = FPP_CMD_IP_ROUTE;
-
-	rt_cmd = (fpp_rt_cmd_t *)msg.msg_cmd.payload;
-	rt_cmd->action = FPP_ACTION_REMOVED;
-
-	/*	Inform client about the entry is being removed */
-	if (NULL != route->refptr)
 	{
-		rt_cmd->id = route->id;
+		(void)memset(&msg, 0, sizeof(fci_msg_t));
+		msg.type = FCI_MSG_CMD;
+		msg.msg_cmd.code = FPP_CMD_IP_ROUTE;
 
-		ret = fci_core_client_send((fci_core_client_t *)route->refptr, &msg, NULL);
-		if (EOK != ret)
+		rt_cmd = (fpp_rt_cmd_t *)msg.msg_cmd.payload;
+		rt_cmd->action = FPP_ACTION_REMOVED;
+
+		/*	Inform client about the entry is being removed */
+		if (NULL != route->refptr)
 		{
-			NXP_LOG_ERROR("Could not notify FCI client\n");
+			rt_cmd->id = route->id;
+
+			ret = fci_core_client_send((fci_core_client_t *)route->refptr, &msg, NULL);
+			if (EOK != ret)
+			{
+				NXP_LOG_ERROR("Could not notify FCI client\n");
+			}
 		}
-	}
 
-	NXP_LOG_DEBUG("Removing route with ID %d\n", (int_t)oal_ntohl(route->id));
+		NXP_LOG_DEBUG("Removing route with ID %d\n", (int_t)oal_ntohl(route->id));
 
-	/*	Remove all associated connections */
-	fci_routes_remove_related_connections(route);
+		/*	Remove all associated connections */
+		fci_routes_remove_related_connections(route);
 
-	/*	Remove the route */
-	ret = fci_rt_db_remove(&fci_context->route_db, route);
-	if (EOK != ret)
-	{
-		NXP_LOG_ERROR("Can't remove route: %d\n", ret);
+		/*	Remove the route */
+		ret = fci_rt_db_remove(&fci_context->route_db, route);
+		if (EOK != ret)
+		{
+			NXP_LOG_ERROR("Can't remove route: %d\n", ret);
+		}
 	}
-
 	return ret;
 }
 
@@ -404,22 +404,23 @@ void fci_routes_drop_all(void)
 	if (unlikely(FALSE == fci_context->fci_initialized))
 	{
 		NXP_LOG_ERROR("Context not initialized\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	NXP_LOG_DEBUG("Removing all routes\n");
-
-	entry = fci_rt_db_get_first(&fci_context->route_db, RT_DB_CRIT_ALL, NULL);
-	while (NULL != entry)
 	{
-		ret = fci_routes_drop_one(entry);
-		if (EOK != ret)
+		NXP_LOG_DEBUG("Removing all routes\n");
+
+		entry = fci_rt_db_get_first(&fci_context->route_db, RT_DB_CRIT_ALL, NULL);
+		while (NULL != entry)
 		{
-			NXP_LOG_WARNING("Couldn't properly drop a route: %d\n", ret);
-		}
+			ret = fci_routes_drop_one(entry);
+			if (EOK != ret)
+			{
+				NXP_LOG_WARNING("Couldn't properly drop a route: %d\n", ret);
+			}
 
-		entry = fci_rt_db_get_next(&fci_context->route_db);
+			entry = fci_rt_db_get_next(&fci_context->route_db);
+		}
 	}
 }
 
@@ -438,25 +439,26 @@ void fci_routes_drop_all_ipv4(void)
     if (unlikely(FALSE == fci_context->fci_initialized))
 	{
     	NXP_LOG_ERROR("Context not initialized\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	NXP_LOG_DEBUG("Removing all IPv4 routes\n");
-
-	entry = fci_rt_db_get_first(&fci_context->route_db, RT_DB_CRIT_ALL, NULL);
-	while (NULL != entry)
 	{
-		if (entry->dst_ip.is_ipv4)
+		NXP_LOG_DEBUG("Removing all IPv4 routes\n");
+
+		entry = fci_rt_db_get_first(&fci_context->route_db, RT_DB_CRIT_ALL, NULL);
+		while (NULL != entry)
 		{
-			ret = fci_routes_drop_one(entry);
-			if (EOK != ret)
+			if (entry->dst_ip.is_ipv4)
 			{
-				NXP_LOG_WARNING("Couldn't properly drop a route: %d\n", ret);
+				ret = fci_routes_drop_one(entry);
+				if (EOK != ret)
+				{
+					NXP_LOG_WARNING("Couldn't properly drop a route: %d\n", ret);
+				}
 			}
-		}
 
-		entry = fci_rt_db_get_next(&fci_context->route_db);
+			entry = fci_rt_db_get_next(&fci_context->route_db);
+		}
 	}
 }
 
@@ -475,25 +477,26 @@ void fci_routes_drop_all_ipv6(void)
     if (unlikely(FALSE == fci_context->fci_initialized))
 	{
     	NXP_LOG_ERROR("Context not initialized\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	NXP_LOG_DEBUG("Removing all IPv6 routes\n");
-
-	entry = fci_rt_db_get_first(&fci_context->route_db, RT_DB_CRIT_ALL, NULL);
-	while (NULL != entry)
 	{
-		if (!entry->dst_ip.is_ipv4)
+		NXP_LOG_DEBUG("Removing all IPv6 routes\n");
+
+		entry = fci_rt_db_get_first(&fci_context->route_db, RT_DB_CRIT_ALL, NULL);
+		while (NULL != entry)
 		{
-			ret = fci_routes_drop_one(entry);
-			if (EOK != ret)
+			if (!entry->dst_ip.is_ipv4)
 			{
-				NXP_LOG_WARNING("Couldn't properly drop a route: %d\n", ret);
+				ret = fci_routes_drop_one(entry);
+				if (EOK != ret)
+				{
+					NXP_LOG_WARNING("Couldn't properly drop a route: %d\n", ret);
+				}
 			}
-		}
 
-		entry = fci_rt_db_get_next(&fci_context->route_db);
+			entry = fci_rt_db_get_next(&fci_context->route_db);
+		}
 	}
 }
 
diff --git a/sw/fci/src/fci_rt_db.c b/sw/fci/src/fci_rt_db.c
index de2d927..3bdabbb 100644
--- a/sw/fci/src/fci_rt_db.c
+++ b/sw/fci/src/fci_rt_db.c
@@ -45,56 +45,57 @@ static bool_t fci_rt_db_match_criterion(fci_rt_db_t *db, const fci_rt_db_entry_t
 	if (unlikely((NULL == db) || (NULL == entry)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return FALSE;
+		match = FALSE;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	switch (db->cur_crit)
 	{
-		case RT_DB_CRIT_ALL:
+		switch (db->cur_crit)
 		{
-			match = TRUE;
-			break;
-		}
+			case RT_DB_CRIT_ALL:
+			{
+				match = TRUE;
+				break;
+			}
 
-		case RT_DB_CRIT_BY_IF:
-		{
-			match = (entry->iface == db->cur_crit_arg.iface);
-			break;
-		}
+			case RT_DB_CRIT_BY_IF:
+			{
+				match = (entry->iface == db->cur_crit_arg.iface);
+				break;
+			}
 
-		case RT_DB_CRIT_BY_IF_NAME:
-		{
-			match = (0 == strcmp(db->cur_crit_arg.outif_name, pfe_phy_if_get_name(entry->iface)));
-			break;
-		}
+			case RT_DB_CRIT_BY_IF_NAME:
+			{
+				match = (0 == strcmp(db->cur_crit_arg.outif_name, pfe_phy_if_get_name(entry->iface)));
+				break;
+			}
 
-		case RT_DB_CRIT_BY_IP:
-		{
-			match = (0 == memcmp(&db->cur_crit_arg.dst_ip, &entry->dst_ip, sizeof(pfe_ip_addr_t)));
-			break;
-		}
+			case RT_DB_CRIT_BY_IP:
+			{
+				match = (0 == memcmp(&db->cur_crit_arg.dst_ip, &entry->dst_ip, sizeof(pfe_ip_addr_t)));
+				break;
+			}
 
-		case RT_DB_CRIT_BY_MAC:
-		{
-			match = (0 == memcmp(&db->cur_crit_arg.dst_mac, &entry->dst_mac, sizeof(pfe_mac_addr_t)));
-			break;
-		}
+			case RT_DB_CRIT_BY_MAC:
+			{
+				match = (0 == memcmp(&db->cur_crit_arg.dst_mac, &entry->dst_mac, sizeof(pfe_mac_addr_t)));
+				break;
+			}
 
-		case RT_DB_CRIT_BY_ID:
-		{
-			match = (db->cur_crit_arg.id == entry->id);
-			break;
-		}
+			case RT_DB_CRIT_BY_ID:
+			{
+				match = (db->cur_crit_arg.id == entry->id);
+				break;
+			}
 
-		default:
-		{
-			NXP_LOG_ERROR("Unknown criterion\n");
-			match = FALSE;
-			break;
+			default:
+			{
+				NXP_LOG_ERROR("Unknown criterion\n");
+				match = FALSE;
+				break;
+			}
 		}
 	}
-
 	return match;
 }
 
@@ -108,12 +109,13 @@ void fci_rt_db_init(fci_rt_db_t *db)
 	if (unlikely(NULL == db))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	LLIST_Init(&db->theList);
-	db->cur_item = db->theList.prNext;
+	{
+		LLIST_Init(&db->theList);
+		db->cur_item = db->theList.prNext;
+	}
 }
 
 /**
@@ -135,56 +137,61 @@ errno_t fci_rt_db_add(fci_rt_db_t *db,  pfe_ip_addr_t *dst_ip,
 {
 	fci_rt_db_entry_t *new_entry;
 	bool_t is_new = false;
+	errno_t ret = EOK;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == db) || (NULL == dst_ip) || (NULL == src_mac) || (NULL == dst_mac) || (NULL == iface)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	/*	Check duplicates by route ID */
-	new_entry = fci_rt_db_get_first(db, RT_DB_CRIT_BY_ID, (void *)&id);
-	if (NULL == new_entry)
 	{
-		new_entry = oal_mm_malloc(sizeof(fci_rt_db_entry_t));
-		is_new = true;
+		/*	Check duplicates by route ID */
+		new_entry = fci_rt_db_get_first(db, RT_DB_CRIT_BY_ID, (void *)&id);
 		if (NULL == new_entry)
 		{
-			return ENOMEM;
+			new_entry = oal_mm_malloc(sizeof(fci_rt_db_entry_t));
+			is_new = true;
+			if (NULL == new_entry)
+			{
+				ret = ENOMEM;
+			}
+			else
+			{
+				(void)memset(new_entry, 0, sizeof(fci_rt_db_entry_t));
+			}
 		}
 		else
 		{
-			(void)memset(new_entry, 0, sizeof(fci_rt_db_entry_t));
+			is_new = false;
+
+			if (false == overwrite)
+			{
+				ret = EPERM;
+			}
 		}
-	}
-	else
-	{
-		is_new = false;
 
-		if (false == overwrite)
+		if(EOK == ret)
 		{
-			return EPERM;
+			/*	Store values */
+			(void)memcpy(&new_entry->dst_ip, dst_ip, sizeof(pfe_ip_addr_t));
+			(void)memcpy(&new_entry->src_mac, src_mac, sizeof(pfe_mac_addr_t));
+			(void)memcpy(&new_entry->dst_mac, dst_mac, sizeof(pfe_mac_addr_t));
+			new_entry->iface = iface;
+			new_entry->id = id;
+			new_entry->mtu = 0; /* Not supported yet */
+			new_entry->refptr = refptr;
+
+			/*	Put to DB */
+			if (true == is_new)
+			{
+				LLIST_AddAtEnd(&(new_entry->list_member), &db->theList);
+			}
 		}
 	}
-
-	/*	Store values */
-	(void)memcpy(&new_entry->dst_ip, dst_ip, sizeof(pfe_ip_addr_t));
-	(void)memcpy(&new_entry->src_mac, src_mac, sizeof(pfe_mac_addr_t));
-	(void)memcpy(&new_entry->dst_mac, dst_mac, sizeof(pfe_mac_addr_t));
-	new_entry->iface = iface;
-	new_entry->id = id;
-	new_entry->mtu = 0; /* Not supported yet */
-	new_entry->refptr = refptr;
-
-	/*	Put to DB */
-	if (true == is_new)
-	{
-		LLIST_AddAtEnd(&(new_entry->list_member), &db->theList);
-	}
-
-	return EOK;
+	return ret;
 }
 
 /**
@@ -196,25 +203,28 @@ errno_t fci_rt_db_add(fci_rt_db_t *db,  pfe_ip_addr_t *dst_ip,
  */
 errno_t fci_rt_db_remove(fci_rt_db_t *db, fci_rt_db_entry_t *entry)
 {
+	errno_t ret = EOK;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == db) || (NULL == entry)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (&entry->list_member == db->cur_item)
 	{
-		/*	Remember the change so we can call remove() between get_first()
-			and get_next() calls. */
-		db->cur_item = db->cur_item->prNext;
-	}
+		if (&entry->list_member == db->cur_item)
+		{
+			/*	Remember the change so we can call remove() between get_first()
+				and get_next() calls. */
+			db->cur_item = db->cur_item->prNext;
+		}
 
-	LLIST_Remove(&(entry->list_member));
-	oal_mm_free(entry);
+		LLIST_Remove(&(entry->list_member));
+		oal_mm_free(entry);
+	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -238,99 +248,93 @@ fci_rt_db_entry_t *fci_rt_db_get_first(fci_rt_db_t *db, fci_rt_db_get_criterion_
 	if (unlikely(NULL == db))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return NULL;
 	}
-
-	if (unlikely((RT_DB_CRIT_ALL != crit) && (NULL == arg)))
+	else if (unlikely((RT_DB_CRIT_ALL != crit) && (NULL == arg)))
 	{
 		/*	All criterions except RT_DB_CRIT_ALL require non-NULL argument */
 		NXP_LOG_ERROR("NULL argument received\n");
-		return NULL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	/*	Remember criterion and argument for possible subsequent fci_rt_db_get_next() calls */
-	db->cur_crit = crit;
-	switch (db->cur_crit)
 	{
-		case RT_DB_CRIT_ALL:
+		/*	Remember criterion and argument for possible subsequent fci_rt_db_get_next() calls */
+		db->cur_crit = crit;
+		switch (db->cur_crit)
 		{
-			break;
-		}
+			case RT_DB_CRIT_ALL:
+			{
+				break;
+			}
 
-		case RT_DB_CRIT_BY_IF:
-		{
-			db->cur_crit_arg.iface = (const pfe_phy_if_t *)arg;
-			break;
-		}
+			case RT_DB_CRIT_BY_IF:
+			{
+				db->cur_crit_arg.iface = (const pfe_phy_if_t *)arg;
+				break;
+			}
 
-		case RT_DB_CRIT_BY_IF_NAME:
-		{
-			(void)memset(db->cur_crit_arg.outif_name, 0, sizeof(db->cur_crit_arg.outif_name));
-			(void)strncpy(db->cur_crit_arg.outif_name, arg, sizeof(db->cur_crit_arg.outif_name)-1U);
-			break;
-		}
+			case RT_DB_CRIT_BY_IF_NAME:
+			{
+				(void)memset(db->cur_crit_arg.outif_name, 0, sizeof(db->cur_crit_arg.outif_name));
+				(void)strncpy(db->cur_crit_arg.outif_name, arg, sizeof(db->cur_crit_arg.outif_name)-1U);
+				break;
+			}
 
-		case RT_DB_CRIT_BY_IP:
-		{
-			(void)memcpy(&db->cur_crit_arg.dst_ip, arg, sizeof(db->cur_crit_arg.dst_ip));
-			break;
-		}
+			case RT_DB_CRIT_BY_IP:
+			{
+				(void)memcpy(&db->cur_crit_arg.dst_ip, arg, sizeof(db->cur_crit_arg.dst_ip));
+				break;
+			}
 
-		case RT_DB_CRIT_BY_MAC:
-		{
-			(void)memcpy(&db->cur_crit_arg.dst_mac, arg, sizeof(db->cur_crit_arg.dst_mac));
-			break;
-		}
+			case RT_DB_CRIT_BY_MAC:
+			{
+				(void)memcpy(&db->cur_crit_arg.dst_mac, arg, sizeof(db->cur_crit_arg.dst_mac));
+				break;
+			}
 
-		case RT_DB_CRIT_BY_ID:
-		{
-			(void)memcpy(&db->cur_crit_arg.id, arg, sizeof(db->cur_crit_arg.id));
-			break;
-		}
+			case RT_DB_CRIT_BY_ID:
+			{
+				(void)memcpy(&db->cur_crit_arg.id, arg, sizeof(db->cur_crit_arg.id));
+				break;
+			}
 
-		default:
-		{
-			NXP_LOG_ERROR("Unknown criterion\n");
-			is_unknown_crit = TRUE;
-			break;
+			default:
+			{
+				NXP_LOG_ERROR("Unknown criterion\n");
+				is_unknown_crit = TRUE;
+				break;
+			}
 		}
-	}
-	
-	if(TRUE == is_unknown_crit)
-	{
-		return NULL;
-	}
-
-	if (false == LLIST_IsEmpty(&db->theList))
-	{
-		/*	Get first matching entry */
-		LLIST_ForEach(item, &db->theList)
+		
+		if(TRUE != is_unknown_crit)
 		{
-			/*	Get data */
-			entry = LLIST_Data(item, fci_rt_db_entry_t, list_member);
-
-			/*	Remember current item to know where to start later */
-			db->cur_item = item->prNext;
-			if (NULL != entry)
+			if (false == LLIST_IsEmpty(&db->theList))
 			{
-				if (true == fci_rt_db_match_criterion(db, entry))
+				/*	Get first matching entry */
+				LLIST_ForEach(item, &db->theList)
 				{
-					match = true;
-					break;
+					/*	Get data */
+					entry = LLIST_Data(item, fci_rt_db_entry_t, list_member);
+
+					/*	Remember current item to know where to start later */
+					db->cur_item = item->prNext;
+					if (NULL != entry)
+					{
+						if (true == fci_rt_db_match_criterion(db, entry))
+						{
+							match = true;
+							break;
+						}
+					}
 				}
 			}
 		}
 	}
 
-	if (true == match)
-	{
-		return entry;
-	}
-	else
+	if (true != match)
 	{
-		return NULL;
+		entry = NULL;
 	}
+	return entry;
 }
 
 /**
@@ -350,44 +354,43 @@ fci_rt_db_entry_t *fci_rt_db_get_next(fci_rt_db_t *db)
 	if (unlikely(NULL == db))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return NULL;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (db->cur_item == &db->theList)
-	{
-		/*	No more entries */
 		entry = NULL;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		while (db->cur_item!=&db->theList)
+		if (db->cur_item == &db->theList)
+		{
+			/*	No more entries */
+			entry = NULL;
+		}
+		else
 		{
-			/*	Get data */
-			entry = LLIST_Data(db->cur_item, fci_rt_db_entry_t, list_member);
+			while (db->cur_item!=&db->theList)
+			{
+				/*	Get data */
+				entry = LLIST_Data(db->cur_item, fci_rt_db_entry_t, list_member);
 
-			/*	Remember current item to know where to start later */
-			db->cur_item = db->cur_item->prNext;
+				/*	Remember current item to know where to start later */
+				db->cur_item = db->cur_item->prNext;
 
-			if (NULL != entry)
-			{
-				if (true == fci_rt_db_match_criterion(db, entry))
+				if (NULL != entry)
 				{
-					match = true;
-					break;
+					if (true == fci_rt_db_match_criterion(db, entry))
+					{
+						match = true;
+						break;
+					}
 				}
 			}
 		}
 	}
 
-	if (true == match)
-	{
-		return entry;
-	}
-	else
+	if (true != match)
 	{
-		return NULL;
+		entry = NULL;
 	}
+	return entry;
 }
 
 /**
@@ -399,25 +402,28 @@ errno_t fci_rt_db_drop_all(fci_rt_db_t *db)
 {
 	LLIST_t *item, *aux;
 	fci_rt_db_entry_t *entry;
+	errno_t ret = EOK;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == db))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	LLIST_ForEachRemovable(item, aux, &db->theList)
 	{
-		entry = LLIST_Data(item, fci_rt_db_entry_t, list_member);
+		LLIST_ForEachRemovable(item, aux, &db->theList)
+		{
+			entry = LLIST_Data(item, fci_rt_db_entry_t, list_member);
 
-		LLIST_Remove(item);
+			LLIST_Remove(item);
 
-		oal_mm_free(entry);
+			oal_mm_free(entry);
+		}
 	}
 
-	return EOK;
+	return ret;
 }
 
 #endif /* PFE_CFG_FCI_ENABLE */
diff --git a/sw/fci/src/fci_spd.c b/sw/fci/src/fci_spd.c
index 85240e8..78b29c7 100644
--- a/sw/fci/src/fci_spd.c
+++ b/sw/fci/src/fci_spd.c
@@ -36,184 +36,195 @@ errno_t fci_spd_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_spd_cmd_t *reply_buf,
 	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-    if (unlikely(FALSE == fci_context->fci_initialized))
+    else if (unlikely(FALSE == fci_context->fci_initialized))
 	{
     	NXP_LOG_ERROR("Context not initialized\n");
-		return EPERM;
+		ret = EPERM;
 	}
+    else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (*reply_len < sizeof(fpp_spd_cmd_t))
-	{
-		NXP_LOG_ERROR("Buffer length does not match expected value (fpp_spd_cmd_t)\n");
-		return EINVAL;
-	}
-	else
-	{
-		/*	No data written to reply buffer (yet) */
-		*reply_len = 0U;
-	}
-    (void)memset(&spd_entry, 0, sizeof(pfe_ct_spd_entry_t));
-
-	/*	Check that the FW feature is available (enabled) in FW */
-	if (FALSE == pfe_feature_mgr_is_available("IPsec"))
-	{
-		/* Unavailable feature. Respond with FCI error code. */
-		NXP_LOG_ERROR("Feature 'IPsec' is not available (not enabled in FW).\n");
-		*fci_ret = FPP_ERR_FW_FEATURE_NOT_AVAILABLE;
-		return EOK;
-	}
-
-	/*	Initialize the reply buffer */
-	(void)memset(reply_buf, 0, sizeof(fpp_spd_cmd_t));
-
-	spd_cmd = (fpp_spd_cmd_t *)(msg->msg_cmd.payload);
-    /* Get the physical interface reference - needed for all commands */
-    ret = pfe_if_db_lock(&fci_context->if_session_id);
-    if (EOK != ret)
-    {
-        *fci_ret = FPP_ERR_IF_RESOURCE_ALREADY_LOCKED;
-        NXP_LOG_DEBUG("DB lock failed\n");
-        return ret;
-    }
-    ret = pfe_if_db_get_first(fci_context->phy_if_db, fci_context->if_session_id, IF_DB_CRIT_BY_NAME, spd_cmd->name, &pfe_if_db_entry);
-    /* We first unlock the database and then examine the result */
-    if (EOK != pfe_if_db_unlock(fci_context->if_session_id))
-    {
-        *fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
-        NXP_LOG_DEBUG("DB unlock failed\n");
-        return ENOENT;
-    }
-    if((EOK != ret) || (NULL == pfe_if_db_entry))
-    {
-        NXP_LOG_WARNING("Interface %s not found\n", spd_cmd->name);
-        *fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-        return ret;
-    }
-    phy_if = pfe_if_db_entry_get_phy_if(pfe_if_db_entry);
-    if(NULL == phy_if)
-    {
-        NXP_LOG_ERROR("Failed to get PHY if from DB entry\n");
-        *fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-        return ENOENT;
-
-    }
-
-    /* Now interpret the command for given physical interface */
-    switch(spd_cmd->action)
     {
-        case FPP_ACTION_REGISTER:
-
-            if(0U != ((uint8_t)spd_cmd->flags & (uint8_t)FPP_SPD_FLAG_IPv6))
-            {
-                spd_entry.flags |= SPD_FLAG_IPv6;
-                (void)memcpy(&spd_entry.ipv.v6.sip, &spd_cmd->saddr[0], 16U);
-                (void)memcpy(&spd_entry.ipv.v6.dip, &spd_cmd->daddr[0], 16U);
-            }
-            else
-            {
-                spd_entry.ipv.v4.sip = spd_cmd->saddr[0];
-                spd_entry.ipv.v4.dip = spd_cmd->daddr[0];
-            }
-            if(0U != ((uint8_t)spd_cmd->flags & (uint8_t)FPP_SPD_FLAG_SPORT_OPAQUE))
-            {
-                spd_entry.flags |= SPD_FLAG_SPORT_OPAQUE;
-            }
-            if(0U != ((uint8_t)spd_cmd->flags & (uint8_t)FPP_SPD_FLAG_DPORT_OPAQUE))
-            {
-                spd_entry.flags |= SPD_FLAG_DPORT_OPAQUE;
-            }
-            spd_entry.proto = spd_cmd->protocol;
-            spd_entry.sport = spd_cmd->sport;
-            spd_entry.dport  = spd_cmd-> dport;
-            spd_entry.sad_entry = spd_cmd->sa_id;
-            spd_entry.spi = spd_cmd->spi;
-            /* Using the fact that enums have same values for the corresponding flags */
-            spd_entry.action = (pfe_ct_spd_entry_action_t)spd_cmd->spd_action;
-
-            ret = pfe_spd_acc_add_rule(phy_if, oal_ntohs(spd_cmd->position), &spd_entry);
-            if(EOK != ret)
-            {
-                *fci_ret = FPP_ERR_INTERNAL_FAILURE;
-            }
-            else
-            {
-                *fci_ret = FPP_ERR_OK;
-            }
-            break;
-
-        case FPP_ACTION_DEREGISTER:
-            ret = pfe_spd_acc_remove_rule(phy_if, oal_ntohs(spd_cmd->position));
-            if(EOK != ret)
+        if (*reply_len < sizeof(fpp_spd_cmd_t))
+        {
+            NXP_LOG_ERROR("Buffer length does not match expected value (fpp_spd_cmd_t)\n");
+            ret = EINVAL;
+        }
+        else
+        {
+            /*	No data written to reply buffer (yet) */
+            *reply_len = 0U;
+            (void)memset(&spd_entry, 0, sizeof(pfe_ct_spd_entry_t));
+
+            /*	Check that the FW feature is available (enabled) in FW */
+            if (FALSE == pfe_feature_mgr_is_available("IPsec"))
             {
-                *fci_ret = FPP_ERR_INTERNAL_FAILURE;
+                /* Unavailable feature. Respond with FCI error code. */
+                NXP_LOG_ERROR("Feature 'IPsec' is not available (not enabled in FW).\n");
+                *fci_ret = FPP_ERR_FW_FEATURE_NOT_AVAILABLE;
+                ret = EOK;
             }
             else
             {
-                *fci_ret = FPP_ERR_OK;
-            }
-            break;
-
-        case FPP_ACTION_QUERY:
-            search_position = 0U;
-            /* FALLTHRU */
-
-        case FPP_ACTION_QUERY_CONT:
-            ret = pfe_spd_acc_get_rule(phy_if, search_position, &spd_entry);
-            if(EOK == ret)
-            {
-                /* Construct reply */
+                /*	Initialize the reply buffer */
                 (void)memset(reply_buf, 0, sizeof(fpp_spd_cmd_t));
-                (void)strcpy(reply_buf->name, spd_cmd->name);
-                if(0 != (spd_entry.flags & SPD_FLAG_IPv6))
+
+                spd_cmd = (fpp_spd_cmd_t *)(msg->msg_cmd.payload);
+                /* Get the physical interface reference - needed for all commands */
+                ret = pfe_if_db_lock(&fci_context->if_session_id);
+                if (EOK != ret)
                 {
-                    reply_buf->flags |= FPP_SPD_FLAG_IPv6;
-                    (void)memcpy(&reply_buf->saddr[0], &spd_entry.ipv.v6.sip[0], 16U);
-                    (void)memcpy(&reply_buf->daddr[0], &spd_entry.ipv.v6.dip[0], 16U);
+                    *fci_ret = FPP_ERR_IF_RESOURCE_ALREADY_LOCKED;
+                    NXP_LOG_DEBUG("DB lock failed\n");
                 }
                 else
                 {
-                    reply_buf->saddr[0] = spd_entry.ipv.v4.sip;
-                    reply_buf->daddr[0] = spd_entry.ipv.v4.dip;
-                }
-                if(0 != (spd_entry.flags & SPD_FLAG_SPORT_OPAQUE))
-                {
-                    reply_buf->flags |= FPP_SPD_FLAG_SPORT_OPAQUE;
-                }
-                if(0 != (spd_entry.flags & SPD_FLAG_DPORT_OPAQUE))
-                {
-                    reply_buf->flags |= FPP_SPD_FLAG_DPORT_OPAQUE;
+                    ret = pfe_if_db_get_first(fci_context->phy_if_db, fci_context->if_session_id, IF_DB_CRIT_BY_NAME, spd_cmd->name, &pfe_if_db_entry);
+                    /* We first unlock the database and then examine the result */
+                    if (EOK != pfe_if_db_unlock(fci_context->if_session_id))
+                    {
+                        *fci_ret = FPP_ERR_IF_WRONG_SESSION_ID;
+                        NXP_LOG_DEBUG("DB unlock failed\n");
+                        ret = ENOENT;
+                    }
+                    else
+                    {
+                        if((EOK != ret) || (NULL == pfe_if_db_entry))
+                        {
+                            NXP_LOG_WARNING("Interface %s not found\n", spd_cmd->name);
+                            *fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
+                        }
+                        else
+                        {
+                            phy_if = pfe_if_db_entry_get_phy_if(pfe_if_db_entry);
+                            if(NULL == phy_if)
+                            {
+                                NXP_LOG_ERROR("Failed to get PHY if from DB entry\n");
+                                *fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
+                                ret = ENOENT;
+                            }
+                            else
+                            {
+                                /* Now interpret the command for given physical interface */
+                                switch(spd_cmd->action)
+                                {
+                                    case FPP_ACTION_REGISTER:
+
+                                        if(0U != ((uint8_t)spd_cmd->flags & (uint8_t)FPP_SPD_FLAG_IPv6))
+                                        {
+                                            spd_entry.flags |= SPD_FLAG_IPv6;
+                                            (void)memcpy(&spd_entry.ipv.v6.sip, &spd_cmd->saddr[0], 16U);
+                                            (void)memcpy(&spd_entry.ipv.v6.dip, &spd_cmd->daddr[0], 16U);
+                                        }
+                                        else
+                                        {
+                                            spd_entry.ipv.v4.sip = spd_cmd->saddr[0];
+                                            spd_entry.ipv.v4.dip = spd_cmd->daddr[0];
+                                        }
+                                        if(0U != ((uint8_t)spd_cmd->flags & (uint8_t)FPP_SPD_FLAG_SPORT_OPAQUE))
+                                        {
+                                            spd_entry.flags |= SPD_FLAG_SPORT_OPAQUE;
+                                        }
+                                        if(0U != ((uint8_t)spd_cmd->flags & (uint8_t)FPP_SPD_FLAG_DPORT_OPAQUE))
+                                        {
+                                            spd_entry.flags |= SPD_FLAG_DPORT_OPAQUE;
+                                        }
+                                        spd_entry.proto = spd_cmd->protocol;
+                                        spd_entry.sport = spd_cmd->sport;
+                                        spd_entry.dport  = spd_cmd-> dport;
+                                        spd_entry.sad_entry = spd_cmd->sa_id;
+                                        spd_entry.spi = spd_cmd->spi;
+                                        /* Using the fact that enums have same values for the corresponding flags */
+                                        spd_entry.action = (pfe_ct_spd_entry_action_t)spd_cmd->spd_action;
+
+                                        ret = pfe_spd_acc_add_rule(phy_if, oal_ntohs(spd_cmd->position), &spd_entry);
+                                        if(EOK != ret)
+                                        {
+                                            *fci_ret = FPP_ERR_INTERNAL_FAILURE;
+                                        }
+                                        else
+                                        {
+                                            *fci_ret = FPP_ERR_OK;
+                                        }
+                                        break;
+
+                                    case FPP_ACTION_DEREGISTER:
+                                        ret = pfe_spd_acc_remove_rule(phy_if, oal_ntohs(spd_cmd->position));
+                                        if(EOK != ret)
+                                        {
+                                            *fci_ret = FPP_ERR_INTERNAL_FAILURE;
+                                        }
+                                        else
+                                        {
+                                            *fci_ret = FPP_ERR_OK;
+                                        }
+                                        break;
+
+                                    case FPP_ACTION_QUERY:
+                                        search_position = 0U;
+                                        /* FALLTHRU */
+
+                                    case FPP_ACTION_QUERY_CONT:
+                                        ret = pfe_spd_acc_get_rule(phy_if, search_position, &spd_entry);
+                                        if(EOK == ret)
+                                        {
+                                            /* Construct reply */
+                                            (void)memset(reply_buf, 0, sizeof(fpp_spd_cmd_t));
+                                            (void)strcpy(reply_buf->name, spd_cmd->name);
+                                            if(0 != (spd_entry.flags & SPD_FLAG_IPv6))
+                                            {
+                                                reply_buf->flags |= FPP_SPD_FLAG_IPv6;
+                                                (void)memcpy(&reply_buf->saddr[0], &spd_entry.ipv.v6.sip[0], 16U);
+                                                (void)memcpy(&reply_buf->daddr[0], &spd_entry.ipv.v6.dip[0], 16U);
+                                            }
+                                            else
+                                            {
+                                                reply_buf->saddr[0] = spd_entry.ipv.v4.sip;
+                                                reply_buf->daddr[0] = spd_entry.ipv.v4.dip;
+                                            }
+                                            if(0 != (spd_entry.flags & SPD_FLAG_SPORT_OPAQUE))
+                                            {
+                                                reply_buf->flags |= FPP_SPD_FLAG_SPORT_OPAQUE;
+                                            }
+                                            if(0 != (spd_entry.flags & SPD_FLAG_DPORT_OPAQUE))
+                                            {
+                                                reply_buf->flags |= FPP_SPD_FLAG_DPORT_OPAQUE;
+                                            }
+                                            reply_buf->protocol = spd_entry.proto;
+                                            reply_buf->sport = spd_entry.sport;
+                                            reply_buf->dport = spd_entry.dport;
+                                            reply_buf->sa_id = spd_entry.sad_entry;
+                                            reply_buf->spi = spd_entry.spi;
+                                            /* Using the fact that enums have same values for the corresponding flags */
+                                            reply_buf->spd_action = (fpp_spd_action_t)spd_entry.action;
+                                            reply_buf->position = oal_htons(search_position);
+                                            search_position++;
+                                            *fci_ret = FPP_ERR_OK;
+                                            *reply_len = sizeof(fpp_spd_cmd_t);
+                                            ret = EOK;
+                                        }
+                                        else
+                                        {
+                                            *fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
+                                            ret = EOK;
+                                        }
+                                        break;
+
+                                    default:
+                                    {
+                                        NXP_LOG_ERROR("Connection Command: Unknown action received: 0x%x\n", spd_cmd->action);
+                                        *fci_ret = FPP_ERR_UNKNOWN_ACTION;
+                                        ret = EINVAL;
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
                 }
-                reply_buf->protocol = spd_entry.proto;
-                reply_buf->sport = spd_entry.sport;
-                reply_buf->dport = spd_entry.dport;
-                reply_buf->sa_id = spd_entry.sad_entry;
-                reply_buf->spi = spd_entry.spi;
-                /* Using the fact that enums have same values for the corresponding flags */
-                reply_buf->spd_action = (fpp_spd_action_t)spd_entry.action;
-                reply_buf->position = oal_htons(search_position);
-                search_position++;
-                *fci_ret = FPP_ERR_OK;
-                *reply_len = sizeof(fpp_spd_cmd_t);
-                ret = EOK;
             }
-            else
-            {
-                *fci_ret = FPP_ERR_IF_ENTRY_NOT_FOUND;
-                ret = EOK;
-            }
-            break;
-
-		default:
-		{
-			NXP_LOG_ERROR("Connection Command: Unknown action received: 0x%x\n", spd_cmd->action);
-			*fci_ret = FPP_ERR_UNKNOWN_ACTION;
-            ret = EINVAL;
-			break;
-		}
+        }
     }
 
     return ret;
diff --git a/sw/libfci_cli/Makefile b/sw/libfci_cli/Makefile
index f004acb..cd7c597 100644
--- a/sw/libfci_cli/Makefile
+++ b/sw/libfci_cli/Makefile
@@ -60,7 +60,7 @@ ifeq ($(TARGET_OS),LINUX)
 	GLOBAL_CCFLAGS := $(shell echo $(GLOBAL_CCFLAGS))
 	
 	CLI_TARGET_OS = "LNX"
-	CLI_DRV_VERSION = "RTM 1.0.0 RC2"
+	CLI_DRV_VERSION = "RTM 1.0.0 RC3"
 else
 #This branch by defaut means QNX.
 	LIBS += -L../xfci/libfci/build/$(PLATFORM)-$(BUILD_PROFILE) -l:libfci.a
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_route_and_cntk.c b/sw/libfci_cli/src/libfci_cli_cmds_route_and_cntk.c
index 75c3796..3dc3d6a 100644
--- a/sw/libfci_cli/src/libfci_cli_cmds_route_and_cntk.c
+++ b/sw/libfci_cli/src/libfci_cli_cmds_route_and_cntk.c
@@ -1,5 +1,5 @@
 /* =========================================================================
- *  Copyright 2020-2021 NXP
+ *  Copyright 2020-2022 NXP
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -189,6 +189,19 @@ static int ct_print(const fpp_ct_cmd_t* p_ct)
         printf("\n");
     }
     
+    {
+        /* statistics */
+        printf("%-*sstats:  ", indent, "");
+        
+        printf(" orig_hit: %"PRIu32, demo_ct_ld_get_stt_hit(p_ct));
+        printf(" orig_hit_bytes: %"PRIu32, demo_ct_ld_get_stt_hit_bytes(p_ct));
+        printf("  ");
+        printf(" reply_hit: %"PRIu32, demo_ct_ld_get_stt_reply_hit(p_ct));
+        printf(" reply_hit_bytes: %"PRIu32, demo_ct_ld_get_stt_reply_hit_bytes(p_ct));
+        
+        printf("\n");
+    }
+    
     return (FPP_ERR_OK); 
 }
 
@@ -259,6 +272,19 @@ static int ct6_print(const fpp_ct6_cmd_t* p_ct6)
         printf("\n");
     }
     
+    {
+        /* statistics */
+        printf("%-*sstats:   ", indent, "");
+        
+        printf(" orig_hit: %"PRIu32, demo_ct6_ld_get_stt_hit(p_ct6));
+        printf(" orig_hit_bytes: %"PRIu32, demo_ct6_ld_get_stt_hit_bytes(p_ct6));
+        printf("   ");
+        printf(" reply_hit: %"PRIu32, demo_ct6_ld_get_stt_reply_hit(p_ct6));
+        printf(" reply_hit_bytes: %"PRIu32, demo_ct6_ld_get_stt_reply_hit_bytes(p_ct6));
+        
+        printf("\n");
+    }
+    
     return (FPP_ERR_OK); 
 }
 
diff --git a/sw/libfci_cli/src/libfci_cli_common.h b/sw/libfci_cli/src/libfci_cli_common.h
index 69b7a17..8f8f9a4 100644
--- a/sw/libfci_cli/src/libfci_cli_common.h
+++ b/sw/libfci_cli/src/libfci_cli_common.h
@@ -43,8 +43,8 @@
 
 /* app version */
 #define CLI_VERSION_MAJOR  "2"
-#define CLI_VERSION_MINOR  "4"
-#define CLI_VERSION_PATCH  "1"
+#define CLI_VERSION_MINOR  "5"
+#define CLI_VERSION_PATCH  "0"
 
 
 /* drv version (default values for non-makefile compilation) */
diff --git a/sw/libfci_cli/src/libfci_demo/demo_rt_ct.c b/sw/libfci_cli/src/libfci_demo/demo_rt_ct.c
index 6e776f1..9b4ea63 100644
--- a/sw/libfci_cli/src/libfci_demo/demo_rt_ct.c
+++ b/sw/libfci_cli/src/libfci_demo/demo_rt_ct.c
@@ -1,5 +1,5 @@
 /* =========================================================================
- *  Copyright 2020-2021 NXP
+ *  Copyright 2020-2022 NXP
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -1417,6 +1417,58 @@ uint16_t demo_ct_ld_get_flags(const fpp_ct_cmd_t* p_ct)
 }
  
  
+/*
+ * @brief      Query the statistics of an IPv4 conntrack (number of frames).
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     Number of frames that used the conntrack.
+ */
+uint32_t demo_ct_ld_get_stt_hit(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return ntohl(p_ct->stats.hit);
+}
+ 
+ 
+/*
+ * @brief      Query the statistics of an IPv6 conntrack (number of bytes).
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     Sum of bytesizes of all frames that used the conntrack.
+ */
+uint32_t demo_ct_ld_get_stt_hit_bytes(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return ntohl(p_ct->stats.hit_bytes);
+}
+ 
+ 
+/*
+ * @brief      Query the statistics of an IPv4 conntrack (number of frames).
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     Number of frames that used the conntrack (reply direction).
+ */
+uint32_t demo_ct_ld_get_stt_reply_hit(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return ntohl(p_ct->stats_reply.hit);
+}
+ 
+ 
+/*
+ * @brief      Query the statistics of an IPv4 conntrack (number of bytes).
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     Sum of bytesizes of all frames that used the conntrack (reply direction).
+ */
+uint32_t demo_ct_ld_get_stt_reply_hit_bytes(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return ntohl(p_ct->stats_reply.hit_bytes);
+}
+ 
+ 
  
  
 /*
@@ -1724,6 +1776,58 @@ uint16_t demo_ct6_ld_get_flags(const fpp_ct6_cmd_t* p_ct6)
 }
  
  
+/*
+ * @brief      Query the statistics of an IPv6 conntrack (number of frames).
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     Number of frames that used the conntrack.
+ */
+uint32_t demo_ct6_ld_get_stt_hit(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return ntohl(p_ct6->stats.hit);
+}
+ 
+ 
+/*
+ * @brief      Query the statistics of an IPv6 conntrack (number of bytes).
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     Sum of bytesizes of all frames that used the conntrack.
+ */
+uint32_t demo_ct6_ld_get_stt_hit_bytes(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return ntohl(p_ct6->stats.hit_bytes);
+}
+ 
+ 
+/*
+ * @brief      Query the statistics of an IPv6 conntrack (number of frames).
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     Number of frames that used the conntrack (reply direction).
+ */
+uint32_t demo_ct6_ld_get_stt_reply_hit(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return ntohl(p_ct6->stats_reply.hit);
+}
+ 
+ 
+/*
+ * @brief      Query the statistics of an IPv6 conntrack (number of bytes).
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     Sum of bytesizes of all frames that used the conntrack (reply direction).
+ */
+uint32_t demo_ct6_ld_get_stt_reply_hit_bytes(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return ntohl(p_ct6->stats_reply.hit_bytes);
+}
+ 
+ 
 /* ==== PUBLIC FUNCTIONS : misc ============================================ */
  
  
diff --git a/sw/libfci_cli/src/libfci_demo/demo_rt_ct.h b/sw/libfci_cli/src/libfci_demo/demo_rt_ct.h
index 85d6341..3a0a476 100644
--- a/sw/libfci_cli/src/libfci_demo/demo_rt_ct.h
+++ b/sw/libfci_cli/src/libfci_demo/demo_rt_ct.h
@@ -1,5 +1,5 @@
 /* =========================================================================
- *  Copyright 2020-2021 NXP
+ *  Copyright 2020-2022 NXP
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -130,8 +130,12 @@ uint16_t demo_ct_ld_get_dport_reply(const fpp_ct_cmd_t* p_ct);
 uint16_t demo_ct_ld_get_vlan_reply(const fpp_ct_cmd_t* p_ct);
 uint32_t demo_ct_ld_get_route_id_reply(const fpp_ct_cmd_t* p_ct);
 uint16_t demo_ct_ld_get_flags(const fpp_ct_cmd_t* p_ct);
-
-
+uint32_t demo_ct_ld_get_stt_hit(const fpp_ct_cmd_t* p_ct);
+uint32_t demo_ct_ld_get_stt_hit_bytes(const fpp_ct_cmd_t* p_ct);
+uint32_t demo_ct_ld_get_stt_reply_hit(const fpp_ct_cmd_t* p_ct);
+uint32_t demo_ct_ld_get_stt_reply_hit_bytes(const fpp_ct_cmd_t* p_ct);
+ 
+ 
 bool demo_ct6_ld_is_nat(const fpp_ct6_cmd_t* p_ct6);
 bool demo_ct6_ld_is_pat(const fpp_ct6_cmd_t* p_ct6);
 bool demo_ct6_ld_is_vlan_tagging(const fpp_ct6_cmd_t* p_ct6);
@@ -153,6 +157,10 @@ uint16_t        demo_ct6_ld_get_dport_reply(const fpp_ct6_cmd_t* p_ct6);
 uint16_t        demo_ct6_ld_get_vlan_reply(const fpp_ct6_cmd_t* p_ct6);
 uint32_t        demo_ct6_ld_get_route_id_reply(const fpp_ct6_cmd_t* p_ct6);
 uint16_t        demo_ct6_ld_get_flags(const fpp_ct6_cmd_t* p_ct6);
+uint32_t        demo_ct6_ld_get_stt_hit(const fpp_ct6_cmd_t* p_ct6);
+uint32_t        demo_ct6_ld_get_stt_hit_bytes(const fpp_ct6_cmd_t* p_ct6);
+uint32_t        demo_ct6_ld_get_stt_reply_hit(const fpp_ct6_cmd_t* p_ct6);
+uint32_t        demo_ct6_ld_get_stt_reply_hit_bytes(const fpp_ct6_cmd_t* p_ct6);
 
 /* ==== PUBLIC FUNCTIONS : misc ============================================ */
 
diff --git a/sw/linux-pfeng/Makefile b/sw/linux-pfeng/Makefile
index 90991f8..34d1164 100644
--- a/sw/linux-pfeng/Makefile
+++ b/sw/linux-pfeng/Makefile
@@ -19,9 +19,7 @@ PFE_CFG_HIF_USE_BD_TRIGGER ?= 1
 PFE_CFG_BD_MEM ?= "pfe-bdr-pool"
 PFE_CFG_SYS_MEM ?= "pfe-bmu2-pool"
 PFE_CFG_RT_MEM ?= "pfe-rt-pool"
-PFE_CFG_LINUX_NO_SERDES_SUPPORT ?= 0
 PFE_CFG_BMU2_BUF_COUNT ?= 256
-PFE_CFG_LINUX_RES_MEM_ENABLE ?= 0
 
 # Warning for PFE_CFG_LINUX_TRACE=1:
 # The compile time checker doesn't work well with -Og
@@ -56,9 +54,6 @@ ccflags-y += -Og
 endif
 ccflags-y += -Wno-date-time
 ccflags-y += -Werror
-ifneq ($(PFE_CFG_LINUX_NO_SERDES_SUPPORT),0)
-ccflags-y += -DPFENG_CFG_LINUX_NO_SERDES_SUPPORT
-endif
 
 OBJ_LIBFCI_DIR = ../xfci/libfci
 OBJ_DIRS = ../oal ../bpool  ../elf  ../fifo  ../pfe_platform ../common
diff --git a/sw/linux-pfeng/pfeng-drv.c b/sw/linux-pfeng/pfeng-drv.c
index 20944f6..6cfec44 100644
--- a/sw/linux-pfeng/pfeng-drv.c
+++ b/sw/linux-pfeng/pfeng-drv.c
@@ -528,10 +528,6 @@ static int pfeng_drv_probe(struct platform_device *pdev)
 			goto err_drv;
 	}
 
-#ifdef PFE_CFG_MULTI_INSTANCE_SUPPORT
-	hal_ip_ready_set(true);
-#endif /* PFE_CFG_MULTI_INSTANCE_SUPPORT */
-
 	/* Prepare EMAC RX/TX clocks */
 	for (id = 0; id < PFENG_PFE_EMACS; id++) {
 		struct pfeng_emac *emac = &priv->emac[id];
@@ -576,12 +572,16 @@ static int pfeng_drv_probe(struct platform_device *pdev)
 				dev_err(dev, "Failed to set RX clock on EMAC%d for interface %s. Error %d\n", id, phy_modes(emac->intf_mode), ret);
 			else {
 				ret = clk_prepare_enable(emac->rx_clk);
-				if (ret)
-					dev_err(dev, "Failed to enable RX clocks on EMAC%d for interface %s. Error %d\n", id, phy_modes(emac->intf_mode), ret);
+				if (ret) {
+					dev_warn(dev, "Defer enabling of RX clock on EMAC%d for interface %s (ret: %d)\n", id, phy_modes(emac->intf_mode), ret);
+					emac->rx_clk_pending = true;
+				}
 			}
 			if (ret) {
-				devm_clk_put(dev, emac->rx_clk);
-				emac->rx_clk = NULL;
+				if (!emac->rx_clk_pending) {
+					devm_clk_put(dev, emac->rx_clk);
+					emac->rx_clk = NULL;
+				}
 			} else
 				dev_info(dev, "RX clock on EMAC%d for interface %s installed\n", id, phy_modes(emac->intf_mode));
 		}
@@ -627,6 +627,10 @@ static int pfeng_drv_probe(struct platform_device *pdev)
 		goto err_drv;
 	}
 
+#ifdef PFE_CFG_MULTI_INSTANCE_SUPPORT
+	hal_ip_ready_set(true);
+#endif /* PFE_CFG_MULTI_INSTANCE_SUPPORT */
+
 	/* Create debugfs */
 	pfeng_debugfs_create(priv);
 
@@ -801,10 +805,6 @@ static int pfeng_drv_pm_resume(struct device *dev)
 		goto err_pfe_init;
 	}
 
-#ifdef PFE_CFG_MULTI_INSTANCE_SUPPORT
-	hal_ip_ready_set(true);
-#endif /* PFE_CFG_MULTI_INSTANCE_SUPPORT */
-
 	/* Start PFE Platform */
 	ret = pfe_platform_init(priv->pfe_cfg);
 	if (ret) {
@@ -818,6 +818,10 @@ static int pfeng_drv_pm_resume(struct device *dev)
 		goto err_pfe_get;
 	}
 
+#ifdef PFE_CFG_MULTI_INSTANCE_SUPPORT
+	hal_ip_ready_set(true);
+#endif /* PFE_CFG_MULTI_INSTANCE_SUPPORT */
+
 	/* Create debugfs */
 	pfeng_debugfs_create(priv);
 
diff --git a/sw/linux-pfeng/pfeng-dt.c b/sw/linux-pfeng/pfeng-dt.c
index b26d68c..e10c0c9 100644
--- a/sw/linux-pfeng/pfeng-dt.c
+++ b/sw/linux-pfeng/pfeng-dt.c
@@ -70,7 +70,6 @@ int pfeng_dt_release_config(struct pfeng_priv *priv)
 	/* Free EMAC clocks */
 	for (id = 0; id < PFENG_PFE_EMACS; id++) {
 		struct pfeng_emac *emac = &priv->emac[id];
-#if !defined(PFENG_CFG_LINUX_NO_SERDES_SUPPORT)
 #if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
 		struct device *dev = &priv->pdev->dev;
 
@@ -78,7 +77,6 @@ int pfeng_dt_release_config(struct pfeng_priv *priv)
 		if (emac->intf_mode == PHY_INTERFACE_MODE_SGMII && emac->serdes_phy)
 			device_link_remove(dev, &emac->serdes_phy->dev);
 #endif
-#endif /* !PFENG_CFG_LINUX_NO_SERDES_SUPPORT */
 
 		/* EMAC RX clk */
 		if (emac->rx_clk) {
@@ -96,7 +94,7 @@ int pfeng_dt_release_config(struct pfeng_priv *priv)
 	return 0;
 }
 
-#if defined(PFE_CFG_PFE_MASTER) && !defined(PFENG_CFG_LINUX_NO_SERDES_SUPPORT)
+#if defined(PFE_CFG_PFE_MASTER)
 static bool pfeng_manged_inband(struct device_node *node)
 {
 	const char *managed;
@@ -107,7 +105,7 @@ static bool pfeng_manged_inband(struct device_node *node)
 
 	return false;
 }
-#endif /* PFENG_CFG_LINUX_NO_SERDES_SUPPORT */
+#endif /* PFE_CFG_PFE_MASTER */
 
 int pfeng_dt_create_config(struct pfeng_priv *priv)
 {
@@ -346,7 +344,6 @@ int pfeng_dt_create_config(struct pfeng_priv *priv)
 			if (of_phy_is_fixed_link(child))
 				emac->link_an = MLO_AN_FIXED;
 
-#if !defined(PFENG_CFG_LINUX_NO_SERDES_SUPPORT)
 			if (pfeng_manged_inband(child)) {
 				emac->link_an = MLO_AN_INBAND;
 				dev_info(dev, "SGMII AN enabled on EMAC%d\n", netif_cfg->emac_id);
@@ -358,7 +355,6 @@ int pfeng_dt_create_config(struct pfeng_priv *priv)
 				dev_info(dev, "EMAC%d PHY less SGMII\n", netif_cfg->emac_id);
 				emac->phyless = true;
 			}
-#endif /* PFENG_CFG_LINUX_NO_SERDES_SUPPORT */
 
 			/* Interface mode */
 			ret = pfeng_of_get_phy_mode(child, &intf_mode);
@@ -390,7 +386,7 @@ int pfeng_dt_create_config(struct pfeng_priv *priv)
 					emac->max_speed = SPEED_2500;
 				else
 					emac->max_speed = SPEED_1000;
-#if !defined(PFENG_CFG_LINUX_NO_SERDES_SUPPORT)
+
 				/* Standard SGMII AN is at 1G */
 				emac->serdes_an_speed = SPEED_1000;
 			} else {
@@ -418,7 +414,6 @@ int pfeng_dt_create_config(struct pfeng_priv *priv)
 			} else {
 				emac->serdes_phy = NULL;
 			}
-#endif /* PFENG_CFG_LINUX_NO_SERDES_SUPPORT */
 
 			/* optional: tx clock */
 			if (phy_interface_mode_is_rgmii(intf_mode))
diff --git a/sw/linux-pfeng/pfeng-ethtool.c b/sw/linux-pfeng/pfeng-ethtool.c
index a6daae6..c5ae4ac 100644
--- a/sw/linux-pfeng/pfeng-ethtool.c
+++ b/sw/linux-pfeng/pfeng-ethtool.c
@@ -104,7 +104,7 @@ static int pfeng_ethtool_get_ts_info(struct net_device *netdev, struct ethtool_t
 	if (netif->ptp_clock)
 		info->phc_index = ptp_clock_index(netif->ptp_clock);
 	else
-		netdev_info(netdev, "No PTP clock available\n");
+		info->phc_index = -1;
 
 	return 0;
 }
diff --git a/sw/linux-pfeng/pfeng-hif.c b/sw/linux-pfeng/pfeng-hif.c
index 2f2bc61..6fdcdcd 100644
--- a/sw/linux-pfeng/pfeng-hif.c
+++ b/sw/linux-pfeng/pfeng-hif.c
@@ -240,7 +240,7 @@ static int pfeng_hif_chnl_rx(struct pfeng_hif_chnl *chnl, int limit)
 			break;
 
 		hif_hdr = (pfe_ct_hif_rx_hdr_t *)skb->data;
-		hif_hdr->flags = (pfe_ct_hif_rx_flags_t)oal_ntohs(hif_hdr->flags);
+		hif_hdr->flags = (pfe_ct_hif_rx_flags_t)oal_ntohl(hif_hdr->flags);
 
 #ifdef PFE_CFG_MULTI_INSTANCE_SUPPORT
 		/* Check for IHC frame */
@@ -276,7 +276,7 @@ static int pfeng_hif_chnl_rx(struct pfeng_hif_chnl *chnl, int limit)
 			/* Accept all traffic */
 		} else if (likely(!chnl->netifs[PFENG_NETIFS_AUX_IDX])) {
 			/* No AUX */
-		} else if (unlikely(hif_hdr->flags & (HIF_RX_PTP | HIF_RX_PUNT | HIF_RX_ETS))) {
+		} else if (unlikely(hif_hdr->flags & (HIF_RX_PTP | HIF_RX_ETS))) {
 			/* Frame is "management" */
 		} else {
 			/* Frame is "non-management", route to AUX */
diff --git a/sw/linux-pfeng/pfeng-hwts.c b/sw/linux-pfeng/pfeng-hwts.c
index 8de3ed4..ed91a3e 100644
--- a/sw/linux-pfeng/pfeng-hwts.c
+++ b/sw/linux-pfeng/pfeng-hwts.c
@@ -172,15 +172,12 @@ int pfeng_hwts_ioctl_set(struct pfeng_netif *netif, struct ifreq *rq)
 	if (copy_from_user(&cfg, rq->ifr_data, sizeof(cfg)))
 		return -EFAULT;
 
-#ifdef PFE_CFG_PFE_MASTER
-	if(!netif->priv->clk_ptp_reference)
-#endif
+	if(!IS_ENABLED(PFE_CFG_PFE_MASTER) || !netif->priv->clk_ptp_reference)
 	{
 		netif->tshw_cfg.rx_filter = HWTSTAMP_FILTER_NONE;
 		netif->tshw_cfg.tx_type = HWTSTAMP_TX_OFF;
 		return copy_to_user(rq->ifr_data, &netif->tshw_cfg, sizeof(struct hwtstamp_config)) ? -EFAULT : 0;
 	}
-#ifdef PFE_CFG_PFE_MASTER
 
 	switch (cfg.tx_type) {
 	case HWTSTAMP_TX_OFF:
@@ -205,9 +202,6 @@ int pfeng_hwts_ioctl_set(struct pfeng_netif *netif, struct ifreq *rq)
 	}
 
 	return copy_to_user(rq->ifr_data, &netif->tshw_cfg, sizeof(cfg)) ? -EFAULT : 0;
-#else
-	return -EFAULT;
-#endif /* PFE_CFG_PFE_MASTER */
 }
 
 int pfeng_hwts_ioctl_get(struct pfeng_netif *netif, struct ifreq *rq)
@@ -217,31 +211,24 @@ int pfeng_hwts_ioctl_get(struct pfeng_netif *netif, struct ifreq *rq)
 
 int pfeng_hwts_ethtool(struct pfeng_netif *netif, struct ethtool_ts_info *info)
 {
-#ifdef PFE_CFG_PFE_MASTER
-	if(!netif->priv->clk_ptp_reference)
-#endif
-	{
-		info->so_timestamping |= (SOF_TIMESTAMPING_TX_SOFTWARE |
-					  SOF_TIMESTAMPING_RX_SOFTWARE |
-					  SOF_TIMESTAMPING_SOFTWARE);
-
+	if (!IS_ENABLED(PFE_CFG_PFE_MASTER) ||
+	    !netif->priv->clk_ptp_reference || netif->cfg->aux) {
+		info->so_timestamping |= SOF_TIMESTAMPING_TX_SOFTWARE |
+					 SOF_TIMESTAMPING_RX_SOFTWARE |
+					 SOF_TIMESTAMPING_SOFTWARE;
 		info->tx_types = BIT(HWTSTAMP_TX_OFF);
+	} else {
+		info->so_timestamping |= SOF_TIMESTAMPING_TX_HARDWARE |
+					 SOF_TIMESTAMPING_RX_HARDWARE |
+					 SOF_TIMESTAMPING_RAW_HARDWARE |
+					 SOF_TIMESTAMPING_TX_SOFTWARE |
+					 SOF_TIMESTAMPING_RX_SOFTWARE |
+					 SOF_TIMESTAMPING_SOFTWARE;
+		info->tx_types = BIT(HWTSTAMP_TX_ON) | BIT(HWTSTAMP_TX_OFF);
+		info->rx_filters = BIT(HWTSTAMP_FILTER_ALL) |
+				   BIT(HWTSTAMP_FILTER_NONE);
 	}
-#ifdef PFE_CFG_PFE_MASTER
-	else {
-	info->so_timestamping |= (SOF_TIMESTAMPING_TX_HARDWARE |
-				  SOF_TIMESTAMPING_RX_HARDWARE |
-				  SOF_TIMESTAMPING_RAW_HARDWARE|
-				  SOF_TIMESTAMPING_TX_SOFTWARE |
-				  SOF_TIMESTAMPING_RX_SOFTWARE |
-				  SOF_TIMESTAMPING_SOFTWARE);
-
-	info->tx_types = BIT(HWTSTAMP_TX_ON) | BIT(HWTSTAMP_TX_OFF);
-
-	info->rx_filters = BIT(HWTSTAMP_FILTER_ALL) |
-			   BIT(HWTSTAMP_FILTER_NONE);
-	}
-#endif
+
 	return 0;
 }
 
diff --git a/sw/linux-pfeng/pfeng-netif.c b/sw/linux-pfeng/pfeng-netif.c
index 8a26ffb..96565ac 100644
--- a/sw/linux-pfeng/pfeng-netif.c
+++ b/sw/linux-pfeng/pfeng-netif.c
@@ -12,6 +12,7 @@
 #include <linux/if_vlan.h>
 #include <linux/tcp.h>
 #include <linux/udp.h>
+#include <net/dsa.h>
 
 #include "pfe_cfg.h"
 #include "oal.h"
@@ -31,24 +32,6 @@ typedef struct
 	pfe_drv_id_t owner;		/* Identification of the driver that owns this entry */
 } pfeng_netif_mac_db_list_entry_t;
 
-static bool pfeng_netif_is_aux(struct pfeng_netif *netif)
-{
-	return netif->cfg->aux;
-}
-
-static struct pfeng_emac *__pfeng_netif_get_emac(struct pfeng_netif *netif)
-{
-	return &netif->priv->emac[netif->cfg->emac_id];
-}
-
-static struct pfeng_emac *pfeng_netif_get_emac(struct pfeng_netif *netif)
-{
-	if (pfeng_netif_is_aux(netif))
-		return NULL;
-
-	return __pfeng_netif_get_emac(netif);
-}
-
 static pfe_log_if_t *pfeng_netif_get_emac_logif(struct pfeng_netif *netif)
 {
 	if (pfeng_netif_is_aux(netif))
@@ -434,26 +417,20 @@ static int pfeng_netif_logif_change_mtu(struct net_device *netdev, int mtu)
 static int pfeng_netif_logif_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
 {
 	struct pfeng_netif *netif = netdev_priv(netdev);
-	int ret = -EOPNOTSUPP;
 
-	if (!netif_running(netdev))
-		return -EINVAL;
-
-	switch (cmd) {
-	case SIOCGMIIPHY:
-	case SIOCGMIIREG:
-	case SIOCSMIIREG:
-		ret = phylink_mii_ioctl(netif->phylink, rq, cmd);
-		break;
-	case SIOCSHWTSTAMP:
-		return pfeng_hwts_ioctl_set(netif, rq);
-	case SIOCGHWTSTAMP:
-		return pfeng_hwts_ioctl_get(netif, rq);
-	default:
-		break;
+	if (!phy_has_hwtstamp(netdev->phydev)) {
+		switch (cmd) {
+		case SIOCSHWTSTAMP:
+			return pfeng_hwts_ioctl_set(netif, rq);
+		case SIOCGHWTSTAMP:
+			return pfeng_hwts_ioctl_get(netif, rq);
+		}
 	}
 
-	return ret;
+	if (!netif->phylink)
+		return -EOPNOTSUPP;
+
+	return phylink_mii_ioctl(netif->phylink, rq, cmd);
 }
 
 #ifdef PFE_CFG_PFE_MASTER
@@ -739,6 +716,11 @@ static void pfeng_netif_logif_remove(struct pfeng_netif *netif)
 	if (!netif->netdev)
 		return;
 
+	if (netif->priv->lower_ndev) {
+		unregister_netdevice_notifier(&netif->priv->upper_notifier);
+		netif->priv->lower_ndev = NULL;
+	}
+
 	unregister_netdev(netif->netdev); /* calls ndo_stop */
 
 #ifdef PFE_CFG_PFE_SLAVE
@@ -1000,6 +982,77 @@ err:
 }
 #endif /* PFE_CFG_PFE_SLAVE */
 
+#ifdef PFE_CFG_PFE_MASTER
+static int pfeng_netif_event(struct notifier_block *nb,
+			     unsigned long event, void *ptr)
+{
+	struct net_device *ndev = netdev_notifier_info_to_dev(ptr);
+	struct netdev_notifier_changeupper_info *info = ptr;
+	struct pfeng_priv *priv;
+	int ret = 0;
+
+	priv = container_of(nb, struct pfeng_priv, upper_notifier);
+	if (priv->lower_ndev != ndev)
+		return NOTIFY_DONE;
+
+	switch (event) {
+	case NETDEV_CHANGEUPPER:
+		if (info->linking) {
+			struct pfeng_netif *netif = netdev_priv(ndev);
+			struct pfeng_emac *emac = pfeng_netif_get_emac(netif);
+
+			if (!emac->rx_clk_pending)
+				goto out;
+
+			ret = clk_prepare_enable(emac->rx_clk);
+			if (ret) {
+				dev_err(netif->dev, "Failed to enable RX clock on EMAC%d for interface %s (err %d)\n",
+					netif->cfg->emac_id, phy_modes(emac->intf_mode), ret);
+				goto out;
+			}
+
+			emac->rx_clk_pending = false;
+
+			dev_info(netif->dev, "RX clock on EMAC%d for interface %s installed\n",
+				 netif->cfg->emac_id, phy_modes(emac->intf_mode));
+		}
+
+		break;
+	}
+
+out:
+	return notifier_from_errno(ret);
+}
+
+static int pfeng_netif_register_dsa_notifier(struct pfeng_netif *netif)
+{
+	struct pfeng_emac *emac = pfeng_netif_get_emac(netif);
+	struct pfeng_priv *priv = netif->priv;
+	int ret;
+
+	if (emac && emac->rx_clk_pending) {
+		if (!priv->lower_ndev) {
+			priv->upper_notifier.notifier_call = pfeng_netif_event;
+
+			ret = register_netdevice_notifier(&priv->upper_notifier);
+			if (ret) {
+				dev_err(netif->dev, "Error registering the DSA notifier\n");
+				return ret;
+			}
+
+			priv->lower_ndev = netif->netdev;
+
+		} else {
+			dev_warn(netif->dev, "DSA master notifier already registered\n");
+		}
+	}
+
+	return 0;
+}
+#else
+#define pfeng_netif_register_dsa_notifier(netif) 0
+#endif
+
 static struct pfeng_netif *pfeng_netif_logif_create(struct pfeng_priv *priv, struct pfeng_netif_cfg *netif_cfg)
 {
 	struct device *dev = &priv->pdev->dev;
@@ -1066,6 +1119,12 @@ static struct pfeng_netif *pfeng_netif_logif_create(struct pfeng_priv *priv, str
 	netdev->priv_flags |= IFF_UNICAST_FLT;
 #endif
 
+	ret = pfeng_netif_register_dsa_notifier(netif);
+	if (ret) {
+		dev_err(dev, "Error registering the DSA notifier: %d\n", ret);
+		goto err_netdev_reg;
+	}
+
 	ret = register_netdev(netdev);
 	if (ret) {
 		dev_err(dev, "Error registering the device: %d\n", ret);
diff --git a/sw/linux-pfeng/pfeng-phylink.c b/sw/linux-pfeng/pfeng-phylink.c
index 09ee24d..d34abca 100644
--- a/sw/linux-pfeng/pfeng-phylink.c
+++ b/sw/linux-pfeng/pfeng-phylink.c
@@ -18,7 +18,6 @@
 #include "pfe_emac.h"
 #include "pfeng.h"
 
-#define MAC_PHYIF_CTRL_STATUS	0xF8
 #define EMAC_CLK_RATE_325M	325000000	/* 325MHz */
 #define EMAC_CLK_RATE_125M	125000000	/* 125MHz */
 #define EMAC_CLK_RATE_25M	25000000	/* 25MHz */
@@ -77,8 +76,7 @@ static void pfeng_cfg_to_plat(struct pfeng_netif *netif, const struct phylink_li
 	}
 }
 
-#if !defined(PFENG_CFG_LINUX_NO_SERDES_SUPPORT)
-/* This is done automatically in phylink in 5.10 */
+/* This could be done automatically in phylink in 5.10+ */
 void pfeng_xpcs_poll(struct work_struct * work) {
 	struct pfeng_netif *netif = container_of(work, struct pfeng_netif, xpcs_poll_work.work);
 	struct pfeng_emac *emac  = &netif->priv->emac[netif->cfg->emac_id];
@@ -94,7 +92,6 @@ void pfeng_xpcs_poll(struct work_struct * work) {
 
 	schedule_delayed_work(&netif->xpcs_poll_work, msecs_to_jiffies(XPCS_POLL_MS));
 }
-#endif /* PFENG_CFG_LINUX_NO_SERDES_SUPPORT */
 
 /**
  * @brief	Validate and update the link configuration
@@ -106,9 +103,7 @@ static void pfeng_phylink_validate(struct phylink_config *config, unsigned long
 	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
 	__ETHTOOL_DECLARE_LINK_MODE_MASK(mac_supported) = { 0, };
 	int max_speed = priv->emac[netif->cfg->emac_id].max_speed;
-#if !defined(PFENG_CFG_LINUX_NO_SERDES_SUPPORT)
 	int an_serdes_speed = priv->emac[netif->cfg->emac_id].serdes_an_speed;
-#endif /* PFENG_CFG_LINUX_NO_SERDES_SUPPORT */
 
 	/* We only support SGMII and R/G/MII modes */
 	if (state->interface != PHY_INTERFACE_MODE_NA &&
@@ -147,7 +142,6 @@ static void pfeng_phylink_validate(struct phylink_config *config, unsigned long
 		phylink_set(mac_supported, 2500baseX_Full);
 	}
 
-#if !defined(PFENG_CFG_LINUX_NO_SERDES_SUPPORT)
 	/* SGMII AN can't distinguish between 1G and 2.5G */
 	if (state->interface == PHY_INTERFACE_MODE_SGMII &&
 	    priv->emac[netif->cfg->emac_id].link_an == MLO_AN_INBAND) {
@@ -164,13 +158,10 @@ static void pfeng_phylink_validate(struct phylink_config *config, unsigned long
 			phylink_set(mask, 2500baseT_Full);
 			phylink_set(mask, 2500baseX_Full);
 		}
-	} else
-#endif /* PFENG_CFG_LINUX_NO_SERDES_SUPPORT */
-	if (priv->emac[netif->cfg->emac_id].link_an == MLO_AN_FIXED) {
+	} else if (priv->emac[netif->cfg->emac_id].link_an == MLO_AN_FIXED) {
 		phylink_clear(mac_supported, Autoneg);
 	}
 
-
 	phylink_set(mac_supported, MII);
 	phylink_set_port_modes(mac_supported);
 
@@ -194,7 +185,6 @@ static int _pfeng_mac_link_state(struct phylink_config *config, struct phylink_l
 
 	state->interface = emac->intf_mode;
 
-#if !defined(PFENG_CFG_LINUX_NO_SERDES_SUPPORT)
 	if (state->interface != PHY_INTERFACE_MODE_SGMII || !emac->xpcs) {
 		netdev_err(netif->netdev, "Configuration not supported\n");
 		return -ENOTSUPP;
@@ -210,9 +200,6 @@ static int _pfeng_mac_link_state(struct phylink_config *config, struct phylink_l
 	}
 
 	return 0;
-#else
-	return -ENOTSUPP;
-#endif /* PFENG_CFG_LINUX_NO_SERDES_SUPPORT */
 }
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5,5,0)
@@ -273,16 +260,11 @@ static void pfeng_mac_config(struct phylink_config *config, unsigned int mode, c
 	struct pfeng_emac *emac = &netif->priv->emac[netif->cfg->emac_id];
 	__maybe_unused struct phylink_link_state sgmii_state = { 0 };
 
-	if (state->speed == emac->speed &&
-	    state->duplex == emac->duplex)
-		return;
-
 	if (mode == MLO_AN_FIXED || mode == MLO_AN_PHY) {
 		if (phy_interface_mode_is_rgmii(emac->intf_mode)) {
 			if (s32g_set_rgmii_speed(netif, state->speed))
 				return;
 		} else if  (emac->intf_mode == PHY_INTERFACE_MODE_SGMII) {
-#if !defined(PFENG_CFG_LINUX_NO_SERDES_SUPPORT)
 			if (!emac->xpcs || !emac->xpcs_ops)
 				return;
 
@@ -291,14 +273,10 @@ static void pfeng_mac_config(struct phylink_config *config, unsigned int mode, c
 			sgmii_state.duplex = state->duplex;
 			sgmii_state.an_enabled = false;
 			emac->xpcs_ops->xpcs_config(emac->xpcs, &sgmii_state);
-#else
-			return;
-#endif /* PFENG_CFG_LINUX_NO_SERDES_SUPPORT */
 		} else {
 			netdev_err(netif->netdev, "Interface not supported\n");
 			return;
 		}
-#if !defined(PFENG_CFG_LINUX_NO_SERDES_SUPPORT)
 	} else if (mode == MLO_AN_INBAND) {
 		if (emac->intf_mode == PHY_INTERFACE_MODE_SGMII &&
 		    emac->xpcs && emac->xpcs_ops) {
@@ -307,7 +285,6 @@ static void pfeng_mac_config(struct phylink_config *config, unsigned int mode, c
 			netdev_err(netif->netdev, "Interface not supported\n");
 			return;
 		}
-#endif /* PFENG_CFG_LINUX_NO_SERDES_SUPPORT */
 	} else {
 		return;
 	}
@@ -377,7 +354,6 @@ int pfeng_phylink_create(struct pfeng_netif *netif)
 
 	netif->phylink = phylink;
 
-#if !defined(PFENG_CFG_LINUX_NO_SERDES_SUPPORT)
 	INIT_DELAYED_WORK(&netif->xpcs_poll_work, pfeng_xpcs_poll);
 
 	/* Get XPCS instance */
@@ -399,7 +375,7 @@ int pfeng_phylink_create(struct pfeng_netif *netif)
 			emac->xpcs = NULL;
 		}
 	}
-#endif /* PFENG_CFG_LINUX_NO_SERDES_SUPPORT */
+
 	return 0;
 }
 
@@ -415,10 +391,8 @@ int pfeng_phylink_start(struct pfeng_netif *netif)
 
 	phylink_start(netif->phylink);
 
-#if !defined(PFENG_CFG_LINUX_NO_SERDES_SUPPORT)
 	if (emac->xpcs && emac->xpcs_ops && emac->phyless)
 		schedule_delayed_work(&netif->xpcs_poll_work, msecs_to_jiffies(XPCS_POLL_MS));
-#endif /* PFENG_CFG_LINUX_NO_SERDES_SUPPORT */
 
 	return 0;
 }
@@ -471,10 +445,8 @@ void pfeng_phylink_stop(struct pfeng_netif *netif)
 
 	phylink_stop(netif->phylink);
 
-#if !defined(PFENG_CFG_LINUX_NO_SERDES_SUPPORT)
 	if (emac->xpcs && emac->xpcs_ops && emac->phyless)
 		cancel_delayed_work_sync(&netif->xpcs_poll_work);
-#endif /* PFENG_CFG_LINUX_NO_SERDES_SUPPORT */
 }
 
 /**
@@ -488,8 +460,6 @@ void pfeng_phylink_destroy(struct pfeng_netif *netif)
 	phylink_destroy(netif->phylink);
 	netif->phylink = NULL;
 
-#if !defined(PFENG_CFG_LINUX_NO_SERDES_SUPPORT)
 	if (emac->serdes_phy)
 		phy_exit(emac->serdes_phy);
-#endif
 }
diff --git a/sw/linux-pfeng/pfeng.h b/sw/linux-pfeng/pfeng.h
index 66f84b6..ba1ef84 100644
--- a/sw/linux-pfeng/pfeng.h
+++ b/sw/linux-pfeng/pfeng.h
@@ -20,10 +20,8 @@
 #include <linux/kfifo.h>
 #include <linux/mutex.h>
 #include <linux/clk.h>
-#if !defined(PFENG_CFG_LINUX_NO_SERDES_SUPPORT)
 #include <linux/pcs/fsl-s32gen1-xpcs.h>
 #include <linux/phy/phy.h>
-#endif /* PFENG_CFG_LINUX_NO_SERDES_SUPPORT */
 #include "pfe_cfg.h"
 #include "oal.h"
 #include "bpool.h"
@@ -39,7 +37,7 @@
 #else
 #error Incorrect configuration!
 #endif
-#define PFENG_DRIVER_VERSION		"RTM 1.0.0 RC2"
+#define PFENG_DRIVER_VERSION		"RTM 1.0.0 RC3"
 
 #define PFENG_FW_CLASS_NAME		"s32g_pfe_class.fw"
 #define PFENG_FW_UTIL_NAME		"s32g_pfe_util.fw"
@@ -224,7 +222,8 @@ struct pfeng_hif_chnl {
 static inline struct pfeng_netif *pfeng_phy_if_id_to_netif(struct pfeng_hif_chnl *chnl,
 							   pfe_ct_phy_if_id_t phy_if_id)
 {
-	if (likely(phy_if_id >= PFE_PHY_IF_ID_EMAC0 && phy_if_id <= PFE_PHY_IF_ID_EMAC2)) {
+	if (likely((phy_if_id >= PFE_PHY_IF_ID_EMAC0 && phy_if_id <= PFE_PHY_IF_ID_EMAC2) &&
+		chnl->netifs[phy_if_id - PFE_PHY_IF_ID_EMAC0])) {
 		return chnl->netifs[phy_if_id - PFE_PHY_IF_ID_EMAC0];
 	}
 
@@ -257,9 +256,9 @@ struct pfeng_emac {
 	u32				duplex;
 	bool				enabled;
 	bool				phyless;
+	bool				rx_clk_pending;
 	struct device_node		*dn_mdio;
 	struct mii_bus			*mii_bus;
-#if !defined(PFENG_CFG_LINUX_NO_SERDES_SUPPORT)
 	/* XPCS */
 	struct phy			*serdes_phy;
 	struct s32gen1_xpcs		*xpcs;
@@ -267,7 +266,6 @@ struct pfeng_emac {
 	struct phylink_link_state 	xpcs_link;
 	u32				serdes_an_speed;
 	bool				sgmii_link;
-#endif /* PFENG_CFG_LINUX_NO_SERDES_SUPPORT */
 
 	pfe_phy_if_t			*phyif_emac;
 	pfe_log_if_t			*logif_emac;
@@ -303,6 +301,8 @@ struct pfeng_priv {
 	u8				local_drv_id;
 	bool				in_suspend;
 
+	struct notifier_block		upper_notifier;
+	struct net_device		*lower_ndev;
 	pfe_platform_t			*pfe_platform;
 	pfe_platform_config_t		*pfe_cfg;
 	const char			*fw_class_name;
@@ -311,6 +311,24 @@ struct pfeng_priv {
 	u32				msg_verbosity;
 };
 
+static inline bool pfeng_netif_is_aux(struct pfeng_netif *netif)
+{
+	return netif->cfg->aux;
+}
+
+static inline struct pfeng_emac *__pfeng_netif_get_emac(struct pfeng_netif *netif)
+{
+	return &netif->priv->emac[netif->cfg->emac_id];
+}
+
+static inline struct pfeng_emac *pfeng_netif_get_emac(struct pfeng_netif *netif)
+{
+	if (pfeng_netif_is_aux(netif))
+		return NULL;
+
+	return __pfeng_netif_get_emac(netif);
+}
+
 /* fw */
 int pfeng_fw_load(struct pfeng_priv *priv, const char *fw_class_name, const char *fw_util_name);
 void pfeng_fw_free(struct pfeng_priv *priv);
diff --git a/sw/oal/src/oal_mm_linux.c b/sw/oal/src/oal_mm_linux.c
index 10783c6..91a5be9 100644
--- a/sw/oal/src/oal_mm_linux.c
+++ b/sw/oal/src/oal_mm_linux.c
@@ -181,7 +181,7 @@ static void __oal_mm_dma_free_htable(struct pfe_kmem *hnode)
 		dma_free_coherent(__dev, hnode->size, hnode->addr, hnode->dma_addr);
 }
 
-static void *__oal_mm_kmalloc_htable(const addr_t size)
+static void *__oal_mm_kmalloc_htable(const addr_t size, const uint32_t align)
 {
 	struct pfe_kmem *hnode;
 	void *vaddr;
@@ -190,6 +190,20 @@ static void *__oal_mm_kmalloc_htable(const addr_t size)
 	if (!vaddr)
 		return NULL;
 
+	/* Check that requested alignment matches what kmalloc provides.
+	 *
+	 * From kmalloc documentation:
+	 * The allocated object address is aligned to at least ARCH_KMALLOC_MINALIGN
+	 * bytes (128B on AMR64). For @size of power of two bytes, the alignment is also
+	 * guaranteed to be at least to the size.
+	 */
+	if (align && !IS_ALIGNED((unsigned long) vaddr, align)) {
+		NXP_LOG_ERROR("Requested allocation of size: 0x%llx not aligned to: 0x%x\n",
+			      size, align);
+		kfree(vaddr);
+		return NULL;
+	}
+
 	hnode = kzalloc(sizeof(struct pfe_kmem), GFP_KERNEL);
 	if (!hnode) {
 		kfree(vaddr);
@@ -271,7 +285,7 @@ static void *__oal_mm_reserved_nomap_mem_alloc_htable(struct pfe_reserved_mem *r
 {
 	struct pfe_kmem *hnode;
 
-	if (!IS_ALIGNED(res_mem->map_start_pa, align)) {
+	if (align && !IS_ALIGNED(res_mem->map_start_pa, align)) {
 		NXP_LOG_ERROR("%s reserved mem region addr not aligned\n", res_mem->name);
 		return NULL;
 	}
@@ -322,12 +336,7 @@ void *oal_mm_malloc_contig_aligned_nocache(const addr_t size, const uint32_t ali
  */
 void *oal_mm_malloc_contig_aligned_cache(const addr_t size, const uint32_t align)
 {
-	/* All kmalloc memory is automatically aligned to at least 128B(or higher power of two) on arm64. */
-	if (align && (ARCH_KMALLOC_MINALIGN % align)) {
-		NXP_LOG_ERROR("Alignment not supported\n");
-		return NULL;
-	}
-	return __oal_mm_kmalloc_htable(size);
+	return __oal_mm_kmalloc_htable(size, align);
 }
 
 /**
@@ -358,12 +367,7 @@ default_alloc:
  */
 void *oal_mm_malloc_contig_named_aligned_cache(const char_t *pool, const addr_t size, const uint32_t align)
 {
-	/* All kmalloc memory is automatically aligned to at least 128B(or higher power of two) on arm64. */
-	if (align && (ARCH_KMALLOC_MINALIGN % align)) {
-		NXP_LOG_ERROR("Alignment not supported\n");
-		return NULL;
-	}
-	return __oal_mm_kmalloc_htable(size);
+	return __oal_mm_kmalloc_htable(size, align);
 }
 
 void *oal_mm_virt_to_phys_contig(void *vaddr)
@@ -553,9 +557,7 @@ out:
 
 	return 0;
 }
-#endif /* PFE_CFG_PFE_MASTER */
 
-#if defined(PFE_CFG_PFE_MASTER) || defined(PFE_CFG_LINUX_RES_MEM_ENABLE)
 static int pfeng_reserved_bdr_pool_region_init(struct device *dev, struct gen_pool **pool_alloc, int rmem_idx)
 {
 	struct device_node *mem_node;
@@ -642,37 +644,14 @@ static int pfeng_reserved_dma_shared_pool_region_init(struct device *dev, int *r
 	return 0;
 }
 
-static void pfeng_reserved_dma_shared_pool_region_release(struct device *dev)
-{
-	of_reserved_mem_device_release(dev);
-}
-#else
-static int pfeng_reserved_bdr_pool_region_init(struct device *dev, struct gen_pool **pool_alloc, int rmem_idx)
+static errno_t __oal_mm_init_master(struct device *dev)
 {
-	dev_info(dev, "shared-dma-pool reserved region skipped\n");
-	return 0;
-}
-
-static int pfeng_reserved_dma_shared_pool_region_init(struct device *dev, int *rmem_idx)
-{
-	dev_info(dev, "pfe-bdr-pool reserved region skipped\n"); 
-	return 0;
-}
-
-#define pfeng_reserved_dma_shared_pool_region_release(dev) NULL
-
-#endif
-
-errno_t oal_mm_init(const void *devh)
-{
-	struct device *dev = (struct device *)devh;
 	struct pfe_reserved_mem *pfe_res_mem;
 	struct gen_pool *pool_alloc = NULL;
 	struct reserved_mem *rmem[PFE_REG_COUNT] = {NULL, NULL};
 	int rmem_idx = 0, i;
 	int ret;
 
-#ifdef PFE_CFG_PFE_MASTER
 	/* BMU2 and RT regions are required by MASTER only */
 	for (i = 0; i < PFE_REG_COUNT; i++) {
 		ret = pfeng_reserved_no_map_region_init(dev, &rmem[i], i, &rmem_idx);
@@ -682,7 +661,6 @@ errno_t oal_mm_init(const void *devh)
 			return ret;
 		}
 	}
-#endif /* PFE_CFG_PFE_MASTER */
 
 	ret = pfeng_reserved_dma_shared_pool_region_init(dev, &rmem_idx);
 	if (ret) {
@@ -727,30 +705,54 @@ errno_t oal_mm_init(const void *devh)
 		list_add(&pfe_res_mem->node, &pfe_reserved_mem_list);
 	}
 
-	__dev = dev;
-
-	hash_init(pfe_addr_htable);
-
-	return EOK;
+	return 0;
 
 err_bdr_pool_region_init:
 err_alloc:
-	pfeng_reserved_dma_shared_pool_region_release(dev);
+	of_reserved_mem_device_release(dev);
 
 	return ret;
 }
 
-void oal_mm_shutdown(void)
+static void __oal_mm_shutdown_master(struct device *dev)
 {
-	pfeng_reserved_dma_shared_pool_region_release(__dev);
+	of_reserved_mem_device_release(dev);
+
 	/* reserved_mem list nodes will be released by devm_ */
 	INIT_LIST_HEAD(&pfe_reserved_mem_list);
+}
+
+#else
+#define __oal_mm_init_master(dev) 0
+#define __oal_mm_shutdown_master(dev) NULL
+#endif /* PFE_CFG_PFE_MASTER */
+
+errno_t oal_mm_init(const void *devh)
+{
+	struct device *dev = (struct device *)devh;
+	int ret;
+
+	ret = __oal_mm_init_master(dev);
+	if (ret)
+		return ret;
+
+	__dev = dev;
+
+	hash_init(pfe_addr_htable);
+
+	return EOK;
+}
+
+void oal_mm_shutdown(void)
+{
+	__oal_mm_shutdown_master(__dev);
 
-	__dev = NULL;
 	if (!hash_empty(pfe_addr_htable)) {
-		NXP_LOG_ERROR("Unfreed memory detected\n");
+		dev_warn(__dev, "Unfreed memory detected\n");
 	}
 
+	__dev = NULL;
+
 	return;
 }
 
diff --git a/sw/pfe_hif_drv/public/pfe_hif_drv.h b/sw/pfe_hif_drv/public/pfe_hif_drv.h
index ca2953b..02fad32 100644
--- a/sw/pfe_hif_drv/public/pfe_hif_drv.h
+++ b/sw/pfe_hif_drv/public/pfe_hif_drv.h
@@ -155,6 +155,14 @@ enum
 #error Impossible configuration
 #endif
 
+#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
+	#define TX_BUF_FRAME_OFFSET ((uint16_t)(sizeof(pfe_ct_hif_tx_hdr_t)) \
+								 + (uint16_t)256U \
+								)
+#else
+	#define TX_BUF_FRAME_OFFSET 0U
+#endif
+
 /**
  * @brief	HIF common RX/TX packet flags
  */
@@ -402,7 +410,23 @@ static inline bool_t pfe_hif_pkt_tcpv6_csum_valid(const pfe_hif_pkt_t *pkt)
 
 	return !!(pkt->flags.specific.rx_flags & HIF_RX_TCPV6_CSUM);
 }
+/**
+ * @brief		Get information that ICMP checksum has been verified by PFE
+ * @param[in]	pkt The packet
+ * @return		TRUE if ICMP checksum has been verified and is valid
+ */
+static inline bool_t pfe_hif_pkt_icmp_csum_valid(const pfe_hif_pkt_t *pkt)
+{
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (unlikely(NULL == pkt))
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		return TRUE;
+	}
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 
+	return !!(pkt->flags.specific.rx_flags & HIF_RX_ICMP_CSUM);
+}
 /**
  * @brief		Get pointer to data buffer
  * @param[in]	pkt The packet
diff --git a/sw/pfe_platform/hw/s32g/pfe_bmu_csr.c b/sw/pfe_platform/hw/s32g/pfe_bmu_csr.c
index 581c94c..ecf39e7 100644
--- a/sw/pfe_platform/hw/s32g/pfe_bmu_csr.c
+++ b/sw/pfe_platform/hw/s32g/pfe_bmu_csr.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2021 NXP
+ *  Copyright 2018-2022 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -169,40 +169,43 @@ void pfe_bmu_cfg_irq_unmask(addr_t base_va)
 void pfe_bmu_cfg_init(addr_t base_va, const pfe_bmu_cfg_t *cfg)
 {
 	uint32_t bmu_buf_size_exp;
+
 	if (unlikely(FALSE == IS_POWER_OF_2(cfg->buf_size)))
 	{
 		NXP_LOG_ERROR("BMU buffer size is not power of 2\n");
-		return;
 	}
-	hal_write32(0U, base_va + BMU_CTRL);
-	hal_write32(0x0U, base_va + BMU_INT_ENABLE);
-	hal_write32(0xffffffffU, base_va + BMU_INT_SRC);
+	else
+	{
+		hal_write32(0U, base_va + BMU_CTRL);
+		hal_write32(0x0U, base_va + BMU_INT_ENABLE);
+		hal_write32(0xffffffffU, base_va + BMU_INT_SRC);
 
-	hal_write32((uint32_t)(cfg->pool_pa & 0xffffffffU), base_va + BMU_UCAST_BASEADDR);
-	hal_write32(cfg->max_buf_cnt & 0xffffU, base_va + BMU_UCAST_CONFIG);
+		hal_write32((uint32_t)(cfg->pool_pa & 0xffffffffU), base_va + BMU_UCAST_BASEADDR);
+		hal_write32(cfg->max_buf_cnt & 0xffffU, base_va + BMU_UCAST_CONFIG);
 
-	for(bmu_buf_size_exp = 0; bmu_buf_size_exp < (sizeof(cfg->buf_size) * 8U); bmu_buf_size_exp++)
-	{
-		if(cfg->buf_size == (1UL << bmu_buf_size_exp))
+		for(bmu_buf_size_exp = 0; bmu_buf_size_exp < (sizeof(cfg->buf_size) * 8U); bmu_buf_size_exp++)
 		{
-			hal_write32(bmu_buf_size_exp & 0xffffU, base_va + BMU_BUF_SIZE);
-			break;
+			if(cfg->buf_size == (1UL << bmu_buf_size_exp))
+			{
+				hal_write32(bmu_buf_size_exp & 0xffffU, base_va + BMU_BUF_SIZE);
+				break;
+			}
 		}
-	}
 
-	/*	Thresholds. 75% of maximum number of available buffers. */
-	hal_write32((cfg->max_buf_cnt * 75U) / 100U, base_va + BMU_THRES);
+		/*	Thresholds. 75% of maximum number of available buffers. */
+		hal_write32((cfg->max_buf_cnt * 75U) / 100U, base_va + BMU_THRES);
 
-	/*	Low Watermark for pause frame generation start 5% of free buffers. */
-	hal_write32((cfg->max_buf_cnt * 5U) / 100U, base_va + BMU_LOW_WATERMARK);
-	/*	High Watermark for pause frame generation stop 10% of free buffers. */
-	hal_write32((cfg->max_buf_cnt * 10U) / 100U, base_va + BMU_HIGH_WATERMARK);
+		/*	Low Watermark for pause frame generation start 5% of free buffers. */
+		hal_write32((cfg->max_buf_cnt * 5U) / 100U, base_va + BMU_LOW_WATERMARK);
+		/*	High Watermark for pause frame generation stop 10% of free buffers. */
+		hal_write32((cfg->max_buf_cnt * 10U) / 100U, base_va + BMU_HIGH_WATERMARK);
 
-	pfe_bmu_cfg_clear_internal_memory(base_va, cfg->int_mem_loc_cnt);
-	pfe_bmu_cfg_clear_buf_cnt_memory(base_va, cfg->buf_mem_loc_cnt);
+		pfe_bmu_cfg_clear_internal_memory(base_va, cfg->int_mem_loc_cnt);
+		pfe_bmu_cfg_clear_buf_cnt_memory(base_va, cfg->buf_mem_loc_cnt);
 
-	/*	Enable BMU interrupts except the global enable bit */
-	hal_write32(0xffffffffU & ~(BMU_INT), base_va + BMU_INT_ENABLE);
+		/*	Enable BMU interrupts except the global enable bit */
+		hal_write32(0xffffffffU & ~(BMU_INT), base_va + BMU_INT_ENABLE);
+	}
 }
 
 /**
@@ -224,13 +227,15 @@ void pfe_bmu_cfg_fini(addr_t base_va)
 errno_t pfe_bmu_cfg_reset(addr_t base_va)
 {
 	uint32_t ii = 0U;
+	errno_t ret = EOK;
 
 	hal_write32(0x2U, base_va + BMU_CTRL);
 	while ((hal_read32(base_va + BMU_CTRL) & 0x2U) != 0U)
 	{
 		if (++ii > 1000U)
 		{
-			return ETIMEDOUT;
+			ret = ETIMEDOUT;
+			break;
 		}
 		else
 		{
@@ -238,7 +243,7 @@ errno_t pfe_bmu_cfg_reset(addr_t base_va)
 		}
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -298,26 +303,27 @@ uint32_t pfe_bmu_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, u
 	if (unlikely(NULL_ADDR == base_va))
 	{
 		NXP_LOG_ERROR("NULL argument received (pfe_bmu_cfg_get_text_stat)\n");
-		return 0U;
+		len = 0U;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if(verb_level >= 10U)
 	{
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "BMU_REM_BUF_CNT     : 0x%x\n", hal_read32(base_va + BMU_REM_BUF_CNT));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "BMU_FREE_ERROR_ADDR : 0x%x\n", hal_read32(base_va + BMU_FREE_ERROR_ADDR));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "BMU_CURR_BUF_CNT    : 0x%x\n", hal_read32(base_va + BMU_CURR_BUF_CNT));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "BMU_DEBUG_BUS       : 0x%x\n", hal_read32(base_va + BMU_DEBUG_BUS));
-	}
+		if(verb_level >= 10U)
+		{
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "BMU_REM_BUF_CNT     : 0x%x\n", hal_read32(base_va + BMU_REM_BUF_CNT));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "BMU_FREE_ERROR_ADDR : 0x%x\n", hal_read32(base_va + BMU_FREE_ERROR_ADDR));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "BMU_CURR_BUF_CNT    : 0x%x\n", hal_read32(base_va + BMU_CURR_BUF_CNT));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "BMU_DEBUG_BUS       : 0x%x\n", hal_read32(base_va + BMU_DEBUG_BUS));
+		}
 
-	if(verb_level >= 9U)
-	{
-		/*	Get version */
-		reg = hal_read32(base_va + BMU_VERSION);
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Revision             : 0x%x\n", (reg >> 24) & 0xffU);
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Version              : 0x%x\n", (reg >> 16) & 0xffU);
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "ID                   : 0x%x\n", reg & 0xffffU);
-	}
+		if(verb_level >= 9U)
+		{
+			/*	Get version */
+			reg = hal_read32(base_va + BMU_VERSION);
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Revision             : 0x%x\n", (reg >> 24) & 0xffU);
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Version              : 0x%x\n", (reg >> 16) & 0xffU);
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "ID                   : 0x%x\n", reg & 0xffffU);
+		}
 		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Buffer Base (uc)     : p0x%x\n", (uint32_t)hal_read32(base_va + BMU_UCAST_BASEADDR));
 		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Buffer Size          : 0x%x\n", 1U << hal_read32(base_va + BMU_BUF_SIZE));
 		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Buffers Remaining    : 0x%x\n", hal_read32(base_va + BMU_REM_BUF_CNT));
@@ -341,5 +347,6 @@ uint32_t pfe_bmu_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, u
 				len += (uint32_t)oal_util_snprintf(buf + len, size - len, "MASTER%02d Count       : 0x%x\n", ii, reg);
 			}
 		}
+	}
 	return len;
 }
diff --git a/sw/pfe_platform/hw/s32g/pfe_class_csr.c b/sw/pfe_platform/hw/s32g/pfe_class_csr.c
index 97aef07..79d3d0b 100644
--- a/sw/pfe_platform/hw/s32g/pfe_class_csr.c
+++ b/sw/pfe_platform/hw/s32g/pfe_class_csr.c
@@ -39,7 +39,7 @@ void pfe_class_cfg_set_config(addr_t base_va, const pfe_class_cfg_t *cfg)
 	hal_write32(0x1U, base_va + CLASS_USE_TMU_INQ);
 	hal_write32(0x1U, base_va + CLASS_PE_SYS_CLK_RATIO);
 	hal_write32(0U, base_va + CLASS_L4_CHKSUM);
-	hal_write32((PFE_CFG_RO_HDR_SIZE << 16) | PFE_CFG_LMEM_HDR_SIZE, base_va + CLASS_HDR_SIZE);
+	hal_write32((cfg->ro_header_size << 16) | cfg->lmem_header_size, base_va + CLASS_HDR_SIZE);
 	hal_write32(PFE_CFG_LMEM_BUF_SIZE, base_va + CLASS_LMEM_BUF_SIZE);
 	hal_write32(CLASS_TPID0_TPID1_VAL, base_va + CLASS_TPID0_TPID1);
 	hal_write32(CLASS_TPID2_VAL, base_va + CLASS_TPID2);
@@ -104,61 +104,76 @@ errno_t pfe_class_cfg_set_rtable(addr_t base_va, addr_t rtable_pa, uint32_t rtab
 {
 	uint8_t ii;
 	uint32_t reg;
+	errno_t ret = EOK;
 
 	if (NULL_ADDR == rtable_pa)
 	{
 		pfe_class_cfg_rtable_lookup_disable(base_va);
-		return EOK;
+		ret = EOK;
 	}
-
-	/* rtable not NULL, add it */
-	if (entry_size > ROUTE_ENTRY_SIZE(0xffffffffu))
+	else
 	{
-		NXP_LOG_ERROR("Entry size exceeds maximum value\n");
-		return EINVAL;
-	}
 
-	/* Validate rtable entry size if route parsing is already enabled. */
-	reg = hal_read32(base_va + CLASS_ROUTE_MULTI);
-	if (0U != (reg & PARSE_ROUTE_EN(TRUE)))
-	{
-		if (entry_size != 128U)
+		/* rtable not NULL, add it */
+		if (entry_size > ROUTE_ENTRY_SIZE(0xffffffffu))
 		{
-			NXP_LOG_ERROR("FATAL: Route table entry length exceeds 128bytes\n");
-			return EINVAL;
+			NXP_LOG_ERROR("Entry size exceeds maximum value\n");
+			ret = EINVAL;
 		}
-	}
-
-	/* Validate that rtable_len is a power of 2 and it's within boundaries. */
-	for (ii=0U; ii<(sizeof(rtable_len) * 8U); ii++)
-	{
-		if (0U != (rtable_len & (1UL << ii)))
+		else
 		{
-			if (0U != (rtable_len & ~(1UL << ii)))
+			/* Validate rtable entry size if route parsing is already enabled. */
+			reg = hal_read32(base_va + CLASS_ROUTE_MULTI);
+			if (0U != (reg & PARSE_ROUTE_EN(TRUE)))
 			{
-				NXP_LOG_ERROR("Routing table length is not a power of 2\n");
-				return EINVAL;
+				if (entry_size != 128U)
+				{
+					NXP_LOG_ERROR("FATAL: Route table entry length exceeds 128bytes\n");
+					ret = EINVAL;
+				}
 			}
 
-			if ((ii < 6U) || (ii > 20U))
+			if (EOK == ret)
 			{
-				NXP_LOG_ERROR("Table length out of boundaries\n");
-				return EINVAL;
+				/* Validate that rtable_len is a power of 2 and it's within boundaries. */
+				for (ii=0U; ii<(sizeof(rtable_len) * 8U); ii++)
+				{
+					if (0U != (rtable_len & (1UL << ii)))
+					{
+						if (0U != (rtable_len & ~(1UL << ii)))
+						{
+							NXP_LOG_ERROR("Routing table length is not a power of 2\n");
+							ret = EINVAL;
+						}
+						else if ((ii < 6U) || (ii > 20U))
+						{
+							NXP_LOG_ERROR("Table length out of boundaries\n");
+							ret = EINVAL;
+						}
+						else
+						{
+							/* Do Nothing */
+						}
+
+						break;
+					}
+				}
+
+				if (EOK == ret)
+				{
+					hal_write32((uint32_t)(rtable_pa & 0xffffffffU), base_va + CLASS_ROUTE_TABLE_BASE);
+					hal_write32(0UL
+								| ROUTE_HASH_SIZE(ii)
+								| ROUTE_ENTRY_SIZE(entry_size)
+								, base_va + CLASS_ROUTE_HASH_ENTRY_SIZE);
+
+					/* Don't enable PARSE_ROUTE_EN here as it will be enabled only when needed later. */
+				}
 			}
-
-			break;
 		}
 	}
 
-	hal_write32((uint32_t)(rtable_pa & 0xffffffffU), base_va + CLASS_ROUTE_TABLE_BASE);
-	hal_write32(0UL
-				| ROUTE_HASH_SIZE(ii)
-				| ROUTE_ENTRY_SIZE(entry_size)
-				, base_va + CLASS_ROUTE_HASH_ENTRY_SIZE);
-
-	/* Don't enable PARSE_ROUTE_EN here as it will be enabled only when needed later. */
-
-	return EOK;
+	return ret;
 }
 
 /**
@@ -195,200 +210,202 @@ uint32_t pfe_class_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size,
 	if (unlikely(NULL_ADDR == base_va))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return 0U;
+		len = 0U;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	/* Debug registers */
-	if(verb_level >= 10U)
 	{
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE0_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE0_DEBUG));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE1_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE1_DEBUG));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE2_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE2_DEBUG));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE3_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE3_DEBUG));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE4_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE4_DEBUG));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE5_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE5_DEBUG));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE6_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE6_DEBUG));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE7_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE7_DEBUG));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_STATE\t0x%x\n", hal_read32(base_va + CLASS_STATE));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_QB_BUF_AVAIL\t0x%x\n", hal_read32(base_va + CLASS_QB_BUF_AVAIL));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_RO_BUF_AVAIL\t0x%x\n", hal_read32(base_va + CLASS_RO_BUF_AVAIL));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_DEBUG_BUS01\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS01));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_DEBUG_BUS23\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS23));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_DEBUG_BUS45\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS45));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_DEBUG_BUS67\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS67));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_DEBUG_BUS89\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS89));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_DEBUG_BUS1011\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS1011));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_DEBUG_BUS12\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS12));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_RX_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_L3_FAIL_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V4_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V6_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_CHKSUM_ERR_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_TTL_ERR_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_RX_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_L3_FAIL_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V4_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V6_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_CHKSUM_ERR_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_TTL_ERR_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_RX_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_L3_FAIL_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V4_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V6_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_CHKSUM_ERR_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_TTL_ERR_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_RX_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_L3_FAIL_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_V4_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_V6_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_CHKSUM_ERR_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_TTL_ERR_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_RX_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_L3_FAIL_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_V4_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_V6_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_CHKSUM_ERR_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_TTL_ERR_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_ICMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_ICMP_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_IGMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_IGMP_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_TCP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_TCP_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_UDP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_UDP_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_ICMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_ICMP_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_IGMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_IGMP_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_TCP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_TCP_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_UDP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_UDP_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_ICMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_ICMP_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_IGMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_IGMP_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_TCP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_TCP_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_UDP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_UDP_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_ICMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_ICMP_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_IGMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_IGMP_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_TCP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_TCP_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_UDP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_UDP_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_RX_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_L3_FAIL_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_V4_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_V6_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_CHKSUM_ERR_PKTS));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_TTL_ERR_PKTS));
-	}
+		/* Debug registers */
+		if(verb_level >= 10U)
+		{
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE0_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE0_DEBUG));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE1_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE1_DEBUG));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE2_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE2_DEBUG));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE3_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE3_DEBUG));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE4_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE4_DEBUG));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE5_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE5_DEBUG));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE6_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE6_DEBUG));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE7_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE7_DEBUG));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_STATE\t0x%x\n", hal_read32(base_va + CLASS_STATE));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_QB_BUF_AVAIL\t0x%x\n", hal_read32(base_va + CLASS_QB_BUF_AVAIL));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_RO_BUF_AVAIL\t0x%x\n", hal_read32(base_va + CLASS_RO_BUF_AVAIL));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_DEBUG_BUS01\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS01));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_DEBUG_BUS23\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS23));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_DEBUG_BUS45\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS45));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_DEBUG_BUS67\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS67));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_DEBUG_BUS89\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS89));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_DEBUG_BUS1011\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS1011));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_DEBUG_BUS12\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS12));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_RX_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_L3_FAIL_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V4_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V6_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_CHKSUM_ERR_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_TTL_ERR_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_RX_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_L3_FAIL_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V4_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V6_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_CHKSUM_ERR_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_TTL_ERR_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_RX_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_L3_FAIL_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V4_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V6_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_CHKSUM_ERR_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_TTL_ERR_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_RX_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_L3_FAIL_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_V4_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_V6_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_CHKSUM_ERR_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_TTL_ERR_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_RX_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_L3_FAIL_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_V4_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_V6_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_CHKSUM_ERR_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_TTL_ERR_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_ICMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_ICMP_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_IGMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_IGMP_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_TCP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_TCP_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_UDP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_UDP_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_ICMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_ICMP_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_IGMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_IGMP_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_TCP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_TCP_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_UDP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_UDP_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_ICMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_ICMP_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_IGMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_IGMP_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_TCP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_TCP_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_UDP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_UDP_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_ICMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_ICMP_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_IGMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_IGMP_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_TCP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_TCP_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_UDP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_UDP_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_RX_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_L3_FAIL_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_V4_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_V6_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_CHKSUM_ERR_PKTS));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_TTL_ERR_PKTS));
+		}
 
-	if(verb_level >= 9U)
-	{
-		/*	Get version */
-		reg = hal_read32(base_va + CLASS_VERSION);
-		len += oal_util_snprintf(buf + len, size - len, "Revision\t0x%x\n", (reg >> 24U) & 0xffU);
-		len += oal_util_snprintf(buf + len, size - len, "Version \t0x%x\n", (reg >> 16U) & 0xffU);
-		len += oal_util_snprintf(buf + len, size - len, "ID      \t0x%x\n", reg & 0xffffU);
+		if(verb_level >= 9U)
+		{
+			/*	Get version */
+			reg = hal_read32(base_va + CLASS_VERSION);
+			len += oal_util_snprintf(buf + len, size - len, "Revision\t0x%x\n", (reg >> 24U) & 0xffU);
+			len += oal_util_snprintf(buf + len, size - len, "Version \t0x%x\n", (reg >> 16U) & 0xffU);
+			len += oal_util_snprintf(buf + len, size - len, "ID      \t0x%x\n", reg & 0xffffU);
+		}
+			/*	CLASS_ROUTE_MULTI */
+			reg = hal_read32(base_va + CLASS_ROUTE_MULTI);
+			len += oal_util_snprintf(buf + len, size - len, "CLASS_ROUTE_MULTI \t0x%x\n", reg);
+
+			/*	CLASS_STATE */
+			reg = hal_read32(base_va + CLASS_STATE);
+			len += oal_util_snprintf(buf + len, size - len, "CLASS_STATE       \t0x%x\n", reg);
+
+			reg = hal_read32(base_va + CLASS_QB_BUF_AVAIL);
+			len += oal_util_snprintf(buf + len, size - len, "CLASS_QB_BUF_AVAIL\t0x%x\n", reg);
+
+			reg = hal_read32(base_va + CLASS_RO_BUF_AVAIL);
+			len += oal_util_snprintf(buf + len, size - len, "CLASS_RO_BUF_AVAIL\t0x%x\n", reg);
+
+			reg = hal_read32(base_va + CLASS_PE0_DEBUG);
+			len += oal_util_snprintf(buf + len, size - len, "PE0 PC\t0x%x\n", reg & 0xffffU);
+			reg = hal_read32(base_va + CLASS_PE1_DEBUG);
+			len += oal_util_snprintf(buf + len, size - len, "PE1 PC\t0x%x\n", reg & 0xffffU);
+			reg = hal_read32(base_va + CLASS_PE2_DEBUG);
+			len += oal_util_snprintf(buf + len, size - len, "PE2 PC\t0x%x\n", reg & 0xffffU);
+			reg = hal_read32(base_va + CLASS_PE3_DEBUG);
+			len += oal_util_snprintf(buf + len, size - len, "PE3 PC\t0x%x\n", reg & 0xffffU);
+			reg = hal_read32(base_va + CLASS_PE4_DEBUG);
+			len += oal_util_snprintf(buf + len, size - len, "PE4 PC\t0x%x\n", reg & 0xffffU);
+			reg = hal_read32(base_va + CLASS_PE5_DEBUG);
+			len += oal_util_snprintf(buf + len, size - len, "PE5 PC\t0x%x\n", reg & 0xffffU);
+			reg = hal_read32(base_va + CLASS_PE6_DEBUG);
+			len += oal_util_snprintf(buf + len, size - len, "PE6 PC\t0x%x\n", reg & 0xffffU);
+			reg = hal_read32(base_va + CLASS_PE7_DEBUG);
+			len += oal_util_snprintf(buf + len, size - len, "PE7 PC\t0x%x\n", reg & 0xffffU);
+
+			/*	Get info per PHY */
+			len += oal_util_snprintf(buf + len, size - len, "[PHY1]\n");
+
+			len += oal_util_snprintf(buf + len, size - len, "RX\t%10u TX\t%10u\nIPV4\t%10u IPV6\t%10u\n",
+					hal_read32(base_va + CLASS_PHY1_RX_PKTS),
+					hal_read32(base_va + CLASS_PHY1_TX_PKTS),
+					hal_read32(base_va + CLASS_PHY1_V4_PKTS),
+					hal_read32(base_va + CLASS_PHY1_V6_PKTS));
+
+			len += oal_util_snprintf(buf + len, size - len, "ICMP\t%10u IGMP\t%10u TCP\t%10u UDP\t%10u\n",
+					hal_read32(base_va + CLASS_PHY1_ICMP_PKTS),
+					hal_read32(base_va + CLASS_PHY1_IGMP_PKTS),
+					hal_read32(base_va + CLASS_PHY1_TCP_PKTS),
+					hal_read32(base_va + CLASS_PHY1_UDP_PKTS));
+
+			len += oal_util_snprintf(buf + len, size - len, "L3 Fail\t%10u CSUM Fail\t%10u TTL Fail\t%10u\n",
+					hal_read32(base_va + CLASS_PHY1_L3_FAIL_PKTS),
+					hal_read32(base_va + CLASS_PHY1_CHKSUM_ERR_PKTS),
+					hal_read32(base_va + CLASS_PHY1_TTL_ERR_PKTS));
+
+			len += oal_util_snprintf(buf + len, size - len, "[PHY2]\n");
+
+			len += oal_util_snprintf(buf + len, size - len, "RX\t%10u TX\t%10u\t IPV4\t%10u IPV6\t%10u\n",
+					hal_read32(base_va + CLASS_PHY2_RX_PKTS),
+					hal_read32(base_va + CLASS_PHY2_TX_PKTS),
+					hal_read32(base_va + CLASS_PHY2_V4_PKTS),
+					hal_read32(base_va + CLASS_PHY2_V6_PKTS));
+
+			len += oal_util_snprintf(buf + len, size - len, "ICMP\t%10u IGMP\t%10u TCP\t%10u UDP\t%10u\n",
+					hal_read32(base_va + CLASS_PHY2_ICMP_PKTS),
+					hal_read32(base_va + CLASS_PHY2_IGMP_PKTS),
+					hal_read32(base_va + CLASS_PHY2_TCP_PKTS),
+					hal_read32(base_va + CLASS_PHY2_UDP_PKTS));
+
+			len += oal_util_snprintf(buf + len, size - len, "L3 Fail\t%10u CSUM Fail\t%10u TTL Fail\t%10u\n",
+					hal_read32(base_va + CLASS_PHY2_L3_FAIL_PKTS),
+					hal_read32(base_va + CLASS_PHY2_CHKSUM_ERR_PKTS),
+					hal_read32(base_va + CLASS_PHY2_TTL_ERR_PKTS));
+
+			len += oal_util_snprintf(buf + len, size - len, "[PHY3]\n");
+
+			len += oal_util_snprintf(buf + len, size - len, "RX\t%10u TX\t%10u\nIPV4\t%10u IPV6\t%10u\n",
+					hal_read32(base_va + CLASS_PHY3_RX_PKTS),
+					hal_read32(base_va + CLASS_PHY3_TX_PKTS),
+					hal_read32(base_va + CLASS_PHY3_V4_PKTS),
+					hal_read32(base_va + CLASS_PHY3_V6_PKTS));
+
+			len += oal_util_snprintf(buf + len, size - len, "ICMP\t%10u IGMP\t%10u TCP\t%10u UDP\t%10u\n",
+					hal_read32(base_va + CLASS_PHY3_ICMP_PKTS),
+					hal_read32(base_va + CLASS_PHY3_IGMP_PKTS),
+					hal_read32(base_va + CLASS_PHY3_TCP_PKTS),
+					hal_read32(base_va + CLASS_PHY3_UDP_PKTS));
+
+			len += oal_util_snprintf(buf + len, size - len, "L3 Fail\t%10u CSUM Fail\t%10u TTL Fail\t%10u\n",
+					hal_read32(base_va + CLASS_PHY3_L3_FAIL_PKTS),
+					hal_read32(base_va + CLASS_PHY3_CHKSUM_ERR_PKTS),
+					hal_read32(base_va + CLASS_PHY3_TTL_ERR_PKTS));
+
+			len += oal_util_snprintf(buf + len, size - len, "[PHY4]\n");
+
+			len += oal_util_snprintf(buf + len, size - len, "RX\t%10u TX\t%10u\nIPV4\t%10u IPV6\t%10u\n",
+					hal_read32(base_va + CLASS_PHY4_RX_PKTS),
+					hal_read32(base_va + CLASS_PHY4_TX_PKTS),
+					hal_read32(base_va + CLASS_PHY4_V4_PKTS),
+					hal_read32(base_va + CLASS_PHY4_V6_PKTS));
+
+			len += oal_util_snprintf(buf + len, size - len, "ICMP\t%10u IGMP\t%10u TCP\t%10u UDP\t%10u\n",
+					hal_read32(base_va + CLASS_PHY4_ICMP_PKTS),
+					hal_read32(base_va + CLASS_PHY4_IGMP_PKTS),
+					hal_read32(base_va + CLASS_PHY4_TCP_PKTS),
+					hal_read32(base_va + CLASS_PHY4_UDP_PKTS));
+
+			len += oal_util_snprintf(buf + len, size - len, "L3 Fail\t%10u CSUM Fail\t%10u TTL Fail\t%10u\n",
+					hal_read32(base_va + CLASS_PHY4_L3_FAIL_PKTS),
+					hal_read32(base_va + CLASS_PHY4_CHKSUM_ERR_PKTS),
+					hal_read32(base_va + CLASS_PHY4_TTL_ERR_PKTS));
 	}
-		/*	CLASS_ROUTE_MULTI */
-		reg = hal_read32(base_va + CLASS_ROUTE_MULTI);
-		len += oal_util_snprintf(buf + len, size - len, "CLASS_ROUTE_MULTI \t0x%x\n", reg);
-
-		/*	CLASS_STATE */
-		reg = hal_read32(base_va + CLASS_STATE);
-		len += oal_util_snprintf(buf + len, size - len, "CLASS_STATE       \t0x%x\n", reg);
-
-		reg = hal_read32(base_va + CLASS_QB_BUF_AVAIL);
-		len += oal_util_snprintf(buf + len, size - len, "CLASS_QB_BUF_AVAIL\t0x%x\n", reg);
-
-		reg = hal_read32(base_va + CLASS_RO_BUF_AVAIL);
-		len += oal_util_snprintf(buf + len, size - len, "CLASS_RO_BUF_AVAIL\t0x%x\n", reg);
-
-		reg = hal_read32(base_va + CLASS_PE0_DEBUG);
-		len += oal_util_snprintf(buf + len, size - len, "PE0 PC\t0x%x\n", reg & 0xffffU);
-		reg = hal_read32(base_va + CLASS_PE1_DEBUG);
-		len += oal_util_snprintf(buf + len, size - len, "PE1 PC\t0x%x\n", reg & 0xffffU);
-		reg = hal_read32(base_va + CLASS_PE2_DEBUG);
-		len += oal_util_snprintf(buf + len, size - len, "PE2 PC\t0x%x\n", reg & 0xffffU);
-		reg = hal_read32(base_va + CLASS_PE3_DEBUG);
-		len += oal_util_snprintf(buf + len, size - len, "PE3 PC\t0x%x\n", reg & 0xffffU);
-		reg = hal_read32(base_va + CLASS_PE4_DEBUG);
-		len += oal_util_snprintf(buf + len, size - len, "PE4 PC\t0x%x\n", reg & 0xffffU);
-		reg = hal_read32(base_va + CLASS_PE5_DEBUG);
-		len += oal_util_snprintf(buf + len, size - len, "PE5 PC\t0x%x\n", reg & 0xffffU);
-		reg = hal_read32(base_va + CLASS_PE6_DEBUG);
-		len += oal_util_snprintf(buf + len, size - len, "PE6 PC\t0x%x\n", reg & 0xffffU);
-		reg = hal_read32(base_va + CLASS_PE7_DEBUG);
-		len += oal_util_snprintf(buf + len, size - len, "PE7 PC\t0x%x\n", reg & 0xffffU);
-
-		/*	Get info per PHY */
-		len += oal_util_snprintf(buf + len, size - len, "[PHY1]\n");
-
-		len += oal_util_snprintf(buf + len, size - len, "RX\t%10u TX\t%10u\nIPV4\t%10u IPV6\t%10u\n",
-				hal_read32(base_va + CLASS_PHY1_RX_PKTS),
-				hal_read32(base_va + CLASS_PHY1_TX_PKTS),
-				hal_read32(base_va + CLASS_PHY1_V4_PKTS),
-				hal_read32(base_va + CLASS_PHY1_V6_PKTS));
-
-		len += oal_util_snprintf(buf + len, size - len, "ICMP\t%10u IGMP\t%10u TCP\t%10u UDP\t%10u\n",
-				hal_read32(base_va + CLASS_PHY1_ICMP_PKTS),
-				hal_read32(base_va + CLASS_PHY1_IGMP_PKTS),
-				hal_read32(base_va + CLASS_PHY1_TCP_PKTS),
-				hal_read32(base_va + CLASS_PHY1_UDP_PKTS));
-
-		len += oal_util_snprintf(buf + len, size - len, "L3 Fail\t%10u CSUM Fail\t%10u TTL Fail\t%10u\n",
-				hal_read32(base_va + CLASS_PHY1_L3_FAIL_PKTS),
-				hal_read32(base_va + CLASS_PHY1_CHKSUM_ERR_PKTS),
-				hal_read32(base_va + CLASS_PHY1_TTL_ERR_PKTS));
-
-		len += oal_util_snprintf(buf + len, size - len, "[PHY2]\n");
-
-		len += oal_util_snprintf(buf + len, size - len, "RX\t%10u TX\t%10u\t IPV4\t%10u IPV6\t%10u\n",
-				hal_read32(base_va + CLASS_PHY2_RX_PKTS),
-				hal_read32(base_va + CLASS_PHY2_TX_PKTS),
-				hal_read32(base_va + CLASS_PHY2_V4_PKTS),
-				hal_read32(base_va + CLASS_PHY2_V6_PKTS));
-
-		len += oal_util_snprintf(buf + len, size - len, "ICMP\t%10u IGMP\t%10u TCP\t%10u UDP\t%10u\n",
-				hal_read32(base_va + CLASS_PHY2_ICMP_PKTS),
-				hal_read32(base_va + CLASS_PHY2_IGMP_PKTS),
-				hal_read32(base_va + CLASS_PHY2_TCP_PKTS),
-				hal_read32(base_va + CLASS_PHY2_UDP_PKTS));
-
-		len += oal_util_snprintf(buf + len, size - len, "L3 Fail\t%10u CSUM Fail\t%10u TTL Fail\t%10u\n",
-				hal_read32(base_va + CLASS_PHY2_L3_FAIL_PKTS),
-				hal_read32(base_va + CLASS_PHY2_CHKSUM_ERR_PKTS),
-				hal_read32(base_va + CLASS_PHY2_TTL_ERR_PKTS));
-
-		len += oal_util_snprintf(buf + len, size - len, "[PHY3]\n");
-
-		len += oal_util_snprintf(buf + len, size - len, "RX\t%10u TX\t%10u\nIPV4\t%10u IPV6\t%10u\n",
-				hal_read32(base_va + CLASS_PHY3_RX_PKTS),
-				hal_read32(base_va + CLASS_PHY3_TX_PKTS),
-				hal_read32(base_va + CLASS_PHY3_V4_PKTS),
-				hal_read32(base_va + CLASS_PHY3_V6_PKTS));
-
-		len += oal_util_snprintf(buf + len, size - len, "ICMP\t%10u IGMP\t%10u TCP\t%10u UDP\t%10u\n",
-				hal_read32(base_va + CLASS_PHY3_ICMP_PKTS),
-				hal_read32(base_va + CLASS_PHY3_IGMP_PKTS),
-				hal_read32(base_va + CLASS_PHY3_TCP_PKTS),
-				hal_read32(base_va + CLASS_PHY3_UDP_PKTS));
-
-		len += oal_util_snprintf(buf + len, size - len, "L3 Fail\t%10u CSUM Fail\t%10u TTL Fail\t%10u\n",
-				hal_read32(base_va + CLASS_PHY3_L3_FAIL_PKTS),
-				hal_read32(base_va + CLASS_PHY3_CHKSUM_ERR_PKTS),
-				hal_read32(base_va + CLASS_PHY3_TTL_ERR_PKTS));
-
-		len += oal_util_snprintf(buf + len, size - len, "[PHY4]\n");
-
-		len += oal_util_snprintf(buf + len, size - len, "RX\t%10u TX\t%10u\nIPV4\t%10u IPV6\t%10u\n",
-				hal_read32(base_va + CLASS_PHY4_RX_PKTS),
-				hal_read32(base_va + CLASS_PHY4_TX_PKTS),
-				hal_read32(base_va + CLASS_PHY4_V4_PKTS),
-				hal_read32(base_va + CLASS_PHY4_V6_PKTS));
-
-		len += oal_util_snprintf(buf + len, size - len, "ICMP\t%10u IGMP\t%10u TCP\t%10u UDP\t%10u\n",
-				hal_read32(base_va + CLASS_PHY4_ICMP_PKTS),
-				hal_read32(base_va + CLASS_PHY4_IGMP_PKTS),
-				hal_read32(base_va + CLASS_PHY4_TCP_PKTS),
-				hal_read32(base_va + CLASS_PHY4_UDP_PKTS));
-
-		len += oal_util_snprintf(buf + len, size - len, "L3 Fail\t%10u CSUM Fail\t%10u TTL Fail\t%10u\n",
-				hal_read32(base_va + CLASS_PHY4_L3_FAIL_PKTS),
-				hal_read32(base_va + CLASS_PHY4_CHKSUM_ERR_PKTS),
-				hal_read32(base_va + CLASS_PHY4_TTL_ERR_PKTS));
 
 	return len;
 }
diff --git a/sw/pfe_platform/hw/s32g/pfe_emac_csr.c b/sw/pfe_platform/hw/s32g/pfe_emac_csr.c
index 5ebb706..95fcc2c 100644
--- a/sw/pfe_platform/hw/s32g/pfe_emac_csr.c
+++ b/sw/pfe_platform/hw/s32g/pfe_emac_csr.c
@@ -12,6 +12,7 @@
 #include "hal.h"
 #include "pfe_cbus.h"
 #include "pfe_emac_csr.h"
+#include "pfe_feature_mgr.h"
 
 static inline uint32_t reverse_bits_32(uint32_t u32Data)
 {
@@ -130,6 +131,7 @@ errno_t pfe_emac_cfg_init(addr_t base_va, pfe_emac_mii_mode_t mode,
 							pfe_emac_speed_t speed, pfe_emac_duplex_t duplex)
 {
 	uint32_t reg;
+	errno_t ret;
 
 	hal_write32(0U, base_va + MAC_CONFIGURATION);
 	hal_write32(0x8000ffeeU, base_va + MAC_ADDRESS0_HIGH);
@@ -159,40 +161,56 @@ errno_t pfe_emac_cfg_init(addr_t base_va, pfe_emac_mii_mode_t mode,
 	hal_write32(0xffffffffU, base_va + MMC_RX_INTERRUPT_MASK);
 	hal_write32(0xffffffffU, base_va + MMC_TX_INTERRUPT_MASK);
 	hal_write32(0xffffffffU, base_va + MMC_IPC_RX_INTERRUPT_MASK);
-	hal_write32(0U
-			| ARP_OFFLOAD_ENABLE(0U)
-			| SA_INSERT_REPLACE_CONTROL(CTRL_BY_SIGNALS)
-			| CHECKSUM_OFFLOAD(1U)
-			| INTER_PACKET_GAP(0U)
-			| GIANT_PACKET_LIMIT_CONTROL(1U)
-			| SUPPORT_2K_PACKETS(0U)
-			| CRC_STRIPPING_FOR_TYPE(1U)
-			| AUTO_PAD_OR_CRC_STRIPPING(1U)
-			| WATCHDOG_DISABLE(1U)
-			| PACKET_BURST_ENABLE(0U)
-			| JABBER_DISABLE(1U)
-			| JUMBO_PACKET_ENABLE(0U)
-			| PORT_SELECT(0U)		/* To be set up by pfe_emac_cfg_set_speed() */
-			| SPEED(0U)				/* To be set up by pfe_emac_cfg_set_speed() */
-			| DUPLEX_MODE(1U)		/* To be set up by pfe_emac_cfg_set_duplex() */
-			| LOOPBACK_MODE(0U)
-			| CARRIER_SENSE_BEFORE_TX(0U)
-			| DISABLE_RECEIVE_OWN(0)
-			| DISABLE_CARRIER_SENSE_TX(0U)
-			| DISABLE_RETRY(0U)
-			| BACK_OFF_LIMIT(MIN_N_10)
-			| DEFERRAL_CHECK(0U)
-			| PREAMBLE_LENGTH_TX(PREAMBLE_7B)
-			| TRANSMITTER_ENABLE(0U)
-			| RECEIVER_ENABLE(0U)
-			, base_va + MAC_CONFIGURATION);
+
+	reg = 0U | ARP_OFFLOAD_ENABLE(0U)
+                 | SA_INSERT_REPLACE_CONTROL(CTRL_BY_SIGNALS)
+                 | CHECKSUM_OFFLOAD(1U)
+                 | INTER_PACKET_GAP(0U)
+                 | GIANT_PACKET_LIMIT_CONTROL(1U)
+                 | SUPPORT_2K_PACKETS(0U)
+                 | CRC_STRIPPING_FOR_TYPE(1U)
+                 | AUTO_PAD_OR_CRC_STRIPPING(1U)
+                 | WATCHDOG_DISABLE(1U)
+                 | PACKET_BURST_ENABLE(0U)
+                 | JABBER_DISABLE(1U)
+                 | PORT_SELECT(0U)               /* To be set up by pfe_emac_cfg_set_speed() */
+                 | SPEED(0U)                             /* To be set up by pfe_emac_cfg_set_speed() */
+                 | DUPLEX_MODE(1U)               /* To be set up by pfe_emac_cfg_set_duplex() */
+                 | LOOPBACK_MODE(0U)
+                 | CARRIER_SENSE_BEFORE_TX(0U)
+                 | DISABLE_RECEIVE_OWN(0)
+                 | DISABLE_CARRIER_SENSE_TX(0U)
+                 | DISABLE_RETRY(0U)
+                 | BACK_OFF_LIMIT(MIN_N_10)
+                 | DEFERRAL_CHECK(0U)
+                 | PREAMBLE_LENGTH_TX(PREAMBLE_7B)
+                 | TRANSMITTER_ENABLE(0U)
+                 | RECEIVER_ENABLE(0U);
+
+	if (TRUE == pfe_feature_mgr_is_available("jumbo_frames"))
+	{
+		reg |= JUMBO_PACKET_ENABLE(1U);
+	}
+	else
+	{
+		reg |= JUMBO_PACKET_ENABLE(0U);
+	}
+
+	hal_write32(reg, base_va + MAC_CONFIGURATION);
 
 	hal_write32((uint32_t)0U
 			| FORWARD_ERROR_PACKETS(1U)
 			, base_va + MTL_RXQ0_OPERATION_MODE);
 
 	hal_write32(0U, base_va + MTL_TXQ0_OPERATION_MODE);
-	hal_write32(GIANT_PACKET_SIZE_LIMIT(1522U), base_va + MAC_EXT_CONFIGURATION);
+	if (TRUE == pfe_feature_mgr_is_available("jumbo_frames"))
+	{
+		hal_write32(GIANT_PACKET_SIZE_LIMIT(9022U), base_va + MAC_EXT_CONFIGURATION);
+	}
+	else
+	{
+		hal_write32(GIANT_PACKET_SIZE_LIMIT(1522U), base_va + MAC_EXT_CONFIGURATION);
+	}
 
 	hal_write32(0U, base_va + MAC_TIMESTAMP_CONTROL);
 	hal_write32(0U, base_va + MAC_SUB_SECOND_INCREMENT);
@@ -200,22 +218,30 @@ errno_t pfe_emac_cfg_init(addr_t base_va, pfe_emac_mii_mode_t mode,
 	/*	Set speed */
 	if (EOK != pfe_emac_cfg_set_speed(base_va, speed))
 	{
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	/*	Set MII mode */
-	if (EOK != pfe_emac_cfg_set_mii_mode(base_va, mode))
-	{
-		return EINVAL;
-	}
-
-	/*	Set duplex */
-	if (EOK != pfe_emac_cfg_set_duplex(base_va, duplex))
+	else
 	{
-		return EINVAL;
+		/*	Set MII mode */
+		if (EOK != pfe_emac_cfg_set_mii_mode(base_va, mode))
+		{
+			ret = EINVAL;
+		}
+		else
+		{
+			/*	Set duplex */
+			if (EOK != pfe_emac_cfg_set_duplex(base_va, duplex))
+			{
+				ret = EINVAL;
+			}
+			else
+			{
+				ret = EOK;
+			}
+		}
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -271,6 +297,7 @@ errno_t pfe_emac_cfg_enable_ts(addr_t base_va, bool_t eclk, uint32_t i_clk_hz, u
 	uint64_t val = 1000000000000ULL;
 	uint32_t ss = 0U, sns = 0U;
 	uint32_t regval, ii;
+	errno_t ret;
 
 	hal_write32(0U
 			| EXTERNAL_TIME(eclk)
@@ -288,82 +315,91 @@ errno_t pfe_emac_cfg_enable_ts(addr_t base_va, bool_t eclk, uint32_t i_clk_hz, u
 	if (eclk == TRUE)
 	{
 		NXP_LOG_INFO("IEEE1588: Using external timestamp input\n");
-		return EOK;
+		ret = EOK;
 	}
-
-	/*	Get output period [ns] */
-	ss = (val / 1000ULL) / o_clk_hz;
-
-	/*	Get sub-nanosecond part */
-	sns = (val / (uint64_t)o_clk_hz) - (((val / 1000ULL) / (uint64_t)o_clk_hz) * 1000ULL);
-
-	NXP_LOG_INFO("IEEE1588: Input Clock: %uHz, Output: %uHz, Accuracy: %u.%uns\n", (uint_t)i_clk_hz, (uint_t)o_clk_hz, (uint_t)ss, (uint_t)sns);
-
-	if (0U == (regval & DIGITAL_ROLLOVER(1)))
+	else
 	{
-		/*	Binary roll-over, 0.465ns accuracy */
-		ss = (ss * 1000U) / 465U;
-	}
+		/*	Get output period [ns] */
+		ss = (val / 1000ULL) / o_clk_hz;
 
-	sns = (sns * 256U) / 1000U;
+		/*	Get sub-nanosecond part */
+		sns = (val / (uint64_t)o_clk_hz) - (((val / 1000ULL) / (uint64_t)o_clk_hz) * 1000ULL);
 
-	/*	Set 'increment' values */
-	hal_write32(((uint32_t)ss << 16U) | ((uint32_t)sns << 8U), base_va + MAC_SUB_SECOND_INCREMENT);
+		NXP_LOG_INFO("IEEE1588: Input Clock: %uHz, Output: %uHz, Accuracy: %u.%uns\n", (uint_t)i_clk_hz, (uint_t)o_clk_hz, (uint_t)ss, (uint_t)sns);
 
-	/*	Set initial 'addend' value */
-	hal_write32(((uint64_t)o_clk_hz << 32U) / (uint64_t)i_clk_hz, base_va + MAC_TIMESTAMP_ADDEND);
-
-	regval = hal_read32(base_va + MAC_TIMESTAMP_CONTROL);
-	hal_write32(regval | UPDATE_ADDEND(1), base_va + MAC_TIMESTAMP_CONTROL);
-	ii = 0U;
-	do
-	{
-		regval = hal_read32(base_va + MAC_TIMESTAMP_CONTROL);
-		oal_time_usleep(100U);
-		if (((regval & UPDATE_ADDEND(1)) != 0U) && (ii < 10U))
-		{
-			++ii;
-		}
-		else
+		if (0U == (regval & DIGITAL_ROLLOVER(1)))
 		{
-			break;
+			/*	Binary roll-over, 0.465ns accuracy */
+			ss = (ss * 1000U) / 465U;
 		}
-	} while (TRUE);
 
-	if (ii >= 10U)
-	{
-		return ETIME;
-	}
+		sns = (sns * 256U) / 1000U;
 
-	/*	Set 'update' values */
-	hal_write32(0U, base_va + MAC_STSU);
-	hal_write32(0U, base_va + MAC_STNSU);
+		/*	Set 'increment' values */
+		hal_write32(((uint32_t)ss << 16U) | ((uint32_t)sns << 8U), base_va + MAC_SUB_SECOND_INCREMENT);
 
-	regval = hal_read32(base_va + MAC_TIMESTAMP_CONTROL);
-	regval |= INITIALIZE_TIMESTAMP(1);
-	hal_write32(regval, base_va + MAC_TIMESTAMP_CONTROL);
+		/*	Set initial 'addend' value */
+		hal_write32(((uint64_t)o_clk_hz << 32U) / (uint64_t)i_clk_hz, base_va + MAC_TIMESTAMP_ADDEND);
 
-	ii = 0U;
-	do
-	{
 		regval = hal_read32(base_va + MAC_TIMESTAMP_CONTROL);
-		oal_time_usleep(100U);
-		if (((regval & INITIALIZE_TIMESTAMP(1)) != 0U) && (ii < 10U))
+		hal_write32(regval | UPDATE_ADDEND(1), base_va + MAC_TIMESTAMP_CONTROL);
+		ii = 0U;
+		do
 		{
-			++ii;
+			regval = hal_read32(base_va + MAC_TIMESTAMP_CONTROL);
+			oal_time_usleep(100U);
+			if (((regval & UPDATE_ADDEND(1)) != 0U) && (ii < 10U))
+			{
+				++ii;
+			}
+			else
+			{
+				break;
+			}
+		} while (TRUE);
+
+		if (ii >= 10U)
+		{
+			ret = ETIME;
 		}
 		else
 		{
-			break;
+			ret = EOK;
 		}
-	} while (TRUE);
 
-	if (ii >= 10U)
-	{
-		return ETIME;
+		if (EOK == ret)
+		{
+			/*	Set 'update' values */
+			hal_write32(0U, base_va + MAC_STSU);
+			hal_write32(0U, base_va + MAC_STNSU);
+
+			regval = hal_read32(base_va + MAC_TIMESTAMP_CONTROL);
+			regval |= INITIALIZE_TIMESTAMP(1);
+			hal_write32(regval, base_va + MAC_TIMESTAMP_CONTROL);
+
+			ii = 0U;
+			do
+			{
+				regval = hal_read32(base_va + MAC_TIMESTAMP_CONTROL);
+				oal_time_usleep(100U);
+				if (((regval & INITIALIZE_TIMESTAMP(1)) != 0U) && (ii < 10U))
+				{
+					++ii;
+				}
+				else
+				{
+					break;
+				}
+			} while (TRUE);
+
+			if (ii >= 10U)
+			{
+				ret = ETIME;
+			}
+		}
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -383,6 +419,7 @@ void pfe_emac_cfg_disable_ts(addr_t base_va)
 errno_t pfe_emac_cfg_adjust_ts_freq(addr_t base_va, uint32_t i_clk_hz, uint32_t o_clk_hz, uint32_t ppb, bool_t sgn)
 {
 	uint32_t nil, delta, regval, ii;
+	errno_t ret;
 
 	/*	Nil drift addend: 1^32 / (o_clk_hz / i_clk_hz) */
 	nil = (uint32_t)(((uint64_t)o_clk_hz << 32U) / (uint64_t)i_clk_hz);
@@ -441,10 +478,14 @@ errno_t pfe_emac_cfg_adjust_ts_freq(addr_t base_va, uint32_t i_clk_hz, uint32_t
 
 	if (ii >= 10U)
 	{
-		return ETIME;
+		ret = ETIME;
+	}
+	else
+	{
+		ret = EOK;
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -472,43 +513,50 @@ void pfe_emac_cfg_get_ts_time(addr_t base_va, uint32_t *sec, uint32_t *nsec, uin
 errno_t pfe_emac_cfg_set_ts_time(addr_t base_va, uint32_t sec, uint32_t nsec, uint16_t sec_hi)
 {
 	uint32_t regval, ii;
+	errno_t ret;
 
 	if (nsec > 0x7fffffffU)
 	{
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
+	{
+		hal_write32(sec, base_va + MAC_STSU);
+		hal_write32(nsec, base_va + MAC_STNSU);
+		hal_write32(sec_hi, base_va + MAC_STS_HIGHER_WORD);
 
-	hal_write32(sec, base_va + MAC_STSU);
-	hal_write32(nsec, base_va + MAC_STNSU);
-	hal_write32(sec_hi, base_va + MAC_STS_HIGHER_WORD);
+		/*	Initialize time */
+		regval = hal_read32(base_va + MAC_TIMESTAMP_CONTROL);
+		regval |= INITIALIZE_TIMESTAMP(1);
+		hal_write32(regval, base_va + MAC_TIMESTAMP_CONTROL);
 
-	/*	Initialize time */
-	regval = hal_read32(base_va + MAC_TIMESTAMP_CONTROL);
-	regval |= INITIALIZE_TIMESTAMP(1);
-	hal_write32(regval, base_va + MAC_TIMESTAMP_CONTROL);
+		/*	Wait for completion */
+		ii = 0U;
+		do
+		{
+			regval = hal_read32(base_va + MAC_TIMESTAMP_CONTROL);
+			oal_time_usleep(100U);
+			if (((regval & INITIALIZE_TIMESTAMP(1)) != 0U) && (ii < 10U))
+			{
+				++ii;
+			}
+			else
+			{
+				break;
+			}
+		} while (TRUE);
 
-	/*	Wait for completion */
-	ii = 0U;
-	do
-	{
-		regval = hal_read32(base_va + MAC_TIMESTAMP_CONTROL);
-		oal_time_usleep(100U);
-		if (((regval & INITIALIZE_TIMESTAMP(1)) != 0U) && (ii < 10U))
+		if (ii >= 10U)
 		{
-			++ii;
+			ret = ETIME;
 		}
 		else
 		{
-			break;
+			ret = EOK;
 		}
-	} while (TRUE);
-
-	if (ii >= 10U)
-	{
-		return ETIME;
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -523,66 +571,74 @@ errno_t pfe_emac_cfg_adjust_ts_time(addr_t base_va, uint32_t sec, uint32_t nsec,
 	uint32_t regval, ii;
 	uint32_t nsec_temp = nsec;
 	int32_t sec_temp = sec;
+	errno_t ret;
 
 	if (nsec_temp > 0x7fffffffU)
 	{
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
+	{
+		ret = EOK;
 
-	regval = hal_read32(base_va + MAC_TIMESTAMP_CONTROL);
+		regval = hal_read32(base_va + MAC_TIMESTAMP_CONTROL);
 
-	if (!sgn)
-	{
-		if (0U != (regval & DIGITAL_ROLLOVER(1)))
-		{
-			nsec_temp = 1000000000U - nsec;
-		}
-		else
+		if (!sgn)
 		{
-			nsec_temp = (1UL << 31U) - nsec;
-		}
+			if (0U != (regval & DIGITAL_ROLLOVER(1)))
+			{
+				nsec_temp = 1000000000U - nsec;
+			}
+			else
+			{
+				nsec_temp = (1UL << 31U) - nsec;
+			}
 
-		sec_temp = -sec_temp;
-	}
+			sec_temp = -sec_temp;
+		}
 
-	if (0U != (regval & DIGITAL_ROLLOVER(1)))
-	{
-		if (nsec_temp > 0x3b9ac9ffU)
+		if (0U != (regval & DIGITAL_ROLLOVER(1)))
 		{
-			return EINVAL;
+			if (nsec_temp > 0x3b9ac9ffU)
+			{
+				ret = EINVAL;
+			}
 		}
-	}
 
-	hal_write32(sec_temp, base_va + MAC_STSU);
-	hal_write32(ADDSUB(!sgn) | nsec_temp, base_va + MAC_STNSU);
+		if (EOK == ret)
+		{
+			hal_write32(sec_temp, base_va + MAC_STSU);
+			hal_write32(ADDSUB(!sgn) | nsec_temp, base_va + MAC_STNSU);
 
-	/*	Trigger the update */
-	regval = hal_read32(base_va + MAC_TIMESTAMP_CONTROL);
-	regval |= UPDATE_TIMESTAMP(1);
-	hal_write32(regval, base_va + MAC_TIMESTAMP_CONTROL);
+			/*	Trigger the update */
+			regval = hal_read32(base_va + MAC_TIMESTAMP_CONTROL);
+			regval |= UPDATE_TIMESTAMP(1);
+			hal_write32(regval, base_va + MAC_TIMESTAMP_CONTROL);
 
-	/*	Wait for completion */
-	ii = 0U;
-	do
-	{
-		regval = hal_read32(base_va + MAC_TIMESTAMP_CONTROL);
-		oal_time_usleep(100U);
-		if (((regval & UPDATE_TIMESTAMP(1)) != 0U) && (ii < 10U))
-		{
-			++ii;
-		}
-		else
-		{
-			break;
+			/*	Wait for completion */
+			ii = 0U;
+			do
+			{
+				regval = hal_read32(base_va + MAC_TIMESTAMP_CONTROL);
+				oal_time_usleep(100U);
+				if (((regval & UPDATE_TIMESTAMP(1)) != 0U) && (ii < 10U))
+				{
+					++ii;
+				}
+				else
+				{
+					break;
+				}
+			} while (TRUE);
+
+			if (ii >= 10U)
+			{
+				ret = ETIME;
+			}
 		}
-	} while (TRUE);
-
-	if (ii >= 10U)
-	{
-		return ETIME;
 	}
 
-	return EOK;
+	return ret;
 }
 
 void pfe_emac_cfg_tx_disable(addr_t base_va)
@@ -619,7 +675,7 @@ errno_t pfe_emac_cfg_set_duplex(addr_t base_va, pfe_emac_duplex_t duplex)
 			ret = EINVAL;
 			break;
 	}
-	if(ret == EOK)
+	if(EOK == ret)
 	{
 		hal_write32(reg, base_va + MAC_CONFIGURATION);
 	}
@@ -778,6 +834,7 @@ errno_t pfe_emac_cfg_set_max_frame_length(addr_t base_va, uint32_t len)
 {
 	uint32_t reg, maxlen = 0U;
 	bool_t je, s2kp, gpslce, edvlp;
+	errno_t ret;
 
 	/*
 		In this case the function just performs check whether the requested length
@@ -834,10 +891,14 @@ errno_t pfe_emac_cfg_set_max_frame_length(addr_t base_va, uint32_t len)
 
 	if (len > maxlen)
 	{
-		return EINVAL;
+		ret = EINVAL;
+	}
+	else
+	{
+		ret = EOK;
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -919,15 +980,13 @@ void pfe_emac_cfg_set_hash_group(addr_t base_va, uint32_t hash, bool_t en)
 		reg &= ~((uint32_t)1U << pos);
 	}
 
-	if (reg == old_reg)
+	if (reg != old_reg)
 	{
-		return;
+		hal_write32(reg, base_va + MAC_HASH_TABLE_REG(hash_table_idx));
+		/*	Wait at least 4 clock cycles ((G)MII) */
+		oal_time_udelay(10);
+		hal_write32(reg, base_va + MAC_HASH_TABLE_REG(hash_table_idx));
 	}
-
-	hal_write32(reg, base_va + MAC_HASH_TABLE_REG(hash_table_idx));
-	/*	Wait at least 4 clock cycles ((G)MII) */
-	oal_time_udelay(10);
-	hal_write32(reg, base_va + MAC_HASH_TABLE_REG(hash_table_idx));
 }
 
 /**
@@ -1035,16 +1094,17 @@ void pfe_emac_cfg_set_tx_flow_control(addr_t base_va, bool_t en)
 	if (ii >= 10U)
 	{
 		NXP_LOG_ERROR("Flow control is busy, exiting...\n");
-		return;
 	}
+	else
+	{
+		reg &= ~(TX_FLOW_CONTROL_ENABLE(1));
+		reg |= TX_FLOW_CONTROL_ENABLE(en);
 
-	reg &= ~(TX_FLOW_CONTROL_ENABLE(1));
-	reg |= TX_FLOW_CONTROL_ENABLE(en);
-
-	reg |= TX_PAUSE_TIME(DEFAULT_PAUSE_QUANTA);
-	reg |= TX_PAUSE_LOW_TRASHOLD(0x0);
+		reg |= TX_PAUSE_TIME(DEFAULT_PAUSE_QUANTA);
+		reg |= TX_PAUSE_LOW_TRASHOLD(0x0);
 
-	hal_write32(reg, base_va + MAC_Q0_TX_FLOW_CTRL);
+		hal_write32(reg, base_va + MAC_Q0_TX_FLOW_CTRL);
+	}
 }
 
 /**
@@ -1075,6 +1135,8 @@ errno_t pfe_emac_cfg_mdio_read22(addr_t base_va, uint8_t pa, uint8_t ra, uint16_
 {
 	uint32_t reg;
 	uint32_t timeout = 500U;
+	errno_t ret = EOK;
+
 	reg = GMII_BUSY(1U)
 			| CLAUSE45_ENABLE(0U)
 			| GMII_OPERATION_CMD(GMII_READ)
@@ -1094,18 +1156,22 @@ errno_t pfe_emac_cfg_mdio_read22(addr_t base_va, uint8_t pa, uint8_t ra, uint16_
 		reg = hal_read32(base_va + MAC_MDIO_ADDRESS);
 		if (timeout == 0U)
 		{
-			return ETIME;
+			ret = ETIME;
+			break;
 		}
 		timeout--;
 		oal_time_usleep(10);
 	}
 	while(GMII_BUSY(1) == (reg & GMII_BUSY(1)));
 
-	/*	Get the data */
-	reg = hal_read32(base_va + MAC_MDIO_DATA);
-	*val = (uint16_t)GMII_DATA(reg);
+	if (EOK == ret)
+	{
+		/*	Get the data */
+		reg = hal_read32(base_va + MAC_MDIO_DATA);
+		*val = (uint16_t)GMII_DATA(reg);
+	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1121,6 +1187,7 @@ errno_t pfe_emac_cfg_mdio_read45(addr_t base_va, uint8_t pa, uint8_t dev, uint16
 {
 	uint32_t reg;
 	uint32_t timeout = 500U;
+	errno_t ret = EOK;
 
 	/* Set the register addresss to read */
 	reg = (uint32_t)GMII_REGISTER_ADDRESS(ra);
@@ -1143,17 +1210,21 @@ errno_t pfe_emac_cfg_mdio_read45(addr_t base_va, uint8_t pa, uint8_t dev, uint16
 	{
 		if (timeout-- == 0U)
 		{
-			return ETIME;
+			ret = ETIME;
+			break;
 		}
 
 		oal_time_usleep(10);
 	}
 
-	/*	Get the data */
-	reg = hal_read32(base_va + MAC_MDIO_DATA);
-	*val = (uint16_t)GMII_DATA(reg);
+	if (EOK == ret)
+	{
+		/*	Get the data */
+		reg = hal_read32(base_va + MAC_MDIO_DATA);
+		*val = (uint16_t)GMII_DATA(reg);
+	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1168,6 +1239,7 @@ errno_t pfe_emac_cfg_mdio_write22(addr_t base_va, uint8_t pa, uint8_t ra, uint16
 {
 	uint32_t reg;
 	uint32_t timeout = 500U;
+	errno_t ret = EOK;
 
 	reg = (uint32_t)GMII_DATA(val);
 	hal_write32(reg, base_va + MAC_MDIO_DATA);
@@ -1189,12 +1261,13 @@ errno_t pfe_emac_cfg_mdio_write22(addr_t base_va, uint8_t pa, uint8_t ra, uint16
 	{
 		if (timeout-- == 0U)
 		{
-			return ETIME;
+			ret = ETIME;
+			break;
 		}
 		oal_time_usleep(10);
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1210,6 +1283,7 @@ errno_t pfe_emac_cfg_mdio_write45(addr_t base_va, uint8_t pa, uint8_t dev, uint1
 {
 	uint32_t reg;
 	uint32_t timeout = 500U;
+	errno_t ret = EOK;
 
 	reg = (uint32_t)(GMII_DATA(val) | GMII_REGISTER_ADDRESS(ra));
 	hal_write32(reg, base_va + MAC_MDIO_DATA);
@@ -1231,13 +1305,14 @@ errno_t pfe_emac_cfg_mdio_write45(addr_t base_va, uint8_t pa, uint8_t dev, uint1
 	{
 		if (timeout-- == 0U)
 		{
-			return ETIME;
+			ret = ETIME;
+			break;
 		}
 
 		oal_time_usleep(10);
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1281,158 +1356,159 @@ uint32_t pfe_emac_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size,
 	if (unlikely(NULL_ADDR == base_va))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return 0U;
+		len = 0U;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		/*	Get version */
+		reg = hal_read32(base_va + MAC_VERSION);
+		len += oal_util_snprintf(buf + len, size - len, "SNPVER                    : 0x%x\n", reg & 0xffU);
+		len += oal_util_snprintf(buf + len, size - len, "USERVER                   : 0x%x\n", (reg >> 8) & 0xffU);
 
+		reg = hal_read32(base_va + RX_PACKETS_COUNT_GOOD_BAD);
+		len += oal_util_snprintf(buf + len, size - len, "RX_PACKETS_COUNT_GOOD_BAD : 0x%x\n", reg);
+		reg = hal_read32(base_va + TX_PACKET_COUNT_GOOD_BAD);
+		len += oal_util_snprintf(buf + len, size - len, "TX_PACKET_COUNT_GOOD_BAD  : 0x%x\n", reg);
 
-	/*	Get version */
-	reg = hal_read32(base_va + MAC_VERSION);
-	len += oal_util_snprintf(buf + len, size - len, "SNPVER                    : 0x%x\n", reg & 0xffU);
-	len += oal_util_snprintf(buf + len, size - len, "USERVER                   : 0x%x\n", (reg >> 8) & 0xffU);
-
-	reg = hal_read32(base_va + RX_PACKETS_COUNT_GOOD_BAD);
-	len += oal_util_snprintf(buf + len, size - len, "RX_PACKETS_COUNT_GOOD_BAD : 0x%x\n", reg);
-	reg = hal_read32(base_va + TX_PACKET_COUNT_GOOD_BAD);
-	len += oal_util_snprintf(buf + len, size - len, "TX_PACKET_COUNT_GOOD_BAD  : 0x%x\n", reg);
-
-	(void)pfe_emac_cfg_get_link_config(base_va, &speed, &duplex);
-	reg = hal_read32(base_va + MAC_CONFIGURATION);
-	len += oal_util_snprintf(buf + len, size - len, "MAC_CONFIGURATION         : 0x%x [speed: %s]\n", reg, emac_speed_to_str(speed));
+		(void)pfe_emac_cfg_get_link_config(base_va, &speed, &duplex);
+		reg = hal_read32(base_va + MAC_CONFIGURATION);
+		len += oal_util_snprintf(buf + len, size - len, "MAC_CONFIGURATION         : 0x%x [speed: %s]\n", reg, emac_speed_to_str(speed));
 
-	reg = (hal_read32(base_va + MAC_HW_FEATURE0) >> 28U) & 0x07U;
-	len += oal_util_snprintf(buf + len, size - len, "ACTPHYSEL(MAC_HW_FEATURE0): %s\n", phy_mode_to_str(reg));
+		reg = (hal_read32(base_va + MAC_HW_FEATURE0) >> 28U) & 0x07U;
+		len += oal_util_snprintf(buf + len, size - len, "ACTPHYSEL(MAC_HW_FEATURE0): %s\n", phy_mode_to_str(reg));
 
-	/* Error debugging */
-	if(verb_level >= 8U)
-	{
-		reg = hal_read32(base_va + TX_UNDERFLOW_ERROR_PACKETS);
-		len += oal_util_snprintf(buf + len, size - len, "TX_UNDERFLOW_ERROR_PACKETS        : 0x%x\n", reg);
-		reg = hal_read32(base_va + TX_SINGLE_COLLISION_GOOD_PACKETS);
-		len += oal_util_snprintf(buf + len, size - len, "TX_SINGLE_COLLISION_GOOD_PACKETS  : 0x%x\n", reg);
-		reg = hal_read32(base_va + TX_MULTIPLE_COLLISION_GOOD_PACKETS);
-		len += oal_util_snprintf(buf + len, size - len, "TX_MULTIPLE_COLLISION_GOOD_PACKETS: 0x%x\n", reg);
-		reg = hal_read32(base_va + TX_DEFERRED_PACKETS);
-		len += oal_util_snprintf(buf + len, size - len, "TX_DEFERRED_PACKETS               : 0x%x\n", reg);
-		reg = hal_read32(base_va + TX_LATE_COLLISION_PACKETS);
-		len += oal_util_snprintf(buf + len, size - len, "TX_LATE_COLLISION_PACKETS         : 0x%x\n", reg);
-		reg = hal_read32(base_va + TX_EXCESSIVE_COLLISION_PACKETS);
-		len += oal_util_snprintf(buf + len, size - len, "TX_EXCESSIVE_COLLISION_PACKETS    : 0x%x\n", reg);
-		reg = hal_read32(base_va + TX_CARRIER_ERROR_PACKETS);
-		len += oal_util_snprintf(buf + len, size - len, "TX_CARRIER_ERROR_PACKETS          : 0x%x\n", reg);
-		reg = hal_read32(base_va + TX_EXCESSIVE_DEFERRAL_ERROR);
-		len += oal_util_snprintf(buf + len, size - len, "TX_EXCESSIVE_DEFERRAL_ERROR       : 0x%x\n", reg);
-
-		reg = hal_read32(base_va + TX_OSIZE_PACKETS_GOOD);
-		len += oal_util_snprintf(buf + len, size - len, "TX_OSIZE_PACKETS_GOOD             : 0x%x\n", reg);
-
-		reg = hal_read32(base_va + RX_CRC_ERROR_PACKETS);
-		len += oal_util_snprintf(buf + len, size - len, "RX_CRC_ERROR_PACKETS              : 0x%x\n", reg);
-		reg = hal_read32(base_va + RX_ALIGNMENT_ERROR_PACKETS);
-		len += oal_util_snprintf(buf + len, size - len, "RX_ALIGNMENT_ERROR_PACKETS        : 0x%x\n", reg);
-		reg = hal_read32(base_va + RX_RUNT_ERROR_PACKETS);
-		len += oal_util_snprintf(buf + len, size - len, "RX_RUNT_ERROR_PACKETS             : 0x%x\n", reg);
-		reg = hal_read32(base_va + RX_JABBER_ERROR_PACKETS);
-		len += oal_util_snprintf(buf + len, size - len, "RX_JABBER_ERROR_PACKETS           : 0x%x\n", reg);
-		reg = hal_read32(base_va + RX_LENGTH_ERROR_PACKETS);
-		len += oal_util_snprintf(buf + len, size - len, "RX_LENGTH_ERROR_PACKETS           : 0x%x\n", reg);
-		reg = hal_read32(base_va + RX_OUT_OF_RANGE_TYPE_PACKETS);
-		len += oal_util_snprintf(buf + len, size - len, "RX_OUT_OF_RANGE_TYPE_PACKETS      : 0x%x\n", reg);
-		reg = hal_read32(base_va + RX_FIFO_OVERFLOW_PACKETS);
-		len += oal_util_snprintf(buf + len, size - len, "RX_FIFO_OVERFLOW_PACKETS          : 0x%x\n", reg);
-		reg = hal_read32(base_va + RX_RECEIVE_ERROR_PACKETS);
-		len += oal_util_snprintf(buf + len, size - len, "RX_RECEIVE_ERROR_PACKETS          : 0x%x\n", reg);
-		reg = hal_read32(base_va + RX_RECEIVE_ERROR_PACKETS);
-		len += oal_util_snprintf(buf + len, size - len, "RX_RECEIVE_ERROR_PACKETS          : 0x%x\n", reg);
-	}
+		/* Error debugging */
+		if(verb_level >= 8U)
+		{
+			reg = hal_read32(base_va + TX_UNDERFLOW_ERROR_PACKETS);
+			len += oal_util_snprintf(buf + len, size - len, "TX_UNDERFLOW_ERROR_PACKETS        : 0x%x\n", reg);
+			reg = hal_read32(base_va + TX_SINGLE_COLLISION_GOOD_PACKETS);
+			len += oal_util_snprintf(buf + len, size - len, "TX_SINGLE_COLLISION_GOOD_PACKETS  : 0x%x\n", reg);
+			reg = hal_read32(base_va + TX_MULTIPLE_COLLISION_GOOD_PACKETS);
+			len += oal_util_snprintf(buf + len, size - len, "TX_MULTIPLE_COLLISION_GOOD_PACKETS: 0x%x\n", reg);
+			reg = hal_read32(base_va + TX_DEFERRED_PACKETS);
+			len += oal_util_snprintf(buf + len, size - len, "TX_DEFERRED_PACKETS               : 0x%x\n", reg);
+			reg = hal_read32(base_va + TX_LATE_COLLISION_PACKETS);
+			len += oal_util_snprintf(buf + len, size - len, "TX_LATE_COLLISION_PACKETS         : 0x%x\n", reg);
+			reg = hal_read32(base_va + TX_EXCESSIVE_COLLISION_PACKETS);
+			len += oal_util_snprintf(buf + len, size - len, "TX_EXCESSIVE_COLLISION_PACKETS    : 0x%x\n", reg);
+			reg = hal_read32(base_va + TX_CARRIER_ERROR_PACKETS);
+			len += oal_util_snprintf(buf + len, size - len, "TX_CARRIER_ERROR_PACKETS          : 0x%x\n", reg);
+			reg = hal_read32(base_va + TX_EXCESSIVE_DEFERRAL_ERROR);
+			len += oal_util_snprintf(buf + len, size - len, "TX_EXCESSIVE_DEFERRAL_ERROR       : 0x%x\n", reg);
+
+			reg = hal_read32(base_va + TX_OSIZE_PACKETS_GOOD);
+			len += oal_util_snprintf(buf + len, size - len, "TX_OSIZE_PACKETS_GOOD             : 0x%x\n", reg);
+
+			reg = hal_read32(base_va + RX_CRC_ERROR_PACKETS);
+			len += oal_util_snprintf(buf + len, size - len, "RX_CRC_ERROR_PACKETS              : 0x%x\n", reg);
+			reg = hal_read32(base_va + RX_ALIGNMENT_ERROR_PACKETS);
+			len += oal_util_snprintf(buf + len, size - len, "RX_ALIGNMENT_ERROR_PACKETS        : 0x%x\n", reg);
+			reg = hal_read32(base_va + RX_RUNT_ERROR_PACKETS);
+			len += oal_util_snprintf(buf + len, size - len, "RX_RUNT_ERROR_PACKETS             : 0x%x\n", reg);
+			reg = hal_read32(base_va + RX_JABBER_ERROR_PACKETS);
+			len += oal_util_snprintf(buf + len, size - len, "RX_JABBER_ERROR_PACKETS           : 0x%x\n", reg);
+			reg = hal_read32(base_va + RX_LENGTH_ERROR_PACKETS);
+			len += oal_util_snprintf(buf + len, size - len, "RX_LENGTH_ERROR_PACKETS           : 0x%x\n", reg);
+			reg = hal_read32(base_va + RX_OUT_OF_RANGE_TYPE_PACKETS);
+			len += oal_util_snprintf(buf + len, size - len, "RX_OUT_OF_RANGE_TYPE_PACKETS      : 0x%x\n", reg);
+			reg = hal_read32(base_va + RX_FIFO_OVERFLOW_PACKETS);
+			len += oal_util_snprintf(buf + len, size - len, "RX_FIFO_OVERFLOW_PACKETS          : 0x%x\n", reg);
+			reg = hal_read32(base_va + RX_RECEIVE_ERROR_PACKETS);
+			len += oal_util_snprintf(buf + len, size - len, "RX_RECEIVE_ERROR_PACKETS          : 0x%x\n", reg);
+			reg = hal_read32(base_va + RX_RECEIVE_ERROR_PACKETS);
+			len += oal_util_snprintf(buf + len, size - len, "RX_RECEIVE_ERROR_PACKETS          : 0x%x\n", reg);
+		}
 
-	/* Cast/vlan/flow control */
-	if(verb_level >= 3U)
-	{
-		reg = hal_read32(base_va + TX_UNICAST_PACKETS_GOOD_BAD);
-		len += oal_util_snprintf(buf + len, size - len, "TX_UNICAST_PACKETS_GOOD_BAD       : 0x%x\n", reg);
-		reg = hal_read32(base_va + TX_BROADCAST_PACKETS_GOOD);
-		len += oal_util_snprintf(buf + len, size - len, "TX_BROADCAST_PACKETS_GOOD         : 0x%x\n", reg);
-		reg = hal_read32(base_va + TX_BROADCAST_PACKETS_GOOD_BAD);
-		len += oal_util_snprintf(buf + len, size - len, "TX_BROADCAST_PACKETS_GOOD_BAD     : 0x%x\n", reg);
-		reg = hal_read32(base_va + TX_MULTICAST_PACKETS_GOOD);
-		len += oal_util_snprintf(buf + len, size - len, "TX_MULTICAST_PACKETS_GOOD         : 0x%x\n", reg);
-		reg = hal_read32(base_va + TX_MULTICAST_PACKETS_GOOD_BAD);
-		len += oal_util_snprintf(buf + len, size - len, "TX_MULTICAST_PACKETS_GOOD_BAD     : 0x%x\n", reg);
-		reg = hal_read32(base_va + TX_VLAN_PACKETS_GOOD);
-		len += oal_util_snprintf(buf + len, size - len, "TX_VLAN_PACKETS_GOOD              : 0x%x\n", reg);
-		reg = hal_read32(base_va + TX_PAUSE_PACKETS);
-		len += oal_util_snprintf(buf + len, size - len, "TX_PAUSE_PACKETS                  : 0x%x\n", reg);
-	}
+		/* Cast/vlan/flow control */
+		if(verb_level >= 3U)
+		{
+			reg = hal_read32(base_va + TX_UNICAST_PACKETS_GOOD_BAD);
+			len += oal_util_snprintf(buf + len, size - len, "TX_UNICAST_PACKETS_GOOD_BAD       : 0x%x\n", reg);
+			reg = hal_read32(base_va + TX_BROADCAST_PACKETS_GOOD);
+			len += oal_util_snprintf(buf + len, size - len, "TX_BROADCAST_PACKETS_GOOD         : 0x%x\n", reg);
+			reg = hal_read32(base_va + TX_BROADCAST_PACKETS_GOOD_BAD);
+			len += oal_util_snprintf(buf + len, size - len, "TX_BROADCAST_PACKETS_GOOD_BAD     : 0x%x\n", reg);
+			reg = hal_read32(base_va + TX_MULTICAST_PACKETS_GOOD);
+			len += oal_util_snprintf(buf + len, size - len, "TX_MULTICAST_PACKETS_GOOD         : 0x%x\n", reg);
+			reg = hal_read32(base_va + TX_MULTICAST_PACKETS_GOOD_BAD);
+			len += oal_util_snprintf(buf + len, size - len, "TX_MULTICAST_PACKETS_GOOD_BAD     : 0x%x\n", reg);
+			reg = hal_read32(base_va + TX_VLAN_PACKETS_GOOD);
+			len += oal_util_snprintf(buf + len, size - len, "TX_VLAN_PACKETS_GOOD              : 0x%x\n", reg);
+			reg = hal_read32(base_va + TX_PAUSE_PACKETS);
+			len += oal_util_snprintf(buf + len, size - len, "TX_PAUSE_PACKETS                  : 0x%x\n", reg);
+		}
 
-	if(verb_level >= 4U)
-	{
-		reg = hal_read32(base_va + RX_UNICAST_PACKETS_GOOD);
-		len += oal_util_snprintf(buf + len, size - len, "RX_UNICAST_PACKETS_GOOD           : 0x%x\n", reg);
-		reg = hal_read32(base_va + RX_BROADCAST_PACKETS_GOOD);
-		len += oal_util_snprintf(buf + len, size - len, "RX_BROADCAST_PACKETS_GOOD         : 0x%x\n", reg);
-		reg = hal_read32(base_va + RX_MULTICAST_PACKETS_GOOD);
-		len += oal_util_snprintf(buf + len, size - len, "RX_MULTICAST_PACKETS_GOOD         : 0x%x\n", reg);
-		reg = hal_read32(base_va + RX_VLAN_PACKETS_GOOD_BAD);
-		len += oal_util_snprintf(buf + len, size - len, "RX_VLAN_PACKETS_GOOD_BAD          : 0x%x\n", reg);
-		reg = hal_read32(base_va + RX_PAUSE_PACKETS);
-		len += oal_util_snprintf(buf + len, size - len, "RX_PAUSE_PACKETS                  : 0x%x\n", reg);
-		reg = hal_read32(base_va + RX_CONTROL_PACKETS_GOOD);
-		len += oal_util_snprintf(buf + len, size - len, "RX_CONTROL_PACKETS_GOOD           : 0x%x\n", reg);
-	}
+		if(verb_level >= 4U)
+		{
+			reg = hal_read32(base_va + RX_UNICAST_PACKETS_GOOD);
+			len += oal_util_snprintf(buf + len, size - len, "RX_UNICAST_PACKETS_GOOD           : 0x%x\n", reg);
+			reg = hal_read32(base_va + RX_BROADCAST_PACKETS_GOOD);
+			len += oal_util_snprintf(buf + len, size - len, "RX_BROADCAST_PACKETS_GOOD         : 0x%x\n", reg);
+			reg = hal_read32(base_va + RX_MULTICAST_PACKETS_GOOD);
+			len += oal_util_snprintf(buf + len, size - len, "RX_MULTICAST_PACKETS_GOOD         : 0x%x\n", reg);
+			reg = hal_read32(base_va + RX_VLAN_PACKETS_GOOD_BAD);
+			len += oal_util_snprintf(buf + len, size - len, "RX_VLAN_PACKETS_GOOD_BAD          : 0x%x\n", reg);
+			reg = hal_read32(base_va + RX_PAUSE_PACKETS);
+			len += oal_util_snprintf(buf + len, size - len, "RX_PAUSE_PACKETS                  : 0x%x\n", reg);
+			reg = hal_read32(base_va + RX_CONTROL_PACKETS_GOOD);
+			len += oal_util_snprintf(buf + len, size - len, "RX_CONTROL_PACKETS_GOOD           : 0x%x\n", reg);
+		}
 
-	if(verb_level >= 1U)
-	{
-		reg = hal_read32(base_va + TX_OCTET_COUNT_GOOD);
-		len += oal_util_snprintf(buf + len, size - len, "TX_OCTET_COUNT_GOOD                : 0x%x\n", reg);
-		reg = hal_read32(base_va + TX_OCTET_COUNT_GOOD_BAD);
-		len += oal_util_snprintf(buf + len, size - len, "TX_OCTET_COUNT_GOOD_BAD            : 0x%x\n", reg);
-		reg = hal_read32(base_va + TX_64OCTETS_PACKETS_GOOD_BAD);
-		len += oal_util_snprintf(buf + len, size - len, "TX_64OCTETS_PACKETS_GOOD_BAD       : 0x%x\n", reg);
-		reg = hal_read32(base_va + TX_65TO127OCTETS_PACKETS_GOOD_BAD);
-		len += oal_util_snprintf(buf + len, size - len, "TX_65TO127OCTETS_PACKETS_GOOD_BAD  : 0x%x\n", reg);
-		reg = hal_read32(base_va + TX_128TO255OCTETS_PACKETS_GOOD_BAD);
-		len += oal_util_snprintf(buf + len, size - len, "TX_128TO255OCTETS_PACKETS_GOOD_BAD : 0x%x\n", reg);
-		reg = hal_read32(base_va + TX_256TO511OCTETS_PACKETS_GOOD_BAD);
-		len += oal_util_snprintf(buf + len, size - len, "TX_256TO511OCTETS_PACKETS_GOOD_BAD : 0x%x\n", reg);
-		reg = hal_read32(base_va + TX_512TO1023OCTETS_PACKETS_GOOD_BAD);
-		len += oal_util_snprintf(buf + len, size - len, "TX_512TO1023OCTETS_PACKETS_GOOD_BAD: 0x%x\n", reg);
-		reg = hal_read32(base_va + TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD);
-		len += oal_util_snprintf(buf + len, size - len, "TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD: 0x%x\n", reg);
-	}
+		if(verb_level >= 1U)
+		{
+			reg = hal_read32(base_va + TX_OCTET_COUNT_GOOD);
+			len += oal_util_snprintf(buf + len, size - len, "TX_OCTET_COUNT_GOOD                : 0x%x\n", reg);
+			reg = hal_read32(base_va + TX_OCTET_COUNT_GOOD_BAD);
+			len += oal_util_snprintf(buf + len, size - len, "TX_OCTET_COUNT_GOOD_BAD            : 0x%x\n", reg);
+			reg = hal_read32(base_va + TX_64OCTETS_PACKETS_GOOD_BAD);
+			len += oal_util_snprintf(buf + len, size - len, "TX_64OCTETS_PACKETS_GOOD_BAD       : 0x%x\n", reg);
+			reg = hal_read32(base_va + TX_65TO127OCTETS_PACKETS_GOOD_BAD);
+			len += oal_util_snprintf(buf + len, size - len, "TX_65TO127OCTETS_PACKETS_GOOD_BAD  : 0x%x\n", reg);
+			reg = hal_read32(base_va + TX_128TO255OCTETS_PACKETS_GOOD_BAD);
+			len += oal_util_snprintf(buf + len, size - len, "TX_128TO255OCTETS_PACKETS_GOOD_BAD : 0x%x\n", reg);
+			reg = hal_read32(base_va + TX_256TO511OCTETS_PACKETS_GOOD_BAD);
+			len += oal_util_snprintf(buf + len, size - len, "TX_256TO511OCTETS_PACKETS_GOOD_BAD : 0x%x\n", reg);
+			reg = hal_read32(base_va + TX_512TO1023OCTETS_PACKETS_GOOD_BAD);
+			len += oal_util_snprintf(buf + len, size - len, "TX_512TO1023OCTETS_PACKETS_GOOD_BAD: 0x%x\n", reg);
+			reg = hal_read32(base_va + TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD);
+			len += oal_util_snprintf(buf + len, size - len, "TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD: 0x%x\n", reg);
+		}
 
-	if(verb_level >= 5U)
-	{
-		reg = hal_read32(base_va + TX_OSIZE_PACKETS_GOOD);
-		len += oal_util_snprintf(buf + len, size - len, "TX_OSIZE_PACKETS_GOOD              : 0x%x\n", reg);
-	}
+		if(verb_level >= 5U)
+		{
+			reg = hal_read32(base_va + TX_OSIZE_PACKETS_GOOD);
+			len += oal_util_snprintf(buf + len, size - len, "TX_OSIZE_PACKETS_GOOD              : 0x%x\n", reg);
+		}
 
-	if(verb_level >= 2U)
-	{
-		reg = hal_read32(base_va + RX_OCTET_COUNT_GOOD);
-		len += oal_util_snprintf(buf + len, size - len, "RX_OCTET_COUNT_GOOD                : 0x%x\n", reg);
-		reg = hal_read32(base_va + RX_OCTET_COUNT_GOOD_BAD);
-		len += oal_util_snprintf(buf + len, size - len, "RX_OCTET_COUNT_GOOD_BAD            : 0x%x\n", reg);
-		reg = hal_read32(base_va + RX_64OCTETS_PACKETS_GOOD_BAD);
-		len += oal_util_snprintf(buf + len, size - len, "RX_64OCTETS_PACKETS_GOOD_BAD       : 0x%x\n", reg);
-		reg = hal_read32(base_va + RX_65TO127OCTETS_PACKETS_GOOD_BAD);
-		len += oal_util_snprintf(buf + len, size - len, "RX_65TO127OCTETS_PACKETS_GOOD_BAD  : 0x%x\n", reg);
-		reg = hal_read32(base_va + RX_128TO255OCTETS_PACKETS_GOOD_BAD);
-		len += oal_util_snprintf(buf + len, size - len, "RX_128TO255OCTETS_PACKETS_GOOD_BAD : 0x%x\n", reg);
-		reg = hal_read32(base_va + RX_256TO511OCTETS_PACKETS_GOOD_BAD);
-		len += oal_util_snprintf(buf + len, size - len, "RX_256TO511OCTETS_PACKETS_GOOD_BAD : 0x%x\n", reg);
-		reg = hal_read32(base_va + RX_512TO1023OCTETS_PACKETS_GOOD_BAD);
-		len += oal_util_snprintf(buf + len, size - len, "RX_512TO1023OCTETS_PACKETS_GOOD_BAD: 0x%x\n", reg);
-		reg = hal_read32(base_va + RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD);
-		len += oal_util_snprintf(buf + len, size - len, "RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD: 0x%x\n", reg);
-	}
+		if(verb_level >= 2U)
+		{
+			reg = hal_read32(base_va + RX_OCTET_COUNT_GOOD);
+			len += oal_util_snprintf(buf + len, size - len, "RX_OCTET_COUNT_GOOD                : 0x%x\n", reg);
+			reg = hal_read32(base_va + RX_OCTET_COUNT_GOOD_BAD);
+			len += oal_util_snprintf(buf + len, size - len, "RX_OCTET_COUNT_GOOD_BAD            : 0x%x\n", reg);
+			reg = hal_read32(base_va + RX_64OCTETS_PACKETS_GOOD_BAD);
+			len += oal_util_snprintf(buf + len, size - len, "RX_64OCTETS_PACKETS_GOOD_BAD       : 0x%x\n", reg);
+			reg = hal_read32(base_va + RX_65TO127OCTETS_PACKETS_GOOD_BAD);
+			len += oal_util_snprintf(buf + len, size - len, "RX_65TO127OCTETS_PACKETS_GOOD_BAD  : 0x%x\n", reg);
+			reg = hal_read32(base_va + RX_128TO255OCTETS_PACKETS_GOOD_BAD);
+			len += oal_util_snprintf(buf + len, size - len, "RX_128TO255OCTETS_PACKETS_GOOD_BAD : 0x%x\n", reg);
+			reg = hal_read32(base_va + RX_256TO511OCTETS_PACKETS_GOOD_BAD);
+			len += oal_util_snprintf(buf + len, size - len, "RX_256TO511OCTETS_PACKETS_GOOD_BAD : 0x%x\n", reg);
+			reg = hal_read32(base_va + RX_512TO1023OCTETS_PACKETS_GOOD_BAD);
+			len += oal_util_snprintf(buf + len, size - len, "RX_512TO1023OCTETS_PACKETS_GOOD_BAD: 0x%x\n", reg);
+			reg = hal_read32(base_va + RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD);
+			len += oal_util_snprintf(buf + len, size - len, "RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD: 0x%x\n", reg);
+		}
 
-	if(verb_level >= 5U)
-	{
-		reg = hal_read32(base_va + RX_OVERSIZE_PACKETS_GOOD);
-		len += oal_util_snprintf(buf + len, size - len, "RX_OSIZE_PACKETS_GOOD              : 0x%x\n", reg);
-		reg = hal_read32(base_va + RX_UNDERSIZE_PACKETS_GOOD);
-		len += oal_util_snprintf(buf + len, size - len, "RX_UNDERSIZE_PACKETS_GOOD          : 0x%x\n", reg);
+		if(verb_level >= 5U)
+		{
+			reg = hal_read32(base_va + RX_OVERSIZE_PACKETS_GOOD);
+			len += oal_util_snprintf(buf + len, size - len, "RX_OSIZE_PACKETS_GOOD              : 0x%x\n", reg);
+			reg = hal_read32(base_va + RX_UNDERSIZE_PACKETS_GOOD);
+			len += oal_util_snprintf(buf + len, size - len, "RX_UNDERSIZE_PACKETS_GOOD          : 0x%x\n", reg);
+		}
 	}
 
 	return len;
@@ -1448,13 +1524,17 @@ uint32_t pfe_emac_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size,
  */
 uint32_t pfe_emac_cfg_get_stat_value(addr_t base_va, uint32_t stat_id)
 {
+	uint32_t stat_value;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL_ADDR == base_va))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return 0xFFFFFFFFU;
+		stat_value = 0xFFFFFFFFU;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	return hal_read32(base_va + stat_id);
+	{
+		stat_value = hal_read32(base_va + stat_id);
+	}
+	return stat_value;
 }
diff --git a/sw/pfe_platform/hw/s32g/pfe_gpi_csr.c b/sw/pfe_platform/hw/s32g/pfe_gpi_csr.c
index d511bf8..8b0bbe8 100644
--- a/sw/pfe_platform/hw/s32g/pfe_gpi_csr.c
+++ b/sw/pfe_platform/hw/s32g/pfe_gpi_csr.c
@@ -100,7 +100,7 @@ void pfe_gpi_cfg_init(addr_t base_va, const pfe_gpi_cfg_t *cfg)
 	}
 
 	hal_write32(((cfg->alloc_retry_cycles << 16) | GPI_DDR_BUF_EN | GPI_LMEM_BUF_EN), base_va + GPI_RX_CONFIG);
-	hal_write32((uint32_t)(PFE_CFG_DDR_HDR_SIZE << 16) | PFE_CFG_LMEM_HDR_SIZE, base_va + GPI_HDR_SIZE);
+	hal_write32((uint32_t)(PFE_CFG_DDR_HDR_SIZE << 16) | cfg->lmem_header_size, base_va + GPI_HDR_SIZE);
 	hal_write32((PFE_CFG_DDR_BUF_SIZE << 16) | PFE_CFG_LMEM_BUF_SIZE, base_va + GPI_BUF_SIZE);
 	hal_write32(PFE_CFG_CBUS_PHYS_BASE_ADDR + CBUS_BMU1_BASE_ADDR + BMU_ALLOC_CTRL, base_va + GPI_LMEM_ALLOC_ADDR);
 	hal_write32(PFE_CFG_CBUS_PHYS_BASE_ADDR + CBUS_BMU1_BASE_ADDR + BMU_FREE_CTRL, base_va + GPI_LMEM_FREE_ADDR);
@@ -109,7 +109,7 @@ void pfe_gpi_cfg_init(addr_t base_va, const pfe_gpi_cfg_t *cfg)
 	hal_write32(PFE_CFG_CBUS_PHYS_BASE_ADDR + CLASS_INQ_PKTPTR, base_va + GPI_CLASS_ADDR);
 	hal_write32(PFE_CFG_DDR_HDR_SIZE, base_va + GPI_DDR_DATA_OFFSET);
 	hal_write32(0x30U, base_va + GPI_LMEM_DATA_OFFSET);
-	hal_write32(PFE_CFG_LMEM_HDR_SIZE, base_va + GPI_LMEM_SEC_BUF_DATA_OFFSET);
+	hal_write32(cfg->lmem_header_size, base_va + GPI_LMEM_SEC_BUF_DATA_OFFSET);
 	hal_write32(cfg->gpi_tmlf_txthres, base_va + GPI_TMLF_TX);
 	hal_write32(cfg->gpi_dtx_aseq_len, base_va + GPI_DTX_ASEQ);
 	hal_write32(1, base_va + GPI_CSR_TOE_CHKSUM_EN);
@@ -228,12 +228,13 @@ void pfe_gpi_cfg_qos_write_flow_entry_req(addr_t base_va, uint32_t addr, const u
 	if (unlikely(NULL == entry))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	igqos_class_prepare_entry_data(base_va, entry);
-	igqos_class_write_flow_cmd(base_va, addr);
+	{
+		igqos_class_prepare_entry_data(base_va, entry);
+		igqos_class_write_flow_cmd(base_va, addr);
+	}
 }
 
 void pfe_gpi_cfg_qos_clear_flow_entry_req(addr_t base_va, uint32_t addr)
@@ -656,75 +657,77 @@ uint32_t pfe_gpi_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, u
 	if (unlikely(NULL_ADDR == base_va))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return 0U;
+		len = 0U;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	/* Debug registers */
-	if(verb_level >= 10U)
 	{
-		len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_FIFO_DEBUG   : 0x%x\n", hal_read32(base_va + GPI_FIFO_DEBUG));
-		len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_TX_DBUG_REG1 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG1));
-		len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_TX_DBUG_REG2 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG2));
-		len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_TX_DBUG_REG3 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG3));
-		len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_TX_DBUG_REG4 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG4));
-		len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_TX_DBUG_REG5 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG5));
-		len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_TX_DBUG_REG6 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG6));
-		len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_RX_DBUG_REG1 : 0x%x\n", hal_read32(base_va + GPI_RX_DBUG_REG1));
-		len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_RX_DBUG_REG2 : 0x%x\n", hal_read32(base_va + GPI_RX_DBUG_REG2));
-		len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_FIFO_STATUS  : 0x%x\n", hal_read32(base_va + GPI_FIFO_STATUS));
-	}
+		/* Debug registers */
+		if(verb_level >= 10U)
+		{
+			len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_FIFO_DEBUG   : 0x%x\n", hal_read32(base_va + GPI_FIFO_DEBUG));
+			len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_TX_DBUG_REG1 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG1));
+			len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_TX_DBUG_REG2 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG2));
+			len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_TX_DBUG_REG3 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG3));
+			len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_TX_DBUG_REG4 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG4));
+			len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_TX_DBUG_REG5 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG5));
+			len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_TX_DBUG_REG6 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG6));
+			len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_RX_DBUG_REG1 : 0x%x\n", hal_read32(base_va + GPI_RX_DBUG_REG1));
+			len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_RX_DBUG_REG2 : 0x%x\n", hal_read32(base_va + GPI_RX_DBUG_REG2));
+			len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_FIFO_STATUS  : 0x%x\n", hal_read32(base_va + GPI_FIFO_STATUS));
+		}
 
-	/*	Get version */
-	if(verb_level >= 9U)
-	{
-		reg = hal_read32(base_va + GPI_VERSION);
-		len += oal_util_snprintf(buf + len, (size_t)size - len, "Revision             : 0x%x\n", (reg >> 24) & 0xffU);
-		len += oal_util_snprintf(buf + len, (size_t)size - len, "Version              : 0x%x\n", (reg >> 16) & 0xffU);
-		len += oal_util_snprintf(buf + len, (size_t)size - len, "ID                   : 0x%x\n", reg & 0xffffU);
-	}
+		/*	Get version */
+		if(verb_level >= 9U)
+		{
+			reg = hal_read32(base_va + GPI_VERSION);
+			len += oal_util_snprintf(buf + len, (size_t)size - len, "Revision             : 0x%x\n", (reg >> 24) & 0xffU);
+			len += oal_util_snprintf(buf + len, (size_t)size - len, "Version              : 0x%x\n", (reg >> 16) & 0xffU);
+			len += oal_util_snprintf(buf + len, (size_t)size - len, "ID                   : 0x%x\n", reg & 0xffffU);
+		}
 
-	/*	Ingress QoS counters */
-	reg = hal_read32(base_va + CSR_IGQOS_QUEUE_STATUS);
-	len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS queue status   : 0x%x\n", reg);
-	reg = hal_read32(base_va + CSR_IGQOS_STAT_CLASS_DROP_CNT);
-	len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS CLASS drop cnt : 0x%x\n", reg);
-	reg = hal_read32(base_va + CSR_IGQOS_STAT_LMEM_QUEUE_DROP_CNT);
-	len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS LMEM drop cnt  : 0x%x\n", reg);
-	reg = hal_read32(base_va + CSR_IGQOS_STAT_DMEM_QUEUE_DROP_CNT);
-	len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS DMEM drop cnt  : 0x%x\n", reg);
-	reg = hal_read32(base_va + CSR_IGQOS_STAT_RXF_QUEUE_DROP_CNT);
-	len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS RXF drop cnt   : 0x%x\n", reg);
-	reg = pfe_gpi_cfg_shp_get_drop_cnt(base_va, 0);
-	len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS SHP0 drop cnt  : 0x%x\n", reg);
-	reg = pfe_gpi_cfg_shp_get_drop_cnt(base_va, 1);
-	len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS SHP1 drop cnt  : 0x%x\n", reg);
-	reg = hal_read32(base_va + CSR_IGQOS_STAT_MANAGED_PACKET_CNT);
-	len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS managed pkts   : 0x%x\n", reg);
-	reg = hal_read32(base_va + CSR_IGQOS_STAT_UNMANAGED_PACKET_CNT);
-	len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS unmanaged pkts : 0x%x\n", reg);
-	reg = hal_read32(base_va + CSR_IGQOS_STAT_RESERVED_PACKET_CNT);
-	len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS reserved pkts  : 0x%x\n", reg);
-
-	reg = hal_read32(base_va + GPI_FIFO_STATUS);
-	len += oal_util_snprintf(buf + len, (size_t)size - len, "TX Underrun          : 0x%x\n", reg);
-	hal_write32(0, base_va + GPI_FIFO_STATUS);
-
-	reg = hal_read32(base_va + GPI_FIFO_DEBUG);
-	len += oal_util_snprintf(buf + len, (size_t)size - len, "TX FIFO Packets      : 0x%x\n", reg & 0x1fU);
-	len += oal_util_snprintf(buf + len, (size_t)size - len, "RX FIFO Packets      : 0x%x\n", (reg >> 6) & 0x1fU);
-	len += oal_util_snprintf(buf + len, (size_t)size - len, "TX FIFO Level        : 0x%x\n", (reg >> 12) & 0xffU);
-	len += oal_util_snprintf(buf + len, (size_t)size - len, "RX FIFO Level        : 0x%x\n", (reg >> 20) & 0xffU);
-
-	reg = hal_read32(base_va + GPI_DTX_ASEQ);
-	len += oal_util_snprintf(buf + len, (size_t)size - len, "ASEQ Length          : 0x%x\n", reg);
-
-	reg = hal_read32(base_va + GPI_EMAC_1588_TIMESTAMP_EN);
-	len += oal_util_snprintf(buf + len, (size_t)size - len, "1588 Enable register : 0x%x\n", reg);
-
-	reg = hal_read32(base_va + GPI_OVERRUN_DROPCNT);
-	len += oal_util_snprintf(buf + len, (size_t)size - len, "Overrun Drop Counter : 0x%x\n", reg);
-	hal_write32(0, base_va + GPI_OVERRUN_DROPCNT);
+		/*	Ingress QoS counters */
+		reg = hal_read32(base_va + CSR_IGQOS_QUEUE_STATUS);
+		len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS queue status   : 0x%x\n", reg);
+		reg = hal_read32(base_va + CSR_IGQOS_STAT_CLASS_DROP_CNT);
+		len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS CLASS drop cnt : 0x%x\n", reg);
+		reg = hal_read32(base_va + CSR_IGQOS_STAT_LMEM_QUEUE_DROP_CNT);
+		len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS LMEM drop cnt  : 0x%x\n", reg);
+		reg = hal_read32(base_va + CSR_IGQOS_STAT_DMEM_QUEUE_DROP_CNT);
+		len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS DMEM drop cnt  : 0x%x\n", reg);
+		reg = hal_read32(base_va + CSR_IGQOS_STAT_RXF_QUEUE_DROP_CNT);
+		len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS RXF drop cnt   : 0x%x\n", reg);
+		reg = pfe_gpi_cfg_shp_get_drop_cnt(base_va, 0);
+		len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS SHP0 drop cnt  : 0x%x\n", reg);
+		reg = pfe_gpi_cfg_shp_get_drop_cnt(base_va, 1);
+		len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS SHP1 drop cnt  : 0x%x\n", reg);
+		reg = hal_read32(base_va + CSR_IGQOS_STAT_MANAGED_PACKET_CNT);
+		len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS managed pkts   : 0x%x\n", reg);
+		reg = hal_read32(base_va + CSR_IGQOS_STAT_UNMANAGED_PACKET_CNT);
+		len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS unmanaged pkts : 0x%x\n", reg);
+		reg = hal_read32(base_va + CSR_IGQOS_STAT_RESERVED_PACKET_CNT);
+		len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS reserved pkts  : 0x%x\n", reg);
+
+		reg = hal_read32(base_va + GPI_FIFO_STATUS);
+		len += oal_util_snprintf(buf + len, (size_t)size - len, "TX Underrun          : 0x%x\n", reg);
+		hal_write32(0, base_va + GPI_FIFO_STATUS);
+
+		reg = hal_read32(base_va + GPI_FIFO_DEBUG);
+		len += oal_util_snprintf(buf + len, (size_t)size - len, "TX FIFO Packets      : 0x%x\n", reg & 0x1fU);
+		len += oal_util_snprintf(buf + len, (size_t)size - len, "RX FIFO Packets      : 0x%x\n", (reg >> 6) & 0x1fU);
+		len += oal_util_snprintf(buf + len, (size_t)size - len, "TX FIFO Level        : 0x%x\n", (reg >> 12) & 0xffU);
+		len += oal_util_snprintf(buf + len, (size_t)size - len, "RX FIFO Level        : 0x%x\n", (reg >> 20) & 0xffU);
+
+		reg = hal_read32(base_va + GPI_DTX_ASEQ);
+		len += oal_util_snprintf(buf + len, (size_t)size - len, "ASEQ Length          : 0x%x\n", reg);
+
+		reg = hal_read32(base_va + GPI_EMAC_1588_TIMESTAMP_EN);
+		len += oal_util_snprintf(buf + len, (size_t)size - len, "1588 Enable register : 0x%x\n", reg);
+
+		reg = hal_read32(base_va + GPI_OVERRUN_DROPCNT);
+		len += oal_util_snprintf(buf + len, (size_t)size - len, "Overrun Drop Counter : 0x%x\n", reg);
+		hal_write32(0, base_va + GPI_OVERRUN_DROPCNT);
+	}
 
 	return len;
 }
diff --git a/sw/pfe_platform/hw/s32g/pfe_hif_csr.c b/sw/pfe_platform/hw/s32g/pfe_hif_csr.c
index 408b52d..3dac237 100644
--- a/sw/pfe_platform/hw/s32g/pfe_hif_csr.c
+++ b/sw/pfe_platform/hw/s32g/pfe_hif_csr.c
@@ -277,78 +277,80 @@ errno_t pfe_hif_chnl_cfg_isr(addr_t base_va, uint32_t channel_id, pfe_hif_chnl_e
 	if (unlikely(channel_id >= HIF_CFG_MAX_CHANNELS))
 	{
 		NXP_LOG_ERROR("Invalid channel ID in ISR\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	/*	Get enabled interrupts */
-	reg_en = hal_read32(base_va + HIF_CHn_INT_EN(channel_id));
-	/*	Disable ALL */
-	hal_write32(0U, base_va + HIF_CHn_INT_EN(channel_id));
-	/*	Get triggered interrupts */
-	reg_src = hal_read32(base_va + HIF_CHn_INT_SRC(channel_id));
-	/*	ACK triggered */
-	hal_write32(reg_src, base_va + HIF_CHn_INT_SRC(channel_id));
-	/*	Enable the non-triggered ones */
-	hal_write32((reg_en & ~reg_src), base_va + HIF_CHn_INT_EN(channel_id));
-
-	/*	Process interrupts which are triggered AND enabled */
-	if ((reg_src & reg_en & (BDP_CSR_RX_PKT_CH_INT|BDP_CSR_RX_CBD_CH_INT)) != 0U)
-	{
-		*events |= HIF_CHNL_EVT_RX_IRQ;
-		ret = EOK;
-	}
-
-	/*	Process interrupts which are triggered AND enabled */
-	if ((reg_src & reg_en & (BDP_CSR_TX_PKT_CH_INT|BDP_CSR_TX_CBD_CH_INT)) != 0U)
-	{
-		*events |= HIF_CHNL_EVT_TX_IRQ;
-		ret = EOK;
-	}
-
-	if (unlikely(reg_src & reg_en
-			& (	BDP_RD_CSR_RX_TIMEOUT_CH_INT|BDP_WR_CSR_RX_TIMEOUT_CH_INT
-				| BDP_RD_CSR_TX_TIMEOUT_CH_INT|BDP_WR_CSR_TX_TIMEOUT_CH_INT
-				| DXR_CSR_RX_TIMEOUT_CH_INT|DXR_CSR_TX_TIMEOUT_CH_INT)))
+	else
 	{
-		if ((reg_src & reg_en & BDP_RD_CSR_RX_TIMEOUT_CH_INT) != 0U)
+		/*	Get enabled interrupts */
+		reg_en = hal_read32(base_va + HIF_CHn_INT_EN(channel_id));
+		/*	Disable ALL */
+		hal_write32(0U, base_va + HIF_CHn_INT_EN(channel_id));
+		/*	Get triggered interrupts */
+		reg_src = hal_read32(base_va + HIF_CHn_INT_SRC(channel_id));
+		/*	ACK triggered */
+		hal_write32(reg_src, base_va + HIF_CHn_INT_SRC(channel_id));
+		/*	Enable the non-triggered ones */
+		hal_write32((reg_en & ~reg_src), base_va + HIF_CHn_INT_EN(channel_id));
+
+		/*	Process interrupts which are triggered AND enabled */
+		if ((reg_src & reg_en & (BDP_CSR_RX_PKT_CH_INT|BDP_CSR_RX_CBD_CH_INT)) != 0U)
 		{
-			/*	AAVB-2144 */
-			NXP_LOG_INFO("BDP_RD_CSR_RX_TIMEOUT_CH%u_INT. Interrupt disabled.\n", (uint_t)channel_id);
+			*events |= HIF_CHNL_EVT_RX_IRQ;
+			ret = EOK;
 		}
 
-		if ((reg_src & reg_en & BDP_WR_CSR_RX_TIMEOUT_CH_INT) != 0U)
+		/*	Process interrupts which are triggered AND enabled */
+		if ((reg_src & reg_en & (BDP_CSR_TX_PKT_CH_INT|BDP_CSR_TX_CBD_CH_INT)) != 0U)
 		{
-			/*	AAVB-2144 */
-			NXP_LOG_INFO("BDP_WR_CSR_RX_TIMEOUT_CH%u_INT. Interrupt disabled.\n", (uint_t)channel_id);
+			*events |= HIF_CHNL_EVT_TX_IRQ;
+			ret = EOK;
 		}
 
-		if ((reg_src & reg_en & BDP_RD_CSR_TX_TIMEOUT_CH_INT) != 0U)
+		if (unlikely(reg_src & reg_en
+				& (	BDP_RD_CSR_RX_TIMEOUT_CH_INT|BDP_WR_CSR_RX_TIMEOUT_CH_INT
+					| BDP_RD_CSR_TX_TIMEOUT_CH_INT|BDP_WR_CSR_TX_TIMEOUT_CH_INT
+					| DXR_CSR_RX_TIMEOUT_CH_INT|DXR_CSR_TX_TIMEOUT_CH_INT)))
 		{
-			/*	AAVB-2144 */
-			NXP_LOG_INFO("BDP_RD_CSR_TX_TIMEOUT_CH%u_INT. Interrupt disabled.\n", (uint_t)channel_id);
-		}
+			if ((reg_src & reg_en & BDP_RD_CSR_RX_TIMEOUT_CH_INT) != 0U)
+			{
+				/*	AAVB-2144 */
+				NXP_LOG_INFO("BDP_RD_CSR_RX_TIMEOUT_CH%u_INT. Interrupt disabled.\n", (uint_t)channel_id);
+			}
 
-		if ((reg_src & reg_en & BDP_WR_CSR_TX_TIMEOUT_CH_INT) != 0U)
-		{
-			/*	AAVB-2144 */
-			NXP_LOG_INFO("BDP_WR_CSR_TX_TIMEOUT_CH%u_INT. Interrupt disabled.\n", (uint_t)channel_id);
-		}
+			if ((reg_src & reg_en & BDP_WR_CSR_RX_TIMEOUT_CH_INT) != 0U)
+			{
+				/*	AAVB-2144 */
+				NXP_LOG_INFO("BDP_WR_CSR_RX_TIMEOUT_CH%u_INT. Interrupt disabled.\n", (uint_t)channel_id);
+			}
 
-		if ((reg_src & reg_en & DXR_CSR_RX_TIMEOUT_CH_INT) != 0U)
-		{
-			/*	AAVB-2144 */
-			NXP_LOG_INFO("DXR_CSR_RX_TIMEOUT_CH%u_INT. Interrupt disabled.\n", (uint_t)channel_id);
-		}
+			if ((reg_src & reg_en & BDP_RD_CSR_TX_TIMEOUT_CH_INT) != 0U)
+			{
+				/*	AAVB-2144 */
+				NXP_LOG_INFO("BDP_RD_CSR_TX_TIMEOUT_CH%u_INT. Interrupt disabled.\n", (uint_t)channel_id);
+			}
 
-		if ((reg_src & reg_en & DXR_CSR_TX_TIMEOUT_CH_INT) != 0U)
-		{
-			/*	AAVB-2144 */
-			NXP_LOG_INFO("DXR_CSR_TX_TIMEOUT_CH%u_INT. Interrupt disabled.\n", (uint_t)channel_id);
-		}
+			if ((reg_src & reg_en & BDP_WR_CSR_TX_TIMEOUT_CH_INT) != 0U)
+			{
+				/*	AAVB-2144 */
+				NXP_LOG_INFO("BDP_WR_CSR_TX_TIMEOUT_CH%u_INT. Interrupt disabled.\n", (uint_t)channel_id);
+			}
 
-		/*	Don't re-enable these interrupts. See AAVB-2144. */
+			if ((reg_src & reg_en & DXR_CSR_RX_TIMEOUT_CH_INT) != 0U)
+			{
+				/*	AAVB-2144 */
+				NXP_LOG_INFO("DXR_CSR_RX_TIMEOUT_CH%u_INT. Interrupt disabled.\n", (uint_t)channel_id);
+			}
 
-		ret = EOK;
+			if ((reg_src & reg_en & DXR_CSR_TX_TIMEOUT_CH_INT) != 0U)
+			{
+				/*	AAVB-2144 */
+				NXP_LOG_INFO("DXR_CSR_TX_TIMEOUT_CH%u_INT. Interrupt disabled.\n", (uint_t)channel_id);
+			}
+
+			/*	Don't re-enable these interrupts. See AAVB-2144. */
+
+			ret = EOK;
+		}
 	}
 
 	return ret;
@@ -396,18 +398,19 @@ void pfe_hif_chnl_cfg_fini(addr_t base_va, uint32_t channel_id)
 	if (channel_id >= HIF_CFG_MAX_CHANNELS)
 	{
 		NXP_LOG_ERROR("Unsupported channel ID: %u\n", (uint_t)channel_id);
-		return;
 	}
+	else
+	{
+		/*	Disable the coalescence timer */
+		hal_write32(0x0U, base_va + HIF_INT_COAL_EN_CHn(channel_id));
 
-	/*	Disable the coalescence timer */
-	hal_write32(0x0U, base_va + HIF_INT_COAL_EN_CHn(channel_id));
+		/*	Disable RX/TX */
+		pfe_hif_chnl_cfg_rx_disable(base_va, channel_id);
+		pfe_hif_chnl_cfg_tx_disable(base_va, channel_id);
 
-	/*	Disable RX/TX */
-	pfe_hif_chnl_cfg_rx_disable(base_va, channel_id);
-	pfe_hif_chnl_cfg_tx_disable(base_va, channel_id);
-
-	/*	Disable all interrupts */
-	hal_write32(0U, base_va + HIF_CHn_INT_EN(channel_id));
+		/*	Disable all interrupts */
+		hal_write32(0U, base_va + HIF_CHn_INT_EN(channel_id));
+	}
 }
 
 /**
@@ -418,6 +421,7 @@ void pfe_hif_chnl_cfg_fini(addr_t base_va, uint32_t channel_id)
  */
 errno_t pfe_hif_cfg_init(addr_t base_va)
 {
+	errno_t ret = EOK;
 #ifdef PFE_CFG_PFE_MASTER
 	uint32_t ii = 0u;
 
@@ -438,7 +442,8 @@ errno_t pfe_hif_cfg_init(addr_t base_va)
 		{
 			if (++ii > 1000u)
 			{
-				return ETIMEDOUT;
+				ret = ETIMEDOUT;
+				break;
 			}
 			else
 			{
@@ -447,34 +452,37 @@ errno_t pfe_hif_cfg_init(addr_t base_va)
 		}
 	}
 
-#if (TRUE == PFE_HIF_CFG_USE_BD_POLLING)
-	hal_write32((0xffUL << 16U) | (0xffUL), base_va + HIF_TX_POLL_CTRL);
-	hal_write32((0xffUL << 16U) | (0xffUL), base_va + HIF_RX_POLL_CTRL);
-#endif /* PFE_HIF_CFG_USE_BD_POLLING */
-
-    /*    MICS */
-    hal_write32(0U
-            /* | BDPRD_AXI_WRITE_DONE */
-            /* | DBPWR_AXI_WRITE_DONE */
-            /* | RXDXR_AXI_WRITE_DONE */
-            /* | TXDXR_AXI_WRITE_DONE */
-            | HIF_TIMEOUT_EN
-            | BD_START_SEQ_NUM(0x0U)
-            , base_va + HIF_MISC);
-
-	hal_write32(100000000U, base_va + HIF_TIMEOUT_REG);
-	hal_write32(0x33221100U, base_va + HIF_RX_QUEUE_MAP_CH_NO_ADDR);
-	hal_write32(0x0U, base_va + HIF_DMA_BURST_SIZE_ADDR); /* 0 = 128B, 1 = 256B, 2 = 512B, 3 = 1024B */
-	hal_write32(0x0U, base_va + HIF_DMA_BASE_ADDR);
-	hal_write32(0x0U, base_va + HIF_LTC_PKT_CTRL_ADDR); /* Must stay disabled. LTC hijaked for Master-detect feature */
-	hal_write32(0xffffffffU & ~(HIF_ERR_INT), base_va + HIF_ERR_INT_EN);
-	hal_write32(0xffffffffU & ~(HIF_TX_FIFO_ERR_INT), base_va + HIF_TX_FIFO_ERR_INT_EN);
-	hal_write32(0xffffffffU  & ~(HIF_RX_FIFO_ERR_INT), base_va + HIF_RX_FIFO_ERR_INT_EN);
+	if (EOK == ret)
+	{
+	#if (TRUE == PFE_HIF_CFG_USE_BD_POLLING)
+		hal_write32((0xffUL << 16U) | (0xffUL), base_va + HIF_TX_POLL_CTRL);
+		hal_write32((0xffUL << 16U) | (0xffUL), base_va + HIF_RX_POLL_CTRL);
+	#endif /* PFE_HIF_CFG_USE_BD_POLLING */
+
+		/*    MICS */
+		hal_write32(0U
+				/* | BDPRD_AXI_WRITE_DONE */
+				/* | DBPWR_AXI_WRITE_DONE */
+				/* | RXDXR_AXI_WRITE_DONE */
+				/* | TXDXR_AXI_WRITE_DONE */
+				| HIF_TIMEOUT_EN
+				| BD_START_SEQ_NUM(0x0U)
+				, base_va + HIF_MISC);
+
+		hal_write32(100000000U, base_va + HIF_TIMEOUT_REG);
+		hal_write32(0x33221100U, base_va + HIF_RX_QUEUE_MAP_CH_NO_ADDR);
+		hal_write32(0x0U, base_va + HIF_DMA_BURST_SIZE_ADDR); /* 0 = 128B, 1 = 256B, 2 = 512B, 3 = 1024B */
+		hal_write32(0x0U, base_va + HIF_DMA_BASE_ADDR);
+		hal_write32(0x0U, base_va + HIF_LTC_PKT_CTRL_ADDR); /* Must stay disabled. LTC hijaked for Master-detect feature */
+		hal_write32(0xffffffffU & ~(HIF_ERR_INT), base_va + HIF_ERR_INT_EN);
+		hal_write32(0xffffffffU & ~(HIF_TX_FIFO_ERR_INT), base_va + HIF_TX_FIFO_ERR_INT_EN);
+		hal_write32(0xffffffffU  & ~(HIF_RX_FIFO_ERR_INT), base_va + HIF_RX_FIFO_ERR_INT_EN);
+	}
 #else
     (void)base_va;
 #endif /* PFE_CFG_PFE_MASTER */
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -512,22 +520,23 @@ void pfe_hif_chnl_cfg_tx_enable(addr_t base_va, uint32_t channel_id)
 	if (channel_id >= HIF_CFG_MAX_CHANNELS)
 	{
 		NXP_LOG_ERROR("Unsupported channel ID: %u\n", (uint_t)channel_id);
-		return;
 	}
+	else
+	{
+		/*	Enable DMA engine */
+		reg = hal_read32(base_va + HIF_CTRL_CHn(channel_id));
 
-	/*	Enable DMA engine */
-	reg = hal_read32(base_va + HIF_CTRL_CHn(channel_id));
+	#if (TRUE == PFE_HIF_CFG_USE_BD_POLLING)
+		reg |= TX_BDP_POLL_CNTR_EN;
+	#endif /* PFE_HIF_CFG_USE_BD_POLLING */
 
-#if (TRUE == PFE_HIF_CFG_USE_BD_POLLING)
-	reg |= TX_BDP_POLL_CNTR_EN;
-#endif /* PFE_HIF_CFG_USE_BD_POLLING */
+		reg |= TX_DMA_ENABLE;
+		hal_write32(reg, base_va + HIF_CTRL_CHn(channel_id));
 
-	reg |= TX_DMA_ENABLE;
-	hal_write32(reg, base_va + HIF_CTRL_CHn(channel_id));
-
-#if (TRUE == PFE_HIF_CFG_USE_BD_POLLING)
-	pfe_hif_chnl_cfg_tx_dma_start(base_va, channel_id);
-#endif /* PFE_HIF_CFG_USE_BD_POLLING */
+	#if (TRUE == PFE_HIF_CFG_USE_BD_POLLING)
+		pfe_hif_chnl_cfg_tx_dma_start(base_va, channel_id);
+	#endif /* PFE_HIF_CFG_USE_BD_POLLING */
+	}
 }
 
 /**
@@ -542,15 +551,16 @@ void pfe_hif_chnl_cfg_tx_disable(addr_t base_va, uint32_t channel_id)
 	if (channel_id >= HIF_CFG_MAX_CHANNELS)
 	{
 		NXP_LOG_ERROR("Unsupported channel ID: %u\n", (uint_t)channel_id);
-		return;
 	}
+	else
+	{
+		reg = hal_read32(base_va + HIF_CTRL_CHn(channel_id));
+		reg &= ~(TX_DMA_ENABLE|TX_BDP_POLL_CNTR_EN);
+		hal_write32(reg, base_va + HIF_CTRL_CHn(channel_id));
 
-	reg = hal_read32(base_va + HIF_CTRL_CHn(channel_id));
-	reg &= ~(TX_DMA_ENABLE|TX_BDP_POLL_CNTR_EN);
-	hal_write32(reg, base_va + HIF_CTRL_CHn(channel_id));
-
-	/*	Disable TX IRQ */
-	pfe_hif_chnl_cfg_tx_irq_mask(base_va, channel_id);
+		/*	Disable TX IRQ */
+		pfe_hif_chnl_cfg_tx_irq_mask(base_va, channel_id);
+	}
 }
 
 /**
@@ -565,21 +575,23 @@ void pfe_hif_chnl_cfg_rx_enable(addr_t base_va, uint32_t channel_id)
 	if (channel_id >= HIF_CFG_MAX_CHANNELS)
 	{
 		NXP_LOG_ERROR("Unsupported channel ID: %u\n", (uint_t)channel_id);
-		return;
 	}
+	else
+	{
 
-	reg = hal_read32(base_va + HIF_CTRL_CHn(channel_id));
+		reg = hal_read32(base_va + HIF_CTRL_CHn(channel_id));
 
-#if (TRUE == PFE_HIF_CFG_USE_BD_POLLING)
-	reg |= RX_BDP_POLL_CNTR_EN;
-#endif /* PFE_HIF_CFG_USE_BD_POLLING */
+	#if (TRUE == PFE_HIF_CFG_USE_BD_POLLING)
+		reg |= RX_BDP_POLL_CNTR_EN;
+	#endif /* PFE_HIF_CFG_USE_BD_POLLING */
 
-	reg |= RX_DMA_ENABLE;
-	hal_write32(reg, base_va + HIF_CTRL_CHn(channel_id));
+		reg |= RX_DMA_ENABLE;
+		hal_write32(reg, base_va + HIF_CTRL_CHn(channel_id));
 
-#if (FALSE == PFE_HIF_CFG_USE_BD_POLLING)
-	pfe_hif_chnl_cfg_rx_dma_start(base_va, channel_id);
-#endif /* PFE_HIF_CFG_USE_BD_POLLING */
+	#if (FALSE == PFE_HIF_CFG_USE_BD_POLLING)
+		pfe_hif_chnl_cfg_rx_dma_start(base_va, channel_id);
+	#endif /* PFE_HIF_CFG_USE_BD_POLLING */
+	}
 }
 
 /**
@@ -594,14 +606,15 @@ void pfe_hif_chnl_cfg_rx_disable(addr_t base_va, uint32_t channel_id)
 	if (channel_id >= HIF_CFG_MAX_CHANNELS)
 	{
 		NXP_LOG_ERROR("Unsupported channel ID: %u\n", (uint_t)channel_id);
-		return;
 	}
+	else
+	{
+		reg = hal_read32(base_va + HIF_CTRL_CHn(channel_id));
+		reg &= ~(RX_DMA_ENABLE|RX_BDP_POLL_CNTR_EN);
+		hal_write32(reg, base_va + HIF_CTRL_CHn(channel_id));
 
-	reg = hal_read32(base_va + HIF_CTRL_CHn(channel_id));
-	reg &= ~(RX_DMA_ENABLE|RX_BDP_POLL_CNTR_EN);
-	hal_write32(reg, base_va + HIF_CTRL_CHn(channel_id));
-
-	pfe_hif_chnl_cfg_rx_irq_mask(base_va, channel_id);
+		pfe_hif_chnl_cfg_rx_irq_mask(base_va, channel_id);
+	}
 }
 
 /**
@@ -747,11 +760,12 @@ void pfe_hif_chnl_cfg_set_rx_bd_ring_addr(addr_t base_va, uint32_t channel_id, c
 	if (channel_id >= HIF_CFG_MAX_CHANNELS)
 	{
 		NXP_LOG_ERROR("Unsupported channel ID: %u\n", (uint_t)channel_id);
-		return;
 	}
-
-	hal_write32((uint32_t)((addr_t)rx_ring_pa & 0xffffffffU), base_va + HIF_RX_BDP_RD_LOW_ADDR_CHn(channel_id));
-	hal_write32(0U, base_va + HIF_RX_BDP_RD_HIGH_ADDR_CHn(channel_id));
+	else
+	{
+		hal_write32((uint32_t)((addr_t)rx_ring_pa & 0xffffffffU), base_va + HIF_RX_BDP_RD_LOW_ADDR_CHn(channel_id));
+		hal_write32(0U, base_va + HIF_RX_BDP_RD_HIGH_ADDR_CHn(channel_id));
+	}
 }
 
 /**
@@ -766,18 +780,17 @@ void pfe_hif_chnl_cfg_set_rx_wb_table(addr_t base_va, uint32_t channel_id, const
 	if (channel_id >= HIF_CFG_MAX_CHANNELS)
 	{
 		NXP_LOG_ERROR("Unsupported channel ID: %u\n", (uint_t)channel_id);
-		return;
 	}
-
-	if (tbl_len > 0xffffU)
+	else if (tbl_len > 0xffffU)
 	{
 		NXP_LOG_ERROR("Unsupported WB table size: %u\n", (uint_t)tbl_len);
-		return;
 	}
-
-	hal_write32((uint32_t)((addr_t)wb_tbl_pa & 0xffffffffU), base_va + HIF_RX_BDP_WR_LOW_ADDR_CHn(channel_id));
-	hal_write32(0U, base_va + HIF_RX_BDP_WR_HIGH_ADDR_CHn(channel_id));
-	hal_write32(tbl_len, base_va + HIF_RX_WRBK_BD_CHn_BUFFER_SIZE(channel_id));
+	else
+	{
+		hal_write32((uint32_t)((addr_t)wb_tbl_pa & 0xffffffffU), base_va + HIF_RX_BDP_WR_LOW_ADDR_CHn(channel_id));
+		hal_write32(0U, base_va + HIF_RX_BDP_WR_HIGH_ADDR_CHn(channel_id));
+		hal_write32(tbl_len, base_va + HIF_RX_WRBK_BD_CHn_BUFFER_SIZE(channel_id));
+	}
 }
 
 /**
@@ -791,11 +804,12 @@ void pfe_hif_chnl_cfg_set_tx_bd_ring_addr(addr_t base_va, uint32_t channel_id, c
 	if (channel_id >= HIF_CFG_MAX_CHANNELS)
 	{
 		NXP_LOG_ERROR("Unsupported channel ID: %u\n", (uint_t)channel_id);
-		return;
 	}
-
-	hal_write32((uint32_t)((addr_t)tx_ring_pa & 0xffffffffU), base_va + HIF_TX_BDP_RD_LOW_ADDR_CHn(channel_id));
-	hal_write32(0U, base_va + HIF_TX_BDP_RD_HIGH_ADDR_CHn(channel_id));
+	else
+	{
+		hal_write32((uint32_t)((addr_t)tx_ring_pa & 0xffffffffU), base_va + HIF_TX_BDP_RD_LOW_ADDR_CHn(channel_id));
+		hal_write32(0U, base_va + HIF_TX_BDP_RD_HIGH_ADDR_CHn(channel_id));
+	}
 }
 
 /**
@@ -810,18 +824,17 @@ void pfe_hif_chnl_cfg_set_tx_wb_table(addr_t base_va, uint32_t channel_id, const
 	if (channel_id >= HIF_CFG_MAX_CHANNELS)
 	{
 		NXP_LOG_ERROR("Unsupported channel ID: %u\n", (uint_t)channel_id);
-		return;
 	}
-
-	if (tbl_len > 0xffffU)
+	else if (tbl_len > 0xffffU)
 	{
 		NXP_LOG_ERROR("Unsupported WB table size: %u\n", (uint_t)tbl_len);
-		return;
 	}
-
-	hal_write32((uint32_t)((addr_t)wb_tbl_pa & 0xffffffffU), base_va + HIF_TX_BDP_WR_LOW_ADDR_CHn(channel_id));
-	hal_write32(0U, base_va + HIF_TX_BDP_WR_HIGH_ADDR_CHn(channel_id));
-	hal_write32(tbl_len, base_va + HIF_TX_WRBK_BD_CHn_BUFFER_SIZE(channel_id));
+	else
+	{
+		hal_write32((uint32_t)((addr_t)wb_tbl_pa & 0xffffffffU), base_va + HIF_TX_BDP_WR_LOW_ADDR_CHn(channel_id));
+		hal_write32(0U, base_va + HIF_TX_BDP_WR_HIGH_ADDR_CHn(channel_id));
+		hal_write32(tbl_len, base_va + HIF_TX_WRBK_BD_CHn_BUFFER_SIZE(channel_id));
+	}
 }
 
 /**
@@ -833,6 +846,7 @@ void pfe_hif_chnl_cfg_set_tx_wb_table(addr_t base_va, uint32_t channel_id, const
 bool_t pfe_hif_chnl_cfg_is_rx_dma_active(addr_t base_va, uint32_t channel_id)
 {
 	uint32_t reg;
+	bool_t ret;
 
 	(void)channel_id;
 
@@ -840,12 +854,13 @@ bool_t pfe_hif_chnl_cfg_is_rx_dma_active(addr_t base_va, uint32_t channel_id)
 
 	if (0U != reg)
 	{
-		return TRUE;
+		ret = TRUE;
 	}
 	else
 	{
-		return FALSE;
+		ret = FALSE;
 	}
+	return ret;
 }
 
 /**
@@ -857,6 +872,7 @@ bool_t pfe_hif_chnl_cfg_is_rx_dma_active(addr_t base_va, uint32_t channel_id)
 bool_t pfe_hif_chnl_cfg_is_tx_dma_active(addr_t base_va, uint32_t channel_id)
 {
 	uint32_t reg;
+	bool_t ret;
 
 	(void)channel_id;
 
@@ -864,12 +880,13 @@ bool_t pfe_hif_chnl_cfg_is_tx_dma_active(addr_t base_va, uint32_t channel_id)
 
 	if (0U != reg)
 	{
-		return TRUE;
+		ret = TRUE;
 	}
 	else
 	{
-		return FALSE;
+		ret = FALSE;
 	}
+	return ret;
 }
 
 /**
@@ -1091,100 +1108,103 @@ uint32_t pfe_hif_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, u
 	if (unlikely(NULL_ADDR == base_va))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return 0U;
+		len = 0U;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-	/* Debug registers */
-	if(verb_level >= 10U)
-	{
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_STATE               : 0x%x\n", hal_read32(base_va + HIF_TX_STATE));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_ACTV                : 0x%x\n", hal_read32(base_va + HIF_TX_ACTV));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_CURR_CH_NO          : 0x%x\n", hal_read32(base_va + HIF_TX_CURR_CH_NO));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_DXR_TX_FIFO_CNT        : 0x%x\n", hal_read32(base_va + HIF_DXR_TX_FIFO_CNT));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_CTRL_WORD_FIFO_CNT1 : 0x%x\n", hal_read32(base_va + HIF_TX_CTRL_WORD_FIFO_CNT1));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_CTRL_WORD_FIFO_CNT2 : 0x%x\n", hal_read32(base_va + HIF_TX_CTRL_WORD_FIFO_CNT2));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_BVALID_FIFO_CNT     : 0x%x\n", hal_read32(base_va + HIF_TX_BVALID_FIFO_CNT));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_PKT_CNT1            : 0x%x\n", hal_read32(base_va + HIF_TX_PKT_CNT1));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_PKT_CNT2            : 0x%x\n", hal_read32(base_va + HIF_TX_PKT_CNT2));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_STATE               : 0x%x\n", hal_read32(base_va + HIF_RX_STATE));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_ACTV                : 0x%x\n", hal_read32(base_va + HIF_RX_ACTV));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_CURR_CH_NO          : 0x%x\n", hal_read32(base_va + HIF_RX_CURR_CH_NO));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_DXR_RX_FIFO_CNT        : 0x%x\n", hal_read32(base_va + HIF_DXR_RX_FIFO_CNT));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_CTRL_WORD_FIFO_CNT  : 0x%x\n", hal_read32(base_va + HIF_RX_CTRL_WORD_FIFO_CNT));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_BVALID_FIFO_CNT     : 0x%x\n", hal_read32(base_va + HIF_RX_BVALID_FIFO_CNT));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_PKT_CNT1            : 0x%x\n", hal_read32(base_va + HIF_RX_PKT_CNT1));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_PKT_CNT2            : 0x%x\n", hal_read32(base_va + HIF_RX_PKT_CNT2));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_CH0_INT_SRC:        : 0x%x\n", hal_read32(base_va + HIF_CH0_INT_SRC));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_BDP_CH0_TX_FIFO_CNT : 0x%x\n", hal_read32(base_va + HIF_BDP_CH0_TX_FIFO_CNT));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_DMA_STATUS_0_CH0 : 0x%x\n", hal_read32(base_va + HIF_TX_DMA_STATUS_0_CH0));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_STATUS_0_CH0     : 0x%x\n", hal_read32(base_va + HIF_TX_STATUS_0_CH0));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_STATUS_1_CH0     : 0x%x\n", hal_read32(base_va + HIF_TX_STATUS_1_CH0));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_PKT_CNT0_CH0     : 0x%x\n", hal_read32(base_va + HIF_TX_PKT_CNT0_CH0));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_PKT_CNT1_CH0     : 0x%x\n", hal_read32(base_va + HIF_TX_PKT_CNT1_CH0));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_PKT_CNT2_CH0     : 0x%x\n", hal_read32(base_va + HIF_TX_PKT_CNT2_CH0));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_BDP_CH0_RX_FIFO_CNT : 0x%x\n", hal_read32(base_va + HIF_BDP_CH0_RX_FIFO_CNT));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_DMA_STATUS_0_CH0 : 0x%x\n", hal_read32(base_va + HIF_RX_DMA_STATUS_0_CH0));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_STATUS_0_CH0     : 0x%x\n", hal_read32(base_va + HIF_RX_STATUS_0_CH0));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_PKT_CNT0_CH0     : 0x%x\n", hal_read32(base_va + HIF_RX_PKT_CNT0_CH0));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_PKT_CNT1_CH0     : 0x%x\n", hal_read32(base_va + HIF_RX_PKT_CNT1_CH0));
-	}
-
-	if(verb_level>=9U)
 	{
-		/*	Get version */
-		reg = hal_read32(base_va + HIF_VERSION);
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Revision                  : 0x%x\n", (reg >> 24U) & 0xffU);
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Version                   : 0x%x\n", (reg >> 16U) & 0xffU);
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "ID                        : 0x%x\n", reg & 0xffffU);
-	}
+		/* Debug registers */
+		if(verb_level >= 10U)
+		{
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_STATE               : 0x%x\n", hal_read32(base_va + HIF_TX_STATE));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_ACTV                : 0x%x\n", hal_read32(base_va + HIF_TX_ACTV));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_CURR_CH_NO          : 0x%x\n", hal_read32(base_va + HIF_TX_CURR_CH_NO));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_DXR_TX_FIFO_CNT        : 0x%x\n", hal_read32(base_va + HIF_DXR_TX_FIFO_CNT));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_CTRL_WORD_FIFO_CNT1 : 0x%x\n", hal_read32(base_va + HIF_TX_CTRL_WORD_FIFO_CNT1));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_CTRL_WORD_FIFO_CNT2 : 0x%x\n", hal_read32(base_va + HIF_TX_CTRL_WORD_FIFO_CNT2));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_BVALID_FIFO_CNT     : 0x%x\n", hal_read32(base_va + HIF_TX_BVALID_FIFO_CNT));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_PKT_CNT1            : 0x%x\n", hal_read32(base_va + HIF_TX_PKT_CNT1));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_PKT_CNT2            : 0x%x\n", hal_read32(base_va + HIF_TX_PKT_CNT2));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_STATE               : 0x%x\n", hal_read32(base_va + HIF_RX_STATE));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_ACTV                : 0x%x\n", hal_read32(base_va + HIF_RX_ACTV));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_CURR_CH_NO          : 0x%x\n", hal_read32(base_va + HIF_RX_CURR_CH_NO));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_DXR_RX_FIFO_CNT        : 0x%x\n", hal_read32(base_va + HIF_DXR_RX_FIFO_CNT));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_CTRL_WORD_FIFO_CNT  : 0x%x\n", hal_read32(base_va + HIF_RX_CTRL_WORD_FIFO_CNT));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_BVALID_FIFO_CNT     : 0x%x\n", hal_read32(base_va + HIF_RX_BVALID_FIFO_CNT));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_PKT_CNT1            : 0x%x\n", hal_read32(base_va + HIF_RX_PKT_CNT1));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_PKT_CNT2            : 0x%x\n", hal_read32(base_va + HIF_RX_PKT_CNT2));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_CH0_INT_SRC:        : 0x%x\n", hal_read32(base_va + HIF_CH0_INT_SRC));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_BDP_CH0_TX_FIFO_CNT : 0x%x\n", hal_read32(base_va + HIF_BDP_CH0_TX_FIFO_CNT));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_DMA_STATUS_0_CH0 : 0x%x\n", hal_read32(base_va + HIF_TX_DMA_STATUS_0_CH0));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_STATUS_0_CH0     : 0x%x\n", hal_read32(base_va + HIF_TX_STATUS_0_CH0));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_STATUS_1_CH0     : 0x%x\n", hal_read32(base_va + HIF_TX_STATUS_1_CH0));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_PKT_CNT0_CH0     : 0x%x\n", hal_read32(base_va + HIF_TX_PKT_CNT0_CH0));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_PKT_CNT1_CH0     : 0x%x\n", hal_read32(base_va + HIF_TX_PKT_CNT1_CH0));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_TX_PKT_CNT2_CH0     : 0x%x\n", hal_read32(base_va + HIF_TX_PKT_CNT2_CH0));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_BDP_CH0_RX_FIFO_CNT : 0x%x\n", hal_read32(base_va + HIF_BDP_CH0_RX_FIFO_CNT));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_DMA_STATUS_0_CH0 : 0x%x\n", hal_read32(base_va + HIF_RX_DMA_STATUS_0_CH0));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_STATUS_0_CH0     : 0x%x\n", hal_read32(base_va + HIF_RX_STATUS_0_CH0));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_PKT_CNT0_CH0     : 0x%x\n", hal_read32(base_va + HIF_RX_PKT_CNT0_CH0));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_PKT_CNT1_CH0     : 0x%x\n", hal_read32(base_va + HIF_RX_PKT_CNT1_CH0));
+		}
 
-	reg = hal_read32(base_va + HIF_RX_STATE);
-	len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_STATE              : 0x%x\n", reg);
-	reg = hal_read32(base_va + HIF_RX_ACTV);
-	len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_ACTV               : 0x%x\n", reg);
-	reg = hal_read32(base_va + HIF_RX_CURR_CH_NO);
-	len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_CURR_CH_NO         : 0x%x\n", reg);
-	reg = hal_read32(base_va + HIF_DXR_RX_FIFO_CNT);
-	len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_DXR_RX_FIFO_CNT       : 0x%x\n", reg);
-	reg = hal_read32(base_va + HIF_RX_CTRL_WORD_FIFO_CNT);
-	len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_CTRL_WORD_FIFO_CNT : 0x%x\n", reg);
-	reg = hal_read32(base_va + HIF_RX_BVALID_FIFO_CNT);
-	len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_BVALID_FIFO_CNT    : 0x%x\n", reg);
-	reg = hal_read32(base_va + HIF_RX_BVALID_FIFO_CNT);
-	len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_BVALID_FIFO_CNT    : 0x%x\n", reg);
-	reg = hal_read32(base_va + HIF_RX_PKT_CNT1);
-	len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_PKT_CNT1           : 0x%x\n", reg);
-	reg = hal_read32(base_va + HIF_RX_PKT_CNT2);
-	len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_PKT_CNT2           : 0x%x\n", reg);
-
-	reg = hal_read32(base_va + HIF_INT_SRC);
-	len += oal_util_snprintf(buf + len, size - len, "HIF_INT_SRC               : 0x%x\n", reg);
-	reg = hal_read32(base_va + HIF_ERR_INT_SRC);
-	len += oal_util_snprintf(buf + len, size - len, "HIF_ERR_INT_SRC           : 0x%x\n", reg);
-	reg = hal_read32(base_va + HIF_TX_FIFO_ERR_INT_SRC);
-	len += oal_util_snprintf(buf + len, size - len, "HIF_TX_FIFO_ERR_INT_SRC   : 0x%x\n", reg);
-	reg = hal_read32(base_va + HIF_RX_FIFO_ERR_INT_SRC);
-	len += oal_util_snprintf(buf + len, size - len, "HIF_RX_FIFO_ERR_INT_SRC   : 0x%x\n", reg);
-	reg = hal_read32(base_va + HIF_TX_STATE);
-	len += oal_util_snprintf(buf + len, size - len, "HIF_TX_STATE              : 0x%x\n", reg);
-	reg = hal_read32(base_va + HIF_TX_ACTV);
-	len += oal_util_snprintf(buf + len, size - len, "HIF_TX_ACTV               : 0x%x\n", reg);
-	reg = hal_read32(base_va + HIF_TX_CURR_CH_NO);
-	len += oal_util_snprintf(buf + len, size - len, "HIF_TX_CURR_CH_NO         : 0x%x\n", reg);
-	reg = hal_read32(base_va + HIF_DXR_TX_FIFO_CNT);
-	len += oal_util_snprintf(buf + len, size - len, "HIF_DXR_TX_FIFO_CNT       : 0x%x\n", reg);
-	reg = hal_read32(base_va + HIF_TX_CTRL_WORD_FIFO_CNT1);
-	len += oal_util_snprintf(buf + len, size - len, "HIF_TX_CTRL_WORD_FIFO_CNT1: 0x%x\n", reg);
-	reg = hal_read32(base_va + HIF_TX_CTRL_WORD_FIFO_CNT2);
-	len += oal_util_snprintf(buf + len, size - len, "HIF_TX_CTRL_WORD_FIFO_CNT2: 0x%x\n", reg);
-	reg = hal_read32(base_va + HIF_TX_BVALID_FIFO_CNT);
-	len += oal_util_snprintf(buf + len, size - len, "HIF_TX_BVALID_FIFO_CNT    : 0x%x\n", reg);
-	reg = hal_read32(base_va + HIF_TX_PKT_CNT1);
-	len += oal_util_snprintf(buf + len, size - len, "HIF_TX_PKT_CNT1           : 0x%x\n", reg);
-	reg = hal_read32(base_va + HIF_TX_PKT_CNT2);
-	len += oal_util_snprintf(buf + len, size - len, "HIF_TX_PKT_CNT2           : 0x%x\n", reg);
+		if(verb_level>=9U)
+		{
+			/*	Get version */
+			reg = hal_read32(base_va + HIF_VERSION);
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Revision                  : 0x%x\n", (reg >> 24U) & 0xffU);
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Version                   : 0x%x\n", (reg >> 16U) & 0xffU);
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "ID                        : 0x%x\n", reg & 0xffffU);
+		}
 
-	dump_hif_channel(base_va, 0U);
+		reg = hal_read32(base_va + HIF_RX_STATE);
+		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_STATE              : 0x%x\n", reg);
+		reg = hal_read32(base_va + HIF_RX_ACTV);
+		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_ACTV               : 0x%x\n", reg);
+		reg = hal_read32(base_va + HIF_RX_CURR_CH_NO);
+		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_CURR_CH_NO         : 0x%x\n", reg);
+		reg = hal_read32(base_va + HIF_DXR_RX_FIFO_CNT);
+		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_DXR_RX_FIFO_CNT       : 0x%x\n", reg);
+		reg = hal_read32(base_va + HIF_RX_CTRL_WORD_FIFO_CNT);
+		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_CTRL_WORD_FIFO_CNT : 0x%x\n", reg);
+		reg = hal_read32(base_va + HIF_RX_BVALID_FIFO_CNT);
+		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_BVALID_FIFO_CNT    : 0x%x\n", reg);
+		reg = hal_read32(base_va + HIF_RX_BVALID_FIFO_CNT);
+		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_BVALID_FIFO_CNT    : 0x%x\n", reg);
+		reg = hal_read32(base_va + HIF_RX_PKT_CNT1);
+		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_PKT_CNT1           : 0x%x\n", reg);
+		reg = hal_read32(base_va + HIF_RX_PKT_CNT2);
+		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_RX_PKT_CNT2           : 0x%x\n", reg);
+
+		reg = hal_read32(base_va + HIF_INT_SRC);
+		len += oal_util_snprintf(buf + len, size - len, "HIF_INT_SRC               : 0x%x\n", reg);
+		reg = hal_read32(base_va + HIF_ERR_INT_SRC);
+		len += oal_util_snprintf(buf + len, size - len, "HIF_ERR_INT_SRC           : 0x%x\n", reg);
+		reg = hal_read32(base_va + HIF_TX_FIFO_ERR_INT_SRC);
+		len += oal_util_snprintf(buf + len, size - len, "HIF_TX_FIFO_ERR_INT_SRC   : 0x%x\n", reg);
+		reg = hal_read32(base_va + HIF_RX_FIFO_ERR_INT_SRC);
+		len += oal_util_snprintf(buf + len, size - len, "HIF_RX_FIFO_ERR_INT_SRC   : 0x%x\n", reg);
+		reg = hal_read32(base_va + HIF_TX_STATE);
+		len += oal_util_snprintf(buf + len, size - len, "HIF_TX_STATE              : 0x%x\n", reg);
+		reg = hal_read32(base_va + HIF_TX_ACTV);
+		len += oal_util_snprintf(buf + len, size - len, "HIF_TX_ACTV               : 0x%x\n", reg);
+		reg = hal_read32(base_va + HIF_TX_CURR_CH_NO);
+		len += oal_util_snprintf(buf + len, size - len, "HIF_TX_CURR_CH_NO         : 0x%x\n", reg);
+		reg = hal_read32(base_va + HIF_DXR_TX_FIFO_CNT);
+		len += oal_util_snprintf(buf + len, size - len, "HIF_DXR_TX_FIFO_CNT       : 0x%x\n", reg);
+		reg = hal_read32(base_va + HIF_TX_CTRL_WORD_FIFO_CNT1);
+		len += oal_util_snprintf(buf + len, size - len, "HIF_TX_CTRL_WORD_FIFO_CNT1: 0x%x\n", reg);
+		reg = hal_read32(base_va + HIF_TX_CTRL_WORD_FIFO_CNT2);
+		len += oal_util_snprintf(buf + len, size - len, "HIF_TX_CTRL_WORD_FIFO_CNT2: 0x%x\n", reg);
+		reg = hal_read32(base_va + HIF_TX_BVALID_FIFO_CNT);
+		len += oal_util_snprintf(buf + len, size - len, "HIF_TX_BVALID_FIFO_CNT    : 0x%x\n", reg);
+		reg = hal_read32(base_va + HIF_TX_PKT_CNT1);
+		len += oal_util_snprintf(buf + len, size - len, "HIF_TX_PKT_CNT1           : 0x%x\n", reg);
+		reg = hal_read32(base_va + HIF_TX_PKT_CNT2);
+		len += oal_util_snprintf(buf + len, size - len, "HIF_TX_PKT_CNT2           : 0x%x\n", reg);
+
+		dump_hif_channel(base_va, 0U);
+	}
 
 	return len;
 }
diff --git a/sw/pfe_platform/hw/s32g/pfe_hif_nocpy_csr.c b/sw/pfe_platform/hw/s32g/pfe_hif_nocpy_csr.c
index 492dd64..e208b8b 100644
--- a/sw/pfe_platform/hw/s32g/pfe_hif_nocpy_csr.c
+++ b/sw/pfe_platform/hw/s32g/pfe_hif_nocpy_csr.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2021 NXP
+ *  Copyright 2018-2022 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -343,17 +343,16 @@ void pfe_hif_nocpy_cfg_set_tx_bd_ring_addr(addr_t base_va, const void *tx_ring_p
 bool_t pfe_hif_nocpy_cfg_is_rx_dma_active(addr_t base_va)
 {
 	uint32_t reg;
+	bool_t ret = FALSE;
 
 	reg = hal_read32(base_va + HIF_NOCPY_RX_STATUS);
 
 	if (0U != (reg & (0xfUL << 18U)))
 	{
-		return TRUE;
-	}
-	else
-	{
-		return FALSE;
+		ret = TRUE;
 	}
+
+	return ret;
 }
 
 /**
@@ -365,17 +364,16 @@ bool_t pfe_hif_nocpy_cfg_is_rx_dma_active(addr_t base_va)
 bool_t pfe_hif_nocpy_cfg_is_tx_dma_active(addr_t base_va)
 {
 	uint32_t reg;
+	bool_t ret = FALSE;
 
 	reg = hal_read32(base_va + HIF_NOCPY_TX_STATUS);
 
 	if (0U != (reg & (0xfUL << 18U)))
 	{
-		return TRUE;
-	}
-	else
-	{
-		return FALSE;
+		ret = TRUE;
 	}
+
+	return ret;
 }
 
 /**
@@ -438,27 +436,29 @@ uint32_t pfe_hif_nocpy_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t s
 	if (unlikely(NULL_ADDR == base_va))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return 0U;
+		len = 0U;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	/*	Get version */
-	if(verb_level >= 9U)
 	{
-		reg = hal_read32(base_va + HIF_NOCPY_VERSION);
-		len += oal_util_snprintf(buf + len, size - len, "Revision             : 0x%x\n", (reg >> 24U) & 0xffU);
-		len += oal_util_snprintf(buf + len, size - len, "Version              : 0x%x\n", (reg >> 16U) & 0xffU);
-		len += oal_util_snprintf(buf + len, size - len, "ID                   : 0x%x\n", reg & 0xffffU);
+		/*	Get version */
+		if(verb_level >= 9U)
+		{
+			reg = hal_read32(base_va + HIF_NOCPY_VERSION);
+			len += oal_util_snprintf(buf + len, size - len, "Revision             : 0x%x\n", (reg >> 24U) & 0xffU);
+			len += oal_util_snprintf(buf + len, size - len, "Version              : 0x%x\n", (reg >> 16U) & 0xffU);
+			len += oal_util_snprintf(buf + len, size - len, "ID                   : 0x%x\n", reg & 0xffffU);
+		}
+
+		len += oal_util_snprintf(buf + len, size - len, "TX Current BD Addr   : 0x%08x\n", hal_read32(base_va + HIF_NOCPY_TX_CURR_BD_ADDR));
+		len += oal_util_snprintf(buf + len, size - len, "TX Status            : 0x%08x\n", hal_read32(base_va + HIF_NOCPY_TX_STATUS));
+		len += oal_util_snprintf(buf + len, size - len, "TX DMA Status        : 0x%08x\n", hal_read32(base_va + HIF_NOCPY_TX_DMA_STATUS));
+		len += oal_util_snprintf(buf + len, size - len, "TX Ctrl              : 0x%08x\n", hal_read32(base_va + HIF_NOCPY_TX_CTRL));
+		len += oal_util_snprintf(buf + len, size - len, "RX Current BD Addr   : 0x%08x\n", hal_read32(base_va + HIF_NOCPY_RX_CURR_BD_ADDR));
+		len += oal_util_snprintf(buf + len, size - len, "RX Status            : 0x%08x\n", hal_read32(base_va + HIF_NOCPY_RX_STATUS));
+		len += oal_util_snprintf(buf + len, size - len, "RX DMA Status        : 0x%08x\n", hal_read32(base_va + HIF_NOCPY_RX_DMA_STATUS));
+		len += oal_util_snprintf(buf + len, size - len, "RX Ctrl              : 0x%08x\n", hal_read32(base_va + HIF_NOCPY_RX_CTRL));
 	}
 
-	len += oal_util_snprintf(buf + len, size - len, "TX Current BD Addr   : 0x%08x\n", hal_read32(base_va + HIF_NOCPY_TX_CURR_BD_ADDR));
-	len += oal_util_snprintf(buf + len, size - len, "TX Status            : 0x%08x\n", hal_read32(base_va + HIF_NOCPY_TX_STATUS));
-	len += oal_util_snprintf(buf + len, size - len, "TX DMA Status        : 0x%08x\n", hal_read32(base_va + HIF_NOCPY_TX_DMA_STATUS));
-	len += oal_util_snprintf(buf + len, size - len, "TX Ctrl              : 0x%08x\n", hal_read32(base_va + HIF_NOCPY_TX_CTRL));
-	len += oal_util_snprintf(buf + len, size - len, "RX Current BD Addr   : 0x%08x\n", hal_read32(base_va + HIF_NOCPY_RX_CURR_BD_ADDR));
-	len += oal_util_snprintf(buf + len, size - len, "RX Status            : 0x%08x\n", hal_read32(base_va + HIF_NOCPY_RX_STATUS));
-	len += oal_util_snprintf(buf + len, size - len, "RX DMA Status        : 0x%08x\n", hal_read32(base_va + HIF_NOCPY_RX_DMA_STATUS));
-	len += oal_util_snprintf(buf + len, size - len, "RX Ctrl              : 0x%08x\n", hal_read32(base_va + HIF_NOCPY_RX_CTRL));
-
 	return len;
 }
diff --git a/sw/pfe_platform/hw/s32g/pfe_platform_master.c b/sw/pfe_platform/hw/s32g/pfe_platform_master.c
index 48b15cb..d85fafc 100644
--- a/sw/pfe_platform/hw/s32g/pfe_platform_master.c
+++ b/sw/pfe_platform/hw/s32g/pfe_platform_master.c
@@ -202,115 +202,162 @@ void  pfe_platform_idex_rpc_cbk(pfe_ct_phy_if_id_t sender, uint32_t id, void *bu
 	if (unlikely(NULL == platform))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	/* Check if phy_if should be extracted from argument */
-	if(((uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_CREATE == id) ||
-	   (((uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_ID_COMPATIBLE_FIRST <= id) &&
-		((uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_ID_COMPATIBLE_LAST >= id)))
 	{
-		ret = pfe_if_db_get_first(	platform->phy_if_db, (uint32_t)sender, IF_DB_CRIT_BY_ID,
-									(void *)(addr_t)((pfe_platform_rpc_pfe_phy_if_generic_t*)buf)->phy_if_id, &entry);
-		if((EOK == ret) && (NULL != entry))
-		{
-			phy_if_arg = pfe_if_db_entry_get_phy_if(entry);
-		}
-		else
-		{
-			/* Entry doesn't exist */
-			ret = ENOENT;
-		}
-	}
-
-	/* Check if log_if should be extracted from argument */
-	if(((uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_ID_COMPATIBLE_FIRST <= id) &&
-	   ((uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_ID_COMPATIBLE_LAST >= id))
-	{
-		ret = pfe_if_db_get_first(	platform->log_if_db, (uint32_t)sender, IF_DB_CRIT_BY_ID,
-									(void *)(addr_t)((pfe_platform_rpc_pfe_log_if_generic_t*)buf)->log_if_id, &entry);
-		if((EOK == ret) && (NULL != entry))
-		{
-			log_if_arg = pfe_if_db_entry_get_log_if(entry);
-		}
-		else
+		/* Check if phy_if should be extracted from argument */
+		if(((uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_CREATE == id) ||
+		(((uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_ID_COMPATIBLE_FIRST <= id) &&
+			((uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_ID_COMPATIBLE_LAST >= id)))
 		{
-			/* Entry doesn't exist */
-			NXP_LOG_DEBUG("Requested entry not found\n");
-			ret = ENOENT;
+			ret = pfe_if_db_get_first(	platform->phy_if_db, (uint32_t)sender, IF_DB_CRIT_BY_ID,
+										(void *)(addr_t)((pfe_platform_rpc_pfe_phy_if_generic_t*)buf)->phy_if_id, &entry);
+			if((EOK == ret) && (NULL != entry))
+			{
+				phy_if_arg = pfe_if_db_entry_get_phy_if(entry);
+			}
+			else
+			{
+				/* Entry doesn't exist */
+				ret = ENOENT;
+			}
 		}
-	}
 
-	switch (id)
-	{
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_IF_LOCK:
+		/* Check if log_if should be extracted from argument */
+		if(((uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_ID_COMPATIBLE_FIRST <= id) &&
+		((uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_ID_COMPATIBLE_LAST >= id))
 		{
-			ret = pfe_if_db_lock_owned((uint32_t)sender);
-
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			ret = pfe_if_db_get_first(	platform->log_if_db, (uint32_t)sender, IF_DB_CRIT_BY_ID,
+										(void *)(addr_t)((pfe_platform_rpc_pfe_log_if_generic_t*)buf)->log_if_id, &entry);
+			if((EOK == ret) && (NULL != entry))
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
+				log_if_arg = pfe_if_db_entry_get_log_if(entry);
 			}
-			/* start timeout*/
-			break;
-		}
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_IF_UNLOCK:
-		{
-			ret = pfe_if_db_unlock((uint32_t)sender);
-
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			else
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
+				/* Entry doesn't exist */
+				NXP_LOG_DEBUG("Requested entry not found\n");
+				ret = ENOENT;
 			}
-			break;
 		}
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_CREATE:
-		{
-			pfe_platform_rpc_pfe_log_if_create_arg_t *arg_p = (pfe_platform_rpc_pfe_log_if_create_arg_t *)buf;
-			pfe_platform_rpc_pfe_log_if_create_ret_t rpc_ret = {0};
-			pfe_log_if_t *log_if = NULL;
-			static char_t namebuf[16];
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_CREATE\n");
+		switch (id)
+		{
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_IF_LOCK:
+			{
+				ret = pfe_if_db_lock_owned((uint32_t)sender);
 
-			if (EOK == ret)
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
+				/* start timeout*/
+				break;
+			}
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_IF_UNLOCK:
 			{
-				/*	Generate some name to easily identify non-local interfaces. Foreign interfaces (the ones
-					created by slave driver instances contains sN. prefix where N identifies the slave
-					driver instance via host interface ID. */
-				(void)oal_util_snprintf(namebuf, sizeof(namebuf), "s%d.%s", sender, arg_p->name);
-				log_if = pfe_log_if_create(phy_if_arg, namebuf);
-				if (NULL == log_if)
+				ret = pfe_if_db_unlock((uint32_t)sender);
+
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
 				{
-					NXP_LOG_ERROR("Could not create logical interface\n");
-					ret = ENODEV;
+					NXP_LOG_ERROR("Could not send RPC response\n");
 				}
-				else
+				break;
+			}
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_CREATE:
+			{
+				pfe_platform_rpc_pfe_log_if_create_arg_t *arg_p = (pfe_platform_rpc_pfe_log_if_create_arg_t *)buf;
+				pfe_platform_rpc_pfe_log_if_create_ret_t rpc_ret = {0};
+				pfe_log_if_t *log_if = NULL;
+				static char_t namebuf[16];
+
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_CREATE\n");
+
+				if (EOK == ret)
 				{
-					rpc_ret.log_if_id = pfe_log_if_get_id(log_if);
-					ret = pfe_if_db_add(platform->log_if_db, (uint32_t)sender, log_if, sender);
-					if (EOK != ret)
+					uint8_t i = 0U;
+					/*	Generate some name to easily identify non-local interfaces. Foreign interfaces (the ones
+						created by slave driver instances contains sN. prefix where N identifies the slave
+						driver instance via host interface ID. */
+					namebuf[0U] = 's';
+					namebuf[1U] = (char_t)sender + 0x30U;
+					namebuf[2U] = '.';
+					while( (arg_p->name[i] != '\0') && (i < (uint8_t)PFE_RPC_MAX_IF_NAME_LEN ))
 					{
-						NXP_LOG_DEBUG("Unable to register logical interface: %d\n", ret);
-						pfe_log_if_destroy(log_if);
-						log_if = NULL;
+						namebuf[3U+i] = arg_p->name[i];
+						i++;
+					}
+					namebuf[3U+i] = '\0';
+					log_if = pfe_log_if_create(phy_if_arg, namebuf);
+					if (NULL == log_if)
+					{
+						NXP_LOG_ERROR("Could not create logical interface\n");
+						ret = ENODEV;
 					}
 					else
 					{
-						NXP_LOG_INFO("Logical interface %s created in %s\n", \
-							pfe_log_if_get_name(log_if), pfe_phy_if_get_name(phy_if_arg));
+						rpc_ret.log_if_id = pfe_log_if_get_id(log_if);
+						ret = pfe_if_db_add(platform->log_if_db, (uint32_t)sender, log_if, sender);
+						if (EOK != ret)
+						{
+							NXP_LOG_DEBUG("Unable to register logical interface: %d\n", ret);
+							pfe_log_if_destroy(log_if);
+							log_if = NULL;
+						}
+						else
+						{
+							NXP_LOG_INFO("Logical interface %s created in %s\n", \
+								pfe_log_if_get_name(log_if), pfe_phy_if_get_name(phy_if_arg));
+						}
+					}
+				}
+
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+				{
+					NXP_LOG_ERROR("Could not send RPC response. Reverting.\n");
+					if (NULL != log_if)
+					{
+						ret = pfe_if_db_get_first(platform->log_if_db, (uint32_t)sender, IF_DB_CRIT_BY_INSTANCE, (void *)log_if, &entry);
+						if (NULL == entry)
+						{
+							ret = ENOENT;
+						}
+						else if (EOK == ret)
+						{
+							ret = pfe_if_db_remove(platform->log_if_db, (uint32_t)sender, entry);
+						}
+						else
+						{
+							/*Do Nothing*/
+							;
+						}
+
+						if (EOK != ret)
+						{
+							/*	This failure is normal in case the logical interface has not been registered */
+							NXP_LOG_DEBUG("Can't unregister %s: %d\n", pfe_log_if_get_name(log_if), ret);
+						}
+						else
+						{
+							pfe_log_if_destroy(log_if);
+							NXP_LOG_INFO("Interface destroyed\n");
+							log_if = NULL;
+						}
 					}
 				}
+
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_DESTROY:
 			{
-				NXP_LOG_ERROR("Could not send RPC response. Reverting.\n");
-				if (NULL != log_if)
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_DESTROY\n");
+
+				if (EOK == ret)
 				{
-					ret = pfe_if_db_get_first(platform->log_if_db, (uint32_t)sender, IF_DB_CRIT_BY_INSTANCE, (void *)log_if, &entry);
+					ret = pfe_if_db_get_first(platform->log_if_db, (uint32_t)sender, IF_DB_CRIT_BY_INSTANCE, (void *)log_if_arg, &entry);
 					if (NULL == entry)
 					{
 						ret = ENOENT;
@@ -327,1165 +374,1126 @@ void  pfe_platform_idex_rpc_cbk(pfe_ct_phy_if_id_t sender, uint32_t id, void *bu
 
 					if (EOK != ret)
 					{
-						/*	This failure is normal in case the logical interface has not been registered */
-						NXP_LOG_DEBUG("Can't unregister %s: %d\n", pfe_log_if_get_name(log_if), ret);
+						NXP_LOG_DEBUG("Unable to unregister %s with ID: %d\n", pfe_log_if_get_name(log_if_arg), pfe_log_if_get_id(log_if_arg));
 					}
 					else
 					{
-						pfe_log_if_destroy(log_if);
-						NXP_LOG_INFO("Interface destroyed\n");
-						log_if = NULL;
+						NXP_LOG_INFO("Removing %s\n", pfe_log_if_get_name(log_if_arg));
+						pfe_log_if_destroy(log_if_arg);
+						log_if_arg = NULL;
 					}
 				}
-			}
-
-			break;
-		}
-
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_DESTROY:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_DESTROY\n");
 
-			if (EOK == ret)
-			{
-				ret = pfe_if_db_get_first(platform->log_if_db, (uint32_t)sender, IF_DB_CRIT_BY_INSTANCE, (void *)log_if_arg, &entry);
-				if (NULL == entry)
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
 				{
-					ret = ENOENT;
-				}
-				else if (EOK == ret)
-				{
-					ret = pfe_if_db_remove(platform->log_if_db, (uint32_t)sender, entry);
-				}
-				else
-				{
-					/*Do Nothing*/
-					;
+					NXP_LOG_ERROR("Could not send RPC response\n");
 				}
 
-				if (EOK != ret)
-				{
-					NXP_LOG_DEBUG("Unable to unregister %s with ID: %d\n", pfe_log_if_get_name(log_if_arg), pfe_log_if_get_id(log_if_arg));
-				}
-				else
-				{
-					NXP_LOG_INFO("Removing %s\n", pfe_log_if_get_name(log_if_arg));
-					pfe_log_if_destroy(log_if_arg);
-					log_if_arg = NULL;
-				}
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_SET_MATCH_RULES:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
-
-			break;
-		}
-
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_SET_MATCH_RULES:
-		{
-			pfe_platform_rpc_pfe_log_if_set_match_rules_arg_t *arg_p = (pfe_platform_rpc_pfe_log_if_set_match_rules_arg_t *)buf;
+				pfe_platform_rpc_pfe_log_if_set_match_rules_arg_t *arg_p = (pfe_platform_rpc_pfe_log_if_set_match_rules_arg_t *)buf;
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_SET_MATCH_RULES\n");
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_SET_MATCH_RULES\n");
 
-			if (EOK == ret)
-			{
-				ret = pfe_log_if_set_match_rules(log_if_arg, (pfe_ct_if_m_rules_t)oal_ntohl(arg_p->rules), &arg_p->args);
 				if (EOK == ret)
 				{
-					NXP_LOG_INFO("New match rules 0x%x set to %s\n", (uint_t)oal_ntohl(arg_p->rules), pfe_log_if_get_name(log_if_arg));
+					ret = pfe_log_if_set_match_rules(log_if_arg, (pfe_ct_if_m_rules_t)oal_ntohl(arg_p->rules), &arg_p->args);
+					if (EOK == ret)
+					{
+						NXP_LOG_INFO("New match rules 0x%x set to %s\n", (uint_t)oal_ntohl(arg_p->rules), pfe_log_if_get_name(log_if_arg));
+					}
+					else
+					{
+						NXP_LOG_ERROR("Can't set matching rules for %s\n", pfe_log_if_get_name(log_if_arg));
+					}
 				}
-				else
+
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
 				{
-					NXP_LOG_ERROR("Can't set matching rules for %s\n", pfe_log_if_get_name(log_if_arg));
+					NXP_LOG_ERROR("Could not send RPC response\n");
 				}
+
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_GET_MATCH_RULES:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_log_if_get_match_rules_ret_t rpc_ret = {0};
+				pfe_ct_if_m_rules_t rules;
 
-			break;
-		}
+				(void)memset(&rules, 0, sizeof(pfe_ct_if_m_rules_t));
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_GET_MATCH_RULES\n");
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_GET_MATCH_RULES:
-		{
-			pfe_platform_rpc_pfe_log_if_get_match_rules_ret_t rpc_ret = {0};
-			pfe_ct_if_m_rules_t rules;
+				if (EOK == ret)
+				{
+					ret = pfe_log_if_get_match_rules(log_if_arg, &rules, &rpc_ret.args);
+					rpc_ret.rules = (pfe_ct_if_m_rules_t)oal_htonl(rules);
+				}
 
-			(void)memset(&rules, 0, sizeof(pfe_ct_if_m_rules_t));
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_GET_MATCH_RULES\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_log_if_get_match_rules(log_if_arg, &rules, &rpc_ret.args);
-				rpc_ret.rules = (pfe_ct_if_m_rules_t)oal_htonl(rules);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_ADD_MATCH_RULE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_log_if_add_match_rule_arg_t *arg_p = (pfe_platform_rpc_pfe_log_if_add_match_rule_arg_t *)buf;
 
-			break;
-		}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_ADD_MATCH_RULE\n");
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_ADD_MATCH_RULE:
-		{
-			pfe_platform_rpc_pfe_log_if_add_match_rule_arg_t *arg_p = (pfe_platform_rpc_pfe_log_if_add_match_rule_arg_t *)buf;
-
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_ADD_MATCH_RULE\n");
-
-			if (EOK == ret)
-			{
-				ret = pfe_log_if_add_match_rule(log_if_arg, (pfe_ct_if_m_rules_t)oal_ntohl(arg_p->rule), arg_p->arg, oal_ntohl(arg_p->arg_len));
 				if (EOK == ret)
 				{
-					NXP_LOG_INFO("New match rule 0x%x added to %s\n", (uint_t)oal_ntohl(arg_p->rule), pfe_log_if_get_name(log_if_arg));
+					ret = pfe_log_if_add_match_rule(log_if_arg, (pfe_ct_if_m_rules_t)oal_ntohl(arg_p->rule), arg_p->arg, oal_ntohl(arg_p->arg_len));
+					if (EOK == ret)
+					{
+						NXP_LOG_INFO("New match rule 0x%x added to %s\n", (uint_t)oal_ntohl(arg_p->rule), pfe_log_if_get_name(log_if_arg));
+					}
+					else
+					{
+						NXP_LOG_ERROR("Can't add match rule 0x%x for %s\n", (uint_t)oal_ntohl(arg_p->rule), pfe_log_if_get_name(log_if_arg));
+					}
 				}
-				else
+
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
 				{
-					NXP_LOG_ERROR("Can't add match rule 0x%x for %s\n", (uint_t)oal_ntohl(arg_p->rule), pfe_log_if_get_name(log_if_arg));
+					NXP_LOG_ERROR("Could not send RPC response\n");
 				}
-			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
-			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
+				break;
 			}
 
-			break;
-		}
-
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_DEL_MATCH_RULE:
-		{
-			pfe_platform_rpc_pfe_log_if_del_match_rule_arg_t *arg_p = (pfe_platform_rpc_pfe_log_if_del_match_rule_arg_t *)buf;
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_DEL_MATCH_RULE:
+			{
+				pfe_platform_rpc_pfe_log_if_del_match_rule_arg_t *arg_p = (pfe_platform_rpc_pfe_log_if_del_match_rule_arg_t *)buf;
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_DEL_MATCH_RULE\n");
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_DEL_MATCH_RULE\n");
 
-			if (EOK == ret)
-			{
-				ret = pfe_log_if_del_match_rule(log_if_arg, (pfe_ct_if_m_rules_t)oal_ntohl(arg_p->rule));
 				if (EOK == ret)
 				{
-					NXP_LOG_INFO("Match rule 0x%x removed from %s\n", (uint_t)oal_ntohl(arg_p->rule), pfe_log_if_get_name(log_if_arg));
+					ret = pfe_log_if_del_match_rule(log_if_arg, (pfe_ct_if_m_rules_t)oal_ntohl(arg_p->rule));
+					if (EOK == ret)
+					{
+						NXP_LOG_INFO("Match rule 0x%x removed from %s\n", (uint_t)oal_ntohl(arg_p->rule), pfe_log_if_get_name(log_if_arg));
+					}
+					else
+					{
+						NXP_LOG_ERROR("Can't delete match rule 0x%x for %s\n", (uint_t)oal_ntohl(arg_p->rule), pfe_log_if_get_name(log_if_arg));
+					}
 				}
-				else
+
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
 				{
-					NXP_LOG_ERROR("Can't delete match rule 0x%x for %s\n", (uint_t)oal_ntohl(arg_p->rule), pfe_log_if_get_name(log_if_arg));
+					NXP_LOG_ERROR("Could not send RPC response\n");
 				}
+
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_ADD_MAC_ADDR:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_log_if_add_mac_addr_arg_t *arg_p = (pfe_platform_rpc_pfe_log_if_add_mac_addr_arg_t *)buf;
 
-			break;
-		}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_ADD_MAC_ADDR\n");
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_ADD_MAC_ADDR:
-		{
-			pfe_platform_rpc_pfe_log_if_add_mac_addr_arg_t *arg_p = (pfe_platform_rpc_pfe_log_if_add_mac_addr_arg_t *)buf;
+				if (EOK == ret)
+				{
+					ret = pfe_log_if_add_mac_addr(log_if_arg, arg_p->addr, sender);
+				}
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_ADD_MAC_ADDR\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_log_if_add_mac_addr(log_if_arg, arg_p->addr, sender);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_DEL_MAC_ADDR:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_log_if_del_mac_addr_arg_t *arg_p = (pfe_platform_rpc_pfe_log_if_del_mac_addr_arg_t *)buf;
 
-			break;
-		}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_DEL_MAC_ADDR\n");
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_DEL_MAC_ADDR:
-		{
-			pfe_platform_rpc_pfe_log_if_del_mac_addr_arg_t *arg_p = (pfe_platform_rpc_pfe_log_if_del_mac_addr_arg_t *)buf;
+				if (EOK == ret)
+				{
+					ret = pfe_log_if_del_mac_addr(log_if_arg, arg_p->addr, sender);
+				}
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_DEL_MAC_ADDR\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_log_if_del_mac_addr(log_if_arg, arg_p->addr, sender);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_FLUSH_MAC_ADDRS:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_log_if_flush_mac_addrs_arg_t *arg_p = (pfe_platform_rpc_pfe_log_if_flush_mac_addrs_arg_t *)buf;
 
-			break;
-		}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_FLUSH_MAC_ADDRS\n");
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_FLUSH_MAC_ADDRS:
-		{
-			pfe_platform_rpc_pfe_log_if_flush_mac_addrs_arg_t *arg_p = (pfe_platform_rpc_pfe_log_if_flush_mac_addrs_arg_t *)buf;
+				if (EOK == ret)
+				{
+					ret = pfe_log_if_flush_mac_addrs(log_if_arg, arg_p->crit, arg_p->type, sender);
+				}
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_FLUSH_MAC_ADDRS\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_log_if_flush_mac_addrs(log_if_arg, arg_p->crit, arg_p->type, sender);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_ENABLE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_ENABLE\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_log_if_enable(log_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_ENABLE:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_ENABLE\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_log_if_enable(log_if_arg);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_DISABLE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_DISABLE\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_log_if_disable(log_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_DISABLE:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_DISABLE\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_log_if_disable(log_if_arg);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_IS_ENABLED:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_log_if_is_enabled_ret_t rpc_ret = {0};
 
-			break;
-		}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_IS_ENABLED\n");
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_IS_ENABLED:
-		{
-			pfe_platform_rpc_pfe_log_if_is_enabled_ret_t rpc_ret = {0};
+				if (EOK == ret)
+				{
+					rpc_ret.status = pfe_log_if_is_enabled(log_if_arg);
+				}
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_IS_ENABLED\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				rpc_ret.status = pfe_log_if_is_enabled(log_if_arg);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_PROMISC_ENABLE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_PROMISC_ENABLE\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_log_if_promisc_enable(log_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_PROMISC_ENABLE:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_PROMISC_ENABLE\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_log_if_promisc_enable(log_if_arg);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_PROMISC_DISABLE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_PROMISC_DISABLE\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_log_if_promisc_disable(log_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_PROMISC_DISABLE:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_PROMISC_DISABLE\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_log_if_promisc_disable(log_if_arg);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_IS_PROMISC:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_log_if_is_promisc_ret_t rpc_ret = {0};
 
-			break;
-		}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_IS_PROMISC\n");
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_IS_PROMISC:
-		{
-			pfe_platform_rpc_pfe_log_if_is_promisc_ret_t rpc_ret = {0};
+				if (EOK == ret)
+				{
+					rpc_ret.status = pfe_log_if_is_promisc(log_if_arg);
+				}
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_IS_PROMISC\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				rpc_ret.status = pfe_log_if_is_promisc(log_if_arg);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_IS_LOOPBACK:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_log_if_is_loopback_ret_t rpc_ret = {0};
 
-			break;
-		}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_IS_LOOPBACK\n");
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_IS_LOOPBACK:
-		{
-			pfe_platform_rpc_pfe_log_if_is_loopback_ret_t rpc_ret = {0};
+				if (EOK == ret)
+				{
+					rpc_ret.status = pfe_log_if_is_loopback(log_if_arg);
+				}
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_IS_LOOPBACK\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				rpc_ret.status = pfe_log_if_is_loopback(log_if_arg);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_LOOPBACK_ENABLE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_LOOPBACK_ENABLE\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_log_if_loopback_enable(log_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_LOOPBACK_ENABLE:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_LOOPBACK_ENABLE\n");
+				/*      Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_log_if_loopback_enable(log_if_arg);
+				break;
 			}
 
-			/*      Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_LOOPBACK_DISABLE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_LOOPBACK_DISABLE\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_log_if_loopback_disable(log_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_LOOPBACK_DISABLE:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_LOOPBACK_DISABLE\n");
+				/*      Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_log_if_loopback_disable(log_if_arg);
+				break;
 			}
 
-			/*      Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_DISCARD_ENABLE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_DISCARD_ENABLE\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_log_if_discard_enable(log_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_DISCARD_ENABLE:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_DISCARD_ENABLE\n");
+				/*      Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_log_if_discard_enable(log_if_arg);
+				break;
 			}
 
-			/*      Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_DISCARD_DISABLE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_DISCARD_DISABLE\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_log_if_discard_disable(log_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_DISCARD_DISABLE:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_DISCARD_DISABLE\n");
+				/*      Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_log_if_discard_disable(log_if_arg);
+				break;
 			}
 
-			/*      Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_IS_DISCARD:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_log_if_is_discard_ret_t rpc_ret = {0};
 
-			break;
-		}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_IS_DISCARD\n");
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_IS_DISCARD:
-		{
-			pfe_platform_rpc_pfe_log_if_is_discard_ret_t rpc_ret = {0};
+				if (EOK == ret)
+				{
+					rpc_ret.status = pfe_log_if_is_discard(log_if_arg);
+				}
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_IS_DISCARD\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				rpc_ret.status = pfe_log_if_is_discard(log_if_arg);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_ALLMULTI_ENABLE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_ALLMULTI_ENABLE\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_log_if_allmulti_enable(log_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_ALLMULTI_ENABLE:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_ALLMULTI_ENABLE\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_log_if_allmulti_enable(log_if_arg);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_ALLMULTI_DISABLE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_ALLMULTI_DISABLE\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_log_if_allmulti_disable(log_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_ALLMULTI_DISABLE:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_ALLMULTI_DISABLE\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_log_if_allmulti_disable(log_if_arg);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_ADD_EGRESS_IF:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_log_if_add_egress_if_arg_t *arg_p = (pfe_platform_rpc_pfe_log_if_add_egress_if_arg_t *)buf;
 
-			break;
-		}
-
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_ADD_EGRESS_IF:
-		{
-			pfe_platform_rpc_pfe_log_if_add_egress_if_arg_t *arg_p = (pfe_platform_rpc_pfe_log_if_add_egress_if_arg_t *)buf;
-
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_ADD_EGRESS_IF\n");
-
-			if (EOK == ret)
-			{
-				ret = pfe_if_db_get_first(platform->phy_if_db, (uint32_t)sender, IF_DB_CRIT_BY_ID, (void *)(addr_t)arg_p->phy_if_id, &entry);
-				phy_if_arg = pfe_if_db_entry_get_phy_if(entry);
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_ADD_EGRESS_IF\n");
 
-				if ((NULL == phy_if_arg) || (EOK != ret))
+				if (EOK == ret)
 				{
-					ret = ENOENT;
+					ret = pfe_if_db_get_first(platform->phy_if_db, (uint32_t)sender, IF_DB_CRIT_BY_ID, (void *)(addr_t)arg_p->phy_if_id, &entry);
+					phy_if_arg = pfe_if_db_entry_get_phy_if(entry);
+
+					if ((NULL == phy_if_arg) || (EOK != ret))
+					{
+						ret = ENOENT;
+					}
+					else
+					{
+						ret = pfe_log_if_add_egress_if(log_if_arg, phy_if_arg);
+					}
 				}
-				else
+
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
 				{
-					ret = pfe_log_if_add_egress_if(log_if_arg, phy_if_arg);
+					NXP_LOG_ERROR("Could not send RPC response\n");
 				}
+
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_SET_EGRESS_IFS:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_log_if_set_egress_ifs_arg_t *arg_p = (pfe_platform_rpc_pfe_log_if_set_egress_ifs_arg_t *)buf;
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_SET_EGRESS_IFS\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_log_if_set_egress_ifs(log_if_arg, (uint32_t)arg_p->phy_if_id_mask);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_SET_EGRESS_IFS:
-		{
-			pfe_platform_rpc_pfe_log_if_set_egress_ifs_arg_t *arg_p = (pfe_platform_rpc_pfe_log_if_set_egress_ifs_arg_t *)buf;
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_SET_EGRESS_IFS\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_log_if_set_egress_ifs(log_if_arg, (uint32_t)arg_p->phy_if_id_mask);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_GET_EGRESS_IFS:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_log_if_get_egress_ifs_ret_t rpc_ret = {0};
+				uint32_t egress = 0U;
 
-			break;
-		}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_GET_EGRESS_IFS\n");
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_GET_EGRESS_IFS:
-		{
-			pfe_platform_rpc_pfe_log_if_get_egress_ifs_ret_t rpc_ret = {0};
-			uint32_t egress = 0U;
+				if (EOK == ret)
+				{
+					ret = pfe_log_if_get_egress_ifs(log_if_arg, &egress);
+					rpc_ret.egress = egress;
+				}
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_GET_EGRESS_IFS\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_log_if_get_egress_ifs(log_if_arg, &egress);
-				rpc_ret.egress = egress;
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_DEL_EGRESS_IF:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
-
-			break;
-		}
-
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_DEL_EGRESS_IF:
-		{
-			const pfe_platform_rpc_pfe_log_if_del_egress_if_arg_t *arg_p = (pfe_platform_rpc_pfe_log_if_del_egress_if_arg_t *)buf;
+				const pfe_platform_rpc_pfe_log_if_del_egress_if_arg_t *arg_p = (pfe_platform_rpc_pfe_log_if_del_egress_if_arg_t *)buf;
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_DEL_EGRESS_IF\n");
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_DEL_EGRESS_IF\n");
 
-			if (EOK == ret)
-			{
-				ret = pfe_if_db_get_first(platform->phy_if_db, (uint32_t)sender, IF_DB_CRIT_BY_ID, (void *)(addr_t)arg_p->phy_if_id, &entry);
-				phy_if_arg = pfe_if_db_entry_get_phy_if(entry);
-
-				if ((NULL == phy_if_arg) || (EOK != ret))
+				if (EOK == ret)
 				{
-					ret = ENOENT;
+					ret = pfe_if_db_get_first(platform->phy_if_db, (uint32_t)sender, IF_DB_CRIT_BY_ID, (void *)(addr_t)arg_p->phy_if_id, &entry);
+					phy_if_arg = pfe_if_db_entry_get_phy_if(entry);
+
+					if ((NULL == phy_if_arg) || (EOK != ret))
+					{
+						ret = ENOENT;
+					}
+					else
+					{
+						ret = pfe_log_if_del_egress_if(log_if_arg, phy_if_arg);
+					}
 				}
-				else
+
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
 				{
-					ret = pfe_log_if_del_egress_if(log_if_arg, phy_if_arg);
+					NXP_LOG_ERROR("Could not send RPC response\n");
 				}
+
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_IS_MATCH_OR:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_log_if_is_match_or_ret_t rpc_ret = {0};
+				bool_t status = FALSE;
 
-			break;
-		}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_IS_MATCH_OR\n");
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_IS_MATCH_OR:
-		{
-			pfe_platform_rpc_pfe_log_if_is_match_or_ret_t rpc_ret = {0};
-			bool_t status = FALSE;
+				if (EOK == ret)
+				{
+					status = pfe_log_if_is_match_or(log_if_arg);
+					rpc_ret.status = status;
+				}
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_IS_MATCH_OR\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				status = pfe_log_if_is_match_or(log_if_arg);
-				rpc_ret.status = status;
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_SET_MATCH_OR:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_SET_MATCH_OR\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_log_if_set_match_or(log_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_SET_MATCH_OR:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_SET_MATCH_OR\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_log_if_set_match_or(log_if_arg);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_SET_MATCH_AND:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_SET_MATCH_AND\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_log_if_set_match_and(log_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_SET_MATCH_AND:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_SET_MATCH_AND\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_log_if_set_match_and(log_if_arg);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_STATS:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_log_if_stats_ret_t rpc_ret = {0};
 
-			break;
-		}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_STATS\n");
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_LOG_IF_STATS:
-		{
-			pfe_platform_rpc_pfe_log_if_stats_ret_t rpc_ret = {0};
+				if (EOK == ret)
+				{
+					ct_assert(sizeof(rpc_ret.stats) == sizeof(pfe_ct_class_algo_stats_t));
+					ret = pfe_log_if_get_stats(log_if_arg, &rpc_ret.stats);
+				}
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_STATS\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ct_assert(sizeof(rpc_ret.stats) == sizeof(pfe_ct_class_algo_stats_t));
-				ret = pfe_log_if_get_stats(log_if_arg, &rpc_ret.stats);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_CREATE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_CREATE\n");
 
-			break;
-		}
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_CREATE:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_CREATE\n");
+				break;
+			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_ENABLE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_ENABLE\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_phy_if_enable(phy_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_ENABLE:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_ENABLE\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_phy_if_enable(phy_if_arg);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_DISABLE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_DISABLE\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_phy_if_disable(phy_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_DISABLE:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_DISABLE\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_phy_if_disable(phy_if_arg);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_PROMISC_ENABLE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_PROMISC_ENABLE\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_phy_if_promisc_enable(phy_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_PROMISC_ENABLE:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_PROMISC_ENABLE\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_phy_if_promisc_enable(phy_if_arg);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_PROMISC_DISABLE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_PROMISC_DISABLE\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_phy_if_promisc_disable(phy_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_PROMISC_DISABLE:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_PROMISC_DISABLE\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_phy_if_promisc_disable(phy_if_arg);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_LOOPBACK_ENABLE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_LOOPBACK_ENABLE\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_phy_if_loopback_enable(phy_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_LOOPBACK_ENABLE:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_LOOPBACK_ENABLE\n");
+				/*      Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_phy_if_loopback_enable(phy_if_arg);
+				break;
 			}
 
-			/*      Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_LOOPBACK_DISABLE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_LOOPBACK_DISABLE\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_phy_if_loopback_disable(phy_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_LOOPBACK_DISABLE:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_LOOPBACK_DISABLE\n");
+				/*      Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_phy_if_loopback_disable(phy_if_arg);
+				break;
 			}
 
-			/*      Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_LOADBALANCE_ENABLE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_LOADBALANCE_ENABLE\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_phy_if_loadbalance_enable(phy_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_LOADBALANCE_ENABLE:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_LOADBALANCE_ENABLE\n");
+				/*      Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_phy_if_loadbalance_enable(phy_if_arg);
+				break;
 			}
 
-			/*      Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_LOADBALANCE_DISABLE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_LOADBALANCE_DISABLE\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_phy_if_loadbalance_disable(phy_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_LOADBALANCE_DISABLE:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_LOADBALANCE_DISABLE\n");
+				/*      Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_phy_if_loadbalance_disable(phy_if_arg);
+				break;
 			}
 
-			/*      Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_ALLMULTI_ENABLE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_ALLMULTI_ENABLE\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_phy_if_allmulti_enable(phy_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_ALLMULTI_ENABLE:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_ALLMULTI_ENABLE\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_phy_if_allmulti_enable(phy_if_arg);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_ALLMULTI_DISABLE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_ALLMULTI_DISABLE\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_phy_if_allmulti_disable(phy_if_arg);
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_ALLMULTI_DISABLE:
-		{
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_ALLMULTI_DISABLE\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_phy_if_allmulti_disable(phy_if_arg);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_ADD_MAC_ADDR:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_phy_if_add_mac_addr_arg_t *rpc_arg = (pfe_platform_rpc_pfe_phy_if_add_mac_addr_arg_t *)buf;
+				pfe_mac_addr_t mac_addr;
 
-			break;
-		}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_ADD_MAC_ADDR\n");
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_ADD_MAC_ADDR:
-		{
-			pfe_platform_rpc_pfe_phy_if_add_mac_addr_arg_t *rpc_arg = (pfe_platform_rpc_pfe_phy_if_add_mac_addr_arg_t *)buf;
-			pfe_mac_addr_t mac_addr;
+				if (EOK == ret)
+				{
+					ct_assert(sizeof(pfe_mac_addr_t) == sizeof(rpc_arg->mac_addr));
+					(void)memcpy(&mac_addr, rpc_arg->mac_addr, sizeof(pfe_mac_addr_t));
+					ret = pfe_phy_if_add_mac_addr(phy_if_arg, mac_addr, sender);
+				}
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_ADD_MAC_ADDR\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ct_assert(sizeof(pfe_mac_addr_t) == sizeof(rpc_arg->mac_addr));
-				(void)memcpy(&mac_addr, rpc_arg->mac_addr, sizeof(pfe_mac_addr_t));
-				ret = pfe_phy_if_add_mac_addr(phy_if_arg, mac_addr, sender);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_DEL_MAC_ADDR:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_phy_if_del_mac_addr_arg_t *rpc_arg = (pfe_platform_rpc_pfe_phy_if_del_mac_addr_arg_t *)buf;
+				pfe_mac_addr_t mac_addr;
 
-			break;
-		}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_DEL_MAC_ADDR\n");
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_DEL_MAC_ADDR:
-		{
-			pfe_platform_rpc_pfe_phy_if_del_mac_addr_arg_t *rpc_arg = (pfe_platform_rpc_pfe_phy_if_del_mac_addr_arg_t *)buf;
-			pfe_mac_addr_t mac_addr;
+				if (EOK == ret)
+				{
+					ct_assert(sizeof(pfe_mac_addr_t) == sizeof(rpc_arg->mac_addr));
+					(void)memcpy(&mac_addr, rpc_arg->mac_addr, sizeof(pfe_mac_addr_t));
+					ret = pfe_phy_if_del_mac_addr(phy_if_arg, mac_addr, sender);
+				}
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_DEL_MAC_ADDR\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ct_assert(sizeof(pfe_mac_addr_t) == sizeof(rpc_arg->mac_addr));
-				(void)memcpy(&mac_addr, rpc_arg->mac_addr, sizeof(pfe_mac_addr_t));
-				ret = pfe_phy_if_del_mac_addr(phy_if_arg, mac_addr, sender);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_FLUSH_MAC_ADDRS:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_phy_if_flush_mac_addrs_arg_t *rpc_arg = (pfe_platform_rpc_pfe_phy_if_flush_mac_addrs_arg_t *)buf;
 
-			break;
-		}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_FLUSH_MAC_ADDRS\n");
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_FLUSH_MAC_ADDRS:
-		{
-			pfe_platform_rpc_pfe_phy_if_flush_mac_addrs_arg_t *rpc_arg = (pfe_platform_rpc_pfe_phy_if_flush_mac_addrs_arg_t *)buf;
+				if (EOK == ret)
+				{
+					ret = pfe_phy_if_flush_mac_addrs(phy_if_arg, rpc_arg->crit, rpc_arg->type, sender);
+				}
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_FLUSH_MAC_ADDRS\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_phy_if_flush_mac_addrs(phy_if_arg, rpc_arg->crit, rpc_arg->type, sender);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_SET_OP_MODE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_phy_if_set_op_mode_arg_t *rpc_arg = (pfe_platform_rpc_pfe_phy_if_set_op_mode_arg_t *)buf;
 
-			break;
-		}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_SET_OP_MODE\n");
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_SET_OP_MODE:
-		{
-			pfe_platform_rpc_pfe_phy_if_set_op_mode_arg_t *rpc_arg = (pfe_platform_rpc_pfe_phy_if_set_op_mode_arg_t *)buf;
+				if (EOK == ret)
+				{
+					ret = pfe_phy_if_set_op_mode(phy_if_arg, rpc_arg->op_mode);
+				}
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_SET_OP_MODE\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_phy_if_set_op_mode(phy_if_arg, rpc_arg->op_mode);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_SET_BLOCK_STATE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_phy_if_set_block_state_arg_t *rpc_arg = (pfe_platform_rpc_pfe_phy_if_set_block_state_arg_t *)buf;
 
-			break;
-		}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_SET_BLOCK_STATE\n");
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_SET_BLOCK_STATE:
-		{
-			pfe_platform_rpc_pfe_phy_if_set_block_state_arg_t *rpc_arg = (pfe_platform_rpc_pfe_phy_if_set_block_state_arg_t *)buf;
+				if (EOK == ret)
+				{
+					ret = pfe_phy_if_set_block_state(phy_if_arg, rpc_arg->block_state);
+				}
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_SET_BLOCK_STATE\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_phy_if_set_block_state(phy_if_arg, rpc_arg->block_state);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_GET_BLOCK_STATE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_phy_if_get_block_state_ret_t rpc_ret = {IF_BS_FORWARDING};
+				pfe_ct_block_state_t block_state = IF_BS_FORWARDING;
+				
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_GET_BLOCK_STATE\n");
 
-			break;
-		}
+				if (EOK == ret)
+				{
+					ret = pfe_phy_if_get_block_state(phy_if_arg, &block_state);
+					rpc_ret.state = block_state;
+				}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_GET_BLOCK_STATE:
-		{
-			pfe_platform_rpc_pfe_phy_if_get_block_state_ret_t rpc_ret = {IF_BS_FORWARDING};
-			pfe_ct_block_state_t block_state = IF_BS_FORWARDING;
-			
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_GET_BLOCK_STATE\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ret = pfe_phy_if_get_block_state(phy_if_arg, &block_state);
-				rpc_ret.state = block_state;
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_HAS_LOG_IF:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
-
-			break;
-		}
-
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_HAS_LOG_IF:
-		{
-			pfe_platform_rpc_pfe_phy_if_has_log_if_arg_t *rpc_arg = (pfe_platform_rpc_pfe_phy_if_has_log_if_arg_t *)buf;
+				pfe_platform_rpc_pfe_phy_if_has_log_if_arg_t *rpc_arg = (pfe_platform_rpc_pfe_phy_if_has_log_if_arg_t *)buf;
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_HAS_LOG_IF\n");
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_HAS_LOG_IF\n");
 
-			ret = pfe_if_db_get_first(platform->log_if_db, (uint32_t)sender, IF_DB_CRIT_BY_ID, (void *)(addr_t)rpc_arg->log_if_id, &entry);
-			log_if_arg = pfe_if_db_entry_get_log_if(entry);
+				ret = pfe_if_db_get_first(platform->log_if_db, (uint32_t)sender, IF_DB_CRIT_BY_ID, (void *)(addr_t)rpc_arg->log_if_id, &entry);
+				log_if_arg = pfe_if_db_entry_get_log_if(entry);
 
-			/* Check local log_if as well as globally extracted phy_if*/
-			if ((NULL == log_if_arg) || (EOK != ret))
-			{
-				/*	Instance does not exist */
-				ret = ENOENT;
-			}
-			else
-			{
-				if (pfe_phy_if_has_log_if(phy_if_arg, log_if_arg))
+				/* Check local log_if as well as globally extracted phy_if*/
+				if ((NULL == log_if_arg) || (EOK != ret))
 				{
-					ret = EOK;
+					/*	Instance does not exist */
+					ret = ENOENT;
 				}
 				else
 				{
-					ret = ENOENT;
+					if (pfe_phy_if_has_log_if(phy_if_arg, log_if_arg))
+					{
+						ret = EOK;
+					}
+					else
+					{
+						ret = ENOENT;
+					}
+				}
+
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
 				}
+
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_GET_OP_MODE:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_phy_if_get_op_mode_ret_t rpc_ret = {IF_OP_DEFAULT};
+				pfe_ct_if_op_mode_t mode = IF_OP_DEFAULT;
 
-			break;
-		}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_GET_OP_MODE\n");
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_GET_OP_MODE:
-		{
-			pfe_platform_rpc_pfe_phy_if_get_op_mode_ret_t rpc_ret = {IF_OP_DEFAULT};
-			pfe_ct_if_op_mode_t mode = IF_OP_DEFAULT;
+				if (EOK == ret)
+				{
+					mode = pfe_phy_if_get_op_mode(phy_if_arg);
+					rpc_ret.mode = mode;
+				}
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_GET_OP_MODE\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				mode = pfe_phy_if_get_op_mode(phy_if_arg);
-				rpc_ret.mode = mode;
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_IS_ENABLED:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_phy_if_is_enabled_ret_t rpc_ret = {0};
+				bool_t status = FALSE;
 
-			break;
-		}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_IS_ENABLED:
-		{
-			pfe_platform_rpc_pfe_phy_if_is_enabled_ret_t rpc_ret = {0};
-			bool_t status = FALSE;
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_IS_ENABLED\n");
 
+				if (EOK == ret)
+				{
+					status = pfe_phy_if_is_enabled(phy_if_arg);
+					rpc_ret.status = status;
+				}
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_IS_ENABLED\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				status = pfe_phy_if_is_enabled(phy_if_arg);
-				rpc_ret.status = status;
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_IS_PROMISC:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_phy_if_is_promisc_ret_t rpc_ret = {0};
+				bool_t status = FALSE;
 
-			break;
-		}
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_IS_PROMISC:
-		{
-			pfe_platform_rpc_pfe_phy_if_is_promisc_ret_t rpc_ret = {0};
-			bool_t status = FALSE;
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_IS_PROMISC\n");
 
+				if (EOK == ret)
+				{
+					status = pfe_phy_if_is_promisc(phy_if_arg);
+					rpc_ret.status = status;
+				}
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_IS_PROMISC\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				status = pfe_phy_if_is_promisc(phy_if_arg);
-				rpc_ret.status = status;
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_STATS:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_phy_if_stats_ret_t rpc_ret = {0};
 
-			break;
-		}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_STATS\n");
 
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_PHY_IF_STATS:
-		{
-			pfe_platform_rpc_pfe_phy_if_stats_ret_t rpc_ret = {0};
+				if (EOK == ret)
+				{
+					ct_assert(sizeof(pfe_ct_phy_if_stats_t) == sizeof(rpc_ret.stats));
+					ret = pfe_phy_if_get_stats(phy_if_arg, &rpc_ret.stats);
+				}
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_STATS\n");
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			if (EOK == ret)
-			{
-				ct_assert(sizeof(pfe_ct_phy_if_stats_t) == sizeof(rpc_ret.stats));
-				ret = pfe_phy_if_get_stats(phy_if_arg, &rpc_ret.stats);
+				break;
 			}
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+	#if defined(PFE_CFG_FCI_ENABLE)
+			case (uint32_t)PFE_PLATFORM_RPC_PFE_FCI_PROXY:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				pfe_platform_rpc_pfe_fci_proxy_arg_t *rpc_arg = (pfe_platform_rpc_pfe_fci_proxy_arg_t *)buf;
+				pfe_platform_rpc_pfe_fci_proxy_ret_t rpc_ret = {0};
 
-			break;
-		}
+				NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_FCI_PROXY\n");
 
-#if defined(PFE_CFG_FCI_ENABLE)
-		case (uint32_t)PFE_PLATFORM_RPC_PFE_FCI_PROXY:
-		{
-			pfe_platform_rpc_pfe_fci_proxy_arg_t *rpc_arg = (pfe_platform_rpc_pfe_fci_proxy_arg_t *)buf;
-			pfe_platform_rpc_pfe_fci_proxy_ret_t rpc_ret = {0};
+				if (EOK == ret)
+				{
+					ct_assert(sizeof(msg_type_t) == sizeof(rpc_arg->type));
+					ct_assert(sizeof(fci_msg_cmd_t) == sizeof(rpc_arg->msg_cmd));
 
-			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_FCI_PROXY\n");
+					/* Construct platform-specific FCI message. Use received platform-independent data. */
+					fci_msg_t msg = {.type=(rpc_arg->type), .msg_cmd=(rpc_arg->msg_cmd)};
+					fci_msg_t rep_msg = {.type=FCI_MSG_CMD, .msg_cmd={0}};
 
-			if (EOK == ret)
-			{
-				ct_assert(sizeof(msg_type_t) == sizeof(rpc_arg->type));
-				ct_assert(sizeof(fci_msg_cmd_t) == sizeof(rpc_arg->msg_cmd));
+					/* Process the FCI message. */
+					ret = fci_process_ipc_message(&msg, &rep_msg);
 
-				/* Construct platform-specific FCI message. Use received platform-independent data. */
-				fci_msg_t msg = {.type=(rpc_arg->type), .msg_cmd=(rpc_arg->msg_cmd)};
-				fci_msg_t rep_msg = {.type=FCI_MSG_CMD, .msg_cmd={0}};
+					/* Fill the RPC reply. */
+					rpc_ret.msg_cmd = rep_msg.msg_cmd;
+				}
 
-				/* Process the FCI message. */
-				ret = fci_process_ipc_message(&msg, &rep_msg);
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-				/* Fill the RPC reply. */
-				rpc_ret.msg_cmd = rep_msg.msg_cmd;
+				break;
 			}
+	#endif /* PFE_CFG_FCI_ENABLE */
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(ret, &rpc_ret, (uint16_t)sizeof(rpc_ret)))
+			default:
 			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
-
-			break;
-		}
-#endif /* PFE_CFG_FCI_ENABLE */
-
-		default:
-		{
-			NXP_LOG_WARNING("Unsupported RPC code: %u\n", (uint_t)id);
+				NXP_LOG_WARNING("Unsupported RPC code: %u\n", (uint_t)id);
 
-			/*	Report execution status to caller */
-			if (EOK != pfe_idex_set_rpc_ret_val(EINVAL, NULL, 0U))
-			{
-				NXP_LOG_ERROR("Could not send RPC response\n");
-			}
+				/*	Report execution status to caller */
+				if (EOK != pfe_idex_set_rpc_ret_val(EINVAL, NULL, 0U))
+				{
+					NXP_LOG_ERROR("Could not send RPC response\n");
+				}
 
-			break;
+				break;
+			}
 		}
 	}
-
-	return;
 }
 #endif /* PFE_CFG_MULTI_INSTANCE_SUPPORT */
 
@@ -1494,25 +1502,29 @@ void  pfe_platform_idex_rpc_cbk(pfe_ct_phy_if_id_t sender, uint32_t id, void *bu
  */
 static errno_t pfe_platform_create_hif(pfe_platform_t *platform, const pfe_platform_config_t *config)
 {
+	errno_t ret;
 	platform->hif = pfe_hif_create(platform->cbus_baseaddr + CBUS_HIF_BASE_ADDR, config->hif_chnls_mask);
 	if (NULL == platform->hif)
 	{
 		NXP_LOG_ERROR("Couldn't create HIF instance\n");
-		return ENODEV;
+		ret = ENODEV;
 	}
+	else
+	{
+	#ifdef PFE_CFG_MULTI_INSTANCE_SUPPORT
+		pfe_hif_set_master_detect_cfg(platform->hif, !config->disable_master_detect);
+	#endif /* PFE_CFG_MULTI_INSTANCE_SUPPORT */
 
-#ifdef PFE_CFG_MULTI_INSTANCE_SUPPORT
-	pfe_hif_set_master_detect_cfg(platform->hif, !config->disable_master_detect);
-#endif /* PFE_CFG_MULTI_INSTANCE_SUPPORT */
-
-	pfe_hif_irq_unmask(platform->hif);
+		pfe_hif_irq_unmask(platform->hif);
 
-#ifdef PFE_CFG_MULTI_INSTANCE_SUPPORT
-	/* Clean Master detect flags for all HIF channels */
-	pfe_hif_clear_master_up(platform->hif);
-#endif /* PFE_CFG_MULTI_INSTANCE_SUPPORT */
+	#ifdef PFE_CFG_MULTI_INSTANCE_SUPPORT
+		/* Clean Master detect flags for all HIF channels */
+		pfe_hif_clear_master_up(platform->hif);
+	#endif /* PFE_CFG_MULTI_INSTANCE_SUPPORT */
+		ret = EOK;
+	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1539,7 +1551,20 @@ static void pfe_platform_destroy_hif(pfe_platform_t *platform)
  */
 static errno_t pfe_platform_create_hif_nocpy(pfe_platform_t *platform)
 {
-	platform->hif_nocpy = pfe_hif_nocpy_create(pfe.cbus_baseaddr + CBUS_HIF_NOCPY_BASE_ADDR, platform->bmu[1]);
+    uint16_t lmem_header_size;
+
+#if 0 /* AAVB-5037 */
+	if(PFE_S32G3_VERSION == platform->pfe_version)
+	{   /* S32G3 */
+		lmem_header_size = 48U;
+	}
+	else
+#endif
+	{   /* S32G2 */
+		lmem_header_size = 112U;
+	}
+
+	platform->hif_nocpy = pfe_hif_nocpy_create(pfe.cbus_baseaddr + CBUS_HIF_NOCPY_BASE_ADDR, platform->bmu[1], lmem_header_size);
 
 	if (NULL == platform->hif_nocpy)
 	{
@@ -1574,94 +1599,108 @@ static void pfe_platform_destroy_hif_nocpy(pfe_platform_t *platform)
 static errno_t pfe_platform_create_bmu(pfe_platform_t *platform, const pfe_platform_config_t *config)
 {
 	pfe_bmu_cfg_t bmu_cfg = {0U};
+	errno_t ret;
 
 	platform->bmu = oal_mm_malloc(platform->bmu_count * sizeof(pfe_bmu_t *));
 	if (NULL == platform->bmu)
 	{
 		NXP_LOG_ERROR("oal_mm_malloc() failed\n");
-		return ENOMEM;
+		ret = ENOMEM;
 	}
-
-	/*	Must be aligned to BUF_COUNT * BUF_SIZE */
-	bmu_cfg.pool_pa = (PFE_CFG_CBUS_PHYS_BASE_ADDR + CBUS_LMEM_BASE_ADDR + PFE_CFG_BMU1_LMEM_BASEADDR);
-	NXP_LOG_INFO("BMU1 buffer base: p0x%"PRINTADDR_T"\n", bmu_cfg.pool_pa);
-	bmu_cfg.max_buf_cnt = PFE_CFG_BMU1_BUF_COUNT;
-	bmu_cfg.buf_size = PFE_CFG_BMU1_BUF_SIZE;
-	bmu_cfg.bmu_ucast_thres = 0x200U;
-	bmu_cfg.bmu_mcast_thres = 0x200U;
-	bmu_cfg.int_mem_loc_cnt = 64U;
-	bmu_cfg.buf_mem_loc_cnt = 64U;
-
-	platform->bmu[0] = pfe_bmu_create(platform->cbus_baseaddr, CBUS_BMU1_BASE_ADDR, &bmu_cfg);
-	if (NULL == platform->bmu[0])
+	else
 	{
-		NXP_LOG_ERROR("Couldn't create BMU1 instance\n");
-		return ENODEV;
-	}
+		/*	Must be aligned to BUF_COUNT * BUF_SIZE */
+		bmu_cfg.pool_pa = (PFE_CFG_CBUS_PHYS_BASE_ADDR + CBUS_LMEM_BASE_ADDR + PFE_CFG_BMU1_LMEM_BASEADDR);
+		NXP_LOG_INFO("BMU1 buffer base: p0x%"PRINTADDR_T"\n", bmu_cfg.pool_pa);
+		bmu_cfg.max_buf_cnt = PFE_CFG_BMU1_BUF_COUNT;
+		bmu_cfg.buf_size = PFE_CFG_BMU1_BUF_SIZE;
+		bmu_cfg.bmu_ucast_thres = 0x200U;
+		bmu_cfg.bmu_mcast_thres = 0x200U;
+		bmu_cfg.int_mem_loc_cnt = 64U;
+		bmu_cfg.buf_mem_loc_cnt = 64U;
 
-	if (2U > platform->bmu_count)
-	{
+		platform->bmu[0] = pfe_bmu_create(platform->cbus_baseaddr, CBUS_BMU1_BASE_ADDR, &bmu_cfg);
+		if (NULL == platform->bmu[0])
+		{
+			NXP_LOG_ERROR("Couldn't create BMU1 instance\n");
+			ret = ENODEV;
+		}
+		else if (2U > platform->bmu_count)
+		{
 			NXP_LOG_WARNING("Only single BMU was configured.\n");
-			return EOK;
-	}
+			ret = EOK;
+		}
+		else
+		{
 
-	/*	Must be aligned to BUF_COUNT * BUF_SIZE */
-	platform->bmu_buffers_size = PFE_CFG_BMU2_BUF_COUNT * PFE_CFG_BMU2_BUF_SIZE;
-	platform->bmu_buffers_va = oal_mm_malloc_contig_named_aligned_nocache(
-			PFE_CFG_SYS_MEM, platform->bmu_buffers_size, platform->bmu_buffers_size);
-	if (NULL == platform->bmu_buffers_va)
-	{
-		NXP_LOG_ERROR("Unable to get BMU2 pool memory\n");
-		return ENOMEM;
-	}
+			/*	Must be aligned to BUF_COUNT * BUF_SIZE */
+			platform->bmu_buffers_size = PFE_CFG_BMU2_BUF_COUNT * PFE_CFG_BMU2_BUF_SIZE;
+			platform->bmu_buffers_va = oal_mm_malloc_contig_named_aligned_nocache(
+					PFE_CFG_SYS_MEM, platform->bmu_buffers_size, platform->bmu_buffers_size);
+			if (NULL == platform->bmu_buffers_va)
+			{
+				NXP_LOG_ERROR("Unable to get BMU2 pool memory\n");
+				ret = ENOMEM;
+			}
+			else
+			{
 
-	bmu_cfg.pool_va = (addr_t)platform->bmu_buffers_va;
-	bmu_cfg.pool_pa = (addr_t)oal_mm_virt_to_phys_contig((void*)platform->bmu_buffers_va);
+				bmu_cfg.pool_va = (addr_t)platform->bmu_buffers_va;
+				bmu_cfg.pool_pa = (addr_t)oal_mm_virt_to_phys_contig((void*)platform->bmu_buffers_va);
 
-	/*	S32G: Some of PFE AXI MASTERs can only access range p0x00020000 - p0xbfffffff */
-	if (((addr_t)bmu_cfg.pool_pa < 0x00020000U) || (((addr_t)bmu_cfg.pool_pa + platform->bmu_buffers_size) > 0xbfffffffU))
-	{
-		NXP_LOG_WARNING("BMU2 buffers not in required range: starts @ p0x%"PRINTADDR_T"\n", bmu_cfg.pool_pa);
-	}
-	else
-	{
-		NXP_LOG_INFO("BMU2 buffer base: p0x%"PRINTADDR_T" (0x%"PRINTADDR_T" bytes)\n", bmu_cfg.pool_pa, platform->bmu_buffers_size);
-	}
+				/*	S32G: Some of PFE AXI MASTERs can only access range p0x00020000 - p0xbfffffff */
+				if (((addr_t)bmu_cfg.pool_pa < 0x00020000U) || (((addr_t)bmu_cfg.pool_pa + platform->bmu_buffers_size) > 0xbfffffffU))
+				{
+					NXP_LOG_WARNING("BMU2 buffers not in required range: starts @ p0x%"PRINTADDR_T"\n", bmu_cfg.pool_pa);
+				}
+				else
+				{
+					NXP_LOG_INFO("BMU2 buffer base: p0x%"PRINTADDR_T" (0x%"PRINTADDR_T" bytes)\n", bmu_cfg.pool_pa, platform->bmu_buffers_size);
+				}
 
-	bmu_cfg.max_buf_cnt = PFE_CFG_BMU2_BUF_COUNT;
-	bmu_cfg.buf_size = PFE_CFG_BMU2_BUF_SIZE;
-	bmu_cfg.bmu_ucast_thres = 0x800U;
-	bmu_cfg.bmu_mcast_thres = 0x200U;
-	bmu_cfg.int_mem_loc_cnt = 1024U;
-	bmu_cfg.buf_mem_loc_cnt = 1024U;
+				bmu_cfg.max_buf_cnt = PFE_CFG_BMU2_BUF_COUNT;
+				bmu_cfg.buf_size = PFE_CFG_BMU2_BUF_SIZE;
+				bmu_cfg.bmu_ucast_thres = 0x800U;
+				bmu_cfg.bmu_mcast_thres = 0x200U;
+				bmu_cfg.int_mem_loc_cnt = 1024U;
+				bmu_cfg.buf_mem_loc_cnt = 1024U;
 
-	platform->bmu[1] = pfe_bmu_create(platform->cbus_baseaddr, CBUS_BMU2_BASE_ADDR, &bmu_cfg);
+				platform->bmu[1] = pfe_bmu_create(platform->cbus_baseaddr, CBUS_BMU2_BASE_ADDR, &bmu_cfg);
 
-	if (NULL == platform->bmu[1])
-	{
-		NXP_LOG_ERROR("Couldn't create BMU2 instance\n");
-		return ENODEV;
-	}
+				if (NULL == platform->bmu[1])
+				{
+					NXP_LOG_ERROR("Couldn't create BMU2 instance\n");
+					ret = ENODEV;
+				}
+				else
+				{
 
-	platform->irq_bmu = oal_irq_create((int32_t)config->irq_vector_bmu, (oal_irq_flags_t)0, "PFE BMU IRQ");
-	if (NULL == platform->irq_bmu)
-	{
-		NXP_LOG_ERROR("Could not create BMU IRQ vector %u\n", (uint_t)config->irq_vector_bmu);
-		return ENODEV;
-	}
-	else
-	{
-		if (EOK != oal_irq_add_handler(platform->irq_bmu, &pfe_platform_bmu_isr, platform, NULL))
-		{
-			NXP_LOG_ERROR("Could not add IRQ handler for the BMU[0]\n");
-			return ENODEV;
+					platform->irq_bmu = oal_irq_create((int32_t)config->irq_vector_bmu, (oal_irq_flags_t)0, "PFE BMU IRQ");
+					if (NULL == platform->irq_bmu)
+					{
+						NXP_LOG_ERROR("Could not create BMU IRQ vector %u\n", (uint_t)config->irq_vector_bmu);
+						ret = ENODEV;
+					}
+					else
+					{
+						if (EOK != oal_irq_add_handler(platform->irq_bmu, &pfe_platform_bmu_isr, platform, NULL))
+						{
+							NXP_LOG_ERROR("Could not add IRQ handler for the BMU[0]\n");
+							ret = ENODEV;
+						}
+						else
+						{
+							pfe_bmu_irq_unmask(platform->bmu[0]);
+							pfe_bmu_irq_unmask(platform->bmu[1]);
+							ret = EOK;
+						}
+					}
+				}
+			}
 		}
 	}
 
-	pfe_bmu_irq_unmask(platform->bmu[0]);
-	pfe_bmu_irq_unmask(platform->bmu[1]);
-
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1705,61 +1744,79 @@ static void pfe_platform_destroy_bmu(pfe_platform_t *platform)
 static errno_t pfe_platform_create_gpi(pfe_platform_t *platform)
 {
 	pfe_gpi_cfg_t gpi_cfg_tmp;
-	uint32_t aseq_len = 0x40U;
+	uint32_t aseq_len = 0x50U;
+	errno_t ret;
+
 
 	platform->gpi = oal_mm_malloc(platform->gpi_count * sizeof(pfe_gpi_t *));
 	if (NULL == platform->gpi)
 	{
 		NXP_LOG_ERROR("oal_mm_malloc() failed\n");
-		return ENOMEM;
+		ret = ENOMEM;
 	}
-
-	if (TRUE == pfe_feature_mgr_is_available("gpi_checksum_fix"))
+	else
 	{
-		aseq_len = 0x50U;
-		NXP_LOG_INFO("Using GPI ASEQ LEN 0x50\n");
-	}
-
-	/*	GPI1 */
-	gpi_cfg_tmp.alloc_retry_cycles = 0x200U;
-	gpi_cfg_tmp.gpi_tmlf_txthres = 0x178U;
-	gpi_cfg_tmp.gpi_dtx_aseq_len = aseq_len; /* See AAVB-2028 */
-	gpi_cfg_tmp.emac_1588_ts_en = TRUE;
+	#if 0 /* AAVB-5037 */
+		if(PFE_S32G3_VERSION == platform->pfe_version)
+		{   /* S32G3 */
+			gpi_cfg_tmp.lmem_header_size = 48U;
+		}
+		else
+	#endif
+		{   /* S32G2 */
+			gpi_cfg_tmp.lmem_header_size = 112U;
+		}
 
-	platform->gpi[0] = pfe_gpi_create(platform->cbus_baseaddr, CBUS_EGPI1_BASE_ADDR, &gpi_cfg_tmp);
-	if (NULL == platform->gpi[0])
-	{
-		NXP_LOG_ERROR("Couldn't create GPI1 instance\n");
-		return ENODEV;
-	}
+		/*	GPI1 */
+		gpi_cfg_tmp.alloc_retry_cycles = 0x200U;
+		gpi_cfg_tmp.gpi_tmlf_txthres = 0x178U;
+		gpi_cfg_tmp.gpi_dtx_aseq_len = aseq_len; /* See AAVB-2028 */
+		gpi_cfg_tmp.emac_1588_ts_en = TRUE;
 
-	/*	GPI2 */
-	gpi_cfg_tmp.alloc_retry_cycles = 0x200U;
-	gpi_cfg_tmp.gpi_tmlf_txthres = 0x178U;
-	gpi_cfg_tmp.gpi_dtx_aseq_len = aseq_len; /* See AAVB-2028 */
-	gpi_cfg_tmp.emac_1588_ts_en = TRUE;
+		platform->gpi[0] = pfe_gpi_create(platform->cbus_baseaddr, CBUS_EGPI1_BASE_ADDR, &gpi_cfg_tmp);
+		if (NULL == platform->gpi[0])
+		{
+			NXP_LOG_ERROR("Couldn't create GPI1 instance\n");
+			ret = ENODEV;
+		}
+		else
+		{
 
-	platform->gpi[1] = pfe_gpi_create(platform->cbus_baseaddr, CBUS_EGPI2_BASE_ADDR, &gpi_cfg_tmp);
-	if (NULL == platform->gpi[1])
-	{
-		NXP_LOG_ERROR("Couldn't create GPI2 instance\n");
-		return ENODEV;
-	}
+			/*	GPI2 */
+			gpi_cfg_tmp.alloc_retry_cycles = 0x200U;
+			gpi_cfg_tmp.gpi_tmlf_txthres = 0x178U;
+			gpi_cfg_tmp.gpi_dtx_aseq_len = aseq_len; /* See AAVB-2028 */
+			gpi_cfg_tmp.emac_1588_ts_en = TRUE;
 
-	/*	GPI3 */
-	gpi_cfg_tmp.alloc_retry_cycles = 0x200U;
-	gpi_cfg_tmp.gpi_tmlf_txthres = 0x178U;
-	gpi_cfg_tmp.gpi_dtx_aseq_len = aseq_len; /* See AAVB-2028 */
-	gpi_cfg_tmp.emac_1588_ts_en = TRUE;
+			platform->gpi[1] = pfe_gpi_create(platform->cbus_baseaddr, CBUS_EGPI2_BASE_ADDR, &gpi_cfg_tmp);
+			if (NULL == platform->gpi[1])
+			{
+				NXP_LOG_ERROR("Couldn't create GPI2 instance\n");
+				ret = ENODEV;
+			}
+			else
+			{
+				/*	GPI3 */
+				gpi_cfg_tmp.alloc_retry_cycles = 0x200U;
+				gpi_cfg_tmp.gpi_tmlf_txthres = 0x178U;
+				gpi_cfg_tmp.gpi_dtx_aseq_len = aseq_len; /* See AAVB-2028 */
+				gpi_cfg_tmp.emac_1588_ts_en = TRUE;
 
-	platform->gpi[2] = pfe_gpi_create(platform->cbus_baseaddr, CBUS_EGPI3_BASE_ADDR, &gpi_cfg_tmp);
-	if (NULL == platform->gpi[2])
-	{
-		NXP_LOG_ERROR("Couldn't create GPI3 instance\n");
-		return ENODEV;
+				platform->gpi[2] = pfe_gpi_create(platform->cbus_baseaddr, CBUS_EGPI3_BASE_ADDR, &gpi_cfg_tmp);
+				if (NULL == platform->gpi[2])
+				{
+					NXP_LOG_ERROR("Couldn't create GPI3 instance\n");
+					ret = ENODEV;
+				}
+				else
+				{
+					ret = EOK;
+				}
+			}
+		}
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1791,54 +1848,76 @@ static void pfe_platform_destroy_gpi(pfe_platform_t *platform)
 static errno_t pfe_platform_create_etgpi(pfe_platform_t *platform)
 {
 	pfe_gpi_cfg_t gpi_cfg_tmp;
+	errno_t ret;
 
 	platform->etgpi = oal_mm_malloc(platform->etgpi_count * sizeof(pfe_gpi_t *));
 	if (NULL == platform->etgpi)
 	{
 		NXP_LOG_ERROR("oal_mm_malloc() failed\n");
-		return ENOMEM;
+		ret = ENOMEM;
 	}
-
-	/*	ETGPI1 */
-	gpi_cfg_tmp.alloc_retry_cycles = 0x200U;
-	gpi_cfg_tmp.gpi_tmlf_txthres = 0xbcU;
-	gpi_cfg_tmp.gpi_dtx_aseq_len = 0x40;
-	gpi_cfg_tmp.emac_1588_ts_en = TRUE;
-
-	platform->etgpi[0] = pfe_gpi_create(platform->cbus_baseaddr, CBUS_ETGPI1_BASE_ADDR, &gpi_cfg_tmp);
-	if (NULL == platform->etgpi[0])
+	else
 	{
-		NXP_LOG_ERROR("Couldn't create ETGPI1 instance\n");
-		return ENODEV;
-	}
+	#if 0 /* AAVB-5037 */
+		if(PFE_S32G3_VERSION == platform->pfe_version)
+		{   /* S32G3 */
+			gpi_cfg_tmp.lmem_header_size = 48U;
+		}
+		else
+	#endif
+		{   /* S32G2 */
+			gpi_cfg_tmp.lmem_header_size = 112U;
+		}
 
-	/*	ETGPI2 */
-	gpi_cfg_tmp.alloc_retry_cycles = 0x200U;
-	gpi_cfg_tmp.gpi_tmlf_txthres = 0xbcU;
-	gpi_cfg_tmp.gpi_dtx_aseq_len = 0x40;
-	gpi_cfg_tmp.emac_1588_ts_en = TRUE;
+		/*	ETGPI1 */
+		gpi_cfg_tmp.alloc_retry_cycles = 0x200U;
+		gpi_cfg_tmp.gpi_tmlf_txthres = 0xbcU;
+		gpi_cfg_tmp.gpi_dtx_aseq_len = 0x40;
+		gpi_cfg_tmp.emac_1588_ts_en = TRUE;
 
-	platform->etgpi[1] = pfe_gpi_create(platform->cbus_baseaddr, CBUS_ETGPI2_BASE_ADDR, &gpi_cfg_tmp);
-	if (NULL == platform->etgpi[1])
-	{
-		NXP_LOG_ERROR("Couldn't create ETGPI2 instance\n");
-		return ENODEV;
-	}
+		platform->etgpi[0] = pfe_gpi_create(platform->cbus_baseaddr, CBUS_ETGPI1_BASE_ADDR, &gpi_cfg_tmp);
+		if (NULL == platform->etgpi[0])
+		{
+			NXP_LOG_ERROR("Couldn't create ETGPI1 instance\n");
+			ret = ENODEV;
+		}
+		else
+		{
+			/*	ETGPI2 */
+			gpi_cfg_tmp.alloc_retry_cycles = 0x200U;
+			gpi_cfg_tmp.gpi_tmlf_txthres = 0xbcU;
+			gpi_cfg_tmp.gpi_dtx_aseq_len = 0x40;
+			gpi_cfg_tmp.emac_1588_ts_en = TRUE;
 
-	/*	ETGPI3 */
-	gpi_cfg_tmp.alloc_retry_cycles = 0x200U;
-	gpi_cfg_tmp.gpi_tmlf_txthres = 0xbcU;
-	gpi_cfg_tmp.gpi_dtx_aseq_len = 0x40;
-	gpi_cfg_tmp.emac_1588_ts_en = TRUE;
+			platform->etgpi[1] = pfe_gpi_create(platform->cbus_baseaddr, CBUS_ETGPI2_BASE_ADDR, &gpi_cfg_tmp);
+			if (NULL == platform->etgpi[1])
+			{
+				NXP_LOG_ERROR("Couldn't create ETGPI2 instance\n");
+				ret = ENODEV;
+			}
+			else
+			{
+				/*	ETGPI3 */
+				gpi_cfg_tmp.alloc_retry_cycles = 0x200U;
+				gpi_cfg_tmp.gpi_tmlf_txthres = 0xbcU;
+				gpi_cfg_tmp.gpi_dtx_aseq_len = 0x40;
+				gpi_cfg_tmp.emac_1588_ts_en = TRUE;
 
-	platform->etgpi[2] = pfe_gpi_create(platform->cbus_baseaddr, CBUS_ETGPI3_BASE_ADDR, &gpi_cfg_tmp);
-	if (NULL == platform->etgpi[2])
-	{
-		NXP_LOG_ERROR("Couldn't create ETGPI3 instance\n");
-		return ENODEV;
+				platform->etgpi[2] = pfe_gpi_create(platform->cbus_baseaddr, CBUS_ETGPI3_BASE_ADDR, &gpi_cfg_tmp);
+				if (NULL == platform->etgpi[2])
+				{
+					NXP_LOG_ERROR("Couldn't create ETGPI3 instance\n");
+					ret = ENODEV;
+				}
+				else
+				{
+					ret = EOK;
+				}
+			}
+		}
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1870,27 +1949,45 @@ static void pfe_platform_destroy_etgpi(pfe_platform_t *platform)
 static errno_t pfe_platform_create_hgpi(pfe_platform_t *platform)
 {
 	pfe_gpi_cfg_t hgpi_cfg;
+	errno_t ret;
 
 	platform->hgpi = oal_mm_malloc(platform->hgpi_count * sizeof(pfe_gpi_t *));
 	if (NULL == platform->hgpi)
 	{
 		NXP_LOG_ERROR("oal_mm_malloc() failed\n");
-		return ENOMEM;
+		ret = ENOMEM;
 	}
+	else
+	{
+	#if 0 /* AAVB-5037 */
+		if(PFE_S32G3_VERSION == platform->pfe_version)
+		{   /* S32G3 */
+			hgpi_cfg.lmem_header_size = 48U;
+		}
+		else
+	#endif
+		{   /* S32G2 */
+			hgpi_cfg.lmem_header_size = 112U;
+		}
 
-	hgpi_cfg.alloc_retry_cycles = 0x200U;
-	hgpi_cfg.gpi_tmlf_txthres = 0x178U;
-	hgpi_cfg.gpi_dtx_aseq_len = HGPI_ASEQ_LEN;
-	hgpi_cfg.emac_1588_ts_en = FALSE;
+		hgpi_cfg.alloc_retry_cycles = 0x200U;
+		hgpi_cfg.gpi_tmlf_txthres = 0x178U;
+		hgpi_cfg.gpi_dtx_aseq_len = HGPI_ASEQ_LEN;
+		hgpi_cfg.emac_1588_ts_en = FALSE;
 
-	platform->hgpi[0] = pfe_gpi_create(platform->cbus_baseaddr, CBUS_HGPI_BASE_ADDR, &hgpi_cfg);
-	if (NULL == platform->hgpi[0])
-	{
-		NXP_LOG_ERROR("Couldn't create HGPI instance\n");
-		return ENODEV;
+		platform->hgpi[0] = pfe_gpi_create(platform->cbus_baseaddr, CBUS_HGPI_BASE_ADDR, &hgpi_cfg);
+		if (NULL == platform->hgpi[0])
+		{
+			NXP_LOG_ERROR("Couldn't create HGPI instance\n");
+			ret = ENODEV;
+		}
+		else
+		{
+			ret = EOK;
+		}
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1936,61 +2033,76 @@ static errno_t pfe_platform_create_class(pfe_platform_t *platform)
 	if (NULL == platform->fw)
 	{
 		NXP_LOG_ERROR("The CLASS firmware is NULL\n");
-		return ENODEV;
+		ret = ENODEV;
 	}
-
-	if ((NULL == platform->fw->class_data) || (0U == platform->fw->class_size))
+	else if ((NULL == platform->fw->class_data) || (0U == platform->fw->class_size))
 	{
 		NXP_LOG_ERROR("The CLASS firmware is not loaded\n");
-		return EIO;
-	}
-
-	platform->classifier = pfe_class_create(platform->cbus_baseaddr, platform->class_pe_count, &class_cfg);
-
-	if (NULL == platform->classifier)
-	{
-		NXP_LOG_ERROR("Couldn't create classifier instance\n");
-		return ENODEV;
+		ret = EIO;
 	}
 	else
 	{
-		temp = (uint8_t *)platform->fw->class_data;
 
-		if ((temp[0] == 0x7fU) &&
-			(temp[1] == (uint8_t)('E')) &&
-			(temp[2] == (uint8_t)('L')) &&
-			(temp[3] == (uint8_t)('F')))
+	#if 0 /* AAVB-5037 */
+		if(PFE_S32G3_VERSION == platform->pfe_version)
+		{   /* S32G3 */
+			class_cfg.lmem_header_size = 48U;
+			class_cfg.ro_header_size = 512U;
+		}
+		else
+	#endif
+		{   /* S32G2 */
+			class_cfg.lmem_header_size = 112U;
+			class_cfg.ro_header_size = 256U;
+		}
+
+		platform->classifier = pfe_class_create(platform->cbus_baseaddr, platform->class_pe_count, &class_cfg);
+
+		if (NULL == platform->classifier)
 		{
-			/*	FW is ELF file */
-			NXP_LOG_INFO("Firmware .elf detected\n");
+			NXP_LOG_ERROR("Couldn't create classifier instance\n");
+			ret = ENODEV;
+		}
+		else
+		{
+			temp = (uint8_t *)platform->fw->class_data;
 
-			if (FALSE == ELF_Open(&elf, platform->fw->class_data, platform->fw->class_size))
-			{
-				NXP_LOG_ERROR("Can't parse CLASS firmware\n");
-				return EIO;
-			}
-			else
+			if ((temp[0] == 0x7fU) &&
+				(temp[1] == (uint8_t)('E')) &&
+				(temp[2] == (uint8_t)('L')) &&
+				(temp[3] == (uint8_t)('F')))
 			{
-				NXP_LOG_INFO("Uploading CLASS firmware\n");
-				ret = pfe_class_load_firmware(platform->classifier, &elf);
-
-				ELF_Close(&elf);
+				/*	FW is ELF file */
+				NXP_LOG_INFO("Firmware .elf detected\n");
 
-				if (EOK != ret)
+				if (FALSE == ELF_Open(&elf, platform->fw->class_data, platform->fw->class_size))
+				{
+					NXP_LOG_ERROR("Can't parse CLASS firmware\n");
+					ret = EIO;
+				}
+				else
 				{
-					NXP_LOG_ERROR("Error during upload of CLASS firmware: %d\n", ret);
-					return EIO;
+					NXP_LOG_INFO("Uploading CLASS firmware\n");
+					ret = pfe_class_load_firmware(platform->classifier, &elf);
+
+					ELF_Close(&elf);
+
+					if (EOK != ret)
+					{
+						NXP_LOG_ERROR("Error during upload of CLASS firmware: %d\n", ret);
+						ret = EIO;
+					}
 				}
 			}
-		}
-		else
-		{
-			NXP_LOG_ERROR("Only ELF format is supported\n");
-			return ENODEV;
+			else
+			{
+				NXP_LOG_ERROR("Only ELF format is supported\n");
+				ret = ENODEV;
+			}
 		}
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -2013,41 +2125,51 @@ static errno_t pfe_platform_create_l2_bridge(pfe_platform_t *platform, const pfe
 {
 	uint16_t vlan_id = config->vlan_id;
 	uint16_t vlan_stats_size = config->vlan_stats_size;
+	errno_t ret;
 
 	platform->mactab = pfe_l2br_table_create(platform->cbus_baseaddr, PFE_L2BR_TABLE_MAC2F);
 	if (NULL == platform->mactab)
 	{
 		NXP_LOG_ERROR("Couldn't create MAC table instance\n");
-		return ENODEV;
+		ret = ENODEV;
 	}
-
-	platform->vlantab = pfe_l2br_table_create(platform->cbus_baseaddr, PFE_L2BR_TABLE_VLAN);
-	if (NULL == platform->vlantab)
+	else
 	{
-		NXP_LOG_ERROR("Couldn't create VLAN table instance\n");
-		return ENODEV;
-	}
 
-	if((vlan_id == 0U) || (vlan_id >= 4095U))
-	{
-		NXP_LOG_WARNING("VLAN ID incorrect or not set. Using default VLAN ID = 0x01.\n");
-		vlan_id = 0x01;
-	}
+		platform->vlantab = pfe_l2br_table_create(platform->cbus_baseaddr, PFE_L2BR_TABLE_VLAN);
+		if (NULL == platform->vlantab)
+		{
+			NXP_LOG_ERROR("Couldn't create VLAN table instance\n");
+			ret = ENODEV;
+		}
+		else
+		{			
+			if((vlan_id == 0U) || (vlan_id >= 4095U))
+			{
+				NXP_LOG_WARNING("VLAN ID incorrect or not set. Using default VLAN ID = 0x01.\n");
+				vlan_id = 0x01;
+			}
 
-	if ((vlan_stats_size < 2U) || (vlan_stats_size > 128U))
-	{
-		NXP_LOG_WARNING("VLAN stats size incorrect or not set. Using default VLAN stats size = 20.\n");
-		vlan_stats_size = 20;
-	}
+			if ((vlan_stats_size < 2U) || (vlan_stats_size > 128U))
+			{
+				NXP_LOG_WARNING("VLAN stats size incorrect or not set. Using default VLAN stats size = 20.\n");
+				vlan_stats_size = 20;
+			}
 
-	platform->l2_bridge = pfe_l2br_create(platform->classifier, vlan_id, 300U, vlan_stats_size, platform->mactab, platform->vlantab);
-	if (NULL == platform->l2_bridge)
-	{
-		NXP_LOG_ERROR("Could not create L2 Bridge\n");
-		return ENODEV;
+			platform->l2_bridge = pfe_l2br_create(platform->classifier, vlan_id, 300U, vlan_stats_size, platform->mactab, platform->vlantab);
+			if (NULL == platform->l2_bridge)
+			{
+				NXP_LOG_ERROR("Could not create L2 Bridge\n");
+				ret = ENODEV;
+			}
+			else
+			{
+				ret = EOK;
+			}
+		}
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -2085,45 +2207,52 @@ static errno_t pfe_platform_create_rtable(pfe_platform_t *platform, const pfe_pl
 	addr_t htable_mem;
 	addr_t pool_mem;
 	uint32_t pool_offs;
+	errno_t ret;
 
 	if (config->rtable_hash_size > PFE_CFG_RT_HASH_ENTRIES_MAX_CNT)
 	{
 		NXP_LOG_ERROR("Required HASH size exceeds allowed range.\n");
-		return EINVAL;
-	}
-
-	pool_offs = config->rtable_hash_size * pfe_rtable_get_entry_size();
-
-	platform->rtable_size = (config->rtable_hash_size + config->rtable_collision_size) * pfe_rtable_get_entry_size();
-	platform->rtable_va = oal_mm_malloc_contig_named_aligned_nocache(PFE_CFG_RT_MEM, platform->rtable_size, 2048U);
-	if (NULL == platform->rtable_va)
-	{
-		NXP_LOG_ERROR("Unable to get routing table memory\n");
-		return ENOMEM;
+		ret = EINVAL;
 	}
-
-	htable_mem = (addr_t)platform->rtable_va;
-	pool_mem = (addr_t)platform->rtable_va + pool_offs;
-
-	if (NULL == platform->classifier)
+	else
 	{
-		NXP_LOG_ERROR("Valid classifier instance required\n");
-		return ENODEV;
-	}
+		pool_offs = config->rtable_hash_size * pfe_rtable_get_entry_size();
 
-	platform->rtable = pfe_rtable_create(platform->classifier, htable_mem, config->rtable_hash_size, pool_mem, config->rtable_collision_size, platform->l2_bridge);
+		platform->rtable_size = (config->rtable_hash_size + config->rtable_collision_size) * pfe_rtable_get_entry_size();
+		platform->rtable_va = oal_mm_malloc_contig_named_aligned_nocache(PFE_CFG_RT_MEM, platform->rtable_size, 2048U);
+		if (NULL == platform->rtable_va)
+		{
+			NXP_LOG_ERROR("Unable to get routing table memory\n");
+			ret = ENOMEM;
+		}
+		else
+		{
+			htable_mem = (addr_t)platform->rtable_va;
+			pool_mem = (addr_t)platform->rtable_va + pool_offs;
 
-	if (NULL == platform->rtable)
-	{
-		NXP_LOG_ERROR("Couldn't create routing table instance\n");
-		return ENODEV;
-	}
-	else
-	{
-		NXP_LOG_INFO("Routing table created, Hash Table @ p0x%"PRINTADDR_T", Pool @ p0x%"PRINTADDR_T" (%u bytes)\n", (addr_t)oal_mm_virt_to_phys_contig((void *)htable_mem), (addr_t)oal_mm_virt_to_phys_contig((void *)htable_mem) + (addr_t)pool_offs, (uint_t)platform->rtable_size);
-	}
+			if (NULL == platform->classifier)
+			{
+				NXP_LOG_ERROR("Valid classifier instance required\n");
+				ret = ENODEV;
+			}
+			else
+			{
+				platform->rtable = pfe_rtable_create(platform->classifier, htable_mem, config->rtable_hash_size, pool_mem, config->rtable_collision_size, platform->l2_bridge);
 
-	return EOK;
+				if (NULL == platform->rtable)
+				{
+					NXP_LOG_ERROR("Couldn't create routing table instance\n");
+					ret = ENODEV;
+				}
+				else
+				{
+					NXP_LOG_INFO("Routing table created, Hash Table @ p0x%"PRINTADDR_T", Pool @ p0x%"PRINTADDR_T" (%u bytes)\n", (addr_t)oal_mm_virt_to_phys_contig((void *)htable_mem), (addr_t)oal_mm_virt_to_phys_contig((void *)htable_mem) + (addr_t)pool_offs, (uint_t)platform->rtable_size);
+					ret = EOK;
+				}
+			}
+		}
+	}
+	return ret;
 }
 
 /**
@@ -2150,6 +2279,7 @@ static void pfe_platform_destroy_rtable(pfe_platform_t *platform)
  */
 static errno_t pfe_platform_create_tmu(pfe_platform_t *platform)
 {
+	errno_t ret;
 	pfe_tmu_cfg_t tmu_cfg =
 	{
 		.pe_sys_clk_ratio = PFE_CFG_CLMODE,
@@ -2160,10 +2290,14 @@ static errno_t pfe_platform_create_tmu(pfe_platform_t *platform)
 	if (NULL == platform->tmu)
 	{
 		NXP_LOG_ERROR("Couldn't create TMU instance\n");
-		return ENODEV;
+		ret = ENODEV;
+	}
+	else
+	{
+		ret = EOK;
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -2194,7 +2328,7 @@ static errno_t pfe_platform_create_util(pfe_platform_t *platform)
 	if (NULL == platform->util)
 	{
 		NXP_LOG_ERROR("Couldn't create UTIL instance\n");
-		return ENODEV;
+		ret = ENODEV;
 	}
 	else
 	{
@@ -2203,30 +2337,32 @@ static errno_t pfe_platform_create_util(pfe_platform_t *platform)
 		if ((NULL == platform->fw->util_data) || (0U == platform->fw->util_size))
 		{
 			NXP_LOG_WARNING("The UTIL firmware is not loaded\n");
-			return EOK;
-		}
-
-		if (FALSE == ELF_Open(&elf, platform->fw->util_data, platform->fw->util_size))
-		{
-			NXP_LOG_ERROR("Can't parse UTIL firmware\n");
-			return EIO;
+			ret = EOK;
 		}
 		else
 		{
-			NXP_LOG_INFO("Uploading UTIL firmware\n");
-			ret = pfe_util_load_firmware(platform->util, &elf);
+			if (FALSE == ELF_Open(&elf, platform->fw->util_data, platform->fw->util_size))
+			{
+				NXP_LOG_ERROR("Can't parse UTIL firmware\n");
+				ret = EIO;
+			}
+			else
+			{
+				NXP_LOG_INFO("Uploading UTIL firmware\n");
+				ret = pfe_util_load_firmware(platform->util, &elf);
 
-			ELF_Close(&elf);
+				ELF_Close(&elf);
 
-			if (EOK != ret)
-			{
-				NXP_LOG_ERROR("Error during upload of UTIL firmware: %d\n", ret);
-				return EIO;
+				if (EOK != ret)
+				{
+					NXP_LOG_ERROR("Error during upload of UTIL firmware: %d\n", ret);
+					ret = EIO;
+				}
 			}
 		}
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -2246,90 +2382,101 @@ static void pfe_platform_destroy_util(pfe_platform_t *platform)
  */
 static errno_t pfe_platform_create_emac(pfe_platform_t *platform, const pfe_platform_config_t *config)
 {
+	errno_t ret = EOK;
+
 	/*	Create storage for instances */
 	platform->emac = oal_mm_malloc(platform->emac_count * sizeof(pfe_emac_t *));
 	if (NULL == platform->emac)
 	{
 		NXP_LOG_ERROR("oal_mm_malloc() failed\n");
-		return ENOMEM;
-	}
-
-	/*	EMAC1 */
-	platform->emac[0] = pfe_emac_create(platform->cbus_baseaddr, CBUS_EMAC1_BASE_ADDR,
-							config->emac_mode[0], EMAC_SPEED_1000_MBPS, EMAC_DUPLEX_FULL);
-	if (NULL == platform->emac[0])
-	{
-		NXP_LOG_ERROR("Couldn't create EMAC1 instance\n");
-		return ENODEV;
+		ret = ENOMEM;
 	}
 	else
 	{
-		(void)pfe_emac_set_max_frame_length(platform->emac[0], 1522);
-		pfe_emac_enable_rx_flow_control(platform->emac[0]);
-		pfe_emac_enable_broadcast(platform->emac[0]);
 
-#ifdef PFE_CFG_IEEE1588_SUPPORT
-		if (EOK != pfe_emac_enable_ts(platform->emac[0],
-				PFE_CFG_IEEE1588_I_CLK_HZ, PFE_CFG_IEEE1588_EMAC0_O_CLK_HZ))
+		/*	EMAC1 */
+		platform->emac[0] = pfe_emac_create(platform->cbus_baseaddr, CBUS_EMAC1_BASE_ADDR, 
+								config->emac_mode[0], EMAC_SPEED_1000_MBPS, EMAC_DUPLEX_FULL);
+		if (NULL == platform->emac[0])
 		{
-			NXP_LOG_WARNING("EMAC0: Could not configure the timestamping unit\n");
+			NXP_LOG_ERROR("Couldn't create EMAC1 instance\n");
+			ret = ENODEV;
 		}
+		else
+		{
+			(void)pfe_emac_set_max_frame_length(platform->emac[0], 1522);
+			pfe_emac_enable_rx_flow_control(platform->emac[0]);
+			pfe_emac_enable_broadcast(platform->emac[0]);
+
+#ifdef PFE_CFG_IEEE1588_SUPPORT
+			if (EOK != pfe_emac_enable_ts(platform->emac[0], 
+					PFE_CFG_IEEE1588_I_CLK_HZ, PFE_CFG_IEEE1588_EMAC0_O_CLK_HZ))
+			{
+				NXP_LOG_WARNING("EMAC0: Could not configure the timestamping unit\n");
+			}
 #endif /* PFE_CFG_IEEE1588_SUPPORT */
 
-		/*	MAC address will be added with phy/log interface */
-	}
+			/*	MAC address will be added with phy/log interface */
+		}
 
-	/*	EMAC2 */
-	platform->emac[1] = pfe_emac_create(platform->cbus_baseaddr, CBUS_EMAC2_BASE_ADDR,
-							config->emac_mode[1], EMAC_SPEED_1000_MBPS, EMAC_DUPLEX_FULL);
-	if (NULL == platform->emac[1])
-	{
-		NXP_LOG_ERROR("Couldn't create EMAC2 instance\n");
-		return ENODEV;
-	}
-	else
-	{
-		(void)pfe_emac_set_max_frame_length(platform->emac[1], 1522);
-		pfe_emac_enable_rx_flow_control(platform->emac[1]);
-		pfe_emac_enable_broadcast(platform->emac[1]);
+		/*	EMAC2 */
+		if (EOK == ret)
+		{
+			platform->emac[1] = pfe_emac_create(platform->cbus_baseaddr, CBUS_EMAC2_BASE_ADDR, 
+									config->emac_mode[1], EMAC_SPEED_1000_MBPS, EMAC_DUPLEX_FULL);
+			if (NULL == platform->emac[1])
+			{
+				NXP_LOG_ERROR("Couldn't create EMAC2 instance\n");
+				ret = ENODEV;
+			}
+			else
+			{
+				(void)pfe_emac_set_max_frame_length(platform->emac[1], 1522);
+				pfe_emac_enable_rx_flow_control(platform->emac[1]);
+				pfe_emac_enable_broadcast(platform->emac[1]);
 
 #ifdef PFE_CFG_IEEE1588_SUPPORT
-		if (EOK != pfe_emac_enable_ts(platform->emac[1],
-				PFE_CFG_IEEE1588_I_CLK_HZ, PFE_CFG_IEEE1588_EMAC1_O_CLK_HZ))
-		{
-			NXP_LOG_WARNING("EMAC1: Could not configure the timestamping unit\n");
-		}
+				if (EOK != pfe_emac_enable_ts(platform->emac[1], 
+						PFE_CFG_IEEE1588_I_CLK_HZ, PFE_CFG_IEEE1588_EMAC1_O_CLK_HZ))
+				{
+					NXP_LOG_WARNING("EMAC1: Could not configure the timestamping unit\n");
+				}
 #endif /* PFE_CFG_IEEE1588_SUPPORT */
 
-		/*	MAC address will be added with phy/log interface */
-	}
+				/*	MAC address will be added with phy/log interface */
+			}
+		}
 
-	/*	EMAC3 */
-	platform->emac[2] = pfe_emac_create(platform->cbus_baseaddr, CBUS_EMAC3_BASE_ADDR,
-							config->emac_mode[2], EMAC_SPEED_1000_MBPS, EMAC_DUPLEX_FULL);
-	if (NULL == platform->emac[2])
-	{
-		NXP_LOG_ERROR("Couldn't create EMAC3 instance\n");
-		return ENODEV;
-	}
-	else
-	{
-		(void)pfe_emac_set_max_frame_length(platform->emac[2], 1522);
-		pfe_emac_enable_rx_flow_control(platform->emac[2]);
-		pfe_emac_enable_broadcast(platform->emac[2]);
+		if (EOK == ret)
+		{
+			/*	EMAC3 */
+			platform->emac[2] = pfe_emac_create(platform->cbus_baseaddr, CBUS_EMAC3_BASE_ADDR, 
+									config->emac_mode[2], EMAC_SPEED_1000_MBPS, EMAC_DUPLEX_FULL);
+			if (NULL == platform->emac[2])
+			{
+				NXP_LOG_ERROR("Couldn't create EMAC3 instance\n");
+				return ENODEV;
+			}
+			else
+			{
+				(void)pfe_emac_set_max_frame_length(platform->emac[2], 1522);
+				pfe_emac_enable_rx_flow_control(platform->emac[2]);
+				pfe_emac_enable_broadcast(platform->emac[2]);
 
 #ifdef PFE_CFG_IEEE1588_SUPPORT
-		if (EOK != pfe_emac_enable_ts(platform->emac[2],
-				PFE_CFG_IEEE1588_I_CLK_HZ, PFE_CFG_IEEE1588_EMAC2_O_CLK_HZ))
-		{
-			NXP_LOG_WARNING("EMAC2: Could not configure the timestamping unit\n");
-		}
+				if (EOK != pfe_emac_enable_ts(platform->emac[2], 
+						PFE_CFG_IEEE1588_I_CLK_HZ, PFE_CFG_IEEE1588_EMAC2_O_CLK_HZ))
+				{
+					NXP_LOG_WARNING("EMAC2: Could not configure the timestamping unit\n");
+				}
 #endif /* PFE_CFG_IEEE1588_SUPPORT */
 
-		/*	MAC address will be added with phy/log interface */
+				/*	MAC address will be added with phy/log interface */
+			}
+		}
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -2360,38 +2507,42 @@ static void pfe_platform_destroy_emac(pfe_platform_t *platform)
  */
 static errno_t pfe_platform_create_safety(pfe_platform_t *platform, const pfe_platform_config_t *config)
 {
+	errno_t ret;
 	(void)config;
+
 	/*	Safety */
 	platform->safety = pfe_safety_create(platform->cbus_baseaddr, CBUS_GLOBAL_CSR_BASE_ADDR);
 
 	if (NULL == platform->safety)
 	{
 		NXP_LOG_ERROR("Couldn't create SAFETY instance\n");
-		return ENODEV;
+		ret = ENODEV;
 	}
 	else
 	{
 		NXP_LOG_INFO("SAFETY instance created\n");
-	}
 
-	/*	Watchdogs */
-	platform->wdt = pfe_wdt_create(platform->cbus_baseaddr, CBUS_GLOBAL_CSR_BASE_ADDR);
+		/*	Watchdogs */
+		platform->wdt = pfe_wdt_create(platform->cbus_baseaddr, CBUS_GLOBAL_CSR_BASE_ADDR);
 
-	if (NULL == platform->wdt)
-	{
-		NXP_LOG_ERROR("Couldn't create Watchdog instance\n");
-		return ENODEV;
-	}
-	else
-	{
-		NXP_LOG_INFO("Watchdog instance created\n");
-	}
+		if (NULL == platform->wdt)
+		{
+			NXP_LOG_ERROR("Couldn't create Watchdog instance\n");
+			ret = ENODEV;
+		}
+		else
+		{
+			NXP_LOG_INFO("Watchdog instance created\n");
 
-	pfe_safety_irq_unmask(platform->safety);
+			pfe_safety_irq_unmask(platform->safety);
 
-	pfe_wdt_irq_unmask(platform->wdt);
+			pfe_wdt_irq_unmask(platform->wdt);
 
-	return EOK;
+			ret = EOK;
+		}
+	}
+
+	return ret;
 }
 
 /**
@@ -2420,7 +2571,7 @@ static void pfe_platform_destroy_safety(pfe_platform_t *platform)
 static errno_t pfe_platform_create_fci(pfe_platform_t *platform)
 {
 	fci_init_info_t fci_init_info;
-	errno_t ret = EOK;
+	errno_t ret;
 
 #if defined(PFE_CFG_RTABLE_ENABLE)
 	fci_init_info.rtable = platform->rtable;
@@ -2436,11 +2587,13 @@ static errno_t pfe_platform_create_fci(pfe_platform_t *platform)
 	if (EOK != ret)
 	{
 		NXP_LOG_ERROR("Could not create the FCI endpoint\n");
-		return ret;
+	}
+	else
+	{
+		platform->fci_created = TRUE;
 	}
 
-	platform->fci_created = TRUE;
-	return EOK;
+	return ret;
 }
 
 /**
@@ -2466,28 +2619,32 @@ errno_t pfe_platform_register_log_if(const pfe_platform_t *platform, pfe_log_if_
 	if (unlikely((NULL == platform) || (NULL == log_if)))
 	{
 		NXP_LOG_ERROR("Null argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	ret = pfe_if_db_lock(&session_id);
-	if (EOK != ret)
 	{
-		NXP_LOG_DEBUG("DB lock failed: %d\n", ret);
-		return ret;
-	}
+		ret = pfe_if_db_lock(&session_id);
+		if (EOK != ret)
+		{
+			NXP_LOG_DEBUG("DB lock failed: %d\n", ret);
+		}
+		else
+		{
 
-	/*	Register in platform to db */
-	ret = pfe_if_db_add(platform->log_if_db, session_id, log_if, PFE_CFG_LOCAL_IF);
-	if (EOK != ret)
-	{
-		NXP_LOG_ERROR("Could not register %s: %d\n", pfe_log_if_get_name(log_if), ret);
-		pfe_log_if_destroy(log_if);
-	}
+			/*	Register in platform to db */
+			ret = pfe_if_db_add(platform->log_if_db, session_id, log_if, PFE_CFG_LOCAL_IF);
+			if (EOK != ret)
+			{
+				NXP_LOG_ERROR("Could not register %s: %d\n", pfe_log_if_get_name(log_if), ret);
+				pfe_log_if_destroy(log_if);
+			}
 
-	if (EOK != pfe_if_db_unlock(session_id))
-	{
-		NXP_LOG_DEBUG("DB unlock failed\n");
+			if (EOK != pfe_if_db_unlock(session_id))
+			{
+				NXP_LOG_DEBUG("DB unlock failed\n");
+			}
+		}
 	}
 
 	return ret;
@@ -2500,7 +2657,7 @@ errno_t pfe_platform_register_log_if(const pfe_platform_t *platform, pfe_log_if_
  */
 errno_t pfe_platform_unregister_log_if(const pfe_platform_t *platform, pfe_log_if_t *log_if)
 {
-	errno_t ret = EOK;
+	errno_t ret;
 	pfe_if_db_entry_t *entry = NULL;
 	uint32_t session_id;
 
@@ -2508,35 +2665,39 @@ errno_t pfe_platform_unregister_log_if(const pfe_platform_t *platform, pfe_log_i
 	if (unlikely((NULL == platform) || (NULL == log_if)))
 	{
 		NXP_LOG_ERROR("Null argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	ret = pfe_if_db_lock(&session_id);
-	if (EOK != ret)
 	{
-		NXP_LOG_DEBUG("DB lock failed: %d\n", ret);
-		return ret;
-	}
+		ret = pfe_if_db_lock(&session_id);
+		if (EOK != ret)
+		{
+			NXP_LOG_DEBUG("DB lock failed: %d\n", ret);
+		}
+		else
+		{
 
-	ret = pfe_if_db_get_first(platform->log_if_db, session_id, IF_DB_CRIT_BY_INSTANCE, (void *)log_if, &entry);
-	if (NULL == entry)
-	{
-		ret = ENOENT;
-	}
-	else if (EOK == ret)
-	{
-		ret = pfe_if_db_remove(platform->log_if_db, session_id, entry);
-	}
-	else
-	{
-		/*Do Nothing*/
-		;
-	}
+			ret = pfe_if_db_get_first(platform->log_if_db, session_id, IF_DB_CRIT_BY_INSTANCE, (void *)log_if, &entry);
+			if (NULL == entry)
+			{
+				ret = ENOENT;
+			}
+			else if (EOK == ret)
+			{
+				ret = pfe_if_db_remove(platform->log_if_db, session_id, entry);
+			}
+			else
+			{
+				/*Do Nothing*/
+				;
+			}
 
-	if (EOK != pfe_if_db_unlock(session_id))
-	{
-		NXP_LOG_DEBUG("DB unlock failed\n");
+			if (EOK != pfe_if_db_unlock(session_id))
+			{
+				NXP_LOG_DEBUG("DB unlock failed\n");
+			}
+		}
 	}
 
 	return ret;
@@ -2556,12 +2717,14 @@ static errno_t pfe_platform_register_phy_if(const pfe_platform_t *platform, uint
 	if (unlikely((NULL == platform) || (NULL == phy_if)))
 	{
 		NXP_LOG_ERROR("Null argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	/*	Owner of the interface is local driver instance */
-	ret = pfe_if_db_add(platform->phy_if_db, session_id, phy_if, PFE_CFG_LOCAL_IF);
+	{
+		/*	Owner of the interface is local driver instance */
+		ret = pfe_if_db_add(platform->phy_if_db, session_id, phy_if, PFE_CFG_LOCAL_IF);
+	}
 
 	return ret;
 }
@@ -2576,34 +2739,38 @@ pfe_log_if_t *pfe_platform_get_log_if_by_id(const pfe_platform_t *platform, uint
 {
 	pfe_if_db_entry_t *entry = NULL;
 	uint32_t session_id = 0U;
+	pfe_log_if_t *logif;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == platform))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return NULL;
+		logif = NULL;
 	}
-
-	if (unlikely(NULL == platform->log_if_db))
+	else if (unlikely(NULL == platform->log_if_db))
 	{
 		NXP_LOG_ERROR("Logical interface DB not found\n");
-		return NULL;
+		logif = NULL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (EOK != pfe_if_db_lock(&session_id))
 	{
-		NXP_LOG_DEBUG("DB lock failed\n");
-	}
+		if (EOK != pfe_if_db_lock(&session_id))
+		{
+			NXP_LOG_DEBUG("DB lock failed\n");
+		}
 
-	(void)pfe_if_db_get_first(platform->log_if_db, session_id, IF_DB_CRIT_BY_ID, (void *)(addr_t)id, &entry);
+		(void)pfe_if_db_get_first(platform->log_if_db, session_id, IF_DB_CRIT_BY_ID, (void *)(addr_t)id, &entry);
 
-	if (EOK != pfe_if_db_unlock(session_id))
-	{
-		NXP_LOG_DEBUG("DB unlock failed\n");
+		if (EOK != pfe_if_db_unlock(session_id))
+		{
+			NXP_LOG_DEBUG("DB unlock failed\n");
+		}
+
+		logif = pfe_if_db_entry_get_log_if(entry);
 	}
 
-	return pfe_if_db_entry_get_log_if(entry);
+	return logif;
 }
 
 /**
@@ -2614,36 +2781,41 @@ pfe_log_if_t *pfe_platform_get_log_if_by_id(const pfe_platform_t *platform, uint
  */
 pfe_log_if_t *pfe_platform_get_log_if_by_name(const pfe_platform_t *platform, char_t *name)
 {
-	pfe_if_db_entry_t *entry = NULL;
+	pfe_if_db_entry_t *entry;
 	uint32_t session_id = 0U;
+	pfe_log_if_t *logif;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == platform))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return NULL;
+		logif = NULL;
 	}
-
-	if (unlikely(NULL == platform->log_if_db))
+	else if (unlikely(NULL == platform->log_if_db))
 	{
 		NXP_LOG_ERROR("Logical interface DB not found\n");
-		return NULL;
+		logif = NULL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (EOK != pfe_if_db_lock(&session_id))
 	{
-		NXP_LOG_DEBUG("DB lock failed\n");
-	}
+		if (EOK != pfe_if_db_lock(&session_id))
+		{
+			NXP_LOG_DEBUG("DB lock failed\n");
+		}
 
-	(void)pfe_if_db_get_first(platform->log_if_db, session_id, IF_DB_CRIT_BY_NAME, (void *)name, &entry);
+		(void)pfe_if_db_get_first(platform->log_if_db, session_id, IF_DB_CRIT_BY_NAME, (void *)name, &entry);
+
+		if (EOK != pfe_if_db_unlock(session_id))
+		{
+			NXP_LOG_DEBUG("DB unlock failed\n");
+		}
+
+		logif = pfe_if_db_entry_get_log_if(entry);
 
-	if (EOK != pfe_if_db_unlock(session_id))
-	{
-		NXP_LOG_DEBUG("DB unlock failed\n");
 	}
 
-	return pfe_if_db_entry_get_log_if(entry);
+	return logif;
 }
 
 /**
@@ -2654,36 +2826,40 @@ pfe_log_if_t *pfe_platform_get_log_if_by_name(const pfe_platform_t *platform, ch
  */
 pfe_phy_if_t *pfe_platform_get_phy_if_by_id(const pfe_platform_t *platform, pfe_ct_phy_if_id_t id)
 {
-	pfe_if_db_entry_t *entry = NULL;
+	pfe_if_db_entry_t *entry;
 	uint32_t session_id = 0U;
+	pfe_phy_if_t *phyif;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == platform))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return NULL;
+		phyif = NULL;
 	}
-
-	if (unlikely(NULL == platform->phy_if_db))
+	else if (unlikely(NULL == platform->phy_if_db))
 	{
 		NXP_LOG_ERROR("Physical interface DB not found\n");
-		return NULL;
+		phyif = NULL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (EOK != pfe_if_db_lock(&session_id))
 	{
-		NXP_LOG_DEBUG("DB lock failed\n");
-	}
+		if (EOK != pfe_if_db_lock(&session_id))
+		{
+			NXP_LOG_DEBUG("DB lock failed\n");
+		}
 
-	(void)pfe_if_db_get_first(platform->phy_if_db, session_id, IF_DB_CRIT_BY_ID, (void *)(addr_t)id, &entry);
+		(void)pfe_if_db_get_first(platform->phy_if_db, session_id, IF_DB_CRIT_BY_ID, (void *)(addr_t)id, &entry);
 
-	if (EOK != pfe_if_db_unlock(session_id))
-	{
-		NXP_LOG_DEBUG("DB unlock failed\n");
-	}
+		if (EOK != pfe_if_db_unlock(session_id))
+		{
+			NXP_LOG_DEBUG("DB unlock failed\n");
+		}
+
+		phyif = pfe_if_db_entry_get_phy_if(entry);
 
-	return pfe_if_db_entry_get_phy_if(entry);
+	}
+	return phyif;
 }
 
 /**
@@ -2695,6 +2871,7 @@ errno_t pfe_platform_create_ifaces(pfe_platform_t *platform)
 	pfe_phy_if_t *phy_if = NULL;
 	uint32_t session_id = 0U;
 	pfe_if_db_entry_t *entry = NULL;
+	errno_t ret = EOK;
 
 	struct
 	{
@@ -2730,7 +2907,7 @@ errno_t pfe_platform_create_ifaces(pfe_platform_t *platform)
 		if (NULL == platform->phy_if_db)
 		{
 			NXP_LOG_DEBUG("Can't create physical interface DB\n");
-			return ENODEV;
+			ret = ENODEV;
 		}
 		else
 		{
@@ -2756,7 +2933,8 @@ errno_t pfe_platform_create_ifaces(pfe_platform_t *platform)
 				if (NULL == phy_if)
 				{
 					NXP_LOG_ERROR("Couldn't create %s\n", phy_ifs[ii].name);
-					return ENODEV;
+					ret = ENODEV;
+					break;
 				}
 				else
 				{
@@ -2766,7 +2944,8 @@ errno_t pfe_platform_create_ifaces(pfe_platform_t *platform)
 						NXP_LOG_ERROR("Could not set default operational mode (%s)\n", phy_ifs[ii].name);
 						pfe_phy_if_destroy(phy_if);
 						phy_if = NULL;
-						return ENODEV;
+						ret = ENODEV;
+						break;
 					}
 
 					if ((pfe_phy_if_get_id(phy_if) == PFE_PHY_IF_ID_EMAC0)
@@ -2779,7 +2958,8 @@ errno_t pfe_platform_create_ifaces(pfe_platform_t *platform)
 							NXP_LOG_ERROR("Can't bind interface with EMAC (%s)\n", phy_ifs[ii].name);
 							pfe_phy_if_destroy(phy_if);
 							phy_if = NULL;
-							return ENODEV;
+							ret = ENODEV;
+							break;
 						}
 
 						/* provide gpi handle to emac: emac phy_ifs need access to gpi to configure Ingress QoS */
@@ -2788,7 +2968,8 @@ errno_t pfe_platform_create_ifaces(pfe_platform_t *platform)
 							NXP_LOG_ERROR("Can't bind interface with GPI (%s)\n", phy_ifs[ii].name);
 							pfe_phy_if_destroy(phy_if);
 							phy_if = NULL;
-							return ENODEV;
+							ret = ENODEV;
+							break;
 						}
 
 						/*	Do not set MAC address here. Will be configured via logical interfaces later. */
@@ -2802,7 +2983,8 @@ errno_t pfe_platform_create_ifaces(pfe_platform_t *platform)
 							NXP_LOG_ERROR("Can't initialize UTIL PHY (%s)\n", phy_ifs[ii].name);
 							pfe_phy_if_destroy(phy_if);
 							phy_if = NULL;
-							return ENODEV;
+							ret = ENODEV;
+							break;
 						}
 					}
 					else
@@ -2815,7 +2997,8 @@ errno_t pfe_platform_create_ifaces(pfe_platform_t *platform)
 								NXP_LOG_ERROR("Can't bind interface with HIF (%s)\n", phy_ifs[ii].name);
 								pfe_phy_if_destroy(phy_if);
 								phy_if = NULL;
-								return ENODEV;
+								ret = ENODEV;
+								break;
 							}
 						}
 						else
@@ -2830,7 +3013,8 @@ errno_t pfe_platform_create_ifaces(pfe_platform_t *platform)
 						NXP_LOG_ERROR("Could not register %s\n", pfe_phy_if_get_name(phy_if));
 						pfe_phy_if_destroy(phy_if);
 						phy_if = NULL;
-						return ENODEV;
+						ret = ENODEV;
+						break;
 					}
 				}
 			}
@@ -2842,17 +3026,20 @@ errno_t pfe_platform_create_ifaces(pfe_platform_t *platform)
 		}
 	}
 
-	if (NULL == platform->log_if_db)
+	if(EOK == ret)
 	{
-		pfe.log_if_db = pfe_if_db_create(PFE_IF_DB_LOG);
-		if (NULL == pfe.log_if_db)
+		if (NULL == platform->log_if_db)
 		{
-			NXP_LOG_DEBUG("Can't create logical interface DB\n");
-			return ENODEV;
+			pfe.log_if_db = pfe_if_db_create(PFE_IF_DB_LOG);
+			if (NULL == pfe.log_if_db)
+			{
+				NXP_LOG_DEBUG("Can't create logical interface DB\n");
+				ret = ENODEV;
+			}
 		}
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -2959,6 +3146,7 @@ errno_t pfe_platform_soft_reset(const pfe_platform_t *platform)
 	uint32_t regval;
 	bool_t run_on_g3 = FALSE;
 	uint32_t timeout = 1000U;
+	errno_t ret = EOK;
 
 	(void)platform;
 
@@ -2996,15 +3184,17 @@ errno_t pfe_platform_soft_reset(const pfe_platform_t *platform)
 		if (0U == timeout)
 		{
 			NXP_LOG_INFO("Soft reset done indication timeouted\n");
-			return ETIMEDOUT;
+			ret = ETIMEDOUT;
+		}
+		else
+		{
+			regval = hal_read32(addr_gen);
+			regval &= ~WSP_SYS_GEN_SOFT_RST_BIT;
+			regval |= WSP_SYS_GEN_SOFT_RST_DONE_CLR_MASK_G3;
+			hal_write32(regval, addr_gen);
+			regval &= ~WSP_SYS_GEN_SOFT_RST_DONE_CLR_MASK_G3;
+			hal_write32(regval, addr_gen);
 		}
-
-		regval = hal_read32(addr_gen);
-		regval &= ~WSP_SYS_GEN_SOFT_RST_BIT;
-		regval |= WSP_SYS_GEN_SOFT_RST_DONE_CLR_MASK_G3;
-		hal_write32(regval, addr_gen);
-		regval &= ~WSP_SYS_GEN_SOFT_RST_DONE_CLR_MASK_G3;
-		hal_write32(regval, addr_gen);
 	}
 	else
 	{
@@ -3013,7 +3203,7 @@ errno_t pfe_platform_soft_reset(const pfe_platform_t *platform)
 		hal_write32(regval, addr_gen);
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -3046,6 +3236,10 @@ errno_t pfe_platform_init(const pfe_platform_config_t *config)
 		NXP_LOG_INFO("PFE CBUS p0x%"PRINTADDR_T" mapped @ v0x%"PRINTADDR_T"\n", config->cbus_base, pfe.cbus_baseaddr);
 	}
 
+	/* Get PFE Version */
+	pfe.pfe_version = *(uint32_t*)(void*)((addr_t)pfe.cbus_baseaddr + CBUS_GLOBAL_CSR_BASE_ADDR + WSP_VERSION);
+	NXP_LOG_INFO("HW version 0x%x\n", (uint_t)pfe.pfe_version);
+
 	/* Initialize the features */
 	ret = pfe_feature_mgr_init((void *)pfe.cbus_baseaddr);
 	if (EOK != ret)
@@ -3363,7 +3557,7 @@ static void pfe_platform_destroy_group2(void)
  */
 errno_t pfe_platform_remove(void)
 {
-	errno_t ret;
+	errno_t ret = EOK;
 	/*	Remove and disable IRQ just before platform modules are destroyed. */
 	if (NULL != pfe.irq_global)
 	{
@@ -3396,14 +3590,15 @@ errno_t pfe_platform_remove(void)
 		if (EOK != ret)
 		{
 			NXP_LOG_ERROR("Can't unmap PPFE CBUS: %d\n", ret);
-			return ret;
 		}
 	}
+	if (EOK == ret)
+	{
+		pfe.cbus_baseaddr = (addr_t)0x0ULL;
+		pfe.probed = FALSE;
+	}
 
-	pfe.cbus_baseaddr = (addr_t)0x0ULL;
-	pfe.probed = FALSE;
-
-	return EOK;
+	return ret;
 }
 
 /**
@@ -3411,14 +3606,13 @@ errno_t pfe_platform_remove(void)
  */
 pfe_platform_t * pfe_platform_get_instance(void)
 {
+	pfe_platform_t *pfe_platform= NULL;
 	if (TRUE == pfe.probed)
 	{
-		return &pfe;
-	}
-	else
-	{
-		return NULL;
+		pfe_platform= &pfe;
 	}
+
+	return pfe_platform;
 }
 
 /**
diff --git a/sw/pfe_platform/hw/s32g/pfe_platform_slave.c b/sw/pfe_platform/hw/s32g/pfe_platform_slave.c
index 3ffb91a..c94585a 100644
--- a/sw/pfe_platform/hw/s32g/pfe_platform_slave.c
+++ b/sw/pfe_platform/hw/s32g/pfe_platform_slave.c
@@ -166,7 +166,20 @@ static void pfe_platform_destroy_hif(pfe_platform_t *platform)
  */
 static errno_t pfe_platform_create_hif_nocpy(pfe_platform_t *platform)
 {
-	platform->hif_nocpy = pfe_hif_nocpy_create(pfe.cbus_baseaddr + CBUS_HIF_NOCPY_BASE_ADDR, platform->bmu[1]);
+    uint16_t lmem_header_size;
+
+#if 0 /* AAVB-5037 */
+	if(PFE_S32G3_VERSION == platform->pfe_version)
+	{   /* S32G3 */
+		lmem_header_size = 48U;
+	}
+	else
+#endif
+	{   /* S32G2 */
+		lmem_header_size = 112U;
+	}
+    
+	platform->hif_nocpy = pfe_hif_nocpy_create(pfe.cbus_baseaddr + CBUS_HIF_NOCPY_BASE_ADDR, platform->bmu[1], lmem_header_size);
 
 	if (NULL == platform->hif_nocpy)
 	{
@@ -484,6 +497,9 @@ errno_t pfe_platform_init(const pfe_platform_config_t *config)
 	{
 		NXP_LOG_INFO("PFE CBUS p0x%p mapped @ v0x%"PRINTADDR_T"\n", (void *)config->cbus_base, pfe.cbus_baseaddr);
 	}
+	
+    pfe.pfe_version = *(uint32_t*)(void*)((addr_t)pfe.cbus_baseaddr + CBUS_GLOBAL_CSR_BASE_ADDR + WSP_VERSION);
+	NXP_LOG_INFO("HW version 0x%x\n", (uint_t)pfe.pfe_version);    
 
 	ret = pfe_platform_create_hif(&pfe, config);
 	if (EOK != ret)
diff --git a/sw/pfe_platform/hw/s32g/pfe_tmu_csr.c b/sw/pfe_platform/hw/s32g/pfe_tmu_csr.c
index cdfe158..65f9c37 100644
--- a/sw/pfe_platform/hw/s32g/pfe_tmu_csr.c
+++ b/sw/pfe_platform/hw/s32g/pfe_tmu_csr.c
@@ -42,6 +42,7 @@ static const pfe_ct_phy_if_id_t phy_if_id_temp[TLITE_PHYS_CNT] =
 const pfe_tmu_phy_cfg_t *pfe_tmu_cfg_get_phy_config(pfe_ct_phy_if_id_t phy)
 {
 	uint32_t ii;
+	const pfe_tmu_phy_cfg_t *phy_config = NULL;
 	/*	List of QoS configuration for each physical interface terminated with invalid entry */
 	static const pfe_tmu_phy_cfg_t phys[] = {
 		{.id = PFE_PHY_IF_ID_EMAC0, .q_cnt = 8U, .sch_cnt = 2U, .shp_cnt = 4U},
@@ -61,11 +62,12 @@ const pfe_tmu_phy_cfg_t *pfe_tmu_cfg_get_phy_config(pfe_ct_phy_if_id_t phy)
 	{
 		if (phys[ii].id == phy)
 		{
-			return &phys[ii];
+			phy_config = &phys[ii];
+			break;
 		}
 	}
 
-	return NULL;
+	return phy_config;
 }
 
 /**
@@ -109,35 +111,34 @@ void pfe_tmu_reclaim_init(addr_t cbus_base_va)
 	{
 		/* Queue 0 PHY 0*/
 		/* WRED min 0 max 0*/
-		if (EOK != pfe_tmu_context_memory(cbus_base_va, PFE_PHY_IF_ID_EMAC0, 0U, 0U, 0U))
+		if(EOK == pfe_tmu_context_memory(cbus_base_va, PFE_PHY_IF_ID_EMAC0, 0U, 0U, 0U))
 		{
-			return;
-		}
 
-		/* Initialize internal TMU FIFO (length is hard coded in verilog)*/
-		for(ii = 0U; ii < (uint32_t)TLITE_INQ_FIFODEPTH; ii++)
-		{
-			hal_write32(0UL, cbus_base_va + TMU_PHY_INQ_PKTINFO);
-		}
+			/* Initialize internal TMU FIFO (length is hard coded in verilog)*/
+			for(ii = 0U; ii < (uint32_t)TLITE_INQ_FIFODEPTH; ii++)
+			{
+				hal_write32(0UL, cbus_base_va + TMU_PHY_INQ_PKTINFO);
+			}
 
-		do
-		{
-			oal_time_usleep(10U);
-			/*	Queue 0 */
-			/*	curQ_drop_cnt is @ position 2 per queue */
-			(void)pfe_tmu_cntx_mem_read(cbus_base_va, PFE_PHY_IF_ID_EMAC0, (8U * 0U) + 2U, &dropped_packets);
+			do
+			{
+				oal_time_usleep(10U);
+				/*	Queue 0 */
+				/*	curQ_drop_cnt is @ position 2 per queue */
+				(void)pfe_tmu_cntx_mem_read(cbus_base_va, PFE_PHY_IF_ID_EMAC0, (8U * 0U) + 2U, &dropped_packets);
 
-			retries++;
-		}
-		while ((TLITE_INQ_FIFODEPTH != dropped_packets) && (10U > retries));
+				retries++;
+			}
+			while ((TLITE_INQ_FIFODEPTH != dropped_packets) && (10U > retries));
 
-		if (dropped_packets != TLITE_INQ_FIFODEPTH)
-		{
-			NXP_LOG_ERROR("Failed to initialize TMU reclaim memory %u\n", (uint_t)dropped_packets);
-		}
+			if (dropped_packets != TLITE_INQ_FIFODEPTH)
+			{
+				NXP_LOG_ERROR("Failed to initialize TMU reclaim memory %u\n", (uint_t)dropped_packets);
+			}
 
-		/* Set queue to default mode */
-		(void)pfe_tmu_q_mode_set_default(cbus_base_va, PFE_PHY_IF_ID_EMAC0, 0U);
+			/* Set queue to default mode */
+			(void)pfe_tmu_q_mode_set_default(cbus_base_va, PFE_PHY_IF_ID_EMAC0, 0U);
+		}
 	}
 }
 
@@ -156,16 +157,19 @@ errno_t pfe_tmu_q_reset_tail_drop_policy(addr_t cbus_base_va)
 			if (EOK != ret)
 			{
 				NXP_LOG_ERROR("Can't set the default queue size for PHY#%u queue 0: %d\n", (uint_t)ii, (int_t)ret);
-				return ret;
+				break;
 			}
-
-			for (queue = 1U; queue < (uint8_t)TLITE_PHY_QUEUES_CNT; queue++)
+			else
 			{
-				ret = pfe_tmu_q_mode_set_tail_drop(cbus_base_va, phy_if_id_temp[ii], queue, (uint16_t)TLITE_OPT_Q1_7_SIZE);
-				if (EOK != ret)
+
+				for (queue = 1U; queue < (uint8_t)TLITE_PHY_QUEUES_CNT; queue++)
 				{
-					NXP_LOG_ERROR("Can't set the default queue size for PHY#%u queue %hhu: %d\n", (uint_t)ii, queue, (int_t)ret);
-					return ret;
+					ret = pfe_tmu_q_mode_set_tail_drop(cbus_base_va, phy_if_id_temp[ii], queue, (uint16_t)TLITE_OPT_Q1_7_SIZE);
+					if (EOK != ret)
+					{
+						NXP_LOG_ERROR("Can't set the default queue size for PHY#%u queue %hhu: %d\n", (uint_t)ii, queue, (int_t)ret);
+						break;
+					}
 				}
 			}
 		}
@@ -177,7 +181,7 @@ errno_t pfe_tmu_q_reset_tail_drop_policy(addr_t cbus_base_va)
 				if (EOK != ret)
 				{
 					NXP_LOG_ERROR("Can't set the default queue size for PHY#%u queue %hhu: %d\n", (uint_t)ii, queue, (int_t)ret);
-					return ret;
+					break;
 				}
 			}
 		}
@@ -189,13 +193,17 @@ errno_t pfe_tmu_q_reset_tail_drop_policy(addr_t cbus_base_va)
 				if (EOK != ret)
 				{
 					NXP_LOG_ERROR("Can't set the default queue size for PHY#%u queue %hhu: %d\n", (uint_t)ii, queue, (int_t)ret);
-					return ret;
+					break;
 				}
 			}
 		}
+		if (EOK != ret)
+		{
+			break;
+		}
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -208,7 +216,7 @@ errno_t pfe_tmu_cfg_init(addr_t cbus_base_va, const pfe_tmu_cfg_t *cfg)
 {
 	uint8_t queue;
 	uint32_t ii;
-	errno_t ret;
+	errno_t ret = EOK;
 
 	(void)cfg;
 
@@ -263,59 +271,75 @@ errno_t pfe_tmu_cfg_init(addr_t cbus_base_va, const pfe_tmu_cfg_t *cfg)
 			if (EOK != ret)
 			{
 				NXP_LOG_DEBUG("Can't bind queue to scheduler: %d\n", ret);
-				return ENOEXEC;
+				ret = ENOEXEC;
+				break;
 			}
 		}
 
-		ret = pfe_tmu_sch_cfg_set_rate_mode(cbus_base_va, phy_if_id_temp[ii], 1U, RATE_MODE_DATA_RATE);
-		if (EOK != ret)
-		{
-			NXP_LOG_DEBUG("Could not set scheduler 1 rate mode: %d\n", ret);
-			return ENOEXEC;
-		}
-
-		ret = pfe_tmu_sch_cfg_set_algo(cbus_base_va, phy_if_id_temp[ii], 1U, SCHED_ALGO_RR);
-		if (EOK != ret)
+		if (EOK == ret)
 		{
-			NXP_LOG_DEBUG("Could not set scheduler 1 algo: %d\n", ret);
-			return ENOEXEC;
-		}
-
-		/*	Set default queue mode */
-		for (queue = 0U; queue < (uint8_t)TLITE_PHY_QUEUES_CNT; queue++)
-		{
-			if((uint32_t)PFE_PHY_IF_ID_HIF == ii)
-			{   /* HIF - special case for ERR051211 workaround */
-				ret = pfe_tmu_q_mode_set_tail_drop(cbus_base_va, phy_if_id_temp[ii], queue, TLITE_HIF_MAX_Q_SIZE);
+			ret = pfe_tmu_sch_cfg_set_rate_mode(cbus_base_va, phy_if_id_temp[ii], 1U, RATE_MODE_DATA_RATE);
+			if (EOK != ret)
+			{
+				NXP_LOG_DEBUG("Could not set scheduler 1 rate mode: %d\n", ret);
+				ret = ENOEXEC;
 			}
 			else
-			{   /* Other */
-				ret = pfe_tmu_q_mode_set_tail_drop(cbus_base_va, phy_if_id_temp[ii], queue, TLITE_MAX_Q_SIZE);
-			}
-
-			if (EOK != ret)
 			{
-				NXP_LOG_DEBUG("Can't set default queue mode: %d\n", ret);
-				return ret;
+				ret = pfe_tmu_sch_cfg_set_algo(cbus_base_va, phy_if_id_temp[ii], 1U, SCHED_ALGO_RR);
+				if (EOK != ret)
+				{
+					NXP_LOG_DEBUG("Could not set scheduler 1 algo: %d\n", ret);
+					ret = ENOEXEC;
+				}
+				else
+				{
+					/*	Set default queue mode */
+					for (queue = 0U; queue < (uint8_t)TLITE_PHY_QUEUES_CNT; queue++)
+					{
+						if((uint32_t)PFE_PHY_IF_ID_HIF == ii)
+						{   /* HIF - special case for ERR051211 workaround */
+							ret = pfe_tmu_q_mode_set_tail_drop(cbus_base_va, phy_if_id_temp[ii], queue, TLITE_HIF_MAX_Q_SIZE);
+						}
+						else
+						{   /* Other */
+							ret = pfe_tmu_q_mode_set_tail_drop(cbus_base_va, phy_if_id_temp[ii], queue, TLITE_MAX_Q_SIZE);
+						}
+
+						if (EOK != ret)
+						{
+							NXP_LOG_DEBUG("Can't set default queue mode: %d\n", ret);
+							break;
+						}
+					}
+				}
 			}
 		}
+		/* Incase one of the ret != EOK break */
+		if (EOK != ret)
+		{
+			break;
+		}
 	}
 
-	hal_write32(PFE_CFG_CBUS_PHYS_BASE_ADDR + CBUS_BMU1_BASE_ADDR + BMU_FREE_CTRL, cbus_base_va + TMU_BMU_INQ_ADDR);
-	hal_write32(PFE_CFG_CBUS_PHYS_BASE_ADDR + CBUS_BMU2_BASE_ADDR + BMU_FREE_CTRL, cbus_base_va + TMU_BMU2_INQ_ADDR);
-	hal_write32(0x100U, cbus_base_va + TMU_AFULL_THRES);
-	hal_write32(0xfcU, cbus_base_va + TMU_INQ_WATERMARK);
-	hal_write32(0xfU, cbus_base_va + TMU_PHY0_TDQ_CTRL);
-	hal_write32(0xfU, cbus_base_va + TMU_PHY1_TDQ_CTRL);
-	hal_write32(0xfU, cbus_base_va + TMU_PHY2_TDQ_CTRL);
-	hal_write32(0xfU, cbus_base_va + TMU_PHY16_TDQ_CTRL);
-	hal_write32(0xfU, cbus_base_va + TMU_PHY3_TDQ_CTRL);
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	hal_write32(0xfU, cbus_base_va + TMU_PHY4_TDQ_CTRL);
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	hal_write32(0xfU, cbus_base_va + TMU_PHY5_TDQ_CTRL);	/* UTIL */
+	if (EOK == ret)
+	{
+		hal_write32(PFE_CFG_CBUS_PHYS_BASE_ADDR + CBUS_BMU1_BASE_ADDR + BMU_FREE_CTRL, cbus_base_va + TMU_BMU_INQ_ADDR);
+		hal_write32(PFE_CFG_CBUS_PHYS_BASE_ADDR + CBUS_BMU2_BASE_ADDR + BMU_FREE_CTRL, cbus_base_va + TMU_BMU2_INQ_ADDR);
+		hal_write32(0x100U, cbus_base_va + TMU_AFULL_THRES);
+		hal_write32(0xfcU, cbus_base_va + TMU_INQ_WATERMARK);
+		hal_write32(0xfU, cbus_base_va + TMU_PHY0_TDQ_CTRL);
+		hal_write32(0xfU, cbus_base_va + TMU_PHY1_TDQ_CTRL);
+		hal_write32(0xfU, cbus_base_va + TMU_PHY2_TDQ_CTRL);
+		hal_write32(0xfU, cbus_base_va + TMU_PHY16_TDQ_CTRL);
+		hal_write32(0xfU, cbus_base_va + TMU_PHY3_TDQ_CTRL);
+	#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
+		hal_write32(0xfU, cbus_base_va + TMU_PHY4_TDQ_CTRL);
+	#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
+		hal_write32(0xfU, cbus_base_va + TMU_PHY5_TDQ_CTRL);	/* UTIL */
+	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -494,6 +518,7 @@ static uint8_t pfe_tmu_hif_q_to_tmu_q(addr_t cbus_base_va, pfe_ct_phy_if_id_t ph
 {
 	uint32_t reg, ii;
 	int8_t hif_queue = -1;
+	uint8_t tmu_queue = PFE_TMU_INVALID_QUEUE;
 
 	/*	Convert HIF channel `queue` (range 0-`n`) to TMU queue (range 0-`m`) */
 	if ((phy == PFE_PHY_IF_ID_HIF0)
@@ -509,13 +534,14 @@ static uint8_t pfe_tmu_hif_q_to_tmu_q(addr_t cbus_base_va, pfe_ct_phy_if_id_t ph
 				hif_queue++;
 				if (queue == (uint8_t)hif_queue)
 				{
-					return (uint8_t)ii;
+					tmu_queue = (uint8_t)ii;
+					break;
 				}
 			}
 		}
 	}
 
-	return PFE_TMU_INVALID_QUEUE;
+	return tmu_queue;
 }
 
 static errno_t pfe_tmu_context_memory(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy, uint8_t queue_temp, uint16_t min, uint16_t max)
@@ -537,20 +563,16 @@ static errno_t pfe_tmu_context_memory(addr_t cbus_base_va, pfe_ct_phy_if_id_t ph
 
 	reg = 0U;
 	ret = pfe_tmu_cntx_mem_write(cbus_base_va, phy, (8U * queue_temp) + 5U, reg);
-	if (EOK != ret)
-	{
-		return ret;
-	}
-
-	ret = pfe_tmu_cntx_mem_write(cbus_base_va, phy, (8U * queue_temp) + 6U, reg);
-	if (EOK != ret)
+	if (EOK == ret)
 	{
-		return ret;
+		ret = pfe_tmu_cntx_mem_write(cbus_base_va, phy, (8U * queue_temp) + 6U, reg);
+		if (EOK == ret)
+		{
+			/*	curQ_Qmax[8:0], curQ_Qmin[8:0], curQ_cfg[1:0] are @ position 4 per queue */
+			reg = ((uint32_t)max << 11U) | ((uint32_t)min << 2U) | 0x2UL;
+			ret = pfe_tmu_cntx_mem_write(cbus_base_va, phy, (8U * queue_temp) + 4U, reg);
+		}
 	}
-
-	/*	curQ_Qmax[8:0], curQ_Qmin[8:0], curQ_cfg[1:0] are @ position 4 per queue */
-	reg = ((uint32_t)max << 11U) | ((uint32_t)min << 2U) | 0x2UL;
-	ret = pfe_tmu_cntx_mem_write(cbus_base_va, phy, (8U * queue_temp) + 4U, reg);
 	return ret;
 }
 
@@ -565,6 +587,7 @@ static errno_t pfe_tmu_context_memory(addr_t cbus_base_va, pfe_ct_phy_if_id_t ph
 errno_t pfe_tmu_q_cfg_get_fill_level(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy, uint8_t queue, uint32_t *level)
 {
 	uint8_t queue_temp = queue;
+	errno_t ret = EOK;
 
 	if ((phy == PFE_PHY_IF_ID_HIF0)
 				|| (phy == PFE_PHY_IF_ID_HIF1)
@@ -574,12 +597,16 @@ errno_t pfe_tmu_q_cfg_get_fill_level(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy
 		queue_temp = pfe_tmu_hif_q_to_tmu_q(cbus_base_va, phy, queue);
 		if (PFE_TMU_INVALID_QUEUE == queue_temp)
 		{
-			return EINVAL;
+			ret = EINVAL;
 		}
 	}
 
-	/*	curQ_pkt_cnt is @ position 1 per queue */
-	return pfe_tmu_cntx_mem_read(cbus_base_va, phy, (8U * queue_temp) + 1U, level);
+	if (EOK == ret)
+	{
+		/*	curQ_pkt_cnt is @ position 1 per queue */
+		ret = pfe_tmu_cntx_mem_read(cbus_base_va, phy, (8U * queue_temp) + 1U, level);
+	}
+	return ret;
 }
 
 /**
@@ -593,7 +620,7 @@ errno_t pfe_tmu_q_cfg_get_fill_level(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy
 errno_t pfe_tmu_q_cfg_get_drop_count(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy, uint8_t queue, uint32_t *cnt)
 {
 	uint32_t drops;
-	errno_t ret;
+	errno_t ret = EOK;
 	uint8_t temp = queue;
 	if ((phy == PFE_PHY_IF_ID_HIF0)
 				|| (phy == PFE_PHY_IF_ID_HIF1)
@@ -603,28 +630,30 @@ errno_t pfe_tmu_q_cfg_get_drop_count(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy
 		temp = pfe_tmu_hif_q_to_tmu_q(cbus_base_va, phy, queue);
 		if (PFE_TMU_INVALID_QUEUE == temp)
 		{
-			return EINVAL;
+			ret = EINVAL;
 		}
 	}
 
-	/*	curQ_drop_cnt is @ position 2 per queue */
-	ret = pfe_tmu_cntx_mem_read(cbus_base_va, phy, (8U * temp) + 2U, &drops);
-
-	/* S32G2: Mitigate side effect of TMU reclaim memory workaround */
 	if (EOK == ret)
 	{
-		if ((phy == PFE_PHY_IF_ID_EMAC0) &&
-			(0U == queue) &&
-			(FALSE == pfe_feature_mgr_is_available(PFE_HW_FEATURE_RUN_ON_G3)))
-		{
-			*cnt = drops - TLITE_INQ_FIFODEPTH;
-		}
-		else
+		/*	curQ_drop_cnt is @ position 2 per queue */
+		ret = pfe_tmu_cntx_mem_read(cbus_base_va, phy, (8U * temp) + 2U, &drops);
+
+		/* S32G2: Mitigate side effect of TMU reclaim memory workaround */
+		if (EOK == ret)
 		{
-			*cnt = drops;
+			if ((phy == PFE_PHY_IF_ID_EMAC0) &&
+				(0U == queue) &&
+				(FALSE == pfe_feature_mgr_is_available(PFE_HW_FEATURE_RUN_ON_G3)))
+			{
+				*cnt = drops - TLITE_INQ_FIFODEPTH;
+			}
+			else
+			{
+				*cnt = drops;
+			}
 		}
 	}
-
 	return ret;
 }
 
@@ -639,6 +668,7 @@ errno_t pfe_tmu_q_cfg_get_drop_count(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy
 errno_t pfe_tmu_q_cfg_get_tx_count(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy, uint8_t queue, uint32_t *cnt)
 {
 	uint8_t temp = queue;
+	errno_t ret = EOK;
 
 	if ((phy == PFE_PHY_IF_ID_HIF0)
 				|| (phy == PFE_PHY_IF_ID_HIF1)
@@ -648,12 +678,17 @@ errno_t pfe_tmu_q_cfg_get_tx_count(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy,
 		temp = pfe_tmu_hif_q_to_tmu_q(cbus_base_va, phy, queue);
 		if (PFE_TMU_INVALID_QUEUE == temp)
 		{
-			return EINVAL;
+			ret = EINVAL;
 		}
 	}
 
-	/*	curQ_trans_cnt is @ position 3 per queue */
-	return pfe_tmu_cntx_mem_read(cbus_base_va, phy, (8U * temp) + 3U, cnt);
+	if (EOK == ret)
+	{
+		/*	curQ_trans_cnt is @ position 3 per queue */
+		ret = pfe_tmu_cntx_mem_read(cbus_base_va, phy, (8U * temp) + 3U, cnt);
+	}
+
+	return ret;
 }
 
 /**
@@ -669,7 +704,7 @@ pfe_tmu_queue_mode_t pfe_tmu_q_get_mode(addr_t cbus_base_va, pfe_ct_phy_if_id_t
 {
 	uint32_t reg;
 	errno_t ret;
-	pfe_tmu_queue_mode_t mode;
+	pfe_tmu_queue_mode_t mode = TMU_Q_MODE_DEFAULT;
 	uint8_t temp = queue;
 
 	if ((phy == PFE_PHY_IF_ID_HIF0)
@@ -680,41 +715,45 @@ pfe_tmu_queue_mode_t pfe_tmu_q_get_mode(addr_t cbus_base_va, pfe_ct_phy_if_id_t
 		temp = pfe_tmu_hif_q_to_tmu_q(cbus_base_va, phy, queue);
 		if (PFE_TMU_INVALID_QUEUE == temp)
 		{
-			return TMU_Q_MODE_INVALID;
+			mode = TMU_Q_MODE_INVALID;
 		}
 	}
-
-	/*	curQ_Qmax[8:0], curQ_Qmin[8:0], curQ_cfg[1:0] are @ position 4 per queue */
-	ret = pfe_tmu_cntx_mem_read(cbus_base_va, phy, (8U * temp) + 4U, &reg);
-	if (EOK != ret)
-	{
-		return TMU_Q_MODE_INVALID;
-	}
-
-	switch (reg & 0x3U)
+	if (TMU_Q_MODE_DEFAULT == mode)
 	{
-		case 1U:
+		/*	curQ_Qmax[8:0], curQ_Qmin[8:0], curQ_cfg[1:0] are @ position 4 per queue */
+		ret = pfe_tmu_cntx_mem_read(cbus_base_va, phy, (8U * temp) + 4U, &reg);
+		if (EOK != ret)
 		{
-			mode = TMU_Q_MODE_TAIL_DROP;
-			*max = (reg >> 11) & 0x1ffU;
-			*min = 0U;
-			break;
+			mode = TMU_Q_MODE_INVALID;
 		}
-
-		case 2U:
+		else
 		{
-			mode = TMU_Q_MODE_WRED;
-			*max = (reg >> 11) & 0x1ffU;
-			*min = (reg >> 2) & 0x1ffU;
-			break;
-		}
+			switch (reg & 0x3U)
+			{
+				case 1U:
+				{
+					mode = TMU_Q_MODE_TAIL_DROP;
+					*max = (reg >> 11) & 0x1ffU;
+					*min = 0U;
+					break;
+				}
 
-		default:
-		{
-			mode = TMU_Q_MODE_DEFAULT;
-			*max = 0U;
-			*min = 0U;
-			break;
+				case 2U:
+				{
+					mode = TMU_Q_MODE_WRED;
+					*max = (reg >> 11) & 0x1ffU;
+					*min = (reg >> 2) & 0x1ffU;
+					break;
+				}
+
+				default:
+				{
+					mode = TMU_Q_MODE_DEFAULT;
+					*max = 0U;
+					*min = 0U;
+					break;
+				}
+			}
 		}
 	}
 
@@ -731,6 +770,7 @@ pfe_tmu_queue_mode_t pfe_tmu_q_get_mode(addr_t cbus_base_va, pfe_ct_phy_if_id_t
 errno_t pfe_tmu_q_mode_set_default(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy, uint8_t queue)
 {
 	uint8_t temp = queue;
+	errno_t ret = EOK;
 
 	if ((phy == PFE_PHY_IF_ID_HIF0)
 				|| (phy == PFE_PHY_IF_ID_HIF1)
@@ -740,16 +780,22 @@ errno_t pfe_tmu_q_mode_set_default(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy,
 		temp = pfe_tmu_hif_q_to_tmu_q(cbus_base_va, phy, queue);
 		if (PFE_TMU_INVALID_QUEUE == temp)
 		{
-			return EINVAL;
+			ret = EINVAL;
 		}
 	}
 
-	/*	If bit 1 is zero then in case when LLM is full the TMU will wait. */
-	hal_write32((uint32_t)0x0U | ((uint32_t)0x0U << 1), cbus_base_va + TMU_TEQ_CTRL);
+	if (EOK == ret)
+	{
+
+		/*	If bit 1 is zero then in case when LLM is full the TMU will wait. */
+		hal_write32((uint32_t)0x0U | ((uint32_t)0x0U << 1), cbus_base_va + TMU_TEQ_CTRL);
 
-	/*	Put the queue to default mode */
-	/*	curQ_Qmax[8:0], curQ_Qmin[8:0], curQ_cfg[1:0] are @ position 4 per queue */
-	return pfe_tmu_cntx_mem_write(cbus_base_va, phy, (8U * temp) + 4U, 0U);
+		/*	Put the queue to default mode */
+		/*	curQ_Qmax[8:0], curQ_Qmin[8:0], curQ_cfg[1:0] are @ position 4 per queue */
+		ret = pfe_tmu_cntx_mem_write(cbus_base_va, phy, (8U * temp) + 4U, 0U);
+	}
+
+	return ret;
 }
 
 /**
@@ -765,27 +811,36 @@ errno_t pfe_tmu_q_mode_set_tail_drop(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy
 {
 	uint32_t reg;
 	uint8_t queue_temp = queue;
+	errno_t ret = EOK;
 
 	if (TLITE_MAX_ENTRIES < max)
 	{
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	if ((phy == PFE_PHY_IF_ID_HIF0)
-				|| (phy == PFE_PHY_IF_ID_HIF1)
-				|| (phy == PFE_PHY_IF_ID_HIF2)
-				|| (phy == PFE_PHY_IF_ID_HIF3))
+	else
 	{
-		queue_temp = pfe_tmu_hif_q_to_tmu_q(cbus_base_va, phy, queue);
-		if (PFE_TMU_INVALID_QUEUE == queue_temp)
+
+		if ((phy == PFE_PHY_IF_ID_HIF0)
+					|| (phy == PFE_PHY_IF_ID_HIF1)
+					|| (phy == PFE_PHY_IF_ID_HIF2)
+					|| (phy == PFE_PHY_IF_ID_HIF3))
+		{
+			queue_temp = pfe_tmu_hif_q_to_tmu_q(cbus_base_va, phy, queue);
+			if (PFE_TMU_INVALID_QUEUE == queue_temp)
+			{
+				ret = EINVAL;
+			}
+		}
+		
+		if (EOK == ret)
 		{
-			return EINVAL;
+			/*	curQ_Qmax[8:0], curQ_Qmin[8:0], curQ_cfg[1:0] are @ position 4 per queue */
+			reg = ((uint32_t)max << (uint32_t)11U) | ((uint32_t)0U << (uint32_t)2U) | ((uint32_t)0x1U << 0U);
+			ret = pfe_tmu_cntx_mem_write(cbus_base_va, phy, (8U * queue_temp) + 4U, reg);
 		}
 	}
 
-	/*	curQ_Qmax[8:0], curQ_Qmin[8:0], curQ_cfg[1:0] are @ position 4 per queue */
-	reg = ((uint32_t)max << (uint32_t)11U) | ((uint32_t)0U << (uint32_t)2U) | ((uint32_t)0x1U << 0U);
-	return pfe_tmu_cntx_mem_write(cbus_base_va, phy, (8U * queue_temp) + 4U, reg);
+	return ret;
 }
 
 /**
@@ -820,27 +875,33 @@ errno_t pfe_tmu_q_mode_set_tail_drop(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy
  */
 errno_t pfe_tmu_q_mode_set_wred(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy, uint8_t queue, uint16_t min, uint16_t max)
 {
-	errno_t ret;
+	errno_t ret = EOK;
 	uint8_t queue_temp = queue;
 
 	if ((max > 0x1ffU) || (min > 0x1ffU))
 	{
 		NXP_LOG_ERROR("Queue WRED 'min' and/or 'max' argument out of range\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	if ((phy == PFE_PHY_IF_ID_HIF0)
-				|| (phy == PFE_PHY_IF_ID_HIF1)
-				|| (phy == PFE_PHY_IF_ID_HIF2)
-				|| (phy == PFE_PHY_IF_ID_HIF3))
+	else
 	{
-		queue_temp = pfe_tmu_hif_q_to_tmu_q(cbus_base_va, phy, queue);
-		if (PFE_TMU_INVALID_QUEUE == queue_temp)
+		if ((phy == PFE_PHY_IF_ID_HIF0)
+					|| (phy == PFE_PHY_IF_ID_HIF1)
+					|| (phy == PFE_PHY_IF_ID_HIF2)
+					|| (phy == PFE_PHY_IF_ID_HIF3))
+		{
+			queue_temp = pfe_tmu_hif_q_to_tmu_q(cbus_base_va, phy, queue);
+			if (PFE_TMU_INVALID_QUEUE == queue_temp)
+			{
+				ret = EINVAL;
+			}
+		}
+
+		if (EOK == ret)
 		{
-			return EINVAL;
+			ret = pfe_tmu_context_memory(cbus_base_va, phy, queue_temp, min, max);
 		}
 	}
-	ret = pfe_tmu_context_memory(cbus_base_va, phy, queue_temp, min, max);
 	return ret;
 }
 
@@ -855,57 +916,56 @@ errno_t pfe_tmu_q_mode_set_wred(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy, uin
  */
 errno_t pfe_tmu_q_set_wred_probability(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy, uint8_t queue, uint8_t zone, uint8_t prob)
 {
-	errno_t ret;
+	errno_t ret = EOK;
 	uint32_t reg;
 	uint8_t pos;
 	uint8_t queue_temp = queue;
 
 	if ((prob > 100U) || (zone > 7U))
 	{
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	if ((phy == PFE_PHY_IF_ID_HIF0)
-				|| (phy == PFE_PHY_IF_ID_HIF1)
-				|| (phy == PFE_PHY_IF_ID_HIF2)
-				|| (phy == PFE_PHY_IF_ID_HIF3))
+	else
 	{
-		queue_temp = pfe_tmu_hif_q_to_tmu_q(cbus_base_va, phy, queue);
-		if (PFE_TMU_INVALID_QUEUE == queue_temp)
+		if ((phy == PFE_PHY_IF_ID_HIF0)
+					|| (phy == PFE_PHY_IF_ID_HIF1)
+					|| (phy == PFE_PHY_IF_ID_HIF2)
+					|| (phy == PFE_PHY_IF_ID_HIF3))
 		{
-			return EINVAL;
+			queue_temp = pfe_tmu_hif_q_to_tmu_q(cbus_base_va, phy, queue);
+			if (PFE_TMU_INVALID_QUEUE == queue_temp)
+			{
+				ret = EINVAL;
+			}
 		}
-	}
-
-	/*	Context memory position 5 (curQ_hw_prob_cfg_tbl0):
-			[4:0]	Zone0 value
-			[9:5]	Zone1 value
-			[14:10]	Zone2 value
-			[19:15]	Zone3 value
-			[24:20]	Zone4 value
-			[29:25]	Zone5 value
-		Context memory position 6 (curQ_hw_prob_cfg_tbl1):
-			[4:0]	Zone6 value
-			[9:5]	Zone7 value
-	*/
-	pos = 5U + (zone / 6U);
 
-	ret = pfe_tmu_cntx_mem_read(cbus_base_va, phy, (8U * queue_temp) + pos, &reg);
-	if (EOK != ret)
-	{
-		return ret;
-	}
+		/*	Context memory position 5 (curQ_hw_prob_cfg_tbl0):
+				[4:0]	Zone0 value
+				[9:5]	Zone1 value
+				[14:10]	Zone2 value
+				[19:15]	Zone3 value
+				[24:20]	Zone4 value
+				[29:25]	Zone5 value
+			Context memory position 6 (curQ_hw_prob_cfg_tbl1):
+				[4:0]	Zone6 value
+				[9:5]	Zone7 value
+		*/
+		if (EOK == ret)
+		{
+			pos = 5U + (zone / 6U);
 
-	reg &= ~(0x1fUL << (5U * (zone % 6U)));
-	reg |= (((0x1fU * (uint32_t)prob) / 100U) & 0x1fU) << (5U * (zone % 6U));
+			ret = pfe_tmu_cntx_mem_read(cbus_base_va, phy, (8U * queue_temp) + pos, &reg);
+			if (EOK == ret)
+			{
+				reg &= ~(0x1fUL << (5U * (zone % 6U)));
+				reg |= (((0x1fU * (uint32_t)prob) / 100U) & 0x1fU) << (5U * (zone % 6U));
 
-	ret = pfe_tmu_cntx_mem_write(cbus_base_va, phy, (8U * queue_temp) + pos, reg);
-	if (EOK != ret)
-	{
-		return ret;
+				ret = pfe_tmu_cntx_mem_write(cbus_base_va, phy, (8U * queue_temp) + pos, reg);
+			}
+		}
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -919,52 +979,54 @@ errno_t pfe_tmu_q_set_wred_probability(addr_t cbus_base_va, pfe_ct_phy_if_id_t p
  */
 errno_t pfe_tmu_q_get_wred_probability(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy, uint8_t queue, uint8_t zone, uint8_t *prob)
 {
-	errno_t ret;
+	errno_t ret = EOK;
 	uint32_t reg;
 	uint8_t pos;
 	uint8_t queue_temp = queue;
 
 	if (zone > 7U)
 	{
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	if ((phy == PFE_PHY_IF_ID_HIF0)
-				|| (phy == PFE_PHY_IF_ID_HIF1)
-				|| (phy == PFE_PHY_IF_ID_HIF2)
-				|| (phy == PFE_PHY_IF_ID_HIF3))
+	else
 	{
-		queue_temp = pfe_tmu_hif_q_to_tmu_q(cbus_base_va, phy, queue);
-		if (PFE_TMU_INVALID_QUEUE == queue_temp)
+		if ((phy == PFE_PHY_IF_ID_HIF0)
+					|| (phy == PFE_PHY_IF_ID_HIF1)
+					|| (phy == PFE_PHY_IF_ID_HIF2)
+					|| (phy == PFE_PHY_IF_ID_HIF3))
 		{
-			return EINVAL;
+			queue_temp = pfe_tmu_hif_q_to_tmu_q(cbus_base_va, phy, queue);
+			if (PFE_TMU_INVALID_QUEUE == queue_temp)
+			{
+				ret = EINVAL;
+			}
 		}
-	}
 
-	/*	Context memory position 5 (curQ_hw_prob_cfg_tbl0):
-			[4:0]	Zone0 value
-			[9:5]	Zone1 value
-			[14:10]	Zone2 value
-			[19:15]	Zone3 value
-			[24:20]	Zone4 value
-			[29:25]	Zone5 value
-		Context memory position 6 (curQ_hw_prob_cfg_tbl1):
-			[4:0]	Zone6 value
-			[9:5]	Zone7 value
-	*/
-
-	pos = 5U + (zone / 6U);
+		/*	Context memory position 5 (curQ_hw_prob_cfg_tbl0):
+				[4:0]	Zone0 value
+				[9:5]	Zone1 value
+				[14:10]	Zone2 value
+				[19:15]	Zone3 value
+				[24:20]	Zone4 value
+				[29:25]	Zone5 value
+			Context memory position 6 (curQ_hw_prob_cfg_tbl1):
+				[4:0]	Zone6 value
+				[9:5]	Zone7 value
+		*/
+		if (EOK == ret)
+		{
+			pos = 5U + (zone / 6U);
 
-	ret = pfe_tmu_cntx_mem_read(cbus_base_va, phy, (8U * queue_temp) + pos, &reg);
-	if (EOK != ret)
-	{
-		return ret;
+			ret = pfe_tmu_cntx_mem_read(cbus_base_va, phy, (8U * queue_temp) + pos, &reg);
+			if (EOK == ret)
+			{
+				reg = reg >> (5U * (zone % 6U));
+				*prob = (uint8_t)(((reg & 0x1fU) * 100U) / 0x1fU);
+			}
+		}
 	}
 
-	reg = reg >> (5U * (zone % 6U));
-	*prob = (uint8_t)(((reg & 0x1fU) * 100U) / 0x1fU);
-
-	return EOK;
+	return ret;
 }
 
 /**
@@ -997,23 +1059,26 @@ errno_t pfe_tmu_shp_cfg_set_limits(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy,
 		uint8_t shp, int32_t max_credit, int32_t min_credit)
 {
 	addr_t shp_base_va = cbus_base_va + TLITE_PHYn_SHPm_BASE_ADDR((uint32_t)phy, shp);
+	errno_t ret;
 
 	if ((max_credit > 0x3fffff) || (max_credit < 0))
 	{
 		NXP_LOG_ERROR("Max credit value exceeded\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	if ((min_credit < -0x3fffff) || (min_credit > 0))
+	else if ((min_credit < -0x3fffff) || (min_credit > 0))
 	{
 		NXP_LOG_ERROR("Min credit value exceeded\n");
-		return EINVAL;
+		ret = EINVAL;
+	}
+	else
+	{
+		hal_write32((uint32_t)max_credit << 10, shp_base_va + TMU_SHP_MAX_CREDIT);
+		hal_write32(-min_credit, shp_base_va + TMU_SHP_MIN_CREDIT);
+		ret = EOK;
 	}
 
-	hal_write32((uint32_t)max_credit << 10, shp_base_va + TMU_SHP_MAX_CREDIT);
-	hal_write32(-min_credit, shp_base_va + TMU_SHP_MIN_CREDIT);
-
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1049,19 +1114,23 @@ errno_t pfe_tmu_shp_cfg_set_position(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy
 {
 	addr_t shp_base_va = cbus_base_va + TLITE_PHYn_SHPm_BASE_ADDR((uint32_t)phy, shp);
 	uint32_t reg;
+	errno_t ret;
 
 	if ((pos > 16U) && (pos != PFE_TMU_INVALID_POSITION))
 	{
 		NXP_LOG_ERROR("Invalid shaper position: %d\n", pos);
-		return EINVAL;
+		ret = EINVAL;
+	}
+	else
+	{
+		reg = hal_read32(shp_base_va + TMU_SHP_CTRL2);
+		reg &= ~(0x1fU << 1);
+		reg |= (((uint32_t)pos & (uint32_t)0x1fU) << 1);
+		hal_write32(reg, shp_base_va + TMU_SHP_CTRL2);
+		ret = EOK;
 	}
 
-	reg = hal_read32(shp_base_va + TMU_SHP_CTRL2);
-	reg &= ~(0x1fU << 1);
-	reg |= (((uint32_t)pos & (uint32_t)0x1fU) << 1);
-	hal_write32(reg, shp_base_va + TMU_SHP_CTRL2);
-
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1108,6 +1177,7 @@ errno_t pfe_tmu_shp_cfg_set_rate_mode(addr_t cbus_base_va,
 {
 	uint32_t reg;
 	addr_t shp_base_va = cbus_base_va + TLITE_PHYn_SHPm_BASE_ADDR((uint32_t)phy, shp);
+	errno_t ret = EOK;
 
 	reg = hal_read32(shp_base_va + TMU_SHP_CTRL2);
 	if (mode == RATE_MODE_DATA_RATE)
@@ -1120,11 +1190,13 @@ errno_t pfe_tmu_shp_cfg_set_rate_mode(addr_t cbus_base_va,
 	}
 	else
 	{
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	hal_write32(reg, shp_base_va + TMU_SHP_CTRL2);
-	return EOK;
+	if (EOK == ret)
+	{
+		hal_write32(reg, shp_base_va + TMU_SHP_CTRL2);
+	}
+	return ret;
 }
 
 /**
@@ -1139,23 +1211,27 @@ pfe_tmu_rate_mode_t pfe_tmu_shp_cfg_get_rate_mode(addr_t cbus_base_va,
 {
 	uint32_t reg;
 	addr_t shp_base_va = cbus_base_va + TLITE_PHYn_SHPm_BASE_ADDR((uint32_t)phy, shp);
+	pfe_tmu_rate_mode_t rate_mode;
 
 	reg = hal_read32(shp_base_va + TMU_SHP_CTRL);
 	if (0U == (reg & 0x1U))
 	{
 		/*	Shaper is disabled */
-		return RATE_MODE_INVALID;
-	}
-
-	reg = hal_read32(shp_base_va + TMU_SHP_CTRL2);
-	if (0U != (reg & 0x1U))
-	{
-		return RATE_MODE_PACKET_RATE;
+		rate_mode = RATE_MODE_INVALID;
 	}
 	else
 	{
-		return RATE_MODE_DATA_RATE;
+		reg = hal_read32(shp_base_va + TMU_SHP_CTRL2);
+		if (0U != (reg & 0x1U))
+		{
+			rate_mode = RATE_MODE_PACKET_RATE;
+		}
+		else
+		{
+			rate_mode = RATE_MODE_DATA_RATE;
+		}
 	}
+	return rate_mode;
 }
 
 /**
@@ -1341,6 +1417,7 @@ errno_t pfe_tmu_sch_cfg_set_rate_mode(addr_t cbus_base_va, pfe_ct_phy_if_id_t ph
 {
 	uint32_t reg;
 	addr_t sch_base_va = cbus_base_va + TLITE_PHYn_SCHEDm_BASE_ADDR((uint32_t)phy, sch);
+	errno_t ret = EOK;
 
 	if (mode == RATE_MODE_DATA_RATE)
 	{
@@ -1352,12 +1429,15 @@ errno_t pfe_tmu_sch_cfg_set_rate_mode(addr_t cbus_base_va, pfe_ct_phy_if_id_t ph
 	}
 	else
 	{
-		return EINVAL;
+		ret = EINVAL;
 	}
 
-	hal_write32(reg, sch_base_va + TMU_SCH_BIT_RATE);
+	if (EOK == ret)
+	{
+		hal_write32(reg, sch_base_va + TMU_SCH_BIT_RATE);
+	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1405,6 +1485,7 @@ errno_t pfe_tmu_sch_cfg_set_algo(addr_t cbus_base_va,
 {
 	uint32_t reg;
 	addr_t sch_base_va = cbus_base_va + TLITE_PHYn_SCHEDm_BASE_ADDR((uint32_t)phy, sch);
+	errno_t ret = EOK;
 
 	if (algo == SCHED_ALGO_PQ)
 	{
@@ -1424,7 +1505,7 @@ errno_t pfe_tmu_sch_cfg_set_algo(addr_t cbus_base_va,
 		{
 			/*	See RTL and WRR pseudocode */
 			NXP_LOG_ERROR("WRR only supported in Packet Rate scheduler mode\n");
-			return EINVAL;
+			ret = EINVAL;
 		}
 		else
 		{
@@ -1433,12 +1514,15 @@ errno_t pfe_tmu_sch_cfg_set_algo(addr_t cbus_base_va,
 	}
 	else
 	{
-		return EINVAL;
+		ret = EINVAL;
 	}
 
-	hal_write32(reg, sch_base_va + TMU_SCH_CTRL);
+	if (EOK == ret)
+	{
+		hal_write32(reg, sch_base_va + TMU_SCH_CTRL);
+	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1507,16 +1591,20 @@ errno_t pfe_tmu_sch_cfg_set_input_weight(addr_t cbus_base_va,
 		pfe_ct_phy_if_id_t phy, uint8_t sch, uint8_t input, uint32_t weight)
 {
 	addr_t sch_base_va = cbus_base_va + TLITE_PHYn_SCHEDm_BASE_ADDR((uint32_t)phy, sch);
+	errno_t ret;
 
 	if (input >= TLITE_SCH_INPUTS_CNT)
 	{
 		NXP_LOG_ERROR("Scheduler input (%d) out of range\n", input);
-		return EINVAL;
+		ret = EINVAL;
+	}
+	else
+	{
+		hal_write32(weight, sch_base_va + TMU_SCH_Qn_WGHT(input));
+		ret = EOK;
 	}
 
-	hal_write32(weight, sch_base_va + TMU_SCH_Qn_WGHT(input));
-
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1530,14 +1618,19 @@ errno_t pfe_tmu_sch_cfg_set_input_weight(addr_t cbus_base_va,
 uint32_t pfe_tmu_sch_cfg_get_input_weight(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy, uint8_t sch, uint8_t input)
 {
 	addr_t sch_base_va = cbus_base_va + TLITE_PHYn_SCHEDm_BASE_ADDR((uint32_t)phy, sch);
+	uint32_t input_weight;
 
 	if (input >= TLITE_SCH_INPUTS_CNT)
 	{
 		NXP_LOG_ERROR("Scheduler input (%d) out of range\n", input);
-		return 0U;
+		input_weight = 0U;
+	}
+	else
+	{
+		input_weight = hal_read32(sch_base_va + TMU_SCH_Qn_WGHT(input));
 	}
 
-	return hal_read32(sch_base_va + TMU_SCH_Qn_WGHT(input));
+	return input_weight;
 }
 
 /**
@@ -1555,26 +1648,29 @@ errno_t pfe_tmu_sch_cfg_bind_queue(addr_t cbus_base_va,
 {
 	uint32_t reg;
 	addr_t sch_base_va = cbus_base_va + TLITE_PHYn_SCHEDm_BASE_ADDR((uint32_t)phy, sch);
+	errno_t ret;
 
 	if ((queue >= TLITE_PHY_QUEUES_CNT) && (queue != TLITE_SCH_INVALID_INPUT))
 	{
 		NXP_LOG_ERROR("Invalid queue\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	if (input >= TLITE_SCH_INPUTS_CNT)
+	else if (input >= TLITE_SCH_INPUTS_CNT)
 	{
 		NXP_LOG_ERROR("Scheduler input (%d) out of range\n", input);
-		return EINVAL;
+		ret = EINVAL;
+	}
+	else
+	{
+		/*	Update appropriate "ALLOC_Q" register */
+		reg = hal_read32(sch_base_va + TMU_SCH_Q_ALLOCn(input / 4U));
+		reg &= ~(0xffUL << (8U * (input % 4U)));
+		reg |= (((uint32_t)queue & 0x1fUL) << (8U * (input % 4U)));
+		hal_write32(reg, sch_base_va + TMU_SCH_Q_ALLOCn(input / 4U));
+		ret = EOK;
 	}
 
-	/*	Update appropriate "ALLOC_Q" register */
-	reg = hal_read32(sch_base_va + TMU_SCH_Q_ALLOCn(input / 4U));
-	reg &= ~(0xffUL << (8U * (input % 4U)));
-	reg |= (((uint32_t)queue & 0x1fUL) << (8U * (input % 4U)));
-	hal_write32(reg, sch_base_va + TMU_SCH_Q_ALLOCn(input / 4U));
-
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1594,13 +1690,20 @@ uint8_t pfe_tmu_sch_cfg_get_bound_queue(addr_t cbus_base_va, pfe_ct_phy_if_id_t
 	if (input >= TLITE_SCH_INPUTS_CNT)
 	{
 		NXP_LOG_ERROR("Scheduler input (%d) out of range\n", input);
-		return PFE_TMU_INVALID_QUEUE;
+		queue = PFE_TMU_INVALID_QUEUE;
 	}
+	else
+	{
+		reg = hal_read32(sch_base_va + TMU_SCH_Q_ALLOCn(input / 4U));
+		queue = (uint8_t)(reg >> (8U * (input % 4U))) & 0xffU;
 
-	reg = hal_read32(sch_base_va + TMU_SCH_Q_ALLOCn(input / 4U));
-	queue = (uint8_t)(reg >> (8U * (input % 4U))) & 0xffU;
+		if (TLITE_PHY_QUEUES_CNT <= queue)
+		{
+			queue = PFE_TMU_INVALID_QUEUE;
+		}
+	}
 
-	return (queue >= TLITE_PHY_QUEUES_CNT) ? PFE_TMU_INVALID_QUEUE : queue;
+	return queue;
 }
 
 /**
@@ -1615,24 +1718,30 @@ uint8_t pfe_tmu_sch_cfg_get_bound_queue(addr_t cbus_base_va, pfe_ct_phy_if_id_t
 errno_t pfe_tmu_sch_cfg_bind_sched_output(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy, uint8_t src_sch, uint8_t dst_sch, uint8_t input)
 {
 	addr_t sch_base_va = cbus_base_va + TLITE_PHYn_SCHEDm_BASE_ADDR((uint32_t)phy, src_sch);
+	errno_t ret;
 
 	/*	Scheduler0 -> Scheduler1 is the only possible option */
 	if ((src_sch != 0U) || (dst_sch != 1U))
 	{
 		NXP_LOG_ERROR("Scheduler 0 output can only be connected to Scheduler 1 input\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	/*	Invalidate the original Scheduler1 input */
-	if (EOK != pfe_tmu_sch_cfg_bind_queue(cbus_base_va, phy, dst_sch, input, PFE_TMU_INVALID_QUEUE))
+	else
 	{
-		return EINVAL;
-	}
 
-	/*	Connect Scheduler0 to given Scheduler1 input */
-	hal_write32((uint32_t)input & (uint32_t)0xfU, sch_base_va + TMU_SCH_POS);
-
-	return EOK;
+		/*	Invalidate the original Scheduler1 input */
+		if (EOK != pfe_tmu_sch_cfg_bind_queue(cbus_base_va, phy, dst_sch, input, PFE_TMU_INVALID_QUEUE))
+		{
+			ret = EINVAL;
+		}
+		else
+		{
+			/*	Connect Scheduler0 to given Scheduler1 input */
+			hal_write32((uint32_t)input & (uint32_t)0xfU, sch_base_va + TMU_SCH_POS);
+			ret = EOK;
+		}
+	}
+	return ret;
 }
 
 /**
@@ -1647,23 +1756,26 @@ uint8_t pfe_tmu_sch_cfg_get_bound_sched_output(addr_t cbus_base_va, pfe_ct_phy_i
 {
 	addr_t sch_base_va = cbus_base_va + TLITE_PHYn_SCHEDm_BASE_ADDR((uint32_t)phy, 0U);
 	uint32_t reg;
+	uint8_t sched_id;
 
 	/*	Scheduler0 -> Scheduler1 is the only possible option */
 	if (sch != 1U)
 	{
-		return PFE_TMU_INVALID_SCHEDULER;
+		sched_id = PFE_TMU_INVALID_SCHEDULER;
 	}
 
 	reg = hal_read32(sch_base_va + TMU_SCH_POS) & 0xffU;
 
 	if (input == reg)
 	{
-		return 0U;
+		sched_id = 0U;
 	}
 	else
 	{
-		return PFE_TMU_INVALID_SCHEDULER;
+		sched_id = PFE_TMU_INVALID_SCHEDULER;
 	}
+
+	return sched_id;
 }
 
 /**
diff --git a/sw/pfe_platform/hw/s32g/pfe_tmu_csr.h b/sw/pfe_platform/hw/s32g/pfe_tmu_csr.h
index efb8ede..43c8367 100644
--- a/sw/pfe_platform/hw/s32g/pfe_tmu_csr.h
+++ b/sw/pfe_platform/hw/s32g/pfe_tmu_csr.h
@@ -204,7 +204,7 @@
 #define TLITE_HIF_MAX_ENTRIES	(2U * TLITE_HIF_MAX_Q_SIZE)
 
 #define TLITE_OPT_Q0_SIZE		150U /* optimal size for the default queue (q0) */
-#define TLITE_OPT_Q1_7_SIZE		((uint16_t)((uint16_t)TLITE_MAX_ENTRIES - TLITE_OPT_Q0_SIZE) / 8U)
+#define TLITE_OPT_Q1_7_SIZE		((uint16_t)((uint16_t)TLITE_MAX_ENTRIES - TLITE_OPT_Q0_SIZE) / 7U)
 
 /*	Implementation of the pfe_tmu_phy_cfg_t */
 struct pfe_tmu_phy_cfg_tag
diff --git a/sw/pfe_platform/hw/s32g/pfe_util_csr.c b/sw/pfe_platform/hw/s32g/pfe_util_csr.c
index 5cbbb5f..ae34ac7 100644
--- a/sw/pfe_platform/hw/s32g/pfe_util_csr.c
+++ b/sw/pfe_platform/hw/s32g/pfe_util_csr.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2021 NXP
+ *  Copyright 2018-2022 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -31,22 +31,23 @@ uint32_t pfe_util_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size,
 	if (unlikely(NULL_ADDR == base_va))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return 0U;
+		len = 0U;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	/*	Get version */
-	if(verb_level >= 9U)
 	{
-		reg = hal_read32(base_va + UTIL_VERSION);
-		len += oal_util_snprintf(buf + len, size - len, "Revision             : 0x%x\n", (reg >> 24U) & 0xffU);
-		len += oal_util_snprintf(buf + len, size - len, "Version              : 0x%x\n", (reg >> 16U) & 0xffU);
-		len += oal_util_snprintf(buf + len, size - len, "ID                   : 0x%x\n", reg & 0xffffU);
-	}
-
-	len += oal_util_snprintf(buf + len, size - len, "Max buffer count\t0x%08x\n", hal_read32(base_va + UTIL_MAX_BUF_CNT));
-	len += oal_util_snprintf(buf + len, size - len, "TQS max count\t\t0x%08x\n", hal_read32(base_va + UTIL_TSQ_MAX_CNT));
+		/*	Get version */
+		if(verb_level >= 9U)
+		{
+			reg = hal_read32(base_va + UTIL_VERSION);
+			len += oal_util_snprintf(buf + len, size - len, "Revision             : 0x%x\n", (reg >> 24U) & 0xffU);
+			len += oal_util_snprintf(buf + len, size - len, "Version              : 0x%x\n", (reg >> 16U) & 0xffU);
+			len += oal_util_snprintf(buf + len, size - len, "ID                   : 0x%x\n", reg & 0xffffU);
+		}
 
+		len += oal_util_snprintf(buf + len, size - len, "Max buffer count\t0x%08x\n", hal_read32(base_va + UTIL_MAX_BUF_CNT));
+		len += oal_util_snprintf(buf + len, size - len, "TQS max count\t\t0x%08x\n", hal_read32(base_va + UTIL_TSQ_MAX_CNT));
+	}
 	return len;
 }
 
diff --git a/sw/pfe_platform/hw/s32g/pfe_wdt_csr.c b/sw/pfe_platform/hw/s32g/pfe_wdt_csr.c
index 2aec273..03af763 100644
--- a/sw/pfe_platform/hw/s32g/pfe_wdt_csr.c
+++ b/sw/pfe_platform/hw/s32g/pfe_wdt_csr.c
@@ -180,34 +180,36 @@ uint32_t pfe_wdt_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, u
 	if (unlikely(NULL_ADDR == base_va) || (NULL == buf))
 	{
 		NXP_LOG_ERROR("NULL argument received (pfe_wdt_cfg_get_text_stat)\n");
-		return 0U;
+		len = 0U;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if(verb_level >= 9U)
 	{
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "base_va              : 0x%x\n", (uint_t)base_va);
-		/*	Get version of wsp (wdt is part of wsp)*/
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "WSP Version          : 0x%x\n", hal_read32(base_va + WSP_VERSION));
+		if(verb_level >= 9U)
+		{
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "base_va              : 0x%x\n", (uint_t)base_va);
+			/*	Get version of wsp (wdt is part of wsp)*/
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "WSP Version          : 0x%x\n", hal_read32(base_va + WSP_VERSION));
+		}
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "WDT_INT_EN           : 0x%x\n", hal_read32(base_va + WDT_INT_EN));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_WDT_INT_EN     : 0x%x\n", hal_read32(base_va + CLASS_WDT_INT_EN));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "UPE_WDT_INT_EN       : 0x%x\n", hal_read32(base_va + UPE_WDT_INT_EN));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HGPI_WDT_INT_EN      : 0x%x\n", hal_read32(base_va + HGPI_WDT_INT_EN));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_WDT_INT_EN       : 0x%x\n", hal_read32(base_va + HIF_WDT_INT_EN));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "TLITE_WDT_INT_EN     : 0x%x\n", hal_read32(base_va + TLITE_WDT_INT_EN));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HNCPY_WDT_INT_EN     : 0x%x\n", hal_read32(base_va + HNCPY_WDT_INT_EN));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "BMU1_WDT_INT_EN      : 0x%x\n", hal_read32(base_va + BMU1_WDT_INT_EN));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "BMU2_WDT_INT_EN      : 0x%x\n", hal_read32(base_va + BMU2_WDT_INT_EN));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "EMAC0_WDT_INT_EN     : 0x%x\n", hal_read32(base_va + EMAC0_WDT_INT_EN));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "EMAC1_WDT_INT_EN     : 0x%x\n", hal_read32(base_va + EMAC1_WDT_INT_EN));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "EMAC2_WDT_INT_EN     : 0x%x\n", hal_read32(base_va + EMAC2_WDT_INT_EN));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "WDT_INT_SRC          : 0x%x\n", hal_read32(base_va + WDT_INT_SRC));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "WDT_TIMER_VAL_1      : 0x%x\n", hal_read32(base_va + WDT_TIMER_VAL_1));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "WDT_TIMER_VAL_2      : 0x%x\n", hal_read32(base_va + WDT_TIMER_VAL_2));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "WDT_TIMER_VAL_3      : 0x%x\n", hal_read32(base_va + WDT_TIMER_VAL_3));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "WDT_TIMER_VAL_4      : 0x%x\n", hal_read32(base_va + WDT_TIMER_VAL_4));
+			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "WSP_DBUG_BUS1        : 0x%x\n", hal_read32(base_va + WSP_DBUG_BUS1));
 	}
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "WDT_INT_EN           : 0x%x\n", hal_read32(base_va + WDT_INT_EN));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_WDT_INT_EN     : 0x%x\n", hal_read32(base_va + CLASS_WDT_INT_EN));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "UPE_WDT_INT_EN       : 0x%x\n", hal_read32(base_va + UPE_WDT_INT_EN));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HGPI_WDT_INT_EN      : 0x%x\n", hal_read32(base_va + HGPI_WDT_INT_EN));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HIF_WDT_INT_EN       : 0x%x\n", hal_read32(base_va + HIF_WDT_INT_EN));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "TLITE_WDT_INT_EN     : 0x%x\n", hal_read32(base_va + TLITE_WDT_INT_EN));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "HNCPY_WDT_INT_EN     : 0x%x\n", hal_read32(base_va + HNCPY_WDT_INT_EN));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "BMU1_WDT_INT_EN      : 0x%x\n", hal_read32(base_va + BMU1_WDT_INT_EN));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "BMU2_WDT_INT_EN      : 0x%x\n", hal_read32(base_va + BMU2_WDT_INT_EN));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "EMAC0_WDT_INT_EN     : 0x%x\n", hal_read32(base_va + EMAC0_WDT_INT_EN));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "EMAC1_WDT_INT_EN     : 0x%x\n", hal_read32(base_va + EMAC1_WDT_INT_EN));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "EMAC2_WDT_INT_EN     : 0x%x\n", hal_read32(base_va + EMAC2_WDT_INT_EN));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "WDT_INT_SRC          : 0x%x\n", hal_read32(base_va + WDT_INT_SRC));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "WDT_TIMER_VAL_1      : 0x%x\n", hal_read32(base_va + WDT_TIMER_VAL_1));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "WDT_TIMER_VAL_2      : 0x%x\n", hal_read32(base_va + WDT_TIMER_VAL_2));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "WDT_TIMER_VAL_3      : 0x%x\n", hal_read32(base_va + WDT_TIMER_VAL_3));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "WDT_TIMER_VAL_4      : 0x%x\n", hal_read32(base_va + WDT_TIMER_VAL_4));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "WSP_DBUG_BUS1        : 0x%x\n", hal_read32(base_va + WSP_DBUG_BUS1));
 
 	return len;
 }
diff --git a/sw/pfe_platform/public/pfe_class.h b/sw/pfe_platform/public/pfe_class.h
index d6bfda8..45b81e5 100644
--- a/sw/pfe_platform/public/pfe_class.h
+++ b/sw/pfe_platform/public/pfe_class.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2021 NXP
+ *  Copyright 2018-2022 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -28,6 +28,8 @@ typedef struct
 	void * ddr_base_va;				/*	DDR region base address (virtual) */
 	void * ddr_base_pa;				/*	DDR region base address (physical) */
 	uint32_t ddr_size;				/*	Size of the DDR region */
+	uint16_t lmem_header_size;
+	uint16_t ro_header_size;
 } pfe_class_cfg_t;
 
 pfe_class_t *pfe_class_create(addr_t cbus_base_va, uint32_t pe_num, const pfe_class_cfg_t *cfg);
diff --git a/sw/pfe_platform/public/pfe_ct.h b/sw/pfe_platform/public/pfe_ct.h
index d943889..3a92cb6 100644
--- a/sw/pfe_platform/public/pfe_ct.h
+++ b/sw/pfe_platform/public/pfe_ct.h
@@ -1038,6 +1038,8 @@ typedef struct __attribute__((packed, aligned(4)))
 	PFE_PTR(pfe_ct_buffer_t) get_buffer;
 	/*	HIF TMU Queue sizes information for errata ERR051211 workaround*/
 	PFE_PTR(pfe_ct_hif_tmu_queue_sizes_t) hif_tmu_queue_sizes;
+	/* HIF interface used for PTP traffic in bridge mode*/
+	PFE_PTR(pfe_ct_phy_if_id_t) ptp_common_hif;
 } pfe_ct_class_mmap_t;
 
 /**
@@ -1080,19 +1082,6 @@ typedef union __attribute__((packed, aligned(4)))
 	pfe_ct_util_mmap_t util_pe;		/* UTIL PE variant */
 } pfe_ct_pe_mmap_t;
 
-typedef enum __attribute__((packed))
-{
-	/*	Invalid reason */
-	PUNT_INVALID = 0U,
-	/*	Punt by snooping feature */
-	PUNT_SNOOP = (1U << 0U),
-	/*	Ensure proper size */
-	PUNT_MAX = (1U << 15U)
-} pfe_ct_punt_reasons_t;
-
-/*	We expect given pfe_ct_punt_reasons_t size due to byte order compatibility. */
-ct_assert(sizeof(pfe_ct_punt_reasons_t) == sizeof(uint16_t));
-
 typedef enum __attribute__((packed))
 {
 	/*	No flag being set */
@@ -1109,8 +1098,6 @@ typedef enum __attribute__((packed))
 	HIF_RX_UDPV6_CSUM = (1U << 4U),
 	/*	PTP packet */
 	HIF_RX_PTP = (1U << 5U),
-	/*	Punt flag. If set then punt reason is valid. */
-	HIF_RX_PUNT = (1U << 6U),
 	/*	Timestamp flag. When set, timestamp is valid. */
 	HIF_RX_TS = (1U << 7U),
 	/*	Inter - HIF communication frame */
@@ -1120,25 +1107,33 @@ typedef enum __attribute__((packed))
 	/*	IPv6 checksum valid */
 	HIF_RX_IPV6_CSUM = (1U << 10U),
 	/*	ICMP checksum valid */
-	HIF_RX_ICMP_CSUM = (1U << 11U)
+	HIF_RX_ICMP_CSUM = (1U << 11U),
+	/*      Frame send to HIF0 has vlan tag*/
+	HIF_RX_HIF0_VLAN = (1U << 12U),
+	/*      Frame send to HIF1 has vlan tag*/
+	HIF_RX_HIF1_VLAN = (1U << 13U),
+	/*      Frame send to HIF2 has vlan tag*/
+	HIF_RX_HIF2_VLAN = (1U << 14U),
+	/*      Frame send to HIF3 has vlan tag*/
+	HIF_RX_HIF3_VLAN = (1U << 15U),
+	/*	Ensure proper size */
+	HIF_RX_MAX = (int)(1U << 31U)
 } pfe_ct_hif_rx_flags_t;
 
 /*	We expect given pfe_ct_hif_rx_flags_t size due to byte order compatibility. */
-ct_assert(sizeof(pfe_ct_hif_rx_flags_t) == sizeof(uint16_t));
+ct_assert(sizeof(pfe_ct_hif_rx_flags_t) == sizeof(uint32_t));
 
 /**
  * @brief	HIF RX packet header
  */
 typedef struct __attribute__((packed))
 {
-	/*	Punt reason flags */
-	pfe_ct_punt_reasons_t punt_reasons;
+	/*	Rx frame flags */
+	pfe_ct_hif_rx_flags_t flags;
 	/*	Ingress physical interface ID */
 	pfe_ct_phy_if_id_t i_phy_if;
 	/*	Ingress logical interface ID */
 	uint8_t i_log_if;
-	/*	Rx frame flags */
-	pfe_ct_hif_rx_flags_t flags;
 	/*	Queue */
 	uint8_t queue;
 	/*	Reserved */
diff --git a/sw/pfe_platform/public/pfe_gpi.h b/sw/pfe_platform/public/pfe_gpi.h
index bac72b5..2a86d97 100644
--- a/sw/pfe_platform/public/pfe_gpi.h
+++ b/sw/pfe_platform/public/pfe_gpi.h
@@ -170,6 +170,7 @@ typedef struct
 	uint32_t alloc_retry_cycles;
 	uint32_t gpi_tmlf_txthres;
 	uint32_t gpi_dtx_aseq_len;
+	uint16_t lmem_header_size;
 	bool_t emac_1588_ts_en;
 } pfe_gpi_cfg_t;
 
diff --git a/sw/pfe_platform/public/pfe_hif_chnl_linux.h b/sw/pfe_platform/public/pfe_hif_chnl_linux.h
index 9fde642..29b1db4 100644
--- a/sw/pfe_platform/public/pfe_hif_chnl_linux.h
+++ b/sw/pfe_platform/public/pfe_hif_chnl_linux.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2021 NXP
+ *  Copyright 2018-2022 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -137,6 +137,7 @@
 #ifndef PUBLIC_PFE_HIF_CHNL_H_
 #define PUBLIC_PFE_HIF_CHNL_H_
 
+#include "pfe_bmu.h"
 #include "pfe_hif_ring_linux.h"
 
 /**
@@ -144,23 +145,14 @@
  * @details	When TRUE then RX buffer management is embedded so caller layer
  * 			does not need to care about it. FALSE disables the feature.
  */
-#if !defined(PFE_CFG_TARGET_OS_LINUX)
-#define PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED		TRUE
-#else
-#define PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED		FALSE
-#endif
+#define PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED	FALSE
 
 /**
  * @brief	RX OOB management
  * @details	When TRUE then RX OOB buffer management is embedded so caller layer
  * 			can process the RX_OOB_EVENT. FALSE removed the feature.
  */
-#if !defined(PFE_CFG_TARGET_OS_LINUX)
-#define PFE_HIF_CHNL_CFG_RX_OOB_EVENT_ENABLED	TRUE
-#else
 #define PFE_HIF_CHNL_CFG_RX_OOB_EVENT_ENABLED	FALSE
-#endif
-#include "pfe_bmu.h"
 
 /**
  * @brief	List of available HIF channel events
@@ -181,6 +173,7 @@ typedef void (* pfe_hif_chnl_cbk_t)(void *arg);
 /*	This is the channel ID used to identify HIF_NOCPY channel */
 #define PFE_HIF_CHNL_NOCPY_ID		1000U
 
+#define MAC_ADDRESS_SIZE		6U
 /*	RX */
 errno_t pfe_hif_chnl_rx_enable(pfe_hif_chnl_t *chnl) __attribute__((cold));
 void pfe_hif_chnl_rx_disable(pfe_hif_chnl_t *chnl) __attribute__((cold));
diff --git a/sw/pfe_platform/public/pfe_hif_nocpy.h b/sw/pfe_platform/public/pfe_hif_nocpy.h
index 5c886ca..5964873 100644
--- a/sw/pfe_platform/public/pfe_hif_nocpy.h
+++ b/sw/pfe_platform/public/pfe_hif_nocpy.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2021 NXP
+ *  Copyright 2018-2022 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -21,7 +21,7 @@ typedef struct
 
 typedef struct pfe_hif_nocpy_tag pfe_hif_nocpy_t;
 
-pfe_hif_nocpy_t *pfe_hif_nocpy_create(addr_t base_va, const pfe_bmu_t *bmu);
+pfe_hif_nocpy_t *pfe_hif_nocpy_create(addr_t base_va, const pfe_bmu_t *bmu, uint16_t lmem_header_size);
 pfe_hif_chnl_t *pfe_hif_nocpy_get_channel(const pfe_hif_nocpy_t *hif, uint32_t channel_id);
 uint32_t pfe_hif_nocpy_get_text_statistics(const pfe_hif_nocpy_t *hif, char_t *buf, uint32_t buf_len, uint8_t verb_level);
 void pfe_hif_nocpy_destroy(pfe_hif_nocpy_t *hif);
diff --git a/sw/pfe_platform/public/pfe_hif_ring_linux.h b/sw/pfe_platform/public/pfe_hif_ring_linux.h
index 882751f..817ce30 100644
--- a/sw/pfe_platform/public/pfe_hif_ring_linux.h
+++ b/sw/pfe_platform/public/pfe_hif_ring_linux.h
@@ -22,7 +22,6 @@ errno_t pfe_hif_ring_enqueue_buf(pfe_hif_ring_t *ring, const void *buf_pa, uint3
 errno_t pfe_hif_ring_dequeue_buf(pfe_hif_ring_t *ring, void **buf_pa, uint32_t *length, bool_t *lifm) __attribute__((hot));
 errno_t pfe_hif_ring_dequeue_plain(pfe_hif_ring_t *ring, bool_t *lifm) __attribute__((hot));
 errno_t pfe_hif_ring_drain_buf(pfe_hif_ring_t *ring, void **buf_pa) __attribute__((cold));
-bool_t spfe_hif_ring_is_below_wm(const pfe_hif_ring_t *ring) __attribute__((pure, hot));
 void pfe_hif_ring_invalidate(const pfe_hif_ring_t *ring) __attribute__((cold));
 uint32_t pfe_hif_ring_get_fill_level(const pfe_hif_ring_t *ring) __attribute__((pure, hot));
 uint32_t pfe_hif_ring_dump(pfe_hif_ring_t *ring, char_t *name, char_t *buf, uint32_t size, uint8_t verb_level);
diff --git a/sw/pfe_platform/public/pfe_platform.h b/sw/pfe_platform/public/pfe_platform.h
index 778b5f5..dfe5f09 100644
--- a/sw/pfe_platform/public/pfe_platform.h
+++ b/sw/pfe_platform/public/pfe_platform.h
@@ -135,6 +135,7 @@ typedef struct
 	pfe_if_db_t *phy_if_db;
 	pfe_if_db_t *log_if_db;
 	bool_t fci_created;
+	uint32_t pfe_version;
 } pfe_platform_t;
 
 pfe_fw_t *pfe_fw_load(char_t *class_fw_name, char_t *util_fw_name);
diff --git a/sw/pfe_platform/public/pfe_platform_cfg.h b/sw/pfe_platform/public/pfe_platform_cfg.h
index f7d5cb8..f79f149 100644
--- a/sw/pfe_platform/public/pfe_platform_cfg.h
+++ b/sw/pfe_platform/public/pfe_platform_cfg.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2021 NXP
+ *  Copyright 2018-2022 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -144,19 +144,18 @@
 #define PFE_CFG_UTIL_FIRMWARE_FILENAME		"/tmp/upe_s32g.elf"
 
 /* LMEM defines */
-#define PFE_CFG_LMEM_HDR_SIZE		0x0070U
 #define PFE_CFG_LMEM_BUF_SIZE_LN2	0x8U /* 256 */
 #define PFE_CFG_LMEM_BUF_SIZE		(1UL << PFE_CFG_LMEM_BUF_SIZE_LN2)
 
 /* DDR defines */
-#define PFE_CFG_DDR_HDR_SIZE		0x0200U 
+#define PFE_CFG_DDR_HDR_SIZE		0x0200U  /* Hardwired in HW */
 #define PFE_CFG_DDR_BUF_SIZE_LN2	0xbU /* 2048 */
 #define PFE_CFG_DDR_BUF_SIZE		(1UL << PFE_CFG_DDR_BUF_SIZE_LN2)
 
-/* RO defines */
-#define PFE_CFG_RO_HDR_SIZE			0x0010UL
-
 /* Maximal count of entries within hash area of routing table */
 #define PFE_CFG_RT_HASH_ENTRIES_MAX_CNT 1048576U
 
+/* Value read from version register on S32G3 */
+#define PFE_S32G3_VERSION 0x00000101U
+
 #endif /* SRC_PFE_PLATFORM_CFG_H_ */
diff --git a/sw/pfe_platform/public/pfe_rtable.h b/sw/pfe_platform/public/pfe_rtable.h
index e0e0d16..c1ef2ba 100644
--- a/sw/pfe_platform/public/pfe_rtable.h
+++ b/sw/pfe_platform/public/pfe_rtable.h
@@ -132,6 +132,7 @@ void pfe_rtable_entry_set_refptr(pfe_rtable_entry_t *entry, void *refptr);
 void *pfe_rtable_entry_get_refptr(pfe_rtable_entry_t *entry);
 void pfe_rtable_entry_set_child(pfe_rtable_entry_t *entry, pfe_rtable_entry_t *child);
 pfe_rtable_entry_t *pfe_rtable_entry_get_child(const pfe_rtable_entry_t *entry);
+uint8_t pfe_rtable_entry_get_stats_index(const pfe_rtable_entry_t *entry);
 
 void pfe_rtable_entry_set_id5t(pfe_rtable_entry_t *entry, uint32_t id5t);
 errno_t pfe_rtable_entry_get_id5t(const pfe_rtable_entry_t *entry, uint32_t *id5t);
diff --git a/sw/pfe_platform/src/pfe_bmu.c b/sw/pfe_platform/src/pfe_bmu.c
index e5efc34..d992c0e 100644
--- a/sw/pfe_platform/src/pfe_bmu.c
+++ b/sw/pfe_platform/src/pfe_bmu.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2021 NXP
+ *  Copyright 2018-2022 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -42,32 +42,34 @@ struct pfe_bmu_tag
  */
 __attribute__((cold)) errno_t pfe_bmu_isr(const pfe_bmu_t *bmu)
 {
-	errno_t ret = ENOENT;
+	errno_t ret;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == bmu))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-#ifdef PFE_CFG_PARANOID_IRQ
-	if (EOK != oal_mutex_lock(&bmu->lock))
 	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
-#endif /* PFE_CFG_PARANOID_IRQ */
+	#ifdef PFE_CFG_PARANOID_IRQ
+		if (EOK != oal_mutex_lock(&bmu->lock))
+		{
+			NXP_LOG_DEBUG("Mutex lock failed\n");
+		}
+	#endif /* PFE_CFG_PARANOID_IRQ */
 
-	/*	Run the low-level ISR to identify and process the interrupt */
-	ret = pfe_bmu_cfg_isr(bmu->bmu_base_va, bmu->cbus_base_va);
+		/*	Run the low-level ISR to identify and process the interrupt */
+		ret = pfe_bmu_cfg_isr(bmu->bmu_base_va, bmu->cbus_base_va);
 
-#ifdef PFE_CFG_PARANOID_IRQ
-	if (EOK != oal_mutex_unlock(&bmu->lock))
-	{
-		NXP_LOG_DEBUG("Mutex unlock failed\n");
+	#ifdef PFE_CFG_PARANOID_IRQ
+		if (EOK != oal_mutex_unlock(&bmu->lock))
+		{
+			NXP_LOG_DEBUG("Mutex unlock failed\n");
+		}
+	#endif /* PFE_CFG_PARANOID_IRQ */
 	}
-#endif /* PFE_CFG_PARANOID_IRQ */
 
 	return ret;
 }
@@ -135,64 +137,63 @@ __attribute__((cold)) pfe_bmu_t *pfe_bmu_create(addr_t cbus_base_va, addr_t bmu_
 	if (unlikely((NULL == cfg) || (NULL_ADDR == cbus_base_va)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return NULL;
+		bmu = NULL;
 	}
-
-	if (unlikely(NULL_ADDR == cfg->pool_pa))
+	else if (unlikely(NULL_ADDR == cfg->pool_pa))
 	{
 		NXP_LOG_ERROR("Buffer pool base is NULL\n");
-		return NULL;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	bmu = oal_mm_malloc(sizeof(pfe_bmu_t));
-
-	if (NULL == bmu)
-	{
-		return NULL;
+		bmu = NULL;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		(void)memset(bmu, 0, sizeof(pfe_bmu_t));
-		bmu->cbus_base_va = cbus_base_va;
-		bmu->bmu_base_offset = bmu_base;
-		bmu->bmu_base_va = (bmu->cbus_base_va + bmu->bmu_base_offset);
-		bmu->pool_base_pa = cfg->pool_pa;
-		bmu->pool_base_va = cfg->pool_va;
-		bmu->pool_va_offset = bmu->pool_base_va - bmu->pool_base_pa;
-		bmu->pool_size = cfg->buf_size * cfg->max_buf_cnt;
-		bmu->buf_size = cfg->buf_size;
+		bmu = oal_mm_malloc(sizeof(pfe_bmu_t));
 
-#ifdef PFE_CFG_PARANOID_IRQ
-		/*	Resource protection */
-		if (EOK != oal_mutex_init(&bmu->lock))
+		if(NULL != bmu)
 		{
-			NXP_LOG_DEBUG("Mutex initialization failed\n");
-			oal_mm_free(bmu);
-			return NULL;
+			(void)memset(bmu, 0, sizeof(pfe_bmu_t));
+			bmu->cbus_base_va = cbus_base_va;
+			bmu->bmu_base_offset = bmu_base;
+			bmu->bmu_base_va = (bmu->cbus_base_va + bmu->bmu_base_offset);
+			bmu->pool_base_pa = cfg->pool_pa;
+			bmu->pool_base_va = cfg->pool_va;
+			bmu->pool_va_offset = bmu->pool_base_va - bmu->pool_base_pa;
+			bmu->pool_size = cfg->buf_size * cfg->max_buf_cnt;
+			bmu->buf_size = cfg->buf_size;
+
+	#ifdef PFE_CFG_PARANOID_IRQ
+			/*	Resource protection */
+			if (EOK != oal_mutex_init(&bmu->lock))
+			{
+				NXP_LOG_DEBUG("Mutex initialization failed\n");
+				oal_mm_free(bmu);
+				bmu = NULL;
+			}
+			else
+	#endif /* PFE_CFG_PARANOID_IRQ */
+			{
+				pfe_bmu_reset(bmu);
+
+			#ifdef PFE_CFG_PARANOID_IRQ
+				if (EOK != oal_mutex_lock(&bmu->lock))
+				{
+					NXP_LOG_DEBUG("Mutex lock failed\n");
+				}
+			#endif /* PFE_CFG_PARANOID_IRQ */
+
+				pfe_bmu_cfg_disable(bmu->bmu_base_va);
+				pfe_bmu_cfg_init(bmu->bmu_base_va, cfg);
+
+			#ifdef PFE_CFG_PARANOID_IRQ
+				if (EOK != oal_mutex_unlock(&bmu->lock))
+				{
+					NXP_LOG_DEBUG("Mutex unlock failed\n");
+				}
+			#endif /* PFE_CFG_PARANOID_IRQ */
+			}
 		}
-#endif /* PFE_CFG_PARANOID_IRQ */
 	}
 
-	pfe_bmu_reset(bmu);
-
-#ifdef PFE_CFG_PARANOID_IRQ
-	if (EOK != oal_mutex_lock(&bmu->lock))
-	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
-#endif /* PFE_CFG_PARANOID_IRQ */
-
-	pfe_bmu_cfg_disable(bmu->bmu_base_va);
-	pfe_bmu_cfg_init(bmu->bmu_base_va, cfg);
-
-#ifdef PFE_CFG_PARANOID_IRQ
-	if (EOK != oal_mutex_unlock(&bmu->lock))
-	{
-		NXP_LOG_DEBUG("Mutex unlock failed\n");
-	}
-#endif /* PFE_CFG_PARANOID_IRQ */
-
 	return bmu;
 }
 
@@ -208,38 +209,40 @@ __attribute__((cold)) void pfe_bmu_reset(const pfe_bmu_t *bmu)
 	if (unlikely(NULL == bmu))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-#ifdef PFE_CFG_PARANOID_IRQ
-	if (EOK != oal_mutex_lock(&bmu->lock))
 	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
-#endif /* PFE_CFG_PARANOID_IRQ */
+	#ifdef PFE_CFG_PARANOID_IRQ
+		if (EOK != oal_mutex_lock(&bmu->lock))
+		{
+			NXP_LOG_DEBUG("Mutex lock failed\n");
+		}
+	#endif /* PFE_CFG_PARANOID_IRQ */
 
-	ret = pfe_bmu_cfg_reset(bmu->bmu_base_va);
-	if (ETIMEDOUT == ret)
-	{
-		NXP_LOG_WARNING("BMU reset timed-out\n");
-	}
-	else if (EOK != ret)
-	{
-		NXP_LOG_WARNING("BMU reset failed: 0x%x\n", ret);
-	}
-	else
-	{
-		/*Do Nothing*/
-		;
-	}
+		ret = pfe_bmu_cfg_reset(bmu->bmu_base_va);
 
-#ifdef PFE_CFG_PARANOID_IRQ
-	if (EOK != oal_mutex_unlock(&bmu->lock))
-	{
-		NXP_LOG_DEBUG("Mutex unlock failed\n");
+		if (ETIMEDOUT == ret)
+		{
+			NXP_LOG_WARNING("BMU reset timed-out\n");
+		}
+		else if (EOK != ret)
+		{
+			NXP_LOG_WARNING("BMU reset failed: 0x%x\n", ret);
+		}
+		else
+		{
+			/*Do Nothing*/
+			;
+		}
+
+	#ifdef PFE_CFG_PARANOID_IRQ
+		if (EOK != oal_mutex_unlock(&bmu->lock))
+		{
+			NXP_LOG_DEBUG("Mutex unlock failed\n");
+		}
+	#endif /* PFE_CFG_PARANOID_IRQ */
 	}
-#endif /* PFE_CFG_PARANOID_IRQ */
 }
 
 /**
@@ -252,25 +255,26 @@ __attribute__((cold)) void pfe_bmu_enable(const pfe_bmu_t *bmu)
 	if (unlikely(NULL == bmu))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-#ifdef PFE_CFG_PARANOID_IRQ
-	if (EOK != oal_mutex_lock(&bmu->lock))
 	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
-#endif /* PFE_CFG_PARANOID_IRQ */
+	#ifdef PFE_CFG_PARANOID_IRQ
+		if (EOK != oal_mutex_lock(&bmu->lock))
+		{
+			NXP_LOG_DEBUG("Mutex lock failed\n");
+		}
+	#endif /* PFE_CFG_PARANOID_IRQ */
 
-	pfe_bmu_cfg_enable(bmu->bmu_base_va);
+		pfe_bmu_cfg_enable(bmu->bmu_base_va);
 
-#ifdef PFE_CFG_PARANOID_IRQ
-	if (EOK != oal_mutex_unlock(&bmu->lock))
-	{
-		NXP_LOG_DEBUG("Mutex unlock failed\n");
+	#ifdef PFE_CFG_PARANOID_IRQ
+		if (EOK != oal_mutex_unlock(&bmu->lock))
+		{
+			NXP_LOG_DEBUG("Mutex unlock failed\n");
+		}
+	#endif /* PFE_CFG_PARANOID_IRQ */
 	}
-#endif /* PFE_CFG_PARANOID_IRQ */
 }
 
 /**
@@ -283,25 +287,26 @@ __attribute__((cold)) void pfe_bmu_disable(const pfe_bmu_t *bmu)
 	if (unlikely(NULL == bmu))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-#ifdef PFE_CFG_PARANOID_IRQ
-	if (EOK != oal_mutex_lock(&bmu->lock))
 	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
-#endif /* PFE_CFG_PARANOID_IRQ */
+	#ifdef PFE_CFG_PARANOID_IRQ
+		if (EOK != oal_mutex_lock(&bmu->lock))
+		{
+			NXP_LOG_DEBUG("Mutex lock failed\n");
+		}
+	#endif /* PFE_CFG_PARANOID_IRQ */
 
-	pfe_bmu_cfg_disable(bmu->bmu_base_va);
+		pfe_bmu_cfg_disable(bmu->bmu_base_va);
 
-#ifdef PFE_CFG_PARANOID_IRQ
-	if (EOK != oal_mutex_unlock(&bmu->lock))
-	{
-		NXP_LOG_DEBUG("Mutex unlock failed\n");
+	#ifdef PFE_CFG_PARANOID_IRQ
+		if (EOK != oal_mutex_unlock(&bmu->lock))
+		{
+			NXP_LOG_DEBUG("Mutex unlock failed\n");
+		}
+	#endif /* PFE_CFG_PARANOID_IRQ */
 	}
-#endif /* PFE_CFG_PARANOID_IRQ */
 }
 
 /**
@@ -312,16 +317,21 @@ __attribute__((cold)) void pfe_bmu_disable(const pfe_bmu_t *bmu)
  */
 __attribute__((hot)) void *pfe_bmu_alloc_buf(const pfe_bmu_t *bmu)
 {
+	void *ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == bmu))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return NULL;
+		ret = NULL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		/*	No resource protection here since it is done by register read */
+		ret = (void *)pfe_bmu_cfg_alloc_buf(bmu->bmu_base_va);
+	}
 
-	/*	No resource protection here since it is done by register read */
-	return (void *)pfe_bmu_cfg_alloc_buf(bmu->bmu_base_va);
+	return ret;
 }
 
 /**
@@ -332,21 +342,25 @@ __attribute__((hot)) void *pfe_bmu_alloc_buf(const pfe_bmu_t *bmu)
  */
 __attribute__((hot, pure)) void *pfe_bmu_get_va(const pfe_bmu_t *bmu, addr_t pa)
 {
+	void * ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == bmu))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return NULL;
+		ret = NULL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if ((bmu->pool_base_pa + bmu->pool_size) < pa)
 	{
-		/*	TODO: The condition is not sufficient and need to consider buffer size... */
-		NXP_LOG_DEBUG("PA out of range\n");
+		if ((bmu->pool_base_pa + bmu->pool_size) < pa)
+		{
+			/*	TODO: The condition is not sufficient and need to consider buffer size... */
+			NXP_LOG_DEBUG("PA out of range\n");
+		}
+		ret = (void *)(pa + bmu->pool_va_offset);
 	}
 
-	return (void *)(pa + bmu->pool_va_offset);
+	return ret;
 }
 
 /**
@@ -357,21 +371,25 @@ __attribute__((hot, pure)) void *pfe_bmu_get_va(const pfe_bmu_t *bmu, addr_t pa)
  */
 __attribute__((hot, pure)) void *pfe_bmu_get_pa(const pfe_bmu_t *bmu, addr_t va)
 {
+	void * ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == bmu))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return NULL;
+		ret = NULL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if ((bmu->pool_base_va + bmu->pool_size) < va)
 	{
-		/*	TODO: The condition is not sufficient and need to consider buffer size... */
-		NXP_LOG_DEBUG("VA out of range\n");
+		if ((bmu->pool_base_va + bmu->pool_size) < va)
+		{
+			/*	TODO: The condition is not sufficient and need to consider buffer size... */
+			NXP_LOG_DEBUG("VA out of range\n");
+		}
+		ret = (void *)(va - bmu->pool_va_offset);
 	}
 
-	return (void *)(va - bmu->pool_va_offset);
+	return ret;
 }
 
 /**
@@ -381,15 +399,19 @@ __attribute__((hot, pure)) void *pfe_bmu_get_pa(const pfe_bmu_t *bmu, addr_t va)
  */
 __attribute__((cold, pure)) uint32_t pfe_bmu_get_buf_size(const pfe_bmu_t *bmu)
 {
+	uint32_t len;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == bmu))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return 0U;
+		len = 0U;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	return bmu->buf_size;
+	{
+		len = bmu->buf_size;
+	}
+	return len;
 }
 
 /**
@@ -404,12 +426,13 @@ __attribute__((hot)) void pfe_bmu_free_buf(const pfe_bmu_t *bmu, addr_t buffer)
 	if (unlikely((NULL == bmu) || (NULL_ADDR == buffer)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	/*	No resource protection here since it is done by register write */
-	pfe_bmu_cfg_free_buf(bmu->bmu_base_va, PFE_CFG_MEMORY_PHYS_TO_PFE(buffer));
+	{
+		/*	No resource protection here since it is done by register write */
+		pfe_bmu_cfg_free_buf(bmu->bmu_base_va, PFE_CFG_MEMORY_PHYS_TO_PFE(buffer));
+	}
 }
 
 /**
@@ -463,11 +486,12 @@ __attribute__((cold)) uint32_t pfe_bmu_get_text_statistics(const pfe_bmu_t *bmu,
 	if (unlikely(NULL == bmu))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return 0U;
+		len = 0U;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
+	{
 		len += pfe_bmu_cfg_get_text_stat(bmu->bmu_base_va, buf, buf_len, verb_level);
-
+	}
 	return len;
 }
diff --git a/sw/pfe_platform/src/pfe_class.c b/sw/pfe_platform/src/pfe_class.c
index 27cca44..453e5f6 100644
--- a/sw/pfe_platform/src/pfe_class.c
+++ b/sw/pfe_platform/src/pfe_class.c
@@ -28,29 +28,28 @@
 */
 #define PFE_CLASS_HEAP_CHUNK_SIZE 4
 
-
 struct pfe_classifier_tag
 {
-	bool_t is_fw_loaded;					/*	Flag indicating that firmware has been loaded */
-	bool_t enabled;							/*	Flag indicating that classifier has been enabled */
-	addr_t cbus_base_va;						/*	CBUS base virtual address */
-	uint32_t pe_num;						/*	Number of PEs */
-	pfe_pe_t **pe;							/*	List of particular PEs */
-	blalloc_t *heap_context;				/* Heap manager context */
-	uint32_t dmem_heap_base;				/* DMEM base address of the heap */
-	oal_mutex_t mutex;
-    uint32_t current_feature;               /* Index of the feature to return by pfe_class_get_feature_next() */
-    pfe_fw_feature_t **fw_features;          /* List of all features*/
-    uint32_t fw_features_count;             /* Number of items in fw_features */
+	bool_t             is_fw_loaded;   /*	Flag indicating that firmware has been loaded */
+	bool_t             enabled;        /*	Flag indicating that classifier has been enabled */
+	addr_t             cbus_base_va;   /*	CBUS base virtual address */
+	uint32_t           pe_num;         /*	Number of PEs */
+	pfe_pe_t **        pe;             /*	List of particular PEs */
+	blalloc_t *        heap_context;   /* Heap manager context */
+	uint32_t           dmem_heap_base; /* DMEM base address of the heap */
+	oal_mutex_t        mutex;
+	uint32_t           current_feature;   /* Index of the feature to return by pfe_class_get_feature_next() */
+	pfe_fw_feature_t **fw_features;       /* List of all features*/
+	uint32_t           fw_features_count; /* Number of items in fw_features */
 };
 
-static errno_t pfe_class_dmem_heap_init(pfe_class_t *class);
-static errno_t pfe_class_load_fw_features(pfe_class_t *class);
-static void pfe_class_alg_stats_endian(pfe_ct_class_algo_stats_t *stat);
-static void pfe_class_ihc_stats_endian(pfe_ct_class_ihc_stats_t *stat);
-static void pfe_class_pe_stats_endian(pfe_ct_pe_stats_t *stat);
-static void pfe_class_sum_pe_algo_stats(pfe_ct_class_algo_stats_t *sum, const pfe_ct_class_algo_stats_t *val);
-static void pfe_class_sum_pe_ihc_stats(pfe_ct_class_ihc_stats_t *sum, const pfe_ct_class_ihc_stats_t *val);
+static errno_t  pfe_class_dmem_heap_init(pfe_class_t *class);
+static errno_t  pfe_class_load_fw_features(pfe_class_t *class);
+static void     pfe_class_alg_stats_endian(pfe_ct_class_algo_stats_t *stat);
+static void     pfe_class_ihc_stats_endian(pfe_ct_class_ihc_stats_t *stat);
+static void     pfe_class_pe_stats_endian(pfe_ct_pe_stats_t *stat);
+static void     pfe_class_sum_pe_algo_stats(pfe_ct_class_algo_stats_t *sum, const pfe_ct_class_algo_stats_t *val);
+static void     pfe_class_sum_pe_ihc_stats(pfe_ct_class_ihc_stats_t *sum, const pfe_ct_class_ihc_stats_t *val);
 static uint32_t pfe_class_stat_to_str(const pfe_ct_class_algo_stats_t *stat, char *buf, uint32_t buf_len, uint8_t verb_level);
 
 /**
@@ -61,63 +60,66 @@ static uint32_t pfe_class_stat_to_str(const pfe_ct_class_algo_stats_t *stat, cha
 errno_t pfe_class_isr(const pfe_class_t *class)
 {
 	uint32_t i;
+	errno_t  ret;
 #ifdef PFE_CFG_FCI_ENABLE
 	pfe_ct_buffer_t buf;
-	fci_msg_t msg;
-	errno_t ret;
+	fci_msg_t       msg;
 #endif /* PFE_CFG_FCI_ENABLE */
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (NULL == class)
 	{
 		NXP_LOG_ERROR("NULL argument\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	for (i=0U; i<class->pe_num; i++)
 	{
-		/*	Allow safe use of _nolock() functions. We don't call the _mem_lock()
-			here as we don't need to have coherent accesses. */
-		if (EOK != pfe_pe_lock(class->pe[i]))
+		for (i = 0U; i < class->pe_num; i++)
 		{
-			NXP_LOG_DEBUG("pfe_pe_lock() failed\n");
-		}
+			/*	Allow safe use of _nolock() functions. We don't call the _mem_lock()
+				here as we don't need to have coherent accesses. */
+			if (EOK != pfe_pe_lock(class->pe[i]))
+			{
+				NXP_LOG_DEBUG("pfe_pe_lock() failed\n");
+			}
 
-		/*	Read and print the error record from each PE */
-		(void)pfe_pe_get_fw_messages_nolock(class->pe[i]);
+			/*	Read and print the error record from each PE */
+			(void)pfe_pe_get_fw_messages_nolock(class->pe[i]);
 
 #ifdef PFE_CFG_FCI_ENABLE
-		/*	Check if there is new message */
-		if (EOK == pfe_pe_get_data_nolock(class->pe[i], &buf))
-		{
-			/*	Provide data to user via FCI */
-			msg.msg_cmd.code = FPP_CMD_DATA_BUF_AVAIL;
-			msg.msg_cmd.length = buf.len;
-
-			if (msg.msg_cmd.length > (uint32_t)sizeof(msg.msg_cmd.payload))
-			{
-				NXP_LOG_ERROR("FCI buffer is too small\n");
-			}
-			else
+			/*	Check if there is new message */
+			if (EOK == pfe_pe_get_data_nolock(class->pe[i], &buf))
 			{
-				(void)memcpy(&msg.msg_cmd.payload, buf.payload, buf.len);
-				ret = fci_core_client_send_broadcast(&msg, NULL);
-				if (EOK != ret)
+				/*	Provide data to user via FCI */
+				msg.msg_cmd.code   = FPP_CMD_DATA_BUF_AVAIL;
+				msg.msg_cmd.length = buf.len;
+
+				if (msg.msg_cmd.length > (uint32_t)sizeof(msg.msg_cmd.payload))
 				{
-					NXP_LOG_ERROR("Can't report data to FCI clients\n");
+					NXP_LOG_ERROR("FCI buffer is too small\n");
+				}
+				else
+				{
+					(void)memcpy(&msg.msg_cmd.payload, buf.payload, buf.len);
+					ret = fci_core_client_send_broadcast(&msg, NULL);
+					if (EOK != ret)
+					{
+						NXP_LOG_ERROR("Can't report data to FCI clients\n");
+					}
 				}
 			}
-		}
 #endif /* PFE_CFG_FCI_ENABLE */
 
-		if (EOK != pfe_pe_unlock(class->pe[i]))
-		{
-			NXP_LOG_DEBUG("pfe_pe_unlock() failed\n");
+			if (EOK != pfe_pe_unlock(class->pe[i]))
+			{
+				NXP_LOG_DEBUG("pfe_pe_unlock() failed\n");
+			}
 		}
+		ret = EOK;
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -140,6 +142,36 @@ void pfe_class_irq_unmask(const pfe_class_t *class)
 	(void)class;
 }
 
+/*
+ * @brief Load PTP related configuration to class cores
+ */
+static errno_t pfe_class_load_ptp_config(pfe_class_t *class)
+{
+	errno_t ret = EOK;
+	uint8_t common_hif;
+	uint32_t pe_idx;
+	addr_t dmem_addr;
+	pfe_ct_pe_mmap_t pfe_pe_mmap;
+
+if ((PFE_CFG_PTP_COMMON_HIF >= PFE_PHY_IF_ID_HIF0 && PFE_CFG_PTP_COMMON_HIF <= PFE_PHY_IF_ID_HIF3) ||
+	PFE_CFG_PTP_COMMON_HIF == PFE_PHY_IF_ID_HIF_NOCPY)
+	{
+		ret = pfe_pe_get_mmap(class->pe[0U], &pfe_pe_mmap);
+		if (EOK == ret)
+		{
+			/* Get the ptp_common_hif offset in DMEM */
+			dmem_addr = oal_ntohl(pfe_pe_mmap.class_pe.ptp_common_hif);
+			common_hif = (uint8_t)PFE_CFG_PTP_COMMON_HIF;				
+			for (pe_idx = 0U; pe_idx < class->pe_num; ++pe_idx)
+			{
+				pfe_pe_memcpy_from_host_to_dmem_32(class->pe[pe_idx], dmem_addr, &common_hif, sizeof(common_hif));
+			}
+		}
+	}
+
+	return ret;
+}
+
 /**
  * @brief		Create new classifier instance
  * @param[in]	cbus_base_va CBUS base virtual address
@@ -151,85 +183,86 @@ pfe_class_t *pfe_class_create(addr_t cbus_base_va, uint32_t pe_num, const pfe_cl
 {
 	pfe_class_t *class;
 	pfe_pe_t *pe;
-	uint32_t ii;
+	uint32_t  ii;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL_ADDR == cbus_base_va) || (NULL == cfg)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return NULL;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	class = oal_mm_malloc(sizeof(pfe_class_t));
-
-	if (NULL == class)
-	{
-		return NULL;
+		class = NULL;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		(void)memset(class, 0, sizeof(pfe_class_t));
-		class->cbus_base_va = cbus_base_va;
-	}
-
-	if (EOK != oal_mutex_init(&class->mutex))
-	{
-		oal_mm_free(class);
-		return NULL;
-	}
-
-	if (pe_num > 0U)
-	{
-		class->pe = oal_mm_malloc(pe_num * sizeof(pfe_pe_t *));
+		class = oal_mm_malloc(sizeof(pfe_class_t));
 
-		if (NULL == class->pe)
+		if (NULL != class)
 		{
-			(void)oal_mutex_destroy(&class->mutex);
-			oal_mm_free(class);
-			return NULL;
-		}
+			(void)memset(class, 0, sizeof(pfe_class_t));
+			class->cbus_base_va = cbus_base_va;
 
-		/*	Create PEs */
-		for (ii=0U; ii<pe_num; ii++)
-		{
-			pe = pfe_pe_create(cbus_base_va, PE_TYPE_CLASS, (uint8_t)ii);
-
-			if (NULL == pe)
+			if (EOK != oal_mutex_init(&class->mutex))
 			{
-				goto free_and_fail;
+				oal_mm_free(class);
+				class = NULL;
 			}
 			else
 			{
-				pfe_pe_set_iaccess(pe, CLASS_MEM_ACCESS_WDATA, CLASS_MEM_ACCESS_RDATA, CLASS_MEM_ACCESS_ADDR);
-				pfe_pe_set_dmem(pe, PFE_CFG_CLASS_ELF_DMEM_BASE, PFE_CFG_CLASS_DMEM_SIZE);
-				pfe_pe_set_imem(pe, PFE_CFG_CLASS_ELF_IMEM_BASE, PFE_CFG_CLASS_IMEM_SIZE);
-				pfe_pe_set_lmem(pe, (PFE_CFG_CBUS_PHYS_BASE_ADDR + PFE_CFG_PE_LMEM_BASE), PFE_CFG_PE_LMEM_SIZE);
-				class->pe[ii] = pe;
-				class->pe_num++;
+				if (pe_num > 0U)
+				{
+					class->pe = oal_mm_malloc(pe_num * sizeof(pfe_pe_t *));
+
+					if (NULL == class->pe)
+					{
+						(void)oal_mutex_destroy(&class->mutex);
+						oal_mm_free(class);
+						class = NULL;
+					}
+					else
+					{
+						/*	Create PEs */
+						for (ii = 0U; ii < pe_num; ii++)
+						{
+							pe = pfe_pe_create(cbus_base_va, PE_TYPE_CLASS, (uint8_t)ii);
+
+							if (NULL == pe)
+							{
+								pfe_class_destroy(class);
+								class = NULL;
+								break;
+							}
+							else
+							{
+								pfe_pe_set_iaccess(pe, CLASS_MEM_ACCESS_WDATA, CLASS_MEM_ACCESS_RDATA, CLASS_MEM_ACCESS_ADDR);
+								pfe_pe_set_dmem(pe, PFE_CFG_CLASS_ELF_DMEM_BASE, PFE_CFG_CLASS_DMEM_SIZE);
+								pfe_pe_set_imem(pe, PFE_CFG_CLASS_ELF_IMEM_BASE, PFE_CFG_CLASS_IMEM_SIZE);
+								pfe_pe_set_lmem(pe, (PFE_CFG_CBUS_PHYS_BASE_ADDR + PFE_CFG_PE_LMEM_BASE), PFE_CFG_PE_LMEM_SIZE);
+								class->pe[ii] = pe;
+								class->pe_num++;
+							}
+						}
+
+						if (NULL != class)
+						{
+							/*	Issue block reset */
+							pfe_class_reset(class);
+
+							/* After soft reset, need to wait for 10us to perform another CSR write/read */
+							oal_time_usleep(10);
+
+							/*	Disable the classifier */
+							pfe_class_disable(class);
+
+							/*	Set new configuration */
+							pfe_class_cfg_set_config(class->cbus_base_va, cfg);
+						}
+					}
+				}
 			}
 		}
-
-		/*	Issue block reset */
-		pfe_class_reset(class);
-
-		/* After soft reset, need to wait for 10us to perform another CSR write/read */
-		oal_time_usleep(10);
-
-		/*	Disable the classifier */
-		pfe_class_disable(class);
-
-		/*	Set new configuration */
-		pfe_class_cfg_set_config(class->cbus_base_va, cfg);
 	}
 
 	return class;
-
-free_and_fail:
-	pfe_class_destroy(class);
-	class = NULL;
-
-	return NULL;
 }
 
 /**
@@ -239,14 +272,15 @@ free_and_fail:
 static errno_t pfe_class_dmem_heap_init(pfe_class_t *class)
 {
 	pfe_ct_pe_mmap_t mmap;
-	errno_t ret = EOK;
+	errno_t          ret;
 
 	ret = pfe_pe_get_mmap(class->pe[0U], &mmap);
-	if(EOK == ret)
+
+	if (EOK == ret)
 	{
 
 		class->heap_context = blalloc_create(oal_ntohl(mmap.class_pe.dmem_heap_size), PFE_CLASS_HEAP_CHUNK_SIZE);
-		if(NULL == class->heap_context)
+		if (NULL == class->heap_context)
 		{
 			ret = ENOMEM;
 		}
@@ -268,19 +302,22 @@ static errno_t pfe_class_dmem_heap_init(pfe_class_t *class)
  */
 addr_t pfe_class_dmem_heap_alloc(const pfe_class_t *class, uint32_t size)
 {
-	addr_t addr;
+	addr_t  addr;
 	errno_t ret;
 
 	ret = blalloc_alloc_offs(class->heap_context, size, 0, &addr);
-	if(EOK == ret)
+
+	if (EOK == ret)
 	{
-		return addr + class->dmem_heap_base;
+		addr = addr + class->dmem_heap_base;
 	}
 	else
-	{   /* Allocation failed - return "NULL" */
+	{ /* Allocation failed - return "NULL" */
 		NXP_LOG_DEBUG("Failed to allocate memory (size %u)\n", (uint_t)size);
-		return 0U;
+		addr = 0U;
 	}
+
+	return addr;
 }
 
 /**
@@ -290,18 +327,17 @@ addr_t pfe_class_dmem_heap_alloc(const pfe_class_t *class, uint32_t size)
  */
 void pfe_class_dmem_heap_free(const pfe_class_t *class, addr_t addr)
 {
-	if(0U == addr)
-	{   /* Ignore "NULL" */
-		return;
+	if (0U == addr)
+	{ /* Ignore "NULL" */
 	}
-
-	if(addr < class->dmem_heap_base)
+	else if (addr < class->dmem_heap_base)
 	{
-		NXP_LOG_ERROR("Impossible address 0x%"PRINTADDR_T" (base is 0x%x)\n", addr, (uint_t)class->dmem_heap_base);
-		return;
+		NXP_LOG_ERROR("Impossible address 0x%" PRINTADDR_T " (base is 0x%x)\n", addr, (uint_t) class->dmem_heap_base);
+	}
+	else
+	{
+		blalloc_free_offs(class->heap_context, addr - class->dmem_heap_base);
 	}
-
-	blalloc_free_offs(class->heap_context, addr - class->dmem_heap_base);
 }
 
 /**
@@ -314,23 +350,24 @@ void pfe_class_reset(pfe_class_t *class)
 	if (unlikely(NULL == class))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	pfe_class_disable(class);
-
-	if (EOK != oal_mutex_lock(&class->mutex))
 	{
-		NXP_LOG_DEBUG("mutex lock failed\n");
-	}
+		pfe_class_disable(class);
+
+		if (EOK != oal_mutex_lock(&class->mutex))
+		{
+			NXP_LOG_DEBUG("mutex lock failed\n");
+		}
 
-	pfe_class_cfg_reset(class->cbus_base_va);
-	class->enabled = FALSE;
+		pfe_class_cfg_reset(class->cbus_base_va);
+		class->enabled = FALSE;
 
-	if (EOK != oal_mutex_unlock(&class->mutex))
-	{
-		NXP_LOG_DEBUG("mutex unlock failed\n");
+		if (EOK != oal_mutex_unlock(&class->mutex))
+		{
+			NXP_LOG_DEBUG("mutex unlock failed\n");
+		}
 	}
 }
 
@@ -341,49 +378,49 @@ void pfe_class_reset(pfe_class_t *class)
  */
 void pfe_class_enable(pfe_class_t *class)
 {
-	uint16_t timeout = 50U;
+	uint16_t             timeout = 50U;
 	pfe_ct_pe_sw_state_t state;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == class))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (unlikely(FALSE == class->is_fw_loaded))
 	{
-		NXP_LOG_WARNING("Attempt to enable classifier without previous firmware upload\n");
-	}
+		if (unlikely(FALSE == class->is_fw_loaded))
+		{
+			NXP_LOG_WARNING("Attempt to enable classifier without previous firmware upload\n");
+		}
 
-	if (EOK != oal_mutex_lock(&class->mutex))
-	{
-		NXP_LOG_DEBUG("mutex lock failed\n");
-	}
+		if (EOK != oal_mutex_lock(&class->mutex))
+		{
+			NXP_LOG_DEBUG("mutex lock failed\n");
+		}
 
-	pfe_class_cfg_enable(class->cbus_base_va);
+		pfe_class_cfg_enable(class->cbus_base_va);
 
-	do
-	{
-		oal_time_usleep(5U);
-		timeout--;
-		state = pfe_pe_get_fw_state(class->pe[0U]);
-	}
-	while ((state < PFE_FW_STATE_INIT) && (timeout > 0U));
+		do
+		{
+			oal_time_usleep(5U);
+			timeout--;
+			state = pfe_pe_get_fw_state(class->pe[0U]);
+		} while ((state < PFE_FW_STATE_INIT) && (timeout > 0U));
 
-	if (timeout == 0U)
-	{
-		NXP_LOG_ERROR("Time-out waiting for classifier to init\n");
-	}
-	else
-	{
-		class->enabled = TRUE;
-	}
+		if (timeout == 0U)
+		{
+			NXP_LOG_ERROR("Time-out waiting for classifier to init\n");
+		}
+		else
+		{
+			class->enabled = TRUE;
+		}
 
-	if (EOK != oal_mutex_unlock(&class->mutex))
-	{
-		NXP_LOG_DEBUG("mutex unlock failed\n");
+		if (EOK != oal_mutex_unlock(&class->mutex))
+		{
+			NXP_LOG_DEBUG("mutex unlock failed\n");
+		}
 	}
 }
 
@@ -398,20 +435,21 @@ void pfe_class_disable(pfe_class_t *class)
 	if (unlikely(NULL == class))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (EOK != oal_mutex_lock(&class->mutex))
 	{
-		NXP_LOG_DEBUG("mutex lock failed\n");
-	}
+		if (EOK != oal_mutex_lock(&class->mutex))
+		{
+			NXP_LOG_DEBUG("mutex lock failed\n");
+		}
 
-	pfe_class_cfg_disable(class->cbus_base_va);
+		pfe_class_cfg_disable(class->cbus_base_va);
 
-	if (EOK != oal_mutex_unlock(&class->mutex))
-	{
-		NXP_LOG_DEBUG("mutex unlock failed\n");
+		if (EOK != oal_mutex_unlock(&class->mutex))
+		{
+			NXP_LOG_DEBUG("mutex unlock failed\n");
+		}
 	}
 }
 
@@ -429,50 +467,59 @@ errno_t pfe_class_load_firmware(pfe_class_t *class, const void *elf)
 	if (unlikely((NULL == class) || (NULL == elf)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (EOK != oal_mutex_lock(&class->mutex))
-	{
-		NXP_LOG_DEBUG("mutex lock failed\n");
-	}
-
-	ret = pfe_pe_load_firmware(class->pe, class->pe_num, elf);
-	if (EOK != ret)
-	{
-		NXP_LOG_ERROR("Classifier firmware loading the PE failed: %d\n", ret);
-	}
-
-	if (EOK == ret)
 	{
-		class->is_fw_loaded = TRUE;
+		if (EOK != oal_mutex_lock(&class->mutex))
+		{
+			NXP_LOG_DEBUG("mutex lock failed\n");
+		}
 
-		/* Check the memory map whether it is correct */
-		/* All PEs have the same map therefore it is sufficient to check one */
-		ret = pfe_pe_check_mmap(class->pe[0U]);
+		ret = pfe_pe_load_firmware(class->pe, class->pe_num, elf);
+		if (EOK != ret)
+		{
+			NXP_LOG_ERROR("Classifier firmware loading the PE failed: %d\n", ret);
+		}
 
 		if (EOK == ret)
 		{
-			/* Firmware has been loaded and the DMEM heap is known - initialize the allocator */
-			ret = pfe_class_dmem_heap_init(class);
+			class->is_fw_loaded = TRUE;
+
+			/* Check the memory map whether it is correct */
+			/* All PEs have the same map therefore it is sufficient to check one */
+			ret = pfe_pe_check_mmap(class->pe[0U]);
+
+			if (EOK == ret)
+			{
+				/* Firmware has been loaded and the DMEM heap is known - initialize the allocator */
+				ret = pfe_class_dmem_heap_init(class);
+				if (EOK != ret)
+				{
+					NXP_LOG_ERROR("Dmem heap allocator initialization failed\n");
+				}
+			}
+
+			ret = pfe_class_load_fw_features(class);
 			if (EOK != ret)
 			{
-				NXP_LOG_ERROR("Dmem heap allocator initialization failed\n");
+				NXP_LOG_ERROR("Failed to initialize FW features\n");
+			}
+			else 
+			{
+				ret = pfe_class_load_ptp_config(class);
+				if(EOK != ret)
+				{
+					NXP_LOG_ERROR("Failed to set PTP common HIF\n");
+				}
 			}
 		}
 
-        ret = pfe_class_load_fw_features(class);
-        if(EOK != ret)
-        {
-            NXP_LOG_ERROR("Failed to initialize FW features\n");
-        }
-
-	}
-
-	if (EOK != oal_mutex_unlock(&class->mutex))
-	{
-		NXP_LOG_DEBUG("mutex unlock failed\n");
+		if (EOK != oal_mutex_unlock(&class->mutex))
+		{
+			NXP_LOG_DEBUG("mutex unlock failed\n");
+		}
 	}
 
 	return ret;
@@ -480,103 +527,103 @@ errno_t pfe_class_load_firmware(pfe_class_t *class, const void *elf)
 
 static errno_t pfe_class_load_fw_features(pfe_class_t *class)
 {
-	pfe_ct_pe_mmap_t mmap;
-	errno_t ret = EOK;
+	pfe_ct_pe_mmap_t       mmap;
+	errno_t                ret;
 	pfe_ct_feature_desc_t *entry;
-	uint32_t i, j;
-	bool_t val_break = FALSE;
+	uint32_t               i, j;
+	bool_t                 val_break = FALSE;
 
 	ret = pfe_pe_get_mmap(class->pe[0U], &mmap);
-	if(EOK == ret)
+	if (EOK == ret)
 	{
-        class->fw_features_count = oal_ntohl(mmap.common.version.features_count);
-        class->fw_features = NULL;
-        if(class->fw_features_count > 0U)
-        {
-            class->fw_features = oal_mm_malloc(class->fw_features_count * sizeof(pfe_fw_feature_t *));
-            if(NULL == class->fw_features)
-            {
-                class->fw_features_count = 0U;
-                NXP_LOG_ERROR("Failed to allocate features storage\n");
-                ret = ENOMEM;
-            }
-            else
-            {
-                /* Initialize current_feature */
-                class->current_feature = 0U;
-                for(i = 0U; i < class->fw_features_count; i++)
-                {
-                    class->fw_features[i] = pfe_fw_feature_create();
-                    if(NULL == class->fw_features[i])
-                    {
-                        NXP_LOG_ERROR("Failed to create feature %u\n", (uint_t)i);
-                        /* Destroy previously created and return failure */
-                        for(j = 0U; j < i; j++)
-                        {
-                            pfe_fw_feature_destroy(class->fw_features[j]);
-                            class->fw_features[j] = NULL;
-                        }
-                        oal_mm_free(class->fw_features);
-                        class->fw_features = NULL;
-                        class->fw_features_count = 0U;
-                        ret = ENOMEM;
-                        val_break = TRUE;
-                    }
-                    else
-                    {
-                        /* Get feature low level data */
-                        ret = pfe_pe_get_fw_feature_entry(class->pe[0U], i, &entry);
-                        if(EOK != ret)
-                        {
-                             NXP_LOG_ERROR("Failed get ll data for feature %u\n", (uint_t)i);
-                            /* Destroy previously created and return failure */
-                            for(j = 0U; j < i; j++)
-                            {
-                                pfe_fw_feature_destroy(class->fw_features[j]);
-                                class->fw_features[j] = NULL;
-                            }
-                            oal_mm_free(class->fw_features);
-                            class->fw_features = NULL;
-                            class->fw_features_count = 0U;
-                            ret = EINVAL;
-                            val_break = TRUE;
-                        }
-                        else
-                        {
-                            /* Set the low level data in the feature */
-                            (void)pfe_fw_feature_set_ll_data(class->fw_features[i], entry);
-                            /* Set the feature string base */
-                            ret = pfe_fw_feature_set_string_base(class->fw_features[i], pfe_pe_get_fw_feature_str_base(class->pe[0U]));
-                            if(EOK != ret)
-                            {
-                                NXP_LOG_ERROR("Failed to set string base for feature %u\n", (uint_t)i);
-                                /* Destroy previously created and return failure */
-                                for(j = 0U; j < i; j++)
-                                {
-                                    pfe_fw_feature_destroy(class->fw_features[j]);
-                                    class->fw_features[j] = NULL;
-                                }
-                                oal_mm_free(class->fw_features);
-                                class->fw_features = NULL;
-                                class->fw_features_count = 0U;
-                                ret = EINVAL;
-                                val_break = TRUE;
-                            }
-                            else
-                            {
-                                /* Set functions to read/write DMEM and their data */
-                                (void)pfe_fw_feature_set_dmem_funcs(class->fw_features[i], pfe_class_read_dmem, pfe_class_write_dmem, (void *)class);
-                            }
-                        }
-                    }
-                    if (TRUE == val_break)
-                    {
-                        break;
-                    }
-                }
-            }
-        } /* Else is OK too */
-    }
+		class->fw_features_count = oal_ntohl(mmap.common.version.features_count);
+		class->fw_features       = NULL;
+		if (class->fw_features_count > 0U)
+		{
+			class->fw_features = oal_mm_malloc(class->fw_features_count * sizeof(pfe_fw_feature_t *));
+			if (NULL == class->fw_features)
+			{
+				class->fw_features_count = 0U;
+				NXP_LOG_ERROR("Failed to allocate features storage\n");
+				ret = ENOMEM;
+			}
+			else
+			{
+				/* Initialize current_feature */
+				class->current_feature = 0U;
+				for (i = 0U; i < class->fw_features_count; i++)
+				{
+					class->fw_features[i] = pfe_fw_feature_create();
+					if (NULL == class->fw_features[i])
+					{
+						NXP_LOG_ERROR("Failed to create feature %u\n", (uint_t)i);
+						/* Destroy previously created and return failure */
+						for (j = 0U; j < i; j++)
+						{
+							pfe_fw_feature_destroy(class->fw_features[j]);
+							class->fw_features[j] = NULL;
+						}
+						oal_mm_free(class->fw_features);
+						class->fw_features       = NULL;
+						class->fw_features_count = 0U;
+						ret                      = ENOMEM;
+						val_break                = TRUE;
+					}
+					else
+					{
+						/* Get feature low level data */
+						ret = pfe_pe_get_fw_feature_entry(class->pe[0U], i, &entry);
+						if (EOK != ret)
+						{
+							NXP_LOG_ERROR("Failed get ll data for feature %u\n", (uint_t)i);
+							/* Destroy previously created and return failure */
+							for (j = 0U; j < i; j++)
+							{
+								pfe_fw_feature_destroy(class->fw_features[j]);
+								class->fw_features[j] = NULL;
+							}
+							oal_mm_free(class->fw_features);
+							class->fw_features       = NULL;
+							class->fw_features_count = 0U;
+							ret                      = EINVAL;
+							val_break                = TRUE;
+						}
+						else
+						{
+							/* Set the low level data in the feature */
+							(void)pfe_fw_feature_set_ll_data(class->fw_features[i], entry);
+							/* Set the feature string base */
+							ret = pfe_fw_feature_set_string_base(class->fw_features[i], pfe_pe_get_fw_feature_str_base(class->pe[0U]));
+							if (EOK != ret)
+							{
+								NXP_LOG_ERROR("Failed to set string base for feature %u\n", (uint_t)i);
+								/* Destroy previously created and return failure */
+								for (j = 0U; j < i; j++)
+								{
+									pfe_fw_feature_destroy(class->fw_features[j]);
+									class->fw_features[j] = NULL;
+								}
+								oal_mm_free(class->fw_features);
+								class->fw_features       = NULL;
+								class->fw_features_count = 0U;
+								ret                      = EINVAL;
+								val_break                = TRUE;
+							}
+							else
+							{
+								/* Set functions to read/write DMEM and their data */
+								(void)pfe_fw_feature_set_dmem_funcs(class->fw_features[i], pfe_class_read_dmem, pfe_class_write_dmem, (void *)class);
+							}
+						}
+					}
+					if (TRUE == val_break)
+					{
+						break;
+					}
+				}
+			}
+		} /* Else is OK too */
+	}
 	return ret;
 }
 
@@ -590,33 +637,37 @@ static errno_t pfe_class_load_fw_features(pfe_class_t *class)
  */
 errno_t pfe_class_get_mmap(pfe_class_t *class, int32_t pe_idx, pfe_ct_class_mmap_t *mmap)
 {
-	errno_t ret;
+	errno_t          ret;
 	pfe_ct_pe_mmap_t mmap_tmp;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == class) || (NULL == mmap)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (pe_idx >= (int32_t)class->pe_num)
-	{
-		return EINVAL;
-	}
-
-	if (EOK != oal_mutex_lock(&class->mutex))
 	{
-		NXP_LOG_DEBUG("mutex lock failed\n");
-	}
+		if (pe_idx >= (int32_t) class->pe_num)
+		{
+			ret = EINVAL;
+		}
+		else
+		{
+			if (EOK != oal_mutex_lock(&class->mutex))
+			{
+				NXP_LOG_DEBUG("mutex lock failed\n");
+			}
 
-	ret = pfe_pe_get_mmap(class->pe[pe_idx], &mmap_tmp);
-	(void)memcpy(mmap, &mmap_tmp.class_pe, sizeof(pfe_ct_class_mmap_t));
+			ret = pfe_pe_get_mmap(class->pe[pe_idx], &mmap_tmp);
+			(void)memcpy(mmap, &mmap_tmp.class_pe, sizeof(pfe_ct_class_mmap_t));
 
-	if (EOK != oal_mutex_unlock(&class->mutex))
-	{
-		NXP_LOG_DEBUG("mutex unlock failed\n");
+			if (EOK != oal_mutex_unlock(&class->mutex))
+			{
+				NXP_LOG_DEBUG("mutex unlock failed\n");
+			}
+		}
 	}
 
 	return ret;
@@ -635,45 +686,52 @@ errno_t pfe_class_write_dmem(void *class_p, int32_t pe_idx, addr_t dst_addr, con
 {
 	uint32_t ii;
 	pfe_class_t *class = (pfe_class_t *)class_p;
+	errno_t ret;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == class))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (pe_idx >= (int32_t)class->pe_num)
-	{
-		return EINVAL;
-	}
-
-	if (EOK != oal_mutex_lock(&class->mutex))
-	{
-		NXP_LOG_DEBUG("mutex lock failed\n");
-	}
-
-	if (pe_idx >= 0)
-	{
-		/*	Single PE */
-		pfe_pe_memcpy_from_host_to_dmem_32(class->pe[pe_idx], dst_addr, src_ptr, len);
+		ret = EINVAL;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		/*	All PEs */
-		for (ii=0U; ii<class->pe_num; ii++)
+		if (pe_idx >= (int32_t) class->pe_num)
 		{
-			pfe_pe_memcpy_from_host_to_dmem_32(class->pe[ii], dst_addr, src_ptr, len);
+			ret = EINVAL;
 		}
-	}
+		else
+		{
+			if (EOK != oal_mutex_lock(&class->mutex))
+			{
+				NXP_LOG_DEBUG("mutex lock failed\n");
+			}
 
-	if (EOK != oal_mutex_unlock(&class->mutex))
-	{
-		NXP_LOG_DEBUG("mutex unlock failed\n");
+			if (pe_idx >= 0)
+			{
+				/*	Single PE */
+				pfe_pe_memcpy_from_host_to_dmem_32(class->pe[pe_idx], dst_addr, src_ptr, len);
+			}
+			else
+			{
+				/*	All PEs */
+				for (ii = 0U; ii < class->pe_num; ii++)
+				{
+					pfe_pe_memcpy_from_host_to_dmem_32(class->pe[ii], dst_addr, src_ptr, len);
+				}
+			}
+
+			if (EOK != oal_mutex_unlock(&class->mutex))
+			{
+				NXP_LOG_DEBUG("mutex unlock failed\n");
+			}
+
+			ret = EOK;
+		}
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -688,32 +746,38 @@ errno_t pfe_class_write_dmem(void *class_p, int32_t pe_idx, addr_t dst_addr, con
 errno_t pfe_class_read_dmem(void *class_p, int32_t pe_idx, void *dst_ptr, addr_t src_addr, uint32_t len)
 {
 	pfe_class_t *class = (pfe_class_t *)class_p;
+	errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == class) || (NULL == dst_ptr)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (pe_idx >= (int32_t)class->pe_num)
 	{
-		return EINVAL;
-	}
-
-	if (EOK != oal_mutex_lock(&class->mutex))
-	{
-		NXP_LOG_DEBUG("mutex lock failed\n");
-	}
+		if (pe_idx >= (int32_t) class->pe_num)
+		{
+			ret = EINVAL;
+		}
+		else
+		{
+			if (EOK != oal_mutex_lock(&class->mutex))
+			{
+				NXP_LOG_DEBUG("mutex lock failed\n");
+			}
 
-	pfe_pe_memcpy_from_dmem_to_host_32(class->pe[pe_idx], dst_ptr, src_addr, len);
+			pfe_pe_memcpy_from_dmem_to_host_32(class->pe[pe_idx], dst_ptr, src_addr, len);
 
-	if (EOK != oal_mutex_unlock(&class->mutex))
-	{
-		NXP_LOG_DEBUG("mutex unlock failed\n");
+			if (EOK != oal_mutex_unlock(&class->mutex))
+			{
+				NXP_LOG_DEBUG("mutex unlock failed\n");
+			}
+			ret = EOK;
+		}
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -727,25 +791,27 @@ errno_t pfe_class_read_dmem(void *class_p, int32_t pe_idx, void *dst_ptr, addr_t
  */
 errno_t pfe_class_gather_read_dmem(pfe_class_t *class, void *dst_ptr, addr_t src_addr, uint32_t buffer_len, uint32_t read_len)
 {
-	errno_t ret = EOK;
+	errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == class) || (NULL == dst_ptr)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (EOK != oal_mutex_lock(&class->mutex))
 	{
-		NXP_LOG_DEBUG("mutex lock failed\n");
-	}
+		if (EOK != oal_mutex_lock(&class->mutex))
+		{
+			NXP_LOG_DEBUG("mutex lock failed\n");
+		}
 
-	ret = pfe_pe_gather_memcpy_from_dmem_to_host_32(class->pe, (int32_t)class->pe_num, dst_ptr, (addr_t)src_addr, buffer_len, read_len);
+		ret = pfe_pe_gather_memcpy_from_dmem_to_host_32(class->pe, (int32_t) class->pe_num, dst_ptr, (addr_t)src_addr, buffer_len, read_len);
 
-	if (EOK != oal_mutex_unlock(&class->mutex))
-	{
-		NXP_LOG_DEBUG("mutex unlock failed\n");
+		if (EOK != oal_mutex_unlock(&class->mutex))
+		{
+			NXP_LOG_DEBUG("mutex unlock failed\n");
+		}
 	}
 
 	return ret;
@@ -770,18 +836,18 @@ void pfe_class_destroy(pfe_class_t *class)
 			oal_mm_free(class->pe);
 		}
 
-		if(NULL != class->fw_features)
+		if (NULL != class->fw_features)
 		{
-			for(ii = 0U; ii < class->fw_features_count; ii++)
+			for (ii = 0U; ii < class->fw_features_count; ii++)
 			{
-				if(NULL != class->fw_features[ii])
+				if (NULL != class->fw_features[ii])
 				{
 					pfe_fw_feature_destroy(class->fw_features[ii]);
 					class->fw_features[ii] = NULL;
 				}
 			}
 			oal_mm_free(class->fw_features);
-			class->fw_features = NULL;
+			class->fw_features       = NULL;
 			class->fw_features_count = 0U;
 		}
 
@@ -812,31 +878,33 @@ void pfe_class_destroy(pfe_class_t *class)
  */
 errno_t pfe_class_set_rtable(pfe_class_t *class, addr_t rtable_pa, uint32_t rtable_len, uint32_t entry_size)
 {
-	errno_t ret = EOK;
+	errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == class) || (NULL_ADDR == rtable_pa)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (class->enabled)
-	{
-		return EBUSY;
+		ret = EINVAL;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		if (EOK != oal_mutex_lock(&class->mutex))
+		if (class->enabled)
 		{
-			NXP_LOG_ERROR("mutex lock failed\n");
+			ret = EBUSY;
 		}
+		else
+		{
+			if (EOK != oal_mutex_lock(&class->mutex))
+			{
+				NXP_LOG_ERROR("mutex lock failed\n");
+			}
 
-		ret = pfe_class_cfg_set_rtable(class->cbus_base_va, rtable_pa, rtable_len, entry_size);
+			ret = pfe_class_cfg_set_rtable(class->cbus_base_va, rtable_pa, rtable_len, entry_size);
 
-		if (EOK != oal_mutex_unlock(&class->mutex))
-		{
-			NXP_LOG_ERROR("mutex unlock failed\n");
+			if (EOK != oal_mutex_unlock(&class->mutex))
+			{
+				NXP_LOG_ERROR("mutex unlock failed\n");
+			}
 		}
 	}
 
@@ -853,16 +921,20 @@ errno_t pfe_class_set_rtable(pfe_class_t *class, addr_t rtable_pa, uint32_t rtab
  */
 errno_t pfe_class_set_default_vlan(const pfe_class_t *class, uint16_t vlan)
 {
+	errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == class))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	pfe_class_cfg_set_def_vlan(class->cbus_base_va, vlan);
-	return EOK;
+	{
+		pfe_class_cfg_set_def_vlan(class->cbus_base_va, vlan);
+		ret = EOK;
+	}
+	return ret;
 }
 
 /**
@@ -873,15 +945,19 @@ errno_t pfe_class_set_default_vlan(const pfe_class_t *class, uint16_t vlan)
 
 uint32_t pfe_class_get_num_of_pes(const pfe_class_t *class)
 {
+	uint32_t pe_num;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == class))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return 0U;
+		pe_num = 0U;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	return class->pe_num;
+	{
+		pe_num = class->pe_num;
+	}
+	return pe_num;
 }
 
 /**
@@ -893,29 +969,35 @@ uint32_t pfe_class_get_num_of_pes(const pfe_class_t *class)
  */
 errno_t pfe_class_get_feature(const pfe_class_t *class, pfe_fw_feature_t **feature, const char *name)
 {
-    uint32_t i;
-    const char *fname;
-    errno_t ret;
+	uint32_t    i;
+	const char *fname;
+	errno_t     ret = ENOENT;
+	errno_t     ret_val = EOK;
+
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely((NULL == class)||(NULL == feature)||(NULL == name)))
+	if (unlikely((NULL == class) || (NULL == feature) || (NULL == name)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-	for(i = 0U; i < class->fw_features_count; i++)
 	{
-		ret = pfe_fw_feature_get_name(class->fw_features[i], &fname);
-		if(ret == EOK)
+		for (i = 0U; i < class->fw_features_count; i++)
 		{
-			if(0 == strcmp(fname, name))
+			ret_val = pfe_fw_feature_get_name(class->fw_features[i], &fname);
+			if (EOK == ret_val)
 			{
-				*feature = class->fw_features[i];
-				return EOK;
+				if (0 == strcmp(fname, name))
+				{
+					*feature = class->fw_features[i];
+					ret = EOK;
+					break;
+				}
 			}
 		}
 	}
-	return ENOENT;
+	return ret;
 }
 
 /**
@@ -926,21 +1008,29 @@ errno_t pfe_class_get_feature(const pfe_class_t *class, pfe_fw_feature_t **featu
  */
 errno_t pfe_class_get_feature_first(pfe_class_t *class, pfe_fw_feature_t **feature)
 {
- #if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely((NULL == class)||(NULL == feature)))
+	errno_t ret;
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (unlikely((NULL == class) || (NULL == feature)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-	if(class->fw_features_count > 0U)
 	{
-		class->current_feature = 0U;
-		*feature = class->fw_features[class->current_feature];
-		return EOK;
+		if (class->fw_features_count > 0U)
+		{
+			class->current_feature = 0U;
+			*feature = class->fw_features[class->current_feature];
+			ret = EOK;
+		}
+		else
+		{
+			ret = ENOENT;
+		}
 	}
 
-	return ENOENT;
+	return ret;
 }
 
 /**
@@ -951,28 +1041,31 @@ errno_t pfe_class_get_feature_first(pfe_class_t *class, pfe_fw_feature_t **featu
  */
 errno_t pfe_class_get_feature_next(pfe_class_t *class, pfe_fw_feature_t **feature)
 {
- #if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely((NULL == class)||(NULL == feature)))
+	errno_t ret = ENOENT;
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (unlikely((NULL == class) || (NULL == feature)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-	if(class->fw_features_count > 0U)
 	{
-		/* Avoid going out of the array boundaries */
-		if((class->current_feature + 1U) < class->fw_features_count)
+		if (class->fw_features_count > 0U)
 		{
-			class->current_feature += 1U;
-			*feature = class->fw_features[class->current_feature];
-			return EOK;
+			/* Avoid going out of the array boundaries */
+			if ((class->current_feature + 1U) < class->fw_features_count)
+			{
+				class->current_feature += 1U;
+				*feature = class->fw_features[class->current_feature];
+				ret = EOK;
+			}
 		}
 	}
 
-	return ENOENT;
+	return ret;
 }
 
-
 /**
 * @brief Converts endiannes of the whole structure containing statistics
 * @param[in,out] stat Statistics which endiannes shall be converted
@@ -983,13 +1076,15 @@ static void pfe_class_alg_stats_endian(pfe_ct_class_algo_stats_t *stat)
 	if (unlikely(NULL == stat))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif
-	stat->processed = oal_ntohl(stat->processed);
-	stat->accepted = oal_ntohl(stat->accepted);
-	stat->rejected = oal_ntohl(stat->rejected);
-	stat->discarded = oal_ntohl(stat->discarded);
+	{
+		stat->processed = oal_ntohl(stat->processed);
+		stat->accepted  = oal_ntohl(stat->accepted);
+		stat->rejected  = oal_ntohl(stat->rejected);
+		stat->discarded = oal_ntohl(stat->discarded);
+	}
 }
 
 /**
@@ -999,29 +1094,32 @@ static void pfe_class_alg_stats_endian(pfe_ct_class_algo_stats_t *stat)
 static void pfe_class_ihc_stats_endian(pfe_ct_class_ihc_stats_t *stat)
 {
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-        if (unlikely(NULL == stat))
-        {
-                NXP_LOG_ERROR("NULL argument received\n");
-                return;
-        }
+	if (unlikely(NULL == stat))
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+	}
+	else
 #endif
-        stat->rx = oal_ntohl(stat->rx);
-        stat->tx = oal_ntohl(stat->tx);
-        stat->discarded = oal_ntohl(stat->discarded);
+	{
+		stat->rx        = oal_ntohl(stat->rx);
+		stat->tx        = oal_ntohl(stat->tx);
+		stat->discarded = oal_ntohl(stat->discarded);
+	}
 }
 
-
 void pfe_class_flexi_parser_stats_endian(pfe_ct_class_flexi_parser_stats_t *stats)
 {
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == stats))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif
-	stats->accepted = oal_ntohl(stats->accepted);
-	stats->rejected = oal_ntohl(stats->rejected);
+	{
+		stats->accepted = oal_ntohl(stats->accepted);
+		stats->rejected = oal_ntohl(stats->rejected);
+	}
 }
 
 void pfe_class_sum_flexi_parser_stats(pfe_ct_class_flexi_parser_stats_t *sum, const pfe_ct_class_flexi_parser_stats_t *val)
@@ -1030,11 +1128,13 @@ void pfe_class_sum_flexi_parser_stats(pfe_ct_class_flexi_parser_stats_t *sum, co
 	if (unlikely((NULL == sum) || (NULL == val)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif
-	sum->accepted += val->accepted;
-	sum->rejected += val->rejected;
+	{
+		sum->accepted += val->accepted;
+		sum->rejected += val->rejected;
+	}
 }
 
 /**
@@ -1048,15 +1148,17 @@ static void pfe_class_pe_stats_endian(pfe_ct_pe_stats_t *stat)
 	if (unlikely(NULL == stat))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif
-	stat->processed = oal_ntohl(stat->processed);
-	stat->discarded = oal_ntohl(stat->discarded);
-	stat->injected = oal_ntohl(stat->injected);
-	for(i = 0U; i < ((uint32_t)PFE_PHY_IF_ID_MAX + 1U); i++)
 	{
-		stat->replicas[i] = oal_ntohl(stat->replicas[i]);
+		stat->processed = oal_ntohl(stat->processed);
+		stat->discarded = oal_ntohl(stat->discarded);
+		stat->injected  = oal_ntohl(stat->injected);
+		for (i = 0U; i < ((uint32_t)PFE_PHY_IF_ID_MAX + 1U); i++)
+		{
+			stat->replicas[i] = oal_ntohl(stat->replicas[i]);
+		}
 	}
 }
 
@@ -1071,13 +1173,15 @@ static void pfe_class_sum_pe_algo_stats(pfe_ct_class_algo_stats_t *sum, const pf
 	if (unlikely((NULL == sum) || (NULL == val)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif
-	sum->processed += val->processed;
-	sum->accepted += val->accepted;
-	sum->rejected += val->rejected;
-	sum->discarded += val->discarded;
+	{
+		sum->processed += val->processed;
+		sum->accepted += val->accepted;
+		sum->rejected += val->rejected;
+		sum->discarded += val->discarded;
+	}
 }
 
 /**
@@ -1088,15 +1192,17 @@ static void pfe_class_sum_pe_algo_stats(pfe_ct_class_algo_stats_t *sum, const pf
 static void pfe_class_sum_pe_ihc_stats(pfe_ct_class_ihc_stats_t *sum, const pfe_ct_class_ihc_stats_t *val)
 {
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-        if (unlikely((NULL == sum) || (NULL == val)))
-        {
-                NXP_LOG_ERROR("NULL argument received\n");
-                return;
-        }
+	if (unlikely((NULL == sum) || (NULL == val)))
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+	}
+	else
 #endif
-        sum->rx += val->rx;
-        sum->tx += val->tx;
-        sum->discarded += val->discarded;
+	{
+		sum->rx += val->rx;
+		sum->tx += val->tx;
+		sum->discarded += val->discarded;
+	}
 }
 
 /**
@@ -1116,13 +1222,16 @@ static uint32_t pfe_class_stat_to_str(const pfe_ct_class_algo_stats_t *stat, cha
 	if (unlikely((NULL == stat) || (NULL == buf)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return 0U;
+		len = 0U;
 	}
+	else
 #endif
-	len += oal_util_snprintf(buf + len, buf_len - len, "Frames processed: %u\n", stat->processed);
-	len += oal_util_snprintf(buf + len, buf_len - len, "Frames accepted:  %u\n", stat->accepted);
-	len += oal_util_snprintf(buf + len, buf_len - len, "Frames rejected:  %u\n", stat->rejected);
-	len += oal_util_snprintf(buf + len, buf_len - len, "Frames discarded: %u\n", stat->discarded);
+	{
+		len += oal_util_snprintf(buf + len, buf_len - len, "Frames processed: %u\n", stat->processed);
+		len += oal_util_snprintf(buf + len, buf_len - len, "Frames accepted:  %u\n", stat->accepted);
+		len += oal_util_snprintf(buf + len, buf_len - len, "Frames rejected:  %u\n", stat->rejected);
+		len += oal_util_snprintf(buf + len, buf_len - len, "Frames discarded: %u\n", stat->discarded);
+	}
 	return len;
 }
 
@@ -1143,12 +1252,15 @@ static uint32_t pfe_class_ihc_stat_to_str(const pfe_ct_class_ihc_stats_t *stat,
 	if (unlikely((NULL == stat) || (NULL == buf)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return 0U;
+		len = 0U;
 	}
+	else
 #endif
-	len += oal_util_snprintf(buf + len, buf_len - len, "  Frames received:    %u\n", stat->rx);
-	len += oal_util_snprintf(buf + len, buf_len - len, "  Frames transmitted: %u\n", stat->tx);
-	len += oal_util_snprintf(buf + len, buf_len - len, "  Frames discarded:   %u\n", stat->discarded);
+	{
+		len += oal_util_snprintf(buf + len, buf_len - len, "  Frames received:    %u\n", stat->rx);
+		len += oal_util_snprintf(buf + len, buf_len - len, "  Frames transmitted: %u\n", stat->tx);
+		len += oal_util_snprintf(buf + len, buf_len - len, "  Frames discarded:   %u\n", stat->discarded);
+	}
 	return len;
 }
 
@@ -1169,11 +1281,14 @@ uint32_t pfe_class_fp_stat_to_str(const pfe_ct_class_flexi_parser_stats_t *stat,
 	if (unlikely((NULL == stat) || (NULL == buf)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return 0U;
+		len = 0U;
 	}
+	else
 #endif
-	len += oal_util_snprintf(buf + len, buf_len - len, "Frames accepted:  %u\n", stat->accepted);
-	len += oal_util_snprintf(buf + len, buf_len - len, "Frames rejected:  %u\n", stat->rejected);
+	{
+		len += oal_util_snprintf(buf + len, buf_len - len, "Frames accepted:  %u\n", stat->accepted);
+		len += oal_util_snprintf(buf + len, buf_len - len, "Frames rejected:  %u\n", stat->rejected);
+	}
 	return len;
 }
 
@@ -1186,9 +1301,9 @@ uint32_t pfe_class_fp_stat_to_str(const pfe_ct_class_flexi_parser_stats_t *stat,
 errno_t pfe_class_put_data(const pfe_class_t *class, pfe_ct_buffer_t *buf)
 {
 	uint32_t ii, tries;
-	errno_t ret;
+	errno_t  ret;
 
-	for (ii=0U; ii<class->pe_num; ii++)
+	for (ii = 0U; ii < class->pe_num; ii++)
 	{
 		/*	Allow safe use of _nolock() functions. We don't call the _mem_lock()
 		 	here as we don't need to have coherent accesses. */
@@ -1216,11 +1331,12 @@ errno_t pfe_class_put_data(const pfe_class_t *class, pfe_ct_buffer_t *buf)
 		if (EOK != ret)
 		{
 			NXP_LOG_ERROR("Unable to update pe %u\n", (uint_t)ii);
-			return EBUSY;
+			ret = EBUSY;
+			break;
 		}
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1232,80 +1348,86 @@ errno_t pfe_class_put_data(const pfe_class_t *class, pfe_ct_buffer_t *buf)
  */
 errno_t pfe_class_get_stats(pfe_class_t *class, pfe_ct_classify_stats_t *stat)
 {
-	pfe_ct_pe_mmap_t mmap;
-	uint32_t i = 0U, j = 0U;
-	errno_t ret = EOK;
-	uint32_t buff_len = 0U;
-	pfe_ct_classify_stats_t * stats = NULL;
+	pfe_ct_pe_mmap_t         mmap;
+	uint32_t                 i = 0U, j = 0U;
+	errno_t                  ret      = EOK;
+	uint32_t                 buff_len = 0U;
+	pfe_ct_classify_stats_t *stats    = NULL;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely((NULL == class) || (NULL == stat)))
-	{
-		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
-	}
+    if (unlikely((NULL == class) || (NULL == stat)))
+    {
+        NXP_LOG_ERROR("NULL argument received\n");
+        ret = EINVAL;
+    }
+    else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	(void)memset(stat,0,sizeof(pfe_ct_classify_stats_t));
-
-	/* Prepare memory */
-	buff_len = sizeof(pfe_ct_classify_stats_t) * pfe_class_get_num_of_pes(class);
-	stats = oal_mm_malloc(buff_len);
-	if(NULL == stats)
 	{
-		return ENOMEM;
-	}
+        (void)memset(stat, 0, sizeof(pfe_ct_classify_stats_t));
 
-	/* Get the memory map - all PEs share the same memory map
-	   therefore we can read arbitrary one (in this case 0U) */
-	ret = pfe_pe_get_mmap(class->pe[0U], &mmap);
-	if (EOK != ret)
-	{
-		NXP_LOG_ERROR("Cannot get PE memory map\n");
-		oal_mm_free(stats);
-		return ret;
-	}
+        /* Prepare memory */
+        buff_len = sizeof(pfe_ct_classify_stats_t) * pfe_class_get_num_of_pes(class);
+        stats    = oal_mm_malloc(buff_len);
+        if (NULL == stats)
+        {
+            ret = ENOMEM;
+        }
+        else
+        {
+            /* Get the memory map - all PEs share the same memory map
+            therefore we can read arbitrary one (in this case 0U) */
+            ret = pfe_pe_get_mmap(class->pe[0U], &mmap);
 
-	/* Gather memory from all PEs*/
-	ret = pfe_class_gather_read_dmem(class, stats, oal_ntohl(mmap.class_pe.classification_stats), buff_len, sizeof(pfe_ct_classify_stats_t));
+            if (EOK != ret)
+            {
+                NXP_LOG_ERROR("Cannot get PE memory map\n");
+                oal_mm_free(stats);
+            }
+            else
+            {
+                /* Gather memory from all PEs*/
+                ret = pfe_class_gather_read_dmem(class, stats, oal_ntohl(mmap.class_pe.classification_stats), buff_len, sizeof(pfe_ct_classify_stats_t));
 
-	/* Calculate total statistics */
-	while(i < pfe_class_get_num_of_pes(class))
-	{
-		pfe_class_alg_stats_endian(&stats[i].flexible_router);
-		pfe_class_alg_stats_endian(&stats[i].ip_router);
-		pfe_class_alg_stats_endian(&stats[i].vlan_bridge);
-		pfe_class_alg_stats_endian(&stats[i].log_if);
+                /* Calculate total statistics */
+                while (i < pfe_class_get_num_of_pes(class))
+                {
+                    pfe_class_alg_stats_endian(&stats[i].flexible_router);
+                    pfe_class_alg_stats_endian(&stats[i].ip_router);
+                    pfe_class_alg_stats_endian(&stats[i].vlan_bridge);
+                    pfe_class_alg_stats_endian(&stats[i].log_if);
 
-		for (j = 0U; j < ((uint32_t)PFE_PHY_IF_ID_MAX + 1U); j++)
-		{
-			pfe_class_ihc_stats_endian(&stats[i].hif_to_hif[j]);
-		}
-		pfe_class_flexi_parser_stats_endian(&stats[i].flexible_filter);
+                    for (j = 0U; j < ((uint32_t)PFE_PHY_IF_ID_MAX + 1U); j++)
+                    {
+                        pfe_class_ihc_stats_endian(&stats[i].hif_to_hif[j]);
+                    }
+                    pfe_class_flexi_parser_stats_endian(&stats[i].flexible_filter);
 
-		pfe_class_sum_pe_algo_stats(&stat->flexible_router, &stats[i].flexible_router);
-		pfe_class_sum_pe_algo_stats(&stat->ip_router, &stats[i].ip_router);
-		pfe_class_sum_pe_algo_stats(&stat->vlan_bridge, &stats[i].vlan_bridge);
-		pfe_class_sum_pe_algo_stats(&stat->log_if, &stats[i].log_if);
+                    pfe_class_sum_pe_algo_stats(&stat->flexible_router, &stats[i].flexible_router);
+                    pfe_class_sum_pe_algo_stats(&stat->ip_router, &stats[i].ip_router);
+                    pfe_class_sum_pe_algo_stats(&stat->vlan_bridge, &stats[i].vlan_bridge);
+                    pfe_class_sum_pe_algo_stats(&stat->log_if, &stats[i].log_if);
 
-		for (j = 0U; j < ((uint32_t)PFE_PHY_IF_ID_MAX + 1U); j++)
-		{
-			pfe_class_sum_pe_ihc_stats(&stat->hif_to_hif[j], &stats[i].hif_to_hif[j]);
-		}
-		pfe_class_sum_flexi_parser_stats(&stat->flexible_filter, &stats[i].flexible_filter);
-		++i;
-	}
+                    for (j = 0U; j < ((uint32_t)PFE_PHY_IF_ID_MAX + 1U); j++)
+                    {
+                        pfe_class_sum_pe_ihc_stats(&stat->hif_to_hif[j], &stats[i].hif_to_hif[j]);
+                    }
+                    pfe_class_sum_flexi_parser_stats(&stat->flexible_filter, &stats[i].flexible_filter);
+                    ++i;
+                }
 
-	oal_mm_free(stats);
+                oal_mm_free(stats);
+            }
+        }
+    }
 
 	return ret;
 }
 
 #define HIF_CHANNELS_MASK (((uint32_t)1U << (uint32_t)PFE_PHY_IF_ID_HIF0)\
-                          |((uint32_t)1U << (uint32_t)PFE_PHY_IF_ID_HIF1)\
-                          |((uint32_t)1U << (uint32_t)PFE_PHY_IF_ID_HIF2)\
-                          |((uint32_t)1U << (uint32_t)PFE_PHY_IF_ID_HIF3)\
-                          |((uint32_t)1U << (uint32_t)PFE_PHY_IF_ID_HIF_NOCPY))
+						  |((uint32_t)1U << (uint32_t)PFE_PHY_IF_ID_HIF1)\
+						  |((uint32_t)1U << (uint32_t)PFE_PHY_IF_ID_HIF2)\
+						  |((uint32_t)1U << (uint32_t)PFE_PHY_IF_ID_HIF3)\
+						  |((uint32_t)1U << (uint32_t)PFE_PHY_IF_ID_HIF_NOCPY))
 
 /**
  * @brief		Return CLASS runtime statistics in text form
@@ -1320,14 +1442,13 @@ uint32_t pfe_class_get_text_statistics(pfe_class_t *class, char_t *buf, uint32_t
 {
 	uint32_t len = 0U;
 
-	pfe_ct_pe_mmap_t mmap;
-	errno_t ret = EOK;
-	uint32_t ii, j;
-	pfe_ct_pe_stats_t *pe_stats;
+	pfe_ct_pe_mmap_t        mmap;
+	errno_t                 ret = EOK;
+	uint32_t                ii, j;
+	pfe_ct_pe_stats_t *     pe_stats;
 	pfe_ct_classify_stats_t c_alg_stats;
-	pfe_ct_version_t fw_ver;
-	char_t phyif_name[][20] =
-	{
+	pfe_ct_version_t        fw_ver;
+	char_t                  phyif_name[][20] = {
         "EMAC0",
         "EMAC1",
         "EMAC2",
@@ -1344,169 +1465,170 @@ uint32_t pfe_class_get_text_statistics(pfe_class_t *class, char_t *buf, uint32_t
 	if (unlikely(NULL == class))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return 0U;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (EOK != oal_mutex_lock(&class->mutex))
-	{
-		NXP_LOG_DEBUG("mutex lock failed\n");
-	}
-
-	/* FW version */
-	if (EOK == pfe_class_get_fw_version(class, &fw_ver))
-	{
-		len += oal_util_snprintf(buf + len, buf_len - len, "FIRMWARE VERSION\t%u.%u.%u (api:%.32s)\n",
-			fw_ver.major, fw_ver.minor, fw_ver.patch, fw_ver.cthdr);
+		len = 0U;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		len += oal_util_snprintf(buf + len, buf_len - len, "FIRMWARE VERSION <unknown>\n");
-	}
-
-	len += pfe_class_cfg_get_text_stat(class->cbus_base_va, buf + len, buf_len - len, verb_level);
-
-	/* Allocate memory to copy the statistics from PEs + one position for sums
-	   (having sums separate from data allows to print also per PE details) */
-	pe_stats = oal_mm_malloc(sizeof(pfe_ct_pe_stats_t) * (class->pe_num + 1U));
-	if (NULL == pe_stats)
-	{
-		NXP_LOG_ERROR("Memory allocation failed\n");
-		if (EOK != oal_mutex_unlock(&class->mutex))
+		if (EOK != oal_mutex_lock(&class->mutex))
 		{
-			NXP_LOG_DEBUG("mutex unlock failed\n");
+			NXP_LOG_DEBUG("mutex lock failed\n");
 		}
 
-		return len;
-	}
-
-	(void)memset(pe_stats, 0, sizeof(pfe_ct_pe_stats_t) * (class->pe_num + 1U));
-
-	/* Get the memory map - all PEs share the same memory map
-	   therefore we can read arbitrary one (in this case 0U) */
-	ret = pfe_pe_get_mmap(class->pe[0U], &mmap);
-	if (EOK != ret)
-	{
-		NXP_LOG_ERROR("Cannot get PE memory map\n");
-		oal_mm_free(pe_stats);
-		if (EOK != oal_mutex_unlock(&class->mutex))
+		/* FW version */
+		if (EOK == pfe_class_get_fw_version(class, &fw_ver))
 		{
-			NXP_LOG_DEBUG("mutex unlock failed\n");
+			len += oal_util_snprintf(buf + len, buf_len - len, "FIRMWARE VERSION\t%u.%u.%u (api:%.32s)\n", fw_ver.major, fw_ver.minor, fw_ver.patch, fw_ver.cthdr);
 		}
-
-		return len;
-	}
-
-	/* Lock all PEs - they will stop processing frames and wait. This will
-	   ensure data coherence. */
-	for (ii = 0U; ii < class->pe_num; ii++)
-	{
-		ret = pfe_pe_mem_lock(class->pe[ii]);
-		if (EOK != ret)
+		else
 		{
-			NXP_LOG_ERROR("PE %u could not be locked\n", (uint_t)ii);
-			len += oal_util_snprintf(buf + len, buf_len - len,
-					"PE %u could not be locked - statistics are not coherent\n", ii);
+			len += oal_util_snprintf(buf + len, buf_len - len, "FIRMWARE VERSION <unknown>\n");
 		}
-	}
 
-	/* Get PE info per PE
-	   - leave 1st position in allocated memory empty for sums */
-	for (ii = 0U; ii < class->pe_num; ii++)
-	{
-		(void)pfe_pe_get_pe_stats_nolock(
-					class->pe[ii],
-					oal_ntohl(mmap.class_pe.pe_stats),
-					&pe_stats[ii + 1U]);
-	}
+		len += pfe_class_cfg_get_text_stat(class->cbus_base_va, buf + len, buf_len - len, verb_level);
 
-	/* Unlock all PEs */
-	for (ii = 0U; ii < class->pe_num; ii++)
-	{
-		ret = pfe_pe_mem_unlock(class->pe[ii]);
-		if (EOK != ret)
+		/* Allocate memory to copy the statistics from PEs + one position for sums
+		(having sums separate from data allows to print also per PE details) */
+		pe_stats = oal_mm_malloc(sizeof(pfe_ct_pe_stats_t) * (class->pe_num + 1U));
+		if (NULL == pe_stats)
 		{
-			NXP_LOG_ERROR("PE %u could not be unlocked\n", (uint_t)ii);
+			NXP_LOG_ERROR("Memory allocation failed\n");
+			if (EOK != oal_mutex_unlock(&class->mutex))
+			{
+				NXP_LOG_DEBUG("mutex unlock failed\n");
+			}
 		}
-	}
+		else
+		{
+			(void)memset(pe_stats, 0, sizeof(pfe_ct_pe_stats_t) * (class->pe_num + 1U));
 
-	if (EOK != oal_mutex_unlock(&class->mutex))
-	{
-		NXP_LOG_DEBUG("mutex unlock failed\n");
-	}
+			/* Get the memory map - all PEs share the same memory map
+			therefore we can read arbitrary one (in this case 0U) */
+			ret = pfe_pe_get_mmap(class->pe[0U], &mmap);
+			if (EOK != ret)
+			{
+				NXP_LOG_ERROR("Cannot get PE memory map\n");
+				oal_mm_free(pe_stats);
+				if (EOK != oal_mutex_unlock(&class->mutex))
+				{
+					NXP_LOG_DEBUG("mutex unlock failed\n");
+				}
+			}
+			else
+			{
 
-	ret = pfe_class_get_stats(class, &c_alg_stats);
-	if (EOK != ret)
-	{
-		NXP_LOG_ERROR("Cannot get class statistics\n");
-	}
+				/* Lock all PEs - they will stop processing frames and wait. This will
+				ensure data coherence. */
+				for (ii = 0U; ii < class->pe_num; ii++)
+				{
+					ret = pfe_pe_mem_lock(class->pe[ii]);
+					if (EOK != ret)
+					{
+						NXP_LOG_ERROR("PE %u could not be locked\n", (uint_t)ii);
+						len += oal_util_snprintf(buf + len, buf_len - len, "PE %u could not be locked - statistics are not coherent\n", ii);
+					}
+				}
 
-	/* Process gathered info from all PEs
-	   - convert endians
-	   - done separately to minimize time when PEs are locked
-	   - create sums in the 1st set
-	*/
-	for (ii = 0U; ii < class->pe_num; ii++)
-	{
-		pfe_class_pe_stats_endian(&pe_stats[ii + 1U]);
+				/* Get PE info per PE
+				- leave 1st position in allocated memory empty for sums */
+				for (ii = 0U; ii < class->pe_num; ii++)
+				{
+					(void)pfe_pe_get_pe_stats_nolock(
+					    class->pe[ii],
+					    oal_ntohl(mmap.class_pe.pe_stats),
+					    &pe_stats[ii + 1U]);
+				}
 
-		/* Calculate sums */
-		pe_stats[0].processed += pe_stats[ii + 1U].processed;
-		pe_stats[0].discarded += pe_stats[ii + 1U].discarded;
-		pe_stats[0].injected += pe_stats[ii + 1U].injected;
+				/* Unlock all PEs */
+				for (ii = 0U; ii < class->pe_num; ii++)
+				{
+					ret = pfe_pe_mem_unlock(class->pe[ii]);
+					if (EOK != ret)
+					{
+						NXP_LOG_ERROR("PE %u could not be unlocked\n", (uint_t)ii);
+					}
+				}
 
-		for(j = 0U; j < ((uint32_t)PFE_PHY_IF_ID_MAX + 1U); j++)
-		{
-			pe_stats[0].replicas[j] += pe_stats[ii + 1U].replicas[j];
-		}
-	}
+				if (EOK != oal_mutex_unlock(&class->mutex))
+				{
+					NXP_LOG_DEBUG("mutex unlock failed\n");
+				}
 
-	/* Print results */
-	len += oal_util_snprintf(buf + len, buf_len - len, "-- Per PE statistics --\n");
+				ret = pfe_class_get_stats(class, &c_alg_stats);
+				if (EOK != ret)
+				{
+					NXP_LOG_ERROR("Cannot get class statistics\n");
+				}
 
-	for (ii = 0U; ii < class->pe_num; ii++)
-	{
-		len += oal_util_snprintf(buf + len, buf_len - len, "PE %u Frames processed: %u\n", ii, pe_stats[ii + 1U].processed);
-		len += oal_util_snprintf(buf + len, buf_len - len, "PE %u Frames discarded: %u\n", ii, pe_stats[ii + 1U].discarded);
-	}
+				/* Process gathered info from all PEs
+				- convert endians
+				- done separately to minimize time when PEs are locked
+				- create sums in the 1st set
+				*/
+				for (ii = 0U; ii < class->pe_num; ii++)
+				{
+					pfe_class_pe_stats_endian(&pe_stats[ii + 1U]);
 
-	len += oal_util_snprintf(buf + len, buf_len - len, "-- Summary statistics --\n");
-	len += oal_util_snprintf(buf + len, buf_len - len, "Frames processed: %u\n", pe_stats[0].processed);
-	len += oal_util_snprintf(buf + len, buf_len - len, "Frames discarded: %u\n", pe_stats[0].discarded);
+					/* Calculate sums */
+					pe_stats[0].processed += pe_stats[ii + 1U].processed;
+					pe_stats[0].discarded += pe_stats[ii + 1U].discarded;
+					pe_stats[0].injected += pe_stats[ii + 1U].injected;
 
-	for (j = 0U; j < ((uint32_t)PFE_PHY_IF_ID_MAX + 1U); j++)
-	{
-		len += oal_util_snprintf(buf + len, buf_len - len, "Frames with %u replicas: %u\n", j + 1U, pe_stats[0].replicas[j]);
-	}
+					for (j = 0U; j < ((uint32_t)PFE_PHY_IF_ID_MAX + 1U); j++)
+					{
+						pe_stats[0].replicas[j] += pe_stats[ii + 1U].replicas[j];
+					}
+				}
 
-	len += oal_util_snprintf(buf + len, buf_len - len, "Frames with HIF_TX_INJECT: %u\n", pe_stats[0].injected);
+				/* Print results */
+				len += oal_util_snprintf(buf + len, buf_len - len, "-- Per PE statistics --\n");
 
-	len += oal_util_snprintf(buf + len, buf_len - len, "- Flexible router -\n");
-	len += pfe_class_stat_to_str(&c_alg_stats.flexible_router, buf + len, buf_len - len, verb_level);
-	len += oal_util_snprintf(buf + len, buf_len - len, "- IP Router -\n");
-	len += pfe_class_stat_to_str(&c_alg_stats.ip_router, buf + len, buf_len - len, verb_level);
-	len += oal_util_snprintf(buf + len, buf_len - len, "- VLAN Bridge -\n");
-	len += pfe_class_stat_to_str(&c_alg_stats.vlan_bridge, buf + len, buf_len - len, verb_level);
-	len += oal_util_snprintf(buf + len, buf_len - len, "- Logical Interfaces -\n");
-	len += pfe_class_stat_to_str(&c_alg_stats.log_if, buf + len, buf_len - len, verb_level);
-	len += oal_util_snprintf(buf + len, buf_len - len, "- Global Flexible filter -\n");
-	len += pfe_class_fp_stat_to_str(&c_alg_stats.flexible_filter, buf + len, buf_len - len, verb_level);
-	len += oal_util_snprintf(buf + len, buf_len - len, "- InterHIF -\n");
+				for (ii = 0U; ii < class->pe_num; ii++)
+				{
+					len += oal_util_snprintf(buf + len, buf_len - len, "PE %u Frames processed: %u\n", ii, pe_stats[ii + 1U].processed);
+					len += oal_util_snprintf(buf + len, buf_len - len, "PE %u Frames discarded: %u\n", ii, pe_stats[ii + 1U].discarded);
+				}
 
-	for (j = 0U; j < ((uint32_t)PFE_PHY_IF_ID_MAX + 1U); j++)
-	{
-		if (0U != (((uint32_t)1U << j) & (uint32_t)HIF_CHANNELS_MASK))
-		{
-			len += oal_util_snprintf(buf + len, buf_len - len, "Interface: %s\n", phyif_name[j]);
-			len += pfe_class_ihc_stat_to_str(&c_alg_stats.hif_to_hif[j], buf + len, buf_len - len, verb_level);
-		}
-	}
+				len += oal_util_snprintf(buf + len, buf_len - len, "-- Summary statistics --\n");
+				len += oal_util_snprintf(buf + len, buf_len - len, "Frames processed: %u\n", pe_stats[0].processed);
+				len += oal_util_snprintf(buf + len, buf_len - len, "Frames discarded: %u\n", pe_stats[0].discarded);
 
-	len += oal_util_snprintf(buf + len, buf_len - len, "\nDMEM heap\n---------\n");
-	len += blalloc_get_text_statistics(class->heap_context, buf + len, buf_len - len, verb_level);
+				for (j = 0U; j < ((uint32_t)PFE_PHY_IF_ID_MAX + 1U); j++)
+				{
+					len += oal_util_snprintf(buf + len, buf_len - len, "Frames with %u replicas: %u\n", j + 1U, pe_stats[0].replicas[j]);
+				}
+
+				len += oal_util_snprintf(buf + len, buf_len - len, "Frames with HIF_TX_INJECT: %u\n", pe_stats[0].injected);
+
+				len += oal_util_snprintf(buf + len, buf_len - len, "- Flexible router -\n");
+				len += pfe_class_stat_to_str(&c_alg_stats.flexible_router, buf + len, buf_len - len, verb_level);
+				len += oal_util_snprintf(buf + len, buf_len - len, "- IP Router -\n");
+				len += pfe_class_stat_to_str(&c_alg_stats.ip_router, buf + len, buf_len - len, verb_level);
+				len += oal_util_snprintf(buf + len, buf_len - len, "- VLAN Bridge -\n");
+				len += pfe_class_stat_to_str(&c_alg_stats.vlan_bridge, buf + len, buf_len - len, verb_level);
+				len += oal_util_snprintf(buf + len, buf_len - len, "- Logical Interfaces -\n");
+				len += pfe_class_stat_to_str(&c_alg_stats.log_if, buf + len, buf_len - len, verb_level);
+				len += oal_util_snprintf(buf + len, buf_len - len, "- Global Flexible filter -\n");
+				len += pfe_class_fp_stat_to_str(&c_alg_stats.flexible_filter, buf + len, buf_len - len, verb_level);
+				len += oal_util_snprintf(buf + len, buf_len - len, "- InterHIF -\n");
+
+				for (j = 0U; j < ((uint32_t)PFE_PHY_IF_ID_MAX + 1U); j++)
+				{
+					if (0U != (((uint32_t)1U << j) & (uint32_t)HIF_CHANNELS_MASK))
+					{
+						len += oal_util_snprintf(buf + len, buf_len - len, "Interface: %s\n", phyif_name[j]);
+						len += pfe_class_ihc_stat_to_str(&c_alg_stats.hif_to_hif[j], buf + len, buf_len - len, verb_level);
+					}
+				}
 
-	/* Free allocated memory */
-	oal_mm_free(pe_stats);
+				len += oal_util_snprintf(buf + len, buf_len - len, "\nDMEM heap\n---------\n");
+				len += blalloc_get_text_statistics(class->heap_context, buf + len, buf_len - len, verb_level);
+
+				/* Free allocated memory */
+				oal_mm_free(pe_stats);
+			}
+		}
+	}
 
 	return len;
 }
@@ -1519,16 +1641,20 @@ uint32_t pfe_class_get_text_statistics(pfe_class_t *class, char_t *buf, uint32_t
 errno_t pfe_class_get_fw_version(const pfe_class_t *class, pfe_ct_version_t *ver)
 {
 	pfe_ct_pe_mmap_t pfe_pe_mmap;
+	errno_t          ret;
 
 	/*	Get mmap base from PE[0] since all PEs have the same memory map */
 	if ((NULL == class->pe[0]) || (EOK != pfe_pe_get_mmap(class->pe[0], &pfe_pe_mmap)))
 	{
-		return EINVAL;
+		ret = EINVAL;
+	}
+	else
+	{
+		(void)memcpy(ver, &pfe_pe_mmap.class_pe.common.version, sizeof(pfe_ct_version_t));
+        ret = EOK;
 	}
 
-	(void)memcpy(ver, &pfe_pe_mmap.class_pe.common.version, sizeof(pfe_ct_version_t));
-
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1548,4 +1674,3 @@ void pfe_class_rtable_lookup_disable(const pfe_class_t *class)
 {
 	pfe_class_cfg_rtable_lookup_disable(class->cbus_base_va);
 }
-
diff --git a/sw/pfe_platform/src/pfe_emac.c b/sw/pfe_platform/src/pfe_emac.c
index 9a2a4fe..16f353e 100644
--- a/sw/pfe_platform/src/pfe_emac.c
+++ b/sw/pfe_platform/src/pfe_emac.c
@@ -74,42 +74,43 @@ static bool_t pfe_emac_flush_criterion_eval(const pfe_mac_addr_db_entry_t *entry
 	if (unlikely(NULL == entry))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return FALSE;
+		ret = FALSE;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (crit == EMAC_CRIT_BY_OWNER)
 	{
-		/* Return the first address where owner match */
-		if (entry->owner == owner)
+		if (crit == EMAC_CRIT_BY_OWNER)
 		{
-			/* Break if entry match with the rule */
-			ret = TRUE;
+			/* Return the first address where owner match */
+			if (entry->owner == owner)
+			{
+				/* Break if entry match with the rule */
+				ret = TRUE;
+			}
 		}
-	}
-	else if (crit == EMAC_CRIT_BY_TYPE)
-	{
-		/* Break if entry match with the rule */
-		ret = pfe_emac_check_crit_by_type(entry->addr, type);
-	}
-	else if (crit == EMAC_CRIT_BY_OWNER_AND_TYPE)
-	{
-		if (entry->owner == owner)
+		else if (crit == EMAC_CRIT_BY_TYPE)
 		{
 			/* Break if entry match with the rule */
 			ret = pfe_emac_check_crit_by_type(entry->addr, type);
 		}
+		else if (crit == EMAC_CRIT_BY_OWNER_AND_TYPE)
+		{
+			if (entry->owner == owner)
+			{
+				/* Break if entry match with the rule */
+				ret = pfe_emac_check_crit_by_type(entry->addr, type);
+			}
+		}
+		else if (crit == EMAC_CRIT_ALL)
+		{
+			/* Break if entry match with the rule */
+			ret = TRUE;
+		}
+		else
+		{
+			NXP_LOG_WARNING("Unknown criterion\n");
+		}
 	}
-	else if (crit == EMAC_CRIT_ALL)
-	{
-		/* Break if entry match with the rule */
-		ret = TRUE;
-	}
-	else
-	{
-		NXP_LOG_WARNING("Unknown criterion\n");
-	}
-
 	return ret;
 }
 
@@ -123,11 +124,12 @@ static void pfe_emac_addr_db_init(pfe_emac_t *emac)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	LLIST_Init(&emac->mac_addr_list);
+	{
+		LLIST_Init(&emac->mac_addr_list);
+	}
 }
 
 /**
@@ -142,46 +144,53 @@ static void pfe_emac_addr_db_init(pfe_emac_t *emac)
 static errno_t pfe_emac_addr_db_add(pfe_emac_t *emac, const pfe_mac_addr_t addr, bool_t in_hash_grp, uint32_t data, pfe_drv_id_t owner)
 {
 	pfe_mac_addr_db_entry_t *entry;
+	errno_t                  ret;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	/*	Create new list entry */
+	{
+		/*	Create new list entry */
 #ifdef PFE_CFG_TARGET_OS_LINUX
-	entry = kzalloc(sizeof(pfe_mac_addr_db_entry_t), GFP_ATOMIC); /* temporary fix for AAVB-3946 */
+		entry = kzalloc(sizeof(pfe_mac_addr_db_entry_t), GFP_ATOMIC); /* temporary fix for AAVB-3946 */
 #else
-	entry = oal_mm_malloc(sizeof(pfe_mac_addr_db_entry_t));
+		entry = oal_mm_malloc(sizeof(pfe_mac_addr_db_entry_t));
 #endif
-	if (NULL == entry)
-	{
-		NXP_LOG_ERROR("oal_mm_malloc() failed\n");
-		return ENOMEM;
-	}
+		if (NULL == entry)
+		{
+			NXP_LOG_ERROR("oal_mm_malloc() failed\n");
+			ret = ENOMEM;
+		}
+		else
+		{
 
-	if (in_hash_grp)
-	{
-		entry->hash = data;
-		entry->in_hash_grp = TRUE;
-	}
-	else
-	{
-		entry->addr_slot_idx = (uint8_t)data;
-		entry->in_hash_grp = FALSE;
-	}
+			if (in_hash_grp)
+			{
+				entry->hash = data;
+				entry->in_hash_grp = TRUE;
+			}
+			else
+			{
+				entry->addr_slot_idx = (uint8_t)data;
+				entry->in_hash_grp = FALSE;
+			}
 
-	entry->owner = owner;
+			entry->owner = owner;
 
-	/*	Add entry to the list */
-	(void)memcpy(entry->addr, addr, sizeof(pfe_mac_addr_t));
+			/*	Add entry to the list */
+			(void)memcpy(entry->addr, addr, sizeof(pfe_mac_addr_t));
 
-	LLIST_AddAtEnd(&entry->iterator, &emac->mac_addr_list);
+			LLIST_AddAtEnd(&entry->iterator, &emac->mac_addr_list);
+			ret = EOK;
+		}
+	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -194,18 +203,22 @@ static errno_t pfe_emac_addr_db_add(pfe_emac_t *emac, const pfe_mac_addr_t addr,
  */
 static errno_t pfe_emac_addr_db_del_entry(const pfe_emac_t *emac, pfe_mac_addr_db_entry_t *entry)
 {
+	errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == emac) || (NULL == entry)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #else
 	(void)emac;
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	LLIST_Remove(&entry->iterator);
-	return EOK;
+	{
+		LLIST_Remove(&entry->iterator);
+		ret = EOK;
+	}
+	return ret;
 }
 
 /**
@@ -222,16 +235,17 @@ static void pfe_emac_addr_db_drop_all(const pfe_emac_t *emac)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	/*	Release the MAC address DB */
-	LLIST_ForEachRemovable(curItem, tmp_item, &emac->mac_addr_list)
 	{
-		entry = LLIST_Data(curItem, pfe_mac_addr_db_entry_t, iterator);
-		LLIST_Remove(&entry->iterator);
-		oal_mm_free(entry);
+		/*	Release the MAC address DB */
+		LLIST_ForEachRemovable(curItem, tmp_item, &emac->mac_addr_list)
+		{
+			entry = LLIST_Data(curItem, pfe_mac_addr_db_entry_t, iterator);
+			LLIST_Remove(&entry->iterator);
+			oal_mm_free(entry);
+		}
 	}
 }
 
@@ -246,26 +260,35 @@ static void pfe_emac_addr_db_drop_all(const pfe_emac_t *emac)
 static pfe_mac_addr_db_entry_t *pfe_emac_addr_db_find_by_addr(const pfe_emac_t *emac, const pfe_mac_addr_t addr, pfe_drv_id_t owner)
 {
 	pfe_mac_addr_db_entry_t *entry = NULL;
-	LLIST_t *curItem;
+	LLIST_t *                curItem;
+	bool_t                   match = FALSE;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return NULL;
+		entry = NULL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	LLIST_ForEach(curItem, &emac->mac_addr_list)
 	{
-		entry = LLIST_Data(curItem, pfe_mac_addr_db_entry_t, iterator);
-		if ((entry->owner == owner) && (0 == memcmp(addr, entry->addr, sizeof(pfe_mac_addr_t))))
+		LLIST_ForEach(curItem, &emac->mac_addr_list)
 		{
-			return entry;
+			entry = LLIST_Data(curItem, pfe_mac_addr_db_entry_t, iterator);
+			if ((entry->owner == owner) && (0 == memcmp(addr, entry->addr, sizeof(pfe_mac_addr_t))))
+			{
+				match = TRUE;
+				break;
+			}
 		}
 	}
 
-	return NULL;
+	if (FALSE == match)
+	{
+		entry = NULL;
+	}
+
+	return entry;
 }
 
 /**
@@ -276,22 +299,27 @@ static pfe_mac_addr_db_entry_t *pfe_emac_addr_db_find_by_addr(const pfe_emac_t *
  */
 static pfe_mac_addr_db_entry_t *pfe_emac_addr_db_get_first(const pfe_emac_t *emac)
 {
+	pfe_mac_addr_db_entry_t *db_entry;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return NULL;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (TRUE == LLIST_IsEmpty(&emac->mac_addr_list))
-	{
-		return NULL;
+		db_entry = NULL;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		return LLIST_Data(emac->mac_addr_list.prNext, pfe_mac_addr_db_entry_t, iterator);
+		if (TRUE == LLIST_IsEmpty(&emac->mac_addr_list))
+		{
+			db_entry = NULL;
+		}
+		else
+		{
+			db_entry = LLIST_Data(emac->mac_addr_list.prNext, pfe_mac_addr_db_entry_t, iterator);
+		}
 	}
+
+	return db_entry;
 }
 
 /**
@@ -304,26 +332,34 @@ static pfe_mac_addr_db_entry_t *pfe_emac_addr_db_get_first(const pfe_emac_t *ema
 static pfe_mac_addr_db_entry_t *pfe_emac_addr_db_find_by_hash(const pfe_emac_t *emac, uint32_t hash)
 {
 	pfe_mac_addr_db_entry_t *entry = NULL;
-	LLIST_t *curItem;
+	LLIST_t *                curItem;
+	bool_t                   match = FALSE;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return NULL;
+		entry = NULL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	LLIST_ForEach(curItem, &emac->mac_addr_list)
 	{
-		entry = LLIST_Data(curItem, pfe_mac_addr_db_entry_t, iterator);
-		if (entry->hash == hash)
+		LLIST_ForEach(curItem, &emac->mac_addr_list)
 		{
-			return entry;
+			entry = LLIST_Data(curItem, pfe_mac_addr_db_entry_t, iterator);
+			if (entry->hash == hash)
+			{
+				match = TRUE;
+				break;
+			}
 		}
 	}
 
-	return NULL;
+	if (FALSE == match)
+	{
+		entry = NULL;
+	}
+	return entry;
 }
 
 /**
@@ -336,26 +372,34 @@ static pfe_mac_addr_db_entry_t *pfe_emac_addr_db_find_by_hash(const pfe_emac_t *
 static pfe_mac_addr_db_entry_t *pfe_emac_addr_db_find_by_slot(const pfe_emac_t *emac, uint8_t slot)
 {
 	pfe_mac_addr_db_entry_t *entry = NULL;
+	bool_t                   match = FALSE;
 	LLIST_t *curItem;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return NULL;
+		entry = NULL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	LLIST_ForEach(curItem, &emac->mac_addr_list)
 	{
-		entry = LLIST_Data(curItem, pfe_mac_addr_db_entry_t, iterator);
-		if (entry->addr_slot_idx == slot)
+		LLIST_ForEach(curItem, &emac->mac_addr_list)
 		{
-			return entry;
+			entry = LLIST_Data(curItem, pfe_mac_addr_db_entry_t, iterator);
+			if (entry->addr_slot_idx == slot)
+			{
+				match = TRUE;
+				break;
+			}
 		}
 	}
 
-	return NULL;
+	if (FALSE == match)
+	{
+		entry = NULL;
+	}
+	return entry;
 }
 
 /**
@@ -376,90 +420,92 @@ pfe_emac_t *pfe_emac_create(addr_t cbus_base_va, addr_t emac_base, pfe_emac_mii_
 	if (unlikely(NULL_ADDR == cbus_base_va))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return NULL;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	emac = oal_mm_malloc(sizeof(pfe_emac_t));
-
-	if (NULL == emac)
-	{
-		return NULL;
+		emac = NULL;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		(void)memset(emac, 0, sizeof(pfe_emac_t));
-		emac->cbus_base_va = cbus_base_va;
-		emac->emac_base_offset = emac_base;
-		emac->emac_base_va = (emac->cbus_base_va + emac->emac_base_offset);
-		emac->mode = EMAC_MODE_INVALID;
-		emac->speed = EMAC_SPEED_INVALID;
-		emac->duplex = EMAC_DUPLEX_INVALID;
-
-		if (EOK != oal_mutex_init(&emac->mutex))
-		{
-			NXP_LOG_ERROR("Mutex init failed\n");
-			oal_mm_free(emac);
-			return NULL;
-		}
-
-		if (EOK != oal_mutex_init(&emac->ts_mutex))
-		{
-			NXP_LOG_ERROR("TS mutex init failed\n");
-			(void)oal_mutex_destroy(&emac->mutex);
-			oal_mm_free(emac);
-			return NULL;
-		}
+		emac = oal_mm_malloc(sizeof(pfe_emac_t));
 
-		if (EOK != oal_mutex_lock(&emac->mutex))
+		if (NULL != emac)
 		{
-			NXP_LOG_DEBUG("Mutex lock failed\n");
-		}
+			(void)memset(emac, 0, sizeof(pfe_emac_t));
+			emac->cbus_base_va = cbus_base_va;
+			emac->emac_base_offset = emac_base;
+			emac->emac_base_va = (emac->cbus_base_va + emac->emac_base_offset);
+			emac->mode = EMAC_MODE_INVALID;
+			emac->speed = EMAC_SPEED_INVALID;
+			emac->duplex = EMAC_DUPLEX_INVALID;
+
+			if (EOK != oal_mutex_init(&emac->mutex))
+			{
+				NXP_LOG_ERROR("Mutex init failed\n");
+				oal_mm_free(emac);
+				emac = NULL;
+			}
+			else
+			{
 
-		/*	All slots are free */
-		emac->mac_addr_slots = 0U;
+				if (EOK != oal_mutex_init(&emac->ts_mutex))
+				{
+					NXP_LOG_ERROR("TS mutex init failed\n");
+					(void)oal_mutex_destroy(&emac->mutex);
+					oal_mm_free(emac);
+					emac = NULL;
+				}
+				else
+				{
+					if (EOK != oal_mutex_lock(&emac->mutex))
+					{
+						NXP_LOG_DEBUG("Mutex lock failed\n");
+					}
 
-		/*	Initialize the MAC address DB */
-		pfe_emac_addr_db_init(emac);
+					/*	All slots are free */
+					emac->mac_addr_slots = 0U;
 
-		/*	Disable the HW */
-		pfe_emac_disable(emac);
+					/*	Initialize the MAC address DB */
+					pfe_emac_addr_db_init(emac);
 
-		/*	Initialize the HW */
-		if (EOK != pfe_emac_cfg_init(emac->emac_base_va, mode, speed, duplex))
-		{
-			if (EOK != oal_mutex_unlock(&emac->mutex))
-			{
-				NXP_LOG_DEBUG("Mutex unlock failed\n");
-			}
+					/*	Disable the HW */
+					pfe_emac_disable(emac);
 
-			/*	Invalid configuration */
-			NXP_LOG_ERROR("Invalid configuration requested\n");
-			(void)oal_mutex_destroy(&emac->mutex);
-			(void)oal_mutex_destroy(&emac->ts_mutex);
-			oal_mm_free(emac);
-			emac = NULL;
-			return NULL;
-		}
-		else
-		{
-			emac->mode = mode;
-			emac->speed = speed;
-			emac->duplex = duplex;
-		}
+					/*	Initialize the HW */
+					if (EOK != pfe_emac_cfg_init(emac->emac_base_va, mode, speed, duplex))
+					{
+						if (EOK != oal_mutex_unlock(&emac->mutex))
+						{
+							NXP_LOG_DEBUG("Mutex unlock failed\n");
+						}
+
+						/*	Invalid configuration */
+						NXP_LOG_ERROR("Invalid configuration requested\n");
+						(void)oal_mutex_destroy(&emac->mutex);
+						(void)oal_mutex_destroy(&emac->ts_mutex);
+						oal_mm_free(emac);
+						emac = NULL;
+					}
+					else
+					{
+						emac->mode = mode;
+						emac->speed = speed;
+						emac->duplex = duplex;
 
-		/*	Disable loop-back */
-		pfe_emac_disable_loopback(emac);
+						/*	Disable loop-back */
+						pfe_emac_disable_loopback(emac);
 
-		/*	Disable promiscuous mode */
-		pfe_emac_disable_promisc_mode(emac);
+						/*	Disable promiscuous mode */
+						pfe_emac_disable_promisc_mode(emac);
 
-		/*	Disable broadcast */
-		pfe_emac_disable_broadcast(emac);
+						/*	Disable broadcast */
+						pfe_emac_disable_broadcast(emac);
 
-		if (EOK != oal_mutex_unlock(&emac->mutex))
-		{
-			NXP_LOG_DEBUG("Mutex unlock failed\n");
+						if (EOK != oal_mutex_unlock(&emac->mutex))
+						{
+							NXP_LOG_DEBUG("Mutex unlock failed\n");
+						}
+					}
+				}
+			}
 		}
 	}
 
@@ -486,17 +532,21 @@ uint8_t pfe_emac_get_index(pfe_emac_t *emac)
 
 errno_t pfe_emac_bind_gpi(pfe_emac_t *emac, pfe_gpi_t *gpi)
 {
+	errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == emac) || (NULL == gpi)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		emac->gpi = gpi;
+		ret = EOK;
+	}
 
-	emac->gpi = gpi;
-
-	return EOK;
+	return ret;
 }
 
 pfe_gpi_t *pfe_emac_get_gpi(const pfe_emac_t *emac)
@@ -515,11 +565,12 @@ void pfe_emac_enable(const pfe_emac_t *emac)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	pfe_emac_cfg_set_enable(emac->emac_base_va, TRUE);
+	{
+		pfe_emac_cfg_set_enable(emac->emac_base_va, TRUE);
+	}
 }
 
 /**
@@ -533,11 +584,12 @@ void pfe_emac_disable(const pfe_emac_t *emac)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	pfe_emac_cfg_set_enable(emac->emac_base_va, FALSE);
+	{
+		pfe_emac_cfg_set_enable(emac->emac_base_va, FALSE);
+	}
 }
 
 /**
@@ -559,24 +611,25 @@ errno_t pfe_emac_enable_ts(pfe_emac_t *emac, uint32_t i_clk_hz, uint32_t o_clk_h
 	if (!eclk && (i_clk_hz <= o_clk_hz))
 	{
 		NXP_LOG_ERROR("Invalid clock configuration\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	emac->i_clk_hz = i_clk_hz;
-	emac->o_clk_hz = o_clk_hz;
-
-	if (EOK != oal_mutex_lock(&emac->ts_mutex))
+	else
 	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
+		emac->i_clk_hz = i_clk_hz;
+		emac->o_clk_hz = o_clk_hz;
 
-	ret = pfe_emac_cfg_enable_ts(emac->emac_base_va, eclk, i_clk_hz, o_clk_hz);
+		if (EOK != oal_mutex_lock(&emac->ts_mutex))
+		{
+			NXP_LOG_DEBUG("Mutex lock failed\n");
+		}
 
-	if (EOK != oal_mutex_unlock(&emac->ts_mutex))
-	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
+		ret = pfe_emac_cfg_enable_ts(emac->emac_base_va, eclk, i_clk_hz, o_clk_hz);
 
+		if (EOK != oal_mutex_unlock(&emac->ts_mutex))
+		{
+			NXP_LOG_DEBUG("Mutex lock failed\n");
+		}
+	}
 	return ret;
 }
 
@@ -618,9 +671,10 @@ errno_t pfe_emac_set_ts_freq_adjustment(pfe_emac_t *emac, uint32_t ppb, bool_t s
  */
 errno_t pfe_emac_get_ts_freq_adjustment(pfe_emac_t *emac, uint32_t *ppb, bool_t *sgn)
 {
+	errno_t ret;
 	if ((NULL == ppb) || (NULL == sgn))
 	{
-		return EINVAL;
+		ret = EINVAL;
 	}
 	else
 	{
@@ -636,9 +690,9 @@ errno_t pfe_emac_get_ts_freq_adjustment(pfe_emac_t *emac, uint32_t *ppb, bool_t
 		{
 			NXP_LOG_DEBUG("Mutex lock failed\n");
 		}
-
-		return EOK;
+		ret = EOK;
 	}
+	return ret;
 }
 
 /**
@@ -657,27 +711,29 @@ errno_t pfe_emac_get_ts_time(pfe_emac_t *emac, uint32_t *sec, uint32_t *nsec, ui
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if ((NULL == sec) || (NULL == nsec) || (NULL == sec_hi))
-	{
 		ret = EINVAL;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		if (EOK != oal_mutex_lock(&emac->ts_mutex))
+		if ((NULL == sec) || (NULL == nsec) || (NULL == sec_hi))
 		{
-			NXP_LOG_DEBUG("Mutex lock failed\n");
+			ret = EINVAL;
 		}
+		else
+		{
+			if (EOK != oal_mutex_lock(&emac->ts_mutex))
+			{
+				NXP_LOG_DEBUG("Mutex lock failed\n");
+			}
 
-		pfe_emac_cfg_get_ts_time(emac->emac_base_va, sec, nsec, sec_hi);
-		ret = EOK;
+			pfe_emac_cfg_get_ts_time(emac->emac_base_va, sec, nsec, sec_hi);
 
-		if (EOK != oal_mutex_unlock(&emac->ts_mutex))
-		{
-			NXP_LOG_DEBUG("Mutex lock failed\n");
+			if (EOK != oal_mutex_unlock(&emac->ts_mutex))
+			{
+				NXP_LOG_DEBUG("Mutex lock failed\n");
+			}
+			ret = EOK;
 		}
 	}
 
@@ -704,20 +760,22 @@ errno_t pfe_emac_adjust_ts_time(pfe_emac_t *emac, uint32_t sec, uint32_t nsec, b
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (EOK != oal_mutex_lock(&emac->ts_mutex))
 	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
+		if (EOK != oal_mutex_lock(&emac->ts_mutex))
+		{
+			NXP_LOG_DEBUG("Mutex lock failed\n");
+		}
 
-	ret = pfe_emac_cfg_adjust_ts_time(emac->emac_base_va, sec, nsec, sgn);
+		ret = pfe_emac_cfg_adjust_ts_time(emac->emac_base_va, sec, nsec, sgn);
 
-	if (EOK != oal_mutex_unlock(&emac->ts_mutex))
-	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
+		if (EOK != oal_mutex_unlock(&emac->ts_mutex))
+		{
+			NXP_LOG_DEBUG("Mutex lock failed\n");
+		}
 	}
 
 	return ret;
@@ -741,20 +799,22 @@ errno_t pfe_emac_set_ts_time(pfe_emac_t *emac, uint32_t sec, uint32_t nsec, uint
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (EOK != oal_mutex_lock(&emac->ts_mutex))
 	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
+		if (EOK != oal_mutex_lock(&emac->ts_mutex))
+		{
+			NXP_LOG_DEBUG("Mutex lock failed\n");
+		}
 
-	ret = pfe_emac_cfg_set_ts_time(emac->emac_base_va, sec, nsec, sec_hi);
+		ret = pfe_emac_cfg_set_ts_time(emac->emac_base_va, sec, nsec, sec_hi);
 
-	if (EOK != oal_mutex_unlock(&emac->ts_mutex))
-	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
+		if (EOK != oal_mutex_unlock(&emac->ts_mutex))
+		{
+			NXP_LOG_DEBUG("Mutex lock failed\n");
+		}
 	}
 
 	return ret;
@@ -771,11 +831,12 @@ void pfe_emac_enable_loopback(const pfe_emac_t *emac)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	pfe_emac_cfg_set_loopback(emac->emac_base_va, TRUE);
+	{
+		pfe_emac_cfg_set_loopback(emac->emac_base_va, TRUE);
+	}
 }
 
 /**
@@ -788,11 +849,12 @@ void pfe_emac_disable_loopback(const pfe_emac_t *emac)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	pfe_emac_cfg_set_loopback(emac->emac_base_va, FALSE);
+	{
+		pfe_emac_cfg_set_loopback(emac->emac_base_va, FALSE);
+	}
 }
 
 /**
@@ -805,11 +867,12 @@ void pfe_emac_enable_promisc_mode(const pfe_emac_t *emac)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	pfe_emac_cfg_set_promisc_mode(emac->emac_base_va, TRUE);
+	{
+		pfe_emac_cfg_set_promisc_mode(emac->emac_base_va, TRUE);
+	}
 }
 
 /**
@@ -822,11 +885,12 @@ void pfe_emac_disable_promisc_mode(const pfe_emac_t *emac)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	pfe_emac_cfg_set_promisc_mode(emac->emac_base_va, FALSE);
+	{
+		pfe_emac_cfg_set_promisc_mode(emac->emac_base_va, FALSE);
+	}
 }
 
 /**
@@ -839,11 +903,12 @@ void pfe_emac_enable_allmulti_mode(const pfe_emac_t *emac)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	pfe_emac_cfg_set_allmulti_mode(emac->emac_base_va, TRUE);
+	{
+		pfe_emac_cfg_set_allmulti_mode(emac->emac_base_va, TRUE);
+	}
 }
 
 /**
@@ -856,11 +921,12 @@ void pfe_emac_disable_allmulti_mode(const pfe_emac_t *emac)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	pfe_emac_cfg_set_allmulti_mode(emac->emac_base_va, FALSE);
+	{
+		pfe_emac_cfg_set_allmulti_mode(emac->emac_base_va, FALSE);
+	}
 }
 
 /**
@@ -873,11 +939,12 @@ void pfe_emac_enable_broadcast(const pfe_emac_t *emac)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	pfe_emac_cfg_set_broadcast(emac->emac_base_va, TRUE);
+	{
+		pfe_emac_cfg_set_broadcast(emac->emac_base_va, TRUE);
+	}
 }
 
 /**
@@ -890,11 +957,12 @@ void pfe_emac_disable_broadcast(const pfe_emac_t *emac)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	pfe_emac_cfg_set_broadcast(emac->emac_base_va, FALSE);
+	{
+		pfe_emac_cfg_set_broadcast(emac->emac_base_va, FALSE);
+	}
 }
 
 void pfe_emac_get_flow_control(const pfe_emac_t *emac, bool_t *tx_enable, bool_t *rx_enable)
@@ -904,11 +972,13 @@ void pfe_emac_get_flow_control(const pfe_emac_t *emac, bool_t *tx_enable, bool_t
 		unlikely(NULL == rx_enable))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-	pfe_emac_cfg_get_tx_flow_control(emac->emac_base_va,tx_enable);
-	pfe_emac_cfg_get_rx_flow_control(emac->emac_base_va,rx_enable);
+	{
+		pfe_emac_cfg_get_tx_flow_control(emac->emac_base_va,tx_enable);
+		pfe_emac_cfg_get_rx_flow_control(emac->emac_base_va,rx_enable);
+	}
 }
 
 /**
@@ -922,11 +992,12 @@ void pfe_emac_enable_tx_flow_control(const pfe_emac_t *emac)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	pfe_emac_cfg_set_tx_flow_control(emac->emac_base_va, TRUE);
+	{
+		pfe_emac_cfg_set_tx_flow_control(emac->emac_base_va, TRUE);
+	}
 }
 
 /**
@@ -940,11 +1011,12 @@ void pfe_emac_disable_tx_flow_control(const pfe_emac_t *emac)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
+    else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	pfe_emac_cfg_set_tx_flow_control(emac->emac_base_va, FALSE);
+    {
+		pfe_emac_cfg_set_tx_flow_control (emac->emac_base_va, FALSE);
+    }
 }
 
 /**
@@ -955,14 +1027,15 @@ void pfe_emac_disable_tx_flow_control(const pfe_emac_t *emac)
 void pfe_emac_enable_rx_flow_control(const pfe_emac_t *emac)
 {
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-        if (unlikely(NULL == emac))
-        {
-                NXP_LOG_ERROR("NULL argument received\n");
-                return;
-        }
+	if (unlikely(NULL == emac))
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
+	{
         pfe_emac_cfg_set_rx_flow_control(emac->emac_base_va, TRUE);
+	}
 }
 
 /**
@@ -973,14 +1046,15 @@ void pfe_emac_enable_rx_flow_control(const pfe_emac_t *emac)
 void pfe_emac_disable_rx_flow_control(const pfe_emac_t *emac)
 {
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-        if (unlikely(NULL == emac))
-        {
-                NXP_LOG_ERROR("NULL argument received\n");
-                return;
-        }
+	if (unlikely(NULL == emac))
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
+	{
         pfe_emac_cfg_set_rx_flow_control(emac->emac_base_va, FALSE);
+	}
 }
 
 
@@ -998,16 +1072,17 @@ errno_t pfe_emac_set_max_frame_length(const pfe_emac_t *emac, uint32_t len)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	ret = pfe_emac_cfg_set_max_frame_length(emac->emac_base_va, len);
-	if (EOK != ret)
 	{
-		NXP_LOG_ERROR("Attempt to set unsupported frame length value\n");
+		ret = pfe_emac_cfg_set_max_frame_length(emac->emac_base_va, len);
+		if (EOK != ret)
+		{
+			NXP_LOG_ERROR("Attempt to set unsupported frame length value\n");
+		}
 	}
-
 	return ret;
 }
 
@@ -1018,15 +1093,19 @@ errno_t pfe_emac_set_max_frame_length(const pfe_emac_t *emac, uint32_t len)
  */
 pfe_emac_mii_mode_t pfe_emac_get_mii_mode(const pfe_emac_t *emac)
 {
+	pfe_emac_mii_mode_t mii_mode;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EMAC_MODE_INVALID;
+		mii_mode = EMAC_MODE_INVALID;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	return emac->mode;
+	{
+		mii_mode = emac->mode;
+	}
+	return mii_mode;
 }
 
 /**
@@ -1044,11 +1123,13 @@ errno_t pfe_emac_get_link_config(const pfe_emac_t *emac, pfe_emac_speed_t *speed
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	ret = pfe_emac_cfg_get_link_config(emac->emac_base_va, speed, duplex);
+	{
+		ret = pfe_emac_cfg_get_link_config(emac->emac_base_va, speed, duplex);
+	}
 
 	return ret;
 }
@@ -1069,12 +1150,13 @@ errno_t pfe_emac_get_link_status(const pfe_emac_t *emac, pfe_emac_link_speed_t *
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	ret = pfe_emac_cfg_get_link_status(emac->emac_base_va, link_speed, duplex, link);
-
+	{
+		ret = pfe_emac_cfg_get_link_status(emac->emac_base_va, link_speed, duplex, link);
+	}
 	return ret;
 }
 
@@ -1087,17 +1169,19 @@ errno_t pfe_emac_get_link_status(const pfe_emac_t *emac, pfe_emac_link_speed_t *
  */
 errno_t pfe_emac_set_link_speed(const pfe_emac_t *emac, pfe_emac_speed_t link_speed)
 {
-	errno_t ret = EOK;
+	errno_t ret;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	ret = pfe_emac_cfg_set_speed(emac->emac_base_va, link_speed);
+	{
+		ret = pfe_emac_cfg_set_speed(emac->emac_base_va, link_speed);
+	}
 
 	return ret;
 }
@@ -1117,11 +1201,13 @@ errno_t pfe_emac_set_link_duplex(const pfe_emac_t *emac, pfe_emac_duplex_t duple
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	ret = pfe_emac_cfg_set_duplex(emac->emac_base_va, duplex);
+	{
+		ret = pfe_emac_cfg_set_duplex(emac->emac_base_va, duplex);
+	}
 
 	return ret;
 }
@@ -1140,57 +1226,56 @@ errno_t pfe_emac_flush_mac_addrs(pfe_emac_t *emac, pfe_emac_crit_t crit, pfe_mac
 {
 	const pfe_mac_addr_db_entry_t *entry = NULL;
 	LLIST_t *item, *tmp_item;
-	errno_t ret;
+	errno_t ret = EOK;
 	pfe_mac_addr_t addr;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-	if (EOK != oal_mutex_lock(&emac->mutex))
 	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
+		if (EOK != oal_mutex_lock(&emac->mutex))
+		{
+			NXP_LOG_DEBUG("Mutex lock failed\n");
+		}
 
-	LLIST_ForEachRemovable(item, tmp_item, &emac->mac_addr_list)
-	{
-		entry = LLIST_Data(item, pfe_mac_addr_db_entry_t, iterator);
-		if ((NULL != entry) && (entry->owner == owner))
+		LLIST_ForEachRemovable(item, tmp_item, &emac->mac_addr_list)
 		{
-			(void)memcpy(addr, entry->addr, sizeof(pfe_mac_addr_t));
-			if (TRUE == pfe_emac_flush_criterion_eval(entry, crit, type, owner))
+			entry = LLIST_Data(item, pfe_mac_addr_db_entry_t, iterator);
+			if ((NULL != entry) && (entry->owner == owner))
 			{
-				ret = pfe_emac_del_addr_nolock(emac, entry->addr, entry->owner);
-				if (EOK != ret)
+				(void)memcpy(addr, entry->addr, sizeof(pfe_mac_addr_t));
+				if (TRUE == pfe_emac_flush_criterion_eval(entry, crit, type, owner))
 				{
-					NXP_LOG_WARNING("Can't remove MAC address within the flush function\n");
-					if (EOK != oal_mutex_unlock(&emac->mutex))
+					ret = pfe_emac_del_addr_nolock(emac, entry->addr, entry->owner);
+					if (EOK != ret)
 					{
-						NXP_LOG_DEBUG("Mutex unlock failed\n");
+						NXP_LOG_WARNING("Can't remove MAC address within the flush function\n");
+						break;
+					}
+					else
+					{
+						NXP_LOG_DEBUG("Address %02x:%02x:%02x:%02x:%02x:%02x removed from owner ID %d\n", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5], owner);
 					}
-					return ret;
-				}
-				else
-				{
-					NXP_LOG_DEBUG("Address %02x:%02x:%02x:%02x:%02x:%02x removed from owner ID %d\n", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5], owner);
 				}
 			}
+			else
+			{
+				;
+			}
 		}
-		else
+
+		if (EOK != oal_mutex_unlock(&emac->mutex))
 		{
-			;
+			NXP_LOG_DEBUG("Mutex unlock failed\n");
 		}
 	}
 
-	if (EOK != oal_mutex_unlock(&emac->mutex))
-	{
-		NXP_LOG_DEBUG("Mutex unlock failed\n");
-	}
-
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1211,19 +1296,22 @@ errno_t pfe_emac_del_addr(pfe_emac_t *emac, const pfe_mac_addr_t addr, pfe_drv_i
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-	if (EOK != oal_mutex_lock(&emac->mutex))
 	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
+		if (EOK != oal_mutex_lock(&emac->mutex))
+		{
+			NXP_LOG_DEBUG("Mutex lock failed\n");
+		}
 
-	ret = pfe_emac_del_addr_nolock(emac, addr, owner);
+		ret = pfe_emac_del_addr_nolock(emac, addr, owner);
 
-	if (EOK != oal_mutex_unlock(&emac->mutex))
-	{
-		NXP_LOG_DEBUG("Mutex unlock failed\n");
+		if (EOK != oal_mutex_unlock(&emac->mutex))
+		{
+			NXP_LOG_DEBUG("Mutex unlock failed\n");
+		}
 	}
 
 	return ret;
@@ -1248,64 +1336,65 @@ static errno_t pfe_emac_del_addr_nolock(pfe_emac_t *emac, const pfe_mac_addr_t a
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	/*	Get address entry from the internal DB */
-	entry = pfe_emac_addr_db_find_by_addr(emac, addr, owner);
-
-	if (NULL == entry)
-	{
-		return ENOENT;
-	}
-
-	/*	Remember the entry */
-	local_entry = *entry;
-
-	/*	Remove the entry form DB */
-	ret = pfe_emac_addr_db_del_entry(emac, entry);
-
-	if (EOK != ret)
-	{
-		return ret;
+		ret = EINVAL;
 	}
 	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		/*	Release the entry */
-		oal_mm_free(entry);
-		entry = NULL;
-	}
+		/*	Get address entry from the internal DB */
+		entry = pfe_emac_addr_db_find_by_addr(emac, addr, owner);
 
-	if (TRUE == local_entry.in_hash_grp)
-	{
-		/*	Check if the hash group the address belongs to contains another addresses */
-		if (NULL != pfe_emac_addr_db_find_by_hash(emac, local_entry.hash))
+		if (NULL == entry)
 		{
-			/*	Hash group contains more addresses. Keep the HW configured. */
-			;
+			ret = ENOENT;
 		}
 		else
 		{
-			/*	Configure the HW */
-			pfe_emac_cfg_set_hash_group(emac->emac_base_va, local_entry.hash, FALSE);
-		}
-	}
-	else
-	{
-		pfe_mac_addr_t zero_addr;
+			/*	Remember the entry */
+			local_entry = *entry;
+
+			/*	Remove the entry form DB */
+			ret = pfe_emac_addr_db_del_entry(emac, entry);
+
+			if (EOK == ret)
+			{
+				/*	Release the entry */
+				oal_mm_free(entry);
+				entry = NULL;
+
+				/* eventhought the entry pointer is freed the local_entry still store the value of the entry pointer */
+				if (TRUE == local_entry.in_hash_grp)
+				{
+					/*	Check if the hash group the address belongs to contains another addresses */
+					if (NULL != pfe_emac_addr_db_find_by_hash(emac, local_entry.hash))
+					{
+						/*	Hash group contains more addresses. Keep the HW configured. */
+						;
+					}
+					else
+					{
+						/*	Configure the HW */
+						pfe_emac_cfg_set_hash_group(emac->emac_base_va, local_entry.hash, FALSE);
+					}
+				}
+				else
+				{
+					pfe_mac_addr_t zero_addr;
 
-		/*	Prepare zero-filled address */
-		(void)memset(zero_addr, 0, sizeof(pfe_mac_addr_t));
+					/*	Prepare zero-filled address */
+					(void)memset(zero_addr, 0, sizeof(pfe_mac_addr_t));
 
-		/*	Clear the specific slot */
-		pfe_emac_cfg_write_addr_slot(emac->emac_base_va, zero_addr, local_entry.addr_slot_idx);
+					/*	Clear the specific slot */
+					pfe_emac_cfg_write_addr_slot(emac->emac_base_va, zero_addr, local_entry.addr_slot_idx);
 
-		/*	Mark the slot as unused */
-		emac->mac_addr_slots &= ~(1U << local_entry.addr_slot_idx);
+					/*	Mark the slot as unused */
+					emac->mac_addr_slots &= ~(1U << local_entry.addr_slot_idx);
+				}
+			}
+		}
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1329,95 +1418,84 @@ errno_t pfe_emac_add_addr(pfe_emac_t *emac, const pfe_mac_addr_t addr, pfe_drv_i
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-	if (EOK != oal_mutex_lock(&emac->mutex))
-	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
-
-	/*	Check if address is already registered */
-	entry = pfe_emac_addr_db_find_by_addr(emac, addr, owner);
-
-	if (NULL != entry)
 	{
-		if (EOK != oal_mutex_unlock(&emac->mutex))
+		if (EOK != oal_mutex_lock(&emac->mutex))
 		{
-			NXP_LOG_DEBUG("Mutex unlock failed\n");
+			NXP_LOG_DEBUG("Mutex lock failed\n");
 		}
-		/*	Duplicates are not allowed */
-		return EEXIST;
-	}
 
-	/*	Try to get free individual address slot */
-	for (slot=0U; slot<EMAC_CFG_INDIVIDUAL_ADDR_SLOTS_COUNT; slot++)
-	{
-		if (0U == (emac->mac_addr_slots & (1U << slot)))
+		/*	Check if address is already registered */
+		entry = pfe_emac_addr_db_find_by_addr(emac, addr, owner);
+
+		if (NULL != entry)
 		{
-			/*	Found */
-			break;
+			/*	Duplicates are not allowed */
+			ret = EEXIST;
 		}
-	}
-
-	/* Slots are full, add hash of the address into the hash table */
-	if (EMAC_CFG_INDIVIDUAL_ADDR_SLOTS_COUNT == slot)
-	{
-		if (pfe_emac_is_broad(addr))
+		else
 		{
-			if (EOK != oal_mutex_unlock(&emac->mutex))
+			/*	Try to get free individual address slot */
+			for (slot=0U; slot<EMAC_CFG_INDIVIDUAL_ADDR_SLOTS_COUNT; slot++)
 			{
-				NXP_LOG_DEBUG("Mutex unlock failed\n");
+				if (0U == (emac->mac_addr_slots & (1U << slot)))
+				{
+					/*	Found */
+					break;
+				}
 			}
 
-			/*	Can't add broadcast address */
-			return EINVAL;
-		}
+			/* Slots are full, add hash of the address into the hash table */
+			if (EMAC_CFG_INDIVIDUAL_ADDR_SLOTS_COUNT == slot)
+			{
+				if (pfe_emac_is_broad(addr))
+				{
+					/*	Can't add broadcast address */
+					ret = EINVAL;
+				}
+				else
+				{
 
-		/*	Get the hash */
-		hash = pfe_emac_cfg_get_hash(emac->emac_base_va, addr);
+					/*	Get the hash */
+					hash = pfe_emac_cfg_get_hash(emac->emac_base_va, addr);
 
-		/*	Store address into EMAC's internal DB together with 'in_hash_grp' flag and hash */
-		ret = pfe_emac_addr_db_add(emac, addr, TRUE, hash, owner);
-		if (EOK != ret)
-		{
-			if (EOK != oal_mutex_unlock(&emac->mutex))
+					/*	Store address into EMAC's internal DB together with 'in_hash_grp' flag and hash */
+					ret = pfe_emac_addr_db_add(emac, addr, TRUE, hash, owner);
+
+					if (EOK == ret)
+					{
+						/*	Configure the HW */
+						pfe_emac_cfg_set_hash_group(emac->emac_base_va, hash, TRUE);
+					}
+				}
+			}
+			/* There is free address slot, use it */
+			else
 			{
-				NXP_LOG_DEBUG("Mutex unlock failed\n");
+				/*	Add address into the internal DB together with slot index */
+				ret = pfe_emac_addr_db_add(emac, addr, FALSE, slot, owner);
+
+				if (EOK == ret)
+				{
+					/*	Mark the slot as used */
+					emac->mac_addr_slots |= (1U << slot);
+
+					/*	Write the address to HW as individual address */
+					pfe_emac_cfg_write_addr_slot(emac->emac_base_va, addr, (uint8_t)slot);
+				}
 			}
-			return ret;
 		}
 
-		/*	Configure the HW */
-		pfe_emac_cfg_set_hash_group(emac->emac_base_va, hash, TRUE);
-	}
-	/* There is free address slot, use it */
-	else
-	{
-		/*	Add address into the internal DB together with slot index */
-		ret = pfe_emac_addr_db_add(emac, addr, FALSE, slot, owner);
-		if (EOK != ret)
+		if (EOK != oal_mutex_unlock(&emac->mutex))
 		{
-			if (EOK != oal_mutex_unlock(&emac->mutex))
-			{
-				NXP_LOG_DEBUG("Mutex unlock failed\n");
-			}
-			return ret;
+			NXP_LOG_DEBUG("Mutex unlock failed\n");
 		}
-
-		/*	Mark the slot as used */
-		emac->mac_addr_slots |= (1U << slot);
-
-		/*	Write the address to HW as individual address */
-		pfe_emac_cfg_write_addr_slot(emac->emac_base_va, addr, (uint8_t)slot);
 	}
 
-	if (EOK != oal_mutex_unlock(&emac->mutex))
-	{
-		NXP_LOG_DEBUG("Mutex unlock failed\n");
-	}
-
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1430,43 +1508,46 @@ errno_t pfe_emac_add_addr(pfe_emac_t *emac, const pfe_mac_addr_t addr, pfe_drv_i
 errno_t pfe_emac_get_addr(pfe_emac_t *emac, pfe_mac_addr_t addr)
 {
 	const pfe_mac_addr_db_entry_t *entry;
+	errno_t ret = EOK;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-	if (EOK != oal_mutex_lock(&emac->mutex))
 	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
+		if (EOK != oal_mutex_lock(&emac->mutex))
+		{
+			NXP_LOG_DEBUG("Mutex lock failed\n");
+		}
 
-	/*	Return address from the 0th individual address slot */
-	entry = pfe_emac_addr_db_find_by_slot(emac, 0U);
-	if (NULL == entry)
-	{
-		/*	Individual slots are empty. Check if there is something in the hash table. */
-		entry = pfe_emac_addr_db_get_first(emac);
+		/*	Return address from the 0th individual address slot */
+		entry = pfe_emac_addr_db_find_by_slot(emac, 0U);
 		if (NULL == entry)
 		{
-			if (EOK != oal_mutex_unlock(&emac->mutex))
+			/*	Individual slots are empty. Check if there is something in the hash table. */
+			entry = pfe_emac_addr_db_get_first(emac);
+			if (NULL == entry)
 			{
-				NXP_LOG_DEBUG("Mutex unlock failed\n");
+				ret = ENOENT;
 			}
-			return ENOENT;
 		}
-	}
 
-	(void)memcpy(addr, entry->addr, sizeof(pfe_mac_addr_t));
+		if (EOK == ret)
+		{
+			(void)memcpy(addr, entry->addr, sizeof(pfe_mac_addr_t));
+		}
 
-	if (EOK != oal_mutex_unlock(&emac->mutex))
-	{
-		NXP_LOG_DEBUG("Mutex unlock failed\n");
+		if (EOK != oal_mutex_unlock(&emac->mutex))
+		{
+			NXP_LOG_DEBUG("Mutex unlock failed\n");
+		}
 	}
 
-	return EOK;
+	return ret;
 }
 
 /**
@@ -1539,32 +1620,34 @@ errno_t pfe_emac_mdio_lock(pfe_emac_t *emac, uint32_t *key)
 	if (unlikely((NULL == emac) || (NULL == key)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (EOK != oal_mutex_lock(&emac->mutex))
 	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
+		if (EOK != oal_mutex_lock(&emac->mutex))
+		{
+			NXP_LOG_DEBUG("Mutex lock failed\n");
+		}
 
-	if (TRUE == emac->mdio_locked)
-	{
-		ret = EPERM;
-	}
-	else
-	{
-		/*	Perform lock + generate and store access key */
-		emac->mdio_locked = TRUE;
-		emac->mdio_key = key_seed;
-		key_seed++;
-		*key = emac->mdio_key;
-		ret = EOK;
-	}
+		if (TRUE == emac->mdio_locked)
+		{
+			ret = EPERM;
+		}
+		else
+		{
+			/*	Perform lock + generate and store access key */
+			emac->mdio_locked = TRUE;
+			emac->mdio_key = key_seed;
+			key_seed++;
+			*key = emac->mdio_key;
+			ret = EOK;
+		}
 
-	if (EOK != oal_mutex_unlock(&emac->mutex))
-	{
-		NXP_LOG_DEBUG("Mutex unlock failed\n");
+		if (EOK != oal_mutex_unlock(&emac->mutex))
+		{
+			NXP_LOG_DEBUG("Mutex unlock failed\n");
+		}
 	}
 
 	return ret;
@@ -1585,35 +1668,37 @@ errno_t pfe_emac_mdio_unlock(pfe_emac_t *emac, uint32_t key)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (EOK != oal_mutex_lock(&emac->mutex))
 	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
+		if (EOK != oal_mutex_lock(&emac->mutex))
+		{
+			NXP_LOG_DEBUG("Mutex lock failed\n");
+		}
 
-	if (TRUE == emac->mdio_locked)
-	{
-		if (key == emac->mdio_key)
+		if (TRUE == emac->mdio_locked)
 		{
-			emac->mdio_locked = FALSE;
-			ret = EOK;
+			if (key == emac->mdio_key)
+			{
+				emac->mdio_locked = FALSE;
+				ret = EOK;
+			}
+			else
+			{
+				ret = EPERM;
+			}
 		}
 		else
 		{
-			ret = EPERM;
+			ret = ENOLCK;
 		}
-	}
-	else
-	{
-		ret = ENOLCK;
-	}
 
-	if (EOK != oal_mutex_unlock(&emac->mutex))
-	{
-		NXP_LOG_DEBUG("Mutex unlock failed\n");
+		if (EOK != oal_mutex_unlock(&emac->mutex))
+		{
+			NXP_LOG_DEBUG("Mutex unlock failed\n");
+		}
 	}
 
 	return ret;
@@ -1636,36 +1721,38 @@ errno_t pfe_emac_mdio_read22(pfe_emac_t *emac, uint8_t pa, uint8_t ra, uint16_t
 	if (unlikely((NULL == emac) || (NULL == val)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (EOK != oal_mutex_lock(&emac->mutex))
 	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
+		if (EOK != oal_mutex_lock(&emac->mutex))
+		{
+			NXP_LOG_DEBUG("Mutex lock failed\n");
+		}
 
-	if (TRUE == emac->mdio_locked)
-	{
-		/*	Locked. Check key. */
-		if (key == emac->mdio_key)
+		if (TRUE == emac->mdio_locked)
 		{
-			ret = pfe_emac_cfg_mdio_read22(emac->emac_base_va, pa, ra, val);
+			/*	Locked. Check key. */
+			if (key == emac->mdio_key)
+			{
+				ret = pfe_emac_cfg_mdio_read22(emac->emac_base_va, pa, ra, val);
+			}
+			else
+			{
+				ret = EPERM;
+			}
 		}
 		else
 		{
-			ret = EPERM;
+			/*	Unlocked. No check required. */
+			ret = pfe_emac_cfg_mdio_read22(emac->emac_base_va, pa, ra, val);
 		}
-	}
-	else
-	{
-		/*	Unlocked. No check required. */
-		ret = pfe_emac_cfg_mdio_read22(emac->emac_base_va, pa, ra, val);
-	}
 
-	if (EOK != oal_mutex_unlock(&emac->mutex))
-	{
-		NXP_LOG_DEBUG("Mutex unlock failed\n");
+		if (EOK != oal_mutex_unlock(&emac->mutex))
+		{
+			NXP_LOG_DEBUG("Mutex unlock failed\n");
+		}
 	}
 
 	return ret;
@@ -1688,38 +1775,39 @@ errno_t pfe_emac_mdio_write22(pfe_emac_t *emac, uint8_t pa, uint8_t ra, uint16_t
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (EOK != oal_mutex_lock(&emac->mutex))
 	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
+		if (EOK != oal_mutex_lock(&emac->mutex))
+		{
+			NXP_LOG_DEBUG("Mutex lock failed\n");
+		}
 
-	if (TRUE == emac->mdio_locked)
-	{
-		/*	Locked. Check key. */
-		if (key == emac->mdio_key)
+		if (TRUE == emac->mdio_locked)
 		{
-			ret = pfe_emac_cfg_mdio_write22(emac->emac_base_va, pa, ra, val);
+			/*	Locked. Check key. */
+			if (key == emac->mdio_key)
+			{
+				ret = pfe_emac_cfg_mdio_write22(emac->emac_base_va, pa, ra, val);
+			}
+			else
+			{
+				ret = EPERM;
+			}
 		}
 		else
 		{
-			ret = EPERM;
+			/*	Unlocked. No check required. */
+			ret = pfe_emac_cfg_mdio_write22(emac->emac_base_va, pa, ra, val);
 		}
-	}
-	else
-	{
-		/*	Unlocked. No check required. */
-		ret = pfe_emac_cfg_mdio_write22(emac->emac_base_va, pa, ra, val);
-	}
 
-	if (EOK != oal_mutex_unlock(&emac->mutex))
-	{
-		NXP_LOG_DEBUG("Mutex unlock failed\n");
+		if (EOK != oal_mutex_unlock(&emac->mutex))
+		{
+			NXP_LOG_DEBUG("Mutex unlock failed\n");
+		}
 	}
-
 	return ret;
 }
 
@@ -1741,36 +1829,38 @@ errno_t pfe_emac_mdio_read45(pfe_emac_t *emac, uint8_t pa, uint8_t dev, uint16_t
 	if (unlikely((NULL == emac) || (NULL == val)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (EOK != oal_mutex_lock(&emac->mutex))
 	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
+		if (EOK != oal_mutex_lock(&emac->mutex))
+		{
+			NXP_LOG_DEBUG("Mutex lock failed\n");
+		}
 
-	if (TRUE == emac->mdio_locked)
-	{
-		/*	Locked. Check key. */
-		if (key == emac->mdio_key)
+		if (TRUE == emac->mdio_locked)
 		{
-			ret = pfe_emac_cfg_mdio_read45(emac->emac_base_va, pa, dev, ra, val);
+			/*	Locked. Check key. */
+			if (key == emac->mdio_key)
+			{
+				ret = pfe_emac_cfg_mdio_read45(emac->emac_base_va, pa, dev, ra, val);
+			}
+			else
+			{
+				ret = EPERM;
+			}
 		}
 		else
 		{
-			ret = EPERM;
+			/*	Unlocked. No check required. */
+			ret = pfe_emac_cfg_mdio_read45(emac->emac_base_va, pa, dev, ra, val);
 		}
-	}
-	else
-	{
-		/*	Unlocked. No check required. */
-		ret = pfe_emac_cfg_mdio_read45(emac->emac_base_va, pa, dev, ra, val);
-	}
 
-	if (EOK != oal_mutex_unlock(&emac->mutex))
-	{
-		NXP_LOG_DEBUG("Mutex unlock failed\n");
+		if (EOK != oal_mutex_unlock(&emac->mutex))
+		{
+			NXP_LOG_DEBUG("Mutex unlock failed\n");
+		}
 	}
 
 	return ret;
@@ -1794,36 +1884,38 @@ errno_t pfe_emac_mdio_write45(pfe_emac_t *emac, uint8_t pa, uint8_t dev, uint16_
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (EOK != oal_mutex_lock(&emac->mutex))
 	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
+		if (EOK != oal_mutex_lock(&emac->mutex))
+		{
+			NXP_LOG_DEBUG("Mutex lock failed\n");
+		}
 
-	if (TRUE == emac->mdio_locked)
-	{
-		/*	Locked. Check key. */
-		if (key == emac->mdio_key)
+		if (TRUE == emac->mdio_locked)
 		{
-			ret = pfe_emac_cfg_mdio_write45(emac->emac_base_va, pa, dev, ra, val);
+			/*	Locked. Check key. */
+			if (key == emac->mdio_key)
+			{
+				ret = pfe_emac_cfg_mdio_write45(emac->emac_base_va, pa, dev, ra, val);
+			}
+			else
+			{
+				ret = EPERM;
+			}
 		}
 		else
 		{
-			ret = EPERM;
+			/*	Unlocked. No check required. */
+			ret = pfe_emac_cfg_mdio_write45(emac->emac_base_va, pa, dev, ra, val);
 		}
-	}
-	else
-	{
-		/*	Unlocked. No check required. */
-		ret = pfe_emac_cfg_mdio_write45(emac->emac_base_va, pa, dev, ra, val);
-	}
 
-	if (EOK != oal_mutex_unlock(&emac->mutex))
-	{
-		NXP_LOG_DEBUG("Mutex unlock failed\n");
+		if (EOK != oal_mutex_unlock(&emac->mutex))
+		{
+			NXP_LOG_DEBUG("Mutex unlock failed\n");
+		}
 	}
 
 	return ret;
@@ -1836,15 +1928,19 @@ errno_t pfe_emac_mdio_write45(pfe_emac_t *emac, uint8_t pa, uint8_t dev, uint16_
  */
 uint32_t pfe_emac_get_rx_cnt(const pfe_emac_t *emac)
 {
+	uint32_t rx_cnt;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return 0xffffffffU;
+		rx_cnt = 0xFFFFFFFFU;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	return pfe_emac_cfg_get_rx_cnt(emac->emac_base_va);
+	{
+		rx_cnt = pfe_emac_cfg_get_rx_cnt(emac->emac_base_va);
+	}
+	return rx_cnt;
 }
 
 /**
@@ -1854,15 +1950,19 @@ uint32_t pfe_emac_get_rx_cnt(const pfe_emac_t *emac)
  */
 uint32_t pfe_emac_get_tx_cnt(const pfe_emac_t *emac)
 {
+	uint32_t tx_cnt;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return 0xffffffffU;
+		tx_cnt = 0xFFFFFFFFU;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	return pfe_emac_cfg_get_tx_cnt(emac->emac_base_va);
+	{
+		tx_cnt = pfe_emac_cfg_get_tx_cnt(emac->emac_base_va);
+	}
+	return tx_cnt;
 }
 
 /**
@@ -1882,11 +1982,13 @@ uint32_t pfe_emac_get_text_statistics(const pfe_emac_t *emac, char_t *buf, uint3
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return 0;
+		len = 0U;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-	len += pfe_emac_cfg_get_text_stat(emac->emac_base_va, buf + len, buf_len - len, verb_level);
-
+	{
+		len += pfe_emac_cfg_get_text_stat(emac->emac_base_va, buf + len, buf_len - len, verb_level);
+	}
 	return len;
 }
 
@@ -1900,13 +2002,17 @@ uint32_t pfe_emac_get_text_statistics(const pfe_emac_t *emac, char_t *buf, uint3
  */
 uint32_t pfe_emac_get_stat_value(const pfe_emac_t *emac, uint32_t stat_id)
 {
+	uint32_t stat_value;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == emac))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return 0xFFFFFFFFU;
+		stat_value = 0xFFFFFFFFU;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	return pfe_emac_cfg_get_stat_value(emac->emac_base_va, stat_id);
+	{
+		stat_value = pfe_emac_cfg_get_stat_value(emac->emac_base_va, stat_id);
+	}
+	return stat_value;
 }
diff --git a/sw/pfe_platform/src/pfe_feature_mgr.c b/sw/pfe_platform/src/pfe_feature_mgr.c
index 6a1ce39..88d5d24 100644
--- a/sw/pfe_platform/src/pfe_feature_mgr.c
+++ b/sw/pfe_platform/src/pfe_feature_mgr.c
@@ -35,15 +35,15 @@
 
 typedef struct
 {
-	uint32_t *cbus_base;
-	uint32_t current_hw_feature;	/* Index of the hw feature to return by pfe_hw_get_feature_next() */
-	pfe_hw_feature_t **hw_features;	/* List of all hw features*/
-	uint32_t hw_features_count;		/* Number of items in hw_features */
+	uint32_t *         cbus_base;
+	uint32_t           current_hw_feature; /* Index of the hw feature to return by pfe_hw_get_feature_next() */
+	pfe_hw_feature_t **hw_features;        /* List of all hw features*/
+	uint32_t           hw_features_count;  /* Number of items in hw_features */
 
-	bool_t rewind_flg;				/* Internal flag supporting transition walk from hw_feature set to fw_feature set */
+	bool_t rewind_flg; /* Internal flag supporting transition walk from hw_feature set to fw_feature set */
 	pfe_class_t *class;
 	pfe_util_t *util;
-	pfe_tmu_t *tmu;					/* Included because of err051211_workaround */
+	pfe_tmu_t * tmu; /* Included because of err051211_workaround */
 } pfe_feature_mgr_t;
 
 static errno_t pfe_hw_get_feature(const pfe_feature_mgr_t *fmgr, pfe_hw_feature_t **feature, const char *name);
@@ -64,35 +64,37 @@ static pfe_feature_mgr_t *feature_mgr = NULL;
  */
 errno_t pfe_feature_mgr_init(uint32_t *cbus_base)
 {
-	errno_t ret = EOK;
+	errno_t ret;
 
-	#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if(NULL == cbus_base)
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == cbus_base)
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-	#endif
-
-	if(NULL == feature_mgr)
+	else
+#endif
 	{
-		feature_mgr = oal_mm_malloc(sizeof(pfe_feature_mgr_t));
-		if(NULL != feature_mgr)
+		if (NULL == feature_mgr)
 		{
-			(void)memset(feature_mgr, 0, sizeof(pfe_feature_mgr_t));
-			feature_mgr->cbus_base = cbus_base;
-			feature_mgr->hw_features = oal_mm_malloc(1U * sizeof(pfe_hw_feature_t *));
-			ret = pfe_hw_feature_init_all(cbus_base, feature_mgr->hw_features, &feature_mgr->hw_features_count);
+			feature_mgr = oal_mm_malloc(sizeof(pfe_feature_mgr_t));
+			if (NULL != feature_mgr)
+			{
+				(void)memset(feature_mgr, 0, sizeof(pfe_feature_mgr_t));
+				feature_mgr->cbus_base = cbus_base;
+				feature_mgr->hw_features = oal_mm_malloc(2U * sizeof(pfe_hw_feature_t *));
+				ret = pfe_hw_feature_init_all(cbus_base, feature_mgr->hw_features, &feature_mgr->hw_features_count);
+			}
+			else
+			{
+				ret = ENOMEM;
+			}
 		}
 		else
 		{
-			ret = ENOMEM;
+			ret = EPERM;
 		}
 	}
-	else
-	{
-		ret = EPERM;
-	}
 
 	return ret;
 }
@@ -106,26 +108,29 @@ errno_t pfe_feature_mgr_init(uint32_t *cbus_base)
  */
 errno_t pfe_feature_mgr_add_modules(pfe_class_t *class, pfe_util_t *util, pfe_tmu_t *tmu)
 {
-	errno_t ret = EOK;
+	errno_t ret;
 
-	#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if((NULL == class) || (NULL == tmu))
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if ((NULL == class) || (NULL == tmu))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-	/* Note it is OK for "util" to be NULL */
-	#endif
-
-	if(NULL != feature_mgr)
+	else
+/* Note it is OK for "util" to be NULL */
+#endif
 	{
+		if (NULL != feature_mgr)
+		{
 			feature_mgr->class = class;
 			feature_mgr->util = util;
 			feature_mgr->tmu = tmu;
-	}
-	else
-	{
-		ret = EPERM;
+			ret = EOK;
+		}
+		else
+		{
+			ret = EPERM;
+		}
 	}
 
 	return ret;
@@ -139,7 +144,7 @@ errno_t pfe_feature_mgr_fini(void)
 {
 	errno_t ret;
 
-	if(NULL == feature_mgr)
+	if (NULL == feature_mgr)
 	{
 		ret = EEXIST;
 	}
@@ -166,127 +171,156 @@ bool_t pfe_feature_mgr_is_available(const char *feature_name)
 	pfe_hw_feature_t *hw_feature;
 	pfe_fw_feature_t *fw_feature_class;
 	pfe_fw_feature_t *fw_feature_util;
-	errno_t ret_class, ret_util;
-	bool_t class_avail = FALSE;
-	bool_t util_avail = FALSE;
-	errno_t ret_hw;
+	errno_t           ret_class, ret_util;
+	bool_t            class_avail = FALSE;
+	bool_t            util_avail = FALSE;
+	bool_t            ret = FALSE;
+	errno_t           ret_hw;
 
-	#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if(NULL == feature_name)
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name)
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return FALSE;
+		ret = FALSE;
 	}
-	#endif
-
-	if(NULL == feature_mgr)
+	else
+#endif
 	{
-		NXP_LOG_ERROR("Feature Mgr not initialized\n");
-		return FALSE;
-	}
-
-
-	ret_hw = pfe_hw_get_feature(feature_mgr, &hw_feature, feature_name);
-	if(EOK == ret_hw)
-	{	/* Descriptor in platform is available */
-		if(pfe_hw_feature_enabled(hw_feature))
-		{	/* Feature is enabled thus it is available */
-			return TRUE;
-		}
-		else
-		{	/* Feature is disabled thus it is not available */
-			return FALSE;
-		}
-	}
-
-	if (NULL == feature_mgr->class)
-	{	/* Class block is not initialized */
-		return FALSE;
-	}
-
-	ret_class = pfe_class_get_feature(feature_mgr->class, &fw_feature_class, feature_name);
-	/* Note if one of ret_class/ret_util is EOK and one is not then the data
-	   is inconsistent. In such case the one without EOK will block feature
-	   use. This situation should not happen. */
-
-	/* Analyze Class */
-	if(EOK == ret_class)
-	{	/* Descriptor in class is available */
-
-		if(TRUE == pfe_fw_feature_is_in_class(fw_feature_class))
-		{	/* This feature is applicable for class */
-
-			if(pfe_fw_feature_enabled(fw_feature_class))
-			{	/* Feature is enabled thus it is available */
-				class_avail = TRUE;
-			}
-			else
-			{	/* Feature is disabled thus it is not available */
-				class_avail = FALSE;
-			}
+		if (NULL == feature_mgr)
+		{
+			NXP_LOG_ERROR("Feature Mgr not initialized\n");
+			ret = FALSE;
 		}
 		else
-		{	/* Not applicable for class */
-			/* Do not block availability of the feature which is not applicable */
-			class_avail = TRUE;
-		}
-	}
-	else
-	{	/* Feature does not exist i.e. it is not available */
-		util_avail = FALSE;
-	}
-
-	if(NULL != feature_mgr->util)
-	{	/* Util is present */
-		ret_util = pfe_util_get_feature(feature_mgr->util, &fw_feature_util, feature_name);
-
-		/* Analyze Util */
-		if(EOK == ret_util)
-		{	/* Descriptor in util is available */
-			if(TRUE == pfe_fw_feature_is_in_util(fw_feature_util))
-			{	/* This feature is applicable for util */
+		{
 
-				if(pfe_fw_feature_enabled(fw_feature_util))
-				{	/* Feature is enabled thus it is available */
-					util_avail = TRUE;
+			ret_hw = pfe_hw_get_feature(feature_mgr, &hw_feature, feature_name);
+			if (EOK == ret_hw)
+			{
+				/* Descriptor in platform is available */
+				if (pfe_hw_feature_enabled(hw_feature))
+				{
+					/* Feature is enabled thus it is available */
+					ret = TRUE;
 				}
 				else
-				{	/* Feature is disabled thus it is not available */
-					util_avail = FALSE;
+				{
+					/* Feature is disabled thus it is not available */
+					ret = FALSE;
 				}
 			}
 			else
-			{	/* Not applicable for util */
-				/* Do not block availability of the feature which is not applicable */
-				util_avail = TRUE;
-			}
-		}
-		else
-		{	/* Feature does not exist i.e. it is not available */
-			util_avail = FALSE;
-		}
-	}
-	else
-	{	/* Util not present */
-
-		if (EOK == ret_class)
-		{
-			/* Use class information to check whether the feature requires util to be present */
-			if(pfe_fw_feature_is_in_util(fw_feature_class))
-			{
-				/* No firmware = no feature */
-				util_avail = FALSE;
-			}
-			else
 			{
-				/* Feature does not need util to be present */
-				util_avail = TRUE;
+
+				if (NULL == feature_mgr->class)
+				{
+					/* Class block is not initialized */
+					ret = FALSE;
+				}
+				else
+				{
+
+					ret_class = pfe_class_get_feature(feature_mgr->class, &fw_feature_class, feature_name);
+					/* Note if one of ret_class/ret_util is EOK and one is not then the data is inconsistent. In such case the one without EOK will block feature
+	   				use. This situation should not happen. */
+
+					/* Analyze Class */
+					if (EOK == ret_class)
+					{
+						/* Descriptor in class is available */
+
+						if (TRUE == pfe_fw_feature_is_in_class(fw_feature_class))
+						{
+							/* This feature is applicable for class */
+
+							if (pfe_fw_feature_enabled(fw_feature_class))
+							{
+								/* Feature is enabled thus it is available */
+								class_avail = TRUE;
+							}
+							else
+							{
+								/* Feature is disabled thus it is not available */
+								class_avail = FALSE;
+							}
+						}
+						else
+						{
+							/* Not applicable for class */
+							/* Do not block availability of the feature which is not applicable */
+							class_avail = TRUE;
+						}
+					}
+					else
+					{
+						/* Feature does not exist i.e. it is not available */
+						util_avail = FALSE;
+					}
+
+					if (NULL != feature_mgr->util)
+					{
+						/* Util is present */
+						ret_util = pfe_util_get_feature(feature_mgr->util, &fw_feature_util, feature_name);
+
+						/* Analyze Util */
+						if (EOK == ret_util)
+						{
+							/* Descriptor in util is available */
+							if (TRUE == pfe_fw_feature_is_in_util(fw_feature_util))
+							{
+								/* This feature is applicable for util */
+
+								if (pfe_fw_feature_enabled(fw_feature_util))
+								{
+									/* Feature is enabled thus it is available */
+									util_avail = TRUE;
+								}
+								else
+								{
+									/* Feature is disabled thus it is not available */
+									util_avail = FALSE;
+								}
+							}
+							else
+							{
+								/* Not applicable for util */
+								/* Do not block availability of the feature which is not applicable */
+								util_avail = TRUE;
+							}
+						}
+						else
+						{
+							/* Feature does not exist i.e. it is not available */
+							util_avail = FALSE;
+						}
+					}
+					else
+					{
+						/* Util not present */
+
+						if (EOK == ret_class)
+						{
+							/* Use class information to check whether the feature requires util to be present */
+							if (pfe_fw_feature_is_in_util(fw_feature_class))
+							{
+								/* No firmware = no feature */
+								util_avail = FALSE;
+							}
+							else
+							{
+								/* Feature does not need util to be present */
+								util_avail = TRUE;
+							}
+						}
+					}
+					/* Return TRUE if the feature availability is not blocked by any of class/util pair */
+					ret = ((FALSE != class_avail) && (FALSE != util_avail)) ? TRUE : FALSE;
+				}
 			}
 		}
 	}
 
-	/* Return TRUE if the feature availability is not blocked by any of class/util pair */
-	return ((FALSE != class_avail) && (FALSE != util_avail)) ? TRUE : FALSE;
+	return ret;
 }
 
 /**
@@ -300,86 +334,110 @@ errno_t pfe_feature_mgr_set_val(const char *feature_name, const uint8_t val)
 	pfe_hw_feature_t *hw_feature;
 	pfe_fw_feature_t *fw_feature_class;
 	pfe_fw_feature_t *fw_feature_util;
-	errno_t ret_class, ret_util;
-	uint8_t old_val;
-	errno_t ret = EOK;
+	pfe_ct_feature_flags_t flags;
+	errno_t           ret_class, ret_util;
+	errno_t           ret_feature;
+	uint8_t           old_val;
+	errno_t           ret = EOK;
 
-	#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if(NULL == feature_name)
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name)
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
-	}
-	#endif
-
-	if(NULL == feature_mgr)
-	{
-		NXP_LOG_ERROR("Feature Mgr not initialized\n");
-		return EINVAL;
-	}
-
-	ret = pfe_hw_get_feature(feature_mgr, &hw_feature, feature_name);
-	if(EOK == ret)
-	{	/* Feature exists */
-		ret = pfe_hw_feature_set_val(hw_feature, val);
-		return ret;
-	}
-
-	if (NULL == feature_mgr->class)
-	{	/* Class block is not initialized */
-		return EINVAL;
-	}
-
-	ret_class = pfe_class_get_feature(feature_mgr->class, &fw_feature_class, feature_name);
-	if(EOK != ret_class)
-	{	/* Feature does not exist or data is inconsistent */
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	if(NULL != feature_mgr->util)
+	else
+#endif
 	{
-		ret_util = pfe_util_get_feature(feature_mgr->util, &fw_feature_util, feature_name);
-		if(EOK != ret_util)
-		{	/* Feature does not exist or data is inconsistent */
+		if (NULL == feature_mgr)
+		{
+			NXP_LOG_ERROR("Feature Mgr not initialized\n");
 			ret = EINVAL;
-			return ret;
 		}
-	}
-
-	/* Handle the Class */
-	if(TRUE == pfe_fw_feature_is_in_class(fw_feature_class))
-	{
-		/* Backup the original value for the failure case */
-		(void )pfe_fw_feature_get_val(fw_feature_class, &old_val);
-		/* Set the new value */
-		ret = pfe_fw_feature_set_val(fw_feature_class, val);
-	}
-
-	/* Handle the Util */
-	if(NULL != feature_mgr->util)
-	{	/* Util is present */
-		/* Continue only if the previous code succeeded - we need to
-		   keep the class and util coherent */
-		if(EOK == ret)
+		else
 		{
-			if(TRUE == pfe_fw_feature_is_in_util(fw_feature_util))
+
+			ret_feature = pfe_hw_get_feature(feature_mgr, &hw_feature, feature_name);
+			if (EOK == ret_feature)
+			{ /* Feature exists */
+				ret = pfe_hw_feature_get_flags(hw_feature, &flags);
+				if (flags & F_RUNTIME)
+				{
+					ret = pfe_hw_feature_set_val(hw_feature, val);
+				}
+				else
+				{
+					ret = EFAULT;
+				}
+			}
+			else
 			{
-				ret = pfe_fw_feature_set_val(fw_feature_util, val);
-				if(EOK != ret)
-				{	/* Failure */
-					/* Revert the changes already made */
-					(void)pfe_fw_feature_set_val(fw_feature_util, old_val);
+
+				if (NULL == feature_mgr->class)
+				{ /* Class block is not initialized */
+					ret = EINVAL;
+				}
+				else
+				{
+					ret_class = pfe_class_get_feature(feature_mgr->class, &fw_feature_class, feature_name);
+					if (EOK != ret_class)
+					{ /* Feature does not exist or data is inconsistent */
+						ret = EINVAL;
+					}
+					else
+					{
+
+						if (NULL != feature_mgr->util)
+						{
+							ret_util = pfe_util_get_feature(feature_mgr->util, &fw_feature_util, feature_name);
+							if (EOK != ret_util)
+							{ /* Feature does not exist or data is inconsistent */
+								ret = EINVAL;
+							}
+						}
+
+						if (EOK == ret)
+						{
+							/* Handle the Class */
+							if (TRUE == pfe_fw_feature_is_in_class(fw_feature_class))
+							{
+								/* Backup the original value for the failure case */
+								(void)pfe_fw_feature_get_val(fw_feature_class, &old_val);
+								/* Set the new value */
+								ret = pfe_fw_feature_set_val(fw_feature_class, val);
+							}
+
+							/* Handle the Util */
+							if (NULL != feature_mgr->util)
+							{ /* Util is present */
+								/* Continue only if the previous code succeeded - we need to
+		   						keep the class and util coherent */
+								if (EOK == ret)
+								{
+									if (TRUE == pfe_fw_feature_is_in_util(fw_feature_util))
+									{
+										ret = pfe_fw_feature_set_val(fw_feature_util, val);
+										if (EOK != ret)
+										{ /* Failure */
+											/* Revert the changes already made */
+											(void)pfe_fw_feature_set_val(fw_feature_util, old_val);
+										}
+									}
+								}
+							}
+
+							/* Check/configure driver (if needed) */
+							if (EOK == ret)
+							{
+								ret = pfe_feature_mgr_configure_driver(feature_name, val);
+							}
+						}
+					}
 				}
 			}
 		}
 	}
 
-	/* Check/configure driver (if needed) */
-	if (EOK == ret)
-	{
-		ret = pfe_feature_mgr_configure_driver(feature_name, val);
-	}
-
 	return ret;
 }
 
@@ -391,83 +449,95 @@ errno_t pfe_feature_mgr_set_val(const char *feature_name, const uint8_t val)
  */
 errno_t pfe_feature_mgr_enable(const char *feature_name)
 {
-	pfe_hw_feature_t *hw_feature;
-	pfe_fw_feature_t *fw_feature_class;
+	pfe_hw_feature_t *     hw_feature;
+	pfe_fw_feature_t *     fw_feature_class;
 	pfe_ct_feature_flags_t tmp;
-	errno_t ret;
+	errno_t                ret = EINVAL;
+	errno_t                ret_class;
+	errno_t                ret_flag;
+	errno_t                ret_hw_feature;
 
-	#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if(NULL == feature_name)
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name)
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-	#endif
-
-	if(NULL == feature_mgr)
-	{
-		NXP_LOG_ERROR("Feature Mgr not initialized\n");
-		return EINVAL;
-	}
-
-	/* HW feature first */
-	ret = pfe_hw_get_feature(feature_mgr, &hw_feature, feature_name);
-	if(EOK == ret)
+	else
+#endif
 	{
-		ret = pfe_hw_feature_get_flags(hw_feature, &tmp);
-		if(EOK == ret)
+		if (NULL == feature_mgr)
 		{
-			if(0U == ((uint8_t)tmp & (uint8_t)F_PRESENT))
-			{	/* Feature cannot be enabled */
-				NXP_LOG_WARNING("Cannot enable feature %s - not present in Platform\n", feature_name);
-				return EINVAL;
-			}
-			else if(0U == ((uint8_t)tmp & (uint8_t)F_RUNTIME))
-			{	/* Feature cannot be disabled */
-				NXP_LOG_INFO("Feature %s is always enabled in Platform\n", feature_name);
-				return EOK;
-			}
-			else
-			{	/* Feature needs to be disabled */
-				return pfe_feature_mgr_set_val(feature_name, 1);
-			}
+			NXP_LOG_ERROR("Feature Mgr not initialized\n");
+			ret = EINVAL;
 		}
+		else
+		{
 
-		/* Don't continue with FW features */
-		return ret;
-	}
-
-	if (NULL == feature_mgr->class)
-	{	/* Class block is not initialized */
-		return EINVAL;
-	}
+			/* HW feature first */
+			ret_hw_feature = pfe_hw_get_feature(feature_mgr, &hw_feature, feature_name);
+			if (EOK == ret_hw_feature)
+			{
+				ret_flag = pfe_hw_feature_get_flags(hw_feature, &tmp);
+				if (EOK == ret_flag)
+				{
+					if (0U == ((uint8_t)tmp & (uint8_t)F_PRESENT))
+					{ /* Feature cannot be enabled */
+						NXP_LOG_WARNING("Cannot enable feature %s - not present in Platform\n", feature_name);
+						ret = EINVAL;
+					}
+					else if (0U == ((uint8_t)tmp & (uint8_t)F_RUNTIME))
+					{ /* Feature cannot be disabled */
+						NXP_LOG_INFO("Feature %s is always enabled in Platform\n", feature_name);
+						ret = EOK;
+					}
+					else
+					{ /* Feature needs to be enabled */
+						ret = pfe_feature_mgr_set_val(feature_name, 1);
+					}
+				}
 
-	/* Class and util share the same information thus it is
-	   enough to use just the class to get it */
-	ret = pfe_class_get_feature(feature_mgr->class, &fw_feature_class, feature_name);
-	if(EOK == ret)
-	{
-		ret = pfe_fw_feature_get_flags(fw_feature_class, &tmp);
-		if(EOK == ret)
-		{
-			if(0U == ((uint8_t)tmp & (uint8_t)F_PRESENT))
-			{	/* Feature cannot be enabled */
-				NXP_LOG_WARNING("Cannot enable feature %s - not present in FW\n", feature_name);
-				return EINVAL;
-			}
-			else if(0U == ((uint8_t)tmp & (uint8_t)F_RUNTIME))
-			{	/* Feature cannot be disabled */
-				NXP_LOG_INFO("Feature %s is always enabled in FW\n", feature_name);
-				return EOK;
+				/* Don't continue with FW features */
 			}
 			else
-			{	/* Feature needs to be disabled */
-				return pfe_feature_mgr_set_val(feature_name, 1);
+			{
+
+				if (NULL == feature_mgr->class)
+				{ /* Class block is not initialized */
+					ret = EINVAL;
+				}
+				else
+				{
+
+					/* Class and util share the same information thus it is enough to use just the class to get it */
+					ret_class = pfe_class_get_feature(feature_mgr->class, &fw_feature_class, feature_name);
+					if (EOK == ret_class)
+					{
+						ret_flag = pfe_fw_feature_get_flags(fw_feature_class, &tmp);
+						if (EOK == ret_flag)
+						{
+							if (0U == ((uint8_t)tmp & (uint8_t)F_PRESENT))
+							{ /* Feature cannot be enabled */
+								NXP_LOG_WARNING("Cannot enable feature %s - not present in FW\n", feature_name);
+								ret = EINVAL;
+							}
+							else if (0U == ((uint8_t)tmp & (uint8_t)F_RUNTIME))
+							{ /* Feature cannot be disabled */
+								NXP_LOG_INFO("Feature %s is always enabled in FW\n", feature_name);
+								ret = EOK;
+							}
+							else
+							{ /* Feature needs to be enabled */
+								ret = pfe_feature_mgr_set_val(feature_name, 1);
+							}
+						}
+					}
+				}
 			}
 		}
 	}
 
-	return EINVAL;
+	return ret;
 }
 
 /**
@@ -478,87 +548,97 @@ errno_t pfe_feature_mgr_enable(const char *feature_name)
  */
 errno_t pfe_feature_mgr_disable(const char *feature_name)
 {
-	pfe_hw_feature_t *hw_feature;
-	pfe_fw_feature_t *fw_feature_class;
+	pfe_hw_feature_t *     hw_feature;
+	pfe_fw_feature_t *     fw_feature_class;
 	pfe_ct_feature_flags_t tmp;
-	errno_t ret;
+	errno_t                ret = EINVAL;
+	errno_t                ret_class;
+	errno_t                ret_flag;
+	errno_t                ret_hw_feature;
 
-	#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if(NULL == feature_name)
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name)
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
-	}
-	#endif
-
-	if(NULL == feature_mgr)
-	{
-		NXP_LOG_ERROR("Feature Mgr not initialized\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	/* HW feature first */
-	ret = pfe_hw_get_feature(feature_mgr, &hw_feature, feature_name);
-	if(EOK == ret)
+	else
+#endif
 	{
-		ret = pfe_hw_feature_get_flags(hw_feature, &tmp);
-		if(EOK == ret)
+		if (NULL == feature_mgr)
 		{
-			if(0U == ((uint8_t)tmp & (uint8_t)F_PRESENT))
-			{	/* Feature cannot be enabled */
-				NXP_LOG_INFO("Feature %s is always disabled in Platform\n", feature_name);
-				return EOK;
-			}
-			else if(0U == ((uint8_t)tmp & (uint8_t)F_RUNTIME))
-			{	/* Feature cannot be disabled */
-				NXP_LOG_ERROR("Cannot disabled feature %s - always enabled in Platform\n", feature_name);
-				return EINVAL;
-			}
-			else
-			{	/* Feature needs to be disabled */
-				return pfe_feature_mgr_set_val(feature_name, 0);
-			}
+			NXP_LOG_ERROR("Feature Mgr not initialized\n");
+			ret = EINVAL;
 		}
+		else
+		{
 
-		/* Don't continue with FW features */
-		return ret;
-	}
-
-	if (NULL == feature_mgr->class)
-	{	/* Class block is not initialized */
-		return EINVAL;
-	}
+			/* HW feature first */
+			ret_hw_feature = pfe_hw_get_feature(feature_mgr, &hw_feature, feature_name);
+			if (EOK == ret_hw_feature)
+			{
+				ret_flag = pfe_hw_feature_get_flags(hw_feature, &tmp);
+				if (EOK == ret_flag)
+				{
+					if (0U == ((uint8_t)tmp & (uint8_t)F_PRESENT))
+					{ /* Feature cannot be enabled */
+						NXP_LOG_INFO("Feature %s is always disabled in Platform\n", feature_name);
+						ret = EOK;
+					}
+					else if (0U == ((uint8_t)tmp & (uint8_t)F_RUNTIME))
+					{ /* Feature cannot be disabled */
+						NXP_LOG_ERROR("Cannot disabled feature %s - always enabled in Platform\n", feature_name);
+						ret = EINVAL;
+					}
+					else
+					{ /* Feature needs to be disabled */
+						ret = pfe_feature_mgr_set_val(feature_name, 0);
+					}
+				}
 
-	/* Class and util share the same information thus it is
-	   enough to use just the class to get it */
-	ret = pfe_class_get_feature(feature_mgr->class, &fw_feature_class, feature_name);
-	if(EOK == ret)
-	{
-		ret = pfe_fw_feature_get_flags(fw_feature_class, &tmp);
-		if(EOK == ret)
-		{
-			if(0U == ((uint8_t)tmp & (uint8_t)F_PRESENT))
-			{	/* Feature cannot be enabled */
-				NXP_LOG_INFO("Feature %s is always disabled in FW\n", feature_name);
-				return EOK;
-			}
-			else if(0U == ((uint8_t)tmp & (uint8_t)F_RUNTIME))
-			{	/* Feature cannot be disabled */
-				NXP_LOG_ERROR("Cannot disabled feature %s - always enabled in FW\n", feature_name);
-				return EINVAL;
+				/* Don't continue with FW features */
 			}
 			else
-			{	/* Feature needs to be disabled */
-				return pfe_feature_mgr_set_val(feature_name, 0);
+			{
+
+				if (NULL == feature_mgr->class)
+				{ /* Class block is not initialized */
+					ret = EINVAL;
+				}
+				else
+				{
+
+					/* Class and util share the same information thus it is enough to use just the class to get it */
+					ret_class = pfe_class_get_feature(feature_mgr->class, &fw_feature_class, feature_name);
+					if (EOK == ret_class)
+					{
+						ret_flag = pfe_fw_feature_get_flags(fw_feature_class, &tmp);
+						if (EOK == ret_flag)
+						{
+							if (0U == ((uint8_t)tmp & (uint8_t)F_PRESENT))
+							{ /* Feature cannot be enabled */
+								NXP_LOG_INFO("Feature %s is always disabled in FW\n", feature_name);
+								ret = EOK;
+							}
+							else if (0U == ((uint8_t)tmp & (uint8_t)F_RUNTIME))
+							{ /* Feature cannot be disabled */
+								NXP_LOG_ERROR("Cannot disabled feature %s - always enabled in FW\n", feature_name);
+								ret = EINVAL;
+							}
+							else
+							{ /* Feature needs to be disabled */
+								ret = pfe_feature_mgr_set_val(feature_name, 0);
+							}
+						}
+					}
+				}
 			}
 		}
 	}
 
-	return EINVAL;
+	return ret;
 }
 
-
-
 /**
  * @brief		Reads the feature value
  * @param[in]	feature_name Name of the feature to be read
@@ -570,72 +650,98 @@ errno_t pfe_feature_mgr_get_val(const char *feature_name, uint8_t *val)
 	pfe_hw_feature_t *hw_feature;
 	pfe_fw_feature_t *fw_feature_class;
 	pfe_fw_feature_t *fw_feature_util;
-	errno_t ret_class, ret_util;
-	errno_t ret = EOK;
+	errno_t           ret_class, ret_util;
+	errno_t           ret_feature;
+	errno_t           ret = EOK;
 
-	#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if((NULL == feature_name)||(NULL == val))
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if ((NULL == feature_name) || (NULL == val))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
-	}
-	#endif
-
-	if(NULL == feature_mgr)
-	{
-		NXP_LOG_ERROR("Feature Mgr not initialized\n");
-		return EINVAL;
-	}
-
-	ret = pfe_hw_get_feature(feature_mgr, &hw_feature, feature_name);
-	if(EOK == ret)
-	{	/* Feature exist */
-		return pfe_hw_feature_get_val(hw_feature, val);
-	}
-
-	if (NULL == feature_mgr->class)
-	{	/* Class block is not initialized */
-		return EINVAL;
+		ret = EINVAL;
 	}
-
-	ret_class = pfe_class_get_feature(feature_mgr->class, &fw_feature_class, feature_name);
-	if(EOK != ret_class)
-	{	/* Feature does not exist or data is inconsistent */
-		return EINVAL;
-	}
-
-	if(NULL != feature_mgr->util)
+	else
+#endif
 	{
-		ret_util = pfe_util_get_feature(feature_mgr->util, &fw_feature_util, feature_name);
-		if(EOK != ret_util)
-		{	/* Data is inconsistent - feature found in class but not in util */
-			NXP_LOG_WARNING("Inconsistent feature data for %s\n", feature_name);
-			return EINVAL;
+		if (NULL == feature_mgr)
+		{
+			NXP_LOG_ERROR("Feature Mgr not initialized\n");
+			ret = EINVAL;
 		}
-	}
+		else
+		{
 
-	/* Check the value in class if relates to class */
-	if(TRUE == pfe_fw_feature_is_in_class(fw_feature_class))
-	{
-		ret = pfe_fw_feature_get_val(fw_feature_class, val);
-		/* We can stop here because data shall be consistent between class and util
-		   thus it does not matter which value is read */
-		return ret;
-	}
+			ret_feature = pfe_hw_get_feature(feature_mgr, &hw_feature, feature_name);
+			if (EOK == ret_feature)
+			{ /* Feature exist */
+				ret = pfe_hw_feature_get_val(hw_feature, val);
+			}
+			else
+			{
 
-	/* This is for features related to util only (code above will not read the value)*/
-	if(NULL != feature_mgr->util)
-	{	/* Util is available */
-		/* Check the value in util if relates to util */
-		if(TRUE == pfe_fw_feature_is_in_util(fw_feature_util))
-		{
-			return pfe_fw_feature_get_val(fw_feature_util, val);
+				if (NULL == feature_mgr->class)
+				{ /* Class block is not initialized */
+					ret = EINVAL;
+				}
+				else
+				{
+
+					ret_class = pfe_class_get_feature(feature_mgr->class, &fw_feature_class, feature_name);
+					if (EOK != ret_class)
+					{ /* Feature does not exist or data is inconsistent */
+						ret = EINVAL;
+					}
+					else
+					{
+
+						if (NULL != feature_mgr->util)
+						{
+							ret_util = pfe_util_get_feature(feature_mgr->util, &fw_feature_util, feature_name);
+							if (EOK != ret_util)
+							{ /* Data is inconsistent - feature found in class but not in util */
+								NXP_LOG_WARNING("Inconsistent feature data for %s\n", feature_name);
+								ret = EINVAL;
+							}
+						}
+						if (EOK == ret)
+						{
+							/* Check the value in class if relates to class */
+							if (TRUE == pfe_fw_feature_is_in_class(fw_feature_class))
+							{
+								ret = pfe_fw_feature_get_val(fw_feature_class, val);
+								/* We can stop here because data shall be consistent between class and util
+		   						thus it does not matter which value is read */
+							}
+							else
+							{
+
+								/* This is for features related to util only (code above will not read the value)*/
+								if (NULL != feature_mgr->util)
+								{ /* Util is available */
+									/* Check the value in util if relates to util */
+									if (TRUE == pfe_fw_feature_is_in_util(fw_feature_util))
+									{
+										ret = pfe_fw_feature_get_val(fw_feature_util, val);
+									}
+									else
+									{
+										/* We can get here only if feature is not present in class nor util */
+										NXP_LOG_WARNING("Wrong feature %s (not relevant to any FW)\n", feature_name);
+									}
+								}
+								else
+								{
+									/* We can get here only if feature is not present in class nor util */
+									NXP_LOG_WARNING("Wrong feature %s (not relevant to any FW)\n", feature_name);
+								}
+							}
+						}
+					}
+				}
+			}
 		}
 	}
-
-	/* We can get here only if feature is not present in class nor util */
-	NXP_LOG_WARNING("Wrong feature %s (not relevant to any FW)\n", feature_name);
-	return EINVAL;
+	return ret;
 }
 
 /**
@@ -647,46 +753,53 @@ errno_t pfe_feature_mgr_get_first(const char **feature_name)
 {
 	pfe_hw_feature_t *hw_feature;
 	pfe_fw_feature_t *fw_feature;
-	errno_t ret;
+	errno_t           ret;
 
-	#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if(NULL == feature_name)
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name)
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
-	}
-	#endif
-
-	if(NULL == feature_mgr)
-	{
-		NXP_LOG_ERROR("Feature Mgr not initialized\n");
-		return EINVAL;
-	}
-
-	/* HW feature first */
-	ret = pfe_hw_get_feature_first(feature_mgr, &hw_feature);
-	if(EOK == ret)
-	{
-		ret = pfe_hw_feature_get_name(hw_feature, feature_name);
-		/* Signal rewind_flg for class/util fw feature walk */
-		feature_mgr->rewind_flg = TRUE;
+		ret = EINVAL;
 	}
 	else
+#endif
 	{
-		/* We use the fact that class and util share same list of features and read
-		   from only one of them */
-
-		if (NULL == feature_mgr->class)
-		{	/* Class block is not initialized */
-			return EINVAL;
+		if (NULL == feature_mgr)
+		{
+			NXP_LOG_ERROR("Feature Mgr not initialized\n");
+			ret = EINVAL;
 		}
-
-		ret = pfe_class_get_feature_first(feature_mgr->class, &fw_feature);
-		if(EOK == ret)
+		else
 		{
-			ret = pfe_fw_feature_get_name(fw_feature, feature_name);
+
+			/* HW feature first */
+			ret = pfe_hw_get_feature_first(feature_mgr, &hw_feature);
+			if (EOK == ret)
+			{
+				ret = pfe_hw_feature_get_name(hw_feature, feature_name);
+				/* Signal rewind_flg for class/util fw feature walk */
+				feature_mgr->rewind_flg = TRUE;
+			}
+			else
+			{
+				/* We use the fact that class and util share same list of features and read
+		   from only one of them */
+
+				if (NULL == feature_mgr->class)
+				{ /* Class block is not initialized */
+					ret = EINVAL;
+				}
+				else
+				{
+					ret = pfe_class_get_feature_first(feature_mgr->class, &fw_feature);
+					if (EOK == ret)
+					{
+						ret = pfe_fw_feature_get_name(fw_feature, feature_name);
+					}
+					feature_mgr->rewind_flg = FALSE;
+				}
+			}
 		}
-		feature_mgr->rewind_flg = FALSE;
 	}
 
 	return ret;
@@ -701,58 +814,66 @@ errno_t pfe_feature_mgr_get_next(const char **feature_name)
 {
 	pfe_hw_feature_t *hw_feature;
 	pfe_fw_feature_t *fw_feature;
-	errno_t ret;
+	errno_t           ret;
 
-	#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if(NULL == feature_name)
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name)
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-	#endif
-
-	if(NULL == feature_mgr)
-	{
-		NXP_LOG_ERROR("Feature Mgr not initialized\n");
-		return EINVAL;
-	}
-
-	/* HW feature first */
-	ret = pfe_hw_get_feature_next(feature_mgr, &hw_feature);
-	if(EOK == ret)
-	{
-		ret = pfe_hw_feature_get_name(hw_feature, feature_name);
-	}
-	else if (ENOENT == ret)
+	else
+#endif
 	{
-		/* We use the fact that class and util share same list of features and read
-		   from only one of them */
-
-		if (NULL == feature_mgr->class)
-		{	/* Class block is not initialized */
-			return EINVAL;
-		}
-
-		if (TRUE == feature_mgr->rewind_flg)
+		if (NULL == feature_mgr)
 		{
-			ret = pfe_class_get_feature_first(feature_mgr->class, &fw_feature);
-			/* Unset 'rewind_flg' to use real pfe_class_get_feature_next next time */
-			feature_mgr->rewind_flg = FALSE;
+			NXP_LOG_ERROR("Feature Mgr not initialized\n");
+			ret = EINVAL;
 		}
 		else
 		{
-			ret = pfe_class_get_feature_next(feature_mgr->class, &fw_feature);
-		}
 
-		if(EOK == ret)
-		{
-			ret = pfe_fw_feature_get_name(fw_feature, feature_name);
+			/* HW feature first */
+			ret = pfe_hw_get_feature_next(feature_mgr, &hw_feature);
+			if (EOK == ret)
+			{
+				ret = pfe_hw_feature_get_name(hw_feature, feature_name);
+			}
+			else if (ENOENT == ret)
+			{
+				/* We use the fact that class and util share same list of features and read
+		   from only one of them */
+
+				if (NULL == feature_mgr->class)
+				{ /* Class block is not initialized */
+					ret = EINVAL;
+				}
+				else
+				{
+
+					if (TRUE == feature_mgr->rewind_flg)
+					{
+						ret = pfe_class_get_feature_first(feature_mgr->class, &fw_feature);
+						/* Unset 'rewind_flg' to use real pfe_class_get_feature_next next time */
+						feature_mgr->rewind_flg = FALSE;
+					}
+					else
+					{
+						ret = pfe_class_get_feature_next(feature_mgr->class, &fw_feature);
+					}
+
+					if (EOK == ret)
+					{
+						ret = pfe_fw_feature_get_name(fw_feature, feature_name);
+					}
+				}
+			}
+			else
+			{
+				; /* No action required */
+			}
 		}
 	}
-	else
-	{
-		; /* No action required */
-	}
 
 	return ret;
 }
@@ -767,44 +888,51 @@ errno_t pfe_feature_mgr_get_def_val(const char *feature_name, uint8_t *val)
 {
 	pfe_hw_feature_t *hw_feature;
 	pfe_fw_feature_t *fw_feature_class;
-	errno_t ret = EOK;
+	errno_t           ret;
 
-	#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if(NULL == feature_name)
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name)
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-	#endif
-
-	if(NULL == feature_mgr)
-	{
-		NXP_LOG_ERROR("Feature Mgr not initialized\n");
-		return EINVAL;
-	}
-
-	/* HW feature first */
-	if(EOK == pfe_hw_get_feature(feature_mgr, &hw_feature, feature_name))
+	else
+#endif
 	{
-		ret = pfe_hw_feature_get_def_val(hw_feature, val);
-		return ret;
-	}
-
-	if (NULL == feature_mgr->class)
-	{	/* Class block is not initialized */
-		return EINVAL;
-	}
+		if (NULL == feature_mgr)
+		{
+			NXP_LOG_ERROR("Feature Mgr not initialized\n");
+			ret = EINVAL;
+		}
+		else
+		{
+			/* HW feature first */
+			if (EOK == pfe_hw_get_feature(feature_mgr, &hw_feature, feature_name))
+			{
+				ret = pfe_hw_feature_get_def_val(hw_feature, val);
+			}
+			else
+			{
 
-	/* The data shall be consistent between util and class thus it is enough to read
-	   them from class */
-	   
-	ret = pfe_class_get_feature(feature_mgr->class, &fw_feature_class, feature_name);
-	if(EOK == ret)
-	{
-		ret = pfe_fw_feature_get_def_val(fw_feature_class, val);
+				if (NULL == feature_mgr->class)
+				{ /* Class block is not initialized */
+					ret = EINVAL;
+				}
+				else
+				{
+					/* The data shall be consistent between util and class thus it is enough to read them from class */
+
+					ret = pfe_class_get_feature(feature_mgr->class, &fw_feature_class, feature_name);
+					if (EOK == ret)
+					{
+						ret = pfe_fw_feature_get_def_val(fw_feature_class, val);
+					}
+				}
+			}
+		}
 	}
 
-	return ret;   
+	return ret;
 }
 
 /**
@@ -817,43 +945,49 @@ errno_t pfe_feature_mgr_get_desc(const char *feature_name, const char **desc)
 {
 	pfe_hw_feature_t *hw_feature;
 	pfe_fw_feature_t *fw_feature_class;
-	errno_t ret = EOK;
+	errno_t           ret;
 
-	#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if((NULL == desc)||(NULL == feature_name))
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if ((NULL == desc) || (NULL == feature_name))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-	#endif
-
-	if(NULL == feature_mgr)
-	{
-		NXP_LOG_ERROR("Feature Mgr not initialized\n");
-		return EINVAL;
-	}
-
-	/* Platfoorm feature first */
-	if(EOK == pfe_hw_get_feature(feature_mgr, &hw_feature, feature_name))
-	{
-		ret = pfe_hw_feature_get_desc(hw_feature, desc);
-		return ret;
-	}
-
-	if (NULL == feature_mgr->class)
-	{	/* Class block is not initialized */
-		return EINVAL;
-	}
-
-	/* The data shall be consistent between util and class thus it is enough to read
-	   them from class */
-	ret = pfe_class_get_feature(feature_mgr->class, &fw_feature_class, feature_name);
-	if(EOK == ret)
+	else
+#endif
 	{
-		ret = pfe_fw_feature_get_desc(fw_feature_class, desc);
+		if (NULL == feature_mgr)
+		{
+			NXP_LOG_ERROR("Feature Mgr not initialized\n");
+			ret = EINVAL;
+		}
+		else
+		{
+			/* Platfoorm feature first */
+			if (EOK == pfe_hw_get_feature(feature_mgr, &hw_feature, feature_name))
+			{
+				ret = pfe_hw_feature_get_desc(hw_feature, desc);
+			}
+			else
+			{
+				if (NULL == feature_mgr->class)
+				{ /* Class block is not initialized */
+					ret = EINVAL;
+				}
+				else
+				{
+					/* The data shall be consistent between util and class thus it is enough to read
+	   				them from class */
+					ret = pfe_class_get_feature(feature_mgr->class, &fw_feature_class, feature_name);
+					if (EOK == ret)
+					{
+						ret = pfe_fw_feature_get_desc(fw_feature_class, desc);
+					}
+				}
+			}
+		}
 	}
-	
-	return ret; 
+	return ret;
 }
 
 /**
@@ -864,53 +998,59 @@ errno_t pfe_feature_mgr_get_desc(const char *feature_name, const char **desc)
  */
 errno_t pfe_feature_mgr_get_variant(const char *feature_name, uint8_t *val)
 {
-	pfe_hw_feature_t *hw_feature;
-	pfe_fw_feature_t *fw_feature_class;
-	errno_t ret = EOK;
+	pfe_hw_feature_t *     hw_feature;
+	pfe_fw_feature_t *     fw_feature_class;
+	errno_t                ret;
 	pfe_ct_feature_flags_t tmp;
 
-	#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if((NULL == feature_name)||(NULL == val))
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if ((NULL == feature_name) || (NULL == val))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-	#endif
-
-	if(NULL == feature_mgr)
-	{
-		NXP_LOG_ERROR("Feature Mgr not initialized\n");
-		return EINVAL;
-	}
-
-	/* HW feature first */
-	if(EOK == pfe_hw_get_feature(feature_mgr, &hw_feature, feature_name))
+	else
+#endif
 	{
-		ret = pfe_hw_feature_get_flags(hw_feature, &tmp);
-		if(EOK == ret)
+		if (NULL == feature_mgr)
 		{
-			*val = (uint8_t)tmp & ((uint8_t)F_PRESENT | (uint8_t)F_RUNTIME);
+			NXP_LOG_ERROR("Feature Mgr not initialized\n");
+			ret = EINVAL;
 		}
-		return ret;
-	}
-
-	if (NULL == feature_mgr->class)
-	{	/* Class block is not initialized */
-		return EINVAL;
-	}
-
-	/* The data shall be consistent between util and class thus it is enough to read
-	   them from class */
-	ret = pfe_class_get_feature(feature_mgr->class, &fw_feature_class, feature_name);
-	if(EOK == ret)
-	{
-		ret = pfe_fw_feature_get_flags(fw_feature_class, &tmp);
-		if(EOK == ret)
+		else
 		{
-			*val = (uint8_t)tmp & ((uint8_t)F_PRESENT | (uint8_t)F_RUNTIME);
+			/* HW feature first */
+			if (EOK == pfe_hw_get_feature(feature_mgr, &hw_feature, feature_name))
+			{
+				ret = pfe_hw_feature_get_flags(hw_feature, &tmp);
+				if (EOK == ret)
+				{
+					*val = (uint8_t)tmp & ((uint8_t)F_PRESENT | (uint8_t)F_RUNTIME);
+				}
+			}
+			else
+			{
+				if (NULL == feature_mgr->class)
+				{ /* Class block is not initialized */
+					ret = EINVAL;
+				}
+				else
+				{
+					/* The data shall be consistent between util and class thus it is enough to read
+	   				them from class */
+					ret = pfe_class_get_feature(feature_mgr->class, &fw_feature_class, feature_name);
+					if (EOK == ret)
+					{
+						ret = pfe_fw_feature_get_flags(fw_feature_class, &tmp);
+						if (EOK == ret)
+						{
+							*val = (uint8_t)tmp & ((uint8_t)F_PRESENT | (uint8_t)F_RUNTIME);
+						}
+					}
+				}
+			}
 		}
 	}
-	
 	return ret;
 }
 
@@ -923,29 +1063,35 @@ errno_t pfe_feature_mgr_get_variant(const char *feature_name, uint8_t *val)
  */
 static errno_t pfe_hw_get_feature(const pfe_feature_mgr_t *fmgr, pfe_hw_feature_t **feature, const char *name)
 {
-	uint32_t i;
+	uint32_t    i;
 	const char *fname;
-	errno_t ret;
+	errno_t     ret = ENOENT;
+	errno_t     ret_val = EOK;
+
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == fmgr) || (NULL == feature) || (NULL == name)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-	for(i = 0U; i < fmgr->hw_features_count; i++)
 	{
-		ret = pfe_hw_feature_get_name(fmgr->hw_features[i], &fname);
-		if(ret == EOK)
+		for (i = 0U; i < fmgr->hw_features_count; i++)
 		{
-			if(0 == strcmp(fname, name))
+			ret_val = pfe_hw_feature_get_name(fmgr->hw_features[i], &fname);
+			if (ret_val == EOK)
 			{
-				*feature = fmgr->hw_features[i];
-				return EOK;
+				if (0 == strcmp(fname, name))
+				{
+					*feature = fmgr->hw_features[i];
+					ret = EOK;
+					break;
+				}
 			}
 		}
 	}
-	return ENOENT;
+	return ret;
 }
 
 /**
@@ -956,21 +1102,29 @@ static errno_t pfe_hw_get_feature(const pfe_feature_mgr_t *fmgr, pfe_hw_feature_
  */
 static errno_t pfe_hw_get_feature_first(pfe_feature_mgr_t *fmgr, pfe_hw_feature_t **feature)
 {
- #if defined(PFE_CFG_NULL_ARG_CHECK)
+	errno_t ret;
+#if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == fmgr) || (NULL == feature)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-	if(fmgr->hw_features_count > 0U)
 	{
-		fmgr->current_hw_feature = 0U;
-		*feature = fmgr->hw_features[fmgr->current_hw_feature];
-		return EOK;
+		if (fmgr->hw_features_count > 0U)
+		{
+			fmgr->current_hw_feature = 0U;
+			*feature = fmgr->hw_features[fmgr->current_hw_feature];
+			ret = EOK;
+		}
+		else
+		{
+			ret = ENOENT;
+		}
 	}
 
-	return ENOENT;
+	return ret;
 }
 
 /**
@@ -981,25 +1135,29 @@ static errno_t pfe_hw_get_feature_first(pfe_feature_mgr_t *fmgr, pfe_hw_feature_
  */
 static errno_t pfe_hw_get_feature_next(pfe_feature_mgr_t *fmgr, pfe_hw_feature_t **feature)
 {
- #if defined(PFE_CFG_NULL_ARG_CHECK)
+	errno_t ret = ENOENT;
+#if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == fmgr) || (NULL == feature)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-	if(fmgr->hw_features_count > 0U)
 	{
-		/* Avoid going out of the array boundaries */
-		if((fmgr->current_hw_feature + 1U) < fmgr->hw_features_count)
+		if (fmgr->hw_features_count > 0U)
 		{
-			fmgr->current_hw_feature += 1U;
-			*feature = fmgr->hw_features[fmgr->current_hw_feature];
-			return EOK;
+			/* Avoid going out of the array boundaries */
+			if ((fmgr->current_hw_feature + 1U) < fmgr->hw_features_count)
+			{
+				fmgr->current_hw_feature += 1U;
+				*feature = fmgr->hw_features[fmgr->current_hw_feature];
+				ret = EOK;
+			}
 		}
 	}
 
-	return ENOENT;
+	return ret;
 }
 
 /**
@@ -1012,21 +1170,22 @@ static errno_t pfe_feature_mgr_configure_driver(const char *feature_name, const
 {
 	errno_t ret = EOK;
 
-	#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if(NULL == feature_name)
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name)
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-	#endif
-
-	if(0 == strcmp(feature_name, "err051211_workaround"))
+	else
+#endif
 	{
-		if (0U != val) /* feature got enabled */
+		if (0 == strcmp(feature_name, "err051211_workaround"))
 		{
-			ret = pfe_tmu_queue_err051211_sync(feature_mgr->tmu);
+			if (0U != val) /* feature got enabled */
+			{
+				ret = pfe_tmu_queue_err051211_sync(feature_mgr->tmu);
+			}
 		}
 	}
-
 	return ret;
 }
diff --git a/sw/pfe_platform/src/pfe_flexible_filter.c b/sw/pfe_platform/src/pfe_flexible_filter.c
index 3fab049..3f8f59b 100644
--- a/sw/pfe_platform/src/pfe_flexible_filter.c
+++ b/sw/pfe_platform/src/pfe_flexible_filter.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2021 NXP
+ *  Copyright 2018-2022 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -29,28 +29,30 @@ void pfe_flexible_filter_init(void)
  */
 errno_t pfe_flexible_filter_set(pfe_class_t *class, const uint32_t dmem_addr)
 {
-	pfe_ct_class_mmap_t mmap;
-	errno_t ret = EOK;
+    pfe_ct_class_mmap_t mmap;
+    errno_t ret;
     uint32_t ff_addr;
     uint32_t ff = dmem_addr;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely(NULL == class))
-	{
-		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
-	}
+    if (unlikely (NULL == class))
+    {
+        NXP_LOG_ERROR ("NULL argument received\n");
+        ret = EINVAL;
+    }
+    else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-    /* Get the memory map */
-	/* All PEs share the same memory map therefore we can read
+    {
+        /* Get the memory map */
+        /* All PEs share the same memory map therefore we can read
 	   arbitrary one (in this case 0U) */
-	ret = pfe_class_get_mmap(class, 0, &mmap);
-	if(EOK == ret)
-	{
-        /* Get the flexible filter address */
-        ff_addr = oal_ntohl(mmap.flexible_filter);
-        /* Write new address of flexible filter */
-        ret = pfe_class_write_dmem(class, -1, (addr_t)ff_addr, (void *)&ff, sizeof(pfe_ct_flexible_filter_t));
+        ret = pfe_class_get_mmap (class, 0, &mmap);
+        if (EOK == ret)
+        {
+            /* Get the flexible filter address */
+            ff_addr = oal_ntohl (mmap.flexible_filter);
+            /* Write new address of flexible filter */
+            ret = pfe_class_write_dmem (class, -1, (addr_t)ff_addr, (void *)&ff, sizeof (pfe_ct_flexible_filter_t));
+        }
     }
     return ret;
 }
diff --git a/sw/pfe_platform/src/pfe_fp.c b/sw/pfe_platform/src/pfe_fp.c
index 33e10ae..e02ed51 100644
--- a/sw/pfe_platform/src/pfe_fp.c
+++ b/sw/pfe_platform/src/pfe_fp.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2019-2021 NXP
+ *  Copyright 2019-2022 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -38,24 +38,26 @@ uint32_t pfe_fp_create_table(pfe_class_t *class, uint16_t rules_count)
     errno_t res;
 
     /* Calculate needed size */
-    size = (uint32_t)sizeof(pfe_ct_fp_table_t) + ((uint32_t)rules_count * sizeof(pfe_ct_fp_rule_t));
+    size = (uint32_t)sizeof (pfe_ct_fp_table_t) + ((uint32_t)rules_count * sizeof (pfe_ct_fp_rule_t));
     /* Allocate DMEM */
-    addr = pfe_class_dmem_heap_alloc(class, size);
-    if(0U == addr)
+    addr = pfe_class_dmem_heap_alloc (class, size);
+    if (0U == addr)
     {
-        NXP_LOG_ERROR("Not enough DMEM memory\n");
-        return 0U;
+        NXP_LOG_ERROR ("Not enough DMEM memory\n");
     }
-    /* Write the table header */
-    temp.count = rules_count;
-    temp.rules = oal_htonl(addr + sizeof(pfe_ct_fp_table_t));
-    (void)memset(&temp.fp_stats, 0, sizeof(pfe_ct_class_flexi_parser_stats_t));
-    res = pfe_class_write_dmem(class, -1, addr, (void *)&temp, sizeof(pfe_ct_fp_table_t));
-    if(EOK != res)
+    else
     {
-        NXP_LOG_ERROR("Cannot write to DMEM\n");
-        pfe_class_dmem_heap_free(class, addr);
-        addr = 0U;
+        /* Write the table header */
+        temp.count = rules_count;
+        temp.rules = oal_htonl (addr + sizeof (pfe_ct_fp_table_t));
+        (void)memset (&temp.fp_stats, 0, sizeof (pfe_ct_class_flexi_parser_stats_t));
+        res = pfe_class_write_dmem (class, -1, addr, (void *)&temp, sizeof (pfe_ct_fp_table_t));
+        if (EOK != res)
+        {
+            NXP_LOG_ERROR ("Cannot write to DMEM\n");
+            pfe_class_dmem_heap_free (class, addr);
+            addr = 0U;
+        }
     }
     /* Return the DMEM address */
     return addr;
diff --git a/sw/pfe_platform/src/pfe_fw_feature.c b/sw/pfe_platform/src/pfe_fw_feature.c
index 1f0240c..8b11734 100644
--- a/sw/pfe_platform/src/pfe_fw_feature.c
+++ b/sw/pfe_platform/src/pfe_fw_feature.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2020-2021 NXP
+ *  Copyright 2020-2022 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -15,11 +15,11 @@
 
 struct pfe_fw_feature_tag
 {
-    pfe_ct_feature_desc_t *ll_data;
-    const char *string_base;
-    dmem_read_func_t dmem_read_func;
-    dmem_write_func_t dmem_write_func;
-    void *dmem_rw_func_data;  
+	pfe_ct_feature_desc_t *ll_data;
+	const char *string_base;
+	dmem_read_func_t dmem_read_func;
+	dmem_write_func_t dmem_write_func;
+	void *dmem_rw_func_data;
 };
 
 /**
@@ -28,17 +28,17 @@ struct pfe_fw_feature_tag
  */
 pfe_fw_feature_t *pfe_fw_feature_create(void)
 {
-    pfe_fw_feature_t *feature;
-    feature = oal_mm_malloc(sizeof(pfe_fw_feature_t));
-    if(NULL != feature)
-    {
-        (void)memset(feature, 0U, sizeof(pfe_fw_feature_t));
-    }
-    else
-    {
-        NXP_LOG_ERROR("Cannot allocate %u bytes of memory for feature\n", (uint_t)sizeof(pfe_fw_feature_t));
-    }
-    return feature;
+	pfe_fw_feature_t *feature;
+	feature = oal_mm_malloc(sizeof(pfe_fw_feature_t));
+	if (NULL != feature)
+	{
+		(void)memset(feature, 0U, sizeof(pfe_fw_feature_t));
+	}
+	else
+	{
+		NXP_LOG_ERROR("Cannot allocate %u bytes of memory for feature\n", (uint_t)sizeof(pfe_fw_feature_t));
+	}
+	return feature;
 }
 
 /**
@@ -51,10 +51,12 @@ void pfe_fw_feature_destroy(const pfe_fw_feature_t *feature)
 	if (unlikely(NULL == feature))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return;
 	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */     
-    oal_mm_free(feature);
+	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		oal_mm_free(feature);
+	}
 }
 
 /**
@@ -65,15 +67,20 @@ void pfe_fw_feature_destroy(const pfe_fw_feature_t *feature)
  */
 errno_t pfe_fw_feature_set_ll_data(pfe_fw_feature_t *feature, pfe_ct_feature_desc_t *ll_data)
 {
+	errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely((NULL == feature)||(NULL == ll_data)))
+	if (unlikely((NULL == feature) || (NULL == ll_data)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */      
-    feature->ll_data = ll_data;
-    return EOK;
+	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		feature->ll_data = ll_data;
+		ret = EOK;
+	}
+	return ret;
 }
 
 /**
@@ -87,15 +94,20 @@ errno_t pfe_fw_feature_set_ll_data(pfe_fw_feature_t *feature, pfe_ct_feature_des
  */
 errno_t pfe_fw_feature_set_string_base(pfe_fw_feature_t *feature, const char *string_base)
 {
+	errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely((NULL == feature)||(NULL == string_base)))
+	if (unlikely((NULL == feature) || (NULL == string_base)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */      
-    feature->string_base = string_base;
-    return EOK;
+	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		feature->string_base = string_base;
+		ret = EOK;
+	}
+	return ret;
 }
 
 /**
@@ -107,21 +119,23 @@ errno_t pfe_fw_feature_set_string_base(pfe_fw_feature_t *feature, const char *st
  * @return EOK or an error code.
  */
 errno_t pfe_fw_feature_set_dmem_funcs(pfe_fw_feature_t *feature, dmem_read_func_t read_func, dmem_write_func_t write_func, void *data)
-{    
+{
+	errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely((NULL == feature)||
-                 (NULL == read_func)||
-                 (NULL == write_func)||
-                 (NULL == data)))
+	if (unlikely((NULL == feature) || (NULL == read_func) || (NULL == write_func) || (NULL == data)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
+	}
+	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		feature->dmem_read_func = read_func;
+		feature->dmem_write_func = write_func;
+		feature->dmem_rw_func_data = data;
+		ret = EOK;
 	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */  
-    feature->dmem_read_func = read_func;
-    feature->dmem_write_func = write_func;
-    feature->dmem_rw_func_data = data;
-    return EOK;
+	return ret;
 }
 
 /**
@@ -132,16 +146,20 @@ errno_t pfe_fw_feature_set_dmem_funcs(pfe_fw_feature_t *feature, dmem_read_func_
  */
 errno_t pfe_fw_feature_get_name(const pfe_fw_feature_t *feature, const char **name)
 {
+	errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely((NULL == feature)||(NULL == name)))
+	if (unlikely((NULL == feature) || (NULL == name)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
+	}
+	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		*name = feature->string_base + oal_ntohl(feature->ll_data->name);
+		ret = EOK;
 	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */  
-    *name = feature->string_base + oal_ntohl(feature->ll_data->name);
-    return EOK;
-    
+	return ret;
 }
 
 /**
@@ -152,16 +170,20 @@ errno_t pfe_fw_feature_get_name(const pfe_fw_feature_t *feature, const char **na
  */
 errno_t pfe_fw_feature_get_desc(const pfe_fw_feature_t *feature, const char **desc)
 {
+	errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely((NULL == feature)||(NULL ==desc)))
+	if (unlikely((NULL == feature) || (NULL == desc)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
+	}
+	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		*desc = feature->string_base + oal_ntohl(feature->ll_data->description);
+		ret = EOK;
 	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */  
-    *desc = feature->string_base + oal_ntohl(feature->ll_data->description);
-    return EOK;
-    
+	return ret;
 }
 
 /**
@@ -172,16 +194,20 @@ errno_t pfe_fw_feature_get_desc(const pfe_fw_feature_t *feature, const char **de
  */
 errno_t pfe_fw_feature_get_flags(const pfe_fw_feature_t *feature, pfe_ct_feature_flags_t *flags)
 {
+	errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely((NULL == feature)||(NULL==flags)))
+	if (unlikely((NULL == feature) || (NULL == flags)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */  
-    *flags = feature->ll_data->flags;
-    return EOK;
-    
+	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		*flags = feature->ll_data->flags;
+		ret = EOK;
+	}
+	return ret;
 }
 
 /**
@@ -192,19 +218,24 @@ errno_t pfe_fw_feature_get_flags(const pfe_fw_feature_t *feature, pfe_ct_feature
  */
 bool_t pfe_fw_feature_is_in_class(const pfe_fw_feature_t *feature)
 {
-    pfe_ct_feature_flags_t flags;
-    flags = F_NONE;
+	pfe_ct_feature_flags_t flags;
+	bool_t ret;
+	flags = F_NONE;
+
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == feature))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return FALSE;
+		ret = FALSE;
 	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */     
-    
-    (void)pfe_fw_feature_get_flags(feature, &flags);
-    
-    return ((uint8_t)F_NONE == ((uint8_t)flags & (uint8_t)F_CLASS))? FALSE : TRUE;
+	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		(void)pfe_fw_feature_get_flags(feature, &flags);
+
+		ret = ((uint8_t)F_NONE == ((uint8_t)flags & (uint8_t)F_CLASS)) ? FALSE : TRUE;
+	}
+	return ret;
 }
 
 /**
@@ -215,21 +246,25 @@ bool_t pfe_fw_feature_is_in_class(const pfe_fw_feature_t *feature)
  */
 bool_t pfe_fw_feature_is_in_util(const pfe_fw_feature_t *feature)
 {
-    pfe_ct_feature_flags_t flags;
-    flags = F_NONE;
+	pfe_ct_feature_flags_t flags;
+	bool_t ret;
+	flags = F_NONE;
+
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == feature))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return FALSE;
+		ret = FALSE;
 	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */     
-    
-    (void)pfe_fw_feature_get_flags(feature, &flags);
-    
-    return ((uint8_t)F_NONE == ((uint8_t)flags & (uint8_t)F_UTIL))? FALSE : TRUE;
-}
+	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		(void)pfe_fw_feature_get_flags(feature, &flags);
 
+		ret = ((uint8_t)F_NONE == ((uint8_t)flags & (uint8_t)F_UTIL)) ? FALSE : TRUE;
+	}
+	return ret;
+}
 
 /**
  * @brief Reads the default value of the feature i.e. initial value set by the FW
@@ -239,16 +274,20 @@ bool_t pfe_fw_feature_is_in_util(const pfe_fw_feature_t *feature)
  */
 errno_t pfe_fw_feature_get_def_val(const pfe_fw_feature_t *feature, uint8_t *def_val)
 {
+	errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely((NULL == feature)||(NULL == def_val)))
+	if (unlikely((NULL == feature) || (NULL == def_val)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */  
-    *def_val = feature->ll_data->def_val;
-    return EOK;
-    
+	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		*def_val = feature->ll_data->def_val;
+		ret = EOK;
+	}
+	return ret;
 }
 
 /**
@@ -259,17 +298,19 @@ errno_t pfe_fw_feature_get_def_val(const pfe_fw_feature_t *feature, uint8_t *def
  */
 errno_t pfe_fw_feature_get_val(const pfe_fw_feature_t *feature, uint8_t *val)
 {
-	 errno_t ret;
+	errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely((NULL == feature)||(NULL == val)))
+	if (unlikely((NULL == feature) || (NULL == val)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
 	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */  
-    ret = feature->dmem_read_func(feature->dmem_rw_func_data, 0U, val, (addr_t)oal_ntohl(feature->ll_data->position), sizeof(uint8_t));
-    return ret;
-    
+	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		ret = feature->dmem_read_func(feature->dmem_rw_func_data, 0U, val, (addr_t)oal_ntohl(feature->ll_data->position), sizeof(uint8_t));
+	}
+	return ret;
 }
 
 /**
@@ -282,24 +323,35 @@ bool_t pfe_fw_feature_enabled(const pfe_fw_feature_t *feature)
 {
 	uint8_t val;
 	errno_t ret;
+	bool_t feature_enabled;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == feature))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return FALSE;
+		feature_enabled = FALSE;
 	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */  
-
-	ret = pfe_fw_feature_get_val(feature, &val);
-	if(EOK != ret) 
-	{
-		return FALSE;
-	}
-	if(0U != val)
+	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		return TRUE;
+		ret = pfe_fw_feature_get_val(feature, &val);
+
+		if (EOK != ret)
+		{
+			feature_enabled = FALSE;
+		}
+		else
+		{
+			if (0U != val)
+			{
+				feature_enabled = TRUE;
+			}
+			else
+			{
+				feature_enabled = FALSE;
+			}
+		}
 	}
-	return FALSE;
+	return feature_enabled;
 }
 
 /**
@@ -310,15 +362,18 @@ bool_t pfe_fw_feature_enabled(const pfe_fw_feature_t *feature)
  */
 errno_t pfe_fw_feature_set_val(const pfe_fw_feature_t *feature, uint8_t val)
 {
-	 errno_t ret;
+	errno_t ret;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == feature))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		ret = EINVAL;
+	}
+	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		ret = feature->dmem_write_func(feature->dmem_rw_func_data, -1, (addr_t)oal_ntohl(feature->ll_data->position), (void *)&val, sizeof(uint8_t));
 	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */  
-	ret = feature->dmem_write_func(feature->dmem_rw_func_data, -1, (addr_t)oal_ntohl(feature->ll_data->position), (void *)&val, sizeof(uint8_t));
 	return ret;
 }
diff --git a/sw/pfe_platform/src/pfe_gpi.c b/sw/pfe_platform/src/pfe_gpi.c
index ac70df2..1f6cf5b 100644
--- a/sw/pfe_platform/src/pfe_gpi.c
+++ b/sw/pfe_platform/src/pfe_gpi.c
@@ -15,8 +15,8 @@
 #include "pfe_cbus.h"
 #include "pfe_gpi.h"
 
-#define IGQOS_BITMAP_ARR_SZ	2U
-#define BITMAP_BITS_U32		32U
+#define IGQOS_BITMAP_ARR_SZ 2U
+#define BITMAP_BITS_U32     32U
 #define DECLARE_BITMAP_U32(name, SIZE) \
 	uint32_t name[SIZE]
 
@@ -25,13 +25,13 @@
 
 struct pfe_gpi_tag
 {
-	addr_t cbus_base_va;		/* CBUS base virtual address */
-	addr_t gpi_base_offset;		/* GPI base offset within CBUS space */
-	addr_t gpi_base_va;		/* GPI base address (virtual) */
+	addr_t cbus_base_va;    /* CBUS base virtual address */
+	addr_t gpi_base_offset; /* GPI base offset within CBUS space */
+	addr_t gpi_base_va;     /* GPI base address (virtual) */
 
 	/* bitmap of all (PFE_IQOS_FLOW_TABLE_SIZE) active classification table entries */
 	DECLARE_BITMAP_U32(igqos_active_entries, IGQOS_BITMAP_ARR_SZ);
-	uint8_t igqos_entry_iter; /* classification table active entries interator */
+	uint8_t  igqos_entry_iter; /* classification table active entries interator */
 	uint32_t sys_clk_mhz;
 	uint32_t clk_div_log2;
 };
@@ -48,62 +48,67 @@ ct_assert(PFE_IQOS_FLOW_TABLE_SIZE <= (BITMAP_BITS_U32 * IGQOS_BITMAP_ARR_SZ));
  */
 pfe_gpi_t *pfe_gpi_create(addr_t cbus_base_va, addr_t gpi_base, const pfe_gpi_cfg_t *cfg)
 {
-	addr_t gpi_cbus_offset;
+	addr_t     gpi_cbus_offset;
 	pfe_gpi_t *gpi;
-	errno_t ret;
+	errno_t    ret;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL_ADDR == cbus_base_va) || (NULL == cfg)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return NULL;
+		gpi = NULL;
 	}
+	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	gpi = (pfe_gpi_t *)oal_mm_malloc(sizeof(pfe_gpi_t));
-
-	if (NULL != gpi)
 	{
-		(void)memset(gpi, 0, sizeof(pfe_gpi_t));
-		gpi->cbus_base_va = cbus_base_va;
-		gpi->gpi_base_offset = gpi_base;
-		gpi->gpi_base_va = (gpi->cbus_base_va + gpi->gpi_base_offset);
-		gpi->sys_clk_mhz = pfe_gpi_cfg_get_sys_clk_mhz(cbus_base_va);
-		gpi_cbus_offset = gpi->gpi_base_va - cbus_base_va;
+		gpi = (pfe_gpi_t *)oal_mm_malloc(sizeof(pfe_gpi_t));
 
-		ret = pfe_gpi_reset(gpi);
-		if (EOK != ret)
+		if (NULL != gpi)
 		{
-			oal_mm_free(gpi);
-			gpi = NULL;
-		}
-		else
-		{
-			switch (gpi_cbus_offset)
+			(void)memset(gpi, 0, sizeof(pfe_gpi_t));
+			gpi->cbus_base_va    = cbus_base_va;
+			gpi->gpi_base_offset = gpi_base;
+			gpi->gpi_base_va     = (gpi->cbus_base_va + gpi->gpi_base_offset);
+			gpi->sys_clk_mhz     = pfe_gpi_cfg_get_sys_clk_mhz(cbus_base_va);
+			gpi_cbus_offset      = gpi->gpi_base_va - cbus_base_va;
+
+			ret = pfe_gpi_reset(gpi);
+			if (EOK != ret)
 			{
-				case CBUS_EGPI1_BASE_ADDR:
-				case CBUS_EGPI2_BASE_ADDR:
-				case CBUS_EGPI3_BASE_ADDR:
-					/*
-					* includes initialization of CLASS tables
-					* required by the ECC module init
-					*/
-					ret = pfe_gpi_qos_reset(gpi);
-					if (EOK != ret)
-					{
-						NXP_LOG_ERROR("GPI QOS reset timed-out\n");
-						oal_mm_free(gpi);
-						return NULL;
-					}
-					break;
-				default:
-					/* Do Nothing */
-					break;
+				oal_mm_free(gpi);
+				gpi = NULL;
+			}
+			else
+			{
+				switch (gpi_cbus_offset)
+				{
+					case CBUS_EGPI1_BASE_ADDR:
+					case CBUS_EGPI2_BASE_ADDR:
+					case CBUS_EGPI3_BASE_ADDR:
+						/*
+						* includes initialization of CLASS tables
+						* required by the ECC module init
+						*/
+						ret = pfe_gpi_qos_reset(gpi);
+						if (EOK != ret)
+						{
+							NXP_LOG_ERROR("GPI QOS reset timed-out\n");
+							oal_mm_free(gpi);
+							gpi = NULL;
+						}
+						break;
+					default:
+						/* Do Nothing */
+						break;
+				}
+
+				if (NULL != gpi)
+				{
+					pfe_gpi_disable(gpi);
+
+					pfe_gpi_cfg_init(gpi->gpi_base_va, cfg);
+				}
 			}
-
-			pfe_gpi_disable(gpi);
-
-			pfe_gpi_cfg_init(gpi->gpi_base_va, cfg);
 		}
 	}
 
@@ -187,9 +192,7 @@ void pfe_gpi_destroy(pfe_gpi_t *gpi)
 	{
 		pfe_gpi_disable(gpi);
 
-		if ((gpi->gpi_base_offset == CBUS_EGPI1_BASE_ADDR) ||
-			(gpi->gpi_base_offset == CBUS_EGPI2_BASE_ADDR) ||
-			(gpi->gpi_base_offset == CBUS_EGPI3_BASE_ADDR))
+		if ((gpi->gpi_base_offset == CBUS_EGPI1_BASE_ADDR) || (gpi->gpi_base_offset == CBUS_EGPI2_BASE_ADDR) || (gpi->gpi_base_offset == CBUS_EGPI3_BASE_ADDR))
 		{
 			ret = pfe_gpi_qos_reset(gpi);
 			if (EOK != ret)
@@ -212,12 +215,17 @@ void pfe_gpi_destroy(pfe_gpi_t *gpi)
 
 bool_t pfe_gpi_qos_is_enabled(const pfe_gpi_t *gpi)
 {
-	bool_t is_enabled = FALSE;
-	errno_t ret = pfe_gpi_null_arg_check_return(gpi, EINVAL);
+	bool_t  is_enabled;
+	errno_t ret        = pfe_gpi_null_arg_check_return(gpi, EINVAL);
+
 	if (ret == EOK)
 	{
 		is_enabled = pfe_gpi_cfg_qos_is_enabled(gpi->gpi_base_va);
 	}
+	else
+	{
+		is_enabled = FALSE;
+	}
 
 	return is_enabled;
 }
@@ -236,9 +244,9 @@ static void igqos_class_clear_active_all(pfe_gpi_t *gpi)
 
 static errno_t igqos_entry_ready_timeout(const pfe_gpi_t *gpi)
 {
-	errno_t ret = EOK;
+	errno_t  ret     = EOK;
 	uint32_t timeout = 200U;
-	bool_t ready;
+	bool_t   ready;
 
 	while (timeout > 0U)
 	{
@@ -267,7 +275,7 @@ static errno_t igqos_entry_ready_timeout(const pfe_gpi_t *gpi)
 static errno_t igqos_class_clear_flow_entry_table(const pfe_gpi_t *gpi)
 {
 	uint32_t ii;
-	errno_t ret = EOK;
+	errno_t  ret;
 
 	for (ii = 0U; ii < ENTRY_TABLE_SIZE; ii++)
 	{
@@ -286,7 +294,7 @@ static errno_t igqos_class_clear_flow_entry_table(const pfe_gpi_t *gpi)
 static errno_t igqos_class_clear_lru_entry_table(const pfe_gpi_t *gpi)
 {
 	uint32_t ii;
-	errno_t ret = EOK;
+	errno_t  ret;
 
 	for (ii = 0U; ii < ENTRY_TABLE_SIZE; ii++)
 	{
@@ -334,7 +342,7 @@ errno_t pfe_gpi_qos_enable(pfe_gpi_t *gpi)
 			ret = pfe_gpi_qos_reset(gpi);
 			if (EOK == ret)
 			{
-				pfe_gpi_cfg_qos_enable(gpi->gpi_base_va);;
+				pfe_gpi_cfg_qos_enable(gpi->gpi_base_va);
 			}
 		}
 	}
@@ -394,7 +402,7 @@ static uint8_t igqos_class_find_entry(const pfe_gpi_t *gpi, uint8_t start, bool_
 			}
 		}
 
-		ret = ii;  /* returns PFE_IQOS_FLOW_TABLE_SIZE if not found */
+		ret = ii; /* returns PFE_IQOS_FLOW_TABLE_SIZE if not found */
 	}
 
 	return ret;
@@ -425,39 +433,43 @@ static uint8_t igqos_class_get_next_active(pfe_gpi_t *gpi)
  */
 static uint8_t igqos_ip_mask_hw_encode(uint8_t ip_m)
 {
+	uint8_t hw_encoded;
 	if (0U != ip_m)
 	{
-		return ip_m - 1U;
+		hw_encoded  = ip_m - 1U;
 	}
 	else
 	{
-		return IGQOS_IP_MASK_0;
+		hw_encoded  = IGQOS_IP_MASK_0;
 	}
+	return hw_encoded ;
 }
 
 static uint8_t igqos_ip_mask_hw_decode(uint8_t ip_m)
 {
+	uint8_t hw_decoded;
 	if (IGQOS_IP_MASK_0 != ip_m)
 	{
-		return ip_m + 1U;
+		hw_decoded = ip_m + 1U;
 	}
 	else
 	{
-		return 0U;
+		hw_decoded = 0U;
 	}
+	return hw_decoded;
 }
 
 static void igqos_convert_entry_to_flow(const uint32_t entry[], pfe_iqos_flow_spec_t *flow)
 {
 	pfe_iqos_flow_args_t *args = &flow->args;
-	uint32_t val;
+	uint32_t              val;
 
 	/* entry reg0 */
-	val = entry[0];
+	val             = entry[0];
 	flow->type_mask = (pfe_iqos_flow_type_t)entry_arg_get(TYPE, val);
-	args->vlan = (uint16_t)entry_arg_get(VLAN_ID, val);
-	args->tos = (uint8_t)entry_arg_get(TOS, val);
-	args->l4proto = (uint8_t)entry_arg_get_lower(PROT, val);
+	args->vlan      = (uint16_t)entry_arg_get(VLAN_ID, val);
+	args->tos       = (uint8_t)entry_arg_get(TOS, val);
+	args->l4proto   = (uint8_t)entry_arg_get_lower(PROT, val);
 
 	/* entry reg1 */
 	val = entry[1];
@@ -485,14 +497,14 @@ static void igqos_convert_entry_to_flow(const uint32_t entry[], pfe_iqos_flow_sp
 	val = entry[5];
 	args->dport_min |= (uint16_t)entry_arg_get_upper(DPORT_MIN, val);
 	args->vlan_m = (uint16_t)entry_arg_get(VLAN_ID_M, val);
-	args->tos_m = (uint8_t)entry_arg_get_lower(TOS_M, val);
+	args->tos_m  = (uint8_t)entry_arg_get_lower(TOS_M, val);
 
 	/* entry reg6 */
 	val = entry[6];
 	args->tos_m |= (uint8_t)entry_arg_get_upper(TOS_M, val);
 	args->l4proto_m = (uint8_t)entry_arg_get(PROT_M, val);
-	args->sip_m = igqos_ip_mask_hw_decode((uint8_t)entry_arg_get(SIP_M, val));
-	args->dip_m = igqos_ip_mask_hw_decode((uint8_t)entry_arg_get(DIP_M, val));
+	args->sip_m     = igqos_ip_mask_hw_decode((uint8_t)entry_arg_get(SIP_M, val));
+	args->dip_m     = igqos_ip_mask_hw_decode((uint8_t)entry_arg_get(DIP_M, val));
 
 	if (entry_arg_get(ACT_DROP, val) == 1U)
 	{
@@ -508,7 +520,7 @@ static void igqos_convert_entry_to_flow(const uint32_t entry[], pfe_iqos_flow_sp
 static void igqos_convert_flow_to_entry(const pfe_iqos_flow_spec_t *flow, uint32_t entry[])
 {
 	const pfe_iqos_flow_args_t *args = &flow->args;
-	uint32_t val;
+	uint32_t                    val;
 
 	/* entry reg0 */
 	val = entry_arg_set(TYPE, (uint32_t)flow->type_mask);
@@ -656,8 +668,8 @@ static void igqos_convert_flow_to_entry(const pfe_iqos_flow_spec_t *flow, uint32
 
 errno_t pfe_gpi_qos_get_flow(const pfe_gpi_t *gpi, uint8_t id, pfe_iqos_flow_spec_t *flow)
 {
-	uint32_t class_table_entry[8] = {0U};
-	errno_t ret;
+	uint32_t class_table_entry[8] = { 0U };
+	errno_t  ret;
 
 	if (id >= PFE_IQOS_FLOW_TABLE_SIZE)
 	{
@@ -690,7 +702,7 @@ errno_t pfe_gpi_qos_rem_flow(pfe_gpi_t *gpi, uint8_t id)
 		if (igqos_class_is_active(gpi, id))
 		{
 			pfe_gpi_cfg_qos_clear_flow_entry_req(gpi->gpi_base_va, id);
-		
+
 			ret = igqos_entry_ready_timeout(gpi);
 			if (EOK == ret)
 			{
@@ -709,8 +721,8 @@ errno_t pfe_gpi_qos_rem_flow(pfe_gpi_t *gpi, uint8_t id)
 errno_t pfe_gpi_qos_add_flow(pfe_gpi_t *gpi, uint8_t id, const pfe_iqos_flow_spec_t *flow)
 {
 	uint32_t class_table_entry[8];
-	uint8_t entry_id;
-	errno_t ret;
+	uint8_t  entry_id;
+	errno_t  ret;
 
 	if ((id >= PFE_IQOS_FLOW_TABLE_SIZE) && (id != PFE_IQOS_FLOW_TABLE_ENTRY_SKIP))
 	{
@@ -783,7 +795,7 @@ errno_t pfe_gpi_qos_get_next_flow(pfe_gpi_t *gpi, uint8_t *id, pfe_iqos_flow_spe
 
 bool_t pfe_gpi_wred_is_enabled(const pfe_gpi_t *gpi, pfe_iqos_queue_t queue)
 {
-	bool_t is_enabled;
+	bool_t  is_enabled;
 	errno_t ret = pfe_gpi_null_arg_check_return(gpi, EINVAL);
 	if (ret != EOK)
 	{
@@ -848,7 +860,7 @@ errno_t pfe_gpi_wred_set_prob(const pfe_gpi_t *gpi, pfe_iqos_queue_t queue, pfe_
 	{
 		if ((queue >= PFE_IQOS_Q_COUNT) || (zone >= PFE_IQOS_WRED_ZONES_COUNT) || (val > PFE_IQOS_WRED_ZONE_PROB_MAX))
 		{
-			ret =  EINVAL;
+			ret = EINVAL;
 		}
 		else
 		{
@@ -942,8 +954,8 @@ static errno_t pfe_gpi_shp_args_checks(const pfe_gpi_t *gpi, uint8_t id)
 
 bool_t pfe_gpi_shp_is_enabled(const pfe_gpi_t *gpi, uint8_t id)
 {
-	bool_t is_enabled = FALSE;
-	errno_t ret = pfe_gpi_shp_args_checks(gpi, id);
+	bool_t  is_enabled = FALSE;
+	errno_t ret        = pfe_gpi_shp_args_checks(gpi, id);
 
 	if (ret == EOK)
 	{
@@ -961,7 +973,7 @@ errno_t pfe_gpi_shp_enable(pfe_gpi_t *gpi, uint8_t id)
 	{
 		if (TRUE != pfe_gpi_cfg_shp_is_enabled(gpi->gpi_base_va, id))
 		{
-			gpi->sys_clk_mhz = pfe_gpi_cfg_get_sys_clk_mhz(gpi->cbus_base_va);
+			gpi->sys_clk_mhz  = pfe_gpi_cfg_get_sys_clk_mhz(gpi->cbus_base_va);
 			gpi->clk_div_log2 = 0;
 			pfe_gpi_cfg_shp_default_init(gpi->gpi_base_va, id);
 			pfe_gpi_cfg_shp_enable(gpi->gpi_base_va, id);
@@ -1087,10 +1099,11 @@ static uint32_t igqos_convert_weight_to_isl(uint32_t wgt, uint32_t clk_div_log2,
 static uint32_t igqos_find_optimal_weight(uint32_t isl, uint32_t sys_clk_mhz, bool_t is_bps, uint32_t *wgt)
 {
 	const uint32_t w_max = IGQOS_PORT_SHP_WEIGHT_MASK;
-	uint32_t w, l, r, k;
+	uint32_t       w, l, r, k;
+	uint32_t       ret;
 
 	r = IGQOS_PORT_SHP_CLKDIV_MASK; /* max clk_div_log2 value */
-	l = 0; /* min clk_div_log2 value */
+	l = 0;                          /* min clk_div_log2 value */
 
 	/* check if 'isl' is out-of-range */
 	w = igqos_convert_isl_to_weight(isl, l, sys_clk_mhz, is_bps);
@@ -1098,51 +1111,61 @@ static uint32_t igqos_find_optimal_weight(uint32_t isl, uint32_t sys_clk_mhz, bo
 	{
 		NXP_LOG_WARNING("Shaper idle slope too high, weight (%u) exceeds max value\n", (uint_t)w);
 		*wgt = w;
-		return l;
+		ret  = l;
 	}
-
-	w = igqos_convert_isl_to_weight(isl, r, sys_clk_mhz, is_bps);
-	if (w == 0U)
-	{
-		NXP_LOG_WARNING("Shaper idle slope too small, computed weight is 0\n");
-		*wgt = w;
-		return r;
-	}
-
-	if (w <= w_max)
-	{
-		*wgt = w;
-		return r; /* optimum found */
-	}
-
-	/* binary search, worst case 4 iterations for r == 15 */
-	while ((l + 1U) < r)
+	else
 	{
-		k = (l + r) / 2U;
-		w = igqos_convert_isl_to_weight(isl, k, sys_clk_mhz, is_bps);
 
-		if (w <= w_max)
+		w = igqos_convert_isl_to_weight(isl, r, sys_clk_mhz, is_bps);
+		if (w == 0U)
 		{
-			l = k;
+			NXP_LOG_WARNING("Shaper idle slope too small, computed weight is 0\n");
+			*wgt = w;
+			ret  = r;
 		}
 		else
 		{
-			r = k;
-		}
-	}
 
-	k = (l + r) / 2U;
+			if (w <= w_max)
+			{
+				*wgt = w;
+				ret  = r; /* optimum found */
+			}
+			else
+			{
+
+				/* binary search, worst case 4 iterations for r == 15 */
+				while ((l + 1U) < r)
+				{
+					k = (l + r) / 2U;
+					w = igqos_convert_isl_to_weight(isl, k, sys_clk_mhz, is_bps);
 
-	*wgt = igqos_convert_isl_to_weight(isl, k, sys_clk_mhz, is_bps);
-	return k;
+					if (w <= w_max)
+					{
+						l = k;
+					}
+					else
+					{
+						r = k;
+					}
+				}
+
+				k = (l + r) / 2U;
+
+				*wgt = igqos_convert_isl_to_weight(isl, k, sys_clk_mhz, is_bps);
+				ret = k;
+			}
+		}
+	}
+	return ret;
 }
 
 errno_t pfe_gpi_shp_set_idle_slope(pfe_gpi_t *gpi, uint8_t id, uint32_t isl)
 {
 	pfe_iqos_shp_rate_mode_t mode;
-	uint32_t weight;
-	bool_t is_bps;
-	errno_t ret;
+	uint32_t                 weight;
+	bool_t                   is_bps;
+	errno_t                  ret;
 
 	ret = pfe_gpi_shp_args_checks(gpi, id);
 	if (ret == EOK)
@@ -1173,9 +1196,9 @@ errno_t pfe_gpi_shp_set_idle_slope(pfe_gpi_t *gpi, uint8_t id, uint32_t isl)
 errno_t pfe_gpi_shp_get_idle_slope(const pfe_gpi_t *gpi, uint8_t id, uint32_t *isl)
 {
 	pfe_iqos_shp_rate_mode_t mode;
-	uint32_t weight;
-	bool_t is_bps;
-	errno_t ret;
+	uint32_t                 weight;
+	bool_t                   is_bps;
+	errno_t                  ret;
 
 	ret = pfe_gpi_shp_args_checks(gpi, id);
 	if (ret == EOK)
@@ -1231,7 +1254,7 @@ errno_t pfe_gpi_shp_set_limits(const pfe_gpi_t *gpi, uint8_t id, int32_t max_cre
 errno_t pfe_gpi_shp_get_limits(const pfe_gpi_t *gpi, uint8_t id, int32_t *max_credit, int32_t *min_credit)
 {
 	uint32_t abs_max_cred, abs_min_cred;
-	errno_t ret;
+	errno_t  ret;
 
 	ret = pfe_gpi_shp_args_checks(gpi, id);
 	if (ret == EOK)
@@ -1270,14 +1293,15 @@ errno_t pfe_gpi_shp_get_drop_cnt(const pfe_gpi_t *gpi, uint8_t id, uint32_t *cnt
 uint32_t pfe_gpi_get_text_statistics(const pfe_gpi_t *gpi, char_t *buf, uint32_t buf_len, uint8_t verb_level)
 {
 	uint32_t len = 0U;
-	errno_t ret = pfe_gpi_null_arg_check_return(gpi, EINVAL);
+	errno_t  ret = pfe_gpi_null_arg_check_return(gpi, EINVAL);
 	if (ret != EOK)
 	{
-		return 0U;
+		len = 0U;
+	}
+	else
+	{
+		len += pfe_gpi_cfg_get_text_stat(gpi->gpi_base_va, buf, buf_len, verb_level);
 	}
-
-	len += pfe_gpi_cfg_get_text_stat(gpi->gpi_base_va, buf, buf_len, verb_level);
-
 
 	return len;
 }
diff --git a/sw/pfe_platform/src/pfe_hif_chnl_linux.c b/sw/pfe_platform/src/pfe_hif_chnl_linux.c
index a8a442f..507b5c3 100644
--- a/sw/pfe_platform/src/pfe_hif_chnl_linux.c
+++ b/sw/pfe_platform/src/pfe_hif_chnl_linux.c
@@ -96,11 +96,7 @@
 #define DUMMY_TX_BUF_LEN		64U
 #define DUMMY_RX_BUF_LEN		2048U
 
-#if defined(PFE_CFG_TARGET_OS_AUTOSAR)
-	#define BUFFERS_CACHED FALSE
-#else
-	#define BUFFERS_CACHED TRUE
-#endif
+#define BUFFERS_CACHED TRUE
 
 typedef struct
 {
@@ -116,26 +112,18 @@ typedef struct
  */
 struct __attribute__((aligned(HAL_CACHE_LINE_SIZE))) __pfe_hif_chnl_tag
 {
-	addr_t cbus_base_va;				/*	CBUS base virtual address */
-	uint32_t id;					/*	Channel ID within HIF (0, 1, 2, ...) */
-	pfe_hif_ring_t *rx_ring;		/*	The RX ring instance */
-	pfe_hif_ring_t *tx_ring;		/*	The TX ring instance */
+	addr_t cbus_base_va;		/*	CBUS base virtual address */
+	uint32_t id;			/*	Channel ID within HIF (0, 1, 2, ...) */
+	pfe_hif_ring_t *rx_ring;	/*	The RX ring instance */
+	pfe_hif_ring_t *tx_ring;	/*	The TX ring instance */
 #if (TRUE == PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED)
-	bpool_t *rx_pool;				/*	Pool of available RX buffers */
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	const pfe_bmu_t *bmu;					/*	Associated BMU instance */
-	void *tx_ibuf_va;				/*	Intermediate TX buffer VA */
-	uint16_t tx_ibuf_len;			/*	Number of bytes in the ibuf */
-	uint32_t a_cnt;					/*	BMU allocations counter */
-	/*	Mutex protecting the allocations counter */
-	oal_spinlock_t a_lock __attribute__((aligned(HAL_CACHE_LINE_SIZE)));
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
+	bpool_t *rx_pool;		/*	Pool of available RX buffers */
 #endif /* PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED */
-	oal_spinlock_t lock __attribute__((aligned(HAL_CACHE_LINE_SIZE)));				/*	Channel HW resources protection */
-	oal_spinlock_t rx_lock __attribute__((aligned(HAL_CACHE_LINE_SIZE)));			/*	RX resource protection */
-	pfe_hif_chnl_cbk_storage_t rx_cbk;		/*	RX callback */
-	pfe_hif_chnl_cbk_storage_t tx_cbk;		/*	TX callback */
-	pfe_hif_chnl_cbk_storage_t rx_tx_cbk;		/*	RX/TX callback */
+	oal_spinlock_t lock __attribute__((aligned(HAL_CACHE_LINE_SIZE)));	/*	Channel HW resources protection */
+	oal_spinlock_t rx_lock __attribute__((aligned(HAL_CACHE_LINE_SIZE)));	/*	RX resource protection */
+	pfe_hif_chnl_cbk_storage_t rx_cbk;	/*	RX callback */
+	pfe_hif_chnl_cbk_storage_t tx_cbk;	/*	TX callback */
+	pfe_hif_chnl_cbk_storage_t rx_tx_cbk;	/*	RX/TX callback */
 #if (TRUE == PFE_HIF_CHNL_CFG_RX_OOB_EVENT_ENABLED)
 	pfe_hif_chnl_cbk_storage_t rx_oob_cbk;	/*	RX Out-Of-Buffers callback */
 #endif
@@ -150,74 +138,6 @@ static errno_t pfe_hif_chnl_flush_rx_bd_fifo(pfe_hif_chnl_t *chnl) __attribute__
 static void pfe_hif_chnl_refill_rx_buffers(const pfe_hif_chnl_t *chnl) __attribute__((hot));
 #endif /* PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED */
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-/*
- * @brief	Increment buffer allocation counter
- * @details	To monitor how many BMU buffers have been allocated
- * 			by a channel instance we need to provide a SW counter.
- */
-static void pfe_hif_chnl_alloc_inc(pfe_hif_chnl_t *chnl)
-{
-	if (EOK != oal_spinlock_lock(&chnl->a_lock))
-	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
-
-	chnl->a_cnt++;
-
-	if (EOK != oal_spinlock_unlock(&chnl->a_lock))
-	{
-		NXP_LOG_DEBUG("Mutex unlock failed\n");
-	}
-}
-
-/*
- * @brief	Decrement buffer allocation counter
- * @details	To monitor how many BMU buffers have been allocated
- * 			by a channel instance we need to provide a SW counter.
- */
-static void pfe_hif_chnl_alloc_dec(pfe_hif_chnl_t *chnl)
-{
-	if (EOK != oal_spinlock_lock(&chnl->a_lock))
-	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
-
-	chnl->a_cnt--;
-
-	if (EOK != oal_spinlock_unlock(&chnl->a_lock))
-	{
-		NXP_LOG_DEBUG("Mutex unlock failed\n");
-	}
-}
-
-/*
- * @brief	Get state of allocation counter
- * @details	To monitor how many BMU buffers have been allocated
- * 			by a channel instance we need to provide a SW counter.
- * @return	Current number of allocated buffers.
- */
-static uint32_t pfe_hif_chnl_get_alloc_cnt(pfe_hif_chnl_t *chnl)
-{
-	uint32_t ret;
-
-	if (EOK != oal_spinlock_lock(&chnl->a_lock))
-	{
-		NXP_LOG_DEBUG("Mutex lock failed\n");
-	}
-
-	ret = chnl->a_cnt;
-
-	if (EOK != oal_spinlock_unlock(&chnl->a_lock))
-	{
-		NXP_LOG_DEBUG("Mutex unlock failed\n");
-	}
-
-	return ret;
-}
-
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-
 /**
  * @brief		Channel master ISR
  * @param[in]	chnl The channel instance
@@ -242,17 +162,7 @@ __attribute__((hot)) errno_t pfe_hif_chnl_isr(pfe_hif_chnl_t *chnl)
 	}
 
 	/*	Run the low-level ISR to identify and process the interrupt */
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF_NOCPY */
-		ret = pfe_hif_nocpy_cfg_isr(chnl->cbus_base_va, &events);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		ret = pfe_hif_chnl_cfg_isr(chnl->cbus_base_va, chnl->id, &events);
-	}
+	ret = pfe_hif_chnl_cfg_isr(chnl->cbus_base_va, chnl->id, &events);
 
 	if (EOK != oal_spinlock_unlock(&chnl->lock))
 	{
@@ -269,7 +179,6 @@ __attribute__((hot)) errno_t pfe_hif_chnl_isr(pfe_hif_chnl_t *chnl)
 	}
 	else
 	{
-
 		if (HIF_CHNL_EVT_RX_IRQ == (events & HIF_CHNL_EVT_RX_IRQ))
 		{
 			if (NULL != chnl->rx_cbk.cbk)
@@ -309,17 +218,7 @@ void pfe_hif_chnl_irq_mask(pfe_hif_chnl_t *chnl)
 		NXP_LOG_DEBUG("Mutex lock failed\n");
 	}
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF_NOCPY */
-		pfe_hif_nocpy_cfg_irq_mask(chnl->cbus_base_va);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		pfe_hif_chnl_cfg_irq_mask(chnl->cbus_base_va, chnl->id);
-	}
+	pfe_hif_chnl_cfg_irq_mask(chnl->cbus_base_va, chnl->id);
 
 	if (EOK != oal_spinlock_unlock(&chnl->lock))
 	{
@@ -338,17 +237,7 @@ void pfe_hif_chnl_irq_unmask(pfe_hif_chnl_t *chnl)
 		NXP_LOG_DEBUG("Mutex lock failed\n");
 	}
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF_NOCPY */
-		pfe_hif_nocpy_cfg_irq_unmask(chnl->cbus_base_va);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		pfe_hif_chnl_cfg_irq_unmask(chnl->cbus_base_va, chnl->id);
-	}
+	pfe_hif_chnl_cfg_irq_unmask(chnl->cbus_base_va, chnl->id);
 
 	if (EOK != oal_spinlock_unlock(&chnl->lock))
 	{
@@ -435,13 +324,11 @@ __attribute__((cold)) pfe_hif_chnl_t *pfe_hif_chnl_create(addr_t cbus_base_va, u
 	}
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
-#if !defined(PFE_CFG_HIF_NOCPY_SUPPORT)
 	if (id >= PFE_HIF_CHNL_NOCPY_ID)
 	{
-		NXP_LOG_ERROR("HIF NOCPY support is not enabled\n");
+		NXP_LOG_ERROR("HIF NOCPY is not supported\n");
 		return NULL;
 	}
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
 
 	chnl = oal_mm_malloc_contig_aligned_cache(sizeof(pfe_hif_chnl_t), HAL_CACHE_LINE_SIZE);
 
@@ -458,32 +345,12 @@ __attribute__((cold)) pfe_hif_chnl_t *pfe_hif_chnl_create(addr_t cbus_base_va, u
 		chnl->rx_ring = NULL;
 #if (TRUE == PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED)
 		chnl->rx_pool = NULL;
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-		chnl->bmu = bmu;
-		chnl->tx_ibuf_va = NULL;
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
 #endif /* PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED */
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-		if (EOK != oal_spinlock_init(&chnl->a_lock))
-		{
-			NXP_LOG_ERROR("Channel BMU allocation mutex initialization failed\n");
-			oal_mm_free_contig(chnl);
-			return NULL;
-		}
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-
 		if (EOK != oal_spinlock_init(&chnl->lock))
 		{
 			NXP_LOG_ERROR("Channel mutex initialization failed\n");
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-			if (EOK != oal_spinlock_destroy(&chnl->a_lock))
-			{
-				NXP_LOG_WARNING("Could not properly destroy mutex\n");
-			}
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-
 			oal_mm_free_contig(chnl);
 
 			return NULL;
@@ -493,57 +360,36 @@ __attribute__((cold)) pfe_hif_chnl_t *pfe_hif_chnl_create(addr_t cbus_base_va, u
 		{
 			NXP_LOG_ERROR("Channel RX mutex initialization failed\n");
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-			(void)oal_spinlock_destroy(&chnl->a_lock);
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-
 			(void)oal_spinlock_destroy(&chnl->lock);
 			oal_mm_free_contig(chnl);
 
 			return NULL;
 		}
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-		if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-		{
 #if (TRUE == PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED)
-			if (NULL == chnl->bmu)
-			{
-				NXP_LOG_ERROR("HIF NOCPY channel requires BMU instance\n");
-				goto free_and_fail;
-			}
-#endif /* PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED */
-			/*	HIF_NOCPY does not need per-channel initialization */
-			;
-		}
-		else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
+		if (NULL != bmu)
 		{
-#if (TRUE == PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED)
-			if (NULL != bmu)
-			{
-				/*	This is not supported. SW buffer pool will be used instead. */
-				NXP_LOG_WARNING("BMU-based RX buffer pool not supported for standard HIF channels. SW pool will be used instead.\n");
-			}
+			/*	This is not supported. SW buffer pool will be used instead. */
+			NXP_LOG_WARNING("BMU-based RX buffer pool not supported for standard HIF channels. SW pool will be used instead.\n");
+		}
 #endif /* PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED */
 
-			if (EOK != oal_spinlock_lock(&chnl->lock))
-			{
-				NXP_LOG_DEBUG("Mutex lock failed\n");
-			}
+		if (EOK != oal_spinlock_lock(&chnl->lock))
+		{
+			NXP_LOG_DEBUG("Mutex lock failed\n");
+		}
 
-			ret = pfe_hif_chnl_cfg_init(chnl->cbus_base_va, id);
+		ret = pfe_hif_chnl_cfg_init(chnl->cbus_base_va, id);
 
-			if (EOK != oal_spinlock_unlock(&chnl->lock))
-			{
-				NXP_LOG_DEBUG("Mutex unlock failed\n");
-			}
+		if (EOK != oal_spinlock_unlock(&chnl->lock))
+		{
+			NXP_LOG_DEBUG("Mutex unlock failed\n");
+		}
 
-			if (EOK != ret)
-			{
-				NXP_LOG_ERROR("HIF channel init failed\n");
-				goto free_and_fail;
-			}
+		if (EOK != ret)
+		{
+			NXP_LOG_ERROR("HIF channel init failed\n");
+			goto free_and_fail;
 		}
 
 		(void) pfe_hif_chnl_init(chnl);
@@ -552,9 +398,6 @@ __attribute__((cold)) pfe_hif_chnl_t *pfe_hif_chnl_create(addr_t cbus_base_va, u
 	return chnl;
 
 free_and_fail:
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	(void)oal_spinlock_destroy(&chnl->a_lock);
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
 
 	(void)oal_spinlock_destroy(&chnl->lock);
 	(void)oal_spinlock_destroy(&chnl->rx_lock);
@@ -609,18 +452,8 @@ __attribute__((cold)) errno_t pfe_hif_chnl_tx_enable(pfe_hif_chnl_t *chnl)
 		NXP_LOG_DEBUG("Mutex lock failed\n");
 	}
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF_NOCPY */
-		pfe_hif_nocpy_cfg_tx_enable(chnl->cbus_base_va);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		/*	HIF */
-		pfe_hif_chnl_cfg_tx_enable(chnl->cbus_base_va, chnl->id);
-	}
+	/*	HIF */
+	pfe_hif_chnl_cfg_tx_enable(chnl->cbus_base_va, chnl->id);
 
 	if (EOK != oal_spinlock_unlock(&chnl->lock))
 	{
@@ -654,18 +487,7 @@ __attribute__((cold)) void pfe_hif_chnl_tx_disable(pfe_hif_chnl_t *chnl)
 	}
 
 	/*	Stop data transmission */
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF_NOCPY */
-		pfe_hif_nocpy_cfg_tx_disable(chnl->cbus_base_va);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		/*	HIF */
-		pfe_hif_chnl_cfg_tx_disable(chnl->cbus_base_va, chnl->id);
-	}
+	pfe_hif_chnl_cfg_tx_disable(chnl->cbus_base_va, chnl->id);
 
 	if (EOK != oal_spinlock_unlock(&chnl->lock))
 	{
@@ -707,18 +529,8 @@ __attribute__((cold)) errno_t pfe_hif_chnl_rx_enable(pfe_hif_chnl_t *chnl)
 		NXP_LOG_DEBUG("Mutex lock failed\n");
 	}
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF_NOCPY */
-		pfe_hif_nocpy_cfg_rx_enable(chnl->cbus_base_va);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		/*	HIF */
-		pfe_hif_chnl_cfg_rx_enable(chnl->cbus_base_va, chnl->id);
-	}
+	/*	HIF */
+	pfe_hif_chnl_cfg_rx_enable(chnl->cbus_base_va, chnl->id);
 
 	if (EOK != oal_spinlock_unlock(&chnl->lock))
 	{
@@ -750,18 +562,7 @@ __attribute__((cold)) void pfe_hif_chnl_rx_disable(pfe_hif_chnl_t *chnl)
 	}
 
 	/*	Stop data reception */
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF_NOCPY */
-		pfe_hif_nocpy_cfg_rx_disable(chnl->cbus_base_va);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		/*	HIF */
-		pfe_hif_chnl_cfg_rx_disable(chnl->cbus_base_va, chnl->id);
-	}
+	pfe_hif_chnl_cfg_rx_disable(chnl->cbus_base_va, chnl->id);
 
 	if (EOK != oal_spinlock_unlock(&chnl->lock))
 	{
@@ -787,19 +588,7 @@ __attribute__((hot)) void pfe_hif_chnl_rx_dma_start(const pfe_hif_chnl_t *chnl)
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
 	/*	No resource protection here, DMA trigger is atomic. */
-
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF_NOCPY */
-		pfe_hif_nocpy_cfg_rx_dma_start(chnl->cbus_base_va);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		/*	HIF */
-		pfe_hif_chnl_cfg_rx_dma_start(chnl->cbus_base_va, chnl->id);
-	}
+	pfe_hif_chnl_cfg_rx_dma_start(chnl->cbus_base_va, chnl->id);
 }
 
 /**
@@ -819,19 +608,7 @@ __attribute__((hot)) void pfe_hif_chnl_tx_dma_start(const pfe_hif_chnl_t *chnl)
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
 	/*	No resource protection here. DMA trigger is atomic. */
-
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF_NOCPY */
-		pfe_hif_nocpy_cfg_tx_dma_start(chnl->cbus_base_va);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		/*	HIF */
-		pfe_hif_chnl_cfg_tx_dma_start(chnl->cbus_base_va, chnl->id);
-	}
+	pfe_hif_chnl_cfg_tx_dma_start(chnl->cbus_base_va, chnl->id);
 }
 
 /**
@@ -920,17 +697,7 @@ __attribute__((hot)) void pfe_hif_chnl_rx_irq_mask(pfe_hif_chnl_t *chnl)
 		NXP_LOG_ERROR("Mutex lock failed\n");
 	}
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF_NOCPY */
-		pfe_hif_nocpy_cfg_rx_irq_mask(chnl->cbus_base_va);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		pfe_hif_chnl_cfg_rx_irq_mask(chnl->cbus_base_va, chnl->id);
-	}
+	pfe_hif_chnl_cfg_rx_irq_mask(chnl->cbus_base_va, chnl->id);
 
 	if (EOK != oal_spinlock_unlock(&chnl->lock))
 	{
@@ -958,17 +725,7 @@ __attribute__((hot)) void pfe_hif_chnl_rx_irq_unmask(pfe_hif_chnl_t *chnl)
 		NXP_LOG_ERROR("Mutex lock failed\n");
 	}
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF_NOCPY */
-		pfe_hif_nocpy_cfg_rx_irq_unmask(chnl->cbus_base_va);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		pfe_hif_chnl_cfg_rx_irq_unmask(chnl->cbus_base_va, chnl->id);
-	}
+	pfe_hif_chnl_cfg_rx_irq_unmask(chnl->cbus_base_va, chnl->id);
 
 	if (EOK != oal_spinlock_unlock(&chnl->lock))
 	{
@@ -996,17 +753,7 @@ __attribute__((hot)) void pfe_hif_chnl_tx_irq_mask(pfe_hif_chnl_t *chnl)
 		NXP_LOG_DEBUG("Mutex lock failed\n");
 	}
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF_NOCPY */
-		pfe_hif_nocpy_cfg_tx_irq_mask(chnl->cbus_base_va);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		pfe_hif_chnl_cfg_tx_irq_mask(chnl->cbus_base_va, chnl->id);
-	}
+	pfe_hif_chnl_cfg_tx_irq_mask(chnl->cbus_base_va, chnl->id);
 
 	if (EOK != oal_spinlock_unlock(&chnl->lock))
 	{
@@ -1034,17 +781,7 @@ __attribute__((hot)) void pfe_hif_chnl_tx_irq_unmask(pfe_hif_chnl_t *chnl)
 		NXP_LOG_DEBUG("Mutex lock failed\n");
 	}
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF_NOCPY */
-		pfe_hif_nocpy_cfg_tx_irq_unmask(chnl->cbus_base_va);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		pfe_hif_chnl_cfg_tx_irq_unmask(chnl->cbus_base_va, chnl->id);
-	}
+	pfe_hif_chnl_cfg_tx_irq_unmask(chnl->cbus_base_va, chnl->id);
 
 	if (EOK != oal_spinlock_unlock(&chnl->lock))
 	{
@@ -1133,13 +870,6 @@ __attribute__((pure, hot)) bool_t pfe_hif_chnl_can_accept_rx_buf(const pfe_hif_c
 	}
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-        return FALSE;
-    }
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-
 	/*	A single entry must remain unused within the ring
 	 	because HIF expects that. */
 	return (pfe_hif_ring_get_fill_level(chnl->rx_ring) < (pfe_hif_ring_get_len(chnl->rx_ring) - 1U));
@@ -1240,10 +970,6 @@ __attribute__((pure, cold)) uint32_t pfe_hif_chnl_get_tx_fifo_depth(const pfe_hi
 __attribute__((hot)) errno_t pfe_hif_chnl_tx(pfe_hif_chnl_t *chnl, const void *buf_pa, const void *buf_va, uint32_t len, bool_t lifm)
 {
 	errno_t err = EOK;
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	uint32_t u32tmp;
-	void *tx_ibuf_pa;
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == chnl) || (NULL == buf_pa)))
@@ -1258,111 +984,8 @@ __attribute__((hot)) errno_t pfe_hif_chnl_tx(pfe_hif_chnl_t *chnl, const void *b
 	oal_mm_cache_flush(buf_va, buf_pa, len);
 #endif /* HAL_HANDLE_CACHE */
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	TODO: What in case when caller is trying to re-transmit a buffer
-				  previously obtained via pfe_hif_chnl_rx() (io-pkt does this
-				  in case of forwarding use case)???
-
-			- first chunk to send will be the HIF TX header
-			- second chunk will be the BMU buffer
-			- how to handle that?
-
-			If no special action will be performed, new BMU buffer will be allocated
-			and the packet will be formed within it = not optimal approach...
-		*/
-
-		if (NULL == chnl->tx_ibuf_va)
-		{
-			/*	The intermediate buffer has not been allocated yet */
-			tx_ibuf_pa = pfe_bmu_alloc_buf(chnl->bmu);
-			if (unlikely(NULL == tx_ibuf_pa))
-			{
-				NXP_LOG_ERROR("BMU can't allocate TX buffer\n");
-				return ENOMEM;
-			}
-			else
-			{
-				/*	Increment BMU allocations counter */
-				pfe_hif_chnl_alloc_inc(chnl);
-
-				/*	Get VA */
-				chnl->tx_ibuf_va = pfe_bmu_get_va(chnl->bmu, (addr_t)tx_ibuf_pa);
-				chnl->tx_ibuf_len = 0U;
-			}
-		}
-
-		tx_ibuf_pa = pfe_bmu_get_pa(chnl->bmu, (addr_t)chnl->tx_ibuf_va);
-
-		/*	Copy payload into the intermediate buffer, leave 256 + PFE_CFG_LMEM_HDR_SIZE bytes empty like
-		    HIF and EMAC do. This space is then used. */
-		if (unlikely((chnl->tx_ibuf_len + len) > (pfe_bmu_get_buf_size(chnl->bmu) - (256U + PFE_CFG_LMEM_HDR_SIZE))))
-		{
-			NXP_LOG_ERROR("Payload exceeds BMU buffer length\n");
-
-			/*	Drop. Resource protection is embedded. */
-			pfe_bmu_free_buf(chnl->bmu, (addr_t)tx_ibuf_pa);
-			chnl->tx_ibuf_va = NULL;
-			chnl->tx_ibuf_len = 0U;
-
-			/*	Decrement BMU allocations counter */
-			pfe_hif_chnl_alloc_dec(chnl);
-
-			return ENOMEM;
-		}
-
-		memcpy((void *)((addr_t)chnl->tx_ibuf_va + (256U + PFE_CFG_LMEM_HDR_SIZE) + chnl->tx_ibuf_len), buf_va, len);
-		chnl->tx_ibuf_len = chnl->tx_ibuf_len + len;
-
-		if (TRUE == lifm)
-		{
-			/*	Enqueue the intermediate buffer */
-			/* Documentation says we need to build structure as described in
-			   Figure 5: GPI-RX- LMEM Buffer Structure & DDR Buffer Structure */
-			/* DDR buffer physical address */
-			u32tmp = oal_htonl((addr_t)tx_ibuf_pa);
-			memcpy(chnl->tx_ibuf_va, &u32tmp, sizeof(u32tmp));
-
-			/* Length and PHYNO */
-			u32tmp = oal_htons(chnl->tx_ibuf_len) | (PFE_PHY_IF_ID_HIF_NOCPY << 24U);
-			memcpy(chnl->tx_ibuf_va + sizeof(u32tmp), &u32tmp, sizeof(u32tmp));
-
-			/* EMAC statistics */
-			memset(chnl->tx_ibuf_va + (2U * sizeof(uint32_t)), 0U, sizeof(uint32_t));
-
-			/* Copy the portion of data to get into LMEM buffer */
-			/* AAVB-3403 shall remove this memcpy() call */
-			u32tmp = ((PFE_CFG_LMEM_BUF_SIZE - PFE_CFG_LMEM_HDR_SIZE) < chnl->tx_ibuf_len)
-							? (PFE_CFG_LMEM_BUF_SIZE - PFE_CFG_LMEM_HDR_SIZE) : chnl->tx_ibuf_len;
-			memcpy(chnl->tx_ibuf_va + PFE_CFG_LMEM_HDR_SIZE, chnl->tx_ibuf_va + (256U + PFE_CFG_LMEM_HDR_SIZE), u32tmp);
-
-			/*	Enqueue the buffer into TX ring */
-			tx_ibuf_pa = pfe_bmu_get_pa(chnl->bmu, (addr_t)chnl->tx_ibuf_va);
-			err = pfe_hif_ring_enqueue_buf(chnl->tx_ring, tx_ibuf_pa, chnl->tx_ibuf_len, TRUE);
-
-			if (unlikely(EOK != err))
-			{
-				/*	Drop. Resource protection is embedded. */
-				pfe_bmu_free_buf(chnl->bmu, (addr_t)tx_ibuf_pa);
-
-				/*	Decrement BMU allocations counter */
-				pfe_hif_chnl_alloc_dec(chnl);
-			}
-
-			/*	Reset the intermediate buffer. No release here since it will
-			 	(should) be done by the PFE HW. */
-			chnl->tx_ibuf_va = NULL;
-			chnl->tx_ibuf_len = 0U;
-		}
-	}
-	else
-#else
 	(void)buf_va;
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		err = pfe_hif_ring_enqueue_buf(chnl->tx_ring, buf_pa, len, lifm);
-	}
+	err = pfe_hif_ring_enqueue_buf(chnl->tx_ring, buf_pa, len, lifm);
 
 	if (TRUE == lifm)
 	{
@@ -1397,16 +1020,6 @@ __attribute__((hot)) errno_t pfe_hif_chnl_get_tx_conf(pfe_hif_chnl_t *chnl)
 		will be reported as TX confirmation. */
 	while (EOK == pfe_hif_ring_dequeue_plain(chnl->tx_ring, &lifm))
 	{
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-		if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-		{
-			/*	Decrement BMU allocations counter. It is here because we expect that
-				the PFE HW just released a TX buffer previously allocated from BMU
-				pool within the pfe_hif_chnl_tx(). */
-			pfe_hif_chnl_alloc_dec(chnl);
-		}
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-
 		if (TRUE == lifm)
 		{
 			return EOK;
@@ -1446,17 +1059,6 @@ __attribute__((hot)) errno_t pfe_hif_chnl_rx(pfe_hif_chnl_t *chnl, void **buf_pa
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
 	err = pfe_hif_ring_dequeue_buf(chnl->rx_ring, buf_pa, len, lifm);
-	
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	Increment BMU allocations counter. We have not allocated a buffer from BMU
-			directly but the HW did that and then provided us the buffer. Therefore we
-			need to properly handle it (release it once it has been processed). So we
-			are counting it as allocated buffer here... */
-		pfe_hif_chnl_alloc_inc(chnl);
-	}
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
 
 #if (TRUE == PFE_HIF_CHNL_CFG_RX_OOB_EVENT_ENABLED)
 	/*	Check if ring has enough RX buffers */
@@ -1473,8 +1075,8 @@ __attribute__((hot)) errno_t pfe_hif_chnl_rx(pfe_hif_chnl_t *chnl, void **buf_pa
 	return err;
 }
 #endif /* PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED */
-#if (TRUE == PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED)
 
+#if (TRUE == PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED)
 /**
  * @brief		Receive a buffer (virtual address)
  * @details		When channel has received some data into RX buffer then this
@@ -1499,6 +1101,9 @@ __attribute__((hot)) errno_t pfe_hif_chnl_rx_va(pfe_hif_chnl_t *chnl, void **buf
 {
 	errno_t err;
 	void *buf_pa;
+	pfe_ct_hif_rx_hdr_t *hif_hdr_ptr = NULL;
+	uint32_t vlan_header;
+	uint32_t flags_map[4] = {HIF_RX_HIF0_VLAN, HIF_RX_HIF1_VLAN, HIF_RX_HIF2_VLAN, HIF_RX_HIF3_VLAN};
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == chnl) || (NULL == buf_va) || (NULL == len) || (NULL == lifm) || (NULL == meta)))
@@ -1511,61 +1116,29 @@ __attribute__((hot)) errno_t pfe_hif_chnl_rx_va(pfe_hif_chnl_t *chnl, void **buf
 	err = pfe_hif_ring_dequeue_buf(chnl->rx_ring, &buf_pa, len, lifm);
 	if (EOK == err)
 	{
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-		if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-		{
-			/*	HIF NOCPY */
-
-			/*	Addresses coming from the ring are physical addresses of buffers provided by BMU. The
-			 	buffer contains so called post-classification header the PFE classifier is internally
-			 	using as well as specific HIF header. Headers start from buffer offset 0x0 and we shall
-				strip-off the post-classification header here since upper layers do not know about such
-				thing. The space can be (and will be) used as the buffer-specific metadata storage. */
-			*buf_va = pfe_bmu_get_va(chnl->bmu, (addr_t)buf_pa);
-#if defined(PFE_CFG_NULL_ARG_CHECK)
-			if (unlikely(NULL == *buf_va))
-			{
-				NXP_LOG_DEBUG("Fatal: BMU converted p0x%p to v0x0\n", buf_pa);
-			}
-			else
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-			/*	Get metadata storage (misuse the buffer headers) */
-			*meta = *buf_va;
+		/*	Return virtual address */
+		*buf_va = bpool_get_va(chnl->rx_pool, buf_pa);
 
-			/*	Skip the post-classification header to gain space for metadata storage.
-			 	The pfe_hif_chnl_release_buf() must be aware of this adjustment before
-				it will attempt to release buffer back to BMU hardware pool. This will
-				ensure the caller will receive also the HIF TX header but can reuse it
-				for custom purposes (see the pfe_hif_chnl_get_meta_size()). */
-			*buf_va = (void *)((addr_t)*buf_va + sizeof(pfe_ct_post_cls_hdr_t));
-
-#if (TRUE == HAL_HANDLE_CACHE)
-			/*	Invalidate cache over the buffer */
-			oal_mm_cache_inval(*buf_va, buf_pa, *len);
-#endif /* HAL_HANDLE_CACHE */
-
-			/*	Increment BMU allocations counter. We have not allocated a buffer from BMU
-				directly but the HW did that and then provided us the buffer. Therefore we
-				need to properly handle it (release it once it has been processed). So we
-				are counting this reception as allocated buffer here... */
-			pfe_hif_chnl_alloc_inc(chnl);
-		}
-		else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
+		hif_hdr_ptr = (pfe_ct_hif_rx_hdr_t *) *buf_va;
+		/*      Check if pkt is tagged */
+		if ((oal_ntohl(hif_hdr_ptr->flags) & (flags_map[chnl->id])) != 0)
 		{
-			/*	Return virtual address */
-			*buf_va = bpool_get_va(chnl->rx_pool, buf_pa);
+			/*	On HIF hw is adding the vlan tag at 12 byte offset from the beggining
+				of the buffer. Copy the vlan header to the right position at offset 12
+				of the pkt witch is after the hif rx header. */
+			vlan_header = hif_hdr_ptr->rx_timestamp_s;
+			memmove((uint8_t *)*buf_va + 2*MAC_ADDRESS_SIZE, (uint8_t *)*buf_va + sizeof(pfe_ct_hif_rx_hdr_t), 2*MAC_ADDRESS_SIZE + sizeof(vlan_header));
+			memcpy((uint8_t *)*buf_va + sizeof(pfe_ct_hif_rx_hdr_t) + 2*MAC_ADDRESS_SIZE, &vlan_header, sizeof(vlan_header));
+		}
 
 #if (TRUE == HAL_HANDLE_CACHE)
-			/*	Invalidate cache over the received data area */
-			oal_mm_cache_inval(*buf_va, buf_pa, *len);
+		/*	Invalidate cache over the received data area */
+		oal_mm_cache_inval(*buf_va, buf_pa, *len);
 #endif /* HAL_HANDLE_CACHE */
 
-			/*	Return pointer to the pre-allocated memory location where
-				a buffer-related metadata can be stored. */
-			*meta = bpool_get_meta_storage(chnl->rx_pool, *buf_va);
-		}
+		/*	Return pointer to the pre-allocated memory location where
+			a buffer-related metadata can be stored. */
+		*meta = bpool_get_meta_storage(chnl->rx_pool, *buf_va);
 	}
 
 #if (TRUE == PFE_HIF_CHNL_CFG_RX_OOB_EVENT_ENABLED)
@@ -1596,32 +1169,8 @@ __attribute__((hot)) errno_t pfe_hif_chnl_rx_va(pfe_hif_chnl_t *chnl, void **buf
  */
 __attribute__((cold)) uint32_t pfe_hif_chnl_get_meta_size(const pfe_hif_chnl_t *chnl)
 {
-#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely(NULL == chnl))
-	{
-		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF NOCPY */
-
-		/*	In case of HIF NOCPY we're using whole RX packet header headroom
-		 	for metadata storage. The headroom includes post-classification
-		 	header and the HIF header. Both can be overwritten by custom
-		 	data. */
-		return sizeof(pfe_ct_post_cls_hdr_t) + sizeof(pfe_ct_hif_rx_hdr_t);
-	}
-	else
-#elif !defined(PFE_CFG_NULL_ARG_CHECK)
 	(void)chnl;
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		return bpool_get_meta_storage_size();
-	}
+	return bpool_get_meta_storage_size();
 }
 
 /**
@@ -1643,48 +1192,24 @@ __attribute__((hot)) errno_t pfe_hif_chnl_release_buf(pfe_hif_chnl_t *chnl, void
 	}
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF NOCPY */
-
-		/*	Get physical address */
-		buf_pa = (addr_t)pfe_bmu_get_pa(chnl->bmu, (addr_t)buf_va);
-
-		/*	Apply the correction due to post-classification header skip done
-		 	during the buffer reception. */
-		buf_pa = buf_pa - sizeof(pfe_ct_post_cls_hdr_t);
-
-		/*	Release the buffer to BMU pool. Resource protection is embedded. */
-		pfe_bmu_free_buf(chnl->bmu, buf_pa);
+	buf_pa = (addr_t)bpool_get_pa(chnl->rx_pool, buf_va);
 
-		/*	Decrement BMU allocations counter */
-		pfe_hif_chnl_alloc_dec(chnl);
-
-		ret = EOK;
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
+	if (unlikely(NULL == (void *)buf_pa))
 	{
-		buf_pa = (addr_t)bpool_get_pa(chnl->rx_pool, buf_va);
-
-		if (unlikely(NULL == (void *)buf_pa))
-		{
-			NXP_LOG_ERROR("VA->PA conversion failed, origin buffer VA: v0x%p\n", buf_va);
-		}
+		NXP_LOG_ERROR("VA->PA conversion failed, origin buffer VA: v0x%p\n", buf_va);
+	}
 
-		if (unlikely(EOK != oal_spinlock_lock(&chnl->rx_lock)))
-		{
-			NXP_LOG_DEBUG("Mutex lock failed\n");
-		}
+	if (unlikely(EOK != oal_spinlock_lock(&chnl->rx_lock)))
+	{
+		NXP_LOG_DEBUG("Mutex lock failed\n");
+	}
 
-		/*	Release the buffer to ring */
-		ret = pfe_hif_ring_enqueue_buf(chnl->rx_ring, (void *)buf_pa, PFE_BUF_SIZE, TRUE);
+	/*	Release the buffer to ring */
+	ret = pfe_hif_ring_enqueue_buf(chnl->rx_ring, (void *)buf_pa, PFE_BUF_SIZE, TRUE);
 
-		if (unlikely(EOK != oal_spinlock_unlock(&chnl->rx_lock)))
-		{
-			NXP_LOG_DEBUG("Mutex unlock failed\n");
-		}
+	if (unlikely(EOK != oal_spinlock_unlock(&chnl->rx_lock)))
+	{
+		NXP_LOG_DEBUG("Mutex unlock failed\n");
 	}
 
 	return ret;
@@ -1712,20 +1237,10 @@ __attribute__((hot)) errno_t pfe_hif_chnl_supply_rx_buf(const pfe_hif_chnl_t *ch
 	}
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	There is noting to supply to HIF NOCPY */
-		err = EINVAL;
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
+	err = pfe_hif_ring_enqueue_buf(chnl->rx_ring, buf_pa, size, TRUE);
+	if (unlikely(EOK != err))
 	{
-		err = pfe_hif_ring_enqueue_buf(chnl->rx_ring, buf_pa, size, TRUE);
-		if (unlikely(EOK != err))
-		{
-			NXP_LOG_WARNING("pfe_hif_ring_enqueue_buf() failed: %d\n", err);
-		}
+		NXP_LOG_WARNING("pfe_hif_ring_enqueue_buf() failed: %d\n", err);
 	}
 
 	return err;
@@ -1767,23 +1282,13 @@ __attribute__((cold)) static errno_t pfe_hif_chnl_set_rx_ring(pfe_hif_chnl_t *ch
 		NXP_LOG_DEBUG("Mutex lock failed\n");
 	}
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF_NOCPY */
-		pfe_hif_nocpy_cfg_set_rx_bd_ring_addr(chnl->cbus_base_va, rx_ring_pa);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		/*	HIF */
-		pfe_hif_chnl_cfg_set_rx_bd_ring_addr(chnl->cbus_base_va, chnl->id, rx_ring_pa);
+	/*	HIF */
+	pfe_hif_chnl_cfg_set_rx_bd_ring_addr(chnl->cbus_base_va, chnl->id, rx_ring_pa);
 
-		if (NULL != wb_tbl_pa)
-		{
-			wb_tbl_len = pfe_hif_ring_get_wb_tbl_len(ring);
-			pfe_hif_chnl_cfg_set_rx_wb_table(chnl->cbus_base_va, chnl->id, wb_tbl_pa, wb_tbl_len);
-		}
+	if (NULL != wb_tbl_pa)
+	{
+		wb_tbl_len = pfe_hif_ring_get_wb_tbl_len(ring);
+		pfe_hif_chnl_cfg_set_rx_wb_table(chnl->cbus_base_va, chnl->id, wb_tbl_pa, wb_tbl_len);
 	}
 
 	chnl->rx_ring = ring;
@@ -1832,23 +1337,13 @@ __attribute__((cold)) static errno_t pfe_hif_chnl_set_tx_ring(pfe_hif_chnl_t *ch
 		NXP_LOG_DEBUG("Mutex lock failed\n");
 	}
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF_NOCPY */
-		pfe_hif_nocpy_cfg_set_tx_bd_ring_addr(chnl->cbus_base_va, tx_ring_pa);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		/*	HIF */
-		pfe_hif_chnl_cfg_set_tx_bd_ring_addr(chnl->cbus_base_va, chnl->id, tx_ring_pa);
+	/*	HIF */
+	pfe_hif_chnl_cfg_set_tx_bd_ring_addr(chnl->cbus_base_va, chnl->id, tx_ring_pa);
 
-		if (NULL != wb_tbl_pa)
-		{
-			wb_tbl_len = pfe_hif_ring_get_wb_tbl_len(ring);
-			pfe_hif_chnl_cfg_set_tx_wb_table(chnl->cbus_base_va, chnl->id, wb_tbl_pa, wb_tbl_len);
-		}
+	if (NULL != wb_tbl_pa)
+	{
+		wb_tbl_len = pfe_hif_ring_get_wb_tbl_len(ring);
+		pfe_hif_chnl_cfg_set_tx_wb_table(chnl->cbus_base_va, chnl->id, wb_tbl_pa, wb_tbl_len);
 	}
 
 	chnl->tx_ring = ring;
@@ -1882,13 +1377,6 @@ static __attribute__((cold)) errno_t pfe_hif_chnl_init(pfe_hif_chnl_t *chnl)
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
 #if (TRUE == PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED)
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if ((chnl->id >= PFE_HIF_CHNL_NOCPY_ID) && (NULL == chnl->bmu))
-	{
-		NXP_LOG_ERROR("Channel requires BMU instance\n");
-		goto free_and_fail;
-	}
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
 #endif /* PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED */
 
 	if (NULL != chnl->rx_ring)
@@ -1936,29 +1424,19 @@ static __attribute__((cold)) errno_t pfe_hif_chnl_init(pfe_hif_chnl_t *chnl)
 	}
 
 #if (TRUE == PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED)
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
+	/*	Initialize RX buffer pool. Resource protection is embedded. */
+	NXP_LOG_INFO("Initializing RX buffer pool. Depth: %d; Buffer Size: %d; Cache Line Size: %d\n",
+		     pfe_hif_chnl_get_rx_fifo_depth(chnl), PFE_BUF_SIZE, HAL_CACHE_LINE_SIZE);
+
+	chnl->rx_pool = bpool_create(pfe_hif_chnl_get_rx_fifo_depth(chnl), PFE_BUF_SIZE, HAL_CACHE_LINE_SIZE, BUFFERS_CACHED);
+	if (unlikely(NULL == chnl->rx_pool))
 	{
-		/*	HIF NOCPY does not need external RX buffers */
-		chnl->rx_pool = NULL;
+		NXP_LOG_ERROR("Could not allocate RX buffer pool\n");
+		goto free_and_fail;
 	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		/*	Initialize RX buffer pool. Resource protection is embedded. */
-		NXP_LOG_INFO("Initializing RX buffer pool. Depth: %d; Buffer Size: %d; Cache Line Size: %d\n",
-				pfe_hif_chnl_get_rx_fifo_depth(chnl), PFE_BUF_SIZE, HAL_CACHE_LINE_SIZE);
 
-		chnl->rx_pool = bpool_create(pfe_hif_chnl_get_rx_fifo_depth(chnl), PFE_BUF_SIZE, HAL_CACHE_LINE_SIZE, BUFFERS_CACHED);
-		if (unlikely(NULL == chnl->rx_pool))
-		{
-			NXP_LOG_ERROR("Could not allocate RX buffer pool\n");
-			goto free_and_fail;
-		}
-
-		/*	Populate the RX ring */
-		pfe_hif_chnl_refill_rx_buffers(chnl);
-	}
+	/*	Populate the RX ring */
+	pfe_hif_chnl_refill_rx_buffers(chnl);
 #endif /* PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED */
 
 	return EOK;
@@ -2003,19 +1481,7 @@ __attribute__((hot)) bool_t pfe_hif_chnl_is_rx_dma_active(const pfe_hif_chnl_t *
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
 	/*	No protection here. Getting DMA status is atomic. */
-
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF_NOCPY */
-		return pfe_hif_nocpy_cfg_is_rx_dma_active(chnl->cbus_base_va);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		/*	HIF */
-		return pfe_hif_chnl_cfg_is_rx_dma_active(chnl->cbus_base_va, chnl->id);
-	}
+	return pfe_hif_chnl_cfg_is_rx_dma_active(chnl->cbus_base_va, chnl->id);
 }
 
 /**
@@ -2034,19 +1500,7 @@ __attribute__((hot)) bool_t pfe_hif_chnl_is_tx_dma_active(const pfe_hif_chnl_t *
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
 	/*	No protection here. Getting DMA status is atomic. */
-
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF_NOCPY */
-		return pfe_hif_nocpy_cfg_is_tx_dma_active(chnl->cbus_base_va);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		/*	HIF */
-		return pfe_hif_chnl_cfg_is_tx_dma_active(chnl->cbus_base_va, chnl->id);
-	}
+	return pfe_hif_chnl_cfg_is_tx_dma_active(chnl->cbus_base_va, chnl->id);
 }
 
 /**
@@ -2103,16 +1557,7 @@ static __attribute__((cold)) errno_t pfe_hif_chnl_flush_rx_bd_fifo(pfe_hif_chnl_
 
 	tx_hdr = (pfe_ct_hif_tx_hdr_t *)tx_buf_va;
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		tx_hdr->e_phy_ifs = oal_htonl(1U << PFE_PHY_IF_ID_HIF_NOCPY);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		tx_hdr->e_phy_ifs = oal_htonl(1U << (PFE_PHY_IF_ID_HIF0 + chnl->id));
-	}
+	tx_hdr->e_phy_ifs = oal_htonl(1U << (PFE_PHY_IF_ID_HIF0 + chnl->id));
 
 	tx_hdr->flags = (pfe_ct_hif_tx_flags_t)(HIF_TX_INJECT|HIF_TX_IHC);
 	tx_hdr->chid = chnl->id;
@@ -2204,9 +1649,6 @@ __attribute__((cold)) void pfe_hif_chnl_destroy(pfe_hif_chnl_t *chnl)
 	uint32_t level;
 	uint32_t total, available, used;
 	errno_t err;
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	void *tx_ibuf_pa;
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
 #endif /* PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED */
 
 	if (NULL != chnl)
@@ -2234,72 +1676,33 @@ __attribute__((cold)) void pfe_hif_chnl_destroy(pfe_hif_chnl_t *chnl)
 			/*	Drain RX buffers (the ones enqueued in RX ring) */
 			while (EOK == pfe_hif_ring_drain_buf(chnl->rx_ring, &buf_pa))
 			{
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-				if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-				{
-                    if (NULL == buf_pa)
-                    {
-                        NXP_LOG_WARNING("Drained buffer PA is NULL\n");
-                    }
-                    else
-                    {
-					/*	Return buffer into BMU. Resource protection is embedded. */
-                        pfe_bmu_free_buf(chnl->bmu, (addr_t)buf_pa);
-                    }
-                }
-                else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-				{
-					/*	HIF buffers are provided by SW pool so return them to SW pool */
-					buf_va = bpool_get_va(chnl->rx_pool, buf_pa);
-                    if (NULL == buf_va)
-                    {
-                        NXP_LOG_WARNING("Drained buffer VA is NULL\n");
-                    }
-                    else
-                    {
-                        /*	Return buffer into pool. Resource protection is embedded. */
-                        bpool_put(chnl->rx_pool, buf_va);
-                    }
-                }
-            }
-
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-			if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-			{
-				/*	Sanity check to verify if the HIF RX ring and the upper SW layers
-					have properly returned all RX and TX buffers back to the BMU. We're
-					using the allocations counter here to determine delta between number
-					of allocated buffers (either TX buffers we have directly allocated
-					or received buffers which have been allocated by the PFE HW) and
-					number of released buffers. */
-				if (0U != pfe_hif_chnl_get_alloc_cnt(chnl))
+				/*	HIF buffers are provided by SW pool so return them to SW pool */
+				buf_va = bpool_get_va(chnl->rx_pool, buf_pa);
+				if (NULL == buf_va)
 				{
-					NXP_LOG_WARNING("Some buffers not returned to the BMU\n");
+					NXP_LOG_WARNING("Drained buffer VA is NULL\n");
 				}
 				else
 				{
-					NXP_LOG_INFO("All buffers returned to the BMU\n");
+					/*	Return buffer into pool. Resource protection is embedded. */
+					bpool_put(chnl->rx_pool, buf_va);
 				}
 			}
-			else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
+
+			/*	Sanity check to verify if the HIF RX ring and the upper SW layers
+				have properly returned all RX buffers back to the pool. */
+			if (EOK != bpool_get_fill_level(chnl->rx_pool, &level))
 			{
-				/*	Sanity check to verify if the HIF RX ring and the upper SW layers
-					have properly returned all RX buffers back to the pool. */
-				if (EOK != bpool_get_fill_level(chnl->rx_pool, &level))
-				{
-					NXP_LOG_ERROR("Can't get buffer pool fill level\n ");
-				}
+				NXP_LOG_ERROR("Can't get buffer pool fill level\n ");
+			}
 
-				if (level < (pfe_hif_chnl_get_rx_fifo_depth(chnl)))
-				{
-					NXP_LOG_WARNING("Some RX buffers not returned to the pool\n");
-				}
-				else
-				{
-					NXP_LOG_INFO("All RX buffers returned to the pool\n");
-				}
+			if (level < (pfe_hif_chnl_get_rx_fifo_depth(chnl)))
+			{
+				NXP_LOG_WARNING("Some RX buffers not returned to the pool\n");
+			}
+			else
+			{
+				NXP_LOG_INFO("All RX buffers returned to the pool\n");
 			}
 
 #endif /* PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED */
@@ -2308,8 +1711,8 @@ __attribute__((cold)) void pfe_hif_chnl_destroy(pfe_hif_chnl_t *chnl)
 			pfe_hif_ring_invalidate(chnl->rx_ring);
 
 			/*
-			 	Here the ring should be empty. Execute HIF channel BDP shutdown
-			 	procedure to ensure that channel will not keep any content in
+				Here the ring should be empty. Execute HIF channel BDP shutdown
+				procedure to ensure that channel will not keep any content in
 				internal buffers.
 			*/
 			if (EOK != pfe_hif_chnl_flush_rx_bd_fifo(chnl))
@@ -2377,18 +1780,6 @@ __attribute__((cold)) void pfe_hif_chnl_destroy(pfe_hif_chnl_t *chnl)
 			chnl->rx_pool = NULL;
 		}
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-		if (NULL != chnl->tx_ibuf_va)
-		{
-			/*	Release the intermediate TX buffer */
-			tx_ibuf_pa = pfe_bmu_get_pa(chnl->bmu, (addr_t)chnl->tx_ibuf_va);
-			pfe_bmu_free_buf(chnl->bmu, (addr_t)tx_ibuf_pa);
-			chnl->tx_ibuf_va = NULL;
-
-			/*	Decrement BMU allocations counter */
-			pfe_hif_chnl_alloc_dec(chnl);
-		}
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
 #endif /* PFE_HIF_CHNL_CFG_RX_BUFFERS_ENABLED */
 
 		if (EOK != oal_spinlock_lock(&chnl->lock))
@@ -2397,13 +1788,6 @@ __attribute__((cold)) void pfe_hif_chnl_destroy(pfe_hif_chnl_t *chnl)
 		}
 
 		/*	Disable and finalize the channel */
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-		if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-		{
-			; /*	HIF NOCPY will do the finalization */
-		}
-		else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
 		{
 			pfe_hif_chnl_cfg_fini(chnl->cbus_base_va, chnl->id);
 		}
@@ -2413,12 +1797,6 @@ __attribute__((cold)) void pfe_hif_chnl_destroy(pfe_hif_chnl_t *chnl)
 			NXP_LOG_DEBUG("Mutex unlock failed\n");
 		}
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-		if (EOK != oal_spinlock_destroy(&chnl->a_lock))
-		{
-			NXP_LOG_WARNING("Could not properly destroy allocation counter mutex\n");
-		}
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
 
 		if (EOK != oal_spinlock_destroy(&chnl->lock))
 		{
@@ -2484,17 +1862,7 @@ uint32_t pfe_hif_chnl_get_tx_cnt(const pfe_hif_chnl_t *chnl)
 	}
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF_NOCPY */
-		return pfe_hif_nocpy_cfg_get_tx_cnt(chnl->cbus_base_va);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		return pfe_hif_chnl_cfg_get_tx_cnt(chnl->cbus_base_va, chnl->id);
-	}
+	return pfe_hif_chnl_cfg_get_tx_cnt(chnl->cbus_base_va, chnl->id);
 }
 
 /**
@@ -2512,17 +1880,7 @@ uint32_t pfe_hif_chnl_get_rx_cnt(const pfe_hif_chnl_t *chnl)
 	}
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF_NOCPY */
-		return pfe_hif_nocpy_cfg_get_rx_cnt(chnl->cbus_base_va);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		return pfe_hif_chnl_cfg_get_rx_cnt(chnl->cbus_base_va, chnl->id);
-	}
+	return pfe_hif_chnl_cfg_get_rx_cnt(chnl->cbus_base_va, chnl->id);
 }
 
 /**
@@ -2546,21 +1904,11 @@ __attribute__((cold)) uint32_t pfe_hif_chnl_get_text_statistics(const pfe_hif_ch
 	}
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
-	{
-		/*	HIF_NOCPY */
-		len += pfe_hif_nocpy_chnl_cfg_get_text_stat(chnl->cbus_base_va, buf, buf_len, verb_level);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		/*	HIF */
-		len += pfe_hif_chnl_cfg_get_text_stat(chnl->cbus_base_va, chnl->id, buf, buf_len, verb_level);
+	/*	HIF */
+	len += pfe_hif_chnl_cfg_get_text_stat(chnl->cbus_base_va, chnl->id, buf, buf_len, verb_level);
 
-		if (verb_level >= 9)
-			len += pfe_hif_chnl_dump_ring(chnl, TRUE, TRUE, buf + len, buf_len - len, verb_level);
-	}
+	if (verb_level >= 9)
+		len += pfe_hif_chnl_dump_ring(chnl, TRUE, TRUE, buf + len, buf_len - len, verb_level);
 
 	return len;
 }
diff --git a/sw/pfe_platform/src/pfe_hif_nocpy.c b/sw/pfe_platform/src/pfe_hif_nocpy.c
index 07f6ca1..073b5fa 100644
--- a/sw/pfe_platform/src/pfe_hif_nocpy.c
+++ b/sw/pfe_platform/src/pfe_hif_nocpy.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2021 NXP
+ *  Copyright 2018-2022 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -27,7 +27,7 @@ struct pfe_hif_nocpy_tag
  * @param[in]	bmu BMU providing buffers for HIF NOCPY operation
  * @return		The HIF_NOCPY instance or NULL if failed
  */
-pfe_hif_nocpy_t *pfe_hif_nocpy_create(addr_t base_va, const pfe_bmu_t *bmu)
+pfe_hif_nocpy_t *pfe_hif_nocpy_create(addr_t base_va, const pfe_bmu_t *bmu, uint16_t lmem_header_size)
 {
 	pfe_hif_nocpy_t *hif;
 	errno_t ret;
@@ -60,6 +60,8 @@ pfe_hif_nocpy_t *pfe_hif_nocpy_create(addr_t base_va, const pfe_bmu_t *bmu)
 		return NULL;
 	}
 
+    pfe_hif_chnl_set_lmem_hdr_size(hif->channel, lmem_header_size);
+
 	ret = pfe_hif_nocpy_cfg_init(hif->base_va);
 	if (EOK != ret)
 	{
diff --git a/sw/pfe_platform/src/pfe_hif_ring_linux.c b/sw/pfe_platform/src/pfe_hif_ring_linux.c
index 2838fde..563bccd 100644
--- a/sw/pfe_platform/src/pfe_hif_ring_linux.c
+++ b/sw/pfe_platform/src/pfe_hif_ring_linux.c
@@ -61,7 +61,6 @@
 		(((ctrl) >> HIF_RING_BD_W0_BD_CTRL_OFFSET) & \
 					  HIF_RING_BD_W0_BD_CTRL_MASK)
 
-
 /* Buffer descriptor WORD1 */
 #define HIF_RING_BD_W1_BD_BUFFLEN_MASK		(0xFFFFU)
 #define HIF_RING_BD_W1_BD_BUFFLEN_OFFSET	(0U)
@@ -79,7 +78,6 @@
 		(((stat) & HIF_RING_BD_W1_BD_RSVD_STAT_MASK)	<< \
 				   HIF_RING_BD_W1_BD_RSVD_STAT_OFFSET)
 
-
 /* Write back Buffer descriptor WORD0 */
 #define HIF_RING_WB_BD_W0_DESC_EN			(1U << 9U)
 #define HIF_RING_WB_BD_W0_DIR				(1U << 8U)
@@ -109,7 +107,6 @@
 		(((seqnum) >> HIF_RING_WB_BD_W1_WB_BD_SEQNUM_OFFSET) & \
 					  HIF_RING_WB_BD_W1_WB_BD_SEQNUM_MASK)
 
-
 /**
  * @brief	The BD as seen by HIF
  * @details	Properly pack to form the structure as expected by HIF.
@@ -128,79 +125,6 @@ typedef struct __attribute__((packed)) pfe_hif_bd_tag
 	volatile uint32_t next;
 } pfe_hif_bd_t;
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-/**
- * @brief	The BD as seen by HIF NOCPY
- * @details	Properly pack to form the structure as expected by HIF NOCPY.
- * @note	Don't use the 'aligned' attribute here since behavior
- * 			is implementation-specific (due to the bitfields). Still
- * 			applies that BD shall be aligned to 64-bits and in
- * 			ideal case to cache line size.
- * @warning	Do not touch the structure (even types) unless you know
- * 			what you're doing.
- */
-typedef struct __attribute__((packed)) pfe_hif_nocpy_bd_tag
-{
-	union
-	{
-		struct
-		{
-			union
-			{
-				volatile uint16_t rx_reserved;
-				volatile uint16_t tx_buflen;
-			};
-
-			union
-			{
-				volatile uint16_t ctrl;
-				struct
-				{
-					volatile uint16_t cbd_int_en	: 1;
-					volatile uint16_t pkt_int_en	: 1;
-					volatile uint16_t lifm			: 1;
-					volatile uint16_t last_bd		: 1;	/*	Not used */
-					volatile uint16_t dir			: 1;
-					volatile uint16_t lmem_cpy		: 1;
-					volatile uint16_t reserved1		: 2;
-					volatile uint16_t pkt_xfer		: 1;
-					volatile uint16_t reserved2		: 6;
-					volatile uint16_t desc_en		: 1;
-				};
-			};
-		};
-		volatile uint32_t ctrl_txlen_w0;
-	};
-
-	union
-	{
-		struct
-		{
-			union
-			{
-				volatile uint16_t rx_buflen;
-				volatile uint16_t tx_status;
-			};
-
-			union
-			{
-				volatile uint16_t rx_status;
-				struct
-				{
-					uint16_t tx_portno		: 3;
-					uint16_t tx_queueno		: 4;
-					uint16_t tx_reserved4	: 9;
-				};
-			};
-		};
-		volatile uint32_t stat_rxlen_txstat_w1;
-	};
-
-	volatile uint32_t data;
-	volatile uint32_t next;
-
-} pfe_hif_nocpy_bd_t;
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
 
 /**
  * @brief	The write-back BD as seen by HIF
@@ -229,47 +153,29 @@ struct __attribute__((aligned (HAL_CACHE_LINE_SIZE), packed)) pfe_hif_ring_tag
 
 	/*	Every 'enqueue' and 'dequeue' access */
 	void *base_va;				/*	Ring base address (virtual) */
-	void *wb_tbl_base_va;		/*	Write-back table base address (virtual) */
+	void *wb_tbl_base_va;			/*	Write-back table base address (virtual) */
 
 	/*	Every 'enqueue' access */
 	uint32_t write_idx;			/*	BD index to be written */
-	union						/* Pointer to BD to be written */
-	{
-		pfe_hif_bd_t *wr_bd;
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-		pfe_hif_nocpy_bd_t *wr_bd_nocpy;
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	};
+	pfe_hif_bd_t *wr_bd;			/*	Pointer to BD to be written */
 
 #if (TRUE == HAL_HANDLE_CACHE)
-	union						/*	Pointer to BD to be written (PA). Only due to CACHE_* macros in QNX... */
-	{
-		pfe_hif_bd_t *wr_bd_pa;
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-		pfe_hif_nocpy_bd_t *wr_bd_nocpy_pa;
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	};
+	pfe_hif_bd_t *wr_bd_pa;			/*	Pointer to BD to be written (PA). Only due to CACHE_* macros in QNX... */
 #endif /* HAL_HANDLE_CACHE */
-	pfe_hif_wb_bd_t *wr_wb_bd;	/*	Pointer to WB BD to be written */
+	pfe_hif_wb_bd_t *wr_wb_bd;		/*	Pointer to WB BD to be written */
 	bool_t is_rx;				/*	If TRUE then ring is RX ring */
 	bool_t is_nocpy;			/*	If TRUE then ring is HIF NOCPY variant */
 
 	/*	Every 'dequeue' access */
 	uint32_t read_idx;			/*	BD index to be read */
-	union						/*	Pointer to BD to be read */
-	{
-		pfe_hif_bd_t *rd_bd;
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-		pfe_hif_nocpy_bd_t *rd_bd_nocpy;
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	};
+	pfe_hif_bd_t *rd_bd;			/*	Pointer to BD to be read */
 
-	pfe_hif_wb_bd_t *rd_wb_bd;	/*	Pointer to WB BD to be read */
-	bool_t heavy_data_mark;		/*	To enable getting size of heavily accessed data */
+	pfe_hif_wb_bd_t *rd_wb_bd;		/*	Pointer to WB BD to be read */
+	bool_t heavy_data_mark;			/*	To enable getting size of heavily accessed data */
 
 	/*	Initialization time only */
 	void *base_pa;				/*	Ring base address (physical) */
-	void *wb_tbl_base_pa;		/*	Write-back table base address (physical) */
+	void *wb_tbl_base_pa;			/*	Write-back table base address (physical) */
 };
 
 __attribute__((hot)) static inline void inc_write_index_std(pfe_hif_ring_t *ring);
@@ -280,15 +186,6 @@ static inline errno_t pfe_hif_ring_enqueue_buf_std(pfe_hif_ring_t *ring, const v
 static inline errno_t pfe_hif_ring_dequeue_buf_std(pfe_hif_ring_t *ring, void **buf_pa, uint32_t *length, bool_t *lifm);
 static inline errno_t pfe_hif_ring_dequeue_plain_std(pfe_hif_ring_t *ring, bool_t *lifm);
 __attribute__((cold)) static void pfe_hif_ring_invalidate_std(const pfe_hif_ring_t *ring);
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-__attribute__((hot)) static inline void inc_write_index_nocpy(pfe_hif_ring_t *ring);
-__attribute__((hot)) static inline void inc_read_index_nocpy(pfe_hif_ring_t *ring);
-__attribute__((cold)) static pfe_hif_ring_t *pfe_hif_ring_create_nocpy(bool_t rx);
-static inline errno_t pfe_hif_ring_enqueue_buf_nocpy(pfe_hif_ring_t *ring, const void *buf_pa, uint32_t length, bool_t lifm);
-static inline errno_t pfe_hif_ring_dequeue_buf_nocpy(pfe_hif_ring_t *ring, void **buf_pa, uint32_t *length, bool_t *lifm);
-static inline errno_t pfe_hif_ring_dequeue_plain_nocpy(pfe_hif_ring_t *ring, bool_t *lifm);
-__attribute__((cold)) static void pfe_hif_ring_invalidate_nocpy(const pfe_hif_ring_t *ring);
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
 
 __attribute__((hot)) static inline void inc_write_index_std(pfe_hif_ring_t *ring)
 {
@@ -304,14 +201,6 @@ __attribute__((hot)) static inline void dec_write_index_std(pfe_hif_ring_t *ring
 	ring->wr_wb_bd = &((pfe_hif_wb_bd_t *)ring->wb_tbl_base_va)[ring->write_idx & RING_LEN_MASK];
 }
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-__attribute__((hot)) static inline void inc_write_index_nocpy(pfe_hif_ring_t *ring)
-{
-	ring->write_idx++;
-	ring->wr_bd_nocpy = &((pfe_hif_nocpy_bd_t *)ring->base_va)[ring->write_idx & RING_LEN_MASK];
-}
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-
 __attribute__((hot)) static inline void inc_read_index_std(pfe_hif_ring_t *ring)
 {
 	ring->read_idx++;
@@ -319,43 +208,6 @@ __attribute__((hot)) static inline void inc_read_index_std(pfe_hif_ring_t *ring)
 	ring->rd_wb_bd = &((pfe_hif_wb_bd_t *)ring->wb_tbl_base_va)[ring->read_idx & RING_LEN_MASK];
 }
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-__attribute__((hot)) static inline void inc_read_index_nocpy(pfe_hif_ring_t *ring)
-{
-	ring->read_idx++;
-	ring->rd_bd_nocpy = &((pfe_hif_nocpy_bd_t *)ring->base_va)[ring->read_idx & RING_LEN_MASK];
-}
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-
-/**
- * @brief		Check if ring contains less than watermark-specified
- * 				number of free entries
- * @param[in]	ring The ring instance
- * @return		TRUE if ring contains less than watermark-specified number
- * 				of free entries
- * @note		Must not be preempted by: pfe_hif_ring_destroy()
- */
-__attribute__((pure, hot)) bool_t pfe_hif_ring_is_below_wm(const pfe_hif_ring_t *ring)
-{
-#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely(NULL == ring))
-	{
-		NXP_LOG_ERROR("NULL argument received\n");
-		return FALSE;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	/*	TODO: Make the water-mark value configurable */
-	if (pfe_hif_ring_get_fill_level(ring) >= (RING_LEN / 2))
-	{
-		return TRUE;
-	}
-	else
-	{
-		return FALSE;
-	}
-}
-
 /**
  * @brief		Get fill level
  * @param[in]	ring The ring instance
@@ -372,20 +224,7 @@ __attribute__((pure, hot)) uint32_t pfe_hif_ring_get_fill_level(const pfe_hif_ri
 	}
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	/*	In case of HIF NOCPY, the HW does not use external RX buffers but internal
-	 	BMU-provided buffers. Thus the RX ring fill level can't be other value
-	 	than zero. */
-
-	if ((ring->is_nocpy) && (ring->is_rx))
-	{
-		return 0U;
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		return (ring->write_idx - ring->read_idx);
-	}
+	return ring->write_idx - ring->read_idx;
 }
 
 /**
@@ -423,14 +262,6 @@ __attribute__((pure, cold)) void *pfe_hif_ring_get_wb_tbl_pa(const pfe_hif_ring_
 	}
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (ring->is_nocpy)
-	{
-		/*	NOCPY ring does not use write-back descriptors */
-		return NULL;
-	}
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-
 	return ring->wb_tbl_base_pa;
 }
 
@@ -443,23 +274,7 @@ __attribute__((pure, cold)) void *pfe_hif_ring_get_wb_tbl_pa(const pfe_hif_ring_
  */
 __attribute__((pure, cold)) uint32_t pfe_hif_ring_get_wb_tbl_len(const pfe_hif_ring_t *ring)
 {
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely(NULL == ring))
-	{
-		NXP_LOG_ERROR("NULL argument received\n");
-		return 0U;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (ring->is_nocpy)
-	{
-		/*	NOCPY ring does not use write-back descriptors */
-		return 0U;
-	}
-#else /* PFE_CFG_HIF_NOCPY_SUPPORT */
 	(void)ring;
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
 
 	return RING_LEN;
 }
@@ -501,83 +316,8 @@ __attribute__((pure, hot)) uint32_t pfe_hif_ring_get_len(const pfe_hif_ring_t *r
  */
 __attribute__((hot)) errno_t pfe_hif_ring_enqueue_buf(pfe_hif_ring_t *ring, const void *buf_pa, uint32_t length, bool_t lifm)
 {
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely(NULL == ring))
-	{
-		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (ring->is_nocpy)
-	{
-		return pfe_hif_ring_enqueue_buf_nocpy(ring, buf_pa, length, lifm);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		return pfe_hif_ring_enqueue_buf_std(ring, buf_pa, length, lifm);
-	}
-}
-
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-
-/**
- * @brief		The HIF NOCPY variant
- * @param[in]	buf_pa This must be BMU2 allocated physical address
- */
-static inline errno_t pfe_hif_ring_enqueue_buf_nocpy(pfe_hif_ring_t *ring, const void *buf_pa, uint32_t length, bool_t lifm)
-{
-#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely((NULL == ring) | (NULL == buf_pa)))
-	{
-		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (unlikely(ring->is_rx))
-	{
-		NXP_LOG_ERROR("There is nothing to enqueue into RX ring in case of HIF NOCPY\n");
-		return EPERM;
-	}
-	else
-	{
-		/*	Write the HW BD. Always write all control word bits since
-		 	the HIF NOCPY is clearing the flags once BD is processed... */
-		ring->wr_bd_nocpy->data = (uint32_t)((addr_t)buf_pa & 0xffffffffU);
-		ring->wr_bd_nocpy->tx_buflen = (uint16_t)length;
-		/* BD_STATUS = {src_buf_offset, dst_buf_offset, buf_len}, the last field tells how many bytes to
-		   copy from the DDR buffer to LMEM buffer (experimentally verified behavior, not documented) in
-		   LMEM copy mode, ignored in DIRECT mode. The value 0xFF was tested
-		   to work correctly. 0xF0 causes 16 bytes to be missing at the end of LMEM buffer. Value 0 causes
-		   all bytes to be missing except the header. */
-		/* AAVB-3403 shall better describe and set the value of tx_status */
-		ring->wr_bd_nocpy->tx_status = 0xFFU;
-		/* Request the LMEM copy mode */
-		ring->wr_bd_nocpy->lmem_cpy = 1U;
-		ring->wr_bd_nocpy->tx_queueno = 0U;
-		ring->wr_bd_nocpy->pkt_xfer = 1U;
-
-		if (lifm)
-		{
-			ring->wr_bd_nocpy->lifm = 1U;
-		}
-		else
-		{
-			ring->wr_bd_nocpy->lifm = 0U;
-		}
-
-		/*	Write the BD 'enable' bit */
-		ring->wr_bd_nocpy->desc_en = 1U;
-		/*	Increment the write pointer */
-		inc_write_index_nocpy(ring);
-	}
-
-	return EOK;
+	return pfe_hif_ring_enqueue_buf_std(ring, buf_pa, length, lifm);
 }
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
 
 /**
  * @brief		The "standard" HIF variant
@@ -617,7 +357,7 @@ static inline errno_t pfe_hif_ring_enqueue_buf_std(pfe_hif_ring_t *ring, const v
 		/*	1.) Process the BD (write new data). */
 		ring->wr_bd->data = (uint32_t)(addr_t)buf_pa;
 		ring->wr_bd->rsvd_buflen_w1 = HIF_RING_BD_W1_BD_RSVD_STAT(0U) |
-									  HIF_RING_BD_W1_BD_BUFFLEN((uint16_t)length);
+					      HIF_RING_BD_W1_BD_BUFFLEN((uint16_t)length);
 
 		if (lifm)
 		{
@@ -666,73 +406,8 @@ static inline errno_t pfe_hif_ring_enqueue_buf_std(pfe_hif_ring_t *ring, const v
  */
 __attribute__((hot)) errno_t pfe_hif_ring_dequeue_buf(pfe_hif_ring_t *ring, void **buf_pa, uint32_t *length, bool_t *lifm)
 {
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely(NULL == ring))
-	{
-		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (ring->is_nocpy)
-	{
-		return pfe_hif_ring_dequeue_buf_nocpy(ring, buf_pa, length, lifm);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		return pfe_hif_ring_dequeue_buf_std(ring, buf_pa, length, lifm);
-	}
-}
-
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-/**
- * @brief		The HIF NOCPY variant
- */
-static inline errno_t pfe_hif_ring_dequeue_buf_nocpy(pfe_hif_ring_t *ring, void **buf_pa, uint32_t *length, bool_t *lifm)
-{
-#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely((NULL == ring) || (NULL == buf_pa) || (NULL == length) || (NULL == lifm)))
-	{
-		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	/* if (unlikely(0U != ring->rd_bd_nocpy->desc_en)) */
-	if (0U != ring->rd_bd_nocpy->pkt_xfer)
-	{
-		return EAGAIN;
-	}
-	else
-	{
-		*buf_pa = (void *)(addr_t)PFE_CFG_MEMORY_PFE_TO_PHYS(ring->rd_bd_nocpy->data);
-
-		if (ring->is_rx)
-		{
-			*length = ring->rd_bd_nocpy->rx_buflen;
-		}
-		else
-		{
-			*length = ring->rd_bd_nocpy->tx_buflen;
-		}
-
-		*lifm = (0U != ring->rd_bd_nocpy->lifm);
-
-		/*	Re-enable the descriptor so HIF can write another RX buffer there */
-		ring->rd_bd_nocpy->pkt_xfer = 1U;
-		ring->rd_bd_nocpy->desc_en = 1U;
-		/*	Must clear also lifm flag to prepare BD for next use */
-		ring->rd_bd_nocpy->lifm = 0U;
-
-		/*	Increment the read pointer */
-		inc_read_index_nocpy(ring);
-	}
-
-	return EOK;
+	return pfe_hif_ring_dequeue_buf_std(ring, buf_pa, length, lifm);
 }
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
 
 /**
  * @brief		The "standard" HIF variant
@@ -817,69 +492,8 @@ static inline errno_t pfe_hif_ring_dequeue_buf_std(pfe_hif_ring_t *ring, void **
  */
 __attribute__((hot)) errno_t pfe_hif_ring_dequeue_plain(pfe_hif_ring_t *ring, bool_t *lifm)
 {
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely(NULL == ring))
-	{
-		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (ring->is_nocpy)
-	{
-		return pfe_hif_ring_dequeue_plain_nocpy(ring, lifm);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		return pfe_hif_ring_dequeue_plain_std(ring, lifm);
-	}
-}
-
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-/**
- * @brief		The HIF NOCPY variant
- */
-static inline errno_t pfe_hif_ring_dequeue_plain_nocpy(pfe_hif_ring_t *ring, bool_t *lifm)
-{
-#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely(NULL == ring))
-	{
-		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	/* if (unlikely((0U != ring->rd_bd_nocpy->desc_en) || (0U == pfe_hif_ring_get_fill_level(ring)))) */
-	if (1U == ring->rd_bd_nocpy->pkt_xfer) /* TODO: Is this OK also within RX ring? */
-	{
-		/*	Nothing to dequeue */
-		return EAGAIN;
-	}
-	else
-	{
-		/*
-			Return the LIFM flag
-
-		 	HIF NOCPY TX BDP will always overwrite the BD so the LIFM
-			flag will be set to zero (very smart...). It must be ensured
-			that the HIF NOCPY ring will be used in the one-frame=one-BD
-			manner.
-		*/
-		*lifm = TRUE;
-
-		/*	Clear the 'TX done' flag */
-		ring->rd_bd_nocpy->pkt_xfer = 1U;
-		ring->rd_bd_nocpy->desc_en = 0U;
-
-		/*	Increment the read pointer */
-		inc_read_index_nocpy(ring);
-	}
-
-	return EOK;
+	return pfe_hif_ring_dequeue_plain_std(ring, lifm);
 }
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
 
 /**
  * @brief		The "standard" HIF variant
@@ -939,7 +553,8 @@ static inline errno_t pfe_hif_ring_dequeue_plain_std(pfe_hif_ring_t *ring, bool_
  * @details		This call dequeues previously enqueued buffer from a ring regardless it
  *				has been processed by the HW or not. Function is intended to properly
  *				shut-down the ring in terms of possibility to retrieve all currently
- *				enqueued entries.
+ *				enqueued entries. In case of RX ring this will return enqueued RX buffer.
+ *				In case of TX ring the enqueued TX buffer will be returned.
  * @param[in]	ring The ring instance
  * @param[out]	buf_pa buf_pa Pointer where pointer to the dequeued buffer shall be written
  * @retval		EOK Buffer has been dequeued
@@ -955,61 +570,29 @@ __attribute__((cold)) errno_t pfe_hif_ring_drain_buf(pfe_hif_ring_t *ring, void
 	}
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-	if (ring->is_nocpy && ring->is_rx)
-	{
-		bool_t lifm;
-
-		/*	In this case we will do standard dequeue until the ring is empty. This
-			will ensure that application can drain RX buffers and return all BMU
-			buffers back to the HW pool. */
-		if (EOK == pfe_hif_ring_dequeue_plain_nocpy(ring, &lifm))
-		{
-			return EOK;
-		}
-		else
-		{
-			return ENOENT;
-		}
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
 	if (0U != pfe_hif_ring_get_fill_level(ring))
 	{
-		/*	In case of RX ring this will return enqueued RX buffer. In
-			case of TX ring the enqueued TX buffer will be returned. */
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-		if (ring->is_nocpy)
+		/*	Draining introduces sequence number corruption. Every enqueued
+			BD increments sequence number in SW and every processed BD
+			increments it in HW. In case when non-processed BDs are dequeued
+			the new ones will be enqueued with sequence number not matching
+			the current HW one. We need to adjust the SW value when draining
+			non-processed BDs. */
+		if ( 0 != (HIF_RING_WB_BD_W0_DESC_EN & ring->wr_wb_bd->rsvd_ctrl_w0))
 		{
-			*buf_pa = (void *)(addr_t)ring->rd_bd_nocpy->data;
-			ring->rd_bd_nocpy->desc_en = 0U;
-			inc_read_index_nocpy(ring);
+			/*	This BD has not been processed yet. Revert the enqueue. */
+			*buf_pa = (void *)(addr_t)ring->wr_bd->data;
+			ring->wr_bd->ctrl_seqnum_w0 &= ~HIF_RING_BD_W0_DESC_EN;
+			ring->wr_wb_bd->rsvd_ctrl_w0 |= HIF_RING_WB_BD_W0_DESC_EN;
+			dec_write_index_std(ring);
 		}
 		else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
 		{
-			/*	Draining introduces sequence number corruption. Every enqueued
-				BD increments sequence number in SW and every processed BD
-				increments it in HW. In case when non-processed BDs are dequeued
-				the new ones will be enqueued with sequence number not matching
-				the current HW one. We need to adjust the SW value when draining
-				non-processed BDs. */
-			if ( 0 != (HIF_RING_WB_BD_W0_DESC_EN & ring->wr_wb_bd->rsvd_ctrl_w0))
-			{
-				/*	This BD has not been processed yet. Revert the enqueue. */
-				*buf_pa = (void *)(addr_t)ring->wr_bd->data;
-				ring->wr_bd->ctrl_seqnum_w0 &= ~HIF_RING_BD_W0_DESC_EN;
-				ring->wr_wb_bd->rsvd_ctrl_w0 |= HIF_RING_WB_BD_W0_DESC_EN;
-				dec_write_index_std(ring);
-			}
-			else
-			{
-				/*	Processed BD. Do standard dequeue. */
-				*buf_pa = (void *)(addr_t)ring->rd_bd->data;
-				ring->rd_bd->ctrl_seqnum_w0 &= ~HIF_RING_BD_W0_DESC_EN;
-				ring->rd_wb_bd->rsvd_ctrl_w0 |= HIF_RING_WB_BD_W0_DESC_EN;
-				inc_read_index_std(ring);
-			}
+			/*	Processed BD. Do standard dequeue. */
+			*buf_pa = (void *)(addr_t)ring->rd_bd->data;
+			ring->rd_bd->ctrl_seqnum_w0 &= ~HIF_RING_BD_W0_DESC_EN;
+			ring->rd_wb_bd->rsvd_ctrl_w0 |= HIF_RING_WB_BD_W0_DESC_EN;
+			inc_read_index_std(ring);
 		}
 	}
 	else
@@ -1028,54 +611,8 @@ __attribute__((cold)) errno_t pfe_hif_ring_drain_buf(pfe_hif_ring_t *ring, void
  */
 __attribute__((cold)) void pfe_hif_ring_invalidate(const pfe_hif_ring_t *ring)
 {
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely(NULL == ring))
-	{
-		NXP_LOG_ERROR("NULL argument received\n");
-		return;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	if (ring->is_nocpy)
-	{
-		pfe_hif_ring_invalidate_nocpy(ring);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		pfe_hif_ring_invalidate_std(ring);
-	}
-
-	return;
-}
-
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-/**
- * @brief		The HIF NOCPY variant
- */
-__attribute__((cold)) static void pfe_hif_ring_invalidate_nocpy(const pfe_hif_ring_t *ring)
-{
-	uint32_t ii;
-
-#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely(NULL == ring))
-	{
-		NXP_LOG_ERROR("NULL argument received\n");
-		return;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	for (ii=0U; ii<RING_LEN; ii++)
-	{
-		/*	Zero-out the EN flag */
-		(((pfe_hif_nocpy_bd_t *)ring->base_va)[ii]).desc_en = 0U;
-
-		/*	Mark the descriptor as last BD */
-		(((pfe_hif_nocpy_bd_t *)ring->base_va)[ii]).last_bd = 1U;
-	}
+	pfe_hif_ring_invalidate_std(ring);
 }
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
 
 /**
  * @brief		The "standard" HIF variant
@@ -1162,9 +699,6 @@ __attribute__((cold)) uint32_t pfe_hif_ring_dump(pfe_hif_ring_t *ring, char_t *n
 		}
 
 		/* WB ring */
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-		if (FALSE == ring->is_nocpy)
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
 		{
 			for (ii=0U; ii<RING_LEN; ii++)
 			{
@@ -1201,143 +735,15 @@ __attribute__((cold)) uint32_t pfe_hif_ring_dump(pfe_hif_ring_t *ring, char_t *n
  */
 __attribute__((cold)) pfe_hif_ring_t *pfe_hif_ring_create(bool_t rx, bool_t nocpy)
 {
-#if !defined(PFE_CFG_HIF_NOCPY_SUPPORT)
 	if (TRUE == nocpy)
 	{
-		NXP_LOG_ERROR("HIF NOCPY support not enabled\n");
-		return NULL;
-	}
-#else
-	if (TRUE == nocpy)
-	{
-		return pfe_hif_ring_create_nocpy(rx);
-	}
-	else
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
-	{
-		return pfe_hif_ring_create_std(rx);
-	}
-}
-
-#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
-/**
- * @brief		The HIF NOCPY variant
- */
-__attribute__((cold)) static pfe_hif_ring_t *pfe_hif_ring_create_nocpy(uint16_t seqnum, bool_t rx)
-{
-	pfe_hif_ring_t *ring;
-	uint32_t ii, size;
-	pfe_hif_nocpy_bd_t *hw_desc_va, *hw_desc_pa;
-
-	(void)seqnum;
-
-	/*	Allocate the ring structure */
-	ring = oal_mm_malloc_contig_aligned_cache(sizeof(pfe_hif_ring_t), HAL_CACHE_LINE_SIZE);
-	if (NULL == ring)
-	{
-		NXP_LOG_ERROR("Can't create BD ring; oal_mm_malloc_contig_aligned_cache() failed\n");
+		NXP_LOG_ERROR("HIF NOCPY not supported\n");
 		return NULL;
 	}
 
-	memset(ring, 0, sizeof(pfe_hif_ring_t));
-	ring->base_va = NULL;
-	ring->wb_tbl_base_va = NULL;
-	ring->wb_tbl_base_pa = NULL;
-	ring->rd_wb_bd = NULL;
-	ring->is_nocpy = TRUE;
-
-	/*	Just a debug check */
-	if (((addr_t)&ring->heavy_data_mark - (addr_t)ring) > HAL_CACHE_LINE_SIZE)
-	{
-		NXP_LOG_DEBUG("Suboptimal: Data split between two cache lines\n");
-	}
-
-	/*	Allocate memory for buffer descriptors. Should be DMA safe, contiguous, and 64-bit aligned. */
-	if (0 != (HAL_CACHE_LINE_SIZE % 8))
-	{
-		NXP_LOG_DEBUG("Suboptimal: Cache line size is not 64-bit aligned\n");
-		ii = 8U;
-	}
-	else
-	{
-		ii = HAL_CACHE_LINE_SIZE;
-	}
-
-	size = RING_LEN * sizeof(pfe_hif_nocpy_bd_t);
-	ring->base_va = oal_mm_malloc_contig_named_aligned_nocache(PFE_CFG_BD_MEM, size, ii);
-
-	if (unlikely(NULL == ring->base_va))
-	{
-		NXP_LOG_ERROR("BD memory allocation failed\n");
-		goto free_and_fail;
-	}
-
-	/*	It shall be ensured that a single BD does not split across 4k boundary */
-	if (0 != (sizeof(pfe_hif_nocpy_bd_t) % 8))
-	{
-		if ((((addr_t)ring->base_va + size) & (MAX_ADDR_T_VAL << 12)) > ((addr_t)ring->base_va & (MAX_ADDR_T_VAL << 12)))
-		{
-			NXP_LOG_ERROR("A buffer descriptor is crossing 4k boundary\n");
-			goto free_and_fail;
-		}
-	}
-
-	ring->base_pa = oal_mm_virt_to_phys_contig(ring->base_va);
-
-	/*	S32G HIFNCPY AXI MASTER can only access range 0x00000000 - 0xbfffffff */
-	if (unlikely((addr_t)ring->base_pa > (addr_t)0xBFFFFFFFU))
-	{
-		NXP_LOG_WARNING("Descriptor ring memory not in required range: starts @ p0x%p\n", ring->base_pa);
-	}
-
-	/*	Initialize state variables */
-	ring->write_idx = 0U;
-	ring->read_idx = 0U;
-	ring->is_rx = rx;
-	ring->rd_bd_nocpy = (pfe_hif_nocpy_bd_t *)ring->base_va;
-	ring->wr_bd_nocpy = (pfe_hif_nocpy_bd_t *)ring->base_va;
-
-	/*	Initialize memory */
-	memset(ring->base_va, 0, RING_LEN * sizeof(pfe_hif_nocpy_bd_t));
-
-	/*	Chain the buffer descriptors */
-	hw_desc_va = (pfe_hif_nocpy_bd_t *)ring->base_va;
-	hw_desc_pa = (pfe_hif_nocpy_bd_t *)ring->base_pa;
-
-	for (ii=0; ii<RING_LEN; ii++)
-	{
-		if (TRUE == ring->is_rx)
-		{
-			/*	Mark BD as RX */
-			hw_desc_va[ii].dir = 0U;
-			/*	Enable the descriptor */
-			hw_desc_va[ii].desc_en = 1U;
-			hw_desc_va[ii].pkt_xfer = 1U;
-		}
-		else
-		{
-			hw_desc_va[ii].dir = 1U;
-			hw_desc_va[ii].desc_en = 0U;
-			hw_desc_va[ii].pkt_xfer = 1U;
-		}
-
-		/*	Enable BD interrupt */
-		hw_desc_va[ii].cbd_int_en = 1U;
-
-		hw_desc_va[ii].next = (uint32_t)((addr_t)(&hw_desc_pa[ii + 1U]) & 0xffffffffU);
-	}
-
-	/*	Chain last one with the first one */
-	hw_desc_va[ii-1].next = (uint32_t)((addr_t)(&hw_desc_pa[0]) & 0xffffffffU);
-	hw_desc_va[ii-1].last_bd = 1U;
-
-	return ring;
-
-free_and_fail:
-	(void)pfe_hif_ring_destroy(ring);
-	return NULL;
+	return pfe_hif_ring_create_std(rx);
 }
-#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
+
 
 /**
  * @brief		The "standard" HIF variant
diff --git a/sw/pfe_platform/src/pfe_hw_feature.c b/sw/pfe_platform/src/pfe_hw_feature.c
index cad6d94..6040272 100644
--- a/sw/pfe_platform/src/pfe_hw_feature.c
+++ b/sw/pfe_platform/src/pfe_hw_feature.c
@@ -39,6 +39,7 @@ static pfe_hw_feature_t *pfe_hw_feature_create(const char *name, const char *des
 		feature->description = descr;
 		feature->flags = flags;
 		feature->def_val = def_val;
+		feature->val = def_val;
 	}
 	else
 	{
@@ -98,6 +99,17 @@ errno_t pfe_hw_feature_init_all(const uint32_t *cbus_base, pfe_hw_feature_t **hw
 		return ENOMEM;
 	}
 
+        feature = pfe_hw_feature_create("jumbo_frames", "Active if we handle jumbo frames", F_NONE, 0);
+        if (NULL != feature)
+        {
+                hw_features[1] = feature;
+                *hw_features_count = 2U;
+        }
+        else
+        {
+                return ENOMEM;
+        }
+
 	return EOK;
 }
 
diff --git a/sw/pfe_platform/src/pfe_idex.c b/sw/pfe_platform/src/pfe_idex.c
index 46455d5..4b39e9f 100644
--- a/sw/pfe_platform/src/pfe_idex.c
+++ b/sw/pfe_platform/src/pfe_idex.c
@@ -451,6 +451,8 @@ static void pfe_idex_do_tx_conf(const pfe_hif_drv_client_t *client, const pfe_id
 				{
 					idex->txc_free_cbk(ref_ptr);
 				}
+		#else
+				(void)idex;
 		#endif
 				break;
 			}
@@ -471,6 +473,8 @@ static void pfe_idex_do_tx_conf(const pfe_hif_drv_client_t *client, const pfe_id
 				{
 					idex->txc_free_cbk(ref_ptr);
 				}
+		#else
+				(void)idex;
 		#endif
 				break;
 			}
@@ -920,7 +924,7 @@ static errno_t pfe_idex_send_frame(pfe_ct_phy_if_id_t dst_phy, pfe_idex_frame_ty
 	/* TX buffer for HIF NOCPY is allocated directly from BMU2.
 	The whole IDEX frame needs to fit into it, so the IDEX header and payload are copied into the TX buffer. */
 #if (TRUE == IDEX_IS_NOCPY)
-	buf_offset = PFE_CFG_LMEM_HDR_SIZE + 256U + sizeof(pfe_ct_hif_tx_hdr_t);
+	buf_offset = pfe_hif_chnl_get_lmem_hdr_size(hif_chnl) + 256U + sizeof(pfe_ct_hif_tx_hdr_t);
 	(void)memcpy((void *)((addr_t)idex_hdr + buf_offset), idex_hdr, sizeof(pfe_idex_frame_header_t));
 #endif /* IDEX_IS_NOCPY */
 
diff --git a/sw/pfe_platform/src/pfe_pe.c b/sw/pfe_platform/src/pfe_pe.c
index b729788..18ea2a3 100644
--- a/sw/pfe_platform/src/pfe_pe.c
+++ b/sw/pfe_platform/src/pfe_pe.c
@@ -147,13 +147,13 @@ static errno_t pfe_pe_upload_sections(pfe_pe_t **pe, uint32_t pe_num, const ELF_
 
 	for (ii = 0U; ii < elf_file->Header.r32.e_shnum; ii++)
 	{
-		if (0U == (elf_file->arSectHead32[ii].sh_flags & (uint32_t)(((uint32_t)SHF_WRITE) | ((uint32_t)SHF_ALLOC) | ((uint32_t)SHF_EXECINSTR))))
+		if (0U == (ENDIAN_SW_4B(elf_file->arSectHead32[ii].sh_flags) & (uint32_t)(((uint32_t)SHF_WRITE) | ((uint32_t)SHF_ALLOC) | ((uint32_t)SHF_EXECINSTR))))
 		{
 			/*	Skip the section */
 			continue;
 		}
 
-		buf = (void*)((addr_t)elf_file->pvData + elf_file->arSectHead32[ii].sh_offset);
+		buf = (void*)((addr_t)elf_file->pvData + ENDIAN_SW_4B(elf_file->arSectHead32[ii].sh_offset));
 		/* Translate elf virtual address to load address */
 		load_addr = pfe_pe_get_elf_sect_load_addr(elf_file, &elf_file->arSectHead32[ii]);
 		if(0U == load_addr)
@@ -166,13 +166,13 @@ static errno_t pfe_pe_upload_sections(pfe_pe_t **pe, uint32_t pe_num, const ELF_
 		for(pe_idx = 0; pe_idx < pfe_pe_fw_load_cycles(pe[0], (uint8_t)pe_num); ++pe_idx)
 		{
 		/*	Upload the section */
-			ret = pfe_pe_load_elf_section(pe[pe_idx], buf, load_addr, elf_file->arSectHead32[ii].sh_size, elf_file->arSectHead32[ii].sh_type);
+			ret = pfe_pe_load_elf_section(pe[pe_idx], buf, load_addr, ENDIAN_SW_4B(elf_file->arSectHead32[ii].sh_size), ENDIAN_SW_4B(elf_file->arSectHead32[ii].sh_type));
 			if (EOK != ret)
 			{
 				NXP_LOG_ERROR("Couldn't upload firmware section %s, %u bytes @ 0x%08x. Reason: %d\n",
-								elf_file->acSectNames+elf_file->arSectHead32[ii].sh_name,
-								(uint_t)elf_file->arSectHead32[ii].sh_size,
-								(uint_t)elf_file->arSectHead32[ii].sh_addr, ret);
+								elf_file->acSectNames+ENDIAN_SW_4B(elf_file->arSectHead32[ii].sh_name),
+								(uint_t)ENDIAN_SW_4B(elf_file->arSectHead32[ii].sh_size),
+								(uint_t)ENDIAN_SW_4B(elf_file->arSectHead32[ii].sh_addr), ret);
 				pfe_pe_free_mem(pe, pe_num);
 				return ret;
 			}
@@ -1585,7 +1585,7 @@ static errno_t pfe_pe_load_elf_section(pfe_pe_t *pe, const void *sdata, addr_t l
  */
 static addr_t pfe_pe_get_elf_sect_load_addr(const ELF_File_t *elf_file, const Elf32_Shdr *shdr)
 {
-	addr_t virt_addr = shdr->sh_addr;
+	addr_t virt_addr = ENDIAN_SW_4B(shdr->sh_addr);
 	addr_t load_addr;
 	addr_t offset;
 	const Elf32_Phdr *phdr;
@@ -1595,15 +1595,16 @@ static addr_t pfe_pe_get_elf_sect_load_addr(const ELF_File_t *elf_file, const El
 	for (ii=0U; ii<elf_file->Header.r32.e_phnum; ii++)
 	{
 		phdr = &elf_file->arProgHead32[ii];
-		if((virt_addr >= phdr->p_vaddr) &&
-		   (virt_addr <= (phdr->p_vaddr + phdr->p_memsz - shdr->sh_size)))
+		if((virt_addr >= ENDIAN_SW_4B(phdr->p_vaddr)) &&
+		(virt_addr <= (ENDIAN_SW_4B(phdr->p_vaddr) + ENDIAN_SW_4B(phdr->p_memsz) - ENDIAN_SW_4B(shdr->sh_size))))
 		{   /* Address belongs into this segment */
 			/* Calculate the offset between segment load and virtual address */
-			offset = phdr->p_vaddr - phdr->p_paddr;
+			offset = ENDIAN_SW_4B(phdr->p_vaddr) - ENDIAN_SW_4B(phdr->p_paddr);
 			/* Same offset applies also for sections in the segment */
 			load_addr = virt_addr - offset;
 			return load_addr;
 		}
+
 	}
 	/* No segment containing the section was found ! */
 	NXP_LOG_ERROR("Translation of 0x%"PRINTADDR_T"x failed, fallback used\n", virt_addr);
@@ -1835,7 +1836,7 @@ errno_t pfe_pe_load_firmware(pfe_pe_t **pe, uint32_t pe_num, const void *elf)
 		/* Get the mmap size, used to load correct data from FW file*/
 		(void)memcpy(
 				(void*)&mmap_size,
-				(const void*)((addr_t)elf_file->pvData + shdr->sh_offset),
+				(const void*)((addr_t)elf_file->pvData + ENDIAN_SW_4B(shdr->sh_offset)),
 				sizeof(uint32_t));
 
 		/* Convert mmap size endian ! */
@@ -1856,7 +1857,7 @@ errno_t pfe_pe_load_firmware(pfe_pe_t **pe, uint32_t pe_num, const void *elf)
 
 			(void)memcpy(
 					(void*)tmp_mmap,
-					(const void*)((addr_t)elf_file->pvData + shdr->sh_offset),
+					(const void*)((addr_t)elf_file->pvData + ENDIAN_SW_4B(shdr->sh_offset)),
 					mmap_size);
 
 			if(0 != strcmp(mmap_version_str, tmp_mmap->common.version.cthdr))
@@ -1883,7 +1884,7 @@ errno_t pfe_pe_load_firmware(pfe_pe_t **pe, uint32_t pe_num, const void *elf)
 
 		/*	Load section to RAM */
 		shdr = &elf_file->arSectHead32[mask_sectIdx];
-		messages_mem = oal_mm_malloc(shdr->sh_size);
+		messages_mem = oal_mm_malloc(ENDIAN_SW_4B(shdr->sh_size));
 		if (NULL == messages_mem)
 		{
 			ret = ENOMEM;
@@ -1896,8 +1897,8 @@ errno_t pfe_pe_load_firmware(pfe_pe_t **pe, uint32_t pe_num, const void *elf)
 		}
 		else
 		{
-			(void)memcpy(messages_mem, (const void *)((uint8_t *)elf_file->pvData + shdr->sh_offset), shdr->sh_size);
-			messages_size = shdr->sh_size;
+			(void)memcpy(messages_mem, (const void *)((uint8_t *)elf_file->pvData + ENDIAN_SW_4B(shdr->sh_offset)), ENDIAN_SW_4B(shdr->sh_size));
+			messages_size = ENDIAN_SW_4B(shdr->sh_size);
 		}
 	}
 	else
@@ -1913,7 +1914,7 @@ errno_t pfe_pe_load_firmware(pfe_pe_t **pe, uint32_t pe_num, const void *elf)
 
 		/*	Load section to RAM */
 		shdr = &elf_file->arSectHead32[mask_sectIdx];
-		features_mem = oal_mm_malloc(shdr->sh_size);
+		features_mem = oal_mm_malloc(ENDIAN_SW_4B(shdr->sh_size));
 		if (NULL == features_mem)
 		{
 			ret = ENOMEM;
@@ -1930,8 +1931,8 @@ errno_t pfe_pe_load_firmware(pfe_pe_t **pe, uint32_t pe_num, const void *elf)
 		}
 		else
 		{
-			(void)memcpy(features_mem, (const void *)((addr_t)elf_file->pvData + shdr->sh_offset), shdr->sh_size);
-			features_size = shdr->sh_size;
+			(void)memcpy(features_mem, (const void *)((addr_t)elf_file->pvData + ENDIAN_SW_4B(shdr->sh_offset)), ENDIAN_SW_4B(shdr->sh_size));
+			features_size = ENDIAN_SW_4B(shdr->sh_size);
 		}
 	}
 	else
diff --git a/sw/pfe_platform/src/pfe_rtable.c b/sw/pfe_platform/src/pfe_rtable.c
index 83e7dae..f5ba90d 100644
--- a/sw/pfe_platform/src/pfe_rtable.c
+++ b/sw/pfe_platform/src/pfe_rtable.c
@@ -1228,6 +1228,8 @@ void pfe_rtable_entry_set_out_vlan(pfe_rtable_entry_t *entry, uint16_t vlan, boo
 
 	entry->phys_entry->args.vlan = oal_htons(vlan);
 
+	entry->phys_entry->actions &= ~oal_htonl(RT_ACT_MOD_VLAN_HDR|RT_ACT_ADD_VLAN_HDR);
+
 	if (replace)
 	{
 		entry->phys_entry->actions |= oal_htonl(RT_ACT_MOD_VLAN_HDR);
@@ -1576,6 +1578,24 @@ pfe_rtable_entry_t *pfe_rtable_entry_get_child(const pfe_rtable_entry_t *entry)
 	return entry->child;
 }
 
+/**
+ * @brief		Get index into statistics table
+ * @param[in]	entry The routing table entry instance
+ * @return		Index into statistics table.
+ */
+uint8_t pfe_rtable_entry_get_stats_index(const pfe_rtable_entry_t *entry)
+{
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (unlikely(NULL == entry))
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		return 0U;
+	}
+#endif /* PFE_CFG_NULL_ARG_CHECK */
+
+	return oal_ntohs(entry->phys_entry->conntrack_stats_index);
+}
+
 /***
  * @brief		Find out if entry has been added to a routing table
  * @param[in]	entry The routing table entry instance
diff --git a/sw/xfci/libfci/public/fpp.h b/sw/xfci/libfci/public/fpp.h
index c2bbd65..a2563c5 100644
--- a/sw/xfci/libfci/public/fpp.h
+++ b/sw/xfci/libfci/public/fpp.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  Copyright (C) 2010 Mindspeed Technologies, Inc.
  *  Copyright 2014-2016 Freescale Semiconductor, Inc.
- *  Copyright 2017-2021 NXP
+ *  Copyright 2017-2022 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -652,6 +652,18 @@ typedef enum {
  */
 #define FPP_CMD_IPV6_CONNTRACK          		0x0414
 
+/**
+ * @brief       Conntrack statistics.
+ * @details     Related data types: @ref fpp_ct_cmd_t and @ref fpp_ct6_cmd_t
+ * @note        @b All values are in a network byte order [@b NBO].
+ *
+ * @snippet     fpp.h  fpp_conntrack_stats_t
+ */
+typedef struct CAL_PACKED_ALIGNED(4) {
+    uint32_t hit;        /*< Number of frames that hit the conntrack */
+    uint32_t hit_bytes;  /*< Sum of bytesizes of all frames that hit the conntrack */
+} fpp_conntrack_stats_t;
+
 /**
  * @brief       Data structure for IPv4 conntrack.
  * @details     Related FCI commands: @ref FPP_CMD_IPV4_CONNTRACK, @ref FPP_CMD_IP_ROUTE
@@ -702,6 +714,9 @@ typedef struct CAL_PACKED_ALIGNED(4) {
                                   If non-zero, then this VLAN tag is added to the routed
                                   packet. If the packet already has a VLAN tag, then its tag
                                   is replaced. */
+
+    fpp_conntrack_stats_t CAL_PACKED_ALIGNED(4) stats;        /*< 'orig'  statistics [ro] */
+    fpp_conntrack_stats_t CAL_PACKED_ALIGNED(4) stats_reply;  /*< 'reply' statistics [ro] */
 } fpp_ct_cmd_t;
 /* [fpp_ct_cmd_t] */
 
@@ -784,6 +799,9 @@ typedef struct CAL_PACKED_ALIGNED(4) {
                                   If non-zero, then this VLAN tag is added to the routed
                                   packet. If the packet already has a VLAN tag, then its tag
                                   is replaced. */
+
+    fpp_conntrack_stats_t CAL_PACKED_ALIGNED(4) stats;        /*< 'orig'  statistics [ro] */
+    fpp_conntrack_stats_t CAL_PACKED_ALIGNED(4) stats_reply;  /*< 'reply' statistics [ro] */
 } fpp_ct6_cmd_t;
 /* [fpp_ct6_cmd_t] */
 
diff --git a/sw/xfci/libfci/src/libfci_linux.c b/sw/xfci/libfci/src/libfci_linux.c
index 4e41dfd..0665c6d 100644
--- a/sw/xfci/libfci/src/libfci_linux.c
+++ b/sw/xfci/libfci/src/libfci_linux.c
@@ -1,6 +1,6 @@
 /* =========================================================================
  *  Copyright (C) 2007 Mindspeed Technologies, Inc.
- *  Copyright 2017-2021 NXP
+ *  Copyright 2017-2022 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -481,15 +481,20 @@ int fci_catch(FCI_CLIENT *client)
 }
 
 /*
- * @brief		fci_fd: Not supported yet
- * @param[in]	client FCI client instance to be used
- * @return		Always -1 (failure) because the function is not supported.
- * @warning		Function shall not be used.
+ * @brief		Return file descriptor of a socket for FCI events from driver.
+ * @param[in]	client The FCI client instance
+ * @return		File descriptor or -1 if some error.
  */
 int fci_fd(FCI_CLIENT *client)
 {
-	FCILIB_PRINTF(FCILIB_ERR, "LIBFCI: fci_fd() not implemented\n");
-	return -1;
+	if (NULL == client)
+	{
+		return -1;
+	}
+	else
+	{
+		return client->back_sock_fd;
+	}
 }
 
 
-- 
2.17.1

