From ab4cab425d4d723280fe3c88a98a88283c0ec91c Mon Sep 17 00:00:00 2001
From: "jan.petrous" <jan.petrous@nxp.com>
Date: Fri, 11 Nov 2022 07:05:31 +0100
Subject: [PATCH 1/3] version PFE_S32G_A53_LNX_1.2.0 RC2

Highlights:
    1) Support for PFE FW 1.4.0/1.5.0
    2) RT_LMEM support for G3
    3) Various fixes

pfe_linux.git: c331ee2c0142f68e099788600d6b4eceb3c8a5a8

Upstream-Status: Pending

Signed-off-by: Jan Petrous <jan.petrous@nxp.com>
Signed-off-by: Claudiu Manoil <claudiu.manoil@nxp.com>
Signed-off-by: Martin Hrdlicka <martin.hrdlicka@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 sw/elf/public/elf.h                           |    1 +
 sw/fci/src/fci.c                              |    6 +
 sw/fci/src/fci_core_linux.c                   |    2 +-
 sw/fci/src/fci_fw_features.c                  |  213 ++++
 sw/fci/src/fci_fw_features.h                  |    1 +
 sw/libfci_cli/Makefile                        |    2 +-
 sw/libfci_cli/src/libfci_cli_cmds_fwfeat.c    |  162 ++-
 sw/libfci_cli/src/libfci_cli_cmds_fwfeat.h    |    4 +-
 sw/libfci_cli/src/libfci_cli_common.h         |   25 +-
 sw/libfci_cli/src/libfci_cli_def_cmds.h       |   23 +-
 sw/libfci_cli/src/libfci_cli_def_help.c       |   89 +-
 .../src/libfci_cli_def_optarg_keywords.c      |   21 +-
 .../src/libfci_cli_def_optarg_keywords.h      |   19 +-
 sw/libfci_cli/src/libfci_cli_def_opts.h       |   47 +
 sw/libfci_cli/src/libfci_cli_parser.c         |  204 ++++
 sw/libfci_cli/src/libfci_cli_parser.h         |    1 -
 sw/libfci_cli/src/libfci_demo/demo_fwfeat.c   |  478 +++++++-
 sw/libfci_cli/src/libfci_demo/demo_fwfeat.h   |   26 +-
 sw/linux-pfeng/pfeng-drv.c                    |   11 +-
 sw/linux-pfeng/pfeng-ethtool.c                |   50 +-
 sw/linux-pfeng/pfeng-netif.c                  |    2 +-
 sw/linux-pfeng/pfeng-phylink.c                |    2 +-
 sw/linux-pfeng/pfeng.h                        |    2 +-
 sw/pfe_platform/hw/s32g/pfe_cbus.h            |   37 +-
 sw/pfe_platform/hw/s32g/pfe_emac_csr.c        |   10 +-
 sw/pfe_platform/hw/s32g/pfe_hif_csr.c         |    7 +
 sw/pfe_platform/hw/s32g/pfe_platform_master.c |   88 +-
 sw/pfe_platform/public/pfe_class.h            |    1 +
 sw/pfe_platform/public/pfe_ct_comp.h          |   31 +
 sw/pfe_platform/public/pfe_feature_mgr.h      |   15 +
 sw/pfe_platform/public/pfe_fw_feature.h       |   22 +-
 sw/pfe_platform/public/pfe_platform.h         |    2 +
 sw/pfe_platform/public/pfe_rtable.h           |   13 +-
 sw/pfe_platform/src/pfe_class.c               |    2 +-
 sw/pfe_platform/src/pfe_feature_mgr.c         |  676 +++++++++-
 sw/pfe_platform/src/pfe_fw_feature.c          |  411 ++++++-
 sw/pfe_platform/src/pfe_pe.c                  |  137 +--
 sw/pfe_platform/src/pfe_rtable.c              | 1085 ++++++++++-------
 sw/pfe_platform/src/pfe_util.c                |    2 +-
 sw/xfci/libfci/public/fpp_ext.h               |   40 +
 40 files changed, 3334 insertions(+), 636 deletions(-)
 create mode 100644 sw/pfe_platform/public/pfe_ct_comp.h

diff --git a/sw/elf/public/elf.h b/sw/elf/public/elf.h
index b3995df..9bf31aa 100644
--- a/sw/elf/public/elf.h
+++ b/sw/elf/public/elf.h
@@ -35,6 +35,7 @@
  2) needed interfaces from external units
  3) internal and external interfaces from this unit
 ==================================================================================================*/
+#include <uapi/linux/elf.h>
 #include "oal.h"
 
 /*==================================================================================================
diff --git a/sw/fci/src/fci.c b/sw/fci/src/fci.c
index f71054e..75795ff 100644
--- a/sw/fci/src/fci.c
+++ b/sw/fci/src/fci.c
@@ -374,6 +374,12 @@ errno_t fci_process_ipc_message(fci_msg_t *msg, fci_msg_t *rep_msg)
 						break;
 					}
 
+					case FPP_CMD_FW_FEATURE_ELEMENT:
+					{
+						ret = fci_fw_features_element_cmd(msg, &fci_ret, (fpp_fw_features_element_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
+						break;
+					}
+
 					case FPP_CMD_SPD:
 					{
 						ret = fci_spd_cmd(msg, &fci_ret, (fpp_spd_cmd_t *)reply_buf_ptr, reply_buf_len_ptr);
diff --git a/sw/fci/src/fci_core_linux.c b/sw/fci/src/fci_core_linux.c
index a88d92d..1670080 100644
--- a/sw/fci/src/fci_core_linux.c
+++ b/sw/fci/src/fci_core_linux.c
@@ -193,7 +193,7 @@ void fci_core_fini(void)
 			
 			if (TRUE == GET_FCI_CORE()->clients[ii].connected)
 			{
-				if (EOK != fci_netlink_send(GET_FCI_CORE()->clients[ii].cmd_port_id, &msg))
+				if (EOK != fci_netlink_send(GET_FCI_CORE()->clients[ii].back_port_id, &msg))
 				{
 					NXP_LOG_ERROR("fci_netlink_send failed\n");
 				}
diff --git a/sw/fci/src/fci_fw_features.c b/sw/fci/src/fci_fw_features.c
index 20b23d8..021faed 100644
--- a/sw/fci/src/fci_fw_features.c
+++ b/sw/fci/src/fci_fw_features.c
@@ -199,6 +199,219 @@ errno_t fci_fw_features_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_fw_features_c
 	return ret;
 }
 
+/**
+ * @brief			Processes FPP_CMD_FW_FEATURE_ELEMENT commands
+ * @param[in]		msg FCI message containing the FPP_CMD_FW_FEATURE_ELEMENT command
+ * @param[out]		fci_ret FCI command return value
+ * @param[out]		reply_buf Pointer to a buffer where function will construct command reply (fpp_fw_features_element_cmd_t)
+ * @param[in,out]	reply_len Maximum reply buffer size on input, real reply size on output (in bytes)
+ * @return			EOK if success, error code otherwise
+ * @note			Function is only called within the FCI worker thread context.
+ * @note			Must run with domain DB protected against concurrent accesses.
+ */
+errno_t fci_fw_features_element_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_fw_features_element_cmd_t *reply_buf, uint32_t *reply_len)
+{
+	fpp_fw_features_element_cmd_t *fp_cmd;
+	char *feature_name;
+	const char *table_el_name;
+	errno_t ret = EOK;
+
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		ret = EINVAL;
+	}
+	else if (unlikely(FALSE == __context.fci_initialized))
+	{
+		NXP_LOG_ERROR("Context not initialized\n");
+ 		ret = EPERM;
+	}
+	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		*fci_ret = FPP_ERR_OK;
+
+		/* Important to initialize to avoid buffer overflows */
+		if (*reply_len < sizeof(fpp_fw_features_element_cmd_t))
+		{
+			/*      Internal problem. Set fci_ret, but respond with detected internal error code (ret). */
+			NXP_LOG_ERROR("Buffer length does not match expected value (fpp_fw_features_element_cmd_t)\n");
+			*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+			ret = EINVAL;
+		}
+		else
+		{
+			/*      No data written to reply buffer (yet) */
+			*reply_len = 0U;
+			(void)memset(reply_buf, 0, sizeof(fpp_fw_features_element_cmd_t));
+			fp_cmd = (fpp_fw_features_element_cmd_t *)(msg->msg_cmd.payload);
+
+
+			if ((NULL == fp_cmd->fw_feature_name) || fp_cmd->fw_feature_name[0] == '\0')
+			{
+				NXP_LOG_ERROR("Feature invalid name (fpp_fw_features_element_cmd_t)\n");
+				*fci_ret = FPP_ERR_FW_FEATURE_NOT_FOUND;
+				ret = EOK;
+			}
+			else
+			{
+				feature_name = fp_cmd->fw_feature_name;
+				if(feature_name[0] == 'u' && feature_name[1] == '_')
+				{
+					feature_name += 2;
+				}
+
+				switch (fp_cmd->action)
+				{
+					case FPP_ACTION_UPDATE:
+					{
+						if (pfe_feature_mgr_is_available(feature_name))
+						{
+							ret = pfe_feature_mgr_table_set_val(fp_cmd->fw_feature_name, fp_cmd->group, fp_cmd->element_name, fp_cmd->index, (uint8_t *)fp_cmd->payload);
+							if (EOK != ret)
+							{
+								*fci_ret = FPP_ERR_FW_FEATURE_ELEMENT_NOT_FOUND;
+							}
+						}
+						else
+						{
+							 *fci_ret = FPP_ERR_FW_FEATURE_NOT_AVAILABLE;
+						}
+						ret = EOK;
+						break;
+					}
+					case FPP_ACTION_QUERY:
+					{
+						if (pfe_feature_mgr_is_available(feature_name))
+						{
+							if (fp_cmd->element_name[0] == '\0')
+							{
+								ret = pfe_feature_mgr_table_first(fp_cmd->fw_feature_name, fp_cmd->group, &table_el_name);
+								if (ret != EOK)
+								{
+									/*      End of the query process (no more entities to report). Respond with FCI error code. */
+									*fci_ret = FPP_ERR_FW_FEATURE_ELEMENT_NOT_FOUND;
+									ret = EOK;
+								}
+								else
+								{
+									ret = pfe_feature_mgr_table_get_size(fp_cmd->fw_feature_name, fp_cmd->group, table_el_name, &reply_buf->unit_size);
+									if (ret == EOK)
+									{
+										ret = pfe_feature_mgr_table_get_multiplicity(fp_cmd->fw_feature_name, fp_cmd->group, table_el_name, &reply_buf->count);
+									}
+									if (ret == EOK)
+									{
+										ret = pfe_feature_mgr_table_get_payload(fp_cmd->fw_feature_name, fp_cmd->group, table_el_name, (uint8_t *)reply_buf->payload);
+									}
+									if(EOK == ret)
+									{
+										(void)strncpy(reply_buf->element_name, table_el_name, FPP_FEATURE_NAME_SIZE);
+										(void)strncpy(reply_buf->fw_feature_name, fp_cmd->fw_feature_name, FPP_FEATURE_NAME_SIZE);
+										*reply_len = sizeof(fpp_fw_features_element_cmd_t);
+										*fci_ret = FPP_ERR_OK;
+									}
+									else
+									{
+									/*      Internal problem. */
+										*reply_len = sizeof(fpp_fw_features_element_cmd_t);
+										*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+									}
+								}
+							}
+							else
+							{
+								ret = pfe_feature_mgr_table_get_size(fp_cmd->fw_feature_name, fp_cmd->group, fp_cmd->element_name, &reply_buf->unit_size);
+								if (ret == EOK)
+								{
+									ret = pfe_feature_mgr_table_get_multiplicity(fp_cmd->fw_feature_name, fp_cmd->group, fp_cmd->element_name, &reply_buf->count);
+								}
+								if (ret == EOK)
+								{
+									ret = pfe_feature_mgr_table_get_payload(fp_cmd->fw_feature_name, fp_cmd->group, fp_cmd->element_name, (uint8_t *)reply_buf->payload);
+								}
+								if(EOK == ret)
+								{
+									(void)strncpy(reply_buf->element_name, fp_cmd->element_name, FPP_FEATURE_NAME_SIZE);
+									(void)strncpy(reply_buf->fw_feature_name, fp_cmd->fw_feature_name, FPP_FEATURE_NAME_SIZE);
+									*reply_len = sizeof(fpp_fw_features_element_cmd_t);
+									*fci_ret = FPP_ERR_OK;
+								}
+								else
+								{
+									*reply_len = sizeof(fpp_fw_features_element_cmd_t);
+									*fci_ret = FPP_ERR_FW_FEATURE_ELEMENT_NOT_FOUND;
+									ret = EOK;
+								}
+							}
+						}
+						else
+						{
+							*fci_ret = FPP_ERR_FW_FEATURE_NOT_AVAILABLE;
+							ret = EOK;
+						}
+						break;
+					}
+					case FPP_ACTION_QUERY_CONT:
+					{
+						if (pfe_feature_mgr_is_available(feature_name))
+						{
+							ret = pfe_feature_mgr_table_next(fp_cmd->fw_feature_name, fp_cmd->group, &table_el_name);
+							if(ret != EOK)
+							{
+								/*      End of the query process (no more entities to report). Respond with FCI error code. */
+								*fci_ret = FPP_ERR_FW_FEATURE_ELEMENT_NOT_FOUND;
+								ret = EOK;
+							}
+							else
+							{
+								ret = pfe_feature_mgr_table_get_size(fp_cmd->fw_feature_name, fp_cmd->group, table_el_name, &reply_buf->unit_size);
+								if (ret == EOK)
+								{
+									ret = pfe_feature_mgr_table_get_multiplicity(fp_cmd->fw_feature_name, fp_cmd->group, table_el_name, &reply_buf->count);
+								}
+								if (ret == EOK)
+								{
+									ret = pfe_feature_mgr_table_get_payload(fp_cmd->fw_feature_name, fp_cmd->group, table_el_name, (uint8_t *)reply_buf->payload);
+								}
+								if(EOK == ret)
+								{
+									(void)strncpy(reply_buf->element_name, table_el_name, FPP_FEATURE_NAME_SIZE);
+									(void)strncpy(reply_buf->fw_feature_name, fp_cmd->fw_feature_name, FPP_FEATURE_NAME_SIZE);
+									*reply_len = sizeof(fpp_fw_features_element_cmd_t);
+									*fci_ret = FPP_ERR_OK;
+								}
+								else
+								{
+									/*      Internal problem. */
+									*reply_len = sizeof(fpp_fw_features_element_cmd_t);
+									*fci_ret = FPP_ERR_INTERNAL_FAILURE;
+								}
+							}
+						}
+						else
+						{
+							*fci_ret = FPP_ERR_FW_FEATURE_NOT_AVAILABLE;
+							ret = EOK;
+						}
+						break;
+					}
+					default:
+					{
+						/*      Unknown action. Respond with FCI error code. */
+						NXP_LOG_ERROR("FPP_CMD_FW_FEATURE: Unknown action received: 0x%x\n", fp_cmd->action);
+						*fci_ret = FPP_ERR_UNKNOWN_ACTION;
+						ret = EOK;
+						break;
+					}
+				}
+			}
+		}
+	}
+	return ret;
+}
+
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
 #include "Eth_43_PFE_MemMap.h"
diff --git a/sw/fci/src/fci_fw_features.h b/sw/fci/src/fci_fw_features.h
index 8eba3d1..c8b1646 100644
--- a/sw/fci/src/fci_fw_features.h
+++ b/sw/fci/src/fci_fw_features.h
@@ -14,6 +14,7 @@
 #endif /* PFE_CFG_TARGET_OS_AUTOSAR */
 
 extern errno_t fci_fw_features_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_fw_features_cmd_t *reply_buf, uint32_t *reply_len);
+extern errno_t fci_fw_features_element_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_fw_features_element_cmd_t *reply_buf, uint32_t *reply_len);
 
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
diff --git a/sw/libfci_cli/Makefile b/sw/libfci_cli/Makefile
index bc659f8..b1e6c07 100644
--- a/sw/libfci_cli/Makefile
+++ b/sw/libfci_cli/Makefile
@@ -61,7 +61,7 @@ ifeq ($(TARGET_OS),LINUX)
 	GLOBAL_CCFLAGS := $(shell echo $(GLOBAL_CCFLAGS))
 	
 	CLI_TARGET_OS = "LNX"
-	CLI_DRV_VERSION = "RTM 1.2.0 RC1"
+	CLI_DRV_VERSION = "1.2.0 RC2"
 	CLI_DRV_COMMIT_HASH = "M4_DRIVER_COMMIT_HASH"
 else
 #This branch by defaut means QNX.
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_fwfeat.c b/sw/libfci_cli/src/libfci_cli_cmds_fwfeat.c
index 100380f..adceb17 100644
--- a/sw/libfci_cli/src/libfci_cli_cmds_fwfeat.c
+++ b/sw/libfci_cli/src/libfci_cli_cmds_fwfeat.c
@@ -1,5 +1,5 @@
 /* =========================================================================
- *  Copyright 2020-2021 NXP
+ *  Copyright 2020-2022 NXP
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -111,6 +111,65 @@ static int fwfeat_print(const fpp_fw_features_cmd_t* p_fwfeat)
     return (FPP_ERR_OK); 
 }
 
+static int fwfeat_el_print(const fpp_fw_features_element_cmd_t* p_fwfeat_el)
+{
+    assert(NULL != p_fwfeat_el);
+    
+    /* NOTE: native data type to comply with 'printf()' conventions (asterisk specifier) */
+    int indent = 0;
+    
+    uint8_t unit_size = 0u;
+    uint8_t count = 0u;
+    const uint8_t* p_payload = NULL;
+    demo_fwfeat_el_ld_get_payload(p_fwfeat_el, &p_payload, &count, &unit_size);
+    
+    printf("%-*s%s\n", indent, "", demo_fwfeat_el_ld_get_name(p_fwfeat_el));
+    
+    indent += 4;
+    
+    {
+        const uint8_t group = demo_fwfeat_el_ld_get_group(p_fwfeat_el);
+        printf("%-*sel-group:  %s (0x%02x)\n"
+               "%-*sunit-size: %hhu\n"
+               "%-*scount:     %hhu\n"
+               "%-*spayload:   ",
+               indent, "", cli_value2txt_fwfeat_el_group(group), group,
+               indent, "", unit_size,
+               indent, "", count,
+               indent, "");  /* indent for payload data is done here ; actual payload is printed in the next code block */
+    }
+    
+    {
+        const char* p_txt_delim = ""; /* no delim for the 1st item */
+        for (uint8_t i = 0; (i < count); i++)
+        {
+            printf("%s", p_txt_delim);
+            switch (unit_size)
+            {
+                case 1u:
+                    printf("0x%02x", p_payload[i]);
+                break;
+                
+                case 2u:
+                    printf("0x%04x", ((const uint16_t*)p_payload)[i]);
+                break;
+                
+                case 4u:
+                    printf("0x%08x", ((const uint32_t*)p_payload)[i]);
+                break;
+                
+                default:
+                    printf("__INVALID_ITEM__");
+                break;
+            }
+            p_txt_delim = " ; ";
+        }
+        printf("\n");
+    }
+    
+    return (FPP_ERR_OK); 
+}
+
 /* ==== PUBLIC FUNCTIONS =================================================== */ 
 
 int cli_cmd_fwfeat_print(const cli_cmdargs_t *p_cmdargs)
@@ -171,4 +230,105 @@ int cli_cmd_fwfeat_set(const cli_cmdargs_t *p_cmdargs)
     return (rtn);
 }
 
+int cli_cmd_fwfeat_el_print(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_fw_features_element_cmd_t fwfeat_el = {0};
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_FEATURE, NULL, (p_cmdargs->feature_name.is_valid)},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        if (p_cmdargs->element_name.is_valid)
+        {
+            /* print a single FW feature element */
+            rtn = demo_fwfeat_el_get_by_name(cli_p_cl, &fwfeat_el, 
+                                             (p_cmdargs->feature_name.txt),
+                                             (p_cmdargs->element_name.txt),
+                                             (p_cmdargs->element_group.value),
+                                             (p_cmdargs->offset.value));
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = fwfeat_el_print(&fwfeat_el);
+            }
+        }
+        else
+        {
+            /* print all elements of a FW feature */
+            rtn = demo_fwfeat_el_print_all(cli_p_cl, fwfeat_el_print, (p_cmdargs->feature_name.txt), (p_cmdargs->element_group.value));
+        }
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_fwfeat_el_set(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_fw_features_element_cmd_t fwfeat_el = {0};
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_FEATURE,   NULL, (p_cmdargs->feature_name.is_valid)},
+        {OPT_ELEMENT,   NULL, (p_cmdargs->element_name.is_valid)},
+        {OPT_UNIT_SIZE, NULL, (p_cmdargs->unit_size.is_valid)},
+        {OPT_PAYLOAD,   NULL, (p_cmdargs->payload.is_valid)},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* get init local data ; if this is successful, then local data should have correct element group and correct index (offset) */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_fwfeat_el_get_by_name(cli_p_cl, &fwfeat_el, 
+                                         (p_cmdargs->feature_name.txt),
+                                         (p_cmdargs->element_name.txt),
+                                         (p_cmdargs->element_group.value),
+                                         (p_cmdargs->offset.value));
+    }
+    
+    /* modify local data - payload and its associated values */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_fwfeat_el_set_payload(&fwfeat_el, (p_cmdargs->payload.arr), (p_cmdargs->payload.count), (p_cmdargs->unit_size.value));
+    }
+    
+    /*
+     * HACK: Currently (9th November 2022), PFE driver does not provide correct info about element group nor about index (offset).
+     *       In order to allow setting of data at particular indexes, let's add here explicit setting of element group and index.
+     */
+    if (FPP_ERR_OK == rtn)
+    {
+        if (p_cmdargs->element_group.is_valid)
+        {
+            demo_fwfeat_el_set_group(&fwfeat_el, (p_cmdargs->element_group.value));
+        }
+        if (p_cmdargs->offset.is_valid)
+        {
+            demo_fwfeat_el_set_index(&fwfeat_el, (p_cmdargs->offset.value));
+        }
+    }
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_fwfeat_el_set(cli_p_cl, &fwfeat_el);
+    }
+    
+    return (rtn);
+}
 /* ========================================================================= */
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_fwfeat.h b/sw/libfci_cli/src/libfci_cli_cmds_fwfeat.h
index edda32c..c155466 100644
--- a/sw/libfci_cli/src/libfci_cli_cmds_fwfeat.h
+++ b/sw/libfci_cli/src/libfci_cli_cmds_fwfeat.h
@@ -41,7 +41,9 @@
 /* ==== PUBLIC FUNCTIONS =================================================== */
 
 int cli_cmd_fwfeat_print(const cli_cmdargs_t *p_cmdargs);
-int cli_cmd_fwfeat_set(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_fwfeat_set(const cli_cmdargs_t *p_cmdargs); 
+int cli_cmd_fwfeat_el_print(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_fwfeat_el_set(const cli_cmdargs_t *p_cmdargs);
 
 /* ========================================================================= */
 
diff --git a/sw/libfci_cli/src/libfci_cli_common.h b/sw/libfci_cli/src/libfci_cli_common.h
index 595ebe4..2fc8293 100644
--- a/sw/libfci_cli/src/libfci_cli_common.h
+++ b/sw/libfci_cli/src/libfci_cli_common.h
@@ -43,7 +43,7 @@
 
 /* app version */
 #define CLI_VERSION_MAJOR   "2"
-#define CLI_VERSION_MINOR   "9"
+#define CLI_VERSION_MINOR   "10"
 #define CLI_VERSION_PATCH   "0"
 #define CLI_VERSION_STRING  CLI_VERSION_MAJOR"."CLI_VERSION_MINOR"."CLI_VERSION_PATCH
 
@@ -96,6 +96,7 @@
 #define FEATURE_NAME_TXT_LN  (FPP_FEATURE_NAME_SIZE + 1)  /* this is how the buffer size is defined in 'fpp.ext.h' */
 #define ZPROBS_LN            (8u)  /* Max count of probability zones is based on info from FCI API Reference (chapter about "QoS" feature) */
 #define SCH_INS_LN           (8u)  /* Max count of scheduler inputs is based on info from FCI API Reference (chapter about "QoS" feature) */
+#define PAYLOAD_LN           (128) /* Value of this symbol must match the hardcoded size of '.payload' array in fpp_fw_features_element_cmd_t */
 
 /* misc macro sanity checks */
 #if (MAC_BYTES_LN < 2u)
@@ -637,6 +638,28 @@ typedef struct cli_cmdargs_tt
         bool is_on;
     } dbg_to_dbgfile;
 
+    struct
+    {
+        bool is_valid;
+        char txt[FEATURE_NAME_TXT_LN];
+    } element_name;
+    struct 
+    {
+        bool is_valid;
+        uint8_t value;
+    } element_group;
+    struct
+    {
+        bool is_valid;
+        uint8_t value;
+    } unit_size;
+    struct
+    {
+        bool is_valid;
+        uint8_t arr[PAYLOAD_LN];
+        uint8_t count;
+    } payload;
+
 } cli_cmdargs_t;
 
 #define TXT_ERR_INDENT     ""
diff --git a/sw/libfci_cli/src/libfci_cli_def_cmds.h b/sw/libfci_cli/src/libfci_cli_def_cmds.h
index 2b3d3e5..24f6ade 100644
--- a/sw/libfci_cli/src/libfci_cli_def_cmds.h
+++ b/sw/libfci_cli/src/libfci_cli_def_cmds.h
@@ -316,9 +316,17 @@
 #define CMD_66_CLI_TXT      "fwfeat-set"
 #define CMD_66_CMDEXEC      cli_cmd_fwfeat_set
 #define CMD_66_HELP         txt_help_fwfeat_set
+ 
+#define CMD_67_ENUM_NAME    CMD_FWFEAT_EL_PRINT
+#define CMD_67_CLI_TXT      "fwfeat-el-print"
+#define CMD_67_CMDEXEC      cli_cmd_fwfeat_el_print
+#define CMD_67_HELP         txt_help_fwfeat_el_print
+
+#define CMD_68_ENUM_NAME    CMD_FWFEAT_EL_SET
+#define CMD_68_CLI_TXT      "fwfeat-el-set"
+#define CMD_68_CMDEXEC      cli_cmd_fwfeat_el_set
+#define CMD_68_HELP         txt_help_fwfeat_el_set
 
-/*      CMD_67_ENUM_NAME    reserved for future FWFEAT cmds */
-/*      CMD_68_ENUM_NAME    reserved for future FWFEAT cmds */
 /*      CMD_69_ENUM_NAME    reserved for future FWFEAT cmds */
 
 #define CMD_70_ENUM_NAME    CMD_QOS_QUE_PRINT
@@ -1079,12 +1087,6 @@ typedef enum cli_cmd_tt {
     CMD_LN  /* length of the ID enum list */
 } cli_cmd_t;
 
-#ifdef PFE_CFG_TARGET_OS_AUTOSAR
-#define ETH_43_PFE_START_SEC_CODE
-#include "Eth_43_PFE_MemMap.h"
-#endif /* PFE_CFG_TARGET_OS_AUTOSAR */
-
-
 /* ==== PUBLIC FUNCTIONS =================================================== */
 
 bool cli_cmd_is_valid(uint16_t value);
@@ -1100,9 +1102,4 @@ const char* cli_cmd_cmd2txt(cli_cmd_t cmd);
 
 /* ========================================================================= */
 
-#ifdef PFE_CFG_TARGET_OS_AUTOSAR
-#define ETH_43_PFE_STOP_SEC_CODE
-#include "Eth_43_PFE_MemMap.h"
-#endif /* PFE_CFG_TARGET_OS_AUTOSAR */
-
 #endif
diff --git a/sw/libfci_cli/src/libfci_cli_def_help.c b/sw/libfci_cli/src/libfci_cli_def_help.c
index ea28eee..015387a 100644
--- a/sw/libfci_cli/src/libfci_cli_def_help.c
+++ b/sw/libfci_cli/src/libfci_cli_def_help.c
@@ -536,6 +536,14 @@
                                         "  Index of the first item to print.\n"  \
                                         "  Default value is 0 (start from the very first item of the table).\n"
 
+#define TXT_OPT__POSITION_FWFEAT_EL_SET          TXT_HELP__POSITION  "=<value>"
+#define TXT_OPTDESCR__POSITION_FWFEAT_EL_SET     TXT_HELP__POSITION  "=<"  TXT_OPTARGS__U8_DEC  ">"  "\n"    \
+                                                 "  Index of the target item in the element table. \n"       \
+                                                 "  Position == 0 : Operate with all table items. \n"        \
+                                                 "  Position > 0  : Operate with the particular item that is at given position. \n"  \
+                                                 "  Indexing starts from positon 1. \n"  \
+                                                 "  Default value of this parameter is 0 (operate with all table items).\n"
+
 #define TXT_OPT__POSITION_INSADD_IQOS_FLOW       TXT_HELP__POSITION  "=<value>"
 #define TXT_OPTDESCR__POSITION_INSADD_IQOS_FLOW  TXT_HELP__POSITION  "=<"  TXT_OPTARGS__U8_DEC  ">"  "\n"  \
                                                  "  Index where to insert the item.\n"                     \
@@ -620,6 +628,10 @@
 #define TXT_OPT__FEATURE_FW             TXT_HELP__FEATURE  "=<feature_name>"
 #define TXT_OPTDESCR__FEATURE_FW        TXT_HELP__FEATURE  "=<ingress_vlan>"  "\n"  \
                                         "  Name of a FW feature.\n"
+                                                                               
+#define TXT_OPT__FEATURE_EL_FW_EL       TXT_HELP__FEATURE  "=<feature_name>"
+#define TXT_OPTDESCR__FEATURE_FW_EL     TXT_HELP__FEATURE  "=<ingress_vlan>"  "\n"  \
+                                        "  Name of a FW feature.\n"
 
 #define TXT_OPT__FEATURE_DEMO           TXT_HELP__FEATURE  "=<feature_name>"
 #define TXT_OPTDESCR__FEATURE_DEMO      TXT_HELP__FEATURE  "=<L2_bridge_simple>"  "\n"  \
@@ -903,6 +915,29 @@
 #define TXT_OPTDESCR__DBG_TO_DBGFILE    TXT_HELP__DBG_TO_DBGFILE  "=<"  TXT_OPTARGS__ON_OFF  ">"  "\n"  \
                                         "  Commands libfci_cli daemon to enable/disable printing of debug messages into debugfile. \n"
 
+#define TXT_OPT__ELEMENT                TXT_HELP__ELEMENT  "=<element_name>"
+#define TXT_OPTDESCR__ELEMENT           TXT_HELP__ELEMENT  "=<br_accept>"  "\n"   \
+                                        "  Name of the requested element.\n" 
+
+#define TXT_OPT__ELEMENT_GROUP          TXT_HELP__ELEMENT_GROUP  "=<group_name|group_ID>"
+#define TXT_OPTDESCR__ELEMENT_GROUP     TXT_HELP__ELEMENT_GROUP  "=<"  TXT_FWFEAT_EL_GROUP__CONFIG  "|2>"  "\n"   \
+                                        "  Specify FW feature element group.\n"  \
+                                        "  Command will search for the target FW feature element only within the specified element group.\n"  \
+                                        "  Groups:\n"  \
+                                        "    "  TXT_FWFEAT_EL_GROUP__DEFAULT  " : search in all available groups \n"  \
+                                        "    "  TXT_FWFEAT_EL_GROUP__CONFIG   "  : search only in configuration elements group \n"  \
+                                        "    "  TXT_FWFEAT_EL_GROUP__STATS    "   : search only in statistics elements group \n"
+
+#define TXT_OPT__UNIT_SIZE              TXT_HELP__UNIT_SIZE  "=<1|2|4>"
+#define TXT_OPTDESCR__UNIT_SIZE         TXT_HELP__UNIT_SIZE  "=<1|2|4>"  "\n"   \
+                                        "  Bytesize of element's data unit. \n" \
+                                        "  See description of FW feature elements (or libfci_cli printout) to learn \n" \
+                                        "  what is the correct unit size of data for any given FW feature element. \n"
+ 
+#define TXT_OPT__PAYLOAD                TXT_HELP__PAYLOAD  "=<list_of_values>"
+#define TXT_OPTDESCR__PAYLOAD           TXT_HELP__PAYLOAD  "=<"  "0,5,20,... | 0x00,0x05,0x14..."  ">"  "\n"   \
+                                        "  Comma seperated list of values. These values will serve as payload of some command.\n"
+
 
 
 
@@ -910,7 +945,7 @@
     Sanity check for opt help texts. When new opt is added, create a help text for the opt and remove its symbol from here.
     And don't forget to check the pairing! ^_^
 */
-#if (defined(OPT_125_TXT_HELP) || defined(OPT_126_TXT_HELP) || defined(OPT_127_TXT_HELP) || defined(OPT_128_TXT_HELP) || defined(OPT_129_TXT_HELP) || \
+#if (defined(OPT_129_TXT_HELP) || \
      defined(OPT_130_TXT_HELP) || defined(OPT_131_TXT_HELP) || defined(OPT_132_TXT_HELP) || defined(OPT_133_TXT_HELP) || defined(OPT_134_TXT_HELP) || \
      defined(OPT_135_TXT_HELP) || defined(OPT_136_TXT_HELP) || defined(OPT_137_TXT_HELP) || defined(OPT_138_TXT_HELP) || defined(OPT_139_TXT_HELP) || \
      defined(OPT_140_TXT_HELP) || defined(OPT_141_TXT_HELP) || defined(OPT_142_TXT_HELP) || defined(OPT_143_TXT_HELP) || defined(OPT_144_TXT_HELP) || \
@@ -1990,6 +2025,58 @@ static const char* txt_help_fwfeat_set[] =
     NULL
 };
 
+static const char* txt_help_fwfeat_el_print[] =
+{
+    TXT_DECOR_CMD,
+    ""    "[1] fwfeat-el-print"   "   ",
+    "<"   TXT_OPT__FEATURE_FW     ">  ",
+    "["   TXT_OPT__ELEMENT_GROUP  "]  ",
+    "\n",
+    ""    "[2] fwfeat-el-print"   "   ",
+    "<"   TXT_OPT__FEATURE_FW     ">  ",
+    "<"   TXT_OPT__ELEMENT        ">  ",
+    "["   TXT_OPT__ELEMENT_GROUP  "]  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "[1] Print all elements of a FW feature.",
+    "\n",
+    ""    "[2] Print the selected element of a FW feature.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__FEATURE_FW,
+    TXT_OPTDESCR__ELEMENT,
+    TXT_OPTDESCR__ELEMENT_GROUP,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_fwfeat_el_set[] =
+{
+    TXT_DECOR_CMD,
+    ""    "fwfeat-el-set"         "   ",
+    "<"   TXT_OPT__FEATURE_FW     ">  ",
+    "<"   TXT_OPT__ELEMENT        ">  ",
+    "<"   TXT_OPT__UNIT_SIZE      ">  ", 
+    "<"   TXT_OPT__PAYLOAD        ">  ",
+    "["   TXT_OPT__POSITION_FWFEAT_EL_SET "]  ",
+    "["   TXT_OPT__ELEMENT_GROUP  "]  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Set data of a FW feature element.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__FEATURE_FW,
+    TXT_OPTDESCR__ELEMENT,
+    TXT_OPTDESCR__UNIT_SIZE,
+    TXT_OPTDESCR__PAYLOAD,
+    TXT_OPTDESCR__POSITION_FWFEAT_EL_SET,
+    TXT_OPTDESCR__ELEMENT_GROUP,
+    "\n",
+    
+    NULL
+};
+
 static const char* txt_help_qos_que_print[] =
 {
     TXT_DECOR_CMD,
diff --git a/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.c b/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.c
index 16ccf04..49cf6c3 100644
--- a/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.c
+++ b/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.c
@@ -1,5 +1,5 @@
 /* =========================================================================
- *  Copyright 2020-2021 NXP
+ *  Copyright 2020-2022 NXP
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -431,6 +431,16 @@ static const char *const txt_pol_flow_types32[] =
 };
 #define POL_FLOW_TYPES32_LN  CALC_LN(txt_pol_flow_types32) 
 
+/* based on element order of 'fpp_fw_feature_element_type_t' */
+/* WARNING: elements of 'fpp_fw_feature_element_type_t' are bitmasks, and thus CANNOT directly index this array */
+static const char *const txt_fwfeat_el_group[] = 
+{
+    TXT_FWFEAT_EL_GROUP__DEFAULT,
+    TXT_FWFEAT_EL_GROUP__CONFIG,
+    TXT_FWFEAT_EL_GROUP__STATS
+};
+#define FWFEAT_EL_GROUP_LN  CALC_LN(txt_fwfeat_el_group) 
+
 /* ==== PRIVATE FUNCTIONS ================================================== */
 
 static int txt2value(uint8_t *p_rtn_value, const char *p_txt,
@@ -797,6 +807,15 @@ int cli_txt2value_pol_flow_type32(uint8_t* p_rtn_value, const char* p_txt)
     return txt2value(p_rtn_value, p_txt, txt_pol_flow_types32, POL_FLOW_TYPES32_LN, 0u);
 }
 
+const char* cli_value2txt_fwfeat_el_group(uint8_t value)
+{
+    return ((FWFEAT_EL_GROUP_LN <= value) ? (TXT_INVALID_ITEM) : (txt_fwfeat_el_group[value]));
+}
+int cli_txt2value_fwfeat_el_group(uint8_t* p_rtn_value, const char* p_txt)
+{
+    return txt2value(p_rtn_value, p_txt, txt_fwfeat_el_group, FWFEAT_EL_GROUP_LN, 0u);
+}
+
 
 /* ==== TESTMODE constants ================================================= */
 
diff --git a/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.h b/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.h
index 4f8c168..14795b4 100644
--- a/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.h
+++ b/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.h
@@ -390,11 +390,11 @@ extern const uint8_t SPD_ACTIONS__MAX;
 #define TXT_POL_FLOW_TYPE2__SPORT       TXT_MATCH_RULE__SPORT
 #define TXT_POL_FLOW_TYPE2__DPORT       TXT_MATCH_RULE__DPORT
 
-#ifdef PFE_CFG_TARGET_OS_AUTOSAR
-#define ETH_43_PFE_START_SEC_CODE
-#include "Eth_43_PFE_MemMap.h"
-#endif /* PFE_CFG_TARGET_OS_AUTOSAR */
-
+/* based on element order of 'fpp_fw_feature_element_type_t' */
+/* WARNING: elements of 'fpp_fw_feature_element_type_t' are bitmasks, and thus CANNOT directly index this array */
+#define TXT_FWFEAT_EL_GROUP__DEFAULT    "DEFAULT"
+#define TXT_FWFEAT_EL_GROUP__CONFIG     "CONFIG"
+#define TXT_FWFEAT_EL_GROUP__STATS      "STATS"
 
 /* ==== PUBLIC FUNCTIONS =================================================== */
 
@@ -482,12 +482,9 @@ int         cli_txt2value_pol_flow_type2(uint8_t* p_rtn_value, const char* p_txt
 const char* cli_value2txt_pol_flow_type32(uint8_t value);
 int         cli_txt2value_pol_flow_type32(uint8_t* p_rtn_value, const char* p_txt);
 
-/* ========================================================================= */
-
+const char* cli_value2txt_fwfeat_el_group(uint8_t value);
+int         cli_txt2value_fwfeat_el_group(uint8_t* p_rtn_value, const char* p_txt);
 
-#ifdef PFE_CFG_TARGET_OS_AUTOSAR
-#define ETH_43_PFE_STOP_SEC_CODE
-#include "Eth_43_PFE_MemMap.h"
-#endif /* PFE_CFG_TARGET_OS_AUTOSAR */
+/* ========================================================================= */
 
 #endif
diff --git a/sw/libfci_cli/src/libfci_cli_def_opts.h b/sw/libfci_cli/src/libfci_cli_def_opts.h
index 7455d4c..d45dce5 100644
--- a/sw/libfci_cli/src/libfci_cli_def_opts.h
+++ b/sw/libfci_cli/src/libfci_cli_def_opts.h
@@ -1571,6 +1571,53 @@ typedef enum cli_opt_incompat_grp_tt {
         OPT_124_TXT_HELP
 
 
+#define OPT_125_ENUM_NAME        OPT_ELEMENT
+#define OPT_125_OPT_PARSE        opt_parse_element
+#define OPT_125_HAS_ARG          y
+#define OPT_125_INCOMPAT_GRPS    OPT_GRP_NONE
+#define OPT_125_CLI_SHORT_CODE   OPT_AUTO_CODE
+#define OPT_125_CLI_LONG_TXT_A   "el"
+#define OPT_125_CLI_LONG_TXT_B   "element"
+#define OPT_125_TXT_HELP         "--el|--element"
+#define                          TXT_HELP__ELEMENT \
+        OPT_125_TXT_HELP
+
+
+#define OPT_126_ENUM_NAME        OPT_ELEMENT_GROUP
+#define OPT_126_OPT_PARSE        opt_parse_element_group
+#define OPT_126_HAS_ARG          y
+#define OPT_126_INCOMPAT_GRPS    OPT_GRP_NONE
+#define OPT_126_CLI_SHORT_CODE   OPT_AUTO_CODE
+#define OPT_126_CLI_LONG_TXT_A   "elgrp"
+#define OPT_126_CLI_LONG_TXT_B   "el-group"
+#define OPT_126_TXT_HELP         "--elgrp|--el-group"
+#define                          TXT_HELP__ELEMENT_GROUP \
+        OPT_126_TXT_HELP
+
+
+#define OPT_127_ENUM_NAME        OPT_UNIT_SIZE
+#define OPT_127_OPT_PARSE        opt_parse_unit_size
+#define OPT_127_HAS_ARG          y
+#define OPT_127_INCOMPAT_GRPS    OPT_GRP_NONE
+#define OPT_127_CLI_SHORT_CODE   OPT_AUTO_CODE
+#define OPT_127_CLI_LONG_TXT_A   "us"
+#define OPT_127_CLI_LONG_TXT_B   "unit_size"
+#define OPT_127_TXT_HELP         "--us|--unit-size"
+#define                          TXT_HELP__UNIT_SIZE \
+        OPT_127_TXT_HELP
+
+
+#define OPT_128_ENUM_NAME        OPT_PAYLOAD
+#define OPT_128_OPT_PARSE        opt_parse_payload
+#define OPT_128_HAS_ARG          y
+#define OPT_128_INCOMPAT_GRPS    OPT_GRP_NONE
+#define OPT_128_CLI_SHORT_CODE   OPT_AUTO_CODE
+#define OPT_128_CLI_LONG_TXT_A   "payload"
+#define OPT_128_TXT_HELP         "--payload"
+#define                          TXT_HELP__PAYLOAD \
+        OPT_128_TXT_HELP
+
+
 
 
 /* OPT_LAST (keep this at the bottom of the cli option definition list) */
diff --git a/sw/libfci_cli/src/libfci_cli_parser.c b/sw/libfci_cli/src/libfci_cli_parser.c
index 2c9aee4..85995c0 100644
--- a/sw/libfci_cli/src/libfci_cli_parser.c
+++ b/sw/libfci_cli/src/libfci_cli_parser.c
@@ -96,6 +96,7 @@ static int cli_txt2num_i32(int32_t* p_rtn_num, const char* p_txt, int base,
 static int cli_txt2bitset32(uint32_t* p_rtn_bitset, const char* p_txt, const cb_txt2value_t p_cb_txt2value);
 static int cli_txt2zprobs(uint8_t* p_rtn_zprobs, const char* p_txt);
 static int cli_txt2sch_ins(struct sch_in_tt* p_rtn_struct_with_sch_ins, const char* p_txt);
+static int txt2num_payload(uint8_t* p_rtn_payload, uint8_t* p_rtn_count, uint8_t max_count, uint8_t unit_size, const char* p_txt);
 
 static int cli_txt2mac(uint8_t* p_rtn_mac, const char* p_txt);
 static int cli_txt2ip(bool* p_rtn_is6, uint32_t* p_rtn_ip, const char* p_txt);
@@ -2100,6 +2101,103 @@ static int opt_dbg_to_dbgfile(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_op
     return (rtn);
 }
 
+static int opt_parse_element(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->element_name.is_valid);
+    char* p_txt      =  (p_rtn_cmdargs->element_name.txt);
+    
+    rtn = cli_txtcpy_feature_name(p_txt, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_element_group(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->element_group.is_valid);
+    uint8_t* p_value = &(p_rtn_cmdargs->element_group.value);
+    
+    rtn = cli_txt2value_fwfeat_el_group(p_value, p_txt_optarg);
+    if (CLI_OK != rtn)
+    {
+        rtn = cli_txt2num_u8(p_value, p_txt_optarg, BASE_DEC, 0u, UINT8_MAX);
+    }
+
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_unit_size(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->unit_size.is_valid);
+    uint8_t* p_value = &(p_rtn_cmdargs->unit_size.value);
+    
+    rtn = cli_txt2num_u8(p_value, p_txt_optarg, BASE_DEC, 0u, UINT8_MAX);
+
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+
+}
+
+static const char* p_txt_optarg_payload = NULL;
+static int opt_parse_payload(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    
+    if (NULL == p_txt_optarg_payload)
+    {
+        /*
+         * NOTE:
+         *   To properly parse 'values' opt, the algorithm needs to know unit_size (that is another opt).
+         *   However, opts can be parsed in arbitrary order.
+         *   Therefore, during the 1st pass (normal opt parsing), just save ptr to associated optarg input text.
+         *   After normal opt parsing is done, this function will be called by the main parser for the 2nd time.
+         *   During this 2nd time, input will be properly parsed.
+         */
+        p_txt_optarg_payload = p_txt_optarg;
+        rtn = CLI_OK;
+    }
+    else
+    {
+        /* It is assumed this code runs after all opts were already processed during normal opt parsing. */
+        
+        bool* p_is_valid = &(p_rtn_cmdargs->payload.is_valid);
+        uint8_t* p_arr   =  (p_rtn_cmdargs->payload.arr);
+        uint8_t* p_count = &(p_rtn_cmdargs->payload.count);
+        
+        if (p_rtn_cmdargs->unit_size.is_valid)
+        {
+            rtn = txt2num_payload(p_arr, p_count,
+                                  (PAYLOAD_LN / (p_rtn_cmdargs->unit_size.value)),
+                                  (p_rtn_cmdargs->unit_size.value),
+                                  p_txt_optarg_payload);
+        }
+        
+        set_if_rtn_ok(rtn, p_is_valid);
+    }
+    
+    return (rtn);
+}
+
 
 
 
@@ -2619,6 +2717,94 @@ static int cli_txt2sch_ins(struct sch_in_tt* p_rtn_struct_with_sch_ins, const ch
     return parse_substrings(p_rtn_struct_with_sch_ins, p_txt, NULL, loop_sch_ins, SCH_INS_LN);
 }
 
+/* ==== PRIVATE FUNCTIONS : cli_txt2num_values ============================= */
+
+/*
+ * Conversion of payload values for FW feature elements is a bit specific (depends on other opts, returns multiple information).
+ * Due to these peculiarities, it has its own loop and does not use the generic 'parse_substings()' loop system.
+ */
+static int txt2num_payload(uint8_t* p_rtn_payload, uint8_t* p_rtn_count, uint8_t max_count, uint8_t unit_size, const char* p_txt)
+{    
+    assert(NULL != p_rtn_payload);
+    assert(NULL != p_rtn_count);
+    assert(NULL != p_txt);    
+    
+    int rtn = CLI_ERR;
+    char* p_txt_mutable = NULL;
+    int base;
+    
+    
+    /* malloc a local modifiable copy of 'p_txt', because even if 'p_txt' was modifiable, it could still point to a literal --> problems galore */
+    {
+        const size_t ln = (strlen(p_txt) + 1u);
+        p_txt_mutable = malloc(ln * sizeof(char));
+        if (NULL == p_txt_mutable)
+        {
+            rtn = CLI_ERR_INVPTR;
+        }
+        else
+        {
+            memcpy(p_txt_mutable, p_txt, ln);
+            rtn = CLI_OK;  /* greenlight execution of the next sub-block */
+        }
+    }
+    
+    /* run the target loop */
+    if (CLI_OK == rtn)
+    {
+        uint8_t i = UINT8_MAX;  /* WARNING: intentional use of owf behavior */
+        char* p_txt_token_next = strtok(p_txt_mutable, ",");
+       
+        /* loop_body */
+        while ((max_count > (++i)) && (CLI_OK == rtn) && (NULL != p_txt_token_next))
+        {
+            /* some strtok() implementations improperly react on "3rd party" modifications of the CURRENT substring */
+            /* work-around is to use the "current - 1" substring */
+            char* p_txt_token = p_txt_token_next;
+            p_txt_token_next = strtok(NULL, ",");
+            
+            /* parse the substring based on unit size ; write parsed results directly into rtn buffer */
+            char* p_txt_hex_token = strstr(p_txt_token, "0x");
+            base = (p_txt_hex_token == p_txt_token) ? (BASE_HEX) : (BASE_DEC);
+            switch(unit_size)
+            {
+                case 1u:
+                    rtn = cli_txt2num_u8((p_rtn_payload + i), p_txt_token, base, 0, UINT8_MAX);
+                break;
+                
+                case 2u:
+                    rtn = cli_txt2num_u16(((uint16_t*)p_rtn_payload + i), p_txt_token, base, 0, UINT16_MAX);
+                break;
+                
+                case 4u:
+                    rtn = cli_txt2num_u32(((uint32_t*)p_rtn_payload + i), p_txt_token, base, 0, UINT32_MAX);
+                break;
+                
+                default:
+                    rtn = CLI_ERR_INVARG;
+                break;
+            }
+        }
+        
+        /* local post-loop check that there are no more substrings left */
+        if ((max_count <= i) && (NULL != p_txt_token_next))
+        {
+            rtn = CLI_ERR_INVARG;
+        }
+        
+        /* return count of data units that are in rtn buffer */
+        *p_rtn_count = i;
+    }
+    
+    /* free the malloc'd memory (do not hide behind rtn check) */
+    if (NULL != p_txt_mutable)  /* better safe than sorry; some C-runtimes crash when NULL ptr is freed */
+    {
+        free(p_txt_mutable);
+    }
+    
+    return (rtn);
+}
+
 /* ==== PRIVATE FUNCTIONS : txt2mac ===================================== */
 
 #define T2M_DELIMS_LN  (MAC_BYTES_LN - 1u)  /* there is no delimiter after the last byte of the mac address */
@@ -3930,6 +4116,13 @@ static int opts_parse(cli_cmdargs_t* p_rtn_cmdargs, char* p_txt_vec[], int vec_l
         rtn = CLI_ERR_NONOPT;
     }
     
+    /* execute 2nd pass for opts which depend on other opts */
+    if (NULL != p_txt_optarg_payload)
+    {
+        p_txt_opt = TXT_HELP__PAYLOAD;
+        rtn = opt_parse_payload(p_rtn_cmdargs, p_txt_optarg_payload);
+    }
+    
     /* reset 'getopt()' fnc family internal static variables (do not hide behind rtn check) */
     /* WARNING: This hack is crucial in order to ensure that 'getopt()' fnc family behaves correctly each time new input txt vector is scanned. */
     while(-1 != getopt_long(vec_ln, p_txt_vec, p_txt_shortopts, p_longopts, NULL)) { /* empty */ };
@@ -4263,6 +4456,17 @@ static int cmd_execute(cli_cmd_t cmd, const cli_cmdargs_t* p_cmdargs)
                                 TXT_ERR_INDENT "Use fwfeat-print to see a list of all FW features.\n";
             break;
             
+            case FPP_ERR_FW_FEATURE_ELEMENT_NOT_FOUND:
+                p_txt_errname = TXT_ERR_NAME(FPP_ERR_FW_FEATURE_ELEMENT_NOT_FOUND);
+                p_txt_errmsg  = TXT_ERR_INDENT "Requested FW feature element not found.\n"
+                                TXT_ERR_INDENT "Is the FW feature element name correct?\n";
+            break;
+
+            case FPP_ERR_FW_FEATURE_ELEMENT_READ_ONLY:
+                p_txt_errname = TXT_ERR_NAME(FPP_ERR_FW_FEATURE_ELEMENT_READ_ONLY);
+                p_txt_errmsg  = TXT_ERR_INDENT "Requested FW feature element is read only.\n";
+            break;
+
             case FPP_ERR_RT_ENTRY_ALREADY_REGISTERED:
                 p_txt_errname = TXT_ERR_NAME(FPP_ERR_RT_ENTRY_ALREADY_REGISTERED);
                 p_txt_errmsg  = TXT_ERR_INDENT "Requested route is already registered.\n";
diff --git a/sw/libfci_cli/src/libfci_cli_parser.h b/sw/libfci_cli/src/libfci_cli_parser.h
index 5e36621..a24aa68 100644
--- a/sw/libfci_cli/src/libfci_cli_parser.h
+++ b/sw/libfci_cli/src/libfci_cli_parser.h
@@ -41,7 +41,6 @@
 void cli_print_app_version(bool is_verbose);
 
 int cli_parse_and_execute(char* pp_txtarr[], int arrln);
-
 /* ========================================================================= */
 
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
diff --git a/sw/libfci_cli/src/libfci_demo/demo_fwfeat.c b/sw/libfci_cli/src/libfci_demo/demo_fwfeat.c
index fbcd0d4..72cb3a8 100644
--- a/sw/libfci_cli/src/libfci_demo/demo_fwfeat.c
+++ b/sw/libfci_cli/src/libfci_demo/demo_fwfeat.c
@@ -1,5 +1,5 @@
 /* =========================================================================
- *  Copyright 2020-2021 NXP
+ *  Copyright 2020-2022 NXP
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -38,35 +38,34 @@
 #include "fpp.h"
 #include "fpp_ext.h"
 #include "libfci.h"
- 
+
 #include "demo_common.h"
 #include "demo_fwfeat.h"
- 
- 
+
 /* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
  
  
 /*
  * @brief       Use FCI calls to get configuration data of a requested FW feature
  *              from PFE. Identify the FW feature by its name.
- * @param[in]   p_cl         FCI client
- * @param[out]  p_rtn_fwfeat Space for data from PFE.
- * @param[in]   p_name       Name of the requested FW feature.
- *                           Names of FW features are hardcoded.
- *                           Use FPP_ACTION_QUERY+FPP_ACTION_QUERY_CONT to get a list of
- *                           available FW features (and their names) from PFE.
- *                           See demo_fwfeat_print_all().
+ * @param[in]   p_cl            FCI client
+ * @param[out]  p_rtn_fwfeat    Space for data from PFE.
+ * @param[in]   p_feature_name  Name of the requested FW feature.
+ *                              Names of FW features are hardcoded.
+ *                              Use FPP_ACTION_QUERY+FPP_ACTION_QUERY_CONT to get a list of
+ *                              available FW features (and their names) from PFE.
+ *                              See demo_fwfeat_print_all().
  * @return      FPP_ERR_OK : The requested FW feature was found.
  *                           A copy of its configuration data was stored into p_rtn_fwfeat.
  *              other      : Some error occurred (represented by the respective error code).
  *                           No data copied.
  */
 int demo_fwfeat_get_by_name(FCI_CLIENT* p_cl, fpp_fw_features_cmd_t* p_rtn_fwfeat, 
-                            const char* p_name)
+                            const char* p_feature_name)
 {
     assert(NULL != p_cl);
     assert(NULL != p_rtn_fwfeat);
-    assert(NULL != p_name);
+    assert(NULL != p_feature_name);
     
     int rtn = FPP_ERR_INTERNAL_FAILURE;
     
@@ -81,7 +80,7 @@ int demo_fwfeat_get_by_name(FCI_CLIENT* p_cl, fpp_fw_features_cmd_t* p_rtn_fwfea
                         &reply_length, (unsigned short*)(&reply_from_fci));
     
     /* query loop (with a search condition) */
-    while ((FPP_ERR_OK == rtn) && (strcmp(p_name, reply_from_fci.name)))
+    while ((FPP_ERR_OK == rtn) && (strcmp(p_feature_name, reply_from_fci.name)))
     {
         cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
         rtn = fci_query(p_cl, FPP_CMD_FW_FEATURE,
@@ -101,31 +100,105 @@ int demo_fwfeat_get_by_name(FCI_CLIENT* p_cl, fpp_fw_features_cmd_t* p_rtn_fwfea
 }
  
  
+/*
+ * @brief       Use FCI calls to get data of a requested FW feature element
+ *              from PFE. Identify the element by name of its parent FW feature and 
+ *              by name of the target element.
+ * @param[in]   p_cl             FCI client
+ * @param[out]  p_rtn_fwfeat_el  Space for data from PFE.
+ * @param[in]   p_feature_name   Name of the requested FW feature.
+ *                               Names of FW features are hardcoded.
+ *                               Use FPP_ACTION_QUERY+FPP_ACTION_QUERY_CONT to get a list of
+ *                               available FW features (and their names) from PFE.
+ *                               See demo_fwfeat_print_all().
+ * @param[in]   p_element_name   Name of the requested FW feature element.
+ *                               Names of FW feature elements are hardcoded.
+ *                               Use FPP_ACTION_QUERY+FPP_ACTION_QUERY_CONT to get a list of
+ *                               available FW feature elements from PFE.
+ * @param[in]   group            Element group where to search.
+ *                               Groups are described in struct definition of
+ *                               fpp_fw_features_element_cmd_t.
+ * @param[in]   index            Element can have an array of data units. This parameter is
+ *                               an index that specifies where to start querying within 
+ *                               element's data array. Quried data will be in the .payload.
+ * @return      FPP_ERR_OK : The requested FW feature element was found.
+ *                           A copy of its data was stored into p_rtn_fwfeat_el.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No data copied.
+ */
+int demo_fwfeat_el_get_by_name(FCI_CLIENT* p_cl,
+                               fpp_fw_features_element_cmd_t* p_rtn_fwfeat_el,
+                               const char* p_feature_name, const char* p_element_name, 
+                               uint8_t group, uint8_t index)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_feature_name);
+    assert(NULL != p_element_name);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_fw_features_element_cmd_t cmd_to_fci = {0};
+    fpp_fw_features_element_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    cmd_to_fci.group = group;
+    cmd_to_fci.index = index;
+    rtn = set_text((cmd_to_fci.fw_feature_name), p_feature_name, 
+                   (FPP_FEATURE_NAME_SIZE + 1));
+    
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = set_text((cmd_to_fci.element_name), p_element_name, 
+                       (FPP_FEATURE_NAME_SIZE + 1));
+    }
+    
+    /* do the query (get the element directly; no need for a loop) */
+    if (FPP_ERR_OK == rtn)
+    {
+        cmd_to_fci.action = FPP_ACTION_QUERY;
+        rtn = fci_query(p_cl, FPP_CMD_FW_FEATURE_ELEMENT,
+                        sizeof(fpp_fw_features_element_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    }
+    
+    /* if a query is successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_fwfeat_el = reply_from_fci;
+    }
+
+    print_if_error(rtn, "demo_fwfeat_el_get_by_name() failed!");
+
+    return (rtn);
+}
+ 
+ 
 /* ==== PUBLIC FUNCTIONS : use FCI calls to update data in PFE ============= */
  
  
 /*
  * @brief      Use FCI calls to enable/disable a target FW feature in PFE.
- * @param[in]  p_cl     FCI client
- * @param[in]  p_name   Name of a FW feature.
- *                      Names of FW features are hardcoded.
- *                      Use FPP_ACTION_QUERY+FPP_ACTION_QUERY_CONT to get a list of
- *                      available FW features (and their names) from PFE.
- *                      See demo_fwfeat_print_all().
- * @param[in]  enable   Request to set/unset the FW feature.
+ * @param[in]  p_cl            FCI client
+ * @param[in]  p_feature_name  Name of a FW feature.
+ *                             Names of FW features are hardcoded.
+ *                             Use FPP_ACTION_QUERY+FPP_ACTION_QUERY_CONT to get a list of
+ *                             available FW features (and their names) from PFE.
+ *                             See demo_fwfeat_print_all().
+ * @param[in]  enable          Request to set/unset the FW feature.
  * @return     FPP_ERR_OK : FW feature was successfully enabled/disabled in PFE.
  *             other      : Some error occurred (represented by the respective error code).
  */
-int demo_fwfeat_set(FCI_CLIENT* p_cl, const char* p_name, bool enable)
+int demo_fwfeat_set(FCI_CLIENT* p_cl, const char* p_feature_name, bool enable)
 {
     assert(NULL != p_cl);
-    assert(NULL != p_name);
+    assert(NULL != p_feature_name);
     
     int rtn = FPP_ERR_INTERNAL_FAILURE;
     fpp_fw_features_cmd_t cmd_to_fci = {0};
     
     /* prepare data */
-    rtn = set_text((cmd_to_fci.name), p_name, (FPP_FEATURE_NAME_SIZE + 1));
+    rtn = set_text((cmd_to_fci.name), p_feature_name, (FPP_FEATURE_NAME_SIZE + 1));
     if (FPP_ERR_OK == rtn)
     {
         cmd_to_fci.val = enable;  /* NOTE: Implicit cast from bool to uintX_t */
@@ -145,6 +218,126 @@ int demo_fwfeat_set(FCI_CLIENT* p_cl, const char* p_name, bool enable)
 }
  
  
+/*
+ * @brief          Use FCI calls to update data of a FW feature element in PFE.
+ * @param[in]      p_cl         FCI client
+ * @param[in,out]  p_fwfeat_el  Local data struct which represents new data of
+ *                              the target FW feature element.
+ *                              It is assumed that the struct contains a valid data of some 
+ *                              FW feature element, just modified via some fwfeat_el setters.
+ * @return        FPP_ERR_OK : Data of the target FW feature element were
+ *                             successfully updated in PFE.
+ *                             The local data struct was automatically updated with 
+ *                             readback data from PFE.
+ *                other      : Some error occurred (represented by the respective error code).
+ *                             The local data struct was not updated.
+ */
+int demo_fwfeat_el_set(FCI_CLIENT* p_cl, fpp_fw_features_element_cmd_t* p_fwfeat_el)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_fwfeat_el);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_fw_features_element_cmd_t cmd_to_fci = *p_fwfeat_el;
+    
+    /* send data */
+    cmd_to_fci.action = FPP_ACTION_UPDATE;
+    rtn = fci_write(p_cl, FPP_CMD_FW_FEATURE_ELEMENT,
+                    sizeof(fpp_fw_features_element_cmd_t), (unsigned short*)(&cmd_to_fci));
+    
+    /* read back and update caller data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_fwfeat_el_get_by_name(p_cl, p_fwfeat_el,
+                                          (p_fwfeat_el->fw_feature_name),
+                                          (p_fwfeat_el->element_name),
+                                          (p_fwfeat_el->group),
+                                          (p_fwfeat_el->index));
+    }
+    
+    print_if_error(rtn, "demo_fwfeat_el_set() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+/*
+ * @defgroup    localdata_fwfeat_el  [localdata_fwfeat_el]
+ * @brief:      Functions marked as [localdata_fwfeat_el] access only local data. 
+ *              No FCI calls are made.
+ * @details:    These functions have a parameter p_fwfeat_el (a struct with element data).
+ *              Initial data for p_fwfeat_el can be obtained via demo_fwfeat_el_get_by_name().
+ */
+ 
+ 
+/*
+ * @brief          Set the element group of a FW feature element.
+ * @details        [localdata_fwfeat_el]
+ *                 This setter should be rarely needed. If FW element data were obtained
+ *                 from PFE via demo_fwfeat_el_get_by_name(), then the data should already 
+ *                 have a correct group set.
+ * @param[in,out]  p_fwfeat_el  Local data to be modified.
+ * @param[in]      group        Element group. For explanation about element groups, see
+ *                              description of fpp_fw_features_element_cmd_t.
+ */
+void demo_fwfeat_el_set_group(fpp_fw_features_element_cmd_t* p_fwfeat_el, uint8_t group)
+{
+    assert(NULL != p_fwfeat_el);
+    p_fwfeat_el->group = group;
+}
+ 
+ 
+/*
+ * @brief          Set the index of a FW feature element.
+ * @details        [localdata_fwfeat_el]
+ *                 What is index:
+ *                   [*] FW feature element (as stored in PFE firmware) can have
+ *                       an array of data units.
+ *                   [*] FCI command allows querying or updating a particular item from 
+ *                       such array by specifying index of the target item.
+ *                   [*] A consecutive series of array items can be queried or updated by 
+ *                       a single FCI command. The index specifies starting point for such 
+ *                       query/update operation.
+ * @param[in,out]  p_fwfeat_el  Local data to be modified.
+ * @param[in]      index        Index into element's data array in PFE.
+ */
+void demo_fwfeat_el_set_index(fpp_fw_features_element_cmd_t* p_fwfeat_el, uint8_t index)
+{
+    assert(NULL != p_fwfeat_el);
+    p_fwfeat_el->index = index;
+}
+ 
+ 
+/*
+ * @brief          Set the payload of a FW feature element.
+ * @details        [localdata_fwfeat_el]
+ * @param[in,out]  p_fwfeat_el Local data to be modified.
+ * @param[in]      p_payload   New payload.
+ * @param[in]      count       Count of data units in the new payload.
+ * @param[in]      unit_size   Bytesize of a data unit.
+ */
+int demo_fwfeat_el_set_payload(fpp_fw_features_element_cmd_t* p_fwfeat_el,
+                               const uint8_t* p_payload, uint8_t count, uint8_t unit_size)
+{
+    assert(NULL != p_fwfeat_el);
+    assert(NULL != p_payload);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    if (sizeof(p_fwfeat_el->payload) >= (count * unit_size))
+    {
+        p_fwfeat_el->count = count;
+        p_fwfeat_el->unit_size = unit_size;
+        memcpy(p_fwfeat_el->payload, p_payload, (count * unit_size));
+        
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
 /* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
 /*
  * @defgroup    localdata_fwfeat  [localdata_fwfeat]
@@ -226,6 +419,90 @@ fpp_fw_feature_flags_t demo_fwfeat_ld_get_flags(const fpp_fw_features_cmd_t* p_f
 }
  
  
+ 
+ 
+/*
+ * @brief      Query the name of a FW feature element.
+ * @details    [localdata_fwfeat_el]
+ * @param[in]  p_fwfeat_el  Local data to be queried.
+ * @return     Name of the FW feature element.
+ */
+const char* demo_fwfeat_el_ld_get_name(const fpp_fw_features_element_cmd_t* p_fwfeat_el)
+{
+    assert(NULL != p_fwfeat_el);
+    return (p_fwfeat_el->element_name);
+}
+ 
+ 
+/*
+ * @brief      Query the name of element's parent FW feature.
+ * @details    [localdata_fwfeat_el]
+ * @param[in]  p_fwfeat_el  Local data to be queried.
+ * @return     Name of the element's parent FW feature.
+ */
+const char* demo_fwfeat_el_ld_get_feat_name(const fpp_fw_features_element_cmd_t* p_fwfeat_el)
+{
+    assert(NULL != p_fwfeat_el);
+    return (p_fwfeat_el->fw_feature_name);
+}
+ 
+ 
+/*
+ * @brief      Query the element group of a FW feature element.
+ * @details    [localdata_fwfeat_el]
+ * @param[in]  p_fwfeat_el  Local data to be queried.
+ * @return     Element group. For explanation about element groups, see
+ *             description of fpp_fw_features_element_cmd_t.
+ */
+uint8_t demo_fwfeat_el_ld_get_group(const fpp_fw_features_element_cmd_t* p_fwfeat_el)
+{
+    assert(NULL != p_fwfeat_el);
+    return (p_fwfeat_el->group);
+}
+ 
+ 
+/*
+ * @brief      Query the index of a FW feature element.
+ * @details    [localdata_fwfeat_el]
+ *             What is index:
+ *               [*] FW feature element (as stored in PFE firmware) can have
+ *                   an array of data units.
+ *               [*] FCI command allows querying or updating a particular item from such array
+ *                   by specifying index of the target item.
+ *               [*] A consecutive series of array items can be queried or updated by a single
+ *                   FCI command. The index specifies starting point for such query/update
+ *                   operation.
+ * @param[in]  p_fwfeat_el  Local data to be queried.
+ * @return     index
+ */
+uint8_t demo_fwfeat_el_ld_get_index(const fpp_fw_features_element_cmd_t* p_fwfeat_el)
+{
+    assert(NULL != p_fwfeat_el);
+    return (p_fwfeat_el->index);
+}
+ 
+ 
+/*
+ * @brief       Query the payload of a FW feature element.
+ * @details     [localdata_fwfeat_el]
+ * @param[in]   p_fwfeat_el   Local data to be queried.
+ * @param[out]  pp_rtn_payload   Passback value. Pointer to payload data bytearray.
+ * @param[out]  p_rtn_count      Passback value. Count of data units in payload.
+ * @param[out]  p_rtn_unit_size  Passback value. Bytesize of a data unit.
+ */
+void demo_fwfeat_el_ld_get_payload(const fpp_fw_features_element_cmd_t* p_fwfeat_el,
+                                   const uint8_t** pp_rtn_payload, uint8_t* p_rtn_count,
+                                   uint8_t* p_rtn_unit_size)
+{
+    assert(NULL != p_fwfeat_el);
+    assert((NULL != pp_rtn_payload) && (NULL != p_rtn_count) && (NULL != p_rtn_unit_size));
+    
+    *pp_rtn_payload = p_fwfeat_el->payload;
+    *p_rtn_count = p_fwfeat_el->count;
+    *p_rtn_unit_size = p_fwfeat_el->unit_size;
+}
+ 
+ 
 /* ==== PUBLIC FUNCTIONS : misc ============================================ */
  
  
@@ -337,5 +614,158 @@ int demo_fwfeat_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count)
 }
  
  
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all available elements of a target FW feature
+ *             in PFE and execute a callback print function for each reported element.
+ * @param[in]  p_cl        FCI client
+ * @param[in]  p_cb_print  Callback print function.
+ *                         --> If the callback returns ZERO, then all is OK and 
+ *                             a next element is picked for a print process.
+ *                         --> If the callback returns NON-ZERO, then some problem is 
+ *                             assumed and this function terminates prematurely.
+ * @param[in]  p_feature_name  Name of the requested FW feature.
+ *                             Names of FW features are hardcoded.
+ *                             Use FPP_ACTION_QUERY+FPP_ACTION_QUERY_CONT to get a list of
+ *                             available FW features (and their names) from PFE.
+ *                             See demo_fwfeat_print_all().
+ * @param[in]  group           Element group where to search.
+ *                             Groups are described in struct definition of
+ *                             fpp_fw_features_element_cmd_t.
+ * @return     FPP_ERR_OK : Successfully iterated through all applicable elements of the
+ *                          target FW feature.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_fwfeat_el_print_all(FCI_CLIENT* p_cl, demo_fwfeat_el_cb_print_t p_cb_print, 
+                             const char* p_feature_name, uint8_t group)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    assert(NULL != p_feature_name);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_fw_features_element_cmd_t cmd_to_fci = {0};
+    fpp_fw_features_element_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    cmd_to_fci.group = group;
+    rtn = set_text((cmd_to_fci.fw_feature_name), p_feature_name, (FPP_FEATURE_NAME_SIZE + 1));
+    
+    /* do the query */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* start query process */
+        cmd_to_fci.action = FPP_ACTION_QUERY;
+        rtn = fci_query(p_cl, FPP_CMD_FW_FEATURE_ELEMENT,
+                        sizeof(fpp_fw_features_element_cmd_t),
+                        (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        
+        /* query loop */
+        while (FPP_ERR_OK == rtn)
+        {
+            rtn = p_cb_print(&reply_from_fci);
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+                rtn = fci_query(p_cl, FPP_CMD_FW_FEATURE_ELEMENT,
+                                sizeof(fpp_fw_features_element_cmd_t),
+                                (unsigned short*)(&cmd_to_fci),
+                                &reply_length, (unsigned short*)(&reply_from_fci));
+            }
+        }
+        
+        /* query loop runs till there are no more FW feature elements to report */
+        /* the following error is therefore OK and expected (it ends the query loop) */
+        if (FPP_ERR_FW_FEATURE_ELEMENT_NOT_FOUND == rtn)
+        {
+            rtn = FPP_ERR_OK;
+        }
+    }
+    print_if_error(rtn, "demo_fwfeat_el_print_all() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all applicable elements of a target FW feature
+ *              in PFE.
+ * @param[in]   p_cl            FCI client
+ * @param[out]  p_rtn_count     Space to store the count of FW features.
+ * @param[in]   p_feature_name  Name of the requested FW feature.
+ *                              Names of FW features are hardcoded.
+ *                              Use FPP_ACTION_QUERY+FPP_ACTION_QUERY_CONT to get a list of
+ *                              available FW features (and their names) from PFE.
+ *                              See demo_fwfeat_print_all().
+ * @param[in]   group           Element group where to search.
+ *                              Groups are described in struct definition of
+ *                              fpp_fw_features_element_cmd_t.
+ * @return      FPP_ERR_OK : Successfully counted all applicable elements of 
+ *                           the target FW feature. Count was stored into p_rtn_count.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No count was stored.
+ */
+int demo_fwfeat_el_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count, 
+                             const char* p_feature_name, uint8_t group)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_count);
+    assert(NULL != p_feature_name);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_fw_features_element_cmd_t cmd_to_fci = {0};
+    fpp_fw_features_element_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    int32_t count = 0u;
+    
+    /* prepare data */
+    cmd_to_fci.group = group;
+    rtn = set_text((cmd_to_fci.fw_feature_name), p_feature_name, (FPP_FEATURE_NAME_SIZE + 1));
+    
+    /* do the query */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* start query process */
+        cmd_to_fci.action = FPP_ACTION_QUERY;
+        rtn = fci_query(p_cl, FPP_CMD_FW_FEATURE_ELEMENT,
+                        sizeof(fpp_fw_features_element_cmd_t),
+                        (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        
+        /* query loop */
+        while (FPP_ERR_OK == rtn)
+        {
+            count++;
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+                rtn = fci_query(p_cl, FPP_CMD_FW_FEATURE_ELEMENT,
+                                sizeof(fpp_fw_features_element_cmd_t),
+                                (unsigned short*)(&cmd_to_fci),
+                                &reply_length, (unsigned short*)(&reply_from_fci));
+            }
+        }
+        
+        /* query loop runs till there are no more FW feature elements to report */
+        /* the following error is therefore OK and expected (it ends the query loop) */
+        if (FPP_ERR_FW_FEATURE_ELEMENT_NOT_FOUND == rtn)
+        {
+            *p_rtn_count = count;
+            rtn = FPP_ERR_OK;
+        }
+    }
+    print_if_error(rtn, "demo_fwfeat_el_get_count() failed!");
+    
+    return (rtn);
+}
+ 
+ 
 /* ========================================================================= */
  
diff --git a/sw/libfci_cli/src/libfci_demo/demo_fwfeat.h b/sw/libfci_cli/src/libfci_demo/demo_fwfeat.h
index 18bbfe8..a60704f 100644
--- a/sw/libfci_cli/src/libfci_demo/demo_fwfeat.h
+++ b/sw/libfci_cli/src/libfci_demo/demo_fwfeat.h
@@ -1,5 +1,5 @@
 /* =========================================================================
- *  Copyright 2020-2021 NXP
+ *  Copyright 2020-2022 NXP
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -40,14 +40,24 @@
 /* ==== TYPEDEFS & DATA ==================================================== */
 
 typedef int (*demo_fwfeat_cb_print_t)(const fpp_fw_features_cmd_t* p_fwfeat);
+typedef int (*demo_fwfeat_el_cb_print_t)(const fpp_fw_features_element_cmd_t* p_fwfeat_el);
 
 /* ==== PUBLIC FUNCTIONS : use FCI calls to get data from PFE ============== */
 
-int demo_fwfeat_get_by_name(FCI_CLIENT* p_cl, fpp_fw_features_cmd_t* p_rtn_fwfeat, const char* p_name);
+int demo_fwfeat_get_by_name(FCI_CLIENT* p_cl, fpp_fw_features_cmd_t* p_rtn_fwfeat, const char* p_feature_name);
+int demo_fwfeat_el_get_by_name(FCI_CLIENT* p_cl, fpp_fw_features_element_cmd_t* p_rtn_fwfeat_el, const char* p_feature_name, 
+                               const char* p_element_name, uint8_t group, uint8_t index);
 
 /* ==== PUBLIC FUNCTIONS : use FCI calls to update data in PFE ============= */
 
-int demo_fwfeat_set(FCI_CLIENT* p_cl, const char* p_name, bool enable);
+int demo_fwfeat_set(FCI_CLIENT* p_cl, const char* p_feature_name, bool enable);
+int demo_fwfeat_el_set(FCI_CLIENT* p_cl, fpp_fw_features_element_cmd_t* p_fwfeat_el);
+
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+
+void demo_fwfeat_el_set_group(fpp_fw_features_element_cmd_t* p_fwfeat_el, uint8_t group);
+void demo_fwfeat_el_set_index(fpp_fw_features_element_cmd_t* p_fwfeat_el, uint8_t index);
+int demo_fwfeat_el_set_payload(fpp_fw_features_element_cmd_t* p_fwfeat_el, const uint8_t* p_payload, uint8_t count, uint8_t unit_size);
 
 /* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
 
@@ -58,11 +68,21 @@ const char* demo_fwfeat_ld_get_name(const fpp_fw_features_cmd_t* p_fwfeat);
 const char* demo_fwfeat_ld_get_desc(const fpp_fw_features_cmd_t* p_fwfeat);
 fpp_fw_feature_flags_t demo_fwfeat_ld_get_flags(const fpp_fw_features_cmd_t* p_fwfeat);
 
+
+const char* demo_fwfeat_el_ld_get_name(const fpp_fw_features_element_cmd_t* p_fwfeat_el);
+const char* demo_fwfeat_el_ld_get_feat_name(const fpp_fw_features_element_cmd_t* p_fwfeat_el);
+uint8_t demo_fwfeat_el_ld_get_group(const fpp_fw_features_element_cmd_t* p_fwfeat_el);
+uint8_t demo_fwfeat_el_ld_get_index(const fpp_fw_features_element_cmd_t* p_fwfeat_el);
+void demo_fwfeat_el_ld_get_payload(const fpp_fw_features_element_cmd_t* p_fwfeat_el, const uint8_t** pp_rtn_payload, uint8_t* p_rtn_count, uint8_t* p_rtn_unit_size);
+
 /* ==== PUBLIC FUNCTIONS : misc ============================================ */
 
 int demo_fwfeat_print_all(FCI_CLIENT* p_cl, demo_fwfeat_cb_print_t p_cb_print);
 int demo_fwfeat_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count);
 
+int demo_fwfeat_el_print_all(FCI_CLIENT* p_cl, demo_fwfeat_el_cb_print_t p_cb_print, const char* p_feature_name, uint8_t group);
+int demo_fwfeat_el_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count, const char* p_feature_name, uint8_t group);
+
 /* ========================================================================= */
 
 #endif
diff --git a/sw/linux-pfeng/pfeng-drv.c b/sw/linux-pfeng/pfeng-drv.c
index 306b143..9ffedc1 100644
--- a/sw/linux-pfeng/pfeng-drv.c
+++ b/sw/linux-pfeng/pfeng-drv.c
@@ -120,9 +120,13 @@ module_param(disable_master_detection, int, 0644);
 MODULE_PARM_DESC(disable_master_detection, "\t 1 - disable Master detection signalization (default is 0)");
 #endif /* PFE_CFG_MULTI_INSTANCE_SUPPORT */
 
-static bool g2_ordered_class_writes = false;
+static bool g2_ordered_class_writes = true;
 module_param(g2_ordered_class_writes, bool, 0644);
-MODULE_PARM_DESC(g2_ordered_class_writes, "\t Enable ordered class writes on S32G2 (default: false)");
+MODULE_PARM_DESC(g2_ordered_class_writes, "\t Enable ordered class writes on S32G2 (default: true)");
+
+static bool g3_rtable_in_lmem = false;
+module_param(g3_rtable_in_lmem , bool, 0644);
+MODULE_PARM_DESC(g3_rtable_in_lmem , "\t Allocate PFE's Routing Table in local memory on S32G3 (default: false)");
 
 uint32_t get_pfeng_pfe_cfg_master_if(void)
 {
@@ -664,6 +668,9 @@ static int pfeng_drv_probe(struct platform_device *pdev)
 	/* Provide switch value for S32G2 ordered class writes */
 	priv->pfe_cfg->g2_ordered_class_writes = g2_ordered_class_writes;
 
+	/* Routing Table allocation option for S32G3 */
+	priv->pfe_cfg->g3_rtable_in_lmem = g3_rtable_in_lmem;
+
 	/* Start PFE Platform */
 	ret = pfe_platform_init(priv->pfe_cfg);
 	if (ret)
diff --git a/sw/linux-pfeng/pfeng-ethtool.c b/sw/linux-pfeng/pfeng-ethtool.c
index 175c268..38f8161 100644
--- a/sw/linux-pfeng/pfeng-ethtool.c
+++ b/sw/linux-pfeng/pfeng-ethtool.c
@@ -33,6 +33,23 @@ static void pfeng_ethtool_getdrvinfo(struct net_device *netdev, struct ethtool_d
 #endif
 }
 
+static int pfeng_ethtool_get_ts_info(struct net_device *netdev, struct ethtool_ts_info *info)
+{
+	struct pfeng_netif *netif = netdev_priv(netdev);
+
+	ethtool_op_get_ts_info(netdev, info);
+
+	pfeng_hwts_ethtool(netif, info);
+
+	if (netif->ptp_clock)
+		info->phc_index = ptp_clock_index(netif->ptp_clock);
+	else
+		info->phc_index = -1;
+
+	return 0;
+}
+
+#ifdef PFE_CFG_PFE_MASTER
 static int pfeng_ethtool_get_link_ksettings(struct net_device *netdev, struct ethtool_link_ksettings *cmd)
 {
 	struct pfeng_netif *netif = netdev_priv(netdev);
@@ -98,22 +115,6 @@ static int pfeng_ethtool_nway_reset(struct net_device *netdev)
 	return phylink_ethtool_nway_reset(netif->phylink);
 }
 
-static int pfeng_ethtool_get_ts_info(struct net_device *netdev, struct ethtool_ts_info *info)
-{
-	struct pfeng_netif *netif = netdev_priv(netdev);
-
-	ethtool_op_get_ts_info(netdev, info);
-
-	pfeng_hwts_ethtool(netif, info);
-
-	if (netif->ptp_clock)
-		info->phc_index = ptp_clock_index(netif->ptp_clock);
-	else
-		info->phc_index = -1;
-
-	return 0;
-}
-
 #if LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
 static int pfeng_get_coalesce(struct net_device *netdev, struct ethtool_coalesce *ec)
 #else
@@ -192,23 +193,26 @@ static void pfeng_ethtool_complete(struct net_device *netdev)
 
 	pm_runtime_put(&netif->priv->pdev->dev);
 }
+#endif
 
 static const struct ethtool_ops pfeng_ethtool_ops = {
+#ifdef PFE_CFG_PFE_MASTER
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5,7,0)
 	.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS,
 #endif
-	.get_drvinfo = pfeng_ethtool_getdrvinfo,
 	.get_link = ethtool_op_get_link,
 	.nway_reset = pfeng_ethtool_nway_reset,
 	.get_pauseparam = pfeng_ethtool_get_pauseparam,
 	.set_pauseparam = pfeng_ethtool_set_pauseparam,
 	.get_link_ksettings = pfeng_ethtool_get_link_ksettings,
 	.set_link_ksettings = pfeng_ethtool_set_link_ksettings,
-	.get_ts_info = pfeng_ethtool_get_ts_info,
 	.get_coalesce = pfeng_get_coalesce,
 	.set_coalesce = pfeng_set_coalesce,
 	.begin = pfeng_ethtool_begin,
 	.complete = pfeng_ethtool_complete,
+#endif
+	.get_drvinfo = pfeng_ethtool_getdrvinfo,
+	.get_ts_info = pfeng_ethtool_get_ts_info,
 };
 
 void pfeng_ethtool_init(struct net_device *netdev)
@@ -216,6 +220,7 @@ void pfeng_ethtool_init(struct net_device *netdev)
 	netdev->ethtool_ops = &pfeng_ethtool_ops;
 }
 
+#ifdef PFE_CFG_PFE_MASTER
 int pfeng_ethtool_params_save(struct pfeng_netif *netif) {
 	struct net_device *netdev = netif->netdev;
 	struct ethtool_pauseparam epp;
@@ -256,3 +261,12 @@ int pfeng_ethtool_params_restore(struct pfeng_netif *netif) {
 
 	return 0;
 }
+#else
+int pfeng_ethtool_params_save(struct pfeng_netif *netif) {
+	return 0;
+}
+
+int pfeng_ethtool_params_restore(struct pfeng_netif *netif) {
+	return 0;
+}
+#endif
diff --git a/sw/linux-pfeng/pfeng-netif.c b/sw/linux-pfeng/pfeng-netif.c
index e9662a0..522e78a 100644
--- a/sw/linux-pfeng/pfeng-netif.c
+++ b/sw/linux-pfeng/pfeng-netif.c
@@ -1105,9 +1105,9 @@ static struct pfeng_netif *pfeng_netif_logif_create(struct pfeng_priv *priv, str
 	/* Each packet requires extra buffer for Tx header (metadata) */
 	netdev->needed_headroom = PFENG_TX_PKT_HEADER_SIZE;
 
-#ifdef PFE_CFG_PFE_MASTER
 	pfeng_ethtool_init(netdev);
 
+#ifdef PFE_CFG_PFE_MASTER
 	/* Add phylink */
 	if (!netif_cfg->aux && priv->emac[netif_cfg->emac_id].intf_mode != PHY_INTERFACE_MODE_INTERNAL)
 		pfeng_phylink_create(netif);
diff --git a/sw/linux-pfeng/pfeng-phylink.c b/sw/linux-pfeng/pfeng-phylink.c
index 3c92cd7..fefa434 100644
--- a/sw/linux-pfeng/pfeng-phylink.c
+++ b/sw/linux-pfeng/pfeng-phylink.c
@@ -263,7 +263,7 @@ static void pfeng_mac_config(struct phylink_config *config, unsigned int mode, c
 	__maybe_unused struct phylink_link_state sgmii_state = { 0 };
 
 	if (mode == MLO_AN_FIXED || mode == MLO_AN_PHY) {
-		if (phy_interface_mode_is_rgmii(emac->intf_mode)) {
+		if (phy_interface_mode_is_rgmii(emac->intf_mode) || emac->intf_mode == PHY_INTERFACE_MODE_RMII) {
 			if (s32g_set_rgmii_speed(netif, state->speed))
 				return;
 		} else if  (emac->intf_mode == PHY_INTERFACE_MODE_SGMII) {
diff --git a/sw/linux-pfeng/pfeng.h b/sw/linux-pfeng/pfeng.h
index e8d5f6d..e223792 100644
--- a/sw/linux-pfeng/pfeng.h
+++ b/sw/linux-pfeng/pfeng.h
@@ -43,7 +43,7 @@
 #else
 #error Incorrect configuration!
 #endif
-#define PFENG_DRIVER_VERSION		"RTM 1.2.0 RC1"
+#define PFENG_DRIVER_VERSION		"1.2.0 RC2"
 
 #define PFENG_FW_CLASS_NAME		"s32g_pfe_class.fw"
 #define PFENG_FW_UTIL_NAME		"s32g_pfe_util.fw"
diff --git a/sw/pfe_platform/hw/s32g/pfe_cbus.h b/sw/pfe_platform/hw/s32g/pfe_cbus.h
index f898a19..eb444d2 100644
--- a/sw/pfe_platform/hw/s32g/pfe_cbus.h
+++ b/sw/pfe_platform/hw/s32g/pfe_cbus.h
@@ -10,31 +10,32 @@
 #ifndef PFE_CBUS_H_
 #define PFE_CBUS_H_
 
+#define CBUS_LMEM_BASE_ADDR		(0x00000U)
+#define CBUS_LMEM_SIZE			(0x20000U)
+#define CBUS_TMU_CSR_BASE_ADDR		(0x80000U)
+#define CBUS_BMU1_BASE_ADDR		(0x88000U)
+#define CBUS_BMU2_BASE_ADDR		(0x8C000U)
+#define CBUS_CLASS_CSR_BASE_ADDR	(0x90000U)
+#define CBUS_GLOBAL_CSR_BASE_ADDR	(0x94000U)
+#define CBUS_HIF_BASE_ADDR		(0x98000U)
+#define CBUS_HGPI_BASE_ADDR		(0x9C000U)
 #define CBUS_EMAC1_BASE_ADDR		(0xA0000U)
-#define CBUS_EGPI1_BASE_ADDR		(0xAC000U)
-#define CBUS_ETGPI1_BASE_ADDR		(0xB8000U)
 #define CBUS_EMAC2_BASE_ADDR		(0xA4000U)
-#define CBUS_EGPI2_BASE_ADDR		(0xB0000U)
-#define CBUS_ETGPI2_BASE_ADDR		(0xBC000U)
 #define CBUS_EMAC3_BASE_ADDR		(0xA8000U)
+#define CBUS_EGPI1_BASE_ADDR		(0xAC000U)
+#define CBUS_EGPI2_BASE_ADDR		(0xB0000U)
 #define CBUS_EGPI3_BASE_ADDR		(0xB4000U)
+#define CBUS_ETGPI1_BASE_ADDR		(0xB8000U)
+#define CBUS_ETGPI2_BASE_ADDR		(0xBC000U)
 #define CBUS_ETGPI3_BASE_ADDR		(0xC0000U)
-#define CBUS_BMU1_BASE_ADDR			(0x88000U)
-#define CBUS_BMU2_BASE_ADDR			(0x8C000U)
-#define CBUS_HIF_BASE_ADDR			(0x98000U)
-#define CBUS_HGPI_BASE_ADDR			(0x9C000U)
-#define CBUS_LMEM_BASE_ADDR			(0x00000U)
-#define CBUS_LMEM_SIZE				(0x20000U)
-#define CBUS_LMEM_END				(LMEM_BASE_ADDR + LMEM_SIZE - 1U)
-#define CBUS_TMU_CSR_BASE_ADDR		(0x80000U)
-#define CBUS_CLASS_CSR_BASE_ADDR	(0x90000U)
-#define CBUS_HIF_NOCPY_BASE_ADDR	(0xD0000U)
 #define CBUS_UTIL_CSR_BASE_ADDR		(0xCC000U)
-#define CBUS_GLOBAL_CSR_BASE_ADDR	(0x94000U)
+#define CBUS_HIF_NOCPY_BASE_ADDR	(0xD0000U)
+#define CBUS_ROUTE_LMEM_ADDR		(0xE0000U)
+#define CBUS_ROUTE_LMEM_SIZE		(0x20000U)
 
-#define PFE_CORE_DISABLE			0x00000000U
-#define PFE_CORE_ENABLE				0x00000001U
-#define PFE_CORE_SW_RESET			0x00000002U
+#define PFE_CORE_DISABLE		0x00000000U
+#define PFE_CORE_ENABLE			0x00000001U
+#define PFE_CORE_SW_RESET		0x00000002U
 
 #include "pfe_global_wsp.h"
 #include "pfe_class_csr.h"
diff --git a/sw/pfe_platform/hw/s32g/pfe_emac_csr.c b/sw/pfe_platform/hw/s32g/pfe_emac_csr.c
index c6aded1..afa201c 100644
--- a/sw/pfe_platform/hw/s32g/pfe_emac_csr.c
+++ b/sw/pfe_platform/hw/s32g/pfe_emac_csr.c
@@ -588,9 +588,15 @@ errno_t pfe_emac_cfg_adjust_ts_freq(addr_t base_va, uint32_t i_clk_hz, uint32_t
  */
 void pfe_emac_cfg_get_ts_time(addr_t base_va, uint32_t *sec, uint32_t *nsec, uint16_t *sec_hi)
 {
+	uint32_t sec_tmp;
+
 	*sec = hal_read32(base_va + MAC_SYSTEM_TIME_SECONDS);
-	*nsec = hal_read32(base_va + MAC_SYSTEM_TIME_NANOSECONDS);
-	*sec_hi = (uint16_t)hal_read32(base_va + MAC_STS_HIGHER_WORD);
+	do {
+		sec_tmp = *sec;
+		*nsec = hal_read32(base_va + MAC_SYSTEM_TIME_NANOSECONDS);
+		*sec_hi = (uint16_t)hal_read32(base_va + MAC_STS_HIGHER_WORD);
+		*sec = hal_read32(base_va + MAC_SYSTEM_TIME_SECONDS);
+	} while (*sec != sec_tmp);
 }
 
 /**
diff --git a/sw/pfe_platform/hw/s32g/pfe_hif_csr.c b/sw/pfe_platform/hw/s32g/pfe_hif_csr.c
index f2a7712..cd85fc1 100644
--- a/sw/pfe_platform/hw/s32g/pfe_hif_csr.c
+++ b/sw/pfe_platform/hw/s32g/pfe_hif_csr.c
@@ -20,6 +20,10 @@
 #error Missing cbus.h
 #endif /* PFE_CBUS_H_ */
 
+#define HIF_CH_TIMEOUT_EN (BDP_RD_CSR_RX_TIMEOUT_CH_INT_EN  | BDP_WR_CSR_RX_TIMEOUT_CH_INT_EN \
+                          | BDP_RD_CSR_TX_TIMEOUT_CH_INT_EN | BDP_WD_CSR_TX_TIMEOUT_CH_INT_EN \
+                          | DXR_CSR_RX_TIMEOUT_CH_INT_EN    | DXR_CSR_TX_TIMEOUT_CH_INT_EN)
+
 /**
  * @brief	Control the buffer descriptor fetch
  * @details	When TRUE then HIF is fetching the same BD until it is valid BD. If FALSE
@@ -376,12 +380,15 @@ errno_t pfe_hif_chnl_cfg_init(addr_t base_va, uint32_t channel_id)
 
 	/*	Enable channel status interrupts except of the RX/TX and
 	 	the global enable bit. */
+
+	/*	Disable bogus HIF timeouts reporting */
 	hal_write32(0xffffffffU
 			& ~HIF_CH_INT_EN
 			& ~BDP_CSR_RX_CBD_CH_INT_EN
 			& ~BDP_CSR_RX_PKT_CH_INT_EN
 			& ~BDP_CSR_TX_CBD_CH_INT_EN
 			& ~BDP_CSR_TX_PKT_CH_INT_EN
+			& ~HIF_CH_TIMEOUT_EN
 			, base_va + HIF_CHn_INT_EN(channel_id));
 
 	return EOK;
diff --git a/sw/pfe_platform/hw/s32g/pfe_platform_master.c b/sw/pfe_platform/hw/s32g/pfe_platform_master.c
index 4e6e91a..f4844a9 100644
--- a/sw/pfe_platform/hw/s32g/pfe_platform_master.c
+++ b/sw/pfe_platform/hw/s32g/pfe_platform_master.c
@@ -15,7 +15,6 @@ MODULE_LICENSE("GPL");
 
 #ifdef PFE_CFG_PFE_MASTER
 #include "elf_cfg.h"
-#include <uapi/linux/elf.h>
 #include "elf.h"
 
 #include "hal.h"
@@ -1876,6 +1875,7 @@ static errno_t pfe_platform_create_gpi(pfe_platform_t *platform, const pfe_platf
 		if(PFE_S32G3_VERSION == platform->pfe_version)
 		{   /* S32G3 */
 			gpi_cfg_tmp.lmem_header_size = 48U;
+			aseq_len = 0x10U;
 		}
 		else
 		{   /* S32G2 */
@@ -1965,6 +1965,7 @@ static errno_t pfe_platform_create_etgpi(pfe_platform_t *platform)
 {
 	pfe_gpi_cfg_t gpi_cfg_tmp;
 	errno_t ret;
+	uint32_t aseq_len = 0x40U;
 
 	platform->etgpi = oal_mm_malloc(platform->etgpi_count * sizeof(pfe_gpi_t *));
 	if (NULL == platform->etgpi)
@@ -1977,6 +1978,7 @@ static errno_t pfe_platform_create_etgpi(pfe_platform_t *platform)
 		if(PFE_S32G3_VERSION == platform->pfe_version)
 		{   /* S32G3 */
 			gpi_cfg_tmp.lmem_header_size = 48U;
+			aseq_len = 0x10U;
 		}
 		else
 		{   /* S32G2 */
@@ -1986,7 +1988,7 @@ static errno_t pfe_platform_create_etgpi(pfe_platform_t *platform)
 		/*	ETGPI1 */
 		gpi_cfg_tmp.alloc_retry_cycles = 0x200U;
 		gpi_cfg_tmp.gpi_tmlf_txthres = 0xbcU;
-		gpi_cfg_tmp.gpi_dtx_aseq_len = 0x40;
+		gpi_cfg_tmp.gpi_dtx_aseq_len = aseq_len;
 		gpi_cfg_tmp.emac_1588_ts_en = TRUE;
 
 		platform->etgpi[0] = pfe_gpi_create(platform->cbus_baseaddr, CBUS_ETGPI1_BASE_ADDR, &gpi_cfg_tmp);
@@ -2000,7 +2002,7 @@ static errno_t pfe_platform_create_etgpi(pfe_platform_t *platform)
 			/*	ETGPI2 */
 			gpi_cfg_tmp.alloc_retry_cycles = 0x200U;
 			gpi_cfg_tmp.gpi_tmlf_txthres = 0xbcU;
-			gpi_cfg_tmp.gpi_dtx_aseq_len = 0x40;
+			gpi_cfg_tmp.gpi_dtx_aseq_len = aseq_len;
 			gpi_cfg_tmp.emac_1588_ts_en = TRUE;
 
 			platform->etgpi[1] = pfe_gpi_create(platform->cbus_baseaddr, CBUS_ETGPI2_BASE_ADDR, &gpi_cfg_tmp);
@@ -2014,7 +2016,7 @@ static errno_t pfe_platform_create_etgpi(pfe_platform_t *platform)
 				/*	ETGPI3 */
 				gpi_cfg_tmp.alloc_retry_cycles = 0x200U;
 				gpi_cfg_tmp.gpi_tmlf_txthres = 0xbcU;
-				gpi_cfg_tmp.gpi_dtx_aseq_len = 0x40;
+				gpi_cfg_tmp.gpi_dtx_aseq_len = aseq_len;
 				gpi_cfg_tmp.emac_1588_ts_en = TRUE;
 
 				platform->etgpi[2] = pfe_gpi_create(platform->cbus_baseaddr, CBUS_ETGPI3_BASE_ADDR, &gpi_cfg_tmp);
@@ -2064,6 +2066,7 @@ static errno_t pfe_platform_create_hgpi(pfe_platform_t *platform)
 {
 	pfe_gpi_cfg_t hgpi_cfg;
 	errno_t ret;
+	uint32_t aseq_len = HGPI_ASEQ_LEN;
 
 	platform->hgpi = oal_mm_malloc(platform->hgpi_count * sizeof(pfe_gpi_t *));
 	if (NULL == platform->hgpi)
@@ -2076,6 +2079,7 @@ static errno_t pfe_platform_create_hgpi(pfe_platform_t *platform)
 		if(PFE_S32G3_VERSION == platform->pfe_version)
 		{   /* S32G3 */
 			hgpi_cfg.lmem_header_size = 48U;
+			aseq_len = 0x10U;
 		}
 		else
 		{   /* S32G2 */
@@ -2084,7 +2088,7 @@ static errno_t pfe_platform_create_hgpi(pfe_platform_t *platform)
 
 		hgpi_cfg.alloc_retry_cycles = 0x200U;
 		hgpi_cfg.gpi_tmlf_txthres = 0x178U;
-		hgpi_cfg.gpi_dtx_aseq_len = HGPI_ASEQ_LEN;
+		hgpi_cfg.gpi_dtx_aseq_len = aseq_len;
 		hgpi_cfg.emac_1588_ts_en = FALSE;
 
 		platform->hgpi[0] = pfe_gpi_create(platform->cbus_baseaddr, CBUS_HGPI_BASE_ADDR, &hgpi_cfg);
@@ -2328,9 +2332,9 @@ static void pfe_platform_destroy_l2_bridge(pfe_platform_t *platform)
  */
 static errno_t pfe_platform_create_rtable(pfe_platform_t *platform, const pfe_platform_config_t *config)
 {
-	addr_t htable_mem;
-	addr_t pool_mem;
+	pfe_rtable_cfg_t cfg = { 0 };
 	uint32_t pool_offs;
+	bool_t in_lmem;
 	errno_t ret;
 
 	if (config->rtable_hash_size > PFE_CFG_RT_HASH_ENTRIES_MAX_CNT)
@@ -2343,7 +2347,35 @@ static errno_t pfe_platform_create_rtable(pfe_platform_t *platform, const pfe_pl
 		pool_offs = config->rtable_hash_size * pfe_rtable_get_entry_size();
 
 		platform->rtable_size = (config->rtable_hash_size + config->rtable_collision_size) * pfe_rtable_get_entry_size();
-		platform->rtable_va = oal_mm_malloc_contig_named_aligned_nocache(PFE_CFG_RT_MEM, platform->rtable_size, 2048U);
+		in_lmem = config->g3_rtable_in_lmem;
+
+		if (TRUE == in_lmem && FALSE == pfe_feature_mgr_is_available(PFE_HW_FEATURE_RUN_ON_G3))
+		{
+			NXP_LOG_WARNING("'g3_rtable_in_lmem' works only on S32G3, ignore option\n");
+			in_lmem = FALSE;
+		}
+
+		if (TRUE == in_lmem)
+		{
+			if (CBUS_ROUTE_LMEM_SIZE >= platform->rtable_size)
+			{
+				platform->g3_rtable_in_lmem = TRUE;
+			}
+			else
+			{
+				NXP_LOG_WARNING("Not enough space to allocate the routing table in LMEM (%u bytes), fall back to default allocation\n", (uint_t)platform->rtable_size);
+			}
+		}
+
+		if (TRUE == platform->g3_rtable_in_lmem)
+		{
+			platform->rtable_va = (void *)(platform->cbus_baseaddr + CBUS_ROUTE_LMEM_ADDR);
+		}
+		else
+		{
+			platform->rtable_va = oal_mm_malloc_contig_named_aligned_nocache(PFE_CFG_RT_MEM, platform->rtable_size, 2048U);
+		}
+
 		if (NULL == platform->rtable_va)
 		{
 			NXP_LOG_ERROR("Unable to get routing table memory\n");
@@ -2351,8 +2383,22 @@ static errno_t pfe_platform_create_rtable(pfe_platform_t *platform, const pfe_pl
 		}
 		else
 		{
-			htable_mem = (addr_t)platform->rtable_va;
-			pool_mem = (addr_t)platform->rtable_va + pool_offs;
+			cfg.htable_base_va = (addr_t)platform->rtable_va;
+			cfg.pool_base_va = (addr_t)platform->rtable_va + pool_offs;
+			cfg.htable_size = config->rtable_hash_size;
+			cfg.pool_size = config->rtable_collision_size;
+			cfg.lmem_allocated = platform->g3_rtable_in_lmem;
+
+			if (TRUE == platform->g3_rtable_in_lmem)
+			{
+				cfg.htable_base_pa = PFE_CFG_CBUS_PHYS_BASE_ADDR + CBUS_ROUTE_LMEM_ADDR;
+				cfg.pool_base_pa = cfg.htable_base_pa + pool_offs;
+			}
+			else
+			{
+				cfg.htable_base_pa = (addr_t)oal_mm_virt_to_phys_contig((void *)cfg.htable_base_va);
+				cfg.pool_base_pa = cfg.htable_base_pa + pool_offs;
+			}
 
 			if (NULL == platform->classifier)
 			{
@@ -2361,7 +2407,7 @@ static errno_t pfe_platform_create_rtable(pfe_platform_t *platform, const pfe_pl
 			}
 			else
 			{
-				platform->rtable = pfe_rtable_create(platform->classifier, htable_mem, config->rtable_hash_size, pool_mem, config->rtable_collision_size, platform->l2_bridge);
+				platform->rtable = pfe_rtable_create(platform->classifier, platform->l2_bridge, &cfg);
 
 				if (NULL == platform->rtable)
 				{
@@ -2370,7 +2416,7 @@ static errno_t pfe_platform_create_rtable(pfe_platform_t *platform, const pfe_pl
 				}
 				else
 				{
-					NXP_LOG_INFO("Routing table created, Hash Table @ p0x%"PRINTADDR_T", Pool @ p0x%"PRINTADDR_T" (%u bytes)\n", (addr_t)oal_mm_virt_to_phys_contig((void *)htable_mem), (addr_t)oal_mm_virt_to_phys_contig((void *)htable_mem) + (addr_t)pool_offs, (uint_t)platform->rtable_size);
+					NXP_LOG_INFO("Routing table created, Hash Table @ p0x%"PRINTADDR_T", Pool @ p0x%"PRINTADDR_T" (%u bytes)\n", cfg.htable_base_pa, cfg.pool_base_pa, (uint_t)platform->rtable_size);
 					ret = EOK;
 				}
 			}
@@ -2392,7 +2438,10 @@ static void pfe_platform_destroy_rtable(pfe_platform_t *platform)
 
 	if (NULL != platform->rtable_va)
 	{
-		oal_mm_free_contig(platform->rtable_va);
+		if (FALSE == platform->g3_rtable_in_lmem)
+		{
+			oal_mm_free_contig(platform->rtable_va);
+		}
 		platform->rtable_va = NULL;
 	}
 }
@@ -3477,7 +3526,7 @@ errno_t pfe_platform_init(const pfe_platform_config_t *config)
 	}
 	else
 	{
-		NXP_LOG_INFO("PFE CBUS p0x%"PRINTADDR_T" mapped @ v0x%"PRINTADDR_T"\n", config->cbus_base, pfe.cbus_baseaddr);
+		NXP_LOG_INFO("PFE CBUS p0x%"PRINTADDR_T" mapped @ v0x%"PRINTADDR_T" (0x%"PRINTADDR_T" bytes)\n", config->cbus_base, pfe.cbus_baseaddr, config->cbus_len);
 	}
 
 	/* Get PFE Version */
@@ -3503,13 +3552,22 @@ errno_t pfe_platform_init(const pfe_platform_config_t *config)
 		hal_write32(0x0, addr);
 	}
 
-	/*	Initialize LMEM TODO: Get LMEM size from global WSP_LMEM_SIZE register */
+	/*	Initialize LMEM and ROUTE LMEM (G3) TODO: Get LMEM size from global WSP_LMEM_SIZE register */
 	addr = (uint32_t*)(void*)((addr_t)pfe.cbus_baseaddr + CBUS_LMEM_BASE_ADDR);
 	for (ii = addr; ((addr_t)ii - (addr_t)addr) < CBUS_LMEM_SIZE; ++ii)
 	{
 		*ii = 0U;
 	}
 
+	if (TRUE == pfe_feature_mgr_is_available(PFE_HW_FEATURE_RUN_ON_G3))
+	{
+		addr = (uint32_t*)(void*)((addr_t)pfe.cbus_baseaddr + CBUS_ROUTE_LMEM_ADDR);
+		for (ii = addr; ((addr_t)ii - (addr_t)addr) < CBUS_ROUTE_LMEM_SIZE; ++ii)
+		{
+			*ii = 0U;
+		}
+	}
+
 	/*	Create HW components */
 	pfe.emac_count = 3U;
 	pfe.gpi_count = 3U;
diff --git a/sw/pfe_platform/public/pfe_class.h b/sw/pfe_platform/public/pfe_class.h
index 1b70001..c19dff9 100644
--- a/sw/pfe_platform/public/pfe_class.h
+++ b/sw/pfe_platform/public/pfe_class.h
@@ -11,6 +11,7 @@
 #define PFE_CLASS_H_
 
 #include "pfe_ct.h"
+#include "pfe_ct_comp.h"
 #include "pfe_fw_feature.h"
 
 typedef struct pfe_classifier_tag pfe_class_t;
diff --git a/sw/pfe_platform/public/pfe_ct_comp.h b/sw/pfe_platform/public/pfe_ct_comp.h
new file mode 100644
index 0000000..dc05f8f
--- /dev/null
+++ b/sw/pfe_platform/public/pfe_ct_comp.h
@@ -0,0 +1,31 @@
+/* =========================================================================
+ *  
+ *  Copyright 2022 NXP
+ *
+ *  SPDX-License-Identifier: GPL-2.0
+ *
+ * ========================================================================= */
+
+#ifndef HW_S32G_PFE_CT_COMP_H_
+#define HW_S32G_PFE_CT_COMP_H_
+#include "pfe_ct.h"
+
+typedef struct __attribute__((packed,aligned(4)))
+{
+	const char name[16];
+	PFE_PTR(uint8_t) const data;
+	const uint8_t size;
+	const uint8_t multiplicity;
+	const uint8_t reserved[2];
+} pfe_ct_feature_tbl_entry_t ;
+
+typedef struct __attribute__((packed,aligned(4)))
+{
+	pfe_ct_feature_desc_t feature;
+	PFE_PTR(const pfe_ct_feature_tbl_entry_t) cfg;
+	PFE_PTR(const pfe_ct_feature_tbl_entry_t) stats;
+}pfe_ct_feature_desc_ext_t;
+
+ct_assert(sizeof(pfe_ct_feature_desc_ext_t) == 24);
+
+#endif /* HW_S32G_PFE_CT_COMP_H_ */
diff --git a/sw/pfe_platform/public/pfe_feature_mgr.h b/sw/pfe_platform/public/pfe_feature_mgr.h
index 5e3c399..88ed01c 100644
--- a/sw/pfe_platform/public/pfe_feature_mgr.h
+++ b/sw/pfe_platform/public/pfe_feature_mgr.h
@@ -20,6 +20,13 @@
 #include "Eth_43_PFE_MemMap.h"
 #endif /* PFE_CFG_TARGET_OS_AUTOSAR */
 
+enum CAL_PACKED
+{
+	FW_FEATURE_TABLE_DEFAULT = 0U,
+	FW_FEATURE_TABLE_CONFIG = 1U,
+	FW_FEATURE_TABLE_STATS = 2U
+};
+
 errno_t pfe_feature_mgr_init(uint32_t *cbus_base);
 errno_t pfe_feature_mgr_fini(void);
 errno_t pfe_feature_mgr_add_modules(pfe_class_t *class, pfe_util_t *util, pfe_tmu_t *tmu);
@@ -36,6 +43,14 @@ errno_t pfe_feature_mgr_get_variant(const char *feature_name, uint8_t *val);
 errno_t pfe_feature_mgr_enable(const char *feature_name);
 errno_t pfe_feature_mgr_disable(const char *feature_name);
 
+errno_t pfe_feature_mgr_table_first(const char *feature_name, uint8_t table_type, const char **table_el_name);
+errno_t pfe_feature_mgr_table_next(const char *feature_name, uint8_t table_type, const char **table_el_name);
+errno_t pfe_feature_mgr_table_get_size(const char *feature_name, uint8_t table_type, const char *table_el_name, uint8_t *size);
+errno_t pfe_feature_mgr_table_get_multiplicity(const char *feature_name, uint8_t table_type, const char *table_el_name, uint8_t *count);
+errno_t pfe_feature_mgr_table_get_payload(const char *feature_name, uint8_t table_type, const char *table_el_name, uint8_t *payload);
+
+errno_t pfe_feature_mgr_table_set_val(const char *feature_name, uint8_t table_type, const char *table_el_name, uint8_t index, uint8_t* val);
+
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
 #include "Eth_43_PFE_MemMap.h"
diff --git a/sw/pfe_platform/public/pfe_fw_feature.h b/sw/pfe_platform/public/pfe_fw_feature.h
index 8cc9ea1..2b62712 100644
--- a/sw/pfe_platform/public/pfe_fw_feature.h
+++ b/sw/pfe_platform/public/pfe_fw_feature.h
@@ -13,6 +13,11 @@
 typedef errno_t(*dmem_read_func_t)(void *, int32_t, void *, addr_t, uint32_t);
 typedef errno_t(*dmem_write_func_t)(void *, int32_t, addr_t, const void *, uint32_t);
 typedef struct pfe_fw_feature_tag pfe_fw_feature_t;
+typedef struct pfe_fw_tbl_handle_tag
+{
+	const pfe_fw_feature_t *feature;
+	pfe_ct_feature_tbl_entry_t *tbl_curr;
+} pfe_fw_tbl_handle_t;
 
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_START_SEC_CODE
@@ -21,7 +26,7 @@ typedef struct pfe_fw_feature_tag pfe_fw_feature_t;
 
 pfe_fw_feature_t *pfe_fw_feature_create(void);
 void pfe_fw_feature_destroy(const pfe_fw_feature_t *feature);
-errno_t pfe_fw_feature_set_ll_data(pfe_fw_feature_t *feature, pfe_ct_feature_desc_t *ll_data);
+errno_t pfe_fw_feature_set_ll_data(pfe_fw_feature_t *feature, pfe_ct_feature_desc_t *ll_data, uint8_t instances);
 errno_t pfe_fw_feature_set_string_base(pfe_fw_feature_t *feature, const char *string_base);
 errno_t pfe_fw_feature_set_dmem_funcs(pfe_fw_feature_t *feature, dmem_read_func_t read_func, dmem_write_func_t write_func, void *data);
 errno_t pfe_fw_feature_get_name(const pfe_fw_feature_t *feature, const char **name);
@@ -34,6 +39,21 @@ errno_t pfe_fw_feature_set_val(const pfe_fw_feature_t *feature, uint8_t val);
 bool_t pfe_fw_feature_is_in_class(const pfe_fw_feature_t *feature);
 bool_t pfe_fw_feature_is_in_util(const pfe_fw_feature_t *feature);
 
+errno_t pfe_fw_feature_table_stats_first(pfe_fw_feature_t *feature, pfe_fw_tbl_handle_t *feature_table);
+errno_t pfe_fw_feature_table_stats_next(pfe_fw_feature_t *feature, pfe_fw_tbl_handle_t *feature_table);
+errno_t pfe_fw_feature_table_cfg_first(pfe_fw_feature_t *feature, pfe_fw_tbl_handle_t *feature_table);
+errno_t pfe_fw_feature_table_cfg_next(pfe_fw_feature_t *feature, pfe_fw_tbl_handle_t *feature_table);
+errno_t pfe_fw_feature_table_entry_name(pfe_fw_tbl_handle_t handle, const char **table_name);
+errno_t pfe_fw_feature_table_stats_by_name(const pfe_fw_feature_t *feature, const char_t *name, pfe_fw_tbl_handle_t *entry);
+errno_t pfe_fw_feature_table_cfg_by_name(const pfe_fw_feature_t *feature, const char *name, pfe_fw_tbl_handle_t *entry);
+uint32_t pfe_fw_feature_table_entry_size(pfe_fw_tbl_handle_t handle);
+uint32_t pfe_fw_feature_table_entry_multiplicity(pfe_fw_tbl_handle_t handle);
+uint32_t pfe_fw_feature_table_entry_allocsize(pfe_fw_tbl_handle_t handle);
+errno_t pfe_fw_feature_table_entry_get(pfe_fw_tbl_handle_t handle, void *mem, uint16_t size, bool_t collect);
+errno_t pfe_fw_feature_table_entry_get_by_idx(pfe_fw_tbl_handle_t handle, void *mem, uint16_t idx, bool_t collect);
+errno_t pfe_fw_feature_table_entry_set_by_idx(pfe_fw_tbl_handle_t handle, void *val, uint16_t idx);
+errno_t pfe_fw_feature_table_entry_set(pfe_fw_tbl_handle_t handle, void *val, uint16_t size);
+
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
 #include "Eth_43_PFE_MemMap.h"
diff --git a/sw/pfe_platform/public/pfe_platform.h b/sw/pfe_platform/public/pfe_platform.h
index 688dbaa..11cf199 100644
--- a/sw/pfe_platform/public/pfe_platform.h
+++ b/sw/pfe_platform/public/pfe_platform.h
@@ -95,6 +95,7 @@ typedef struct
 	uint16_t vlan_stats_size;	/*VLAN stats size(number of vlan entry) used to collect info from firmware */
 	pfe_emac_mii_mode_t emac_mode[3]; /* MII mode per PFE EMAC */
 	bool_t g2_ordered_class_writes;	/* S32G2 ordered class writes switch */
+	bool_t g3_rtable_in_lmem;	/* allocate the routing table in LMEM for S32G3 */
 } pfe_platform_config_t;
 
 typedef struct
@@ -157,6 +158,7 @@ typedef struct
 	pfe_fci_owner_hif_id_t hif_fci_owner_chnls_mask;
 #endif /* PFE_CFG_MULTI_INSTANCE_SUPPORT */
 	bool_t fci_created;
+	bool_t g3_rtable_in_lmem;
 	uint32_t pfe_version;
 } pfe_platform_t;
 
diff --git a/sw/pfe_platform/public/pfe_rtable.h b/sw/pfe_platform/public/pfe_rtable.h
index fedec2b..a22950d 100644
--- a/sw/pfe_platform/public/pfe_rtable.h
+++ b/sw/pfe_platform/public/pfe_rtable.h
@@ -22,6 +22,17 @@
  */
 #define PFE_RTABLE_CFG_TICK_PERIOD_SEC			1U
 
+typedef struct
+{
+	addr_t htable_base_va;	/*!< Virtual address where the hash table shall be placed */
+	addr_t htable_base_pa;	/*!< The physical base address of the hash table */
+	uint32_t htable_size;	/*!< Number of entries within the hash table */
+	addr_t pool_base_va;	/*!< Virtual address where the pool of collision entries shall be placed */
+	addr_t pool_base_pa;	/*!< The physical base address of the pool */
+	uint32_t pool_size;	/*|< Number of entries within the pool */
+	bool_t lmem_allocated;
+} pfe_rtable_cfg_t;
+
 typedef struct pfe_rtable_tag pfe_rtable_t;
 typedef struct pfe_rtable_entry_tag pfe_rtable_entry_t;
 
@@ -92,7 +103,7 @@ typedef void (* pfe_rtable_callback_t)(void *arg, pfe_rtable_cbk_event_t event);
 #include "Eth_43_PFE_MemMap.h"
 #endif /* PFE_CFG_TARGET_OS_AUTOSAR */
 
-pfe_rtable_t *pfe_rtable_create(pfe_class_t *class, addr_t htable_base_va, uint32_t htable_size, addr_t pool_base_va, uint32_t pool_size, pfe_l2br_t *bridge);
+pfe_rtable_t *pfe_rtable_create(pfe_class_t *class, pfe_l2br_t *bridge, pfe_rtable_cfg_t *config);
 errno_t pfe_rtable_add_entry(pfe_rtable_t *rtable, pfe_rtable_entry_t *entry);
 errno_t pfe_rtable_del_entry(pfe_rtable_t *rtable, pfe_rtable_entry_t *entry);
 void pfe_rtable_destroy(pfe_rtable_t *rtable);
diff --git a/sw/pfe_platform/src/pfe_class.c b/sw/pfe_platform/src/pfe_class.c
index 932b759..de89093 100644
--- a/sw/pfe_platform/src/pfe_class.c
+++ b/sw/pfe_platform/src/pfe_class.c
@@ -570,7 +570,7 @@ static errno_t pfe_class_load_fw_process(pfe_class_t *class)
 			else
 			{
 				/* Set the low level data in the feature */
-				(void)pfe_fw_feature_set_ll_data(class->fw_features[i], entry);
+				(void)pfe_fw_feature_set_ll_data(class->fw_features[i], entry, pfe_class_get_num_of_pes(class));
 				/* Set the feature string base */
 				ret = pfe_fw_feature_set_string_base(class->fw_features[i], pfe_pe_get_fw_feature_str_base(class->pe[0U]));
 				if (EOK != ret)
diff --git a/sw/pfe_platform/src/pfe_feature_mgr.c b/sw/pfe_platform/src/pfe_feature_mgr.c
index cec4db0..3fb9930 100644
--- a/sw/pfe_platform/src/pfe_feature_mgr.c
+++ b/sw/pfe_platform/src/pfe_feature_mgr.c
@@ -16,6 +16,7 @@
 #include "pfe_tmu.h"
 #include "pfe_hw_feature.h"
 #include "pfe_feature_mgr.h"
+#include "pfe_fw_feature.h"
 
 /*
 --------------         -----------------         -----------
@@ -59,6 +60,11 @@ typedef struct
 
 static pfe_feature_mgr_t *feature_mgr = NULL;
 
+/**
+ *  Internal flag supporting transition walk from cfg table to stats table
+ */
+static bool_t table_rewind_flag = FALSE;
+
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_VAR_INIT_32
 #include "Eth_43_PFE_MemMap.h"
@@ -100,6 +106,7 @@ errno_t pfe_feature_mgr_init(uint32_t *cbus_base)
 				(void)memset(feature_mgr, 0, sizeof(pfe_feature_mgr_t));
 				feature_mgr->cbus_base = cbus_base;
 				feature_mgr->hw_features = oal_mm_malloc(2U * sizeof(pfe_hw_feature_t *));
+				table_rewind_flag = FALSE;
 				ret = pfe_hw_feature_init_all(cbus_base, feature_mgr->hw_features, &feature_mgr->hw_features_count);
 			}
 			else
@@ -818,10 +825,10 @@ errno_t pfe_feature_mgr_get_first(const char **feature_name)
 			}
 		}
 	}
-
 	return ret;
 }
 
+
 /**
  * @brief		Returns the next feature (continues the features query)
  * @param[out]	feature_name Name of the next feature
@@ -1209,6 +1216,673 @@ static errno_t pfe_feature_mgr_configure_driver(const char *feature_name, const
 	return ret;
 }
 
+static errno_t pfe_feature_mgr_table_parent_inst(const char *feature_name, pfe_fw_feature_t **feature)
+{
+	errno_t ret = EOK;
+	bool_t class_parrent = TRUE;
+
+	if(feature_name[0] == 'u' && feature_name[1] == '_')
+	{
+		feature_name += 2;
+		class_parrent = FALSE;
+	}
+
+	if(TRUE == class_parrent)
+	{
+		if (NULL == feature_mgr->class)
+		{ /* Class block is not initialized */
+			ret = EINVAL;
+		}
+		else
+		{
+			ret = pfe_class_get_feature(feature_mgr->class, feature, feature_name);
+		}
+	}
+	else
+	{
+		if (NULL == feature_mgr->util)
+		{ /* Class block is not initialized */
+			ret = EINVAL;
+		}
+		else
+		{
+			ret = pfe_util_get_feature(feature_mgr->util, feature, feature_name);
+		}
+	}
+
+	return ret;
+}
+
+/**
+ * @brief		Sets a value in the provided feature table element
+ * @param[in]	feature_name Name of the feature to set the value
+ * @param[in]	table_type In witch table the element is looked for
+ * @param[in]	table_el_name Name of the table element to set the value
+ * @param[in]	index Index of the value in the table
+				index=0 means set the value on all table described by elemnt
+				index > 0 means to set the value at a specific index witch
+				start from 1.
+ * @param[in]	val Value to be set
+ * @return		EOK or failure code.
+ */
+errno_t pfe_feature_mgr_table_set_val(const char *feature_name, uint8_t table_type, const char *table_el_name, uint8_t index, uint8_t* val)
+{
+	pfe_fw_feature_t	*fw_feature;
+	pfe_fw_tbl_handle_t	fw_feature_table_entry;
+	errno_t				ret = EOK;
+
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name || NULL == table_el_name || NULL == val)
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		ret = EINVAL;
+	}
+	else
+#endif
+	{
+		ret = pfe_feature_mgr_table_parent_inst(feature_name, &fw_feature);
+		if (EOK == ret)
+		{
+			switch (table_type)
+			{
+				case FW_FEATURE_TABLE_DEFAULT:
+					ret = pfe_fw_feature_table_cfg_by_name(fw_feature, table_el_name, &fw_feature_table_entry);
+					if (ENOENT == ret)
+					{
+						ret = pfe_fw_feature_table_stats_by_name(fw_feature, table_el_name, &fw_feature_table_entry);
+					}
+					break;
+				case FW_FEATURE_TABLE_CONFIG:
+					ret = pfe_fw_feature_table_cfg_by_name(fw_feature, table_el_name, &fw_feature_table_entry);
+					break;
+				case FW_FEATURE_TABLE_STATS:
+					ret = pfe_fw_feature_table_stats_by_name(fw_feature, table_el_name, &fw_feature_table_entry);
+					break;
+				default:
+					ret = EINVAL;
+			}
+
+			if (EOK == ret)
+			{
+				if (index == 0)
+				{
+					ret = pfe_fw_feature_table_entry_set(fw_feature_table_entry, (void *) val, pfe_fw_feature_table_entry_allocsize(fw_feature_table_entry));
+				}
+				else
+				{
+					ret = pfe_fw_feature_table_entry_set_by_idx(fw_feature_table_entry, (void *) val, index-1);
+				}
+			}
+		}
+	}
+
+	return ret;
+}
+
+/**
+ * @brief	Returns the 1st feature table stats element
+ *			(resets the features table stts element query)
+ * @param[in]	feature_name Name of the feature to be set.
+ * @param[out]	Name of the 1st element.
+ * @return		EOK or failure code.
+ */
+static errno_t pfe_feature_mgr_table_stats_first(const char *feature_name, const char **table_el_name)
+{
+	pfe_fw_feature_t	*fw_feature;
+	pfe_fw_tbl_handle_t	fw_feature_table_stats;
+	errno_t				ret = EOK;
+
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name || NULL == table_el_name)
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		ret = EINVAL;
+	}
+	else
+#endif
+	{ 
+		ret = pfe_feature_mgr_table_parent_inst(feature_name, &fw_feature);
+		if (EOK == ret)
+		{
+			ret = pfe_fw_feature_table_stats_first(fw_feature, &fw_feature_table_stats);
+			if (EOK == ret)
+			{
+				ret = pfe_fw_feature_table_entry_name(fw_feature_table_stats, table_el_name);
+			}
+		}
+	}
+
+	return ret;
+}
+
+/**
+ * @brief	Returns the next feature element in stats table
+ *			(continues the features table stats query)
+ * @param[in]	feature_name Name of the feature to be set
+ * @param[out]	Name of the next element.
+ * @return		EOK or failure code.
+ */
+static errno_t pfe_feature_mgr_table_stats_next(const char *feature_name, const char **table_el_name)
+{
+	pfe_fw_feature_t	*fw_feature;
+	pfe_fw_tbl_handle_t	fw_feature_table_stats;
+	errno_t				ret = EOK;
+
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name || NULL == table_el_name)
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		ret = EINVAL;
+	}
+	else
+#endif
+	{
+		ret = pfe_feature_mgr_table_parent_inst(feature_name, &fw_feature);
+		if (EOK == ret)
+		{
+			ret = pfe_fw_feature_table_stats_next(fw_feature, &fw_feature_table_stats);
+			if (EOK == ret)
+			{
+				ret = pfe_fw_feature_table_entry_name(fw_feature_table_stats, table_el_name);
+			}
+		}
+	}
+
+	return ret;
+}
+
+/**
+ * @brief	Returns the 1st feature table config element 
+ *			(resets the features table config element query)
+ * @param[in]	feature_name Name of the feature to be set.
+ * @param[out]	Name of the 1st element.
+ * @return		EOK or failure code.
+ */
+static errno_t pfe_feature_mgr_table_cfg_first(const char *feature_name, const char **table_el_name)
+{
+	pfe_fw_feature_t	*fw_feature;
+	pfe_fw_tbl_handle_t	fw_feature_table_cfg;
+	errno_t				ret = EOK;
+
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name || NULL == table_el_name)
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		ret = EINVAL;
+	}
+	else
+#endif
+	{
+		ret = pfe_feature_mgr_table_parent_inst(feature_name, &fw_feature);
+		if (EOK == ret)
+		{
+			ret = pfe_fw_feature_table_cfg_first(fw_feature, &fw_feature_table_cfg);
+			if (EOK == ret)
+			{
+				ret = pfe_fw_feature_table_entry_name(fw_feature_table_cfg, table_el_name);
+			}
+		}
+	}
+
+	return ret;
+}
+
+/**
+ * @brief	Returns the next feature element in config table 
+ * 			(continues the features table config query)
+ * @param[in]	feature_name Name of the feature to be set
+ * @param[out]	Name of the next element.
+ * @return		EOK or failure code.
+ */
+static errno_t pfe_feature_mgr_table_cfg_next(const char *feature_name, const char **table_el_name)
+{
+	pfe_fw_feature_t	*fw_feature;
+	pfe_fw_tbl_handle_t	fw_feature_table_cfg;
+	errno_t				ret = EOK;
+
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name || NULL == feature_table_name)
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		ret = EINVAL;
+	}
+	else
+#endif
+	{
+		ret = pfe_feature_mgr_table_parent_inst(feature_name, &fw_feature);
+		if (EOK == ret)
+		{
+			ret = pfe_fw_feature_table_cfg_next(fw_feature, &fw_feature_table_cfg);
+			if (EOK == ret)
+			{
+				ret = pfe_fw_feature_table_entry_name(fw_feature_table_cfg, table_el_name);
+			}
+		}
+ 	}
+
+	return ret;
+}
+
+/**
+ * @brief		Returns the 1st feature table element (resets the features table element query)
+ * @param[in]	feature_name Name of the feature to be set
+ * @param[in]	table_type In witch table the element is looked for
+ * @param[out]	Name of the 1st element
+ * @return		EOK or failure code.
+ */
+errno_t pfe_feature_mgr_table_first(const char *feature_name, uint8_t table_type, const char **table_el_name)
+{
+	errno_t ret = EOK;
+
+	switch(table_type)
+	{
+		case FW_FEATURE_TABLE_DEFAULT:
+			ret = pfe_feature_mgr_table_cfg_first(feature_name, table_el_name);
+			table_rewind_flag = TRUE;
+			if (EOK != ret)
+			{
+				ret = pfe_feature_mgr_table_stats_first(feature_name, table_el_name);
+				table_rewind_flag = FALSE;
+			}
+			break;
+		case FW_FEATURE_TABLE_CONFIG:
+			ret = pfe_feature_mgr_table_cfg_first(feature_name, table_el_name);
+			break;
+		case FW_FEATURE_TABLE_STATS:
+			ret = pfe_feature_mgr_table_stats_first(feature_name, table_el_name);
+			break;
+		default:
+			ret = EINVAL;
+	}
+
+	return ret;
+}
+
+/**
+ * @brief		Returns the next feature element (continues the features element query)
+ * @param[in]	feature_name Name of the feature to be set
+ * @param[in]	table_type In witch table the element is looked for
+ * @param[out]	feature table name of the next element
+ * @return		EOK or failure code.
+ */
+
+errno_t pfe_feature_mgr_table_next(const char *feature_name, uint8_t table_type, const char **table_el_name)
+{
+	errno_t ret = EOK;
+
+	switch(table_type)
+	{
+		case FW_FEATURE_TABLE_DEFAULT:
+			ret = pfe_feature_mgr_table_cfg_next(feature_name, table_el_name);
+			if (ENOENT == ret)
+			{
+				if (TRUE == table_rewind_flag)
+				{
+					ret = pfe_feature_mgr_table_stats_first(feature_name, table_el_name);
+					table_rewind_flag = FALSE;
+				}
+				else
+				{
+					ret = pfe_feature_mgr_table_stats_next(feature_name, table_el_name);
+				}
+			}
+			break;
+		case FW_FEATURE_TABLE_CONFIG:
+			ret = pfe_feature_mgr_table_cfg_next(feature_name, table_el_name);
+			break;
+		case FW_FEATURE_TABLE_STATS:
+			ret = pfe_feature_mgr_table_stats_next(feature_name, table_el_name);
+			break;
+		default:
+			ret = EINVAL;
+	}
+
+	return ret;
+}
+
+/**
+ * @brief		Reads the config table element size
+ * @param[in]	feature_name Name of the feature to be read
+ * @param[in]	table_el_name Name of the table element to be read
+ * @param[out]	count The read value of the table element size
+ * @return		EOK or failure code.
+ */
+static errno_t pfe_feature_mgr_table_cfg_get_size(const char *feature_name, const char *table_el_name, uint8_t *size)
+{
+	pfe_fw_feature_t	*fw_feature;
+	pfe_fw_tbl_handle_t	fw_feature_table_cfg;
+	errno_t				ret = EOK;
+
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name || NULL == table_el_name || NULL == size)
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		ret = EINVAL;
+	}
+	else
+#endif
+	{
+		ret = pfe_feature_mgr_table_parent_inst(feature_name, &fw_feature);
+		if (EOK == ret)
+		{
+			ret = pfe_fw_feature_table_cfg_by_name(fw_feature, table_el_name, &fw_feature_table_cfg);
+			if (EOK == ret)
+			{
+				*size = pfe_fw_feature_table_entry_size(fw_feature_table_cfg);
+			}
+		}
+	}
+	return ret;
+}
+
+/**
+ * @brief		Reads the config table element multiplicity
+ * @param[in]	feature_name Name of the feature to be read
+ * @param[in]	table_el_name Name of the table element to be read
+ * @param[out]	count The read value of the table element multiplicity
+ * @return		EOK or failure code.
+ */
+static errno_t pfe_feature_mgr_table_cfg_get_multiplicity(const char *feature_name, const char *table_el_name, uint8_t *count)
+{
+	pfe_fw_feature_t	*fw_feature;
+	pfe_fw_tbl_handle_t	fw_feature_table_cfg;
+	errno_t				ret = EOK;
+
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name || NULL == table_el_name || NULL == count)
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		ret = EINVAL;
+	}
+	else
+#endif
+	{
+		ret = pfe_feature_mgr_table_parent_inst(feature_name, &fw_feature);
+		if (EOK == ret)
+		{
+			ret = pfe_fw_feature_table_cfg_by_name(fw_feature, table_el_name, &fw_feature_table_cfg);
+			if (EOK == ret)
+			{
+				*count = pfe_fw_feature_table_entry_multiplicity(fw_feature_table_cfg);
+			}
+		}
+	}
+	return ret;
+}
+
+/**
+ * @brief		Reads the config table element payload
+ * @param[in]	feature_name Name of the feature to be read
+ * @param[in]	table_el_name Name of the table element to be read
+ * @param[out]	payload The read value of the table element payload
+ * @return		EOK or failure code.
+ */
+static errno_t pfe_feature_mgr_table_cfg_get_payload(const char *feature_name, const char *table_el_name, uint8_t *payload)
+{
+
+	pfe_fw_feature_t	*fw_feature;
+	pfe_fw_tbl_handle_t	fw_feature_table_cfg;
+	errno_t				ret = EOK;
+
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name || NULL == table_el_name || NULL == payload)
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		ret = EINVAL;
+	}
+	else
+#endif
+	{
+		ret = pfe_feature_mgr_table_parent_inst(feature_name, &fw_feature);
+		if (EOK == ret)
+		{
+			ret = pfe_fw_feature_table_cfg_by_name(fw_feature, table_el_name, &fw_feature_table_cfg);
+			if (EOK == ret)
+			{
+				pfe_fw_feature_table_entry_get(fw_feature_table_cfg, payload,
+						pfe_fw_feature_table_entry_allocsize(fw_feature_table_cfg), FALSE);
+			}
+		}
+	}
+ 	return ret;
+}
+
+/**
+ * @brief		Reads the stats table element size
+ * @param[in]	feature_name Name of the feature to be read
+ * @param[in]	table_el_name Name of the table element to be read
+ * @param[out]	size The read value of the table element size
+ * @return		EOK or failure code.
+ */
+static errno_t pfe_feature_mgr_table_stats_get_size(const char *feature_name, const char *table_el_name, uint8_t *size)
+{
+	pfe_fw_feature_t	*fw_feature;
+	pfe_fw_tbl_handle_t	fw_feature_table_stats;
+	errno_t				ret = EOK;
+
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name || NULL == table_el_name || NULL == size)
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		ret = EINVAL;
+	}
+	else
+#endif
+	{
+		ret = pfe_feature_mgr_table_parent_inst(feature_name, &fw_feature);
+		if (EOK == ret)
+		{
+			ret = pfe_fw_feature_table_stats_by_name(fw_feature, table_el_name, &fw_feature_table_stats);
+			if (EOK == ret)
+			{
+				*size = pfe_fw_feature_table_entry_size(fw_feature_table_stats);
+			}
+		}
+	}
+	return ret;
+}
+
+/**
+ * @brief		Reads the stats table element multiplicity
+ * @param[in]	feature_name Name of the feature to be read
+ * @param[in]	table_el_name Name of the table element to be read
+ * @param[out]	count The read value of the table element multiplicity
+ * @return		EOK or failure code.
+ */
+static errno_t pfe_feature_mgr_table_stats_get_multiplicity(const char *feature_name, const char *table_el_name, uint8_t *count)
+{
+	pfe_fw_feature_t	*fw_feature;
+	pfe_fw_tbl_handle_t	fw_feature_table_stats;
+	errno_t				ret = EOK;
+
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name || NULL == table_el_name || NULL == count)
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		ret = EINVAL;
+	}
+	else
+#endif
+	{
+		ret = pfe_feature_mgr_table_parent_inst(feature_name, &fw_feature);
+		if (EOK == ret)
+		{
+			ret = pfe_fw_feature_table_stats_by_name(fw_feature, table_el_name, &fw_feature_table_stats);
+			if (EOK == ret)
+			{
+				*count = pfe_fw_feature_table_entry_multiplicity(fw_feature_table_stats);
+			}
+		}
+	}
+	return ret;
+}
+
+/**
+ * @brief		Reads the stats table element payload
+ * @param[in]	feature_name Name of the feature to be read
+ * @param[in]	table_el_name Name of the table element to be read
+ * @param[out]	payload The read value of the table element payload
+ * @return		EOK or failure code.
+ */
+static errno_t pfe_feature_mgr_table_stats_get_payload(const char *feature_name, const char *table_el_name, uint8_t *payload)
+{
+
+	pfe_fw_feature_t	*fw_feature;
+	pfe_fw_tbl_handle_t	fw_feature_table_stats;
+	errno_t			ret = EOK;
+
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name || NULL == table_el_name || NULL == payload)
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		ret = EINVAL;
+	}
+	else
+#endif
+	{
+		ret = pfe_feature_mgr_table_parent_inst(feature_name, &fw_feature);
+		if (EOK == ret)
+		{
+			ret = pfe_fw_feature_table_stats_by_name(fw_feature, table_el_name, &fw_feature_table_stats);
+			if (EOK == ret)
+			{
+				pfe_fw_feature_table_entry_get(fw_feature_table_stats, payload,
+						pfe_fw_feature_table_entry_allocsize(fw_feature_table_stats), TRUE);
+			}
+		}
+	}
+	return ret;
+}
+
+/**
+ * @brief		Reads the table element size
+ * @param[in]	feature_name Name of the feature to be read
+ * @param[in]   table_el_name Name of the table element to be read
+ * @param[in]   table_type In witch table the element is looked for
+ * @param[out]	size The read value of the table element size
+ * @return		EOK or failure code.
+ */
+errno_t pfe_feature_mgr_table_get_size(const char *feature_name, uint8_t table_type, const char *table_el_name, uint8_t *size)
+{
+	errno_t ret = EOK;
+	
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name || NULL == table_el_name || NULL == size)
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		ret = EINVAL;
+	}
+	else
+#endif
+	{
+		switch(table_type)
+		{
+			case FW_FEATURE_TABLE_DEFAULT:
+				ret = pfe_feature_mgr_table_cfg_get_size(feature_name, table_el_name, size);
+				if (EOK != ret)
+				{
+					ret = pfe_feature_mgr_table_stats_get_size(feature_name, table_el_name, size);
+				}
+				break;
+			case FW_FEATURE_TABLE_CONFIG:
+				ret = pfe_feature_mgr_table_cfg_get_size(feature_name, table_el_name, size);
+				break;
+			case FW_FEATURE_TABLE_STATS:
+				ret = pfe_feature_mgr_table_stats_get_size(feature_name, table_el_name, size);
+				break;
+			default:
+				ret = EINVAL;
+		}
+	}
+	return ret;
+}
+
+/**
+ * @brief		Reads the table element multiplicity
+ * @param[in]	feature_name Name of the feature to be read
+ * @param[in]	table_el_name Name of the table element to be read
+ * @param[in]	table_type In witch table the element is looked for
+ * @param[out]	count The read value of the table element multiplicity
+ * @return		EOK or failure code.
+ */
+errno_t pfe_feature_mgr_table_get_multiplicity(const char *feature_name, uint8_t table_type, const char *table_el_name, uint8_t *count)
+{
+	errno_t ret = EOK;
+	
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name || NULL == table_el_name || NULL == count)
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		ret = EINVAL;
+	}
+	else
+#endif
+	{
+		switch(table_type)
+		{
+			case FW_FEATURE_TABLE_DEFAULT:
+				ret = pfe_feature_mgr_table_cfg_get_multiplicity(feature_name, table_el_name, count);
+				if (EOK != ret)
+				{
+					ret = pfe_feature_mgr_table_stats_get_multiplicity(feature_name, table_el_name, count);
+				}
+				break;
+			case FW_FEATURE_TABLE_CONFIG:
+				ret = pfe_feature_mgr_table_cfg_get_multiplicity(feature_name, table_el_name, count);
+				break;
+			case FW_FEATURE_TABLE_STATS:
+				ret = pfe_feature_mgr_table_stats_get_multiplicity(feature_name, table_el_name, count);
+				break;
+			default:
+				ret = EINVAL;
+		}
+	}
+	return ret;
+}
+
+/**
+ * @brief		Reads the table element payload
+ * @param[in]	feature_name Name of the feature to be read
+ * @param[in]	table_el_name Name of the table element to be read
+ * @param[in]	table_type In witch table the element is looked for
+ * @param[out]	payload The read value of the table element payload
+ * @return		EOK or failure code.
+ */
+errno_t pfe_feature_mgr_table_get_payload(const char *feature_name, uint8_t table_type, const char *table_el_name, uint8_t *payload)
+{
+	errno_t ret = EOK;
+
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (NULL == feature_name || NULL == table_el_name || NULL == count)
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		ret = EINVAL;
+	}
+	else
+#endif
+	{
+		switch(table_type)
+		{
+			case FW_FEATURE_TABLE_DEFAULT:
+				ret = pfe_feature_mgr_table_cfg_get_payload(feature_name, table_el_name, payload);
+				if (EOK != ret)
+				{
+					ret = pfe_feature_mgr_table_stats_get_payload(feature_name, table_el_name, payload);
+				}
+				break;
+			case FW_FEATURE_TABLE_CONFIG:
+				ret = pfe_feature_mgr_table_cfg_get_payload(feature_name, table_el_name, payload);
+				break;
+			case FW_FEATURE_TABLE_STATS:
+				ret = pfe_feature_mgr_table_stats_get_payload(feature_name, table_el_name, payload);
+				break;
+			default:
+				ret = EINVAL;
+		}
+	}
+	return ret;
+}
+
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
 #include "Eth_43_PFE_MemMap.h"
diff --git a/sw/pfe_platform/src/pfe_fw_feature.c b/sw/pfe_platform/src/pfe_fw_feature.c
index 291a122..ade878e 100644
--- a/sw/pfe_platform/src/pfe_fw_feature.c
+++ b/sw/pfe_platform/src/pfe_fw_feature.c
@@ -15,13 +15,23 @@
 
 struct pfe_fw_feature_tag
 {
-	pfe_ct_feature_desc_t *ll_data;
+	union {
+		pfe_ct_feature_desc_t *data;
+		pfe_ct_feature_desc_ext_t *data_ext;
+	} ll;
 	const char *string_base;
 	dmem_read_func_t dmem_read_func;
 	dmem_write_func_t dmem_write_func;
 	void *dmem_rw_func_data;
+	uint8_t current_cfg;
+	uint8_t current_stats;
+	uint8_t instances;
 };
 
+#define UINT_8_SIZE		1
+#define UINT_16_SIZE	2
+#define UINT_32_SIZE	4
+
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_START_SEC_CODE
 #include "Eth_43_PFE_MemMap.h"
@@ -68,9 +78,10 @@ void pfe_fw_feature_destroy(const pfe_fw_feature_t *feature)
  * @brief Sets reference to low level data in obtained from PE
  * @param[in] feature Feature to set the low level data
  * @param[in] ll_data Low level data to set
+ * @param[in] instances of processing
  * @return EOK or an error code.
  */
-errno_t pfe_fw_feature_set_ll_data(pfe_fw_feature_t *feature, pfe_ct_feature_desc_t *ll_data)
+errno_t pfe_fw_feature_set_ll_data(pfe_fw_feature_t *feature, pfe_ct_feature_desc_t *ll_data, uint8_t instances)
 {
 	errno_t ret;
 #if defined(PFE_CFG_NULL_ARG_CHECK)
@@ -82,7 +93,8 @@ errno_t pfe_fw_feature_set_ll_data(pfe_fw_feature_t *feature, pfe_ct_feature_des
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		feature->ll_data = ll_data;
+		feature->ll.data = ll_data;
+		feature->instances = instances;
 		ret = EOK;
 	}
 	return ret;
@@ -162,7 +174,7 @@ errno_t pfe_fw_feature_get_name(const pfe_fw_feature_t *feature, const char **na
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		*name = feature->string_base + oal_ntohl(feature->ll_data->name);
+		*name = feature->string_base + oal_ntohl(feature->ll.data->name);
 		ret = EOK;
 	}
 	return ret;
@@ -186,7 +198,7 @@ errno_t pfe_fw_feature_get_desc(const pfe_fw_feature_t *feature, const char **de
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		*desc = feature->string_base + oal_ntohl(feature->ll_data->description);
+		*desc = feature->string_base + oal_ntohl(feature->ll.data->description);
 		ret = EOK;
 	}
 	return ret;
@@ -210,7 +222,7 @@ errno_t pfe_fw_feature_get_flags(const pfe_fw_feature_t *feature, pfe_ct_feature
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		*flags = feature->ll_data->flags;
+		*flags = feature->ll.data->flags;
 		ret = EOK;
 	}
 	return ret;
@@ -290,7 +302,7 @@ errno_t pfe_fw_feature_get_def_val(const pfe_fw_feature_t *feature, uint8_t *def
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		*def_val = feature->ll_data->def_val;
+		*def_val = feature->ll.data->def_val;
 		ret = EOK;
 	}
 	return ret;
@@ -314,7 +326,7 @@ errno_t pfe_fw_feature_get_val(const pfe_fw_feature_t *feature, uint8_t *val)
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		ret = feature->dmem_read_func(feature->dmem_rw_func_data, 0U, val, (addr_t)oal_ntohl(feature->ll_data->position), sizeof(uint8_t));
+		ret = feature->dmem_read_func(feature->dmem_rw_func_data, 0U, val, (addr_t)oal_ntohl(feature->ll.data->position), sizeof(uint8_t));
 	}
 	return ret;
 }
@@ -379,8 +391,389 @@ errno_t pfe_fw_feature_set_val(const pfe_fw_feature_t *feature, uint8_t val)
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		ret = feature->dmem_write_func(feature->dmem_rw_func_data, -1, (addr_t)oal_ntohl(feature->ll_data->position), (void *)&val, sizeof(uint8_t));
+		ret = feature->dmem_write_func(feature->dmem_rw_func_data, -1, (addr_t)oal_ntohl(feature->ll.data->position), (void *)&val, sizeof(uint8_t));
+	}
+	return ret;
+}
+
+/**
+ * @brief Search feature entry table by name
+ * @param[in] handle to the first table element
+ * @param[in] name to be searched
+ * @return EOK or an error code
+ */
+static errno_t pfe_fw_feature_table_entry_by_name(pfe_fw_tbl_handle_t *handle, const char_t *name)
+{
+	pfe_ct_feature_tbl_entry_t * tbl_curr;
+	errno_t ret = ENOENT;
+
+	if(NULL != handle->tbl_curr)
+	{
+		tbl_curr = handle->tbl_curr;
+
+		while(tbl_curr->name[0] != '\0')
+		{
+			if(0 == strcmp(name, tbl_curr->name))
+			{
+				handle->tbl_curr = tbl_curr;
+				ret = EOK;
+			}
+			tbl_curr++;
+		}
+	}
+
+	return ret;
+}
+
+/**
+ * @brief Search feature entry in config table by name
+ * @param[in] feature Feature to be searched
+ * @param[in] name to be searched
+ * @param[out] entry table handle of the search element
+ * @return EOK or an error code
+ */
+errno_t pfe_fw_feature_table_cfg_by_name(const pfe_fw_feature_t *feature, const char *name, pfe_fw_tbl_handle_t *entry)
+{
+	pfe_fw_tbl_handle_t handle;
+	errno_t ret;
+
+	handle.tbl_curr = (pfe_ct_feature_tbl_entry_t *)(uintptr_t)(feature->string_base + oal_ntohl(feature->ll.data_ext->cfg));
+	handle.feature = feature;
+
+	ret = pfe_fw_feature_table_entry_by_name(&handle, name);
+
+	if (ret == EOK)
+	{
+		*entry = handle;
+	}
+
+	return ret;
+}
+
+/*
+ * @brief Search feature entry in stats table by name
+ * @param[in] feature Feature to be searched
+ * @param[in] name to be searched
+ * @param[out] entry table handle of the search element
+ * @return EOK or an error code
+ */
+errno_t pfe_fw_feature_table_stats_by_name(const pfe_fw_feature_t *feature, const char* name, pfe_fw_tbl_handle_t *entry)
+{
+	pfe_fw_tbl_handle_t handle;
+	errno_t ret;
+
+	handle.tbl_curr = (pfe_ct_feature_tbl_entry_t *)(uintptr_t)(feature->string_base + oal_ntohl(feature->ll.data_ext->stats));
+	handle.feature = feature;
+
+	ret = pfe_fw_feature_table_entry_by_name(&handle, name);
+
+	if(ret == EOK)
+	{
+		*entry = handle;
+	}
+	return ret;
+}
+
+/*
+ * @brief Returns first entry of the config table
+ * @param[in] feature Feature from witch to get config table
+ * @param[out] feature_table table handle of the first entry
+ * @return EOK or an error code
+ */
+errno_t pfe_fw_feature_table_cfg_first(pfe_fw_feature_t *feature, pfe_fw_tbl_handle_t *feature_table)
+{
+	errno_t ret = ENOENT;
+
+	if(0 != feature->ll.data_ext->cfg)
+	{
+		feature_table->feature = feature;
+		feature->current_cfg = 0;
+		feature_table->tbl_curr = (pfe_ct_feature_tbl_entry_t *)(uintptr_t)(feature->string_base + oal_ntohl(feature->ll.data_ext->cfg));
+		ret = EOK;
 	}
+
+	return ret;
+}
+
+/*
+ * @brief Returns next entry of the config table
+ * @param[in] feature Feature from witch to get config table
+ * @param[out] feature_table table handle of the next entry
+ * @return EOK or an error code
+ */
+errno_t pfe_fw_feature_table_cfg_next(pfe_fw_feature_t *feature, pfe_fw_tbl_handle_t *feature_table)
+{
+	errno_t ret = ENOENT;
+
+	if(0 != feature->ll.data_ext->cfg)
+	{
+		feature_table->feature = feature;
+		feature->current_cfg ++;
+		feature_table->tbl_curr = (pfe_ct_feature_tbl_entry_t *)(uintptr_t)(feature->string_base + oal_ntohl(feature->ll.data_ext->cfg) + feature->current_cfg*sizeof(pfe_ct_feature_tbl_entry_t));
+		if(feature_table->tbl_curr->name[0] != '\0')
+		{
+			ret = EOK;
+		}
+	}
+
+	return ret;
+}
+
+/*
+ * @brief Returns first entry of the stats table
+ * @param[in] feature Feature from witch to get stats table
+ * @param[out] feature_table table handle of the first entry
+ * @return EOK or an error code
+ */
+errno_t pfe_fw_feature_table_stats_first(pfe_fw_feature_t *feature, pfe_fw_tbl_handle_t *feature_table)
+{
+	errno_t ret = ENOENT;
+
+	if(0 != feature->ll.data_ext->stats)
+	{
+		feature_table->feature = feature;
+		feature->current_stats = 0;
+		feature_table->tbl_curr = (pfe_ct_feature_tbl_entry_t *)(uintptr_t)(feature->string_base + oal_ntohl(feature->ll.data_ext->stats));
+		ret = EOK;
+	}
+
+	return ret;
+}
+
+/*
+ * @brief Returns next entry of the stats table
+ * @param[in] feature Feature from witch to get stats table
+ * @param[out] feature_table table handle of the next entry
+ * @return EOK or an error code
+ */
+errno_t pfe_fw_feature_table_stats_next(pfe_fw_feature_t *feature, pfe_fw_tbl_handle_t *feature_table)
+{
+	errno_t ret = ENOENT;
+
+	if(0 != feature->ll.data_ext->stats)
+	{
+		feature_table->feature = feature;
+		feature->current_stats ++;
+		feature_table->tbl_curr = (pfe_ct_feature_tbl_entry_t *)(uintptr_t)(feature->string_base + oal_ntohl(feature->ll.data_ext->stats) + feature->current_stats*sizeof(pfe_ct_feature_tbl_entry_t));
+		if(feature_table->tbl_curr->name[0] != '\0')
+		{
+			ret = EOK;
+		}
+	}
+
+	return ret;
+}
+
+/*
+ * @brief Returns the name of the element handle
+ * @param[in] handle Table element handle
+ * @param[out] table_name name of the element
+ * @return EOK
+ */
+errno_t pfe_fw_feature_table_entry_name(pfe_fw_tbl_handle_t handle, const char **table_name)
+{
+	*table_name = handle.tbl_curr->name;
+
+	return EOK;
+}
+
+/*
+ * @brief Returns the size of the element handle
+ * @param[in] handle Table element handle
+ * @return size of the element
+ */
+uint32_t pfe_fw_feature_table_entry_size(pfe_fw_tbl_handle_t handle)
+{
+	return handle.tbl_curr->size;
+}
+
+/*
+ * @brief Returns the multiplicity of the element handle
+ * @param[in] handle Table element handle
+ * @return multiplicity of the element
+ */
+uint32_t pfe_fw_feature_table_entry_multiplicity(pfe_fw_tbl_handle_t handle)
+{
+	return handle.tbl_curr->multiplicity;
+}
+
+/*
+ * @brief Returns the allocation size of the payload
+ * @param[in] handle Table element handle
+ * @return allocation size of the payload
+ */
+uint32_t pfe_fw_feature_table_entry_allocsize(pfe_fw_tbl_handle_t handle)
+{
+	return handle.tbl_curr->size * handle.tbl_curr->multiplicity;
+}
+
+/*
+ * @brief Sets the table entry payload
+ * @param[in] handle Feature table entry on witch to set the value
+ * @param[in] val    Value to be set
+ * @param[in] size   Size of the value to be set
+ * @return EOK or an error code
+ */
+errno_t pfe_fw_feature_table_entry_set(pfe_fw_tbl_handle_t handle, void *val, uint16_t size)
+{
+	errno_t ret;
+	uint8_t idx;
+	void   *ptr;
+
+	switch (pfe_fw_feature_table_entry_size(handle))
+	{
+		case UINT_16_SIZE: 
+			for (idx = 0; idx < size/pfe_fw_feature_table_entry_size(handle); idx++)
+			{
+				ptr = val + idx * sizeof(uint16_t);
+				*(uint16_t *)ptr = oal_ntohs(*(uint16_t *)ptr);
+			}
+			break;
+		case UINT_32_SIZE:
+			for (idx = 0; idx < size/pfe_fw_feature_table_entry_size(handle); idx++)
+ 			{
+				ptr = val + idx * sizeof(uint32_t);
+				*(uint32_t *)ptr = oal_ntohl(*(uint32_t *) ptr);
+			}
+			break;
+ 	}
+
+	ret = handle.feature->dmem_write_func(handle.feature->dmem_rw_func_data, -1, (addr_t)oal_ntohl(handle.tbl_curr->data), (void *)val, size);
+
+	return ret;
+}
+
+/*
+ * @brief Gets the table entry payload
+ * @param[in] handle Feature table entry from witch to get the payload
+ * @param[in] mem    memory where we write the read values
+ * @param[in] size   Size of the value to be read
+ * @param[in] collect Read the values from one/all PE cores 
+ * @return EOK or an error code
+ */
+errno_t pfe_fw_feature_table_entry_get(pfe_fw_tbl_handle_t handle, void *mem, uint16_t size, bool_t collect)
+{
+	errno_t ret;
+	uint8_t idx;
+	void  *ptr;
+
+	if(FALSE == collect)
+	{
+		ret =  handle.feature->dmem_read_func(handle.feature->dmem_rw_func_data, 0U, mem, (addr_t)oal_ntohl(handle.tbl_curr->data), size);
+
+		if (EOK == ret)
+		{
+			for (idx = 0; idx < size/pfe_fw_feature_table_entry_size(handle); idx++)
+			{
+				ptr = mem + idx * pfe_fw_feature_table_entry_size(handle);
+				switch (pfe_fw_feature_table_entry_size(handle))
+				{
+					case UINT_16_SIZE:
+							*(uint16_t *)ptr = oal_ntohs(*(uint16_t *)ptr);
+						break;
+					case UINT_32_SIZE:
+							*(uint32_t *)ptr = oal_ntohl(*(uint32_t *) ptr);
+						break;
+				}
+			}
+		}
+	}
+	else
+	{
+		for(idx = 0; idx < size/pfe_fw_feature_table_entry_size(handle); idx++)
+		{
+			ptr = mem + idx * pfe_fw_feature_table_entry_size(handle);
+			ret = pfe_fw_feature_table_entry_get_by_idx(handle, ptr, idx, collect);
+		}
+	}
+
+	return ret;
+}
+
+/*
+ * @brief Sets the table entry payload at a specific index
+ * @param[in] handle Feature table entry on witch to set the value
+ * @param[in] val    Value to be set
+ * @param[in] idx    Index of the vector to set the value
+ * @return EOK or an error code
+ */
+errno_t pfe_fw_feature_table_entry_set_by_idx(pfe_fw_tbl_handle_t handle, void *val, uint16_t idx)
+{
+	errno_t ret = EINVAL;
+
+	if( idx < pfe_fw_feature_table_entry_multiplicity(handle))
+	{
+		switch (pfe_fw_feature_table_entry_size(handle))
+		{
+			case UINT_16_SIZE:
+				*(uint16_t*)val = oal_htons(*(uint16_t *) val);
+				break;
+			case UINT_32_SIZE:
+				*(uint32_t*)val = oal_htonl(*(uint32_t *) val);
+				break;
+		}
+		ret = handle.feature->dmem_write_func(handle.feature->dmem_rw_func_data, -1, (addr_t)oal_ntohl(handle.tbl_curr->data) + idx * handle.tbl_curr->size, (void *)val, handle.tbl_curr->size);
+	}
+
+	return ret;
+}
+
+/*
+ * @brief Gets the table entry payload at a specific index
+ * @param[in] handle Feature table entry on witch to get the vale
+ * @param[in] mem    Memory where to put the value
+ * @param[in] idx    Index of the vector to set the value
+ * @param[in] collect Read the data from one/all PE cores
+ * @return EOK or an error code
+ */
+errno_t pfe_fw_feature_table_entry_get_by_idx(pfe_fw_tbl_handle_t handle, void *mem, uint16_t idx, bool_t collect)
+{
+	errno_t ret = EINVAL;
+	uint8_t pe_idx = 0;
+	uint8_t pe_idx_max = 1;
+	uint8_t val8 = 0;
+	uint16_t val16 = 0;
+	uint32_t val32 = 0;
+
+	if(TRUE == collect)
+	{
+		pe_idx_max = handle.feature->instances;
+	}
+
+	if( idx < pfe_fw_feature_table_entry_multiplicity(handle))
+	{
+		for(pe_idx = 0; pe_idx < pe_idx_max; pe_idx++)
+		{
+			ret = handle.feature->dmem_read_func(handle.feature->dmem_rw_func_data, pe_idx, mem, (addr_t)oal_ntohl(handle.tbl_curr->data) + idx * handle.tbl_curr->size, handle.tbl_curr->size);
+
+			switch (pfe_fw_feature_table_entry_size(handle))
+			{
+				case UINT_8_SIZE:
+					val8 += *(uint8_t *)mem;
+					break;
+				case UINT_16_SIZE:
+					val16 += oal_htons(*(uint16_t *) mem);
+					break;
+				case UINT_32_SIZE:
+					val32 += oal_htonl(*(uint32_t *) mem);
+					break;
+			}
+		}
+
+		switch (pfe_fw_feature_table_entry_size(handle))
+		{
+			case UINT_8_SIZE:
+				*(uint8_t*)mem = val8;
+				break;
+			case UINT_16_SIZE:
+				*(uint16_t*)mem = val16;
+				break;
+			case UINT_32_SIZE:
+				*(uint32_t*)mem = val32;
+				break;
+		}
+	}
+
 	return ret;
 }
 
diff --git a/sw/pfe_platform/src/pfe_pe.c b/sw/pfe_platform/src/pfe_pe.c
index 49f5983..72f1ee9 100644
--- a/sw/pfe_platform/src/pfe_pe.c
+++ b/sw/pfe_platform/src/pfe_pe.c
@@ -13,7 +13,6 @@
 
 #include "pfe_platform.h"
 #include "elf_cfg.h"
-#include <uapi/linux/elf.h>
 #include "elf.h"
 #include "pfe_cbus.h"
 #include "pfe_pe.h"
@@ -21,6 +20,8 @@
 
 #define BYTES_TO_4B_ALIGNMENT(x)	(4U - ((x) & 0x3U))
 #define INVALID_FEATURES_BASE 		0xFFFFFFFFU
+#define ALIGNMENT_CHECKMASK			0x3U
+#define ALIGNMENT_PACKEDNUMBER		4U
 /**
  * @brief	Mutex protecting access to common mem_access_* registers
  */
@@ -156,7 +157,7 @@ static addr_t pfe_pe_get_elf_sect_load_addr(const ELF_File_t *elf_file, const El
 static errno_t pfe_pe_fw_ops_valid(pfe_pe_t *pe1, const pfe_pe_t *pe2);
 static errno_t pfe_pe_fw_install_ops(pfe_pe_t **pe, uint8_t pe_num);
 static uint32_t pfe_pe_mem_read(pfe_pe_t *pe, pfe_pe_mem_t mem, addr_t addr, uint8_t size);
-static void pfe_pe_mem_write(pfe_pe_t *pe, pfe_pe_mem_t mem, uint32_t val, addr_t addr, uint8_t size);
+static void pfe_pe_mem_write(pfe_pe_t *pe, pfe_pe_mem_t mem, uint32_t val, addr_t addr, uint8_t size, uint8_t offset);
 static inline uint32_t pfe_pe_get_u32_from_byteptr(const uint8_t *src_byteptr, uint32_t len);
 static errno_t pfe_pe_load_dmem_section_nolock(pfe_pe_t *pe, const void *sdata, addr_t addr, addr_t size, uint32_t type);
 static errno_t pfe_pe_load_imem_section_nolock(pfe_pe_t *pe, const void *data, addr_t addr, addr_t size, uint32_t type);
@@ -992,16 +993,15 @@ static uint32_t pfe_pe_mem_read(pfe_pe_t *pe, pfe_pe_mem_t mem, addr_t addr, uin
  * @param[in]	addr Write address (should be aligned to 32 bits)
  * @param[in]	val Value to write (BE)
  * @param[in]	size Number of bytes to write (maximum 4)
+ * @param[in]	offset Number of bytes the addr needs to be aligned (maximum 3)
  */
-static void pfe_pe_mem_write(pfe_pe_t *pe, pfe_pe_mem_t mem, uint32_t val, addr_t addr, uint8_t size)
+static void pfe_pe_mem_write(pfe_pe_t *pe, pfe_pe_mem_t mem, uint32_t val, addr_t addr, uint8_t size, uint8_t offset)
 {
 	uint8_t bytesel = 0U;
-	uint32_t memsel;
-	uint8_t offset;
+	uint32_t memsel = 0U;
 	uint32_t val_temp = val;
 	uint8_t size_temp = size;
 	addr_t addr_temp = addr;
-	bool_t status = FALSE;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == pe))
@@ -1011,63 +1011,42 @@ static void pfe_pe_mem_write(pfe_pe_t *pe, pfe_pe_mem_t mem, uint32_t val, addr_
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		if (unlikely((addr_temp & 0x3U) != 0U))
+		if (unlikely((0U != offset)))
 		{
-			offset = BYTES_TO_4B_ALIGNMENT(addr_temp);
-
-			if (size_temp <= offset)
-			{
-				/*	Move the value to the desired address offset */
-				val_temp = val << (8U * (addr_temp & 0x3U));
-				/*	Enable writes of depicted bytes */
-				bytesel = (((1U << size_temp) - 1U) << (offset - size_temp));
-			}
-			else
-			{
-				/*	Here we need to split the write into two writes */
-
-				/*	Write 1 (LS bytes). Recursive call. Limited to single recursion. */
-				pfe_pe_mem_write(pe, mem, val_temp, addr, offset);
-				val_temp >>= 8U * offset;
-				size_temp = size - offset;
-				addr_temp = addr + offset;
-
-				/*	Write 2 (MS bytes). Recursive call. Limited to single recursion. */
-				pfe_pe_mem_write(pe, mem, val_temp, addr_temp, size_temp);
-				status = TRUE;
-			}
+			/* Move the value to the desired address offset */
+			val_temp = val << (8U * (addr_temp & ALIGNMENT_CHECKMASK));
+			/* Enable writes of depicted bytes */
+			bytesel = (1U << (offset - size_temp));
 		}
 		else
 		{
 			/*	Destination is aligned */
 			bytesel = (uint8_t)PE_IBUS_BYTES(size_temp);
 		}
-		if(status == FALSE)
-		{
-			if (PFE_PE_DMEM == mem)
-			{
-				memsel = PE_IBUS_ACCESS_DMEM;
-			}
-			else
-			{
-				memsel = PE_IBUS_ACCESS_IMEM;
-			}
 
-			addr_temp = (addr_temp & 0xfffffU)
-					| PE_IBUS_WRITE
-					| memsel
-					| PE_IBUS_PE_ID(pe->id)
-					| PE_IBUS_WREN(bytesel);
+		if (PFE_PE_DMEM == mem)
+		{
+			memsel = PE_IBUS_ACCESS_DMEM;
+		}
+		else
+		{
+			memsel = PE_IBUS_ACCESS_IMEM;
+		}
 
-			/*	Sanity check if we can safely access the memory interface */
-			if (unlikely(!pe->miflock))
-			{
-				NXP_LOG_ERROR("Accessing unlocked PE memory interface (write).\n");
-			}
+		addr_temp = (addr_temp & 0xfffffU)
+				| PE_IBUS_WRITE
+				| memsel
+				| PE_IBUS_PE_ID(pe->id)
+				| PE_IBUS_WREN(bytesel);
 
-			hal_write32(oal_htonl(val_temp), pe->mem_access_wdata);
-			hal_write32((uint32_t)addr_temp, pe->mem_access_addr);
+		/*	Sanity check if we can safely access the memory interface */
+		if (unlikely(!pe->miflock))
+		{
+			NXP_LOG_ERROR("Accessing unlocked PE memory interface (write).\n");
 		}
+
+		hal_write32(oal_htonl(val_temp), pe->mem_access_wdata);
+		hal_write32((uint32_t)addr_temp, pe->mem_access_addr);
 	}
 }
 
@@ -1129,55 +1108,33 @@ static void pfe_pe_memcpy_from_host_to_dmem_32_nolock(
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		if ((dst_temp & 0x3U) != 0U)
+		/* First loop is for the unaligned dst_addr */
+		/* It fills the offset with one by one byte taken from src_ptr */
+		while ((0U != (dst_temp & ALIGNMENT_CHECKMASK)) && (0U != len_temp))
 		{
-			/*	Write unaligned bytes to align the destination address */
 			offset = BYTES_TO_4B_ALIGNMENT(dst_temp);
-			offset = (len < offset) ? len : offset;
-			/* Check if src_byteptr is 4 bytes alignment */
-			if (((uintptr_t)src_byteptr & 0x3U) == 0U)
-			{
-				/* src_byteptr aligns 4 bytes */
-				val = pfe_pe_get_u32_from_byteptr(src_byteptr, len);
-			}
-			else
-			{
-				/* src_byteptr doesn't align 4 bytes : access each byte */
-				val =  ((uint32_t)*(src_byteptr + 0U)) << 0U;
-				if (2U <= len)
-				{
-					val += ((uint32_t)*(src_byteptr + 1U)) << 8U;
-				}
-				if (3U <= len)
-				{
-					val += ((uint32_t)*(src_byteptr + 2U)) << 16U;
-				}
-				if (4U <= len)
-				{
-					val += ((uint32_t)*(src_byteptr + 3U)) << 24U;
-				}
-			}
-			pfe_pe_mem_write(pe, PFE_PE_DMEM, val, dst_temp, (uint8_t)offset);
-			src_byteptr += offset;
-			dst_temp = dst_addr + offset;
-			len_temp = (len >= offset) ? (len - offset) : 0U;
+			val = *src_byteptr;
+			pfe_pe_mem_write(pe, PFE_PE_DMEM, val, dst_temp, 1U, offset);
+			dst_temp += 1U;
+			src_byteptr += 1U;
+			len_temp -= 1U;
 		}
-
-		while (len_temp>=4U)
+		/* Second loops if to write the data with 4 bytes each time to the aligned address */
+		while (ALIGNMENT_PACKEDNUMBER <= len_temp)
 		{
 			/*	4-byte writes */
 			val = *(uint32_t *)src_byteptr;
-			pfe_pe_mem_write(pe, PFE_PE_DMEM, val, (uint32_t)dst_temp, 4U);
-			len_temp-=4U;
-			src_byteptr+=4U;
-			dst_temp+=4U;
+			pfe_pe_mem_write(pe, PFE_PE_DMEM, val, (uint32_t)dst_temp, 4U, 0U);
+			len_temp -= 4U;
+			src_byteptr += 4U;
+			dst_temp += 4U;
 		}
-
+		/* The last step is to write the trailing last data to the aligned address */
 		if (0U != len_temp)
 		{
 			/*	The rest */
 			val = pfe_pe_get_u32_from_byteptr(src_byteptr, len_temp);
-			pfe_pe_mem_write(pe, PFE_PE_DMEM, val, (uint32_t)dst_temp, (uint8_t)len_temp);
+			pfe_pe_mem_write(pe, PFE_PE_DMEM, val, (uint32_t)dst_temp, (uint8_t)len_temp, 0U);
 		}
 	}
 }
diff --git a/sw/pfe_platform/src/pfe_rtable.c b/sw/pfe_platform/src/pfe_rtable.c
index 98113d2..e38e3bd 100644
--- a/sw/pfe_platform/src/pfe_rtable.c
+++ b/sw/pfe_platform/src/pfe_rtable.c
@@ -96,11 +96,11 @@ struct pfe_rtable_tag
  */
 struct pfe_rtable_entry_tag
 {
-	pfe_rtable_t *rtable;						/*	!< Reference to the parent table */
-	pfe_ct_rtable_entry_t *phys_entry;			/*	!< Pointer to the entry within the routing table */
-	pfe_ct_rtable_entry_t *temp_phys_entry;		/*	!< Temporary storage during entry creation process */
-	struct pfe_rtable_entry_tag *next;		/*	!< Pointer to the next entry within the routing table */
-	struct pfe_rtable_entry_tag *prev;		/*	!< Pointer to the previous entry within the routing table */
+	pfe_rtable_t *rtable;				/*	!< Reference to the parent table */
+	pfe_ct_rtable_entry_t *phys_entry_cache;	/*	!< Intermediate storage used for updating a physical entry */
+	addr_t phys_entry_va;				/*	!< The virtual address of the entry within the physical routing table */
+	struct pfe_rtable_entry_tag *next_ble;		/*	!< Pointer to the next entry from the same hash bucket */
+	struct pfe_rtable_entry_tag *prev_ble;		/*	!< Pointer to the previous entry from the same hash bucket */
 	struct pfe_rtable_entry_tag *child;		/*	!< Entry associated with this one (used to identify entries for 'reply' direction) */
 	uint32_t timeout;							/*	!< Timeout value in seconds */
 	uint32_t curr_timeout;						/*	!< Current timeout value */
@@ -113,14 +113,6 @@ struct pfe_rtable_entry_tag
 	LLIST_t list_to_remove_entry;				/*	!< Linked list element */
 };
 
-typedef struct
-{
-	pfe_ct_rtable_entry_t *new_phys_entry_va;
-	pfe_ct_rtable_entry_t *new_phys_entry_pa;
-	pfe_ct_rtable_entry_t *last_phys_entry_va;
-	uint32_t hash;
-} pfe_rtable_phys_entry_infor_t;
-
 /**
  * @brief	IP version type
  */
@@ -150,6 +142,7 @@ enum pfe_rtable_worker_signals
 #endif /* PFE_CFG_TARGET_OS_AUTOSAR */
 
 static uint8_t stats_tbl_index[PFE_CFG_CONN_STATS_SIZE + 1];
+static bool_t rtable_in_lmem;
 
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_VAR_CLEARED_8
@@ -172,24 +165,21 @@ static const pfe_ct_conntrack_stats_t pfe_rtable_clear_stats_stat = {0};
 
 static uint32_t pfe_get_crc32_be(uint32_t crc, uint8_t *data, uint16_t len);
 static void pfe_rtable_invalidate(pfe_rtable_t *rtable);
-static uint32_t pfe_rtable_entry_get_hash(pfe_rtable_entry_t *entry, pfe_ipv_type_t iptype, uint32_t hash_mask);
-static bool_t pfe_rtable_phys_entry_is_htable(const pfe_rtable_t *rtable, const pfe_ct_rtable_entry_t *phys_entry);
-static bool_t pfe_rtable_phys_entry_is_pool(const pfe_rtable_t *rtable, const pfe_ct_rtable_entry_t *phys_entry);
-static pfe_ct_rtable_entry_t *pfe_rtable_phys_entry_get_pa(pfe_rtable_t *rtable, pfe_ct_rtable_entry_t *phys_entry_va);
-static pfe_ct_rtable_entry_t *pfe_rtable_phys_entry_get_va(pfe_rtable_t *rtable, pfe_ct_rtable_entry_t *phys_entry_pa);
+static uint32_t pfe_rtable_entry_get_hash(pfe_ct_rtable_entry_t *phys_entry_cache, pfe_ipv_type_t iptype, uint32_t hash_mask);
+static bool_t pfe_rtable_phys_entry_is_htable(const pfe_rtable_t *rtable, addr_t phys_entry_addr);
+static bool_t pfe_rtable_phys_entry_is_pool(const pfe_rtable_t *rtable, addr_t phys_entry_addr);
+static addr_t pfe_rtable_phys_entry_get_pa(pfe_rtable_t *rtable, addr_t phys_entry_va);
+static addr_t pfe_rtable_phys_entry_get_va(pfe_rtable_t *rtable, addr_t phys_entry_pa);
 static errno_t pfe_rtable_del_entry_nolock(pfe_rtable_t *rtable, pfe_rtable_entry_t *entry);
 static bool_t pfe_rtable_match_criterion(pfe_rtable_get_criterion_t crit, const pfe_rtable_criterion_arg_t *arg, pfe_rtable_entry_t *entry);
 static bool_t pfe_rtable_entry_is_in_table(const pfe_rtable_entry_t *entry);
-static pfe_rtable_entry_t *pfe_rtable_get_by_phys_entry_va(const pfe_rtable_t *rtable, const pfe_ct_rtable_entry_t *phys_entry_va);
+static pfe_rtable_entry_t *pfe_rtable_get_by_phys_entry_va(const pfe_rtable_t *rtable, addr_t phys_entry_va);
 static uint32_t pfe_rtable_create_stats_table(pfe_class_t *class, uint16_t conntrack_count);
 static uint8_t pfe_rtable_get_free_stats_index(const pfe_rtable_t *rtable);
 static void pfe_rtable_free_stats_index(uint8_t index);
 static errno_t pfe_rtable_destroy_stats_table(pfe_class_t *class, uint32_t table_address);
 static bool_t pfe_rtable_entry_is_duplicate(pfe_rtable_t *rtable, pfe_rtable_entry_t *entry);
-static errno_t pfe_rtable_add_entry_get_phys_pa(pfe_rtable_t *rtable, pfe_rtable_phys_entry_infor_t *phys_entry_temp);
-static errno_t pfe_rtable_add_entry_link(pfe_rtable_t *rtable, pfe_rtable_phys_entry_infor_t *phys_entry_temp);
-static void pfe_rtable_add_entry_validate(pfe_rtable_t *rtable, pfe_rtable_entry_t *entry, pfe_rtable_phys_entry_infor_t *phys_entry_temp);
-static errno_t pfe_rtable_add_entry_id(pfe_rtable_t *rtable, pfe_rtable_entry_t *entry, pfe_rtable_phys_entry_infor_t *phys_entry_temp);
+static errno_t pfe_rtable_add_entry_by_hash(pfe_rtable_t *rtable, uint32_t hash, void **new_phys_entry_va, void **last_phys_entry_va, addr_t *new_phys_entry_pa);
 
 errno_t pfe_rtable_clear_stats(const pfe_rtable_t *rtable, uint8_t conntrack_index);
 #if !defined(PFE_CFG_TARGET_OS_AUTOSAR)
@@ -198,6 +188,69 @@ errno_t pfe_rtable_clear_stats(const pfe_rtable_t *rtable, uint8_t conntrack_ind
 
 #define CRCPOLY_BE 0x04C11DB7U
 
+static void read_phys_entry_dbus(addr_t phys_entry, pfe_ct_rtable_entry_t *phys_entry_cache)
+{
+	memcpy(phys_entry_cache, (void *)phys_entry, sizeof(*phys_entry_cache));
+}
+
+static void write_phys_entry_dbus(addr_t phys_entry, pfe_ct_rtable_entry_t *phys_entry_cache)
+{
+	memcpy((void *)phys_entry, phys_entry_cache, sizeof(*phys_entry_cache));
+}
+
+static void read_phys_entry_cbus(addr_t phys_entry, pfe_ct_rtable_entry_t *phys_entry_cache)
+{
+	uint32_t *data_out = (uint32_t *)phys_entry_cache;
+	uint32_t *data_in = (uint32_t *)phys_entry;
+	int i, words = sizeof(*phys_entry_cache) >> 2;
+
+	for (i = 0; i < words; i++)
+	{
+		data_out[i] = oal_ntohl(data_in[i]);
+	}
+}
+
+static void write_phys_entry_cbus(addr_t phys_entry, pfe_ct_rtable_entry_t *phys_entry_cache)
+{
+	uint32_t *data_out = (uint32_t *)phys_entry;
+	uint32_t *data_in = (uint32_t *)phys_entry_cache;
+	int i, words = sizeof(*phys_entry_cache) >> 2;
+
+	for (i = 0; i < words; i++)
+	{
+		data_out[i] = oal_htonl(data_in[i]);
+	}
+}
+
+static void pfe_rtable_read_phys_entry(addr_t phys_entry, pfe_ct_rtable_entry_t *phys_entry_cache)
+{
+	if (TRUE == rtable_in_lmem)
+	{
+		read_phys_entry_cbus(phys_entry, phys_entry_cache);
+	}
+	else
+	{
+		read_phys_entry_dbus(phys_entry, phys_entry_cache);
+	}
+}
+
+static void pfe_rtable_write_phys_entry(addr_t phys_entry, pfe_ct_rtable_entry_t *phys_entry_cache)
+{
+	if (TRUE == rtable_in_lmem)
+	{
+		write_phys_entry_cbus(phys_entry, phys_entry_cache);
+	}
+	else
+	{
+		write_phys_entry_dbus(phys_entry, phys_entry_cache);
+	}
+}
+
+static void pfe_rtable_clear_phys_entry(addr_t phys_entry)
+{
+	memset((void *)phys_entry, 0, sizeof(pfe_ct_rtable_entry_t));
+}
+
 /**
  * @brief		Get the next free index in the conntrack stats table
  * @return		The index
@@ -239,7 +292,7 @@ static void pfe_rtable_free_stats_index(uint8_t index)
 	}
 }
 
-static pfe_rtable_entry_t *pfe_rtable_get_by_phys_entry_va(const pfe_rtable_t *rtable, const pfe_ct_rtable_entry_t *phys_entry_va)
+static pfe_rtable_entry_t *pfe_rtable_get_by_phys_entry_va(const pfe_rtable_t *rtable, addr_t phys_entry_va)
 {
 	LLIST_t *item;
 	pfe_rtable_entry_t *entry;
@@ -260,7 +313,7 @@ static pfe_rtable_entry_t *pfe_rtable_get_by_phys_entry_va(const pfe_rtable_t *r
 			/*	Remember current item to know where to start later */
 			if (NULL != entry)
 			{
-				if (phys_entry_va == entry->phys_entry)
+				if (phys_entry_va == entry->phys_entry_va)
 				{
 					match = TRUE;
 					break;
@@ -328,16 +381,14 @@ static void pfe_rtable_invalidate(pfe_rtable_t *rtable)
 
 	for (ii=0U; ii<rtable->htable_size; ii++)
 	{
-		table[ii].flags = (pfe_ct_rtable_flags_t)(oal_ntohl(0));
-		table[ii].next = oal_ntohl(0);
+		pfe_rtable_clear_phys_entry((addr_t)&table[ii]);
 	}
 
 	table = (pfe_ct_rtable_entry_t *)rtable->pool_base_va;
 
 	for (ii=0U; ii<rtable->pool_size; ii++)
 	{
-		table[ii].flags = (pfe_ct_rtable_flags_t)(oal_ntohl(0));
-		table[ii].next = oal_ntohl(0);
+		pfe_rtable_clear_phys_entry((addr_t)&table[ii]);
 	}
 
 	if (unlikely(EOK != oal_mutex_unlock(rtable->lock)))
@@ -348,19 +399,19 @@ static void pfe_rtable_invalidate(pfe_rtable_t *rtable)
 
 /**
  * @brief		Get hash for a routing table entry
- * @param[in]	entry The entry
+ * @param[in]	phys_entry_cache Cached physical entry data
  * @param[in]	ipv_type Frame Ip type
  * @param[in]	hash_mask Mask to be applied on the resulting hash (bitwise AND)
  * @note		IPv4 addresses within entry are in network order due to way how the type is defined
  */
-static uint32_t pfe_rtable_entry_get_hash(pfe_rtable_entry_t *entry, pfe_ipv_type_t ipv_type, uint32_t hash_mask)
+static uint32_t pfe_rtable_entry_get_hash(pfe_ct_rtable_entry_t *phys_entry_cache, pfe_ipv_type_t ipv_type, uint32_t hash_mask)
 {
 	uint32_t temp = 0U;
 	uint32_t crc = 0xffffffffU;
 	uint32_t sport = 0U;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely(NULL == entry))
+	if (unlikely(NULL == phys_entry_cache))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
 		return 0;
@@ -369,11 +420,11 @@ static uint32_t pfe_rtable_entry_get_hash(pfe_rtable_entry_t *entry, pfe_ipv_typ
 	if (IPV4 == ipv_type)
 	{
 		/*	CRC(SIP) + DIP + CRC(SPORT) + DPORT + PROTO */
-		sport = entry->phys_entry->ipv.v4.sip ^ oal_ntohl((uint32_t)oal_ntohs(entry->phys_entry->sport));
+		sport = phys_entry_cache->ipv.v4.sip ^ oal_ntohl((uint32_t)oal_ntohs(phys_entry_cache->sport));
 		temp = pfe_get_crc32_be(crc, (uint8_t *)&sport, 4);
-		temp += oal_ntohl(entry->phys_entry->ipv.v4.dip);
-		temp += entry->phys_entry->proto;
-		temp += oal_ntohs(entry->phys_entry->dport);
+		temp += oal_ntohl(phys_entry_cache->ipv.v4.dip);
+		temp += phys_entry_cache->proto;
+		temp += oal_ntohs(phys_entry_cache->dport);
 
 	}
 	else if (IPV6 == ipv_type)
@@ -383,18 +434,18 @@ static uint32_t pfe_rtable_entry_get_hash(pfe_rtable_entry_t *entry, pfe_ipv_typ
 
 		for(jj=0; jj<4 ; jj++)
 		{
-			crc_ipv6 += entry->phys_entry->ipv.v6.sip[jj];
+			crc_ipv6 += phys_entry_cache->ipv.v6.sip[jj];
 		}
 
 		/*	CRC(SIP) + DIP + CRC(SPORT) + DPORT + PROTO */
-		sport = crc_ipv6 ^ oal_ntohl((uint32_t)oal_ntohs(entry->phys_entry->sport));
+		sport = crc_ipv6 ^ oal_ntohl((uint32_t)oal_ntohs(phys_entry_cache->sport));
 		temp = pfe_get_crc32_be(crc,(uint8_t *)&sport, 4);
-		temp += oal_ntohl(entry->phys_entry->ipv.v6.dip[0]);
-		temp += oal_ntohl(entry->phys_entry->ipv.v6.dip[1]);
-		temp += oal_ntohl(entry->phys_entry->ipv.v6.dip[2]);
-		temp += oal_ntohl(entry->phys_entry->ipv.v6.dip[3]);
-		temp += entry->phys_entry->proto;
-		temp += oal_ntohs(entry->phys_entry->dport);
+		temp += oal_ntohl(phys_entry_cache->ipv.v6.dip[0]);
+		temp += oal_ntohl(phys_entry_cache->ipv.v6.dip[1]);
+		temp += oal_ntohl(phys_entry_cache->ipv.v6.dip[2]);
+		temp += oal_ntohl(phys_entry_cache->ipv.v6.dip[3]);
+		temp += phys_entry_cache->proto;
+		temp += oal_ntohs(phys_entry_cache->dport);
 	}
 	else
 	{
@@ -408,16 +459,16 @@ static uint32_t pfe_rtable_entry_get_hash(pfe_rtable_entry_t *entry, pfe_ipv_typ
 /**
  * @brief		Check if entry belongs to hash table
  * @param[in]	rtable The routing table instance
- * @param[in]	phys_entry Entry to be checked (VA or PA)
+ * @param[in]	phys_entry_addr Entry address to be checked (VA or PA)
  * @retval		TRUE Entry belongs to hash table
  * @retval		FALSE Entry does not belong to hash table
  */
-static bool_t pfe_rtable_phys_entry_is_htable(const pfe_rtable_t *rtable, const pfe_ct_rtable_entry_t *phys_entry)
+static bool_t pfe_rtable_phys_entry_is_htable(const pfe_rtable_t *rtable, addr_t phys_entry_addr)
 {
 	bool_t ret;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely((NULL == rtable) || (NULL == phys_entry)))
+	if (unlikely((NULL == rtable) || (NULL_ADDR == phys_entry_addr)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
 		ret = FALSE;
@@ -425,13 +476,13 @@ static bool_t pfe_rtable_phys_entry_is_htable(const pfe_rtable_t *rtable, const
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		if (((addr_t)phys_entry >= rtable->htable_base_va) && ((addr_t)phys_entry < rtable->htable_end_va))
+		if ((phys_entry_addr >= rtable->htable_base_va) && (phys_entry_addr < rtable->htable_end_va))
 		{
 			ret = TRUE;
 		}
 		else
 		{
-			if (((addr_t)phys_entry >= rtable->htable_base_pa) && ((addr_t)phys_entry < rtable->htable_end_pa))
+			if ((phys_entry_addr >= rtable->htable_base_pa) && (phys_entry_addr < rtable->htable_end_pa))
 			{
 				ret = TRUE;
 			}
@@ -448,16 +499,16 @@ static bool_t pfe_rtable_phys_entry_is_htable(const pfe_rtable_t *rtable, const
 /**
  * @brief		Check if entry belongs to the pool
  * @param[in]	rtable The routing table instance
- * @param[in]	phys_entry Entry to be checked (VA or PA)
+ * @param[in]	phys_entry_addr Entry address to be checked (VA or PA)
  * @retval		TRUE Entry belongs to the pool
  * @retval		FALSE Entry does not belong to the pool
  */
-static bool_t pfe_rtable_phys_entry_is_pool(const pfe_rtable_t *rtable, const pfe_ct_rtable_entry_t *phys_entry)
+static bool_t pfe_rtable_phys_entry_is_pool(const pfe_rtable_t *rtable, addr_t phys_entry_addr)
 {
 	bool_t ret;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely((NULL == rtable) || (NULL == phys_entry)))
+	if (unlikely((NULL == rtable) || (NULL_ADDR == phys_entry_addr)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
 		ret = FALSE;
@@ -465,13 +516,13 @@ static bool_t pfe_rtable_phys_entry_is_pool(const pfe_rtable_t *rtable, const pf
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		if (((addr_t)phys_entry >= rtable->pool_base_va) && ((addr_t)phys_entry < rtable->pool_end_va))
+		if ((phys_entry_addr >= rtable->pool_base_va) && (phys_entry_addr < rtable->pool_end_va))
 		{
 			ret = TRUE;
 		}
 		else
 		{
-			if (((addr_t)phys_entry >= rtable->pool_base_pa) && ((addr_t)phys_entry < rtable->pool_end_pa))
+			if ((phys_entry_addr >= rtable->pool_base_pa) && (phys_entry_addr < rtable->pool_end_pa))
 			{
 				ret = TRUE;
 			}
@@ -488,33 +539,33 @@ static bool_t pfe_rtable_phys_entry_is_pool(const pfe_rtable_t *rtable, const pf
 /**
  * @brief		Convert entry to physical address
  * @param[in]	rtable The routing table instance
- * @param[in]	phys_entry_va The entry (virtual address)
- * @return		The PA or NULL if failed
+ * @param[in]	phys_entry_va The entry address (virtual address)
+ * @return		The PA or NULL_ADDR if failed
  */
-static pfe_ct_rtable_entry_t *pfe_rtable_phys_entry_get_pa(pfe_rtable_t *rtable, pfe_ct_rtable_entry_t *phys_entry_va)
+static addr_t pfe_rtable_phys_entry_get_pa(pfe_rtable_t *rtable, addr_t phys_entry_va)
 {
-	pfe_ct_rtable_entry_t *pa;
+	addr_t pa;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely((NULL == rtable) || (NULL == phys_entry_va)))
+	if (unlikely((NULL == rtable) || (NULL_ADDR  == phys_entry_va)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		pa = NULL;
+		pa = NULL_ADDR;
 	}
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
 		if (TRUE == pfe_rtable_phys_entry_is_htable(rtable, phys_entry_va))
 		{
-			pa = (pfe_ct_rtable_entry_t *)((addr_t)phys_entry_va - rtable->htable_va_pa_offset);
+			pa = phys_entry_va - rtable->htable_va_pa_offset;
 		}
 		else if (TRUE == pfe_rtable_phys_entry_is_pool(rtable, phys_entry_va))
 		{
-			pa = (pfe_ct_rtable_entry_t *)((addr_t)phys_entry_va - rtable->pool_va_pa_offset);
+			pa = phys_entry_va - rtable->pool_va_pa_offset;
 		}
 		else
 		{
-			pa = NULL;
+			pa = NULL_ADDR;
 		}
 	}
 
@@ -527,30 +578,30 @@ static pfe_ct_rtable_entry_t *pfe_rtable_phys_entry_get_pa(pfe_rtable_t *rtable,
  * @param[in]	entry_pa The entry (physical address)
  * @return		The VA or NULL if failed
  */
-static pfe_ct_rtable_entry_t *pfe_rtable_phys_entry_get_va(pfe_rtable_t *rtable, pfe_ct_rtable_entry_t *phys_entry_pa)
+static addr_t pfe_rtable_phys_entry_get_va(pfe_rtable_t *rtable, addr_t phys_entry_pa)
 {
-	pfe_ct_rtable_entry_t *va;
+	addr_t va;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely((NULL == rtable) || (NULL == phys_entry_pa)))
+	if (unlikely((NULL == rtable) || (NULL_ADDR == phys_entry_pa)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		va = NULL;
+		va = NULL_ADDR;
 	}
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
 		if (TRUE == pfe_rtable_phys_entry_is_htable(rtable, phys_entry_pa))
 		{
-			va = (pfe_ct_rtable_entry_t *)((addr_t)phys_entry_pa + rtable->htable_va_pa_offset);
+			va = phys_entry_pa + rtable->htable_va_pa_offset;
 		}
 		else if (TRUE == pfe_rtable_phys_entry_is_pool(rtable, phys_entry_pa))
 		{
-			va = (pfe_ct_rtable_entry_t *)((addr_t)phys_entry_pa + rtable->pool_va_pa_offset);
+			va = phys_entry_pa + rtable->pool_va_pa_offset;
 		}
 		else
 		{
-			va = NULL;
+			va = NULL_ADDR;
 		}
 	}
 
@@ -571,20 +622,17 @@ pfe_rtable_entry_t *pfe_rtable_entry_create(void)
 	if (NULL != entry)
 	{
 		(void)memset(entry, 0, sizeof(pfe_rtable_entry_t));
-		entry->temp_phys_entry = NULL;
-		entry->phys_entry = NULL;
 
-		/*	This is temporary 'physical' entry storage */
-		entry->temp_phys_entry = oal_mm_malloc(sizeof(pfe_ct_rtable_entry_t));
-		if (NULL == entry->temp_phys_entry)
+		/*	allocate intermediate 'physical' entry storage */
+		entry->phys_entry_cache = oal_mm_malloc(sizeof(pfe_ct_rtable_entry_t));
+		if (NULL == entry->phys_entry_cache)
 		{
 			oal_mm_free(entry);
 			entry = NULL;
 		}
 		else
 		{
-			(void)memset(entry->temp_phys_entry, 0, sizeof(pfe_ct_rtable_entry_t));
-			entry->phys_entry = entry->temp_phys_entry;
+			(void)memset(entry->phys_entry_cache, 0, sizeof(pfe_ct_rtable_entry_t));
 
 			/*	Set defaults */
 			entry->rtable = NULL;
@@ -597,7 +645,7 @@ pfe_rtable_entry_t *pfe_rtable_entry_create(void)
 			entry->refptr = NULL;
 			entry->child = NULL;
 
-			entry->temp_phys_entry->flag_ipv6 = (uint8_t)IPV_INVALID;
+			entry->phys_entry_cache->flag_ipv6 = (uint8_t)IPV_INVALID;
 		}
 	}
 
@@ -615,9 +663,9 @@ void pfe_rtable_entry_free(pfe_rtable_entry_t *entry)
 {
 	if (NULL != entry)
 	{
-		if (NULL != entry->temp_phys_entry)
+		if (NULL != entry->phys_entry_cache)
 		{
-			oal_mm_free(entry->temp_phys_entry);
+			oal_mm_free(entry->phys_entry_cache);
 		}
 
 		oal_mm_free(entry);
@@ -677,27 +725,37 @@ errno_t pfe_rtable_entry_set_sip(pfe_rtable_entry_t *entry,const pfe_ip_addr_t *
 	}
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
+	if (NULL_ADDR != entry->phys_entry_va)
+	{
+		pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+	}
+
 	if (ip_addr->is_ipv4)
 	{
-		if ((entry->phys_entry->flag_ipv6 != (uint8_t)IPV_INVALID) && (entry->phys_entry->flag_ipv6 != (uint8_t)IPV4))
+		if ((entry->phys_entry_cache->flag_ipv6 != (uint8_t)IPV_INVALID) && (entry->phys_entry_cache->flag_ipv6 != (uint8_t)IPV4))
 		{
 			NXP_LOG_ERROR("IP version mismatch\n");
 			return EINVAL;
 		}
 
-		(void)memcpy(&entry->phys_entry->ipv.v4.sip, &ip_addr->v4, 4);
-		entry->phys_entry->flag_ipv6 = (uint8_t)IPV4;
+		(void)memcpy(&entry->phys_entry_cache->ipv.v4.sip, &ip_addr->v4, 4);
+		entry->phys_entry_cache->flag_ipv6 = (uint8_t)IPV4;
 	}
 	else
 	{
-		if ((entry->phys_entry->flag_ipv6 != (uint8_t)IPV_INVALID) && (entry->phys_entry->flag_ipv6 != (uint8_t)IPV6))
+		if ((entry->phys_entry_cache->flag_ipv6 != (uint8_t)IPV_INVALID) && (entry->phys_entry_cache->flag_ipv6 != (uint8_t)IPV6))
 		{
 			NXP_LOG_ERROR("IP version mismatch\n");
 			return EINVAL;
 		}
 
-		(void)memcpy(&entry->phys_entry->ipv.v6.sip[0], &ip_addr->v6, 16);
-		entry->phys_entry->flag_ipv6 = (uint8_t)IPV6;
+		(void)memcpy(&entry->phys_entry_cache->ipv.v6.sip[0], &ip_addr->v6, 16);
+		entry->phys_entry_cache->flag_ipv6 = (uint8_t)IPV6;
+	}
+
+	if (NULL_ADDR != entry->phys_entry_va)
+	{
+		pfe_rtable_write_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
 	}
 
 	return EOK;
@@ -746,27 +804,37 @@ errno_t pfe_rtable_entry_set_dip(pfe_rtable_entry_t *entry, const pfe_ip_addr_t
 	}
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
+	if (NULL_ADDR != entry->phys_entry_va)
+	{
+		pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+	}
+
 	if (ip_addr->is_ipv4)
 	{
-		if ((entry->phys_entry->flag_ipv6 != (uint8_t)IPV_INVALID) && (entry->phys_entry->flag_ipv6 != (uint8_t)IPV4))
+		if ((entry->phys_entry_cache->flag_ipv6 != (uint8_t)IPV_INVALID) && (entry->phys_entry_cache->flag_ipv6 != (uint8_t)IPV4))
 		{
 			NXP_LOG_ERROR("IP version mismatch\n");
 			return EINVAL;
 		}
 
-		(void)memcpy(&entry->phys_entry->ipv.v4.dip, &ip_addr->v4, 4);
-		entry->phys_entry->flag_ipv6 = (uint8_t)IPV4;
+		(void)memcpy(&entry->phys_entry_cache->ipv.v4.dip, &ip_addr->v4, 4);
+		entry->phys_entry_cache->flag_ipv6 = (uint8_t)IPV4;
 	}
 	else
 	{
-		if ((entry->phys_entry->flag_ipv6 != (uint8_t)IPV_INVALID) && (entry->phys_entry->flag_ipv6 != (uint8_t)IPV6))
+		if ((entry->phys_entry_cache->flag_ipv6 != (uint8_t)IPV_INVALID) && (entry->phys_entry_cache->flag_ipv6 != (uint8_t)IPV6))
 		{
 			NXP_LOG_ERROR("IP version mismatch\n");
 			return EINVAL;
 		}
 
-		(void)memcpy(&entry->phys_entry->ipv.v6.dip[0], &ip_addr->v6, 16);
-		entry->phys_entry->flag_ipv6 = (uint8_t)IPV6;
+		(void)memcpy(&entry->phys_entry_cache->ipv.v6.dip[0], &ip_addr->v6, 16);
+		entry->phys_entry_cache->flag_ipv6 = (uint8_t)IPV6;
+	}
+
+	if (NULL_ADDR != entry->phys_entry_va)
+	{
+		pfe_rtable_write_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
 	}
 
 	return EOK;
@@ -814,7 +882,17 @@ void pfe_rtable_entry_set_sport(pfe_rtable_entry_t *entry, uint16_t sport)
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		entry->phys_entry->sport = oal_htons(sport);
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
+		entry->phys_entry_cache->sport = oal_htons(sport);
+
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_write_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
 	}
 }
 
@@ -836,7 +914,12 @@ uint16_t pfe_rtable_entry_get_sport(const pfe_rtable_entry_t *entry)
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		ret = oal_ntohs(entry->phys_entry->sport);
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
+		ret = oal_ntohs(entry->phys_entry_cache->sport);
 	}
 	return ret;
 }
@@ -856,7 +939,17 @@ void pfe_rtable_entry_set_dport(pfe_rtable_entry_t *entry, uint16_t dport)
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		entry->phys_entry->dport = oal_htons(dport);
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
+		entry->phys_entry_cache->dport = oal_htons(dport);
+
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_write_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
 	}
 }
 
@@ -878,7 +971,12 @@ uint16_t pfe_rtable_entry_get_dport(const pfe_rtable_entry_t *entry)
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		ret = oal_ntohs(entry->phys_entry->dport);
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
+		ret = oal_ntohs(entry->phys_entry_cache->dport);
 	}
 	return ret;
 }
@@ -898,7 +996,17 @@ void pfe_rtable_entry_set_proto(pfe_rtable_entry_t *entry, uint8_t proto)
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		entry->phys_entry->proto = proto;
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
+		entry->phys_entry_cache->proto = proto;
+
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_write_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
 	}
 }
 
@@ -920,7 +1028,17 @@ uint8_t pfe_rtable_entry_get_proto(const pfe_rtable_entry_t *entry)
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		ret = entry->phys_entry->proto;
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
+		ret = entry->phys_entry_cache->proto;
+
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_write_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
 	}
 	return ret;
 }
@@ -951,8 +1069,18 @@ errno_t pfe_rtable_entry_set_dstif_id(pfe_rtable_entry_t *entry, pfe_ct_phy_if_i
 		}
 		else
 		{
-			entry->phys_entry->e_phy_if = if_id;
+			if (NULL_ADDR != entry->phys_entry_va)
+			{
+				pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+			}
+
+			entry->phys_entry_cache->e_phy_if = if_id;
 			ret = EOK;
+
+			if (NULL_ADDR != entry->phys_entry_va)
+			{
+				pfe_rtable_write_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+			}
 		}
 	}
 
@@ -1010,16 +1138,21 @@ errno_t pfe_rtable_entry_set_out_sip(pfe_rtable_entry_t *entry, const pfe_ip_add
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		if (((uint8_t)IPV_INVALID != entry->phys_entry->flag_ipv6) && (output_sip->is_ipv4))
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
+		if (((uint8_t)IPV_INVALID != entry->phys_entry_cache->flag_ipv6) && (output_sip->is_ipv4))
 		{
-			(void)memcpy(&entry->phys_entry->args.ipv.v4.sip, &output_sip->v4, 4);
-			entry->phys_entry->flag_ipv6 = (uint8_t)IPV4;
+			(void)memcpy(&entry->phys_entry_cache->args.ipv.v4.sip, &output_sip->v4, 4);
+			entry->phys_entry_cache->flag_ipv6 = (uint8_t)IPV4;
 			ret = EOK;
 		}
-		else if (((uint8_t)IPV_INVALID != entry->phys_entry->flag_ipv6) && (!output_sip->is_ipv4))
+		else if (((uint8_t)IPV_INVALID != entry->phys_entry_cache->flag_ipv6) && (!output_sip->is_ipv4))
 		{
-			(void)memcpy(&entry->phys_entry->args.ipv.v6.sip[0], &output_sip->v6, 16);
-			entry->phys_entry->flag_ipv6 = (uint8_t)IPV6;
+			(void)memcpy(&entry->phys_entry_cache->args.ipv.v6.sip[0], &output_sip->v6, 16);
+			entry->phys_entry_cache->flag_ipv6 = (uint8_t)IPV6;
 			ret = EOK;
 		}
 		else
@@ -1030,7 +1163,11 @@ errno_t pfe_rtable_entry_set_out_sip(pfe_rtable_entry_t *entry, const pfe_ip_add
 
 		if (EOK == ret)
 		{
-			entry->phys_entry->actions |= oal_htonl(RT_ACT_CHANGE_SIP_ADDR);
+			entry->phys_entry_cache->actions |= oal_htonl(RT_ACT_CHANGE_SIP_ADDR);
+			if (NULL_ADDR != entry->phys_entry_va)
+			{
+				pfe_rtable_write_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+			}
 		}
 	}
 
@@ -1059,16 +1196,21 @@ errno_t pfe_rtable_entry_set_out_dip(pfe_rtable_entry_t *entry, const pfe_ip_add
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		if (((uint8_t)IPV_INVALID != entry->phys_entry->flag_ipv6) && (output_dip->is_ipv4))
+		if (NULL_ADDR != entry->phys_entry_va)
 		{
-			(void)memcpy(&entry->phys_entry->args.ipv.v4.dip, &output_dip->v4, 4);
-			entry->phys_entry->flag_ipv6 = (uint8_t)IPV4;
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
+		if (((uint8_t)IPV_INVALID != entry->phys_entry_cache->flag_ipv6) && (output_dip->is_ipv4))
+		{
+			(void)memcpy(&entry->phys_entry_cache->args.ipv.v4.dip, &output_dip->v4, 4);
+			entry->phys_entry_cache->flag_ipv6 = (uint8_t)IPV4;
 			ret = EOK;
 		}
-		else if (((uint8_t)IPV_INVALID != entry->phys_entry->flag_ipv6) && (!output_dip->is_ipv4))
+		else if (((uint8_t)IPV_INVALID != entry->phys_entry_cache->flag_ipv6) && (!output_dip->is_ipv4))
 		{
-			(void)memcpy(&entry->phys_entry->args.ipv.v6.dip[0], &output_dip->v6, 16);
-			entry->phys_entry->flag_ipv6 = (uint8_t)IPV6;
+			(void)memcpy(&entry->phys_entry_cache->args.ipv.v6.dip[0], &output_dip->v6, 16);
+			entry->phys_entry_cache->flag_ipv6 = (uint8_t)IPV6;
 			ret = EOK;
 		}
 		else
@@ -1079,7 +1221,12 @@ errno_t pfe_rtable_entry_set_out_dip(pfe_rtable_entry_t *entry, const pfe_ip_add
 
 		if (EOK == ret)
 		{
-			entry->phys_entry->actions |= oal_htonl(RT_ACT_CHANGE_DIP_ADDR);
+			entry->phys_entry_cache->actions |= oal_htonl(RT_ACT_CHANGE_DIP_ADDR);
+
+			if (NULL_ADDR != entry->phys_entry_va)
+			{
+				pfe_rtable_write_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+			}
 		}
 	}
 
@@ -1105,8 +1252,18 @@ void pfe_rtable_entry_set_out_sport(const pfe_rtable_entry_t *entry, uint16_t ou
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		entry->phys_entry->args.sport = oal_htons(output_sport);
-		entry->phys_entry->actions |= oal_htonl(RT_ACT_CHANGE_SPORT);
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
+		entry->phys_entry_cache->args.sport = oal_htons(output_sport);
+		entry->phys_entry_cache->actions |= oal_htonl(RT_ACT_CHANGE_SPORT);
+
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_write_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
 	}
 }
 
@@ -1129,8 +1286,18 @@ void pfe_rtable_entry_set_out_dport(pfe_rtable_entry_t *entry, uint16_t output_d
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		entry->phys_entry->args.dport = oal_htons(output_dport);
-		entry->phys_entry->actions |= oal_htonl(RT_ACT_CHANGE_DPORT);
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
+		entry->phys_entry_cache->args.dport = oal_htons(output_dport);
+		entry->phys_entry_cache->actions |= oal_htonl(RT_ACT_CHANGE_DPORT);
+
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_write_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
 	}
 }
 
@@ -1151,7 +1318,17 @@ void pfe_rtable_entry_set_ttl_decrement(pfe_rtable_entry_t *entry)
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		entry->phys_entry->actions |= oal_htonl(RT_ACT_DEC_TTL);
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
+		entry->phys_entry_cache->actions |= oal_htonl(RT_ACT_DEC_TTL);
+
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_write_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
 	}
 }
 
@@ -1172,7 +1349,17 @@ void pfe_rtable_entry_remove_ttl_decrement(pfe_rtable_entry_t *entry)
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		entry->phys_entry->actions &= ~(oal_htonl(RT_ACT_DEC_TTL));
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
+		entry->phys_entry_cache->actions &= ~(oal_htonl(RT_ACT_DEC_TTL));
+
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_write_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
 	}
 }
 
@@ -1194,9 +1381,19 @@ void pfe_rtable_entry_set_out_mac_addrs(pfe_rtable_entry_t *entry, const pfe_mac
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		(void)memcpy(entry->phys_entry->args.smac, smac, sizeof(pfe_mac_addr_t));
-		(void)memcpy(entry->phys_entry->args.dmac, dmac, sizeof(pfe_mac_addr_t));
-		entry->phys_entry->actions |= oal_htonl(RT_ACT_ADD_ETH_HDR);
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
+		(void)memcpy(entry->phys_entry_cache->args.smac, smac, sizeof(pfe_mac_addr_t));
+		(void)memcpy(entry->phys_entry_cache->args.dmac, dmac, sizeof(pfe_mac_addr_t));
+		entry->phys_entry_cache->actions |= oal_htonl(RT_ACT_ADD_ETH_HDR);
+
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_write_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
 	}
 }
 
@@ -1219,17 +1416,27 @@ void pfe_rtable_entry_set_out_vlan(pfe_rtable_entry_t *entry, uint16_t vlan, boo
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		entry->phys_entry->args.vlan = oal_htons(vlan);
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
+		entry->phys_entry_cache->args.vlan = oal_htons(vlan);
 
-		entry->phys_entry->actions &= ~oal_htonl(RT_ACT_MOD_VLAN_HDR|RT_ACT_ADD_VLAN_HDR);
+		entry->phys_entry_cache->actions &= ~oal_htonl(RT_ACT_MOD_VLAN_HDR|RT_ACT_ADD_VLAN_HDR);
 
 		if (replace)
 		{
-			entry->phys_entry->actions |= oal_htonl(RT_ACT_MOD_VLAN_HDR);
+			entry->phys_entry_cache->actions |= oal_htonl(RT_ACT_MOD_VLAN_HDR);
 		}
 		else
 		{
-			entry->phys_entry->actions |= oal_htonl(RT_ACT_ADD_VLAN_HDR);
+			entry->phys_entry_cache->actions |= oal_htonl(RT_ACT_ADD_VLAN_HDR);
+		}
+
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_write_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
 		}
 	}
 }
@@ -1256,10 +1463,19 @@ uint16_t pfe_rtable_entry_get_out_vlan(const pfe_rtable_entry_t *entry)
 	else
 	{
 #endif /* PFE_CFG_NULL_ARG_CHECK */
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
 
-		if (0U != (oal_ntohl(entry->phys_entry->actions) & ((uint32_t)RT_ACT_ADD_VLAN_HDR | (uint32_t)RT_ACT_MOD_VLAN_HDR)))
+		if (0U != (oal_ntohl(entry->phys_entry_cache->actions) & ((uint32_t)RT_ACT_ADD_VLAN_HDR | (uint32_t)RT_ACT_MOD_VLAN_HDR)))
 		{
-			ret = oal_ntohs(entry->phys_entry->args.vlan);
+			ret = oal_ntohs(entry->phys_entry_cache->args.vlan);
+		}
+
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_write_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
 		}
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	}
@@ -1285,8 +1501,18 @@ void pfe_rtable_entry_set_out_inner_vlan(pfe_rtable_entry_t *entry, uint16_t vla
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		entry->phys_entry->args.vlan1 = oal_htons(vlan);
-		entry->phys_entry->actions |= oal_htonl(RT_ACT_ADD_VLAN1_HDR);
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
+		entry->phys_entry_cache->args.vlan1 = oal_htons(vlan);
+		entry->phys_entry_cache->actions |= oal_htonl(RT_ACT_ADD_VLAN1_HDR);
+
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_write_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
 	}
 }
 
@@ -1309,7 +1535,12 @@ void pfe_rtable_entry_set_out_pppoe_sid(pfe_rtable_entry_t *entry, uint16_t sid)
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		flags = (pfe_ct_route_actions_t)(oal_ntohl(entry->phys_entry->actions));
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
+		flags = (pfe_ct_route_actions_t)(oal_ntohl(entry->phys_entry_cache->actions));
 
 		if (0U != (flags & (uint32_t)RT_ACT_ADD_VLAN1_HDR))
 		{
@@ -1323,8 +1554,13 @@ void pfe_rtable_entry_set_out_pppoe_sid(pfe_rtable_entry_t *entry, uint16_t sid)
 			}
 			else
 			{
-				entry->phys_entry->args.pppoe_sid = oal_htons(sid);
-				entry->phys_entry->actions |= oal_htonl(RT_ACT_ADD_PPPOE_HDR);
+				entry->phys_entry_cache->args.pppoe_sid = oal_htons(sid);
+				entry->phys_entry_cache->actions |= oal_htonl(RT_ACT_ADD_PPPOE_HDR);
+
+				if (NULL_ADDR != entry->phys_entry_va)
+				{
+					pfe_rtable_write_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+				}
 			}
 		}
 	}
@@ -1340,7 +1576,17 @@ void pfe_rtable_entry_set_id5t(pfe_rtable_entry_t *entry, uint32_t id5t)
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		entry->phys_entry->id5t = oal_htonl(id5t);
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
+		entry->phys_entry_cache->id5t = oal_htonl(id5t);
+
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_write_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
 	}
 }
 
@@ -1357,7 +1603,12 @@ errno_t pfe_rtable_entry_get_id5t(const pfe_rtable_entry_t *entry, uint32_t *id5
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		*id5t = oal_ntohl(entry->phys_entry->id5t);
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
+		*id5t = oal_ntohl(entry->phys_entry_cache->id5t);
 		ret = EOK;
 	}
 
@@ -1382,7 +1633,12 @@ pfe_ct_route_actions_t pfe_rtable_entry_get_action_flags(pfe_rtable_entry_t *ent
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		ret = (pfe_ct_route_actions_t)oal_ntohl((uint32_t)(entry->phys_entry->actions));
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
+		ret = (pfe_ct_route_actions_t)oal_ntohl((uint32_t)(entry->phys_entry_cache->actions));
 	}
 	return ret;
 }
@@ -1631,7 +1887,12 @@ uint8_t pfe_rtable_entry_get_stats_index(const pfe_rtable_entry_t *entry)
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		ret = (uint8_t)oal_ntohs(entry->phys_entry->conntrack_stats_index);
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
+		ret = (uint8_t)oal_ntohs(entry->phys_entry_cache->conntrack_stats_index);
 	}
 	return ret;
 }
@@ -1725,211 +1986,120 @@ static bool_t pfe_rtable_entry_is_duplicate(pfe_rtable_t *rtable, pfe_rtable_ent
 }
 
 /**
- * @brief		Get physical address of entry
+ * @brief		Add entry in the physical hash table
  * @param[in]	rtable The routing table instance
- * @param[in]	phys_entry_temp Temporary saved entry to be added
- * @retval		EOK Success, error code otherwise
- */
-static errno_t pfe_rtable_add_entry_get_phys_pa(pfe_rtable_t *rtable, pfe_rtable_phys_entry_infor_t *phys_entry_temp)
-{
-	errno_t ret = EOK;
-
-	/*	Get physical address */
-	phys_entry_temp->new_phys_entry_pa = pfe_rtable_phys_entry_get_pa(rtable, phys_entry_temp->new_phys_entry_va);
-	if (NULL == phys_entry_temp->new_phys_entry_pa)
-	{
-		NXP_LOG_ERROR("Couldn't get PA (entry @ v0x%p)\n", (void *)phys_entry_temp->new_phys_entry_va);
-		if (pfe_rtable_phys_entry_is_pool(rtable, phys_entry_temp->new_phys_entry_va))
-		{
-			/*	Entry from the pool. Return it. */
-			ret = fifo_put(rtable->pool_va, phys_entry_temp->new_phys_entry_va);
-			if (EOK != ret)
-			{
-				NXP_LOG_ERROR("Couldn't return routing table entry to the pool\n");
-			}
-		}
-
-		if (unlikely(EOK != oal_mutex_unlock(rtable->lock)))
-		{
-			NXP_LOG_DEBUG("Mutex unlock failed\n");
-		}
-
-		ret = EFAULT;
-	}
-
-	return ret;
-}
-
-/**
- * @brief		Link entry in the table
- * @param[in]	rtable The routing table instance
- * @param[in]	phys_entry_temp Temporary saved entry to be added
- * @retval		EOK Success, error code otherwise
- */
-static errno_t pfe_rtable_add_entry_link(pfe_rtable_t *rtable, pfe_rtable_phys_entry_infor_t *phys_entry_temp)
-{
-	errno_t ret = EOK;
-
-#if (TRUE == PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE)
-	pfe_ct_rtable_flags_t valid_tmp;
-#endif /* PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE */
-
-	/*	Make sure the new entry is invalid */
-	phys_entry_temp->new_phys_entry_va->flags = RT_FL_NONE;
-
-	ret = pfe_rtable_add_entry_get_phys_pa(rtable, phys_entry_temp);
-
-	if(EOK == ret)
-	{
-		/*	Set link */
-		if (TRUE == pfe_rtable_phys_entry_is_htable(rtable, phys_entry_temp->new_phys_entry_va))
-		{
-			/*	This is very first entry in a hash bucket */
-			phys_entry_temp->new_phys_entry_va->next = 0U;
-		}
-		else
-		{
-			/*	Find last entry in the chain */
-			while (NULL != (void *)(addr_t)phys_entry_temp->last_phys_entry_va->next)
-			{
-				phys_entry_temp->last_phys_entry_va = pfe_rtable_phys_entry_get_va(rtable, (pfe_ct_rtable_entry_t *)(addr_t)oal_ntohl(phys_entry_temp->last_phys_entry_va->next));
-			}
-
-			/*	Link last entry with the new one. Both are in network byte order. */
-#if (TRUE == PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE)
-			/*	Invalidate the last entry first */
-			valid_tmp = phys_entry_temp->last_phys_entry_va->flags;
-			phys_entry_temp->last_phys_entry_va->flags = RT_FL_NONE;
-
-			/*	Wait some time due to sync with firmware */
-			oal_time_usleep(10U);
-#endif /* PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE */
-
-			/*	Update the next pointer */
-			phys_entry_temp->last_phys_entry_va->next = oal_htonl((uint32_t)((addr_t)phys_entry_temp->new_phys_entry_pa & 0xffffffffU));
-
-#if (TRUE == PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE)
-			/*	Ensure that all previous writes has been done */
-			hal_wmb();
-
-			/*	Re-enable the entry. Next (new last) entry remains invalid. */
-			phys_entry_temp->last_phys_entry_va->flags = valid_tmp;
-#endif /* PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE */
-		}
-	}
-
-	return ret;
-}
-
-/**
- * @brief		Add entry in the table
- * @param[in]	rtable The routing table instance
- * @param[in]	entry The entry to be added
- * @param[in]	phys_entry_temp Temporary saved entry to be added
+ * @param[in]	hash 5-tuple hash used for physical entry creation
+ * @param[out]	new_phys_entry_va The VA of the new entry location in the physical table
+ * @param[out]	last_phys_entry_va The VA of the last entry in the hash bucket prior to adding the new entry;
+ * 				   it's the same as the new entry VA if the bucket is empty.
+ * @param[out]	new_phys_entry_pa The PA (physical bus address) of the new entry location in the physical table.
  * @retval		EOK Success
  * @retval		ENOENT Routing table is full
  */
-static errno_t pfe_rtable_add_entry_id(pfe_rtable_t *rtable, pfe_rtable_entry_t *entry, pfe_rtable_phys_entry_infor_t *phys_entry_temp)
+static errno_t pfe_rtable_add_entry_by_hash(pfe_rtable_t *rtable, uint32_t hash, void **new_phys_entry_va, void **last_phys_entry_va, addr_t *new_phys_entry_pa)
 {
-	pfe_l2br_domain_t *domain;
-	pfe_ipv_type_t ipv_type = ((uint8_t)IPV4 == entry->phys_entry->flag_ipv6) ? IPV4: IPV6;
 	pfe_ct_rtable_entry_t *hash_table_va = (pfe_ct_rtable_entry_t *)rtable->htable_base_va;
+	pfe_ct_rtable_entry_t phys_entry_cache_tmp;
+#if (TRUE == PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE)
+	pfe_ct_rtable_flags_t valid_tmp;
+#endif /* PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE */
+	bool_t in_pool = FALSE;
 	errno_t ret = EOK;
-	uint8_t index;
-
-	phys_entry_temp->hash = pfe_rtable_entry_get_hash(entry, ipv_type, (rtable->htable_size - 1U));
-	entry->temp_phys_entry->flags = RT_FL_NONE;
-	entry->temp_phys_entry->status &= ~(uint8_t)RT_STATUS_ACTIVE;
-	index = pfe_rtable_get_free_stats_index(rtable);
-	entry->temp_phys_entry->conntrack_stats_index = oal_htons((uint16_t)index);
-
-	/* Add vlan stats index into the phy_entry structure */
-	if (0U != (oal_ntohl(entry->temp_phys_entry->actions) & ((uint32_t)RT_ACT_ADD_VLAN_HDR | (uint32_t)RT_ACT_MOD_VLAN_HDR)))
-	{
-		if (NULL != rtable->bridge)
-		{
-			domain = pfe_l2br_get_first_domain(rtable->bridge, L2BD_CRIT_BY_VLAN, (void *)(addr_t)oal_ntohs(entry->temp_phys_entry->args.vlan));
-			if (domain != NULL)
-			{
-				entry->temp_phys_entry->args.vlan_stats_index = oal_htons((uint16_t)pfe_l2br_get_vlan_stats_index(domain));
-			}
-			else
-			{
-				/* Index 0 is the fallback domain */
-				entry->temp_phys_entry->args.vlan_stats_index = 0;
-			}
-		}
-	}
+	addr_t pa, va;
 
+	pfe_rtable_read_phys_entry((addr_t)(&hash_table_va[hash]), &phys_entry_cache_tmp);
 	/*	Allocate 'real' entry from hash heads or pool */
-	if (0U == (oal_ntohl(hash_table_va[phys_entry_temp->hash].flags) & (uint32_t)RT_FL_VALID))
+	if (0U == (oal_ntohl(phys_entry_cache_tmp.flags) & (uint32_t)RT_FL_VALID))
 	{
-		phys_entry_temp->new_phys_entry_va = &hash_table_va[phys_entry_temp->hash];
+		*new_phys_entry_va = &hash_table_va[hash];
 	}
 	else
 	{
 		/*	First-level entry is already occupied. Create entry within the pool. Get
 			some free entry from the pool first. */
-		phys_entry_temp->new_phys_entry_va = fifo_get(rtable->pool_va);
-		if (NULL == phys_entry_temp->new_phys_entry_va)
+		*new_phys_entry_va = fifo_get(rtable->pool_va);
+		if (NULL == *new_phys_entry_va)
 		{
-			if (unlikely(EOK != oal_mutex_unlock(rtable->lock)))
-			{
-				NXP_LOG_DEBUG("Mutex unlock failed\n");
-			}
-
 			ret = ENOENT;
 		}
-		NXP_LOG_WARNING("Routing table hash [%u] collision detected. New entry will be added to linked list leading to performance penalty during lookup.\n", (uint_t)(phys_entry_temp->hash));
+		in_pool = TRUE;
+		NXP_LOG_WARNING("Routing table hash [0x%x] collision detected. New entry will be added to linked list leading to performance penalty during lookup.\n", (uint_t)hash);
 	}
 
-	if(EOK == ret)
+	if (EOK == ret)
 	{
 		/*	Find last entry in the chain */
-        phys_entry_temp->last_phys_entry_va = &hash_table_va[phys_entry_temp->hash];
-		ret = pfe_rtable_add_entry_link(rtable, phys_entry_temp);
-	}
+		*last_phys_entry_va = &hash_table_va[hash];
 
-	return ret;
-}
+		/*	Make sure the new entry is invalid */
+		pfe_rtable_read_phys_entry((addr_t)*new_phys_entry_va, &phys_entry_cache_tmp);
+		phys_entry_cache_tmp.flags = RT_FL_NONE;
+		if (FALSE == in_pool)
+		{
+			phys_entry_cache_tmp.next = 0U;
+		}
+		pfe_rtable_write_phys_entry((addr_t)*new_phys_entry_va, &phys_entry_cache_tmp);
 
-/**
- * @brief		Validate entry in the table
- * @param[in]	rtable The routing table instance
- * @param[in]	entry The entry to be added
- * @param[in]	phys_entry_temp Temporary saved hash to be used
- */
-static void pfe_rtable_add_entry_validate(pfe_rtable_t *rtable, pfe_rtable_entry_t *entry, pfe_rtable_phys_entry_infor_t *phys_entry_temp)
-{
-	/*	Validate the new entry */
-	entry->phys_entry->flags = (pfe_ct_rtable_flags_t)oal_htonl((uint32_t)RT_FL_VALID | (((uint8_t)IPV4 == entry->phys_entry->flag_ipv6) ? 0U : (uint32_t)RT_FL_IPV6));
-	entry->prev = (NULL == phys_entry_temp->last_phys_entry_va) ? NULL : pfe_rtable_get_by_phys_entry_va(rtable, phys_entry_temp->last_phys_entry_va);
-	entry->next = NULL;
-	if (NULL != entry->prev)
-	{
-		/*	Store pointer to the new entry */
-		entry->prev->next = entry;
+		/*	Get physical address */
+		va = (addr_t)*new_phys_entry_va;
+		pa = pfe_rtable_phys_entry_get_pa(rtable, va);
+		if (NULL_ADDR == pa)
+		{
+			NXP_LOG_ERROR("Couldn't get PA (entry @ v0x%p)\n", (void *)va);
+			if (pfe_rtable_phys_entry_is_pool(rtable, va))
+			{
+				/*	Entry from the pool. Return it. */
+				ret = fifo_put(rtable->pool_va, *new_phys_entry_va);
+				if (EOK != ret)
+				{
+					NXP_LOG_ERROR("Couldn't return routing table entry to the pool\n");
+				}
+			}
+
+			ret = EFAULT;
+		}
+		*new_phys_entry_pa = pa;
 	}
 
-	LLIST_AddAtEnd(&entry->list_entry, &rtable->active_entries);
+	if (EOK == ret && TRUE == in_pool)
+	{
+		/*	Find last entry in the chain */
+		pfe_rtable_read_phys_entry((addr_t)*last_phys_entry_va, &phys_entry_cache_tmp);
+		pa = (addr_t)oal_ntohl(phys_entry_cache_tmp.next);
+		while (NULL_ADDR != pa)
+		{
+			va = pfe_rtable_phys_entry_get_va(rtable, pa);
+			*last_phys_entry_va = (void *)va;
+			pfe_rtable_read_phys_entry((addr_t)*last_phys_entry_va, &phys_entry_cache_tmp);
+			pa = (addr_t)oal_ntohl(phys_entry_cache_tmp.next);
+		}
 
-	NXP_LOG_INFO("RTable entry added, hash: 0x%x\n", (uint_t)(phys_entry_temp->hash));
+		/*	Link last entry with the new one. Both are in network byte order. */
+#if (TRUE == PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE)
+		/*	Invalidate the last entry first */
+		valid_tmp = phys_entry_cache_tmp.flags;
+		phys_entry_cache_tmp.flags = RT_FL_NONE;
+		pfe_rtable_write_phys_entry((addr_t)*last_phys_entry_va, &phys_entry_cache_tmp);
 
-	entry->rtable = rtable;
+		/*	Wait some time due to sync with firmware */
+		oal_time_usleep(10U);
+#endif /* PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE */
 
-	if (0U == rtable->active_entries_count)
-	{
-		NXP_LOG_INFO("RTable first entry added, enable hardware RTable lookup\n");
-		pfe_class_rtable_lookup_enable(rtable->class);
-	}
+		/*	Update the next pointer */
+		phys_entry_cache_tmp.next = oal_htonl((uint32_t)(*new_phys_entry_pa & 0xffffffffU));
+		pfe_rtable_write_phys_entry((addr_t)*last_phys_entry_va, &phys_entry_cache_tmp);
 
-	rtable->active_entries_count++;
-	NXP_LOG_INFO("RTable active_entries_count: %u\n", (uint_t)(rtable->active_entries_count));
+#if (TRUE == PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE)
+		/*	Ensure that all previous writes has been done */
+		hal_wmb();
 
-	if (unlikely(EOK != oal_mutex_unlock(rtable->lock)))
-	{
-		NXP_LOG_DEBUG("Mutex unlock failed\n");
+		/*	Re-enable the entry. Next (new last) entry remains invalid. */
+		phys_entry_cache_tmp.flags = valid_tmp;
+		pfe_rtable_write_phys_entry((addr_t)*last_phys_entry_va, &phys_entry_cache_tmp);
+#endif /* PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE */
 	}
+
+	return ret;
 }
 
 /**
@@ -1944,7 +2114,13 @@ static void pfe_rtable_add_entry_validate(pfe_rtable_t *rtable, pfe_rtable_entry
  */
 errno_t pfe_rtable_add_entry(pfe_rtable_t *rtable, pfe_rtable_entry_t *entry)
 {
-	pfe_rtable_phys_entry_infor_t *phys_entry_temp;
+	pfe_ct_rtable_entry_t *phys_entry_cache = entry->phys_entry_cache;
+	void *new_phys_entry_va = NULL, *last_phys_entry_va = NULL;
+	addr_t new_phys_entry_pa = NULL_ADDR;
+	pfe_l2br_domain_t *domain;
+	pfe_ipv_type_t ipv_type;
+	uint32_t hash;
+	uint8_t index;
 	errno_t ret;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
@@ -1974,29 +2150,75 @@ errno_t pfe_rtable_add_entry(pfe_rtable_t *rtable, pfe_rtable_entry_t *entry)
 		return EEXIST;
 	}
 
-	phys_entry_temp = oal_mm_malloc(sizeof(pfe_rtable_phys_entry_infor_t));
-	(void)memset(phys_entry_temp, 0, sizeof(pfe_rtable_phys_entry_infor_t));
-
-	ret = pfe_rtable_add_entry_id(rtable, entry, phys_entry_temp);
+	ipv_type = ((uint8_t)IPV4 == phys_entry_cache->flag_ipv6) ? IPV4 : IPV6;
+	hash = pfe_rtable_entry_get_hash(phys_entry_cache, ipv_type, (rtable->htable_size - 1U));
 
-	if(EOK == ret)
+	ret = pfe_rtable_add_entry_by_hash(rtable, hash, &new_phys_entry_va, &last_phys_entry_va, &new_phys_entry_pa);
+	if (EOK == ret)
 	{
-		/*	Copy temporary entry into its destination (pool/hash entry) */
-		(void)memcpy(phys_entry_temp->new_phys_entry_va, entry->temp_phys_entry, sizeof(pfe_ct_rtable_entry_t));
+		/*	Remember the physical entry virtual address */
+		entry->phys_entry_va = (addr_t)new_phys_entry_va;
 
-		/*	Remember the real pointer */
-		entry->phys_entry = phys_entry_temp->new_phys_entry_va;
+		phys_entry_cache->status &= ~(uint8_t)RT_STATUS_ACTIVE;
+		index = pfe_rtable_get_free_stats_index(rtable);
+		phys_entry_cache->conntrack_stats_index = oal_htons((uint16_t)index);
+
+		/* Add vlan stats index into the phy_entry structure */
+		if (0U != (oal_ntohl(phys_entry_cache->actions) & ((uint32_t)RT_ACT_ADD_VLAN_HDR | (uint32_t)RT_ACT_MOD_VLAN_HDR)))
+		{
+			if (NULL != rtable->bridge)
+			{
+				domain = pfe_l2br_get_first_domain(rtable->bridge, L2BD_CRIT_BY_VLAN, (void *)(addr_t)oal_ntohs(phys_entry_cache->args.vlan));
+				if (domain != NULL)
+				{
+					phys_entry_cache->args.vlan_stats_index = oal_htons((uint16_t)pfe_l2br_get_vlan_stats_index(domain));
+				}
+				else
+				{
+					/* Index 0 is the fallback domain */
+					phys_entry_cache->args.vlan_stats_index = 0;
+				}
+			}
+		}
 
 		/*	Remember (physical) location of the new entry within the DDR. */
-		entry->phys_entry->rt_orig = oal_htonl((uint32_t)((addr_t)phys_entry_temp->new_phys_entry_pa));
+		phys_entry_cache->rt_orig = oal_htonl((uint32_t)new_phys_entry_pa);
 
 		/*	Just invalidate the ingress interface here to not confuse the firmware code */
-		entry->phys_entry->i_phy_if = PFE_PHY_IF_ID_INVALID;
+		phys_entry_cache->i_phy_if = PFE_PHY_IF_ID_INVALID;
+		phys_entry_cache->flags = (pfe_ct_rtable_flags_t)oal_htonl((uint32_t)RT_FL_VALID | (((uint8_t)IPV4 == ipv_type) ? 0U : (uint32_t)RT_FL_IPV6));
 
 		/*	Ensure that all previous writes has been done */
+		pfe_rtable_write_phys_entry(entry->phys_entry_va, phys_entry_cache);
 		hal_wmb();
 
-		pfe_rtable_add_entry_validate(rtable, entry, phys_entry_temp);
+		entry->prev_ble = (NULL == last_phys_entry_va) ? NULL : pfe_rtable_get_by_phys_entry_va(rtable, (addr_t)last_phys_entry_va);
+		entry->next_ble = NULL;
+		if (NULL != entry->prev_ble)
+		{
+			/*	Store pointer to the new entry */
+			entry->prev_ble->next_ble = entry;
+		}
+
+		LLIST_AddAtEnd(&entry->list_entry, &rtable->active_entries);
+
+		NXP_LOG_INFO("RTable entry added, hash: 0x%x\n", (uint_t)hash);
+
+		entry->rtable = rtable;
+
+		if (0U == rtable->active_entries_count)
+		{
+			NXP_LOG_INFO("RTable first entry added, enable hardware RTable lookup\n");
+			pfe_class_rtable_lookup_enable(rtable->class);
+		}
+
+		rtable->active_entries_count++;
+		NXP_LOG_INFO("RTable active_entries_count: %u\n", (uint_t)(rtable->active_entries_count));
+	}
+
+	if (unlikely(EOK != oal_mutex_unlock(rtable->lock)))
+	{
+		NXP_LOG_DEBUG("Mutex unlock failed\n");
 	}
 
 	return ret;
@@ -2055,7 +2277,8 @@ errno_t pfe_rtable_del_entry(pfe_rtable_t *rtable, pfe_rtable_entry_t *entry)
  */
 static errno_t pfe_rtable_del_entry_nolock(pfe_rtable_t *rtable, pfe_rtable_entry_t *entry)
 {
-	pfe_ct_rtable_entry_t *next_phys_entry_pa = NULL;
+	pfe_ct_rtable_entry_t *phys_entry_cache = entry->phys_entry_cache;
+	addr_t next_phys_entry_pa = NULL_ADDR;
 	errno_t ret;
 #if (TRUE == PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE)
 	pfe_ct_rtable_flags_t valid_tmp;
@@ -2074,23 +2297,26 @@ static errno_t pfe_rtable_del_entry_nolock(pfe_rtable_t *rtable, pfe_rtable_entr
 		return EOK;
 	}
 
-	if (TRUE == pfe_rtable_phys_entry_is_htable(rtable, entry->phys_entry))
+	if (TRUE == pfe_rtable_phys_entry_is_htable(rtable, entry->phys_entry_va))
 	{
 		/*	Invalidate the found entry. This will disable the whole chain. */
-		entry->phys_entry->flags = RT_FL_NONE;
-		if ( entry->temp_phys_entry->conntrack_stats_index != 0U)
+		pfe_rtable_read_phys_entry(entry->phys_entry_va, phys_entry_cache);
+		phys_entry_cache->flags = RT_FL_NONE;
+		pfe_rtable_write_phys_entry(entry->phys_entry_va, phys_entry_cache);
+		if (phys_entry_cache->conntrack_stats_index != 0U)
 		{
-			(void)pfe_rtable_clear_stats(rtable, oal_ntohs(entry->temp_phys_entry->conntrack_stats_index));
-			pfe_rtable_free_stats_index(oal_ntohs(entry->temp_phys_entry->conntrack_stats_index));
+			(void)pfe_rtable_clear_stats(rtable, oal_ntohs(phys_entry_cache->conntrack_stats_index));
+			pfe_rtable_free_stats_index(oal_ntohs(phys_entry_cache->conntrack_stats_index));
 		}
 
-		if (NULL != entry->next)
+		if (NULL != entry->next_ble)
 		{
+			pfe_rtable_read_phys_entry(entry->next_ble->phys_entry_va, entry->next_ble->phys_entry_cache);
 #if (TRUE == PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE)
 			/*	Invalidate also the next entry if any. This will prevent uncertainty
 				during copying next entry to the place of the found one. */
-			valid_tmp = entry->next->phys_entry->flags;
-			entry->next->phys_entry->flags = RT_FL_NONE;
+			valid_tmp = entry->next_ble->phys_entry_cache->flags;
+			pfe_rtable_clear_phys_entry(entry->next_ble->phys_entry_va);
 
 			/*	Ensure that all previous writes has been done */
 			hal_wmb();
@@ -2100,13 +2326,12 @@ static errno_t pfe_rtable_del_entry_nolock(pfe_rtable_t *rtable, pfe_rtable_entr
 #endif /* PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE */
 
 			/*	Replace hash table entry with next (pool) entry */
-			(void)memcpy(entry->phys_entry, entry->next->phys_entry, sizeof(pfe_ct_rtable_entry_t));
 
-			/*	Clear the copied entry (next one) and return it back to the pool */
-			(void)memset(entry->next->phys_entry, 0, sizeof(pfe_ct_rtable_entry_t));
-			if (TRUE == pfe_rtable_phys_entry_is_pool(rtable, entry->next->phys_entry))
+			/*	Clear the physical next (pool) entry and return it back to the pool */
+			pfe_rtable_clear_phys_entry(entry->next_ble->phys_entry_va);
+			if (TRUE == pfe_rtable_phys_entry_is_pool(rtable, entry->next_ble->phys_entry_va))
 			{
-				ret = fifo_put(rtable->pool_va, entry->next->phys_entry);
+				ret = fifo_put(rtable->pool_va, (void *)entry->next_ble->phys_entry_va);
 				if (EOK != ret)
 				{
 					NXP_LOG_ERROR("Couldn't return routing table entry to the pool\n");
@@ -2117,10 +2342,15 @@ static errno_t pfe_rtable_del_entry_nolock(pfe_rtable_t *rtable, pfe_rtable_entr
 				NXP_LOG_WARNING("Unexpected entry detected\n");
 			}
 
+			next_phys_entry_pa = pfe_rtable_phys_entry_get_pa(rtable, entry->phys_entry_va);
+			entry->next_ble->phys_entry_cache->rt_orig = oal_htonl((uint32_t)(next_phys_entry_pa & 0xffffffffU));
+#if (TRUE == PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE)
+			/*	Validate the new entry */
+			entry->next_ble->phys_entry_cache->flags = valid_tmp;
+#endif /* PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE */
+			pfe_rtable_write_phys_entry(entry->phys_entry_va, entry->next_ble->phys_entry_cache);
 			/*	Next entry now points to the copied physical one */
-			entry->next->phys_entry = entry->phys_entry;
-			next_phys_entry_pa = pfe_rtable_phys_entry_get_pa(rtable, entry->next->phys_entry);
-			entry->next->phys_entry->rt_orig = oal_htonl((uint32_t)((addr_t)next_phys_entry_pa & 0xffffffffU));
+			entry->next_ble->phys_entry_va = entry->phys_entry_va;
 
 			/*	Remove entry from the list of active entries and ensure consistency
 				of get_first() and get_next() calls */
@@ -2131,20 +2361,10 @@ static errno_t pfe_rtable_del_entry_nolock(pfe_rtable_t *rtable, pfe_rtable_entr
 
 			LLIST_Remove(&entry->list_entry);
 
-#if (TRUE == PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE)
-			/*	Validate the new entry */
-			entry->next->phys_entry->flags = valid_tmp;
-#endif /* PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE */
-
-			/*	Set up links */
-			if (NULL != entry->next)
-			{
-				entry->next->prev = entry->prev;
-			}
-
-			entry->prev = NULL;
-			entry->next = NULL;
-			entry->phys_entry = entry->temp_phys_entry;
+			entry->next_ble->prev_ble = entry->prev_ble;
+			entry->prev_ble = NULL;
+			entry->next_ble = NULL;
+			entry->phys_entry_va = NULL_ADDR;
 		}
 		else
 		{
@@ -2155,7 +2375,8 @@ static errno_t pfe_rtable_del_entry_nolock(pfe_rtable_t *rtable, pfe_rtable_entr
 			oal_time_usleep(10U);
 
 			/*	Zero-out the entry */
-			(void)memset(entry->phys_entry, 0, sizeof(pfe_ct_rtable_entry_t));
+			(void)memset(phys_entry_cache, 0, sizeof(pfe_ct_rtable_entry_t));
+			pfe_rtable_clear_phys_entry(entry->phys_entry_va);
 
 			/*	Remove entry from the list of active entries and ensure consistency
 				of get_first() and get_next() calls */
@@ -2166,39 +2387,45 @@ static errno_t pfe_rtable_del_entry_nolock(pfe_rtable_t *rtable, pfe_rtable_entr
 
 			LLIST_Remove(&entry->list_entry);
 
-			entry->prev = NULL;
-			entry->next = NULL;
-			entry->phys_entry = entry->temp_phys_entry;
+			entry->prev_ble = NULL;
+			entry->next_ble = NULL;
+			entry->phys_entry_va = NULL_ADDR;
 		}
 	}
-	else if (TRUE == pfe_rtable_phys_entry_is_pool(rtable, entry->phys_entry))
+	else if (TRUE == pfe_rtable_phys_entry_is_pool(rtable, entry->phys_entry_va))
 	{
+		pfe_rtable_read_phys_entry(entry->phys_entry_va, phys_entry_cache);
+		pfe_rtable_read_phys_entry(entry->prev_ble->phys_entry_va, entry->prev_ble->phys_entry_cache);
 #if (TRUE == PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE)
 		/*	Invalidate the previous entry */
-		valid_tmp = entry->prev->phys_entry->flags;
-		entry->prev->phys_entry->flags = RT_FL_NONE;
+		valid_tmp = entry->prev_ble->phys_entry_cache->flags;
+		entry->prev_ble->phys_entry_cache->flags = RT_FL_NONE;
+		pfe_rtable_write_phys_entry(entry->prev_ble->phys_entry_va, entry->prev_ble->phys_entry_cache);
 
 		/*	Invalidate the found entry */
-		entry->phys_entry->flags = RT_FL_NONE;
+		phys_entry_cache->flags = RT_FL_NONE;
+		pfe_rtable_write_phys_entry(entry->phys_entry_va, phys_entry_cache);
 
 		/*	Wait some time to sync with firmware */
 		oal_time_usleep(10U);
 #endif /* PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE */
 
 		/*	Bypass the found entry */
-		entry->prev->phys_entry->next = entry->phys_entry->next;
+		entry->prev_ble->phys_entry_cache->next = phys_entry_cache->next;
+		pfe_rtable_write_phys_entry(entry->prev_ble->phys_entry_va, entry->prev_ble->phys_entry_cache);
 
 #if (TRUE == PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE)
 		/*	Ensure that all previous writes has been done */
 		hal_wmb();
 
 		/*	Validate the previous entry */
-		entry->prev->phys_entry->flags = valid_tmp;
+		entry->prev_ble->phys_entry_cache->flags = valid_tmp;
+		pfe_rtable_write_phys_entry(entry->prev_ble->phys_entry_va, entry->prev_ble->phys_entry_cache);
 #endif /* PFE_RTABLE_CFG_PARANOID_ENTRY_UPDATE */
 
-		/*	Clear the found entry and return it back to the pool */
-		(void)memset(entry->phys_entry, 0, sizeof(pfe_ct_rtable_entry_t));
-		ret = fifo_put(rtable->pool_va, entry->phys_entry);
+		/*	Clear the found physical entry and return it back to the pool */
+		pfe_rtable_clear_phys_entry(entry->phys_entry_va);
+		ret = fifo_put(rtable->pool_va, (void *)entry->phys_entry_va);
 		if (EOK != ret)
 		{
 			NXP_LOG_ERROR("Couldn't return routing table entry to the pool\n");
@@ -2214,19 +2441,19 @@ static errno_t pfe_rtable_del_entry_nolock(pfe_rtable_t *rtable, pfe_rtable_entr
 		LLIST_Remove(&entry->list_entry);
 
 		/*	Set up links */
-		entry->prev->next = entry->next;
-		if (NULL != entry->next)
+		entry->prev_ble->next_ble = entry->next_ble;
+		if (NULL != entry->next_ble)
 		{
-			entry->next->prev = entry->prev;
+			entry->next_ble->prev_ble = entry->prev_ble;
 		}
 
-		entry->prev = NULL;
-		entry->next = NULL;
-		entry->phys_entry = entry->temp_phys_entry;
+		entry->prev_ble = NULL;
+		entry->next_ble = NULL;
+		entry->phys_entry_va = NULL_ADDR;
 	}
 	else
 	{
-		NXP_LOG_ERROR("Wrong address (found rtable entry @ v0x%p)\n", (void *)entry->phys_entry);
+		NXP_LOG_ERROR("Wrong address (found rtable entry @ v0x%p)\n", (void *)entry->phys_entry_va);
 	}
 
 	entry->rtable = NULL;
@@ -2276,18 +2503,27 @@ void pfe_rtable_do_timeouts(pfe_rtable_t *rtable)
 		LLIST_ForEach(item, &rtable->active_entries)
 		{
 			entry = LLIST_Data(item, pfe_rtable_entry_t, list_entry);
-			flags = (uint8_t)entry->phys_entry->status;
 
 			if (0xffffffffU == entry->timeout)
 			{
 				continue;
 			}
 
+			if (NULL_ADDR != entry->phys_entry_va)
+			{
+				pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+			}
+			flags = (uint8_t)entry->phys_entry_cache->status;
+
 			if (0U != ((uint8_t)RT_STATUS_ACTIVE & flags))
 			{
 				/*	Entry is active. Reset timeout and the active flag. */
 				entry->curr_timeout = entry->timeout;
-				entry->phys_entry->status &= ~(uint8_t)RT_STATUS_ACTIVE;
+				entry->phys_entry_cache->status &= ~(uint8_t)RT_STATUS_ACTIVE;
+				if (NULL_ADDR != entry->phys_entry_va)
+				{
+					pfe_rtable_write_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+				}
 			}
 			else
 			{
@@ -2494,21 +2730,19 @@ static errno_t pfe_rtable_destroy_stats_table(pfe_class_t *class, uint32_t table
  * @brief		Create routing table instance
  * @details		Creates and initializes routing table at given memory location.
  * @param[in]	class The classifier instance implementing the routing
- * @param[in]	htable_base_va Virtual address where the hash table shall be placed
- * @param[in]	htable_size Number of entries within the hash table
- * @param[in]	pool_base_va Virtual address where pool shall be placed
- * @param[in]	pool_size Number of entries within the pool
+ * @param[in]	bridge Reference to the bridge instance
+ * @param[in]	config Routing table config params
  * @return		The routing table instance or NULL if failed
  */
-pfe_rtable_t *pfe_rtable_create(pfe_class_t *class, addr_t htable_base_va, uint32_t htable_size, addr_t pool_base_va, uint32_t pool_size, pfe_l2br_t *bridge)
+pfe_rtable_t *pfe_rtable_create(pfe_class_t *class, pfe_l2br_t *bridge, pfe_rtable_cfg_t *config)
 {
-	pfe_rtable_t *rtable;
 	pfe_ct_rtable_entry_t *table_va;
+	pfe_rtable_t *rtable;
 	uint32_t ii;
 	errno_t ret;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely((NULL_ADDR == htable_base_va) || (NULL_ADDR == pool_base_va) || (NULL == class)))
+	if (unlikely((NULL_ADDR == config->htable_base_va) || (NULL_ADDR == config->pool_base_va) || (NULL == class) || (NULL == bridge)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
 		return NULL;
@@ -2540,17 +2774,18 @@ pfe_rtable_t *pfe_rtable_create(pfe_class_t *class, addr_t htable_base_va, uint3
 			if (EOK == oal_mutex_init(rtable->lock))
 			{
 				/*	Store properties */
-				rtable->htable_base_va = htable_base_va;
-				rtable->htable_base_pa = (addr_t)oal_mm_virt_to_phys_contig((void *)htable_base_va);
-				rtable->htable_size = htable_size;
+				rtable->htable_base_va = config->htable_base_va;
+				rtable->htable_base_pa = config->htable_base_pa;
+				rtable->htable_size = config->htable_size;
 				rtable->htable_end_va = rtable->htable_base_va + (rtable->htable_size * sizeof(pfe_ct_rtable_entry_t)) - 1U;
 				rtable->htable_end_pa = rtable->htable_base_pa + (rtable->htable_size * sizeof(pfe_ct_rtable_entry_t)) - 1U;
 
-				rtable->pool_base_va = pool_base_va;
-				rtable->pool_base_pa = rtable->htable_base_pa + (pool_base_va - htable_base_va);
-				rtable->pool_size = pool_size;
+				rtable->pool_base_va = config->pool_base_va;
+				rtable->pool_base_pa = config->pool_base_pa;
+				rtable->pool_size = config->pool_size;
 				rtable->pool_end_va = rtable->pool_base_va + (rtable->pool_size * sizeof(pfe_ct_rtable_entry_t)) - 1U;
 				rtable->pool_end_pa = rtable->pool_base_pa + (rtable->pool_size * sizeof(pfe_ct_rtable_entry_t)) - 1U;
+				rtable_in_lmem = config->lmem_allocated;
 				rtable->bridge = bridge;
 				rtable->class = class;
 				rtable->active_entries_count = 0;
@@ -2784,23 +3019,28 @@ errno_t pfe_rtable_entry_to_5t(const pfe_rtable_entry_t *entry, pfe_5_tuple_t *t
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
 		/*	Clean the destination */
 		(void)memset(tuple, 0, sizeof(pfe_5_tuple_t));
 
-		if ((uint8_t)IPV4 == entry->phys_entry->flag_ipv6)
+		if ((uint8_t)IPV4 == entry->phys_entry_cache->flag_ipv6)
 		{
 			/*	SRC + DST IP */
-			(void)memcpy(&tuple->src_ip.v4, &entry->phys_entry->ipv.v4.sip, 4);
-			(void)memcpy(&tuple->dst_ip.v4, &entry->phys_entry->ipv.v4.dip, 4);
+			(void)memcpy(&tuple->src_ip.v4, &entry->phys_entry_cache->ipv.v4.sip, 4);
+			(void)memcpy(&tuple->dst_ip.v4, &entry->phys_entry_cache->ipv.v4.dip, 4);
 			tuple->src_ip.is_ipv4 = TRUE;
 			tuple->dst_ip.is_ipv4 = TRUE;
 			ret = EOK;
 		}
-		else if ((uint8_t)IPV6 == entry->phys_entry->flag_ipv6)
+		else if ((uint8_t)IPV6 == entry->phys_entry_cache->flag_ipv6)
 		{
 			/*	SRC + DST IP */
-			(void)memcpy(&tuple->src_ip.v6, &entry->phys_entry->ipv.v6.sip[0], 16);
-			(void)memcpy(&tuple->dst_ip.v6, &entry->phys_entry->ipv.v6.dip[0], 16);
+			(void)memcpy(&tuple->src_ip.v6, &entry->phys_entry_cache->ipv.v6.sip[0], 16);
+			(void)memcpy(&tuple->dst_ip.v6, &entry->phys_entry_cache->ipv.v6.dip[0], 16);
 			tuple->src_ip.is_ipv4 = FALSE;
 			tuple->dst_ip.is_ipv4 = FALSE;
 			ret = EOK;
@@ -2813,9 +3053,9 @@ errno_t pfe_rtable_entry_to_5t(const pfe_rtable_entry_t *entry, pfe_5_tuple_t *t
 
 		if (EOK == ret)
 		{
-			tuple->sport = oal_ntohs(entry->phys_entry->sport);
-			tuple->dport = oal_ntohs(entry->phys_entry->dport);
-			tuple->proto = entry->phys_entry->proto;
+			tuple->sport = oal_ntohs(entry->phys_entry_cache->sport);
+			tuple->dport = oal_ntohs(entry->phys_entry_cache->dport);
+			tuple->proto = entry->phys_entry_cache->proto;
 		}
 	}
 
@@ -2843,29 +3083,34 @@ errno_t pfe_rtable_entry_to_5t_out(const pfe_rtable_entry_t *entry, pfe_5_tuple_
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
 		/*	Clean the destination */
 		(void)memset(tuple, 0, sizeof(pfe_5_tuple_t));
 
-		if ((uint8_t)IPV6 == entry->phys_entry->flag_ipv6)
+		if ((uint8_t)IPV6 == entry->phys_entry_cache->flag_ipv6)
 		{
 			/*	SRC + DST IP */
-			(void)memcpy(&tuple->src_ip.v6, &entry->phys_entry->args.ipv.v6.sip[0], 16);
-			(void)memcpy(&tuple->dst_ip.v6, &entry->phys_entry->args.ipv.v6.dip[0], 16);
+			(void)memcpy(&tuple->src_ip.v6, &entry->phys_entry_cache->args.ipv.v6.sip[0], 16);
+			(void)memcpy(&tuple->dst_ip.v6, &entry->phys_entry_cache->args.ipv.v6.dip[0], 16);
 			tuple->src_ip.is_ipv4 = FALSE;
 			tuple->dst_ip.is_ipv4 = FALSE;
 		}
 		else
 		{
 			/*	SRC + DST IP */
-			(void)memcpy(&tuple->src_ip.v4, &entry->phys_entry->args.ipv.v4.sip, 4);
-			(void)memcpy(&tuple->dst_ip.v4, &entry->phys_entry->args.ipv.v4.dip, 4);
+			(void)memcpy(&tuple->src_ip.v4, &entry->phys_entry_cache->args.ipv.v4.sip, 4);
+			(void)memcpy(&tuple->dst_ip.v4, &entry->phys_entry_cache->args.ipv.v4.dip, 4);
 			tuple->src_ip.is_ipv4 = TRUE;
 			tuple->dst_ip.is_ipv4 = TRUE;
 		}
 
-		tuple->sport = oal_ntohs(entry->phys_entry->args.sport);
-		tuple->dport = oal_ntohs(entry->phys_entry->args.dport);
-		tuple->proto = entry->phys_entry->proto;
+		tuple->sport = oal_ntohs(entry->phys_entry_cache->args.sport);
+		tuple->dport = oal_ntohs(entry->phys_entry_cache->args.dport);
+		tuple->proto = entry->phys_entry_cache->proto;
 		ret = EOK;
 	}
 
@@ -2894,6 +3139,11 @@ static bool_t pfe_rtable_match_criterion(pfe_rtable_get_criterion_t crit, const
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
+		if (NULL_ADDR != entry->phys_entry_va)
+		{
+			pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+		}
+
 		switch (crit)
 		{
 			case RTABLE_CRIT_ALL:
@@ -2901,15 +3151,15 @@ static bool_t pfe_rtable_match_criterion(pfe_rtable_get_criterion_t crit, const
 				break;
 
 			case RTABLE_CRIT_ALL_IPV4:
-				match = ((uint8_t)IPV4 == entry->phys_entry->flag_ipv6);
+				match = ((uint8_t)IPV4 == entry->phys_entry_cache->flag_ipv6);
 				break;
 
 			case RTABLE_CRIT_ALL_IPV6:
-				match = ((uint8_t)IPV6 == entry->phys_entry->flag_ipv6);
+				match = ((uint8_t)IPV6 == entry->phys_entry_cache->flag_ipv6);
 				break;
 
 			case RTABLE_CRIT_BY_DST_IF:
-				match = (pfe_phy_if_get_id(arg->iface) == (pfe_ct_phy_if_id_t)entry->phys_entry->e_phy_if);
+				match = (pfe_phy_if_get_id(arg->iface) == (pfe_ct_phy_if_id_t)entry->phys_entry_cache->e_phy_if);
 				break;
 
 			case RTABLE_CRIT_BY_ROUTE_ID:
@@ -2917,7 +3167,7 @@ static bool_t pfe_rtable_match_criterion(pfe_rtable_get_criterion_t crit, const
 				break;
 
 			case RTABLE_CRIT_BY_ID5T:
-				match = (arg->id5t == entry->phys_entry->id5t);
+				match = (arg->id5t == entry->phys_entry_cache->id5t);
 				break;
 
 			case RTABLE_CRIT_BY_5_TUPLE:
@@ -2960,7 +3210,7 @@ pfe_rtable_entry_t *pfe_rtable_get_first(pfe_rtable_t *rtable, pfe_rtable_get_cr
 	bool_t known_crit = TRUE;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely((NULL == rtable) || (NULL == arg)))
+	if (unlikely((NULL == rtable)))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
 		entry = NULL;
@@ -3243,7 +3493,7 @@ uint32_t pfe_rtable_get_text_statistics(const pfe_rtable_t *rtable, char_t *buf,
 	}
 	else
 	{
-		len += oal_util_snprintf(buf + len, buf_len - len, "Default				  hit: %12d hit_bytes: %12d\n", stats.hit, stats.hit_bytes);
+		len += oal_util_snprintf(buf + len, buf_len - len, "Default				  hit: %12lu hit_bytes: %12lu\n", stats.hit, stats.hit_bytes);
 
 		/*	Protect table accesses */
 		if (unlikely(EOK != oal_mutex_lock(rtable->lock)))
@@ -3255,16 +3505,21 @@ uint32_t pfe_rtable_get_text_statistics(const pfe_rtable_t *rtable, char_t *buf,
 		{
 			entry = LLIST_Data(item, pfe_rtable_entry_t, list_entry);
 
-			if (oal_ntohs(entry->phys_entry->conntrack_stats_index) != 0U)
+			if (NULL_ADDR != entry->phys_entry_va)
+			{
+				pfe_rtable_read_phys_entry(entry->phys_entry_va, entry->phys_entry_cache);
+			}
+
+			if (oal_ntohs(entry->phys_entry_cache->conntrack_stats_index) != 0U)
 			{
-				ret = pfe_rtable_get_stats(rtable, &stats, oal_ntohs(entry->phys_entry->conntrack_stats_index));
+				ret = pfe_rtable_get_stats(rtable, &stats, oal_ntohs(entry->phys_entry_cache->conntrack_stats_index));
 
 				if (EOK != ret)
 				{
 					continue;
 				}
 
-				len += oal_util_snprintf(buf + len, buf_len - len, "Conntrack route_id %2d hit: %12d hit_bytes: %12d\n", oal_ntohl(entry->route_id) , stats.hit, stats.hit_bytes);
+				len += oal_util_snprintf(buf + len, buf_len - len, "Conntrack route_id %2d hit: %12lu hit_bytes: %12lu\n", oal_ntohl(entry->route_id) , stats.hit, stats.hit_bytes);
 			}
 		}
 
diff --git a/sw/pfe_platform/src/pfe_util.c b/sw/pfe_platform/src/pfe_util.c
index 967f0e3..46ae4cc 100644
--- a/sw/pfe_platform/src/pfe_util.c
+++ b/sw/pfe_platform/src/pfe_util.c
@@ -94,7 +94,7 @@ static bool_t pfe_util_check_new_fw_features(pfe_util_t *util, errno_t *ret, uin
 		else
 		{
 			/* Set the low level data in the feature */
-			(void)pfe_fw_feature_set_ll_data(util->fw_features[features_idx], entry);
+			(void)pfe_fw_feature_set_ll_data(util->fw_features[features_idx], entry, util->pe_num);
 			/* Set the feature string base */
 			*ret = pfe_fw_feature_set_string_base(util->fw_features[features_idx], pfe_pe_get_fw_feature_str_base(util->pe[0U]));
 			if(EOK != *ret)
diff --git a/sw/xfci/libfci/public/fpp_ext.h b/sw/xfci/libfci/public/fpp_ext.h
index 785ca90..0cf8538 100644
--- a/sw/xfci/libfci/public/fpp_ext.h
+++ b/sw/xfci/libfci/public/fpp_ext.h
@@ -3369,6 +3369,46 @@ typedef struct CAL_PACKED_ALIGNED(2)
 } fpp_fw_features_cmd_t;
 /* [fpp_fw_features_cmd_t] */
 
+#define FPP_CMD_FW_FEATURE_ELEMENT				0xf260
+#define FPP_ERR_FW_FEATURE_ELEMENT_NOT_FOUND		0xf261
+#define FPP_ERR_FW_FEATURE_ELEMENT_READ_ONLY		0xf262
+
+enum CAL_PACKED
+{
+    FW_FEATURE_ELEMENT_DEFAUT = 0U,
+    FW_FEATURE_ELEMENT_CONFIG = 1U,
+    FW_FEATURE_ELEMENT_STATS = 2U
+};
+
+/* [fpp_fw_feature_element_cmd_t] */
+typedef struct CAL_PACKED_ALIGNED(4)
+{
+    uint16_t action;                                 /*< Action */
+    char fw_feature_name[FPP_FEATURE_NAME_SIZE + 1]; /*< Name of a fw feature (see fpp_fw_features_cmd_t) */
+    char element_name[FPP_FEATURE_NAME_SIZE + 1];    /*< Name of the fw feature's target element */
+    uint8_t group; /*< Element group
+                                             0 == ANY ; No group specified. Special value, intended only for FPP_ACTION_QUERY.
+                                                        FPP_ACTION_QUERY command with EMPTY element_name[] and with this group starts
+                                                        a QUERY/QUERY_CONT process that will successively report all elements of 
+                                                        the parent fw feature (regardless of their element group).
+                                             1 == CFG  ;Configuration group. Command with this group can target only some configuration element.
+                                                        FPP_ACTION_QUERY command with EMPTY element_name[] and with this group starts
+                                                        a QUERY/QUERY_CONT process that will successively report all configuration elements of 
+                                                        the parent fw feature.
+                                             2 == STATS ; Statistics group. Command with this group can target only some statistics element.
+                                                        FPP_ACTION_QUERY command with EMPTY element_name[] and with this group starts
+                                                        a QUERY/QUERY_CONT process that will successively report all statistics elements of 
+                                                        the parent fw feature. */
+
+    uint8_t unit_size;     /*< Byte size of element's data unit.
+                               Data unit exact size (and underlying data type) is feature and element specific.
+                               See appropriate documentation of fw feature elements. */
+    uint8_t index;         /*< Index into element's data (as laid out in PFE firmware) which correspond with the first data unit in the .payload */
+    uint8_t count;         /*< Count of consecutive data units in the .payload */
+    uint8_t payload[128];  /*< Data (composed of one or more data units). */
+} fpp_fw_features_element_cmd_t;
+/* [fpp_fw_feature_element_cmd_t] */
+
 /**
  * @def         FPP_CMD_FCI_OWNERSHIP_LOCK
  * @brief       FCI command to get FCI ownership.
-- 
2.25.1

