From a917dcf8aa1795913e0ec6f0ee3507e53110b700 Mon Sep 17 00:00:00 2001
From: "jan.petrous" <jan.petrous@nxp.com>
Date: Tue, 17 Aug 2021 15:20:59 +0200
Subject: [PATCH 3/4] version BLN_PFE-DRV_S32G_A53_LNX_BETA_0.9.5 RC3

libfci_cli added.

Upstream-Status: Pending

Signed-off-by: Jan Petrous <jan.petrous@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 PFE_S32G_A53_LNX_BETA_0.9.5_ReleaseNotes.txt  |   92 +-
 PFE_S32G_A53_LNX_BETA_0.9.5_SCR.txt           |    5 +
 sw/libfci_cli/Makefile                        |  143 +
 sw/libfci_cli/src/libfci_cli.c                |   86 +
 sw/libfci_cli/src/libfci_cli_cmds_bd.c        |  545 ++
 sw/libfci_cli/src/libfci_cli_cmds_bd.h        |   39 +
 sw/libfci_cli/src/libfci_cli_cmds_fp.c        |  320 +
 sw/libfci_cli/src/libfci_cli_cmds_fp.h        |   35 +
 sw/libfci_cli/src/libfci_cli_cmds_fwfeat.c    |  151 +
 sw/libfci_cli/src/libfci_cli_cmds_fwfeat.h    |   28 +
 sw/libfci_cli/src/libfci_cli_cmds_if.c        |  668 ++
 sw/libfci_cli/src/libfci_cli_cmds_if.h        |   33 +
 sw/libfci_cli/src/libfci_cli_cmds_qos.c       |  435 +
 sw/libfci_cli/src/libfci_cli_cmds_qos.h       |   34 +
 .../src/libfci_cli_cmds_route_and_cntk.c      |  770 ++
 .../src/libfci_cli_cmds_route_and_cntk.h      |   37 +
 sw/libfci_cli/src/libfci_cli_cmds_spd.c       |  249 +
 sw/libfci_cli/src/libfci_cli_cmds_spd.h       |   29 +
 sw/libfci_cli/src/libfci_cli_common.h         |  511 ++
 sw/libfci_cli/src/libfci_cli_def_cmds.c       | 1029 +++
 sw/libfci_cli/src/libfci_cli_def_cmds.h       |  647 ++
 sw/libfci_cli/src/libfci_cli_def_help.c       | 2469 +++++
 sw/libfci_cli/src/libfci_cli_def_help.h       |   27 +
 .../src/libfci_cli_def_optarg_keywords.c      |  617 ++
 .../src/libfci_cli_def_optarg_keywords.h      |  402 +
 sw/libfci_cli/src/libfci_cli_def_opts.c       | 8036 +++++++++++++++++
 sw/libfci_cli/src/libfci_cli_def_opts.h       | 4670 ++++++++++
 sw/libfci_cli/src/libfci_cli_parser.c         | 3843 ++++++++
 sw/libfci_cli/src/libfci_cli_parser.h         |   27 +
 sw/libfci_cli/src/libfci_cli_print_helpers.c  |  137 +
 sw/libfci_cli/src/libfci_cli_print_helpers.h  |   34 +
 .../src/libfci_interface/fci_common.c         |  162 +
 .../src/libfci_interface/fci_common.h         |   41 +
 sw/libfci_cli/src/libfci_interface/fci_ep.c   |   72 +
 sw/libfci_cli/src/libfci_interface/fci_ep.h   |   29 +
 sw/libfci_cli/src/libfci_interface/fci_fp.c   |  715 ++
 sw/libfci_cli/src/libfci_interface/fci_fp.h   |   58 +
 .../src/libfci_interface/fci_fwfeat.c         |  235 +
 .../src/libfci_interface/fci_fwfeat.h         |   41 +
 .../src/libfci_interface/fci_l2_bd.c          | 1193 +++
 .../src/libfci_interface/fci_l2_bd.h          |   92 +
 .../src/libfci_interface/fci_log_if.c         | 1715 ++++
 .../src/libfci_interface/fci_log_if.h         |  102 +
 .../src/libfci_interface/fci_phy_if.c         |  979 ++
 .../src/libfci_interface/fci_phy_if.h         |   93 +
 sw/libfci_cli/src/libfci_interface/fci_qos.c  | 1119 +++
 sw/libfci_cli/src/libfci_interface/fci_qos.h  |   74 +
 .../src/libfci_interface/fci_rt_ct.c          | 1785 ++++
 .../src/libfci_interface/fci_rt_ct.h          |  116 +
 sw/libfci_cli/src/libfci_interface/fci_spd.c  |  588 ++
 sw/libfci_cli/src/libfci_interface/fci_spd.h  |   56 +
 51 files changed, 35372 insertions(+), 41 deletions(-)
 create mode 100644 sw/libfci_cli/Makefile
 create mode 100644 sw/libfci_cli/src/libfci_cli.c
 create mode 100644 sw/libfci_cli/src/libfci_cli_cmds_bd.c
 create mode 100644 sw/libfci_cli/src/libfci_cli_cmds_bd.h
 create mode 100644 sw/libfci_cli/src/libfci_cli_cmds_fp.c
 create mode 100644 sw/libfci_cli/src/libfci_cli_cmds_fp.h
 create mode 100644 sw/libfci_cli/src/libfci_cli_cmds_fwfeat.c
 create mode 100644 sw/libfci_cli/src/libfci_cli_cmds_fwfeat.h
 create mode 100644 sw/libfci_cli/src/libfci_cli_cmds_if.c
 create mode 100644 sw/libfci_cli/src/libfci_cli_cmds_if.h
 create mode 100644 sw/libfci_cli/src/libfci_cli_cmds_qos.c
 create mode 100644 sw/libfci_cli/src/libfci_cli_cmds_qos.h
 create mode 100644 sw/libfci_cli/src/libfci_cli_cmds_route_and_cntk.c
 create mode 100644 sw/libfci_cli/src/libfci_cli_cmds_route_and_cntk.h
 create mode 100644 sw/libfci_cli/src/libfci_cli_cmds_spd.c
 create mode 100644 sw/libfci_cli/src/libfci_cli_cmds_spd.h
 create mode 100644 sw/libfci_cli/src/libfci_cli_common.h
 create mode 100644 sw/libfci_cli/src/libfci_cli_def_cmds.c
 create mode 100644 sw/libfci_cli/src/libfci_cli_def_cmds.h
 create mode 100644 sw/libfci_cli/src/libfci_cli_def_help.c
 create mode 100644 sw/libfci_cli/src/libfci_cli_def_help.h
 create mode 100644 sw/libfci_cli/src/libfci_cli_def_optarg_keywords.c
 create mode 100644 sw/libfci_cli/src/libfci_cli_def_optarg_keywords.h
 create mode 100644 sw/libfci_cli/src/libfci_cli_def_opts.c
 create mode 100644 sw/libfci_cli/src/libfci_cli_def_opts.h
 create mode 100644 sw/libfci_cli/src/libfci_cli_parser.c
 create mode 100644 sw/libfci_cli/src/libfci_cli_parser.h
 create mode 100644 sw/libfci_cli/src/libfci_cli_print_helpers.c
 create mode 100644 sw/libfci_cli/src/libfci_cli_print_helpers.h
 create mode 100644 sw/libfci_cli/src/libfci_interface/fci_common.c
 create mode 100644 sw/libfci_cli/src/libfci_interface/fci_common.h
 create mode 100644 sw/libfci_cli/src/libfci_interface/fci_ep.c
 create mode 100644 sw/libfci_cli/src/libfci_interface/fci_ep.h
 create mode 100644 sw/libfci_cli/src/libfci_interface/fci_fp.c
 create mode 100644 sw/libfci_cli/src/libfci_interface/fci_fp.h
 create mode 100644 sw/libfci_cli/src/libfci_interface/fci_fwfeat.c
 create mode 100644 sw/libfci_cli/src/libfci_interface/fci_fwfeat.h
 create mode 100644 sw/libfci_cli/src/libfci_interface/fci_l2_bd.c
 create mode 100644 sw/libfci_cli/src/libfci_interface/fci_l2_bd.h
 create mode 100644 sw/libfci_cli/src/libfci_interface/fci_log_if.c
 create mode 100644 sw/libfci_cli/src/libfci_interface/fci_log_if.h
 create mode 100644 sw/libfci_cli/src/libfci_interface/fci_phy_if.c
 create mode 100644 sw/libfci_cli/src/libfci_interface/fci_phy_if.h
 create mode 100644 sw/libfci_cli/src/libfci_interface/fci_qos.c
 create mode 100644 sw/libfci_cli/src/libfci_interface/fci_qos.h
 create mode 100644 sw/libfci_cli/src/libfci_interface/fci_rt_ct.c
 create mode 100644 sw/libfci_cli/src/libfci_interface/fci_rt_ct.h
 create mode 100644 sw/libfci_cli/src/libfci_interface/fci_spd.c
 create mode 100644 sw/libfci_cli/src/libfci_interface/fci_spd.h

diff --git a/PFE_S32G_A53_LNX_BETA_0.9.5_ReleaseNotes.txt b/PFE_S32G_A53_LNX_BETA_0.9.5_ReleaseNotes.txt
index e7d653a..0c59bc5 100644
--- a/PFE_S32G_A53_LNX_BETA_0.9.5_ReleaseNotes.txt
+++ b/PFE_S32G_A53_LNX_BETA_0.9.5_ReleaseNotes.txt
@@ -7,6 +7,18 @@ All product or service names are the property of their respective owners.
 Copyright (C) 2018-2021 NXP
 ****************************************************************************************************
 
+========================================================
+What is new in this release
+========================================================
+This release has BETA quality status in terms of testing and quality documentation.
+
+The main goals of this release are:
+1) provide an improved Suspend to RAM (STR) feature support,
+2) introduce the AUX interface feature implementation.
+
+The release includes also other features (i.e. MAC unicast filtering) and many improvements,
+as well as an important number of bug fixes (see detailed list below).
+
 ========================================================
 Installation
 ========================================================
@@ -34,8 +46,6 @@ Release Specifics:
         S32GRV-PLATEVB 700-30081
         X-S32G-PROCEVB-S 700-32170
 
-- This release has BETA quality status in terms of testing and quality documentation
-
 ========================================================
 Supported Features:
 ========================================================
@@ -91,26 +101,51 @@ Compatible firmware: BLN_PFE-FW_S32G_RTM_1.0.0
 What's Modified in BETA_0.9.5
 ========================================================
 
+# New Feature
+
+[AAVB-2328] - [PFE_LINUX] HIF traffic steering
+[AAVB-2827] - [PFE_LINUX] Aux interface support
+[AAVB-3398] - [PFE_LINUX] Add support for multiple MAC unicast addresses (MAC unicast filtering)
+[AAVB-3633] - [PFE_LINUX] Improved suspend to RAM (STR) support - restore net device configs
+
 # Bug
 
-[AAVB-2149] - [PFE_LINUX]Promiscuous mode not working
+[AAVB-2149] - [PFE_LINUX] Promiscuous mode not working
 [AAVB-2320] - [PFE_LINUX] pfeng: mtu setting doesn't work of value < 68
+[AAVB-2973] - [PFE_LINUX] Configured Bridge outputs periodic backtrace dumps
+[AAVB-3187] - [PFE_LINUX] Observed zero throughput results for slow path bi-directional tests
+[AAVB-3196] - [PFE_LINUX] each pfeX interface should be found by of_find_net_device_by_node
+[AAVB-3375] - [PFE_LINUX] "ERR: No timer was running" on rmmod
+[AAVB-3496] - [PFE_LINUX] sw bridged traffic gets damaged on output
+[AAVB-3580] - [PFE_LINUX] Transition to IDEX_REQ_STATE_TRANSMITTED failed
+[AAVB-3611] - [PFE_LINUX] Replace pfe_log_if_*() MAC filtering API with pfe_phy_if_*() equivalent
+[AAVB-3639] - [PFE_LINUX] linux interface in PFENG_LOGIF_MODE_TX_CLASS mode don't work
+[AAVB-3671] - [PFE_LINUX][PFE_PLATFORM] use-after-free in _raw_spin_lock_irqsave
+
+# Improvement
+
+[AAVB-2700] - [PFE_LINUX] pfeng: follow SGMII configuration for PHY config
+[AAVB-2866] - [PFE_DRV_LINUX] Map functional tests to requirements
+[AAVB-3066] - [PFE_LINUX] Move TX confirmation processing to NAPI
+[AAVB-3340] - [PFE_LINUX] libfci_cli: Fix build warnings
+[AAVB-3374] - [PFE_LINUX] STR: guard all necessary functions by pm_runtime_get_sync
+[AAVB-3451] - [PFE_LINUX] use-case: run driver w/o u-boot dependency
+[AAVB-3636] - [PFE_LINUX] Configure hif channel interrupt affinity hint to distribute interrupt load
+
+
+# PFE Platform changes (Common code among multiple drivers)
+## PFE Platform - New Feature
+[AAVB-1602] - [PFE_PLATFORM] HIF NOCPY LMEM copy mode
+[AAVB-3404] - [PFE_PLATFORM] Fast path router uses phyif MAC as default source address make this configurable
+
+## PFE Platform - Bug
 [AAVB-2326] - [PFE_PLATFORM] Logical interface 'discard' API missing in slave variant
-[AAVB-2445] - [ALB 25.0]Observed zero throughput numbers for Rx traffic while measuring IPerf3 UDP self termination traffic for 1518B frame size.
-[AAVB-2448] - Observed "Zero Throughput numbers" while measuring IPv4/IPv6 routing Bi-directional RAW/UDP traffic
-[AAVB-2695] - [ALB 27.0] [Regression]: Observed "0" throughput number for IPv4 64B while measuring Slow path routing performance
-[AAVB-2973] - [PFE_DRV_LINUX] Configured Bridge outputs periodic backtrace
-[AAVB-3187] - [BSP28]Observed zero throughput results for slow path bi-directional tests using spirent
-[AAVB-3192] - [BSP28] Observed zero throughput results while measuring IPerf3 UDP bi-directional ROUTING throughput results.
-[AAVB-3196] - [PFE_DRV_LINUX] each pfeX interface should be found by of_find_net_device_by_node
-[AAVB-3197] - [PFE_DRV_LINUX] pinctrl-0/pinctrl-names properties are ignored
-[AAVB-3375] - [PFE][Linux] "ERR: No timer was running" on rmmod
-[AAVB-3377] - [PFE_DRV_QNX][PFE_PLATFORM] Driver reports a couple of build errors when PFE_CFG_NULL_ARG_CHECK is enabled
+[AAVB-3377] - [PFE_PLATFORM] Driver reports a couple of build errors when PFE_CFG_NULL_ARG_CHECK is enabled
 [AAVB-3378] - [PFE_PLATFORM] SIP/DIP replacement flags rewrite other flags.
 [AAVB-3380] - [PFE_PLATFORM] Rx interrupt coalescing configuration failed
 [AAVB-3385] - [PFE_PLATFORM] libFCI: FW feature struct has too small buffer for some FW feature names
 [AAVB-3406] - [PFE_PLATFORM] Incorrect return value when reading QoS shaper idle slope
-[AAVB-3414] - [PFE_PLATFORM] Memory leak when mac address is already in db.
+[AAVB-3414] - [PFE_PLATFORM] Memory leak when mac address is already in db
 [AAVB-3415] - [PFE_PLATFORM] MAC database memory leak when MAC addr addition fails
 [AAVB-3417] - [PFE_PLATFORM] libFCI: Missing ntoh() conversions in conntrack handling
 [AAVB-3418] - [PFE_PLATFORM] libFCI: Wrong return value of ".vlan" and ".vlan_reply" fields in IPv4 conntracks
@@ -119,48 +154,23 @@ What's Modified in BETA_0.9.5
 [AAVB-3458] - [PFE_PLATFORM] Forwarding list of MAC static entry is not propagated to HW
 [AAVB-3478] - [PFE_PLATFORM] IDEX buffers not allocated from a controlled pool
 [AAVB-3482] - [PFE_PLATFORM] FCI: HIF_NOCPY is skipped when updating a logical interface
-[AAVB-3496] - [PFE_LINUX] sw bridged traffic gets damaged on output
-[AAVB-3527] - [PFE_PLATFORM] Platform doesn't clear all states on destroy (issue for suspend)
 [AAVB-3570] - [PFE_PLATFORM] pfe_idex_rpc not callable from atomic context
 [AAVB-3574] - [PFE_PLATFORM] Type pfe_ip_addr_t in pfe_rtable.h is too large
 [AAVB-3578] - [PFE_PLATFORM] pfe_idex_rpc RPC transport time-out when enabling MAC filtering on slave
 [AAVB-3579] - [PFE_PLATFORM] Physical interface flags are set incorrectly
-[AAVB-3580] - [PFE_LINUX] Transition to IDEX_REQ_STATE_TRANSMITTED failed
-[AAVB-3611] - [PFE_LINUX] Replace pfe_log_if_*() MAC filtering API with pfe_phy_if_*() equivalent
-[AAVB-3639] - [PFE_LINUX] linux interface in PFENG_LOGIF_MODE_TX_CLASS mode don't work
 [AAVB-3658] - [PFE_PLATFORM] HIF NOCPY - Buffer descriptors wrap mechanism does not work
-[AAVB-3671] - [PFE_PLATFORM][PFE_LINUX]use-after-free in _raw_spin_lock_irqsave
-
-# New Feature
-
-[AAVB-1602] - [PFE_PLATFORM] HIF NOCPY LMEM copy mode
-[AAVB-1872] - [PFE_PLATFORM] All buffers shall be returned at driver shutdown phase
-[AAVB-2086] - Move fci_msg_t definition to the fci_msg.h
-[AAVB-2205] - [PFE_QNX] Return provided buffers
-[AAVB-2328] - [PFE_LINUX] HIF traffic steering
-[AAVB-2827] - [PFE_DRV_LINUX] Aux Interface support
-[AAVB-3398] - [PFE_LINUX] Add support for multiple MAC unicast addreses
-[AAVB-3404] - [PFE_PLATFORM] Fast path router uses phyif MAC as default source address make this configurable
-[AAVB-3633] - [PFE_LINUX] STR: v2, netinterface config changes support
-
-# Improvement
 
+## PFE Platform - Improvement
 [AAVB-1645] - [PFE_PLATFORM] Interrupt dispatchers
+[AAVB-2086] - [PFE_PLATFORM] Move fci_msg_t definition to the fci_msg.h
 [AAVB-2304] - [PFE_PLATFORM] Allow to set the physical interface to promiscuous mode via FCI
 [AAVB-2350] - [PFE_PLATFORM] Add FCI usage examples, stage 3
 [AAVB-2511] - [PFE_PLATFORM][PFE_FW] Remove PE ID passing
-[AAVB-2700] - [PFE_LINUX] pfeng: follow SGMII configuration for PHY config
 [AAVB-2807] - [PFE_FW] HIF no copy/LMEM copy mode
 [AAVB-2938] - [PFE_PLATFORM] Static entry documentation update
-[AAVB-3066] - [PFE_LINUX] pfeng: move TXconf to NAPI
-[AAVB-3129] - [PFE_DRV_LINUX] Make FCI endpoint OS-independent - Linux replica
-[AAVB-3374] - [PFE_LINUX] STR: guard all necessary functions by pm_runtime_get_sync
-[AAVB-3420] - [PFE_PLATFORM] Update libFCI documentation with demo codes from libFCI_cli
 [AAVB-3431] - [PFE_PLATFORM] Remove compilation warnings
-[AAVB-3451] - [PFE_LINUX] use-case: run driver w/o u-boot dependency
 [AAVB-3467] - [PFE_PLATFORM] Disable PFE_CFG_HIF_NOCPY_SUPPORT in PFE SLAVE mode
 [AAVB-3471] - [PFE_PLATFORM] Optimize PE memory access locks
-[AAVB-3636] - [PFE_LINUX] Configure hif channel interrupt affinity hint to distribute interrupt load
 [AAVB-3649] - [PFE_PLATFORM] libfci_cli: Add rebuilding of libfci library to libfci_cli makefile
 [AAVB-3669] - [PFE_PLATFORM] Fix master/slave to work again
 
diff --git a/PFE_S32G_A53_LNX_BETA_0.9.5_SCR.txt b/PFE_S32G_A53_LNX_BETA_0.9.5_SCR.txt
index e13d416..260c600 100644
--- a/PFE_S32G_A53_LNX_BETA_0.9.5_SCR.txt
+++ b/PFE_S32G_A53_LNX_BETA_0.9.5_SCR.txt
@@ -41,3 +41,8 @@ Component:              FCI
 Component:              ct_assert.h
     Description:        Compile-time assert implementation
     License:            GNU All-Permissive License
+
+Component:              LIBFCI_CLI
+    Location:           sw/libfci_cli/
+    Description:        Example FCI config tool
+    License:            BSD-3
diff --git a/sw/libfci_cli/Makefile b/sw/libfci_cli/Makefile
new file mode 100644
index 0000000..601225b
--- /dev/null
+++ b/sw/libfci_cli/Makefile
@@ -0,0 +1,143 @@
+# =========================================================================
+#  Copyright 2018-2021 NXP
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice,
+#    this list of conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice,
+#    this list of conditions and the following disclaimer in the documentation
+#    and/or other materials provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors
+#    may be used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+# =========================================================================
+
+ifndef __KERNEL__
+include ../build_env.mak
+endif
+
+ARTIFACT = libfci_cli
+TARGET = $(OUTPUT_DIR)/$(ARTIFACT)
+
+#Build profile. Possible values: release, debug, profile, coverage
+BUILD_PROFILE ?= release
+
+#Build string for architecture/variant.
+CONFIG_NAME ?= $(PLATFORM)-$(BUILD_PROFILE)
+OUTPUT_DIR = build/$(CONFIG_NAME)
+
+TARGET_OS ?= QNX
+
+#Specific configuration per TARGET_OS.
+ifeq ($(TARGET_OS),LINUX)
+	LD = $(PLATFORM)-gcc
+	LIBS += -L../xfci/libfci/build/$(PLATFORM)-$(BUILD_PROFILE) -l:libfci.a
+	
+	#Expand GLOBAL_CCFLAGS to get rid of single quotes around string parameters of GLOBAL_CCFLAGS.
+	#Those single quotes are utilized in build process of the Linux PFE driver, but they cause warnings in this makefile.
+	GLOBAL_CCFLAGS := $(shell echo $(GLOBAL_CCFLAGS))
+	
+	LIBFCI_CLI_TARGET_OS = "LNX"
+	LIBFCI_CLI_VERSION = "BETA 0.9.5"
+else
+#This branch by defaut means QNX.
+	LIBS += -L../xfci/libfci/build/$(PLATFORM)-$(BUILD_PROFILE) -l:libfci.a
+	LIBS_all += -lsocket
+	
+	LIBFCI_CLI_TARGET_OS = "QNX"
+	LIBFCI_CLI_VERSION = "$(RELEASE_VERSION)"
+endif
+
+#User defined include/preprocessor flags and libraries
+INCLUDES += -Isrc/libfci_interface \
+			-I../xfci/libfci/public \
+			-I../fci/public \
+			-I../common/public \
+			-I./src/libfci_interface
+
+#Dependencies
+DEPENDENCIES = $(subst -L,,$(subst $(EMPTY) $(EMPTY)-l:,/,$(LIBS)))
+
+#Compiler flags for build profiles
+CCFLAGS_release += -O3
+CCFLAGS_debug += -g -O0 -fno-builtin
+CCFLAGS_coverage += -g -O0 -ftest-coverage -fprofile-arcs -nopipe -Wc,-auxbase-strip,$@
+LDFLAGS_coverage += -ftest-coverage -fprofile-arcs
+CCFLAGS_profile += -g -O0 -finstrument-functions
+LIBS_profile += -lprofilingS
+
+#Generic compiler flags (which include build type flags)
+CCFLAGS_all += -Wall -fmessage-length=0
+CCFLAGS_all += $(CCFLAGS_$(BUILD_PROFILE))
+CCFLAGS_all += -D$(PFE_CFG_TARGET_ARCH_DEF) -D$(PFE_CFG_TARGET_OS_DEF) -D$(PFE_CFG_BUILD_PROFILE_DEF)
+#Shared library has to be compiled with -fPIC
+#CCFLAGS_all += -fPIC
+LDFLAGS_all += $(LDFLAGS_$(BUILD_PROFILE))
+LIBS_all += $(LIBS_$(BUILD_PROFILE))
+DEPS = -Wp,-MMD,$(@:%.o=%.d),-MT,$@
+
+#Versioning info - MD5 hash of pfe_ct.h + most recent commit in this project's git.
+PFE_CT_H_START_OFFSET=$(word 1, $(shell cat -n ../pfe_platform/public/pfe_ct.h | sed -n '/=== \*/,$$p'))
+PFE_CT_H_MD5 = $(word 1, $(shell cat ../pfe_platform/public/pfe_ct.h | sed -n '$(PFE_CT_H_START_OFFSET),$$p' | tr -d '\040\011\012\015' | md5sum))
+CCFLAGS += -DGLOBAL_VERSION_CONTROL_ID=\"$(shell git log -1 --pretty=format:"%h")\"
+CCFLAGS += -DPFE_CT_H_MD5=\"$(PFE_CT_H_MD5)\"
+CCFLAGS += -DLIBFCI_CLI_VERSION=\"$(LIBFCI_CLI_VERSION)\"
+CCFLAGS += -DLIBFCI_CLI_TARGET_OS=\"$(LIBFCI_CLI_TARGET_OS)\"
+
+#Macro to expand files recursively: parameters $1 -  directory, $2 - extension, i.e. cpp
+rwildcard = $(wildcard $(addprefix $1/*.,$2)) $(foreach d,$(wildcard $1/*),$(call rwildcard,$d,$2))
+
+#Source list
+SRCS = $(call rwildcard, src, c)
+
+#Object files list
+OBJS = $(addprefix $(OUTPUT_DIR)/,$(addsuffix .o, $(basename $(SRCS))))
+
+#Deps building rule
+.PHONY: $(DEPENDENCIES)
+$(DEPENDENCIES):
+	@make --no-print-directory -C $(subst build/$(PLATFORM)-$(BUILD_PROFILE),,$(dir $@))
+
+#Compiling rule
+$(OUTPUT_DIR)/%.o: %.c
+	@mkdir -p $(dir $@)
+	$(CC) -c $(DEPS) -o $@ $(INCLUDES) $(CCFLAGS_all) $(CCFLAGS) $(GLOBAL_CCFLAGS) $<
+
+#Linking rule
+EMPTY =
+$(TARGET):$(OBJS) $(subst -L,,$(subst $(EMPTY) $(EMPTY)-l:,/,$(LIBS)))
+	$(LD) -o $(TARGET) $(LDFLAGS_all) $(LDFLAGS) $(OBJS) $(LIBS_all) $(LIBS)
+	cp $(TARGET) $(ARTIFACT) 
+
+#Rules section for default compilation and linking
+all: $(TARGET)
+
+.PHONY clean:
+clean: $(addsuffix .clean,$(DEPENDENCIES))
+	rm -fr $(OUTPUT_DIR)
+
+#Deps cleaning rule
+%.clean:
+	make --no-print-directory -C $(subst build/$(PLATFORM)-$(BUILD_PROFILE),,$(dir $@)) clean
+
+
+rebuild: clean all
+
+#Inclusion of dependencies (object files to source and includes)
+-include $(OBJS:%.o=%.d)
diff --git a/sw/libfci_cli/src/libfci_cli.c b/sw/libfci_cli/src/libfci_cli.c
new file mode 100644
index 0000000..9152ac0
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli.c
@@ -0,0 +1,86 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#include <assert.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include "libfci_cli_common.h"
+#include "libfci_cli_def_help.h"
+#include "libfci_cli_parser.h"
+#include "fci_ep.h"
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+FCI_CLIENT* cli_p_cl = NULL;
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+void cli_print_error(int rtncode, const char* p_txt_err, ...)
+{
+    assert(NULL != p_txt_err);
+
+    printf("ERROR (%d): ", rtncode);
+    
+    va_list args;
+    va_start(args, p_txt_err);
+    vprintf(p_txt_err, args);
+    va_end(args);
+    
+    printf("\n");
+}
+
+int main(int argc, char* argv[])
+{
+    #if !defined(NDEBUG)
+        #warning "DEBUG build"
+        printf("\nWARNING: DEBUG build\n");
+    #endif
+    
+    
+    int rtn = CLI_ERR;
+    
+    printf("DISCLAIMER: This is a DEMO application. It is not part of the production code deliverables.\n");
+    
+    if (1 >= argc)
+    {
+        cli_print_app_version();
+        cli_print_help(0);
+    }
+    
+    rtn = fci_ep_open_in_cmd_mode(&cli_p_cl);
+    if (CLI_OK != rtn)
+    {
+        cli_print_error(rtn, "FCI endpoint failed to open.");
+    }
+    else
+    {
+        rtn = cli_parse_and_execute(argv, argc);
+    }
+    
+    /* close FCI (do not hide behind rtn check) */
+    if (NULL != cli_p_cl)
+    {
+        const int rtn_close = fci_ep_close(cli_p_cl);
+        rtn = ((CLI_OK == rtn) ? (rtn_close) : (rtn));
+        if (CLI_OK != rtn_close)
+        {
+            cli_print_error(rtn_close, "FCI endpoint failed to close.");
+        }
+    }
+    
+    return (rtn);
+}
+
+/* ========================================================================= */
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_bd.c b/sw/libfci_cli/src/libfci_cli_cmds_bd.c
new file mode 100644
index 0000000..b17805c
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_cmds_bd.c
@@ -0,0 +1,545 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#include <assert.h>
+#include <inttypes.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <string.h>
+#include "libfci_cli_common.h"
+#include "libfci_cli_def_opts.h"
+#include "libfci_cli_print_helpers.h"
+#include "libfci_cli_def_optarg_keywords.h"
+#include "libfci_cli_cmds_bd.h"
+
+#include "libfci_interface/fci_l2_bd.h"
+
+/* ==== TESTMODE vars ====================================================== */
+
+#if !defined(NDEBUG)
+/* empty */
+#endif
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+extern FCI_CLIENT* cli_p_cl;
+
+/* ==== PRIVATE FUNCTIONS : prints for BD_STENT ============================ */
+
+static int stent_print_aux(const fpp_l2_static_ent_cmd_t* p_stent, bool is_nested_in_bd)
+{
+    assert(NULL != p_stent);
+    
+    
+    /* NOTE: native data type to comply with 'printf()' conventions (asterisk specifier) */ 
+    int indent = ((is_nested_in_bd) ? (8) : (0));
+    
+    {
+        const char* p_txt_local = (0 != (p_stent->local)) ? ("[local address]") : ("");
+        printf("%-*sMAC: ", indent, "");
+        cli_print_mac(p_stent->mac);
+        printf("  %s\n", p_txt_local);
+    }
+    
+    indent += 5;  /* detailed static entry info is indented deeper */
+    
+    if (!is_nested_in_bd)
+    {
+        printf("%-*svlan: %"PRIu16"\n", indent, "", (p_stent->vlan));
+    }
+    
+    {
+        const char* p_txt_local = (0 != (p_stent->local)) ? (" (ignored when local)") : ("");
+        printf("%-*segress%s: ", indent, "", p_txt_local);
+        cli_print_bitset32((p_stent->forward_list), ",", cli_value2txt_phyif, "---");
+        printf("\n");
+    }
+    
+    printf("%-*sdiscard-on-match-src: %s\n", indent, "", cli_value2txt_on_off(p_stent->src_discard));
+    printf("%-*sdiscard-on-match-dst: %s\n", indent, "", cli_value2txt_on_off(p_stent->dst_discard));
+    
+    return (FPP_ERR_OK);
+}
+
+static inline int stent_print(const fpp_l2_static_ent_cmd_t* p_stent)
+{
+    return stent_print_aux(p_stent, false);
+}
+
+static inline int stent_print_in_bd(const fpp_l2_static_ent_cmd_t* p_stent)
+{
+    return stent_print_aux(p_stent, true);
+}
+
+/* ==== PRIVATE FUNCTIONS : prints for BD ================================== */
+
+static int bd_print_aux(const fpp_l2_bd_cmd_t* p_bd, bool is_verbose)
+{
+    assert(NULL != p_bd);
+    
+    
+    /* NOTE: native data type to comply with 'printf()' conventions (asterisk specifier) */ 
+    int indent = 0;
+    
+    {
+        const char *const p_txt_def = (fci_l2_bd_ld_is_default(p_bd)  ? ("[default]")  : (""));
+        const char *const p_txt_fbk = (fci_l2_bd_ld_is_fallback(p_bd) ? ("[fallback]") : (""));
+        printf("%-*sdomain %02"PRIu16"  %s%s\n", indent, "",
+        (p_bd->vlan), p_txt_def, p_txt_fbk);
+    }
+    
+    indent += 4;
+    
+    {
+        const uint32_t phyifs_bitset = (p_bd->if_list) & ~(p_bd->untag_if_list);
+        printf("%-*sphyifs (tagged)   : ", indent, "");
+        cli_print_bitset32(phyifs_bitset, ",", cli_value2txt_phyif, "---");
+        printf("\n");
+    }
+    {
+        const uint32_t phyifs_bitset = (p_bd->if_list) & (p_bd->untag_if_list);
+        printf("%-*sphyifs (untagged) : ", indent, "");
+        cli_print_bitset32(phyifs_bitset, ",", cli_value2txt_phyif, "---");
+        printf("\n");
+    }
+    {
+        printf("%-*sucast-hit  action : %"PRIu8" (%s)\n"
+               "%-*sucast-miss action : %"PRIu8" (%s)\n"
+               "%-*smcast-hit  action : %"PRIu8" (%s)\n"
+               "%-*smcast-miss action : %"PRIu8" (%s)\n",
+               indent, "", (p_bd->ucast_hit) , cli_value2txt_bd_action(p_bd->ucast_hit),
+               indent, "", (p_bd->ucast_miss), cli_value2txt_bd_action(p_bd->ucast_miss),
+               indent, "", (p_bd->mcast_hit) , cli_value2txt_bd_action(p_bd->mcast_hit),
+               indent, "", (p_bd->mcast_miss), cli_value2txt_bd_action(p_bd->mcast_miss));
+    }
+    
+    if (is_verbose)
+    {
+        uint16_t cnt = 0u;
+        fci_l2_stent_get_count_by_vlan(cli_p_cl, &cnt, (p_bd->vlan));
+        const char* p_txt_dashes_if_none = ((0u == cnt) ? ("---") : (""));
+        printf("%-*sstatic entries: %s\n", indent, "", p_txt_dashes_if_none);
+    }
+    
+    return (FPP_ERR_OK);
+}
+
+static inline int bd_print(const fpp_l2_bd_cmd_t* p_bd)
+{
+    return bd_print_aux(p_bd, false);
+}
+
+static inline int bd_print_verbose(const fpp_l2_bd_cmd_t* p_bd)
+{
+    bd_print_aux(p_bd, true);
+    return fci_l2_stent_print_by_vlan(cli_p_cl, stent_print_in_bd, (p_bd->vlan));
+}
+
+/* ==== PUBLIC FUNCTIONS : BD ============================================== */
+
+int cli_cmd_bd_print(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_l2_bd_cmd_t bd = {0};
+    
+    /* check for mandatory opts */
+    /* empty */
+    
+    /* exec */
+    const fci_l2_bd_cb_print_t p_cb_print = ((p_cmdargs->verbose.is_valid) ? (bd_print_verbose) : (bd_print));
+    if (p_cmdargs->vlan.is_valid)
+    {
+        /* print a single bridge domain */
+        rtn = fci_l2_bd_get_by_vlan(cli_p_cl, &bd, (p_cmdargs->vlan.value));
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = p_cb_print(&bd);
+        }
+    }
+    else
+    {
+        /* print all bridge domains */
+        rtn = fci_l2_bd_print_all(cli_p_cl, p_cb_print);
+    }
+
+    return (rtn);
+}
+
+int cli_cmd_bd_update(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_l2_bd_cmd_t bd = {0};
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = {{OPT_VLAN, NULL, (p_cmdargs->vlan.is_valid)}};
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* get init local data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_l2_bd_get_by_vlan(cli_p_cl, &bd, (p_cmdargs->vlan.value));
+    }
+    
+    /* modify local data - hit/miss actions */
+    if (FPP_ERR_OK == rtn)
+    {
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->ucast_hit.is_valid))
+        {
+            rtn = fci_l2_bd_ld_set_ucast_hit(&bd, (p_cmdargs->ucast_hit.value));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->ucast_miss.is_valid))
+        {
+            rtn = fci_l2_bd_ld_set_ucast_miss(&bd, (p_cmdargs->ucast_miss.value));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->mcast_hit.is_valid))
+        {
+            rtn = fci_l2_bd_ld_set_mcast_hit(&bd, (p_cmdargs->mcast_hit.value));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->mcast_miss.is_valid))
+        {
+            rtn = fci_l2_bd_ld_set_mcast_miss(&bd, (p_cmdargs->mcast_miss.value));
+        }
+    }
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_l2_bd_update(cli_p_cl, &bd);
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_bd_add(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = {{OPT_VLAN, NULL, (p_cmdargs->vlan.is_valid)}};
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_l2_bd_add(cli_p_cl, NULL, (p_cmdargs->vlan.value));
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_bd_del(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = {{OPT_VLAN, NULL, (p_cmdargs->vlan.is_valid)}};
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /*  exec  */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_l2_bd_del(cli_p_cl, (p_cmdargs->vlan.value));
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_bd_insif(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_l2_bd_cmd_t bd = {0};
+    uint32_t phyif_id = 0uL;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_VLAN, NULL, (p_cmdargs->vlan.is_valid)},
+        {OPT_INTERFACE, NULL, (p_cmdargs->if_name.is_valid)},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* convert phyif name to phyif ID */
+    if (FPP_ERR_OK == rtn)
+    {
+        uint8_t tmp_value = 0u;
+        rtn = cli_txt2value_phyif(&tmp_value, (p_cmdargs->if_name.txt));
+        if (FPP_ERR_OK == rtn)
+        {
+            phyif_id = tmp_value; /* implicit cast */
+        }
+    }
+    
+    /* get init local data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_l2_bd_get_by_vlan(cli_p_cl, &bd, (p_cmdargs->vlan.value));
+    }
+    
+    /* modify local data */
+    if (FPP_ERR_OK == rtn)
+    {
+        const bool is_vlan_tag = ((p_cmdargs->tag.is_valid) ? (p_cmdargs->tag.is_on) : (false));
+        rtn = fci_l2_bd_ld_insert_phyif(&bd, phyif_id, is_vlan_tag);
+    }
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_l2_bd_update(cli_p_cl, &bd);
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_bd_remif(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_l2_bd_cmd_t bd = {0};
+    uint32_t phyif_id = 0uL;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_VLAN, NULL, (p_cmdargs->vlan.is_valid)},
+        {OPT_INTERFACE, NULL, (p_cmdargs->if_name.is_valid)},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* convert phyif name to phyif ID */
+    if (FPP_ERR_OK == rtn)
+    {
+        uint8_t tmp_value = 0u;
+        rtn = cli_txt2value_phyif(&tmp_value, (p_cmdargs->if_name.txt));
+        if (FPP_ERR_OK == rtn)
+        {
+            phyif_id = tmp_value; /* implicit cast */
+        }
+    }
+    
+    /* get init local data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_l2_bd_get_by_vlan(cli_p_cl, &bd, (p_cmdargs->vlan.value));
+    }
+    
+    /* modify local data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_l2_bd_ld_remove_phyif(&bd, phyif_id);
+    }
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_l2_bd_update(cli_p_cl, &bd);
+    }
+    
+    return (rtn);
+}
+
+/* ==== PUBLIC FUNCTIONS : BD_STENT ======================================== */
+
+int cli_cmd_bd_stent_print(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    /* empty */
+    
+    /* exec */
+    if (p_cmdargs->vlan.is_valid)
+    {
+        /* print all static entries affiliated with given bridge domain */
+        rtn = fci_l2_stent_print_by_vlan(cli_p_cl, stent_print, (p_cmdargs->vlan.value));
+    }
+    else
+    {
+        /* print all static entries (regardless of bridge domain affiliation) */
+        rtn = fci_l2_stent_print_all(cli_p_cl, stent_print);
+    }
+
+    return (rtn);
+}
+
+int cli_cmd_bd_stent_update(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_l2_static_ent_cmd_t stent = {0};
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_VLAN, NULL, (p_cmdargs->vlan.is_valid)},
+        {OPT_MAC,  NULL, (p_cmdargs->smac.is_valid)},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* get init local data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_l2_stent_get_by_vlanmac(cli_p_cl, &stent, (p_cmdargs->vlan.value), (p_cmdargs->smac.arr));
+    }
+    
+    /* modify local data */
+    if (FPP_ERR_OK == rtn)
+    {
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->egress.is_valid))
+        {
+            rtn = fci_l2_stent_ld_set_fwlist(&stent, (p_cmdargs->egress.bitset));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->local.is_valid))
+        {
+            rtn = fci_l2_stent_ld_set_local(&stent, (p_cmdargs->local.is_on));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->vlan_conf__x_src.is_valid))
+        {
+            rtn = fci_l2_stent_ld_set_src_discard(&stent, (p_cmdargs->vlan_conf__x_src.is_on));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->ptp_conf__x_dst.is_valid))
+        {
+            rtn = fci_l2_stent_ld_set_dst_discard(&stent, (p_cmdargs->ptp_conf__x_dst.is_on));
+        }
+    }
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_l2_stent_update(cli_p_cl, &stent);
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_bd_stent_add(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_VLAN, NULL, (p_cmdargs->vlan.is_valid)},
+        {OPT_MAC,  NULL, (p_cmdargs->smac.is_valid)},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_l2_stent_add(cli_p_cl, NULL, (p_cmdargs->vlan.value), (p_cmdargs->smac.arr));
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_bd_stent_del(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_VLAN, NULL, (p_cmdargs->vlan.is_valid)},
+        {OPT_MAC,  NULL, (p_cmdargs->smac.is_valid)},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_l2_stent_del(cli_p_cl, (p_cmdargs->vlan.value), (p_cmdargs->smac.arr));
+    }
+    
+    return (rtn);
+}
+
+/* ==== PUBLIC FUNCTIONS : FLUSH =========================================== */
+
+int cli_cmd_bd_flush(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_optbuf_t asd = {{OPT_ALL, OPT_STATIC, OPT_DYNAMIC}};
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_NONE, &asd, ((p_cmdargs->all.is_valid) || (p_cmdargs->static0.is_valid) || (p_cmdargs->dynamic0.is_valid))},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        if (p_cmdargs->all.is_valid)
+        {
+            rtn = fci_l2_flush_all(cli_p_cl);
+        }
+        if (p_cmdargs->static0.is_valid)
+        {
+            rtn = fci_l2_flush_static(cli_p_cl);
+        }
+        if (p_cmdargs->dynamic0.is_valid)
+        {
+            rtn = fci_l2_flush_learned(cli_p_cl);
+        }
+    }
+    
+    return (rtn);
+}
+
+/* ========================================================================= */
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_bd.h b/sw/libfci_cli/src/libfci_cli_cmds_bd.h
new file mode 100644
index 0000000..5849875
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_cmds_bd.h
@@ -0,0 +1,39 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef LIBFCI_CLI_CMDS_BD_H_
+#define LIBFCI_CLI_CMDS_BD_H_
+
+#include "libfci_cli_common.h"
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+int cli_cmd_bd_print(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_bd_update(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_bd_add(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_bd_del(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_bd_insif(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_bd_remif(const cli_cmdargs_t *p_cmdargs);
+
+int cli_cmd_bd_stent_print(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_bd_stent_update(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_bd_stent_add(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_bd_stent_del(const cli_cmdargs_t *p_cmdargs);
+
+int cli_cmd_bd_flush(const cli_cmdargs_t *p_cmdargs);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_fp.c b/sw/libfci_cli/src/libfci_cli_cmds_fp.c
new file mode 100644
index 0000000..a1011a0
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_cmds_fp.c
@@ -0,0 +1,320 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#include <assert.h>
+#include <inttypes.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <string.h>
+#include "libfci_cli_common.h"
+#include "libfci_cli_def_opts.h"
+#include "libfci_cli_print_helpers.h"
+#include "libfci_cli_def_optarg_keywords.h"
+#include "libfci_cli_cmds_fp.h"
+
+#include "libfci_interface/fci_fp.h"
+
+/* ==== TESTMODE vars ====================================================== */
+
+#if !defined(NDEBUG)
+/* empty */
+#endif
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+extern FCI_CLIENT* cli_p_cl;
+
+static bool stt_do_header_print = false;
+
+/* ==== PRIVATE FUNCTIONS : prints ========================================= */
+
+static void fprule_header_print(unsigned int indent)
+{
+    printf("%-*s|  pos  | rule name       | data       | mask       | offset | offset-from | invert | match-action              |\n"
+           "%-*s|=======|=================|============|============|========|=============|========|===========================|\n", indent, "", indent, "");
+}
+
+static int fprule_print_aux(const fpp_fp_rule_props_t* p_rule_props, uint16_t position, unsigned int indent)
+{
+    assert(NULL != p_rule_props);
+    
+    if (stt_do_header_print)
+    {
+        fprule_header_print(indent);
+        stt_do_header_print = false;
+    }
+    
+    printf("%-*s| %5"PRIu16" | %-15s | 0x%08"PRIX32" | 0x%08"PRIX32" |  %5"PRIu16" | %-11s | %-6s | %-9s %-15s |\n", indent, "",
+           position, (p_rule_props->rule_name), (p_rule_props->data), (p_rule_props->mask),
+           (p_rule_props->offset), cli_value2txt_offset_from(p_rule_props->offset_from),
+           cli_value2txt_on_off(p_rule_props->invert), cli_value2txt_match_action(p_rule_props->match_action),
+           (p_rule_props->next_rule_name));
+    
+    return (FPP_ERR_OK);
+}
+
+static inline int fptable_rule_print(const fpp_fp_rule_props_t* p_rule_props, uint16_t position)
+{
+    return fprule_print_aux(p_rule_props, position, 2u);
+}
+
+static inline int fprule_print(const fpp_fp_rule_props_t* p_rule_props, uint16_t position)
+{
+    return fprule_print_aux(p_rule_props, position, 0u);
+}
+
+/* ==== PUBLIC FUNCTIONS : fptable ========================================= */
+
+int cli_cmd_fptable_print(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = {{OPT_TABLE, NULL, (p_cmdargs->table0_name.is_valid)}};
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        const uint16_t pos = ((p_cmdargs->offset.is_valid) ? (p_cmdargs->offset.value) : (0u));
+        const uint16_t cnt = ((p_cmdargs->count_ethtype.is_valid) ? (p_cmdargs->count_ethtype.value) : (0u));
+        stt_do_header_print = true;
+        rtn = fci_fp_table_print(cli_p_cl, fptable_rule_print, (p_cmdargs->table0_name.txt), pos, cnt);
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_fptable_add(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = {{OPT_TABLE, NULL, (p_cmdargs->table0_name.is_valid)}};
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /*  exec  */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_fp_table_add(cli_p_cl, (p_cmdargs->table0_name.txt));
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_fptable_del(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = {{OPT_TABLE, NULL, (p_cmdargs->table0_name.is_valid)}};
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_fp_table_del(cli_p_cl, (p_cmdargs->table0_name.txt));
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_fptable_insrule(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_TABLE, NULL, (p_cmdargs->table0_name.is_valid)},
+        {OPT_RULE,  NULL, (p_cmdargs->ruleA0_name.is_valid)}
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        const uint16_t pos = ((p_cmdargs->offset.is_valid) ? (p_cmdargs->offset.value) : (UINT16_MAX));
+        rtn = fci_fp_table_insert_rule(cli_p_cl, (p_cmdargs->table0_name.txt), (p_cmdargs->ruleA0_name.txt), pos);
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_fptable_remrule(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_TABLE, NULL, (p_cmdargs->table0_name.is_valid)},
+        {OPT_RULE,  NULL, (p_cmdargs->ruleA0_name.is_valid)}
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_fp_table_remove_rule(cli_p_cl, (p_cmdargs->table0_name.txt), (p_cmdargs->ruleA0_name.txt));
+    }
+    
+    return (rtn);
+}
+
+/* ==== PUBLIC FUNCTIONS : fprule ========================================== */
+
+int cli_cmd_fprule_print(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_fp_rule_cmd_t fprule = {0};
+    
+    /* check for mandatory opts */
+    /* empty */
+    
+    /* exec */
+    if (p_cmdargs->ruleA0_name.is_valid)
+    {
+        /* print a single rule */
+        uint16_t idx = 0u;
+        rtn = fci_fp_rule_get_by_name(cli_p_cl, &fprule, &idx, (p_cmdargs->ruleA0_name.txt));
+        if (FPP_ERR_OK == rtn)
+        {
+            stt_do_header_print = true;
+            rtn = fprule_print(&(fprule.r), idx);
+        }
+    }
+    else
+    {
+        /* print all rules */
+        const uint16_t pos = ((p_cmdargs->offset.is_valid) ? (p_cmdargs->offset.value) : (0u));
+        const uint16_t cnt = ((p_cmdargs->count_ethtype.is_valid) ? (p_cmdargs->count_ethtype.value) : (0u));
+        stt_do_header_print = true;
+        rtn = fci_fp_rule_print_all(cli_p_cl, fprule_print, pos, cnt);
+    }
+
+    return (rtn);
+}
+
+int cli_cmd_fprule_add(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_fp_rule_cmd_t fprule = {0};
+    
+    /* check for mandatory opts */
+    const mandopt_optbuf_t arn = {{OPT_ACCEPT, OPT_REJECT, OPT_NEXT_RULE}};
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_RULE,   NULL,  (p_cmdargs->ruleA0_name.is_valid)},
+        {OPT_DATA,   NULL,  (p_cmdargs->data_hifc_sad.is_valid)},
+        {OPT_MASK,   NULL,  (p_cmdargs->mask_spi.is_valid)},
+        {OPT_OFFSET, NULL,  (p_cmdargs->offset.is_valid)},
+        {OPT_LAYER,  NULL,  (p_cmdargs->layer.is_valid)},
+        {OPT_NONE,   &arn, ((p_cmdargs->accept.is_valid) || (p_cmdargs->reject.is_valid) || (p_cmdargs->ruleB0_name.is_valid))}
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* get init local data */
+    /* empty (no 'init data' from the PFE) */
+    
+    /* modify local data */
+    if (FPP_ERR_OK == rtn)
+    {
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = fci_fp_rule_ld_set_data(&fprule, (p_cmdargs->data_hifc_sad.value));
+        }
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = fci_fp_rule_ld_set_mask(&fprule, (p_cmdargs->mask_spi.value));
+        }
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = fci_fp_rule_ld_set_offset(&fprule, (p_cmdargs->offset.value), (p_cmdargs->layer.value));
+        }
+        if (FPP_ERR_OK == rtn)
+        {
+            fpp_fp_rule_match_action_t match_action = ((p_cmdargs->accept.is_valid) ? (FP_ACCEPT) :
+                                                      ((p_cmdargs->ruleB0_name.is_valid) ? (FP_NEXT_RULE) : 
+                                                       (FP_REJECT)));
+            const char* p_txt = ((p_cmdargs->ruleB0_name.is_valid) ? (p_cmdargs->ruleB0_name.txt) : (NULL));
+            rtn = fci_fp_rule_ld_set_match_action(&fprule, match_action, p_txt);
+        }
+        
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->invert.is_valid))  /* this one is optional, hence validity check */
+        {
+            rtn = fci_fp_rule_ld_set_invert(&fprule, (p_cmdargs->invert.is_valid));
+        }
+    }
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_fp_rule_add(cli_p_cl, (p_cmdargs->ruleA0_name.txt), &fprule);
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_fprule_del(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = {{OPT_RULE, NULL, (p_cmdargs->ruleA0_name.is_valid)}};
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_fp_rule_del(cli_p_cl, (p_cmdargs->ruleA0_name.txt));
+    }
+    
+    return (rtn);
+}
+
+/* ========================================================================= */
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_fp.h b/sw/libfci_cli/src/libfci_cli_cmds_fp.h
new file mode 100644
index 0000000..ee6bcf0
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_cmds_fp.h
@@ -0,0 +1,35 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef LIBFCI_CLI_CMDS_FP_H_
+#define LIBFCI_CLI_CMDS_FP_H_
+
+#include "libfci_cli_common.h"
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+int cli_cmd_fptable_print(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_fptable_add(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_fptable_del(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_fptable_insrule(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_fptable_remrule(const cli_cmdargs_t *p_cmdargs);
+
+int cli_cmd_fprule_print(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_fprule_add(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_fprule_del(const cli_cmdargs_t *p_cmdargs);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_fwfeat.c b/sw/libfci_cli/src/libfci_cli_cmds_fwfeat.c
new file mode 100644
index 0000000..3319c56
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_cmds_fwfeat.c
@@ -0,0 +1,151 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#include <assert.h>
+#include <inttypes.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <string.h>
+#include "libfci_cli_common.h"
+#include "libfci_cli_def_opts.h"
+#include "libfci_cli_print_helpers.h"
+#include "libfci_cli_def_optarg_keywords.h"
+#include "libfci_cli_cmds_fwfeat.h"
+
+#include "libfci_interface/fci_fwfeat.h"
+
+/* ==== TESTMODE vars ====================================================== */
+
+#if !defined(NDEBUG)
+/* empty */
+#endif
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+extern FCI_CLIENT* cli_p_cl;
+
+/* ==== PRIVATE FUNCTIONS : prints ========================================= */
+
+static int fwfeat_print(const fpp_fw_features_cmd_t* p_fwfeat)
+{
+    assert(NULL != p_fwfeat);
+    
+    /* NOTE: native data type to comply with 'printf()' conventions (asterisk specifier) */ 
+    int indent = 0;
+    
+    printf("%-*s%s\n", indent, "", (p_fwfeat->name));
+    
+    indent += 4;
+    
+    {
+        const char* p_txt_ignored = (2u != (p_fwfeat->variant)) ? (" (ignored)") : ("");
+        printf("%-*sstate%s: %s\n", indent, "", 
+               p_txt_ignored,
+               cli_value2txt_en_dis(p_fwfeat->val));
+    }
+    
+    {
+        const char* p_txt_variant_descr = "__INVALID_ITEM__";
+        switch (p_fwfeat->variant)
+        {
+            case 0:
+                p_txt_variant_descr = "ignore state and always act as DISABLED";
+            break;
+            
+            case 1:
+                p_txt_variant_descr = "ignore state and always act as ENABLED";
+            break;
+            
+            case 2:
+                p_txt_variant_descr = "feature is runtime-configurable";
+            break;
+            
+            default:
+                p_txt_variant_descr = "__INVALID_ITEM__";
+            break;
+        }
+        printf("%-*svariant: %"PRIu8" (%s)\n", indent, "", 
+               (p_fwfeat->variant),
+               (p_txt_variant_descr));
+    }
+    
+    {
+        printf("%-*s%s\n", indent, "", (p_fwfeat->desc));
+    }
+    
+    return (FPP_ERR_OK); 
+}
+
+/* ==== PUBLIC FUNCTIONS =================================================== */ 
+
+int cli_cmd_fwfeat_print(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_fw_features_cmd_t fwfeat = {0};
+    
+    /* check for mandatory opts */
+    /* empty */
+    
+    /* exec */
+    if (p_cmdargs->feature_name.is_valid)
+    {
+        /* print a single feature */
+        rtn = fci_fwfeat_get_by_name(cli_p_cl, &fwfeat, (p_cmdargs->feature_name.txt));
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = fwfeat_print(&fwfeat);
+        }
+    }
+    else
+    {
+        /* print all FW features */
+        rtn = fci_fwfeat_print_all(cli_p_cl, fwfeat_print);
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_fwfeat_set(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_optbuf_t endis = {{OPT_ENABLE, OPT_DISABLE}};
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_FEATURE, NULL,    (p_cmdargs->feature_name.is_valid)},
+        {OPT_NONE,    &endis, ((p_cmdargs->enable_noreply.is_valid) || (p_cmdargs->disable_noorig.is_valid))},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* NOTE: enable and disable opts are mutually exclusive */
+        rtn = fci_fwfeat_set(cli_p_cl, (p_cmdargs->feature_name.txt), (p_cmdargs->enable_noreply.is_valid));
+    }
+    
+    return (rtn);
+}
+
+/* ========================================================================= */
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_fwfeat.h b/sw/libfci_cli/src/libfci_cli_cmds_fwfeat.h
new file mode 100644
index 0000000..0ed9d6b
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_cmds_fwfeat.h
@@ -0,0 +1,28 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef LIBFCI_CLI_CMDS_SPD_H_
+#define LIBFCI_CLI_CMDS_SPD_H_
+
+#include "libfci_cli_common.h"
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+int cli_cmd_fwfeat_print(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_fwfeat_set(const cli_cmdargs_t *p_cmdargs);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_if.c b/sw/libfci_cli/src/libfci_cli_cmds_if.c
new file mode 100644
index 0000000..5c7d106
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_cmds_if.c
@@ -0,0 +1,668 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#include <assert.h>
+#include <inttypes.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <string.h>
+#include "libfci_cli_common.h"
+#include "libfci_cli_def_opts.h"
+#include "libfci_cli_print_helpers.h"
+#include "libfci_cli_def_optarg_keywords.h"
+#include "libfci_cli_cmds_if.h"
+
+#include "libfci_interface/fci_common.h"
+#include "libfci_interface/fci_phy_if.h"
+#include "libfci_interface/fci_log_if.h"
+
+/* ==== TESTMODE vars ====================================================== */
+
+#if !defined(NDEBUG)
+/* empty */
+#endif
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+extern FCI_CLIENT* cli_p_cl;
+
+typedef int (*cb_cmdexec_t)(const cli_cmdargs_t* p_cmdargs);
+
+/* ==== PRIVATE FUNCTIONS : prints for LOGIF =============================== */
+
+static int logif_print_aux(const fpp_log_if_cmd_t* p_logif, bool is_verbose, bool is_nested_in_phyif)
+{
+    assert(NULL != p_logif);
+    
+    
+    /* NOTE: native data type to comply with 'printf()' conventions (asterisk specifier) */ 
+    int indent = ((is_nested_in_phyif) ? (6) : (0));
+    
+    printf("%-*s%2"PRIu32": %s: %s\n", indent, "",
+           (p_logif->id),
+           (p_logif->name),
+           cli_value2txt_en_dis(fci_log_if_ld_is_enabled(p_logif)));
+    
+    indent += 6;  /* detailed interface info is indented deeper */
+    
+    printf("%-*s<promisc:%s, match-mode:%s, discard-on-match:%s, loopback:%s>\n", indent, "",
+           cli_value2txt_on_off(fci_log_if_ld_is_promisc(p_logif)),
+           cli_value2txt_or_and(fci_log_if_ld_is_match_mode_or(p_logif)),
+           cli_value2txt_on_off(fci_log_if_ld_is_discard_on_m(p_logif)),
+           cli_value2txt_on_off(fci_log_if_ld_is_loopback(p_logif)));
+    
+    printf("%-*saccepted: %"PRIu32" rejected: %"PRIu32" discarded: %"PRIu32" processed: %"PRIu32"\n", indent, "",
+           (p_logif->stats.accepted), (p_logif->stats.rejected), (p_logif->stats.discarded), (p_logif->stats.processed));
+    
+    if (!is_nested_in_phyif)
+    {
+        printf("%-*sparent: %s\n", indent, "",
+               (p_logif->parent_name));
+    }
+    
+    printf("%-*segress: ", indent, "");
+    cli_print_bitset32((p_logif->egress), ",", cli_value2txt_phyif, "---");
+    printf("\n");
+    
+    printf("%-*smatch-rules: ", indent, "");
+    cli_print_bitset32((p_logif->match), ",", cli_value2txt_match_rule, "---");
+    printf("\n");
+    
+    /* verbose info - match rule arguments (only if corresponding match rule active) */
+    if (is_verbose)
+    {
+        indent += 2u;  /* verbose info is indented even deeper */
+        
+        if (FPP_IF_MATCH_VLAN & (p_logif->match))
+        {
+            printf("%-*s"TXT_MATCH_RULE__VLAN": %"PRIu16"\n", indent, "",
+                   (p_logif->arguments.vlan));
+        }
+        if (FPP_IF_MATCH_PROTO & (p_logif->match))
+        {
+            printf("%-*s"TXT_MATCH_RULE__PROTOCOL": %"PRIu8" (%s)\n", indent, "",
+                   (p_logif->arguments.proto), cli_value2txt_protocol(p_logif->arguments.proto));
+        }
+        if (FPP_IF_MATCH_SPORT & (p_logif->match))
+        {
+            printf("%-*s"TXT_MATCH_RULE__SPORT": %"PRIu16"\n", indent, "",
+                   (p_logif->arguments.sport));
+        }
+        if (FPP_IF_MATCH_DPORT & (p_logif->match))
+        {
+            printf("%-*s"TXT_MATCH_RULE__DPORT": %"PRIu16"\n", indent, "",
+                   (p_logif->arguments.dport));
+        }
+        if (FPP_IF_MATCH_SIP6 & (p_logif->match))
+        {
+            printf("%-*s"TXT_MATCH_RULE__SIP6": ", indent, "");
+            cli_print_ip6(p_logif->arguments.ipv.v6.sip);
+            printf("\n");
+        }
+        if (FPP_IF_MATCH_DIP6 & (p_logif->match))
+        {
+            printf("%-*s"TXT_MATCH_RULE__DIP6": ", indent, "");
+            cli_print_ip6(p_logif->arguments.ipv.v6.dip);
+            printf("\n");
+        }
+        if (FPP_IF_MATCH_SIP & (p_logif->match))
+        {
+            printf("%-*s"TXT_MATCH_RULE__SIP": ", indent, "");
+            cli_print_ip4(p_logif->arguments.ipv.v4.sip, false);
+            printf("\n");
+        }
+        if (FPP_IF_MATCH_DIP & (p_logif->match))
+        {
+            printf("%-*s"TXT_MATCH_RULE__DIP": ", indent, "");
+            cli_print_ip4(p_logif->arguments.ipv.v4.dip, false);
+            printf("\n");
+        }
+        if (FPP_IF_MATCH_ETHTYPE & (p_logif->match))
+        {
+            printf("%-*s"TXT_MATCH_RULE__ETHER_TYPE": %"PRIu16" (0x%04"PRIx16")\n", indent, "", 
+                   (p_logif->arguments.ethtype), (p_logif->arguments.ethtype));
+        }
+        if (FPP_IF_MATCH_FP0 & (p_logif->match))
+        {
+            printf("%-*s"TXT_MATCH_RULE__FP_TABLE0": %s\n", indent, "",
+                   (p_logif->arguments.fp_table0));
+        }
+        if (FPP_IF_MATCH_FP1 & (p_logif->match))
+        {
+            printf("%-*s"TXT_MATCH_RULE__FP_TABLE1": %s\n", indent, "",
+                   (p_logif->arguments.fp_table1));
+        }
+        if (FPP_IF_MATCH_SMAC & (p_logif->match))
+        {
+            printf("%-*s"TXT_MATCH_RULE__SMAC": ", indent, "");
+            cli_print_mac(p_logif->arguments.smac);
+            printf("\n");
+        }
+        if (FPP_IF_MATCH_DMAC & (p_logif->match))
+        {
+            printf("%-*s"TXT_MATCH_RULE__DMAC": ", indent, "");
+            cli_print_mac(p_logif->arguments.dmac);
+            printf("\n");
+        }
+        if (FPP_IF_MATCH_HIF_COOKIE & (p_logif->match))
+        {
+            printf("%-*s"TXT_MATCH_RULE__HIF_COOKIE": %"PRIu32" (0x%04"PRIx32")\n", indent, "",
+                   (p_logif->arguments.hif_cookie), (p_logif->arguments.hif_cookie));
+        }
+    }
+    
+    return (FPP_ERR_OK);
+}
+
+static inline int logif_print(const fpp_log_if_cmd_t* p_if)
+{
+    return logif_print_aux(p_if, false, false);
+}
+
+static inline int logif_print_verbose(const fpp_log_if_cmd_t* p_if)
+{
+    return logif_print_aux(p_if, true, false);
+}
+
+static inline int logif_print_in_phyif(const fpp_log_if_cmd_t* p_if)
+{
+    return logif_print_aux(p_if, false, true);
+}
+
+static inline int logif_print_in_phyif_verbose(const fpp_log_if_cmd_t* p_if)
+{
+    return logif_print_aux(p_if, true, true);
+}
+
+/* ==== PRIVATE FUNCTIONS : prints for PHYIF =============================== */
+
+static int phyif_print_aux(const fpp_phy_if_cmd_t* p_phyif, bool is_verbose)
+{
+    assert(NULL != p_phyif);
+    UNUSED(is_verbose);
+    
+    /* NOTE: native data type to comply with 'printf()' conventions (asterisk specifier) */ 
+    int indent = 0;
+    
+    printf("%-*s%2"PRIu32": %s: %s\n", indent, "",
+           (p_phyif->id),
+           (p_phyif->name),
+           cli_value2txt_en_dis(fci_phy_if_ld_is_enabled(p_phyif)));
+           
+    indent += 6u;  /* detailed info is indented deeper */
+    
+    printf("%-*s<promisc:%s, mode:%s, block-state:%s, loadbalance:%s>\n", indent, "",
+           cli_value2txt_on_off(fci_phy_if_ld_is_promisc(p_phyif)),
+           cli_value2txt_if_mode(p_phyif->mode),
+           cli_value2txt_if_block_state(p_phyif->block_state), 
+           cli_value2txt_on_off(fci_phy_if_ld_is_loadbalance(p_phyif)));
+    
+    printf("%-*s<vlan-conf:%s, ptp-conf:%s, ptp-promisc:%s, q-in-q:%s>\n", indent, "", 
+           cli_value2txt_on_off(fci_phy_if_ld_is_vlan_conf(p_phyif)),
+           cli_value2txt_on_off(fci_phy_if_ld_is_ptp_conf(p_phyif)),
+           cli_value2txt_on_off(fci_phy_if_ld_is_ptp_promisc(p_phyif)),
+           cli_value2txt_on_off(fci_phy_if_ld_is_qinq(p_phyif)));
+    
+    printf("%-*s<discard-if-ttl-below-2:%s>\n", indent, "", 
+           cli_value2txt_on_off(fci_phy_if_ld_is_discard_ttl(p_phyif)));
+    
+    printf("%-*singress: %"PRIu32" egress: %"PRIu32" discarded: %"PRIu32" malformed: %"PRIu32"\n", indent, "",
+           (p_phyif->stats.ingress), (p_phyif->stats.egress), (p_phyif->stats.discarded), (p_phyif->stats.malformed));
+    
+    printf("%-*sMAC: ", indent, "");
+    cli_print_mac(p_phyif->mac_addr);
+    printf("\n");
+    
+    printf("%-*smirror: (%s) ", indent, "",
+           cli_value2txt_on_off(fci_phy_if_ld_is_mirror(p_phyif)));
+    cli_print_tablenames(&(p_phyif->mirror), 1u, "", "---");
+    printf("\n");
+    
+    printf("%-*sflexible-filter: ", indent, "");
+    cli_print_tablenames(&(p_phyif->ftable), 1u, "", "---");
+    printf("\n");
+    
+    return (FPP_ERR_OK);
+}
+
+static inline int phyif_print(const fpp_phy_if_cmd_t* p_if)
+{   
+    phyif_print_aux(p_if, false);
+    return fci_log_if_print_by_parent(cli_p_cl, logif_print_in_phyif, (p_if->name));
+}
+
+static inline int phyif_print_verbose(const fpp_phy_if_cmd_t* p_if)
+{   
+    phyif_print_aux(p_if, true);
+    return fci_log_if_print_by_parent(cli_p_cl, logif_print_in_phyif_verbose, (p_if->name));
+}
+
+/* ==== PRIVATE FUNCTIONS : cmds =========================================== */
+
+static int exec_inside_locked_session(cb_cmdexec_t p_cb_cmdexec, const cli_cmdargs_t* p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cb_cmdexec);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    rtn = fci_if_session_lock(cli_p_cl);
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = p_cb_cmdexec(p_cmdargs);
+    }
+    rtn = fci_if_session_unlock(cli_p_cl, rtn);
+    
+    return (rtn);
+}
+
+static int stt_cmd_phyif_print(const cli_cmdargs_t* p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_phy_if_cmd_t phyif = {0};
+    
+    /* check for mandatory opts */
+    /* empty */
+    
+    /* exec */
+    const fci_phy_if_cb_print_t p_cb_print = ((p_cmdargs->verbose.is_valid) ? (phyif_print_verbose) : (phyif_print));
+    if (p_cmdargs->if_name.is_valid)
+    {
+        /* print single interface */
+        rtn = fci_phy_if_get_by_name(cli_p_cl, &phyif, (p_cmdargs->if_name.txt));    
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = p_cb_print(&phyif);
+        }
+    }
+    else
+    {
+        /* print all interfaces */
+        rtn = fci_phy_if_print_all(cli_p_cl, p_cb_print);
+    }
+    
+    return (rtn);
+}
+
+static int stt_cmd_phyif_update(const cli_cmdargs_t* p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_phy_if_cmd_t phyif = {0};
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = {{OPT_INTERFACE, NULL, (p_cmdargs->if_name.is_valid)}};
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* get init local data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_phy_if_get_by_name(cli_p_cl, &phyif, (p_cmdargs->if_name.txt));
+    }
+    
+    /* modify local data - bitflags */
+    if (FPP_ERR_OK == rtn)
+    {
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->enable_noreply.is_valid))
+        {
+            rtn = fci_phy_if_ld_enable(&phyif);
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->disable_noorig.is_valid))
+        {
+            rtn = fci_phy_if_ld_disable(&phyif);
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->promisc.is_valid))
+        {
+            rtn = fci_phy_if_ld_set_promisc(&phyif, (p_cmdargs->promisc.is_on));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->loadbalance__ttl_decr.is_valid))
+        {
+            rtn = fci_phy_if_ld_set_loadbalance(&phyif, (p_cmdargs->loadbalance__ttl_decr.is_on));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->vlan_conf__x_src.is_valid))
+        {
+            rtn = fci_phy_if_ld_set_vlan_conf(&phyif, (p_cmdargs->vlan_conf__x_src.is_on));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->ptp_conf__x_dst.is_valid))
+        {
+            rtn = fci_phy_if_ld_set_ptp_conf(&phyif, (p_cmdargs->ptp_conf__x_dst.is_on));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->ptp_promisc.is_valid))
+        {
+            rtn = fci_phy_if_ld_set_ptp_promisc(&phyif, (p_cmdargs->ptp_promisc.is_on));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->qinq.is_valid))
+        {
+            rtn = fci_phy_if_ld_set_qinq(&phyif, (p_cmdargs->qinq.is_on));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->discard_if_ttl_below_2.is_valid))
+        {
+            rtn = fci_phy_if_ld_set_discard_ttl(&phyif, (p_cmdargs->discard_if_ttl_below_2.is_on));
+        }
+    }
+    
+    /* modify local data - misc configuration */
+    if (FPP_ERR_OK == rtn)
+    {
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->if_mode.is_valid))
+        {
+            rtn = fci_phy_if_ld_set_mode(&phyif, (p_cmdargs->if_mode.value));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->if_block_state.is_valid))
+        {
+            rtn = fci_phy_if_ld_set_block_state(&phyif, (p_cmdargs->if_block_state.value));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->if_name_mirror.is_valid))
+        {
+            rtn = fci_phy_if_ld_set_mirror(&phyif, (p_cmdargs->if_name_mirror.txt));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->table0_name.is_valid))
+        {
+            rtn = fci_phy_if_ld_set_flexifilter(&phyif, (p_cmdargs->table0_name.txt));
+        }
+    }
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_phy_if_update(cli_p_cl, &phyif);
+    }
+    
+    return (rtn);
+}
+
+static int stt_cmd_logif_print(const cli_cmdargs_t* p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_log_if_cmd_t logif = {0};
+    
+    /* check for mandatory opts */
+    /* empty */
+    
+    /* exec */
+    const fci_log_if_cb_print_t p_cb_print = ((p_cmdargs->verbose.is_valid) ? (logif_print_verbose) : (logif_print));
+    if (p_cmdargs->if_name.is_valid)
+    {
+        /*  print single interface  */
+        rtn = fci_log_if_get_by_name(cli_p_cl, &logif, (p_cmdargs->if_name.txt));
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = p_cb_print(&logif);
+        }
+    }
+    else
+    {
+        /* print all interfaces */
+        rtn = fci_log_if_print_all(cli_p_cl, p_cb_print);
+    }
+
+    return (rtn);
+}
+
+static int stt_cmd_logif_update(const cli_cmdargs_t* p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_log_if_cmd_t logif = {0};
+    const fpp_if_m_rules_t match_rules = ((p_cmdargs->match_rules.is_valid) ? (p_cmdargs->match_rules.bitset) : (0));
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_INTERFACE,   NULL, (p_cmdargs->if_name.is_valid)},
+        
+        /* these are mandatory only if the related match rule is requested */
+        {OPT_VLAN,        NULL, ((FPP_IF_MATCH_VLAN    & match_rules) ? (p_cmdargs->vlan.is_valid)          : (true))},
+        {OPT_PROTOCOL,    NULL, ((FPP_IF_MATCH_PROTO   & match_rules) ? (p_cmdargs->protocol.is_valid)      : (true))},
+        {OPT_SPORT,       NULL, ((FPP_IF_MATCH_SPORT   & match_rules) ? (p_cmdargs->sport.is_valid)         : (true))},
+        {OPT_DPORT,       NULL, ((FPP_IF_MATCH_DPORT   & match_rules) ? (p_cmdargs->dport.is_valid)         : (true))},
+        {OPT_SIP6,        NULL, ((FPP_IF_MATCH_SIP6    & match_rules) ? (p_cmdargs->sip2.is_valid)          : (true))},
+        {OPT_DIP6,        NULL, ((FPP_IF_MATCH_DIP6    & match_rules) ? (p_cmdargs->dip2.is_valid)          : (true))},
+        {OPT_SIP,         NULL, ((FPP_IF_MATCH_SIP     & match_rules) ? (p_cmdargs->sip.is_valid)           : (true))},
+        {OPT_DIP,         NULL, ((FPP_IF_MATCH_DIP     & match_rules) ? (p_cmdargs->dip.is_valid)           : (true))},
+        {OPT_ETHTYPE,     NULL, ((FPP_IF_MATCH_ETHTYPE & match_rules) ? (p_cmdargs->count_ethtype.is_valid) : (true))},
+        {OPT_TABLE0,      NULL, ((FPP_IF_MATCH_FP0     & match_rules) ? (p_cmdargs->table0_name.is_valid)   : (true))},
+        {OPT_TABLE1,      NULL, ((FPP_IF_MATCH_FP1     & match_rules) ? (p_cmdargs->table1_name.is_valid)   : (true))},
+        {OPT_SMAC,        NULL, ((FPP_IF_MATCH_SMAC    & match_rules) ? (p_cmdargs->smac.is_valid)          : (true))},
+        {OPT_DMAC,        NULL, ((FPP_IF_MATCH_DMAC    & match_rules) ? (p_cmdargs->dmac.is_valid)          : (true))},
+        {OPT_HIF_COOKIE,  NULL, ((FPP_IF_MATCH_HIF_COOKIE & match_rules) ? (p_cmdargs->data_hifc_sad.is_valid) : (true))},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* late opt arg check to ensure that sip/dip are IPv4 and sip2/dip2 are IPv6 (specialty of this cli cmd) */
+    if (FPP_ERR_OK == rtn)
+    {
+        if (((p_cmdargs->sip.is_valid)  &&  (p_cmdargs->sip.is6))  || 
+            ((p_cmdargs->dip.is_valid)  &&  (p_cmdargs->dip.is6))  ||
+            ((p_cmdargs->sip2.is_valid) && !(p_cmdargs->sip2.is6)) || 
+            ((p_cmdargs->dip2.is_valid) && !(p_cmdargs->dip2.is6)))
+        {
+            rtn = CLI_ERR_WRONG_IP_TYPE;
+        }
+    }
+    
+    /* get init local data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_log_if_get_by_name(cli_p_cl, &logif, (p_cmdargs->if_name.txt));
+    }
+    
+    /* modify local data - match rules */
+    if ((FPP_ERR_OK == rtn) && (p_cmdargs->match_rules.is_valid))
+    {
+        /* shortcut - set all requested match rules at once (even those which require args) */
+        fci_log_if_ld_clear_all_mr(&logif);
+        logif.match = match_rules;
+        
+        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_VLAN & match_rules))
+        {
+            rtn = fci_log_if_ld_set_mr_vlan(&logif, true, (p_cmdargs->vlan.value));
+        }
+        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_PROTO & match_rules))
+        {
+            rtn = fci_log_if_ld_set_mr_proto(&logif, true, (p_cmdargs->protocol.value));
+        }
+        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_SPORT & match_rules))
+        {
+            rtn = fci_log_if_ld_set_mr_sport(&logif, true, (p_cmdargs->sport.value));
+        }
+        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_DPORT & match_rules))
+        {
+            rtn = fci_log_if_ld_set_mr_dport(&logif, true, (p_cmdargs->dport.value));
+        } 
+        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_SIP6 & match_rules))
+        {
+            rtn = fci_log_if_ld_set_mr_sip6(&logif, true, (p_cmdargs->sip2.arr));
+        }
+        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_DIP6 & match_rules))
+        {
+            rtn = fci_log_if_ld_set_mr_dip6(&logif, true, (p_cmdargs->dip2.arr));
+        }
+        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_SIP & match_rules))
+        {
+            rtn = fci_log_if_ld_set_mr_sip(&logif, true, (p_cmdargs->sip.arr[0]));
+        }
+        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_DIP & match_rules))
+        {
+            rtn = fci_log_if_ld_set_mr_dip(&logif, true, (p_cmdargs->dip.arr[0]));
+        }
+        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_ETHTYPE & match_rules))
+        {
+            rtn = fci_log_if_ld_set_mr_ethtype(&logif, true, (p_cmdargs->count_ethtype.value));
+        }
+        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_FP0 & match_rules))
+        {
+            rtn = fci_log_if_ld_set_mr_fp0(&logif, true, (p_cmdargs->table0_name.txt));
+        }
+        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_FP1 & match_rules))
+        {
+            rtn = fci_log_if_ld_set_mr_fp1(&logif, true, (p_cmdargs->table1_name.txt));
+        }
+        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_SMAC & match_rules))
+        {
+            rtn = fci_log_if_ld_set_mr_smac(&logif, true, (p_cmdargs->smac.arr));
+        }
+        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_DMAC & match_rules))
+        {
+            rtn = fci_log_if_ld_set_mr_dmac(&logif, true, (p_cmdargs->dmac.arr));
+        }
+        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_HIF_COOKIE & match_rules))
+        {
+            rtn = fci_log_if_ld_set_mr_hif_cookie(&logif, true, (p_cmdargs->data_hifc_sad.value));
+        }
+    }
+    
+    /* modify local data - bitflags + egress */
+    if (FPP_ERR_OK == rtn)
+    {
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->enable_noreply.is_valid))
+        {
+            rtn = fci_log_if_ld_enable(&logif);
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->disable_noorig.is_valid))
+        {
+            rtn = fci_log_if_ld_disable(&logif);
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->promisc.is_valid))
+        {
+            rtn = fci_log_if_ld_set_promisc(&logif, (p_cmdargs->promisc.is_on));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->loopback.is_valid))
+        {
+            rtn = fci_log_if_ld_set_loopback(&logif, (p_cmdargs->loopback.is_on));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->match_mode.is_valid))
+        {
+            rtn = fci_log_if_ld_set_match_mode_or(&logif, (p_cmdargs->match_mode.is_or));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->discard_on_match.is_valid))
+        {
+            rtn = fci_log_if_ld_set_discard_on_m(&logif, (p_cmdargs->discard_on_match.is_on));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->egress.is_valid))
+        {
+            rtn = fci_log_if_ld_set_egress_phyifs(&logif, (p_cmdargs->egress.bitset));
+        }
+    }
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_log_if_update(cli_p_cl, &logif);
+    }
+    
+    return (rtn);
+}
+
+static int stt_cmd_logif_add(const cli_cmdargs_t* p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_INTERFACE, NULL, (p_cmdargs->if_name.is_valid)},
+        {OPT_PARENT,    NULL, (p_cmdargs->if_name_parent.is_valid)},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_log_if_add(cli_p_cl, 0, (p_cmdargs->if_name.txt), (p_cmdargs->if_name_parent.txt));
+    }
+    
+    return (rtn);
+}
+
+static int stt_cmd_logif_del(const cli_cmdargs_t* p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = {{OPT_INTERFACE, NULL, (p_cmdargs->if_name.is_valid)}};
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_log_if_del(cli_p_cl, (p_cmdargs->if_name.txt));
+    }
+    
+    return (rtn);
+}
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+inline int cli_cmd_phyif_print(const cli_cmdargs_t* p_cmdargs)
+{
+    return exec_inside_locked_session(stt_cmd_phyif_print, p_cmdargs);
+}
+
+inline int cli_cmd_phyif_update(const cli_cmdargs_t* p_cmdargs)
+{
+    return exec_inside_locked_session(stt_cmd_phyif_update, p_cmdargs);
+}
+
+inline int cli_cmd_logif_print(const cli_cmdargs_t* p_cmdargs)
+{
+    return exec_inside_locked_session(stt_cmd_logif_print, p_cmdargs);
+}
+
+inline int cli_cmd_logif_update(const cli_cmdargs_t* p_cmdargs)
+{
+    return exec_inside_locked_session(stt_cmd_logif_update, p_cmdargs);
+}
+
+inline int cli_cmd_logif_add(const cli_cmdargs_t* p_cmdargs)
+{
+    return exec_inside_locked_session(stt_cmd_logif_add, p_cmdargs);
+}
+
+int cli_cmd_logif_del(const cli_cmdargs_t* p_cmdargs)
+{
+    return exec_inside_locked_session(stt_cmd_logif_del, p_cmdargs);
+}
+
+/* ==== TESTMODE constants ================================================= */
+
+#if !defined(NDEBUG)
+/* empty */
+#endif
+
+/* ========================================================================= */
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_if.h b/sw/libfci_cli/src/libfci_cli_cmds_if.h
new file mode 100644
index 0000000..d02ee13
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_cmds_if.h
@@ -0,0 +1,33 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef LIBFCI_CLI_CMDS_IF_H_
+#define LIBFCI_CLI_CMDS_IF_H_
+
+#include "libfci_cli_common.h"
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+int cli_cmd_phyif_print(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_phyif_update(const cli_cmdargs_t *p_cmdargs);
+
+int cli_cmd_logif_print(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_logif_update(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_logif_add(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_logif_del(const cli_cmdargs_t *p_cmdargs);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_qos.c b/sw/libfci_cli/src/libfci_cli_cmds_qos.c
new file mode 100644
index 0000000..289c968
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_cmds_qos.c
@@ -0,0 +1,435 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#include <assert.h>
+#include <inttypes.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <string.h>
+#include "libfci_cli_common.h"
+#include "libfci_cli_def_opts.h"
+#include "libfci_cli_print_helpers.h"
+#include "libfci_cli_def_optarg_keywords.h"
+#include "libfci_cli_cmds_qos.h"
+
+#include "libfci_interface/fci_qos.h"
+
+/* ==== TESTMODE vars ====================================================== */
+
+#if !defined(NDEBUG)
+/* empty */
+#endif
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+extern FCI_CLIENT* cli_p_cl;
+
+/* ==== PRIVATE FUNCTIONS : prints ========================================= */
+
+static int qos_que_print(const fpp_qos_queue_cmd_t* p_que)
+{
+    assert(NULL != p_que);
+    
+    
+    /* NOTE: native data type to comply with 'printf()' conventions (asterisk specifier) */ 
+    int indent = 0;
+    
+    printf("%-*squeue %"PRIu8":\n", indent, "", (p_que->id));
+    
+    indent += 4;
+    
+    printf("%-*sinterface: %s\n"
+           "%-*sque-mode:  %"PRIu8" (%s)\n"
+           "%-*sthld-min:  %"PRIu32"\n"
+           "%-*sthld-max:  %"PRIu32"\n",
+           indent, "", (p_que->if_name),
+           indent, "", (p_que->mode), cli_value2txt_que_mode(p_que->mode),
+           indent, "", (p_que->min),
+           indent, "", (p_que->max));
+    
+    {
+        printf("%-*szprob:     ", indent, "");
+        const char* p_txt_delim = "";  /* no delim in front of the first item */
+        for (uint8_t i = 0u; (ZPROBS_LN > i); (++i))
+        {
+            printf("%s[%"PRIu8"]<%"PRIu8">", p_txt_delim, i, p_que->zprob[i]);
+            p_txt_delim = ",";
+        }
+        printf("\n");
+    }
+    
+    return (FPP_ERR_OK); 
+}
+
+static int qos_sch_print(const fpp_qos_scheduler_cmd_t* p_sch)
+{
+    assert(NULL != p_sch);
+    
+    
+    /* NOTE: native data type to comply with 'printf()' conventions (asterisk specifier) */ 
+    int indent = 0;
+    
+    printf("%-*sscheduler %"PRIu8":\n", indent, "", (p_sch->id));
+    
+    indent += 4;
+    
+    printf("%-*sinterface: %s\n"
+           "%-*ssch-mode:  %"PRIu8" (%s)\n"
+           "%-*ssch-algo:  %"PRIu8" (%s)\n",
+           indent, "", (p_sch->if_name),
+           indent, "", (p_sch->mode), cli_value2txt_sch_mode(p_sch->mode),
+           indent, "", (p_sch->algo), cli_value2txt_sch_algo(p_sch->algo));
+    
+    {
+        printf("%-*ssch-in:    ", indent, "");
+        const char* p_txt_delim = "";  /* no delim in front of the first item */
+        for (uint8_t i = 0u; (SCH_INS_LN > i); (++i))
+        {
+            const char* p_txt = cli_value2txt_sch_in(p_sch->input_src[i]);
+            if (fci_qos_sch_ld_is_input_enabled(p_sch, i))
+            {
+                printf("%s[%"PRIu8"]<%s:%"PRIu32">", p_txt_delim, i, p_txt, (p_sch->input_w[i]));
+            }
+            else
+            {
+                printf("%s[%"PRIu8"]<%s>", p_txt_delim, i, p_txt);
+            }
+            p_txt_delim = ",";
+        }
+        printf("\n");
+    }
+    
+    return (FPP_ERR_OK); 
+}
+
+static int qos_shp_print(const fpp_qos_shaper_cmd_t* p_shp)
+{
+    assert(NULL != p_shp);
+    
+    
+    /* NOTE: native data type to comply with 'printf()' conventions (asterisk specifier) */ 
+    int indent = 0;
+    
+    printf("%-*sshaper %"PRIu8":\n", indent, "", (p_shp->id));
+    
+    indent += 4;
+    
+    printf("%-*sinterface:  %s\n"
+           "%-*sshp-mode:   %"PRIu8" (%s)\n"
+           "%-*sshp-pos:    %"PRIu8" (%s)\n"
+           "%-*sisl:        %"PRIu32"\n"
+           "%-*scredit-min: %"PRId32"\n"
+           "%-*scredit-max: %"PRId32"\n",
+           indent, "", (p_shp->if_name),
+           indent, "", (p_shp->mode), cli_value2txt_shp_mode(p_shp->mode),
+           indent, "", (p_shp->position), cli_value2txt_shp_pos(p_shp->position),
+           indent, "", (p_shp->isl),
+           indent, "", (p_shp->min_credit),
+           indent, "", (p_shp->max_credit));
+    
+    return (FPP_ERR_OK); 
+}
+
+/* ==== PUBLIC FUNCTIONS : QoS queue ======================================= */
+
+int cli_cmd_qos_que_print(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_qos_queue_cmd_t que = {0};
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = {{OPT_INTERFACE,  NULL,  (p_cmdargs->if_name.is_valid)}};
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* exec */
+    if (CLI_OK == rtn)
+    {
+        if (p_cmdargs->que_sch_shp.is_valid)
+        {
+            /* print single QoS queue */
+            rtn = fci_qos_que_get_by_id(cli_p_cl, &que, (p_cmdargs->if_name.txt), (p_cmdargs->que_sch_shp.value));
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = qos_que_print(&que);
+            }
+        }
+        else
+        {
+            /* print all QoS queues of the given interface */
+            rtn = fci_qos_que_print_by_phyif(cli_p_cl, qos_que_print, (p_cmdargs->if_name.txt));
+        }
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_qos_que_update(const cli_cmdargs_t* p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_qos_queue_cmd_t que = {0};
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] =
+    {
+        {OPT_INTERFACE, NULL, (p_cmdargs->if_name.is_valid)},
+        {OPT_QUE,       NULL, (p_cmdargs->que_sch_shp.is_valid)},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* get init local data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_qos_que_get_by_id(cli_p_cl, &que, (p_cmdargs->if_name.txt), (p_cmdargs->que_sch_shp.value));
+    }
+    
+    /* modify local data - misc */
+    if (FPP_ERR_OK == rtn)
+    {
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->que_sch_shp_mode.is_valid))
+        {
+            rtn = fci_qos_que_ld_set_mode(&que, (p_cmdargs->que_sch_shp_mode.value));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->thmin.is_valid))
+        {
+            rtn = fci_qos_que_ld_set_min(&que, (p_cmdargs->thmin.value));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->thmax.is_valid))
+        {
+            rtn = fci_qos_que_ld_set_max(&que, (p_cmdargs->thmax.value));
+        }
+    }
+    
+    /* modify local data - zprob elements */
+    if ((FPP_ERR_OK == rtn) && ((p_cmdargs->zprob.is_valid)))
+    {
+        for (uint8_t i = 0u; (ZPROBS_LN > i); (++i))
+        {
+            const uint8_t cmdarg_value = (p_cmdargs->zprob.arr[i]);
+            if (cli_que_zprob_is_not_keep(cmdarg_value))
+            {
+                fci_qos_que_ld_set_zprob(&que, i, cmdarg_value);
+            }
+        }
+    }
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_qos_que_update(cli_p_cl, &que);
+    }
+    
+    return (rtn);
+}
+
+/* ==== PUBLIC FUNCTIONS : QoS scheduler =================================== */
+
+int cli_cmd_qos_sch_print(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_qos_scheduler_cmd_t sch = {0};
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = {{OPT_INTERFACE,  NULL,  (p_cmdargs->if_name.is_valid)}};
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* exec */
+    if (CLI_OK == rtn)
+    {
+        if (p_cmdargs->que_sch_shp.is_valid)
+        {
+            /* print single QoS scheduler */
+            rtn = fci_qos_sch_get_by_id(cli_p_cl, &sch, (p_cmdargs->if_name.txt), (p_cmdargs->que_sch_shp.value));
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = qos_sch_print(&sch);
+            }
+        }
+        else
+        {
+            /* print all QoS schedulers of the given interface */
+            rtn = fci_qos_sch_print_by_phyif(cli_p_cl, qos_sch_print, (p_cmdargs->if_name.txt));
+        }
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_qos_sch_update(const cli_cmdargs_t* p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_qos_scheduler_cmd_t sch = {0};
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] =
+    {
+        {OPT_INTERFACE, NULL, (p_cmdargs->if_name.is_valid)},
+        {OPT_SCH,       NULL, (p_cmdargs->que_sch_shp.is_valid)},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* get init local data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_qos_sch_get_by_id(cli_p_cl, &sch, (p_cmdargs->if_name.txt), (p_cmdargs->que_sch_shp.value));
+    }
+    
+    /* modify local data - misc */
+    if (FPP_ERR_OK == rtn)
+    {
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->que_sch_shp_mode.is_valid))
+        {
+            rtn = fci_qos_sch_ld_set_mode(&sch, (p_cmdargs->que_sch_shp_mode.value));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->sch_algo.is_valid))
+        {
+            rtn = fci_qos_sch_ld_set_algo(&sch, (p_cmdargs->sch_algo.value));
+        }
+    }
+    
+    /* modify local data - scheduler inputs */
+    if ((FPP_ERR_OK == rtn) && ((p_cmdargs->sch_in.is_valid)))
+    {
+        for (uint8_t i = 0u; (SCH_INS_LN > i); (++i))
+        {
+            const uint8_t cmdarg_src = (p_cmdargs->sch_in.arr_src[i]);
+            const uint32_t cmdarg_w  = (p_cmdargs->sch_in.arr_w[i]);
+            if (cli_que_zprob_is_not_keep(cmdarg_src))
+            {
+                const bool enable = cli_sch_in_is_not_dis(cmdarg_src);
+                fci_qos_sch_ld_set_input(&sch, i, enable, cmdarg_src, cmdarg_w);
+            }
+        }
+    }
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_qos_sch_update(cli_p_cl, &sch);
+    }
+    
+    return (rtn);
+}
+
+/* ==== PUBLIC FUNCTIONS : QoS shaper ====================================== */
+
+int cli_cmd_qos_shp_print(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_qos_shaper_cmd_t shp = {0};
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = {{OPT_INTERFACE,  NULL,  (p_cmdargs->if_name.is_valid)}};
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* exec */
+    if (CLI_OK == rtn)
+    {
+        if (p_cmdargs->que_sch_shp.is_valid)
+        {
+            /* print single QoS shaper */
+            rtn = fci_qos_shp_get_by_id(cli_p_cl, &shp, (p_cmdargs->if_name.txt), (p_cmdargs->que_sch_shp.value));
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = qos_shp_print(&shp);
+            }
+        }
+        else
+        {
+            /* print all QoS schedulers of the given interface */
+            rtn = fci_qos_shp_print_by_phyif(cli_p_cl, qos_shp_print, (p_cmdargs->if_name.txt));
+        }
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_qos_shp_update(const cli_cmdargs_t* p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_qos_shaper_cmd_t shp = {0};
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] =
+    {
+        {OPT_INTERFACE, NULL, (p_cmdargs->if_name.is_valid)},
+        {OPT_SHP,       NULL, (p_cmdargs->que_sch_shp.is_valid)},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* get init local data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_qos_shp_get_by_id(cli_p_cl, &shp, (p_cmdargs->if_name.txt), (p_cmdargs->que_sch_shp.value));
+    }
+    
+    /* modify local data - misc */
+    if (FPP_ERR_OK == rtn)
+    {
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->que_sch_shp_mode.is_valid))
+        {
+            rtn = fci_qos_shp_ld_set_mode(&shp, (p_cmdargs->que_sch_shp_mode.value));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->shp_pos.is_valid))
+        {
+            rtn = fci_qos_shp_ld_set_position(&shp, (p_cmdargs->shp_pos.value));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->isl.is_valid))
+        {
+            rtn = fci_qos_shp_ld_set_isl(&shp, (p_cmdargs->isl.value));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->crmin.is_valid))
+        {
+            rtn = fci_qos_shp_ld_set_min_credit(&shp, (p_cmdargs->crmin.value));
+        }
+        if ((FPP_ERR_OK == rtn) && (p_cmdargs->crmax.is_valid))
+        {
+            rtn = fci_qos_shp_ld_set_max_credit(&shp, (p_cmdargs->crmax.value));
+        }
+    }
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_qos_shp_update(cli_p_cl, &shp);
+    }
+    
+    return (rtn);
+}
+
+/* ========================================================================= */
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_qos.h b/sw/libfci_cli/src/libfci_cli_cmds_qos.h
new file mode 100644
index 0000000..d18255c
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_cmds_qos.h
@@ -0,0 +1,34 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef LIBFCI_CLI_CMDS_QOS_H_
+#define LIBFCI_CLI_CMDS_QOS_H_
+
+#include "libfci_cli_common.h"
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+int cli_cmd_qos_que_print(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_qos_que_update(const cli_cmdargs_t *p_cmdargs);
+
+int cli_cmd_qos_sch_print(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_qos_sch_update(const cli_cmdargs_t *p_cmdargs);
+
+int cli_cmd_qos_shp_print(const cli_cmdargs_t *p_cmdargs);
+//int cli_cmd_qos_sch_update(const cli_cmdargs_t *p_cmdargs);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_route_and_cntk.c b/sw/libfci_cli/src/libfci_cli_cmds_route_and_cntk.c
new file mode 100644
index 0000000..cc12d53
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_cmds_route_and_cntk.c
@@ -0,0 +1,770 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#include <assert.h>
+#include <inttypes.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <string.h>
+#include "libfci_cli_common.h"
+#include "libfci_cli_def_opts.h"
+#include "libfci_cli_print_helpers.h"
+#include "libfci_cli_def_optarg_keywords.h"
+#include "libfci_cli_cmds_route_and_cntk.h"
+
+#include "libfci_interface/fci_rt_ct.h"
+
+/* ==== TESTMODE vars ====================================================== */
+
+#if !defined(NDEBUG)
+/* empty */
+#endif
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+extern FCI_CLIENT* cli_p_cl;
+
+static bool stt_do_header_print = false;
+
+/* ==== PRIVATE FUNCTIONS : print route ==================================== */
+
+static void rt_header_print(void)
+{
+    printf("| route      | IP   | src-mac           | dst-mac           | egress interface |\n"
+           "|============|======|===================|===================|==================|\n");
+}
+
+static int rt_print(const fpp_rt_cmd_t* p_rt)
+{
+    assert(NULL != p_rt);
+    
+    if (stt_do_header_print)
+    {
+        rt_header_print();
+        stt_do_header_print = false;
+    }
+    
+    {
+        printf("| %10"PRIu32, (p_rt->id));
+    }
+    {
+        const char* p_txt = ((fci_rt_ld_is_ip4(p_rt)) ? (TXT_PROTOCOL__IPv4) :
+                            ((fci_rt_ld_is_ip6(p_rt)) ? (TXT_PROTOCOL__IPv6) : "???"));
+        printf(" | %4s", p_txt);
+    }
+    {
+        printf(" | ");
+        cli_print_mac(p_rt->src_mac);
+        printf(" | ");
+        cli_print_mac(p_rt->dst_mac);
+    }
+    {
+        printf(" | %-15s ", (p_rt->output_device));
+    }
+    
+    printf(" |\n");
+    return (FPP_ERR_OK);
+}
+
+/* ==== PRIVATE FUNCTIONS : print conntrack ================================ */
+
+static void ct_print_aux_flags(bool isA, const char* p_txtA, bool isB, const char* p_txtB, bool isC, const char* p_txtC)
+{
+    assert(NULL != p_txtA);
+    assert(NULL != p_txtB);
+    assert(NULL != p_txtC);
+    
+    if (isA || isB || isC)
+    {
+        
+        p_txtA = (isA) ? (p_txtA) : ("");
+        p_txtB = (isB) ? (p_txtB) : ("");
+        p_txtC = (isC) ? (p_txtC) : ("");
+        
+        printf("[ %s%s%s]", p_txtA, p_txtB, p_txtC);
+    }
+    else 
+    {
+        printf("[ --- ]");
+    }
+}
+
+static int ct_print(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    
+    
+    /* NOTE: native data type to comply with 'printf()' conventions (asterisk specifier) */ 
+    int indent = 0;
+    
+    printf("%-*sconntrack:\n", indent, "");
+    
+    indent += 4;
+    
+    {
+        printf("%-*sproto:   %"PRIu16" (%s)\n", indent, "",
+               (p_ct->protocol), cli_value2txt_protocol(p_ct->protocol));
+    }
+    
+    {
+        printf("%-*sflags:   ", indent, "");
+        
+        ct_print_aux_flags(fci_ct_ld_is_ttl_decr(p_ct),   "TTL_DECR ",
+                           fci_ct_ld_is_reply_only(p_ct), "NO_ORIG ",    /* NOTE: negative logic */
+                           fci_ct_ld_is_orig_only(p_ct),  "NO_REPLY ");  /* NOTE: negative logic */
+        printf(" ; ");
+        ct_print_aux_flags(fci_ct_ld_is_nat(p_ct), "NAT ",
+                           fci_ct_ld_is_pat(p_ct), "PAT ",
+                           fci_ct_ld_is_vlan_tagging(p_ct), "VLAN_TAGGING ");
+        printf("\n");
+    }
+    
+    {
+        /* orig dir info */
+        printf("%-*sorig:    ", indent, "");
+        
+        printf("src=");
+        cli_print_ip4((p_ct->saddr), true);
+        
+        printf("    dst=");
+        cli_print_ip4((p_ct->daddr), true);
+        
+        printf("    sport=%-5"PRIu16, (p_ct->sport));
+        printf("    dport=%-5"PRIu16, (p_ct->dport));
+        printf("    vlan=%-5"PRIu16, (p_ct->vlan));
+        printf("    route=%-10"PRIu32, (p_ct->route_id));
+        
+        printf("\n");
+    }
+    
+    {
+        /* reply dir info */
+        printf("%-*sreply: ", indent, "");
+        
+        printf("r-src=");
+        cli_print_ip4((p_ct->saddr_reply), true);
+        
+        printf("  r-dst=");
+        cli_print_ip4((p_ct->daddr_reply), true);
+        
+        printf("  r-sport=%-5"PRIu16, (p_ct->sport_reply));
+        printf("  r-dport=%-5"PRIu16, (p_ct->dport_reply));
+        printf("  r-vlan=%-5"PRIu16, (p_ct->vlan_reply));
+        printf("  r-route=%-10"PRIu32, (p_ct->route_id_reply));
+        
+        printf("\n");
+    }
+    
+    return (FPP_ERR_OK); 
+}
+
+static int ct6_print(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    
+    
+    /* NOTE: native data type to comply with 'printf()' conventions (asterisk specifier) */ 
+    int indent = 0;
+    
+    printf("%-*sconntrack:\n", indent, "");
+    
+    indent += 4;
+    
+    {
+        printf("%-*sproto:   %"PRIu16" (%s)\n", indent, "",
+               (p_ct6->protocol), cli_value2txt_protocol(p_ct6->protocol));
+    }
+    
+    {
+        printf("%-*sflags:   ", indent, "");
+        
+        ct_print_aux_flags(fci_ct6_ld_is_ttl_decr(p_ct6),   "TTL_DECR ",
+                           fci_ct6_ld_is_reply_only(p_ct6), "NO_ORIG ",    /* NOTE: negative logic */
+                           fci_ct6_ld_is_orig_only(p_ct6),  "NO_REPLY ");  /* NOTE: negative logic */
+        printf(" ; ");
+        ct_print_aux_flags(fci_ct6_ld_is_nat(p_ct6), "NAT ",
+                           fci_ct6_ld_is_pat(p_ct6), "PAT ",
+                           fci_ct6_ld_is_vlan_tagging(p_ct6), "VLAN_TAGGING ");
+        printf("\n");
+    }
+    
+    {
+        /* orig dir info */
+        printf("%-*sorig:    ", indent, "");
+        
+        printf("src=");
+        cli_print_ip6(p_ct6->saddr);
+        
+        printf("    dst=");
+        cli_print_ip6(p_ct6->daddr);
+        
+        printf("    sport=%-5"PRIu16, (p_ct6->sport));
+        printf("    dport=%-5"PRIu16, (p_ct6->dport));
+        printf("    vlan=%-5"PRIu16, (p_ct6->vlan));
+        printf("    route=%-10"PRIu32, (p_ct6->route_id));
+        
+        printf("\n");
+    }
+    
+    {
+        /* reply dir info */
+        printf("%-*sreply: ", indent, "");
+        
+        printf("r-src=");
+        cli_print_ip6(p_ct6->saddr_reply);
+        
+        printf("  r-dst=");
+        cli_print_ip6(p_ct6->daddr_reply);
+        
+        printf("  r-sport=%-5"PRIu16, (p_ct6->sport_reply));
+        printf("  r-dport=%-5"PRIu16, (p_ct6->dport_reply));
+        printf("  r-vlan=%-5"PRIu16, (p_ct6->vlan_reply));
+        printf("  r-route=%-10"PRIu32, (p_ct6->route_id_reply));
+        
+        printf("\n");
+    }
+    
+    return (FPP_ERR_OK); 
+}
+
+/* ==== PUBLIC FUNCTIONS : route =========================================== */
+
+int cli_cmd_route_print(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_rt_cmd_t rt = {0};
+    
+    /* check for mandatory opts */
+    /* empty */
+    
+    /* exec */
+    stt_do_header_print = true;
+    if (p_cmdargs->route.is_valid)
+    {
+        /* print single route */
+        rtn = fci_rt_get_by_id(cli_p_cl, &rt, (p_cmdargs->route.value));
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = rt_print(&rt);
+        }
+    }
+    else if (p_cmdargs->ip4.is_valid)
+    {
+        /* print all IPv4 routes */
+        rtn = fci_rt_print_all(cli_p_cl, rt_print, true, false);
+    }
+    else if (p_cmdargs->ip6.is_valid)
+    {
+        /* print all IPv6 routes */
+        rtn = fci_rt_print_all(cli_p_cl, rt_print, false, true);
+    }
+    else
+    {
+        /* print all routes */
+        rtn = fci_rt_print_all(cli_p_cl, rt_print, true, true);
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_route_add(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_rt_cmd_t rt = {0};
+    
+    /* check for mandatory opts */
+    const mandopt_optbuf_t ip46 = {{OPT_IP4, OPT_IP6}};
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_ROUTE,     NULL,   (p_cmdargs->route.is_valid)},
+        {OPT_NONE,      &ip46, ((p_cmdargs->ip4.is_valid) || (p_cmdargs->ip6.is_valid))},
+        {OPT_DMAC,      NULL,   (p_cmdargs->dmac.is_valid)},
+        {OPT_INTERFACE, NULL,   (p_cmdargs->if_name.is_valid)},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* get init local data */
+    /* empty (no 'init data' from the PFE) */
+    
+    /* modify local data - set IP type */
+    if (FPP_ERR_OK == rtn)
+    {
+        if (p_cmdargs->ip4.is_valid)
+        {
+            rtn = fci_rt_ld_set_as_ip4(&rt);
+        }
+        else if (p_cmdargs->ip6.is_valid)
+        {
+            rtn = fci_rt_ld_set_as_ip6(&rt);
+        }
+        else
+        {
+            rtn = CLI_ERR;  /* should never happen */
+        }
+    }
+    
+    /* modify local data - smac (optional) */
+    if ((FPP_ERR_OK == rtn) && (p_cmdargs->smac.is_valid))
+    {
+        rtn = fci_rt_ld_set_src_mac(&rt, (p_cmdargs->smac.arr));
+    }
+    
+    /* modify local data - dmac */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_rt_ld_set_dst_mac(&rt, (p_cmdargs->dmac.arr));
+    }
+    
+    /* modify local data - phyif */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_rt_ld_set_egress_phyif(&rt, (p_cmdargs->if_name.txt));
+    }
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_rt_add(cli_p_cl, (p_cmdargs->route.value), &rt);
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_route_del(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = {{OPT_ROUTE, NULL,  (p_cmdargs->route.is_valid)}};
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_rt_del(cli_p_cl, (p_cmdargs->route.value));
+    }
+    
+    return (rtn);
+}
+
+/* ==== PUBLIC FUNCTIONS : conntrack ======================================= */
+
+int cli_cmd_cntk_print(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = FPP_ERR_OK;  /* must be initially OK for the following algorithm to work */
+    
+    /* check for mandatory opts */
+    /* empty */
+    
+    /* exec */
+    const bool print_all = (!(p_cmdargs->ip4.is_valid) && !(p_cmdargs->ip6.is_valid));
+    if ((FPP_ERR_OK == rtn) && ((p_cmdargs->ip4.is_valid) || print_all))
+    {
+        rtn = fci_ct_print_all(cli_p_cl, ct_print);
+    }
+    if ((FPP_ERR_OK == rtn) && ((p_cmdargs->ip6.is_valid) || print_all))
+    {
+        rtn = fci_ct6_print_all(cli_p_cl, ct6_print);
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_cntk_update(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_PROTOCOL, NULL,  (p_cmdargs->protocol.is_valid)},
+        {OPT_SIP,      NULL,  (p_cmdargs->sip.is_valid)},
+        {OPT_DIP,      NULL,  (p_cmdargs->dip.is_valid)},
+        {OPT_SPORT,    NULL,  (p_cmdargs->sport.is_valid)},
+        {OPT_DPORT,    NULL,  (p_cmdargs->dport.is_valid)},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* late opt arg check to ensure that all IP-related cli opts are either IPv4, or IPv6 (no mixing allowed) */
+    /* check optional IP-related cli opts as well (if they are valid) */
+    if (FPP_ERR_OK == rtn)
+    {
+        const bool is6 = (p_cmdargs->sip.is6);
+        if (((p_cmdargs->sip.is6) != (p_cmdargs->dip.is6)) ||
+            ((p_cmdargs->sip2.is_valid) && ((p_cmdargs->sip2.is6) != is6)) ||
+            ((p_cmdargs->dip2.is_valid) && ((p_cmdargs->dip2.is6) != is6)))
+        {
+            rtn = CLI_ERR_INCOMPATIBLE_IPS;
+        }
+    }
+    
+    /* get init local data */
+    /* empty (no universal 'init data' from the PFE) */
+    
+    /* modify local data */
+    if (FPP_ERR_OK == rtn)
+    {
+        if (p_cmdargs->sip.is6)
+        {
+            fpp_ct6_cmd_t ct6 = {0};
+            ct6.protocol = (p_cmdargs->protocol.value);
+            ct6.sport = (p_cmdargs->sport.value);
+            ct6.sport = (p_cmdargs->dport.value);
+            memcpy(ct6.saddr, p_cmdargs->sip.arr, (IP6_U32S_LN * sizeof(uint32_t)));
+            memcpy(ct6.daddr, p_cmdargs->dip.arr, (IP6_U32S_LN * sizeof(uint32_t)));
+            
+            /* get init local data */
+            rtn = fci_ct6_get_by_tuple(cli_p_cl, &ct6, &ct6);
+            
+            /* modify local data */
+            if ((CLI_OK == rtn) && (p_cmdargs->loadbalance__ttl_decr.is_valid))
+            {
+                rtn = fci_ct6_ld_set_ttl_decr(&ct6, (p_cmdargs->loadbalance__ttl_decr.is_on));
+            }
+            
+            /* exec */
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = fci_ct6_update(cli_p_cl, &ct6);
+            }
+        }
+        else
+        {
+            fpp_ct_cmd_t ct = {0};
+            ct.protocol = (p_cmdargs->protocol.value);
+            ct.sport = (p_cmdargs->sport.value);
+            ct.sport = (p_cmdargs->dport.value);
+            ct.saddr = (p_cmdargs->sip.arr[0]);
+            ct.daddr = (p_cmdargs->dip.arr[0]);
+            
+            /* get init local data */
+            rtn = fci_ct_get_by_tuple(cli_p_cl, &ct, &ct);
+            
+            /* modify local data */
+            if ((CLI_OK == rtn) && (p_cmdargs->loadbalance__ttl_decr.is_valid))
+            {
+                rtn = fci_ct_ld_set_ttl_decr(&ct, (p_cmdargs->loadbalance__ttl_decr.is_on));
+            }
+            
+            /* exec */
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = fci_ct_update(cli_p_cl, &ct);
+            }
+        }
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_cntk_add(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_PROTOCOL, NULL,  (p_cmdargs->protocol.is_valid)},
+        {OPT_SIP,      NULL,  (p_cmdargs->sip.is_valid)},
+        {OPT_DIP,      NULL,  (p_cmdargs->dip.is_valid)},
+        {OPT_SPORT,    NULL,  (p_cmdargs->sport.is_valid)},
+        {OPT_DPORT,    NULL,  (p_cmdargs->dport.is_valid)},
+        {OPT_ROUTE,    NULL,  (p_cmdargs->route.is_valid)},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* late opt arg check to ensure that all IP-related cli opts are either IPv4, or IPv6 (no mixing allowed) */
+    /* check optional IP-related cli opts as well (if they are valid) */
+    if (FPP_ERR_OK == rtn)
+    {
+        const bool is6 = (p_cmdargs->sip.is6);
+        if (((p_cmdargs->sip.is6) != (p_cmdargs->dip.is6)) ||
+            ((p_cmdargs->sip2.is_valid) && ((p_cmdargs->sip2.is6) != is6)) ||
+            ((p_cmdargs->dip2.is_valid) && ((p_cmdargs->dip2.is6) != is6)))
+        {
+            rtn = CLI_ERR_INCOMPATIBLE_IPS;
+        }
+    }
+    
+    /* get init local data */
+    /* empty (no 'init data' from the PFE) */
+    
+    /* modify local data */
+    if (FPP_ERR_OK == rtn)
+    {
+        /*
+            NOTE:   If reply opts ('r-XXX') are not cli-specified, they are filled with the "cross" value from the orig data.
+                    Example: if 'r-sip' not specified by user, it is by default filled with 'dip' value.
+                    For details, see the FCI API Reference.
+        */
+        const uint32_t* p_saddr_reply = ((p_cmdargs->sip2.is_valid)   ? (p_cmdargs->sip2.arr)     : (p_cmdargs->dip.arr));
+        const uint32_t* p_daddr_reply = ((p_cmdargs->dip2.is_valid)   ? (p_cmdargs->dip2.arr)     : (p_cmdargs->sip.arr));
+        const uint16_t    sport_reply = ((p_cmdargs->sport2.is_valid) ? (p_cmdargs->sport2.value) : (p_cmdargs->dport.value));
+        const uint16_t    dport_reply = ((p_cmdargs->dport2.is_valid) ? (p_cmdargs->dport2.value) : (p_cmdargs->sport.value));
+        const uint32_t route_id_reply = ((p_cmdargs->route2.is_valid) ? (p_cmdargs->route2.value) : (p_cmdargs->route.value));
+        const uint16_t     vlan_reply = ((p_cmdargs->vlan2.is_valid)  ? (p_cmdargs->vlan2.value)  : (p_cmdargs->vlan.value));
+        
+        if (p_cmdargs->sip.is6)
+        {
+            fpp_ct6_cmd_t ct6 = {0};
+            
+            /* prepare data for IPv6 conntrack */
+            rtn = fci_ct6_ld_set_protocol(&ct6, (p_cmdargs->protocol.value));
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = fci_ct6_ld_set_orig_dir(&ct6, (p_cmdargs->sip.arr), (p_cmdargs->dip.arr),
+                                                    (p_cmdargs->sport.value), (p_cmdargs->dport.value),
+                                                    (p_cmdargs->route.value), (p_cmdargs->vlan.value),
+                                                    (p_cmdargs->enable_noreply.is_valid));
+            }
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = fci_ct6_ld_set_reply_dir(&ct6, p_saddr_reply, p_daddr_reply,
+                                                     sport_reply, dport_reply,
+                                                     route_id_reply, vlan_reply,
+                                                    (p_cmdargs->disable_noorig.is_valid));
+            }
+            
+            /* exec - create IPv6 conntrack */
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = fci_ct6_add(cli_p_cl, &ct6);
+            }
+            
+            /* WORKAROUND - ttl decrement is accessible only via update command */
+            if ((FPP_ERR_OK == rtn) && (p_cmdargs->loadbalance__ttl_decr.is_valid))
+            {
+                /* modify local data */
+                rtn = fci_ct6_ld_set_ttl_decr(&ct6, (p_cmdargs->loadbalance__ttl_decr.is_on));
+                
+                /* exec */
+                if (FPP_ERR_OK == rtn)
+                {
+                    rtn = fci_ct6_update(cli_p_cl, &ct6);
+                }
+            }
+        }
+        else
+        {
+            fpp_ct_cmd_t ct = {0};
+                        
+            /* prepare data for IPv4 conntrack */
+            rtn = fci_ct_ld_set_protocol(&ct, (p_cmdargs->protocol.value));
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = fci_ct_ld_set_orig_dir(&ct, (p_cmdargs->sip.arr[0]),  (p_cmdargs->dip.arr[0]),
+                                                  (p_cmdargs->sport.value), (p_cmdargs->dport.value),
+                                                  (p_cmdargs->route.value), (p_cmdargs->vlan.value),
+                                                  (p_cmdargs->enable_noreply.is_valid));
+            }
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = fci_ct_ld_set_reply_dir(&ct, p_saddr_reply[0], p_daddr_reply[0],
+                                                   sport_reply, dport_reply,
+                                                   route_id_reply, vlan_reply,
+                                                  (p_cmdargs->disable_noorig.is_valid));
+            }
+            
+            /* exec - create IPv4 conntrack */
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = fci_ct_add(cli_p_cl, &ct);
+            }
+            
+            /* WORKAROUND - ttl decrement is accessible only via update command */
+            if ((FPP_ERR_OK == rtn) && (p_cmdargs->loadbalance__ttl_decr.is_valid))
+            {
+                /* modify local data */
+                rtn = fci_ct_ld_set_ttl_decr(&ct, (p_cmdargs->loadbalance__ttl_decr.is_on));
+                
+                /* exec */
+                if (FPP_ERR_OK == rtn)
+                {
+                    rtn = fci_ct_update(cli_p_cl, &ct);
+                }
+            }
+        }
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_cntk_del(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_PROTOCOL, NULL,  (p_cmdargs->protocol.is_valid)},
+        {OPT_SIP,      NULL,  (p_cmdargs->sip.is_valid)},
+        {OPT_DIP,      NULL,  (p_cmdargs->dip.is_valid)},
+        {OPT_SPORT,    NULL,  (p_cmdargs->sport.is_valid)},
+        {OPT_DPORT,    NULL,  (p_cmdargs->dport.is_valid)},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* late opt arg check to ensure that all IP-related cli opts are either IPv4, or IPv6 (no mixing allowed) */
+    if ((FPP_ERR_OK == rtn) && ((p_cmdargs->sip.is6) != (p_cmdargs->dip.is6)))
+    {
+        rtn = CLI_ERR_INCOMPATIBLE_IPS;
+    }
+    
+    /* modify local data */
+    if (FPP_ERR_OK == rtn)
+    {
+        if (p_cmdargs->sip.is6)
+        {
+            fpp_ct6_cmd_t ct6 = {0};
+            
+            /* prepare data for IPv6 conntrack */
+            rtn = fci_ct6_ld_set_protocol(&ct6, (p_cmdargs->protocol.value));
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = fci_ct6_ld_set_orig_dir(&ct6, (p_cmdargs->sip.arr), (p_cmdargs->dip.arr),
+                                                    (p_cmdargs->sport.value), (p_cmdargs->dport.value),
+                                                     0uL, 0u, false);
+            }
+            
+            /* exec - destroy IPv6 conntrack */
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = fci_ct6_del(cli_p_cl, &ct6);
+            }
+        }
+        else
+        {
+            fpp_ct_cmd_t ct = {0};
+            
+            /* prepare data for IPv4 conntrack */
+            rtn = fci_ct_ld_set_protocol(&ct, (p_cmdargs->protocol.value));
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = fci_ct_ld_set_orig_dir(&ct, (p_cmdargs->sip.arr[0]), (p_cmdargs->dip.arr[0]),
+                                                  (p_cmdargs->sport.value), (p_cmdargs->dport.value),
+                                                   0uL, 0u, false);
+            }
+            
+            /*  exec - destroy IPv4 conntrack  */
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = fci_ct_del(cli_p_cl, &ct);
+            }
+        }
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_cntk_timeout(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_PROTOCOL, NULL,  (p_cmdargs->protocol.is_valid)},
+        {OPT_TIMEOUT,  NULL,  (p_cmdargs->timeout.is_valid)},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        if (6u == (p_cmdargs->protocol.value))  /* 6u is protocol ID of TCP */
+        {
+            fci_ct_timeout_tcp(cli_p_cl, (p_cmdargs->timeout.value), (p_cmdargs->fallback_4o6.is_valid));
+        }
+        else if (17u == (p_cmdargs->protocol.value))  /* 17u is protocol ID of UDP */
+        {
+            const uint32_t timeout2 = ((p_cmdargs->timeout2.is_valid) ? (p_cmdargs->timeout2.value) : (0uL));
+            fci_ct_timeout_udp(cli_p_cl, (p_cmdargs->timeout.value), timeout2, (p_cmdargs->fallback_4o6.is_valid));
+        }
+        else
+        {
+            fci_ct_timeout_others(cli_p_cl, (p_cmdargs->timeout.value), (p_cmdargs->fallback_4o6.is_valid));
+        }
+    }
+    
+    return (rtn);
+}
+
+/* ==== PUBLIC FUNCTIONS : route and conntrack reset ======================= */
+
+int cli_cmd_route_and_cntk_reset(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_optbuf_t a46 = {{OPT_ALL, OPT_IP4, OPT_IP6}};
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_NONE, &a46, ((p_cmdargs->all.is_valid) || (p_cmdargs->ip4.is_valid) || (p_cmdargs->ip6.is_valid))},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        if ((p_cmdargs->ip4.is_valid) || (p_cmdargs->all.is_valid))
+        {
+            fci_rtct_reset_ip4(cli_p_cl);
+        }
+        if ((p_cmdargs->ip6.is_valid) || (p_cmdargs->all.is_valid))
+        {
+            fci_rtct_reset_ip6(cli_p_cl);
+        }
+    }
+    
+    return (rtn);
+}
+
+/* ========================================================================= */
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_route_and_cntk.h b/sw/libfci_cli/src/libfci_cli_cmds_route_and_cntk.h
new file mode 100644
index 0000000..7a048e2
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_cmds_route_and_cntk.h
@@ -0,0 +1,37 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef LIBFCI_CLI_CMDS_ROUTE_AND_CNTK_H_
+#define LIBFCI_CLI_CMDS_ROUTE_AND_CNTK_H_
+
+#include "libfci_cli_common.h"
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+int cli_cmd_route_print(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_route_add(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_route_del(const cli_cmdargs_t *p_cmdargs);
+
+int cli_cmd_cntk_print(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_cntk_update(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_cntk_add(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_cntk_del(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_cntk_timeout(const cli_cmdargs_t *p_cmdargs);
+
+int cli_cmd_route_and_cntk_reset(const cli_cmdargs_t *p_cmdargs);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_spd.c b/sw/libfci_cli/src/libfci_cli_cmds_spd.c
new file mode 100644
index 0000000..82fd348
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_cmds_spd.c
@@ -0,0 +1,249 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#include <assert.h>
+#include <inttypes.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <string.h>
+#include "libfci_cli_common.h"
+#include "libfci_cli_def_opts.h"
+#include "libfci_cli_print_helpers.h"
+#include "libfci_cli_def_optarg_keywords.h"
+#include "libfci_cli_cmds_spd.h"
+
+#include "libfci_interface/fci_spd.h"
+
+/* ==== TESTMODE vars ====================================================== */
+
+#if !defined(NDEBUG)
+/* empty */
+#endif
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+extern FCI_CLIENT* cli_p_cl;
+
+/* ==== PRIVATE FUNCTIONS : prints ========================================= */
+
+static int spd_print(const fpp_spd_cmd_t* p_spd)
+{
+    assert(NULL != p_spd);
+    
+    
+    {
+        printf("[%5"PRIu16"]", (p_spd->position));
+    }
+    {
+        unsigned int padding = 0u;
+        
+        const char* p_txt = cli_value2txt_spd_action(p_spd->spd_action);
+        padding += strlen(p_txt);
+        printf("  ;  [ %s", p_txt);
+        
+        switch (p_spd->spd_action)
+        {
+            case FPP_SPD_ACTION_PROCESS_ENCODE:
+                p_txt = " sad=";
+                padding += strlen(p_txt) + 10u;  /* counting in fixed 10 characters of the associated numeric value */
+                printf("%s%-10"PRIu32, p_txt, (p_spd->sa_id));
+            break;
+            
+            case FPP_SPD_ACTION_PROCESS_DECODE:
+                p_txt = " spi=0x";
+                padding += strlen(p_txt) + 8u;  /* counting in fixed 8 characters of the associated numeric value */
+                printf("%s%08"PRIx32, p_txt, (p_spd->spi));
+            break;
+            
+            default:
+                p_txt = NULL;
+                padding += 0uL;
+            break;
+        }
+        
+        padding = ((21u >= padding) ? (21u - padding) : (0u));  /* 21 chars is maximal expected length of this section */
+        printf("%-*s ]", padding, "");
+    }
+    {
+        /* protocol */
+        const char* p_txt = cli_value2txt_protocol(p_spd->protocol);
+        printf("  ;  %-10s %3"PRIu16, p_txt, (p_spd->protocol));
+    }
+    {
+        /* IP */
+        uint32_t tmpbuf_ipaddr[4] = {0u};  /* use tmp buf to enforce correct alignment */
+        
+        printf("  ;  src=");
+        memcpy(tmpbuf_ipaddr, (p_spd->saddr), sizeof(uint32_t)*4);
+        if (fci_spd_ld_is_ip6(p_spd))
+        {
+            cli_print_ip6(tmpbuf_ipaddr);
+        }
+        else
+        {
+            cli_print_ip4(tmpbuf_ipaddr[0], true);
+        }
+        
+        printf("  dst=");
+        memcpy(tmpbuf_ipaddr, (p_spd->daddr), sizeof(uint32_t)*4);
+        if (fci_spd_ld_is_ip6(p_spd))
+        {
+            cli_print_ip6(tmpbuf_ipaddr);
+        }
+        else
+        {
+            cli_print_ip4(tmpbuf_ipaddr[0], true);
+        }
+    }
+    {
+        /* port */
+        if (fci_spd_ld_is_used_sport(p_spd))
+        {
+            printf("  sport=%-5"PRIu16, (p_spd->sport));
+        }
+        else
+        {
+            printf("  sport= --- ");
+        }
+        
+        if (fci_spd_ld_is_used_dport(p_spd))
+        {
+            printf("  dport=%-5"PRIu16, (p_spd->dport));
+        }
+        else
+        {
+            printf("  dport= --- ");
+        }
+    }
+    
+    printf("\n");
+    return (FPP_ERR_OK); 
+}
+
+/* ==== PUBLIC FUNCTIONS =================================================== */ 
+
+int cli_cmd_spd_print(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = {{OPT_INTERFACE, NULL, (p_cmdargs->if_name.is_valid)}};
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        const uint16_t pos = (p_cmdargs->offset.is_valid) ? (p_cmdargs->offset.value) : (0u);
+        const uint16_t cnt = (p_cmdargs->count_ethtype.is_valid) ? (p_cmdargs->count_ethtype.value) : (0u);
+        rtn = fci_spd_print_by_phyif(cli_p_cl, spd_print, (p_cmdargs->if_name.txt), pos, cnt);
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_spd_add(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    fpp_spd_cmd_t spd = {0};
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] =
+    {
+        {OPT_INTERFACE,  NULL,  (p_cmdargs->if_name.is_valid)},
+        {OPT_PROTOCOL,   NULL,  (p_cmdargs->protocol.is_valid)},
+        {OPT_SIP,        NULL,  (p_cmdargs->sip.is_valid)},
+        {OPT_DIP,        NULL,  (p_cmdargs->dip.is_valid)},
+        {OPT_SPD_ACTION, NULL,  (p_cmdargs->spd_action.is_valid)},
+        {OPT_SAD,        NULL, ((FPP_SPD_ACTION_PROCESS_ENCODE == (p_cmdargs->spd_action.value)) ? (p_cmdargs->data_hifc_sad.is_valid) : (true))},
+        {OPT_SPI,        NULL, ((FPP_SPD_ACTION_PROCESS_DECODE == (p_cmdargs->spd_action.value)) ? (p_cmdargs->mask_spi.is_valid)      : (true))},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* late opt arg check to ensure that all IP-related cli opts are either IPv4, or IPv6 (no mixing allowed) */
+    if ((FPP_ERR_OK == rtn) && ((p_cmdargs->sip.is6) != (p_cmdargs->dip.is6)))
+    {
+        rtn = CLI_ERR_INCOMPATIBLE_IPS;
+    }
+    
+    /* get init local data */
+    /* empty (no 'init data' from the PFE) */
+    
+    /* modify local data */
+    if (FPP_ERR_OK == rtn)
+    {
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = fci_spd_ld_set_protocol(&spd, (p_cmdargs->protocol.value));
+        }
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = fci_spd_ld_set_ip(&spd, (p_cmdargs->sip.arr), (p_cmdargs->dip.arr), (p_cmdargs->sip.is6));
+        }
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = fci_spd_ld_set_port(&spd, (p_cmdargs->sport.is_valid), (p_cmdargs->sport.value), 
+                                            (p_cmdargs->dport.is_valid), (p_cmdargs->dport.value));
+        }
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = fci_spd_ld_set_action(&spd, (p_cmdargs->spd_action.value), 
+                                              (p_cmdargs->data_hifc_sad.value), (p_cmdargs->mask_spi.value));
+        }
+    }
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        const uint16_t pos = ((p_cmdargs->offset.is_valid) ? (p_cmdargs->offset.value) : (UINT16_MAX));
+        rtn = fci_spd_add(cli_p_cl, (p_cmdargs->if_name.txt), pos, &spd);
+    }
+    
+    return (rtn);
+}
+
+int cli_cmd_spd_del(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] =
+    {
+        {OPT_INTERFACE,  NULL,  (p_cmdargs->if_name.is_valid)},
+        {OPT_POSITION,   NULL,  (p_cmdargs->offset.is_valid)},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* exec */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_spd_del(cli_p_cl, (p_cmdargs->if_name.txt), (p_cmdargs->offset.value));
+    }
+    
+    return (rtn);
+}
+
+/* ========================================================================= */
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_spd.h b/sw/libfci_cli/src/libfci_cli_cmds_spd.h
new file mode 100644
index 0000000..d03c611
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_cmds_spd.h
@@ -0,0 +1,29 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef LIBFCI_CLI_CMDS_SPD_H_
+#define LIBFCI_CLI_CMDS_SPD_H_
+
+#include "libfci_cli_common.h"
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+int cli_cmd_spd_print(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_spd_add(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_spd_del(const cli_cmdargs_t *p_cmdargs);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_cli_common.h b/sw/libfci_cli/src/libfci_cli_common.h
new file mode 100644
index 0000000..78c1e49
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_common.h
@@ -0,0 +1,511 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef CLI_COMMON_H_
+#define CLI_COMMON_H_
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+#define NDEBUG
+
+/* app version (default values for non-makefile compilation) */
+#ifndef LIBFCI_CLI_TARGET_OS
+#define LIBFCI_CLI_TARGET_OS  "UNKNOWN_OS"
+#endif
+#ifndef LIBFCI_CLI_VERSION
+#define LIBFCI_CLI_VERSION  "?.?.?"
+#endif
+#ifndef PFE_CT_H_MD5
+#define PFE_CT_H_MD5  "????????????????????????????????"
+#endif
+#ifndef GLOBAL_VERSION_CONTROL_ID
+#define GLOBAL_VERSION_CONTROL_ID  "???????"
+#endif
+
+/* return codes */
+#define CLI_OK                     (FPP_ERR_OK)  /* Bound to LibFCI OK code for compatibility reasons */
+#define CLI_ERR                    (-111)
+#define CLI_ERR_INVPTR             (-112)
+#define CLI_ERR_INVCMD             (-113)
+#define CLI_ERR_INVOPT             (-114)
+#define CLI_ERR_INVARG             (-115)
+#define CLI_ERR_NONOPT             (-116)
+#define CLI_ERR_INCOMPATIBLE_OPTS  (-117)
+#define CLI_ERR_MISSING_MANDOPT    (-118)
+#define CLI_ERR_INCOMPATIBLE_IPS   (-119)
+#define CLI_ERR_WRONG_IP_TYPE      (-120)
+
+
+/* misc macros */
+#define MAC_BYTES_LN         (6u)
+#define MAC_STRLEN           (17)
+#define IP6_U32S_LN          (4u)
+#define IF_NAME_TXT_LN       (IFNAMSIZ)
+#define TABLE_NAME_TXT_LN    (16u)
+#define FEATURE_NAME_TXT_LN  (FPP_FEATURE_NAME_SIZE + 1)  /* this is how the buffer size is defined in 'fpp.ext.h' */
+#define ZPROBS_LN            (8u)  /* Max count of probability zones is based on info from FCI API Reference (chapter about "QoS" feature) */
+#define SCH_INS_LN           (8u)  /* Max count of scheduler inputs is based on info from FCI API Reference (chapter about "QoS" feature) */
+
+/* misc macro sanity checks */
+#if (MAC_BYTES_LN < 2u)
+  #error "MAC_BYTES_LN must be '2' or greater! (why not '6' as usual?)"
+#endif
+#if (IF_NAME_TXT_LN < 2u)
+  #error "IF_NAME_TXT_LN must be '2' or greater!"
+#endif
+#if (TABLE_NAME_TXT_LN < 2u)
+  #error "TABLE_NAME_TXT_LN must be '2' or greater!"
+#endif
+#if (FEATURE_NAME_TXT_LN < 2u)
+  #error "FEATURE_NAME_TXT_LN must be '2' or greater!"
+#endif
+
+
+#define UNUSED(PAR) ((void)(PAR))
+
+
+/* 'superstructure' - all available arguments for cli commands (usually tied with cli opts) */
+typedef struct cli_cmdargs_tt
+{
+    struct
+    {
+        bool is_valid;
+    } ip4;
+    struct
+    {
+        bool is_valid;
+    } ip6;
+    struct
+    {
+        bool is_valid;
+    } all;
+    struct
+    {
+        bool is_valid;
+    } help;
+    struct
+    {
+        bool is_valid;
+    } verbose;
+    struct
+    {
+        bool is_valid;
+    } version;
+    
+    
+    struct
+    {
+        bool is_valid;
+        char txt[IF_NAME_TXT_LN];
+    } if_name;
+    struct
+    {
+        bool is_valid;
+        char txt[IF_NAME_TXT_LN];
+    } if_name_parent;
+    struct
+    {
+        bool is_valid;
+        char txt[IF_NAME_TXT_LN];  /* empty string ("") indicates rq to disable mirroring */
+    } if_name_mirror;
+    struct
+    {
+        bool is_valid;
+        fpp_phy_if_op_mode_t value;
+    } if_mode;
+    struct
+    {
+        bool is_valid;
+        fpp_phy_if_block_state_t value;
+    } if_block_state;
+    
+    
+    struct
+    {
+        bool is_valid;
+    } enable_noreply;        /* NOTE: 'OPT_ENABLE' and 'OPT_NO_REPLY' share the same storage */
+    struct
+    {
+        bool is_valid;
+    } disable_noorig;        /* NOTE: 'OPT_DISABLE' and 'OPT_NO_ORIG' share the same storage */
+    struct
+    {
+        bool is_valid;
+        bool is_on;
+    } promisc;
+    struct
+    {
+        bool is_valid;
+        bool is_on;
+    } loadbalance__ttl_decr; /* NOTE: 'OPT_LOADBALANCE' and 'OPT_TTL_DESCR' share the same storage */
+    struct
+    {
+        bool is_valid;       /* NOTE: 'OPT_VLAN_CONF' and 'OPT_DISCARD_ON_MATCH_SRC' share the same storage */
+        bool is_on;
+    } vlan_conf__x_src;
+    struct
+    {
+        bool is_valid;
+        bool is_on;
+    } ptp_conf__x_dst;       /* NOTE: 'OPT_PTP_CONF' and 'OPT_DISCARD_ON_MATCH_DST' share the same storage */
+    struct
+    {
+        bool is_valid;
+        bool is_on;
+    } ptp_promisc;
+    struct
+    {
+        bool is_valid;
+        bool is_on;
+    } loopback;
+    struct
+    {
+        bool is_valid;
+        bool is_on;
+    } qinq;
+    struct
+    {
+        bool is_valid;
+        bool is_on;
+    } local;
+    struct
+    {
+        bool is_valid;
+        bool is_or;
+    } match_mode;
+    struct
+    {
+        bool is_valid;
+        bool is_on;
+    } discard_on_match;
+    struct
+    {
+        bool is_valid;
+        bool is_on;
+    } discard_if_ttl_below_2;
+    struct
+    {
+        bool is_valid;
+        uint32_t bitset;
+    } egress;
+    struct
+    {
+        bool is_valid;
+        fpp_if_m_rules_t bitset;
+    } match_rules;
+    
+    
+    struct
+    {
+        bool is_valid;
+        uint16_t value;
+    } vlan;
+    struct
+    {
+        bool is_valid;
+        uint16_t value;
+    } vlan2;
+    struct
+    {
+        bool is_valid;
+        uint8_t value;
+    } protocol;
+    struct
+    {
+        bool is_valid;
+        uint16_t value;
+    } count_ethtype;         /* NOTE: 'OPT_COUNT' and 'OPT_ETHTYPE' share the same storage */
+    struct
+    {
+        bool is_valid;
+        uint8_t arr[MAC_BYTES_LN];
+    } smac;                  /* NOTE: 'OPT_SMAC' and 'OPT_MAC' share the same storage */
+    struct
+    {
+        bool is_valid;
+        uint8_t arr[MAC_BYTES_LN];
+    } dmac;
+    
+    
+    struct
+    {
+        bool is_valid;
+        bool is6;
+        uint32_t arr[IP6_U32S_LN];
+    } sip;
+    struct
+    {
+        bool is_valid;
+        bool is6;
+        uint32_t arr[IP6_U32S_LN];
+    } dip;
+    struct
+    {
+        bool is_valid;
+        bool is6;
+        uint32_t arr[IP6_U32S_LN];
+    } sip2;                  /* NOTE: 'OPT_R_SIP' and 'OPT_SIP6' share the same storage */
+    struct
+    {
+        bool is_valid;
+        bool is6;
+        uint32_t arr[IP6_U32S_LN];
+    } dip2;                  /* NOTE: 'OPT_R_DIP' and 'OPT_DIP6' share the same storage */
+    
+    
+    struct
+    {
+        bool is_valid;
+        uint16_t value;
+    } sport;
+    struct
+    {
+        bool is_valid;
+        uint16_t value;
+    } dport;
+    struct
+    {
+        bool is_valid;
+        uint16_t value;
+    } sport2;
+    struct
+    {
+        bool is_valid;
+        uint16_t value;
+    } dport2;
+    
+    
+    struct
+    {
+        bool is_valid;
+        uint8_t value;
+    } ucast_hit;
+    struct
+    {
+        bool is_valid;
+        uint8_t value;
+    } ucast_miss;
+    struct
+    {
+        bool is_valid;
+        uint8_t value;
+    } mcast_hit;
+    struct
+    {
+        bool is_valid;
+        uint8_t value;
+    } mcast_miss;
+    struct
+    {
+        bool is_valid;
+        bool is_on;
+    } tag;
+    struct
+    {
+        bool is_valid;
+    } default0;
+    struct
+    {
+        bool is_valid;
+    } fallback_4o6;          /* NOTE: 'OPT_FALLBACK' and 'OPT_4o6' share the same storage */
+    
+    
+    struct
+    {
+        bool is_valid;
+        uint32_t value;
+    } route;
+    struct
+    {
+        bool is_valid;
+        uint32_t value;
+    } route2;
+    
+    
+    struct
+    {
+        bool is_valid;
+        char txt[TABLE_NAME_TXT_LN];
+    } ruleA0_name;           /* NOTE: 'OPT_INGRESS_MR0' and 'OPT_RULE' share the same storage */
+    struct
+    {
+        bool is_valid;
+        char txt[TABLE_NAME_TXT_LN];
+    } ruleA1_name;
+    struct
+    {
+        bool is_valid;
+        char txt[TABLE_NAME_TXT_LN];
+    } ruleB0_name;           /* NOTE: 'OPT_EGRESS_MR0' and 'OPT_NEXT_RULE' share the same storage */
+    struct
+    {
+        bool is_valid;
+        char txt[TABLE_NAME_TXT_LN];
+    } ruleB1_name;
+    struct
+    {
+        bool is_valid;
+        char txt[TABLE_NAME_TXT_LN];
+    } table0_name;           /* NOTE: 'OPT_TABLE', 'OPT_TABLE0' and 'OPT_FLEXIBLE_FILTER' share the same storage */
+    struct
+    {
+        bool is_valid;
+        char txt[TABLE_NAME_TXT_LN];
+    } table1_name;
+    
+    
+    struct
+    {
+        bool is_valid;
+        uint32_t value;
+    } timeout;
+    struct
+    {
+        bool is_valid;
+        uint32_t value;
+    } timeout2;
+    struct
+    {
+        bool is_valid;
+        uint32_t value;
+    } data_hifc_sad;         /* NOTE: 'OPT_DATA', 'OPT_HIF_COOKIE' and 'OPT_SAD' share the same storage */
+    struct
+    {
+        bool is_valid;
+        uint32_t value;
+    } mask_spi;              /* NOTE: 'OPT_MASK' and 'OPT_SPI' share the same storage  */
+    struct
+    {
+        bool is_valid;
+        fpp_fp_offset_from_t value;
+    } layer;
+    struct
+    {
+        bool is_valid;
+        uint16_t value;
+    } offset;                /* NOTE: 'OPT_OFFSET' and 'OPT_POSITION' share the same storage */
+    struct
+    {
+        bool is_valid;
+    } invert;
+    struct
+    {
+        bool is_valid;
+    } accept;
+    struct
+    {
+        bool is_valid;
+    } reject;
+    
+    
+    struct
+    {
+        bool is_valid;
+        fpp_spd_action_t value;
+    } spd_action;
+    
+    
+    struct
+    {
+        bool is_valid;
+        char txt[FEATURE_NAME_TXT_LN];
+    } feature_name;
+    
+    
+    struct
+    {
+        bool is_valid;
+    } static0;
+    struct
+    {
+        bool is_valid;
+    } dynamic0;
+    
+    
+    struct
+    {
+        bool is_valid;
+        uint8_t value;
+    } que_sch_shp;           /* NOTE: 'OPT_QUE', 'OPT_SCH' and 'OPT_SHP' share the same storage */
+    struct
+    {
+        bool is_valid;
+        uint8_t value;
+    } que_sch_shp_mode;      /* NOTE: 'OPT_QUE_MODE', 'OPT_SCH_MODE' and 'OPT_SHP_MODE' share the same storage */
+    
+    struct
+    {
+        bool is_valid;
+        uint32_t value;
+    } thmin;
+    struct
+    {
+        bool is_valid;
+        uint32_t value;
+    } thmax;
+    struct
+    {
+        bool is_valid;
+        uint8_t arr[ZPROBS_LN];
+    } zprob;
+    
+    struct
+    {
+        bool is_valid;
+        uint8_t value;
+    } sch_algo;
+    struct sch_in_tt
+    {
+        bool is_valid;
+        uint8_t  arr_src[SCH_INS_LN];
+        uint32_t arr_w[SCH_INS_LN];
+    } sch_in;
+    
+    struct
+    {
+        bool is_valid;
+        uint8_t value;
+    } shp_pos;
+    struct
+    {
+        bool is_valid;
+        uint32_t value;
+    } isl;
+    struct
+    {
+        bool is_valid;
+        int32_t value;
+    } crmin;
+    struct
+    {
+        bool is_valid;
+        int32_t value;
+    } crmax;
+    
+} cli_cmdargs_t;
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+extern void cli_print_error(int rtncode, const char* p_txt_err, ...);
+
+/* ========================================================================= */
+
+#endif
+
diff --git a/sw/libfci_cli/src/libfci_cli_def_cmds.c b/sw/libfci_cli/src/libfci_cli_def_cmds.c
new file mode 100644
index 0000000..f223d7c
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_def_cmds.c
@@ -0,0 +1,1029 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#include <assert.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <string.h>
+#include "libfci_cli_common.h"
+#include "libfci_cli_def_cmds.h"
+
+/* ==== TESTMODE vars ====================================================== */
+
+#if !defined(NDEBUG)
+cli_cmdargs_t TEST_cmdargs;
+#endif
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+/* declarations of extern functions */
+#ifdef CMD_01_ENUM_NAME
+   int CMD_01_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_02_ENUM_NAME
+   int CMD_02_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_03_ENUM_NAME
+   int CMD_03_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_04_ENUM_NAME
+   int CMD_04_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_05_ENUM_NAME
+   int CMD_05_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_06_ENUM_NAME
+   int CMD_06_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_07_ENUM_NAME
+   int CMD_07_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_08_ENUM_NAME
+   int CMD_08_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_09_ENUM_NAME
+   int CMD_09_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+
+#ifdef CMD_10_ENUM_NAME
+   int CMD_10_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_11_ENUM_NAME
+   int CMD_11_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_12_ENUM_NAME
+   int CMD_12_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_13_ENUM_NAME
+   int CMD_13_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_14_ENUM_NAME
+   int CMD_14_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_15_ENUM_NAME
+   int CMD_15_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_16_ENUM_NAME
+   int CMD_16_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_17_ENUM_NAME
+   int CMD_17_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_18_ENUM_NAME
+   int CMD_18_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_19_ENUM_NAME
+   int CMD_19_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+
+#ifdef CMD_20_ENUM_NAME
+   int CMD_20_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_21_ENUM_NAME
+   int CMD_21_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_22_ENUM_NAME
+   int CMD_22_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_23_ENUM_NAME
+   int CMD_23_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_24_ENUM_NAME
+   int CMD_24_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_25_ENUM_NAME
+   int CMD_25_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_26_ENUM_NAME
+   int CMD_26_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_27_ENUM_NAME
+   int CMD_27_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_28_ENUM_NAME
+   int CMD_28_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_29_ENUM_NAME
+   int CMD_29_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+
+#ifdef CMD_30_ENUM_NAME
+   int CMD_30_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_31_ENUM_NAME
+   int CMD_31_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_32_ENUM_NAME
+   int CMD_32_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_33_ENUM_NAME
+   int CMD_33_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_34_ENUM_NAME
+   int CMD_34_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_35_ENUM_NAME
+   int CMD_35_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_36_ENUM_NAME
+   int CMD_36_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_37_ENUM_NAME
+   int CMD_37_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_38_ENUM_NAME
+   int CMD_38_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_39_ENUM_NAME
+   int CMD_39_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+
+#ifdef CMD_40_ENUM_NAME
+   int CMD_40_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_41_ENUM_NAME
+   int CMD_41_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_42_ENUM_NAME
+   int CMD_42_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_43_ENUM_NAME
+   int CMD_43_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_44_ENUM_NAME
+   int CMD_44_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_45_ENUM_NAME
+   int CMD_45_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_46_ENUM_NAME
+   int CMD_46_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_47_ENUM_NAME
+   int CMD_47_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_48_ENUM_NAME
+   int CMD_48_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_49_ENUM_NAME
+   int CMD_49_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+
+#ifdef CMD_50_ENUM_NAME
+   int CMD_50_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_51_ENUM_NAME
+   int CMD_51_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_52_ENUM_NAME
+   int CMD_52_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_53_ENUM_NAME
+   int CMD_53_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_54_ENUM_NAME
+   int CMD_54_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_55_ENUM_NAME
+   int CMD_55_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_56_ENUM_NAME
+   int CMD_56_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_57_ENUM_NAME
+   int CMD_57_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_58_ENUM_NAME
+   int CMD_58_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_59_ENUM_NAME
+   int CMD_59_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+
+#ifdef CMD_60_ENUM_NAME
+   int CMD_60_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_61_ENUM_NAME
+   int CMD_61_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_62_ENUM_NAME
+   int CMD_62_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_63_ENUM_NAME
+   int CMD_63_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_64_ENUM_NAME
+   int CMD_64_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_65_ENUM_NAME
+   int CMD_65_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_66_ENUM_NAME
+   int CMD_66_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_67_ENUM_NAME
+   int CMD_67_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_68_ENUM_NAME
+   int CMD_68_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_69_ENUM_NAME
+   int CMD_69_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+
+#ifdef CMD_70_ENUM_NAME
+   int CMD_70_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_71_ENUM_NAME
+   int CMD_71_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_72_ENUM_NAME
+   int CMD_72_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_73_ENUM_NAME
+   int CMD_73_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_74_ENUM_NAME
+   int CMD_74_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_75_ENUM_NAME
+   int CMD_75_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_76_ENUM_NAME
+   int CMD_76_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_77_ENUM_NAME
+   int CMD_77_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_78_ENUM_NAME
+   int CMD_78_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_79_ENUM_NAME
+   int CMD_79_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+
+#ifdef CMD_80_ENUM_NAME
+   int CMD_80_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_81_ENUM_NAME
+   int CMD_81_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_82_ENUM_NAME
+   int CMD_82_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_83_ENUM_NAME
+   int CMD_83_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_84_ENUM_NAME
+   int CMD_84_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_85_ENUM_NAME
+   int CMD_85_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_86_ENUM_NAME
+   int CMD_86_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_87_ENUM_NAME
+   int CMD_87_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_88_ENUM_NAME
+   int CMD_88_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_89_ENUM_NAME
+   int CMD_89_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+
+#ifdef CMD_90_ENUM_NAME
+   int CMD_90_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_91_ENUM_NAME
+   int CMD_91_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_92_ENUM_NAME
+   int CMD_92_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_93_ENUM_NAME
+   int CMD_93_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_94_ENUM_NAME
+   int CMD_94_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_95_ENUM_NAME
+   int CMD_95_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_96_ENUM_NAME
+   int CMD_96_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_97_ENUM_NAME
+   int CMD_97_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_98_ENUM_NAME
+   int CMD_98_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+#ifdef CMD_99_ENUM_NAME
+   int CMD_99_CMDEXEC (const cli_cmdargs_t* p_cmdargs);
+#endif
+
+
+static int cmdexec_dummy(const cli_cmdargs_t* p_cmdargs);
+
+/* indexed by 'cmd_t' */
+typedef int (*cb_cmdexec_t)(const cli_cmdargs_t* p_cmdargs);
+static const cb_cmdexec_t cmdexecs[CMD_LN] = 
+{
+    cmdexec_dummy,  /* CMD_00_NO_COMMAND_CMD */
+    
+#ifdef CMD_01_ENUM_NAME
+       CMD_01_CMDEXEC,
+#endif
+#ifdef CMD_02_ENUM_NAME
+       CMD_02_CMDEXEC,
+#endif
+#ifdef CMD_03_ENUM_NAME
+       CMD_03_CMDEXEC,
+#endif
+#ifdef CMD_04_ENUM_NAME
+       CMD_04_CMDEXEC,
+#endif
+#ifdef CMD_05_ENUM_NAME
+       CMD_05_CMDEXEC,
+#endif
+#ifdef CMD_06_ENUM_NAME
+       CMD_06_CMDEXEC,
+#endif
+#ifdef CMD_07_ENUM_NAME
+       CMD_07_CMDEXEC,
+#endif
+#ifdef CMD_08_ENUM_NAME
+       CMD_08_CMDEXEC,
+#endif
+#ifdef CMD_09_ENUM_NAME
+       CMD_09_CMDEXEC,
+#endif
+
+#ifdef CMD_10_ENUM_NAME
+       CMD_10_CMDEXEC,
+#endif
+#ifdef CMD_11_ENUM_NAME
+       CMD_11_CMDEXEC,
+#endif
+#ifdef CMD_12_ENUM_NAME
+       CMD_12_CMDEXEC,
+#endif
+#ifdef CMD_13_ENUM_NAME
+       CMD_13_CMDEXEC,
+#endif
+#ifdef CMD_14_ENUM_NAME
+       CMD_14_CMDEXEC,
+#endif
+#ifdef CMD_15_ENUM_NAME
+       CMD_15_CMDEXEC,
+#endif
+#ifdef CMD_16_ENUM_NAME
+       CMD_16_CMDEXEC,
+#endif
+#ifdef CMD_17_ENUM_NAME
+       CMD_17_CMDEXEC,
+#endif
+#ifdef CMD_18_ENUM_NAME
+       CMD_18_CMDEXEC,
+#endif
+#ifdef CMD_19_ENUM_NAME
+       CMD_19_CMDEXEC,
+#endif
+
+#ifdef CMD_20_ENUM_NAME
+       CMD_20_CMDEXEC,
+#endif
+#ifdef CMD_21_ENUM_NAME
+       CMD_21_CMDEXEC,
+#endif
+#ifdef CMD_22_ENUM_NAME
+       CMD_22_CMDEXEC,
+#endif
+#ifdef CMD_23_ENUM_NAME
+       CMD_23_CMDEXEC,
+#endif
+#ifdef CMD_24_ENUM_NAME
+       CMD_24_CMDEXEC,
+#endif
+#ifdef CMD_25_ENUM_NAME
+       CMD_25_CMDEXEC,
+#endif
+#ifdef CMD_26_ENUM_NAME
+       CMD_26_CMDEXEC,
+#endif
+#ifdef CMD_27_ENUM_NAME
+       CMD_27_CMDEXEC,
+#endif
+#ifdef CMD_28_ENUM_NAME
+       CMD_28_CMDEXEC,
+#endif
+#ifdef CMD_29_ENUM_NAME
+       CMD_29_CMDEXEC,
+#endif
+
+#ifdef CMD_30_ENUM_NAME
+       CMD_30_CMDEXEC,
+#endif
+#ifdef CMD_31_ENUM_NAME
+       CMD_31_CMDEXEC,
+#endif
+#ifdef CMD_32_ENUM_NAME
+       CMD_32_CMDEXEC,
+#endif
+#ifdef CMD_33_ENUM_NAME
+       CMD_33_CMDEXEC,
+#endif
+#ifdef CMD_34_ENUM_NAME
+       CMD_34_CMDEXEC,
+#endif
+#ifdef CMD_35_ENUM_NAME
+       CMD_35_CMDEXEC,
+#endif
+#ifdef CMD_36_ENUM_NAME
+       CMD_36_CMDEXEC,
+#endif
+#ifdef CMD_37_ENUM_NAME
+       CMD_37_CMDEXEC,
+#endif
+#ifdef CMD_38_ENUM_NAME
+       CMD_38_CMDEXEC,
+#endif
+#ifdef CMD_39_ENUM_NAME
+       CMD_39_CMDEXEC,
+#endif
+
+#ifdef CMD_40_ENUM_NAME
+       CMD_40_CMDEXEC,
+#endif
+#ifdef CMD_41_ENUM_NAME
+       CMD_41_CMDEXEC,
+#endif
+#ifdef CMD_42_ENUM_NAME
+       CMD_42_CMDEXEC,
+#endif
+#ifdef CMD_43_ENUM_NAME
+       CMD_43_CMDEXEC,
+#endif
+#ifdef CMD_44_ENUM_NAME
+       CMD_44_CMDEXEC,
+#endif
+#ifdef CMD_45_ENUM_NAME
+       CMD_45_CMDEXEC,
+#endif
+#ifdef CMD_46_ENUM_NAME
+       CMD_46_CMDEXEC,
+#endif
+#ifdef CMD_47_ENUM_NAME
+       CMD_47_CMDEXEC,
+#endif
+#ifdef CMD_48_ENUM_NAME
+       CMD_48_CMDEXEC,
+#endif
+#ifdef CMD_49_ENUM_NAME
+       CMD_49_CMDEXEC,
+#endif
+
+#ifdef CMD_50_ENUM_NAME
+       CMD_50_CMDEXEC,
+#endif
+#ifdef CMD_51_ENUM_NAME
+       CMD_51_CMDEXEC,
+#endif
+#ifdef CMD_52_ENUM_NAME
+       CMD_52_CMDEXEC,
+#endif
+#ifdef CMD_53_ENUM_NAME
+       CMD_53_CMDEXEC,
+#endif
+#ifdef CMD_54_ENUM_NAME
+       CMD_54_CMDEXEC,
+#endif
+#ifdef CMD_55_ENUM_NAME
+       CMD_55_CMDEXEC,
+#endif
+#ifdef CMD_56_ENUM_NAME
+       CMD_56_CMDEXEC,
+#endif
+#ifdef CMD_57_ENUM_NAME
+       CMD_57_CMDEXEC,
+#endif
+#ifdef CMD_58_ENUM_NAME
+       CMD_58_CMDEXEC,
+#endif
+#ifdef CMD_59_ENUM_NAME
+       CMD_59_CMDEXEC,
+#endif
+
+#ifdef CMD_60_ENUM_NAME
+       CMD_60_CMDEXEC,
+#endif
+#ifdef CMD_61_ENUM_NAME
+       CMD_61_CMDEXEC,
+#endif
+#ifdef CMD_62_ENUM_NAME
+       CMD_62_CMDEXEC,
+#endif
+#ifdef CMD_63_ENUM_NAME
+       CMD_63_CMDEXEC,
+#endif
+#ifdef CMD_64_ENUM_NAME
+       CMD_64_CMDEXEC,
+#endif
+#ifdef CMD_65_ENUM_NAME
+       CMD_65_CMDEXEC,
+#endif
+#ifdef CMD_66_ENUM_NAME
+       CMD_66_CMDEXEC,
+#endif
+#ifdef CMD_67_ENUM_NAME
+       CMD_67_CMDEXEC,
+#endif
+#ifdef CMD_68_ENUM_NAME
+       CMD_68_CMDEXEC,
+#endif
+#ifdef CMD_69_ENUM_NAME
+       CMD_69_CMDEXEC,
+#endif
+
+#ifdef CMD_70_ENUM_NAME
+       CMD_70_CMDEXEC,
+#endif
+#ifdef CMD_71_ENUM_NAME
+       CMD_71_CMDEXEC,
+#endif
+#ifdef CMD_72_ENUM_NAME
+       CMD_72_CMDEXEC,
+#endif
+#ifdef CMD_73_ENUM_NAME
+       CMD_73_CMDEXEC,
+#endif
+#ifdef CMD_74_ENUM_NAME
+       CMD_74_CMDEXEC,
+#endif
+#ifdef CMD_75_ENUM_NAME
+       CMD_75_CMDEXEC,
+#endif
+#ifdef CMD_76_ENUM_NAME
+       CMD_76_CMDEXEC,
+#endif
+#ifdef CMD_77_ENUM_NAME
+       CMD_77_CMDEXEC,
+#endif
+#ifdef CMD_78_ENUM_NAME
+       CMD_78_CMDEXEC,
+#endif
+#ifdef CMD_79_ENUM_NAME
+       CMD_79_CMDEXEC,
+#endif
+
+#ifdef CMD_80_ENUM_NAME
+       CMD_80_CMDEXEC,
+#endif
+#ifdef CMD_81_ENUM_NAME
+       CMD_81_CMDEXEC,
+#endif
+#ifdef CMD_82_ENUM_NAME
+       CMD_82_CMDEXEC,
+#endif
+#ifdef CMD_83_ENUM_NAME
+       CMD_83_CMDEXEC,
+#endif
+#ifdef CMD_84_ENUM_NAME
+       CMD_84_CMDEXEC,
+#endif
+#ifdef CMD_85_ENUM_NAME
+       CMD_85_CMDEXEC,
+#endif
+#ifdef CMD_86_ENUM_NAME
+       CMD_86_CMDEXEC,
+#endif
+#ifdef CMD_87_ENUM_NAME
+       CMD_87_CMDEXEC,
+#endif
+#ifdef CMD_88_ENUM_NAME
+       CMD_88_CMDEXEC,
+#endif
+#ifdef CMD_89_ENUM_NAME
+       CMD_89_CMDEXEC,
+#endif
+
+#ifdef CMD_90_ENUM_NAME
+       CMD_90_CMDEXEC,
+#endif
+#ifdef CMD_91_ENUM_NAME
+       CMD_91_CMDEXEC,
+#endif
+#ifdef CMD_92_ENUM_NAME
+       CMD_92_CMDEXEC,
+#endif
+#ifdef CMD_93_ENUM_NAME
+       CMD_93_CMDEXEC,
+#endif
+#ifdef CMD_94_ENUM_NAME
+       CMD_94_CMDEXEC,
+#endif
+#ifdef CMD_95_ENUM_NAME
+       CMD_95_CMDEXEC,
+#endif
+#ifdef CMD_96_ENUM_NAME
+       CMD_96_CMDEXEC,
+#endif
+#ifdef CMD_97_ENUM_NAME
+       CMD_97_CMDEXEC,
+#endif
+#ifdef CMD_98_ENUM_NAME
+       CMD_98_CMDEXEC,
+#endif
+#ifdef CMD_99_ENUM_NAME
+       CMD_99_CMDEXEC,
+#endif
+};
+
+/* indexed by 'cmd_t' */
+static const char *const txt_cmdnames[CMD_LN] =
+{
+    "",  /*  CMD_00_NO_COMMAND  */
+    
+#ifdef CMD_01_ENUM_NAME
+       CMD_01_CLI_TXT,
+#endif
+#ifdef CMD_02_ENUM_NAME
+       CMD_02_CLI_TXT,
+#endif
+#ifdef CMD_03_ENUM_NAME
+       CMD_03_CLI_TXT,
+#endif
+#ifdef CMD_04_ENUM_NAME
+       CMD_04_CLI_TXT,
+#endif
+#ifdef CMD_05_ENUM_NAME
+       CMD_05_CLI_TXT,
+#endif
+#ifdef CMD_06_ENUM_NAME
+       CMD_06_CLI_TXT,
+#endif
+#ifdef CMD_07_ENUM_NAME
+       CMD_07_CLI_TXT,
+#endif
+#ifdef CMD_08_ENUM_NAME
+       CMD_08_CLI_TXT,
+#endif
+#ifdef CMD_09_ENUM_NAME
+       CMD_09_CLI_TXT,
+#endif
+
+#ifdef CMD_10_ENUM_NAME
+       CMD_10_CLI_TXT,
+#endif
+#ifdef CMD_11_ENUM_NAME
+       CMD_11_CLI_TXT,
+#endif
+#ifdef CMD_12_ENUM_NAME
+       CMD_12_CLI_TXT,
+#endif
+#ifdef CMD_13_ENUM_NAME
+       CMD_13_CLI_TXT,
+#endif
+#ifdef CMD_14_ENUM_NAME
+       CMD_14_CLI_TXT,
+#endif
+#ifdef CMD_15_ENUM_NAME
+       CMD_15_CLI_TXT,
+#endif
+#ifdef CMD_16_ENUM_NAME
+       CMD_16_CLI_TXT,
+#endif
+#ifdef CMD_17_ENUM_NAME
+       CMD_17_CLI_TXT,
+#endif
+#ifdef CMD_18_ENUM_NAME
+       CMD_18_CLI_TXT,
+#endif
+#ifdef CMD_19_ENUM_NAME
+       CMD_19_CLI_TXT,
+#endif
+
+#ifdef CMD_20_ENUM_NAME
+       CMD_20_CLI_TXT,
+#endif
+#ifdef CMD_21_ENUM_NAME
+       CMD_21_CLI_TXT,
+#endif
+#ifdef CMD_22_ENUM_NAME
+       CMD_22_CLI_TXT,
+#endif
+#ifdef CMD_23_ENUM_NAME
+       CMD_23_CLI_TXT,
+#endif
+#ifdef CMD_24_ENUM_NAME
+       CMD_24_CLI_TXT,
+#endif
+#ifdef CMD_25_ENUM_NAME
+       CMD_25_CLI_TXT,
+#endif
+#ifdef CMD_26_ENUM_NAME
+       CMD_26_CLI_TXT,
+#endif
+#ifdef CMD_27_ENUM_NAME
+       CMD_27_CLI_TXT,
+#endif
+#ifdef CMD_28_ENUM_NAME
+       CMD_28_CLI_TXT,
+#endif
+#ifdef CMD_29_ENUM_NAME
+       CMD_29_CLI_TXT,
+#endif
+
+#ifdef CMD_30_ENUM_NAME
+       CMD_30_CLI_TXT,
+#endif
+#ifdef CMD_31_ENUM_NAME
+       CMD_31_CLI_TXT,
+#endif
+#ifdef CMD_32_ENUM_NAME
+       CMD_32_CLI_TXT,
+#endif
+#ifdef CMD_33_ENUM_NAME
+       CMD_33_CLI_TXT,
+#endif
+#ifdef CMD_34_ENUM_NAME
+       CMD_34_CLI_TXT,
+#endif
+#ifdef CMD_35_ENUM_NAME
+       CMD_35_CLI_TXT,
+#endif
+#ifdef CMD_36_ENUM_NAME
+       CMD_36_CLI_TXT,
+#endif
+#ifdef CMD_37_ENUM_NAME
+       CMD_37_CLI_TXT,
+#endif
+#ifdef CMD_38_ENUM_NAME
+       CMD_38_CLI_TXT,
+#endif
+#ifdef CMD_39_ENUM_NAME
+       CMD_39_CLI_TXT,
+#endif
+
+#ifdef CMD_40_ENUM_NAME
+       CMD_40_CLI_TXT,
+#endif
+#ifdef CMD_41_ENUM_NAME
+       CMD_41_CLI_TXT,
+#endif
+#ifdef CMD_42_ENUM_NAME
+       CMD_42_CLI_TXT,
+#endif
+#ifdef CMD_43_ENUM_NAME
+       CMD_43_CLI_TXT,
+#endif
+#ifdef CMD_44_ENUM_NAME
+       CMD_44_CLI_TXT,
+#endif
+#ifdef CMD_45_ENUM_NAME
+       CMD_45_CLI_TXT,
+#endif
+#ifdef CMD_46_ENUM_NAME
+       CMD_46_CLI_TXT,
+#endif
+#ifdef CMD_47_ENUM_NAME
+       CMD_47_CLI_TXT,
+#endif
+#ifdef CMD_48_ENUM_NAME
+       CMD_48_CLI_TXT,
+#endif
+#ifdef CMD_49_ENUM_NAME
+       CMD_49_CLI_TXT,
+#endif
+
+#ifdef CMD_50_ENUM_NAME
+       CMD_50_CLI_TXT,
+#endif
+#ifdef CMD_51_ENUM_NAME
+       CMD_51_CLI_TXT,
+#endif
+#ifdef CMD_52_ENUM_NAME
+       CMD_52_CLI_TXT,
+#endif
+#ifdef CMD_53_ENUM_NAME
+       CMD_53_CLI_TXT,
+#endif
+#ifdef CMD_54_ENUM_NAME
+       CMD_54_CLI_TXT,
+#endif
+#ifdef CMD_55_ENUM_NAME
+       CMD_55_CLI_TXT,
+#endif
+#ifdef CMD_56_ENUM_NAME
+       CMD_56_CLI_TXT,
+#endif
+#ifdef CMD_57_ENUM_NAME
+       CMD_57_CLI_TXT,
+#endif
+#ifdef CMD_58_ENUM_NAME
+       CMD_58_CLI_TXT,
+#endif
+#ifdef CMD_59_ENUM_NAME
+       CMD_59_CLI_TXT,
+#endif
+
+#ifdef CMD_60_ENUM_NAME
+       CMD_60_CLI_TXT,
+#endif
+#ifdef CMD_61_ENUM_NAME
+       CMD_61_CLI_TXT,
+#endif
+#ifdef CMD_62_ENUM_NAME
+       CMD_62_CLI_TXT,
+#endif
+#ifdef CMD_63_ENUM_NAME
+       CMD_63_CLI_TXT,
+#endif
+#ifdef CMD_64_ENUM_NAME
+       CMD_64_CLI_TXT,
+#endif
+#ifdef CMD_65_ENUM_NAME
+       CMD_65_CLI_TXT,
+#endif
+#ifdef CMD_66_ENUM_NAME
+       CMD_66_CLI_TXT,
+#endif
+#ifdef CMD_67_ENUM_NAME
+       CMD_67_CLI_TXT,
+#endif
+#ifdef CMD_68_ENUM_NAME
+       CMD_68_CLI_TXT,
+#endif
+#ifdef CMD_69_ENUM_NAME
+       CMD_69_CLI_TXT,
+#endif
+
+#ifdef CMD_70_ENUM_NAME
+       CMD_70_CLI_TXT,
+#endif
+#ifdef CMD_71_ENUM_NAME
+       CMD_71_CLI_TXT,
+#endif
+#ifdef CMD_72_ENUM_NAME
+       CMD_72_CLI_TXT,
+#endif
+#ifdef CMD_73_ENUM_NAME
+       CMD_73_CLI_TXT,
+#endif
+#ifdef CMD_74_ENUM_NAME
+       CMD_74_CLI_TXT,
+#endif
+#ifdef CMD_75_ENUM_NAME
+       CMD_75_CLI_TXT,
+#endif
+#ifdef CMD_76_ENUM_NAME
+       CMD_76_CLI_TXT,
+#endif
+#ifdef CMD_77_ENUM_NAME
+       CMD_77_CLI_TXT,
+#endif
+#ifdef CMD_78_ENUM_NAME
+       CMD_78_CLI_TXT,
+#endif
+#ifdef CMD_79_ENUM_NAME
+       CMD_79_CLI_TXT,
+#endif
+
+#ifdef CMD_80_ENUM_NAME
+       CMD_80_CLI_TXT,
+#endif
+#ifdef CMD_81_ENUM_NAME
+       CMD_81_CLI_TXT,
+#endif
+#ifdef CMD_82_ENUM_NAME
+       CMD_82_CLI_TXT,
+#endif
+#ifdef CMD_83_ENUM_NAME
+       CMD_83_CLI_TXT,
+#endif
+#ifdef CMD_84_ENUM_NAME
+       CMD_84_CLI_TXT,
+#endif
+#ifdef CMD_85_ENUM_NAME
+       CMD_85_CLI_TXT,
+#endif
+#ifdef CMD_86_ENUM_NAME
+       CMD_86_CLI_TXT,
+#endif
+#ifdef CMD_87_ENUM_NAME
+       CMD_87_CLI_TXT,
+#endif
+#ifdef CMD_88_ENUM_NAME
+       CMD_88_CLI_TXT,
+#endif
+#ifdef CMD_89_ENUM_NAME
+       CMD_89_CLI_TXT,
+#endif
+
+#ifdef CMD_90_ENUM_NAME
+       CMD_90_CLI_TXT,
+#endif
+#ifdef CMD_91_ENUM_NAME
+       CMD_91_CLI_TXT,
+#endif
+#ifdef CMD_92_ENUM_NAME
+       CMD_92_CLI_TXT,
+#endif
+#ifdef CMD_93_ENUM_NAME
+       CMD_93_CLI_TXT,
+#endif
+#ifdef CMD_94_ENUM_NAME
+       CMD_94_CLI_TXT,
+#endif
+#ifdef CMD_95_ENUM_NAME
+       CMD_95_CLI_TXT,
+#endif
+#ifdef CMD_96_ENUM_NAME
+       CMD_96_CLI_TXT,
+#endif
+#ifdef CMD_97_ENUM_NAME
+       CMD_97_CLI_TXT,
+#endif
+#ifdef CMD_98_ENUM_NAME
+       CMD_98_CLI_TXT,
+#endif
+#ifdef CMD_99_ENUM_NAME
+       CMD_99_CLI_TXT,
+#endif
+};
+
+/* ==== PRIVATE FUNCTIONS ================================================== */
+
+inline static int cmdexec_dummy(const cli_cmdargs_t* p_cmdargs)
+{
+    #if !defined(NDEBUG)
+    TEST_cmdargs = *p_cmdargs;
+    #endif
+    return ((p_cmdargs) ? (CLI_OK) : (CLI_OK));  /* ternary used just to suppress gcc warning */
+}
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+inline bool cli_cmd_is_valid(uint16_t value)
+{
+    return (value < CMD_LN);
+}
+
+inline bool cli_cmd_is_not_valid(uint16_t value)
+{
+    return !(cli_cmd_is_valid(value));
+}
+
+int cli_cmd_execute(cli_cmd_t cmd, const cli_cmdargs_t* p_cmdargs)
+{
+    return ((cli_cmd_is_not_valid(cmd)) ? (CLI_ERR_INVCMD) : (cmdexecs[cmd](p_cmdargs)));
+}
+
+int cli_cmd_txt2cmd(cli_cmd_t* p_rtn_cmd, const char* p_txt)
+{
+    assert(NULL != p_rtn_cmd);
+    assert(NULL != p_txt);
+    
+    
+    int rtn = CLI_ERR;
+    uint16_t i = 0u;  /* loop intentionally skips element [0] (it is NO_COMMAND) */
+    while ((CMD_LN > (++i)) && (0 != strcmp(txt_cmdnames[i], p_txt))) { /* empty */ };
+    if (CMD_LN <= i)
+    {
+        rtn = CLI_ERR_INVCMD;
+    }
+    else
+    {
+        *p_rtn_cmd = (cli_cmd_t)(i);  /* WARNING: cast to enum type (valid value is assumed) */
+        rtn = CLI_OK;
+    }
+    
+    return (rtn);
+}
+
+const char* cli_cmd_cmd2txt(cli_cmd_t cmd)
+{
+    return ((cli_cmd_is_not_valid(cmd)) ? ("__INVALID_ITEM__") : (txt_cmdnames[cmd]));
+}
+
+/* ==== TESTMODE constants ================================================= */
+
+#if !defined(NDEBUG)
+const uint16_t TEST_defcmds__cmdnames_ln = (sizeof(txt_cmdnames) / sizeof(char*));
+#endif
+
+/* ========================================================================= */
diff --git a/sw/libfci_cli/src/libfci_cli_def_cmds.h b/sw/libfci_cli/src/libfci_cli_def_cmds.h
new file mode 100644
index 0000000..abc485a
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_def_cmds.h
@@ -0,0 +1,647 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef CLI_DEF_CMDS_H_
+#define CLI_DEF_CMDS_H_
+
+#include <stdint.h>
+#include <stdbool.h>
+
+/* ==== DEFINITIONS ======================================================== */
+/* 
+    For each cli command, fill the necessary info here.
+    Do NOT include any *.h files. It should not be needed.
+    
+    CMD_00_NO_COMMAND is hardcoded.
+    
+    Search for keyword 'CMD_LAST' to get to the bottom of the cli command definition list.
+    
+    
+    Description of a cli cmd definition (xx is a number from 01 to 99)
+    ------------------------------------------------------------------
+    CMD_xx_ENUM_NAME    CMD_MY_TEST        This enum key is automatically created and associated
+                                           with the given cli command.
+                                           
+    CMD_xx_CLI_TXT      "my-test"          Command-line text which represents the given cli command.
+                                           
+    CMD_xx_CMDEXEC      my_test            Name of a global function which is called when this command is invoked.
+                                           The global function itself can be defined in any source file.
+                                           The global function must conform to the prototype:
+                                           int my_test(const cli_cmdargs_t* p_cmdargs);
+                                           
+    CMD_xx_HELP         txt_help_mytest    Name of a text array which represents a help text for this cli command.
+                                           The array needs to be defined in the source file 'libfci_cli_def_help.c'.
+*/
+
+#define CMD_01_ENUM_NAME    CMD_PHYIF_PRINT
+#define CMD_01_CLI_TXT      "phyif-print"
+#define CMD_01_CMDEXEC      cli_cmd_phyif_print
+#define CMD_01_HELP         txt_help_phyif_print
+
+#define CMD_02_ENUM_NAME    CMD_PHYIF_UPDATE
+#define CMD_02_CLI_TXT      "phyif-update"
+#define CMD_02_CMDEXEC      cli_cmd_phyif_update
+#define CMD_02_HELP         txt_help_phyif_update
+
+/*      CMD_03_ENUM_NAME    reserved for future PHYIF cmds */
+/*      CMD_04_ENUM_NAME    reserved for future PHYIF cmds */
+/*      CMD_05_ENUM_NAME    reserved for future PHYIF cmds */
+/*      CMD_06_ENUM_NAME    reserved for future PHYIF cmds */
+/*      CMD_07_ENUM_NAME    reserved for future PHYIF cmds */
+/*      CMD_08_ENUM_NAME    reserved for future PHYIF cmds */
+/*      CMD_09_ENUM_NAME    reserved for future PHYIF cmds */
+
+#define CMD_10_ENUM_NAME    CMD_LOGIF_PRINT
+#define CMD_10_CLI_TXT      "logif-print"
+#define CMD_10_CMDEXEC      cli_cmd_logif_print
+#define CMD_10_HELP         txt_help_logif_print
+
+#define CMD_11_ENUM_NAME    CMD_LOGIF_UPDATE
+#define CMD_11_CLI_TXT      "logif-update"
+#define CMD_11_CMDEXEC      cli_cmd_logif_update
+#define CMD_11_HELP         txt_help_logif_update
+
+#define CMD_12_ENUM_NAME    CMD_LOGIF_ADD
+#define CMD_12_CLI_TXT      "logif-add"
+#define CMD_12_CMDEXEC      cli_cmd_logif_add
+#define CMD_12_HELP         txt_help_logif_add
+
+#define CMD_13_ENUM_NAME    CMD_LOGIF_DEL
+#define CMD_13_CLI_TXT      "logif-del"
+#define CMD_13_CMDEXEC      cli_cmd_logif_del
+#define CMD_13_HELP         txt_help_logif_del
+
+/*      CMD_14_ENUM_NAME    reserved for future LOGIF cmds */
+/*      CMD_15_ENUM_NAME    reserved for future LOGIF cmds */
+/*      CMD_16_ENUM_NAME    reserved for future LOGIF cmds */
+/*      CMD_17_ENUM_NAME    reserved for future LOGIF cmds */
+/*      CMD_18_ENUM_NAME    reserved for future LOGIF cmds */
+/*      CMD_19_ENUM_NAME    reserved for future LOGIF cmds */
+
+#define CMD_20_ENUM_NAME    CMD_BD_PRINT
+#define CMD_20_CLI_TXT      "bd-print"
+#define CMD_20_CMDEXEC      cli_cmd_bd_print
+#define CMD_20_HELP         txt_help_bd_print
+
+#define CMD_21_ENUM_NAME    CMD_BD_UPDATE
+#define CMD_21_CLI_TXT      "bd-update"
+#define CMD_21_CMDEXEC      cli_cmd_bd_update
+#define CMD_21_HELP         txt_help_bd_update
+
+#define CMD_22_ENUM_NAME    CMD_BD_ADD
+#define CMD_22_CLI_TXT      "bd-add"
+#define CMD_22_CMDEXEC      cli_cmd_bd_add
+#define CMD_22_HELP         txt_help_bd_add
+
+#define CMD_23_ENUM_NAME    CMD_BD_DEL
+#define CMD_23_CLI_TXT      "bd-del"
+#define CMD_23_CMDEXEC      cli_cmd_bd_del
+#define CMD_23_HELP         txt_help_bd_del
+
+#define CMD_24_ENUM_NAME    CMD_BD_INSIF
+#define CMD_24_CLI_TXT      "bd-insif"
+#define CMD_24_CMDEXEC      cli_cmd_bd_insif
+#define CMD_24_HELP         txt_help_bd_insif
+
+#define CMD_25_ENUM_NAME    CMD_BD_REMIF
+#define CMD_25_CLI_TXT      "bd-remif"
+#define CMD_25_CMDEXEC      cli_cmd_bd_remif
+#define CMD_25_HELP         txt_help_bd_remif
+
+#define CMD_26_ENUM_NAME    CMD_BD_FLUSH
+#define CMD_26_CLI_TXT      "bd-flush"
+#define CMD_26_CMDEXEC      cli_cmd_bd_flush
+#define CMD_26_HELP         txt_help_bd_flush
+
+#define CMD_27_ENUM_NAME    CMD_BD_STENT_PRINT
+#define CMD_27_CLI_TXT      "bd-stent-print"
+#define CMD_27_CMDEXEC      cli_cmd_bd_stent_print
+#define CMD_27_HELP         txt_help_bd_stent_print
+
+#define CMD_28_ENUM_NAME    CMD_BD_STENT_UPDATE
+#define CMD_28_CLI_TXT      "bd-stent-update"
+#define CMD_28_CMDEXEC      cli_cmd_bd_stent_update
+#define CMD_28_HELP         txt_help_bd_stent_update
+
+#define CMD_29_ENUM_NAME    CMD_BD_STENT_ADD
+#define CMD_29_CLI_TXT      "bd-stent-add"
+#define CMD_29_CMDEXEC      cli_cmd_bd_stent_add
+#define CMD_29_HELP         txt_help_bd_stent_add
+
+#define CMD_30_ENUM_NAME    CMD_BD_STENT_DEL
+#define CMD_30_CLI_TXT      "bd-stent-del"
+#define CMD_30_CMDEXEC      cli_cmd_bd_stent_del
+#define CMD_30_HELP         txt_help_bd_stent_del
+
+/*      CMD_31_ENUM_NAME    reserved for future BD cmds */
+/*      CMD_32_ENUM_NAME    reserved for future BD cmds */
+/*      CMD_33_ENUM_NAME    reserved for future BD cmds */
+/*      CMD_34_ENUM_NAME    reserved for future BD cmds */
+/*      CMD_35_ENUM_NAME    reserved for future BD cmds */
+/*      CMD_36_ENUM_NAME    reserved for future BD cmds */
+/*      CMD_37_ENUM_NAME    reserved for future BD cmds */
+/*      CMD_38_ENUM_NAME    reserved for future BD cmds */
+/*      CMD_39_ENUM_NAME    reserved for future BD cmds */
+
+#define CMD_40_ENUM_NAME    CMD_FPTABLE_PRINT
+#define CMD_40_CLI_TXT      "fptable-print"
+#define CMD_40_CMDEXEC      cli_cmd_fptable_print
+#define CMD_40_HELP         txt_help_fptable_print
+
+#define CMD_41_ENUM_NAME    CMD_FPTABLE_ADD
+#define CMD_41_CLI_TXT      "fptable-add"
+#define CMD_41_CMDEXEC      cli_cmd_fptable_add
+#define CMD_41_HELP         txt_help_fptable_add
+
+#define CMD_42_ENUM_NAME    CMD_FPTABLE_DEL
+#define CMD_42_CLI_TXT      "fptable-del"
+#define CMD_42_CMDEXEC      cli_cmd_fptable_del
+#define CMD_42_HELP         txt_help_fptable_del
+
+#define CMD_43_ENUM_NAME    CMD_FPTABLE_INSRULE
+#define CMD_43_CLI_TXT      "fptable-insrule"
+#define CMD_43_CMDEXEC      cli_cmd_fptable_insrule
+#define CMD_43_HELP         txt_help_fptable_insrule
+
+#define CMD_44_ENUM_NAME    CMD_FPTABLE_REMRULE
+#define CMD_44_CLI_TXT      "fptable-remrule"
+#define CMD_44_CMDEXEC      cli_cmd_fptable_remrule
+#define CMD_44_HELP         txt_help_fptable_remrule
+
+#define CMD_45_ENUM_NAME    CMD_FPRULE_PRINT
+#define CMD_45_CLI_TXT      "fprule-print"
+#define CMD_45_CMDEXEC      cli_cmd_fprule_print
+#define CMD_45_HELP         txt_help_fprule_print
+
+#define CMD_46_ENUM_NAME    CMD_FPRULE_ADD
+#define CMD_46_CLI_TXT      "fprule-add"
+#define CMD_46_CMDEXEC      cli_cmd_fprule_add
+#define CMD_46_HELP         txt_help_fprule_add
+
+#define CMD_47_ENUM_NAME    CMD_FPRULE_DEL
+#define CMD_47_CLI_TXT      "fprule-del"
+#define CMD_47_CMDEXEC      cli_cmd_fprule_del
+#define CMD_47_HELP         txt_help_fprule_del
+
+/*      CMD_48_ENUM_NAME    reserved for future FP cmds */
+/*      CMD_49_ENUM_NAME    reserved for future FP cmds */
+
+#define CMD_50_ENUM_NAME    CMD_ROUTE_PRINT
+#define CMD_50_CLI_TXT      "route-print"
+#define CMD_50_CMDEXEC      cli_cmd_route_print
+#define CMD_50_HELP         txt_help_route_print
+
+#define CMD_51_ENUM_NAME    CMD_ROUTE_ADD
+#define CMD_51_CLI_TXT      "route-add"
+#define CMD_51_CMDEXEC      cli_cmd_route_add
+#define CMD_51_HELP         txt_help_route_add
+
+#define CMD_52_ENUM_NAME    CMD_ROUTE_DEL
+#define CMD_52_CLI_TXT      "route-del"
+#define CMD_52_CMDEXEC      cli_cmd_route_del
+#define CMD_52_HELP         txt_help_route_del
+
+#define CMD_53_ENUM_NAME    CMD_CNTK_PRINT
+#define CMD_53_CLI_TXT      "cntk-print"
+#define CMD_53_CMDEXEC      cli_cmd_cntk_print
+#define CMD_53_HELP         txt_help_cntk_print
+
+#define CMD_54_ENUM_NAME    CMD_CNTK_UPDATE
+#define CMD_54_CLI_TXT      "cntk-update"
+#define CMD_54_CMDEXEC      cli_cmd_cntk_update
+#define CMD_54_HELP         txt_help_cntk_update
+
+#define CMD_55_ENUM_NAME    CMD_CNTK_ADD
+#define CMD_55_CLI_TXT      "cntk-add"
+#define CMD_55_CMDEXEC      cli_cmd_cntk_add
+#define CMD_55_HELP         txt_help_cntk_add
+
+#define CMD_56_ENUM_NAME    CMD_CNTK_DEL
+#define CMD_56_CLI_TXT      "cntk-del"
+#define CMD_56_CMDEXEC      cli_cmd_cntk_del
+#define CMD_56_HELP         txt_help_cntk_del
+
+#define CMD_57_ENUM_NAME    CMD_CNTK_TIMEOUT
+#define CMD_57_CLI_TXT      "cntk-timeout"
+#define CMD_57_CMDEXEC      cli_cmd_cntk_timeout
+#define CMD_57_HELP         txt_help_cntk_timeout
+
+#define CMD_58_ENUM_NAME    CMD_ROUTE_AND_CNTK_RESET
+#define CMD_58_CLI_TXT      "route-and-cntk-reset"
+#define CMD_58_CMDEXEC      cli_cmd_route_and_cntk_reset
+#define CMD_58_HELP         txt_help_route_and_cntk_reset
+
+/*      CMD_59_ENUM_NAME    reserved for future RT & CNTK cmds */
+
+#define CMD_60_ENUM_NAME    CMD_SPD_PRINT
+#define CMD_60_CLI_TXT      "spd-print"
+#define CMD_60_CMDEXEC      cli_cmd_spd_print
+#define CMD_60_HELP         txt_help_spd_print
+
+#define CMD_61_ENUM_NAME    CMD_SPD_ADD
+#define CMD_61_CLI_TXT      "spd-add"
+#define CMD_61_CMDEXEC      cli_cmd_spd_add
+#define CMD_61_HELP         txt_help_spd_add
+
+#define CMD_62_ENUM_NAME    CMD_SPD_DEL
+#define CMD_62_CLI_TXT      "spd-del"
+#define CMD_62_CMDEXEC      cli_cmd_spd_del
+#define CMD_62_HELP         txt_help_spd_del
+
+/*      CMD_63_ENUM_NAME    reserved for future SPD cmds */
+/*      CMD_64_ENUM_NAME    reserved for future SPD cmds */
+
+#define CMD_65_ENUM_NAME    CMD_FWFEAT_PRINT
+#define CMD_65_CLI_TXT      "fwfeat-print"
+#define CMD_65_CMDEXEC      cli_cmd_fwfeat_print
+#define CMD_65_HELP         txt_help_fwfeat_print
+
+#define CMD_66_ENUM_NAME    CMD_FWFEAT_SET
+#define CMD_66_CLI_TXT      "fwfeat-set"
+#define CMD_66_CMDEXEC      cli_cmd_fwfeat_set
+#define CMD_66_HELP         txt_help_fwfeat_set
+
+/*      CMD_67_ENUM_NAME    reserved for future FWFEAT cmds */
+/*      CMD_68_ENUM_NAME    reserved for future FWFEAT cmds */
+/*      CMD_69_ENUM_NAME    reserved for future FWFEAT cmds */
+
+#define CMD_70_ENUM_NAME    CMD_QOS_QUE_PRINT
+#define CMD_70_CLI_TXT      "qos-que-print"
+#define CMD_70_CMDEXEC      cli_cmd_qos_que_print
+#define CMD_70_HELP         txt_help_qos_que_print
+
+#define CMD_71_ENUM_NAME    CMD_QOS_QUE_UPDATE
+#define CMD_71_CLI_TXT      "qos-que-update"
+#define CMD_71_CMDEXEC      cli_cmd_qos_que_update
+#define CMD_71_HELP         txt_help_qos_que_update
+
+#define CMD_72_ENUM_NAME    CMD_QOS_SCH_PRINT
+#define CMD_72_CLI_TXT      "qos-sch-print"
+#define CMD_72_CMDEXEC      cli_cmd_qos_sch_print
+#define CMD_72_HELP         txt_help_qos_sch_print
+
+#define CMD_73_ENUM_NAME    CMD_QOS_SCH_UPDATE
+#define CMD_73_CLI_TXT      "qos-sch-update"
+#define CMD_73_CMDEXEC      cli_cmd_qos_sch_update
+#define CMD_73_HELP         txt_help_qos_sch_update
+
+#define CMD_74_ENUM_NAME    CMD_QOS_SHP_PRINT
+#define CMD_74_CLI_TXT      "qos-shp-print"
+#define CMD_74_CMDEXEC      cli_cmd_qos_shp_print
+#define CMD_74_HELP         txt_help_qos_shp_print
+
+#define CMD_75_ENUM_NAME    CMD_QOS_SHP_UPDATE
+#define CMD_75_CLI_TXT      "qos-shp-update"
+#define CMD_75_CMDEXEC      cli_cmd_qos_shp_update
+#define CMD_75_HELP         txt_help_qos_shp_update
+
+/*      CMD_76_ENUM_NAME    reserved for future QOS cmds */
+/*      CMD_77_ENUM_NAME    reserved for future QOS cmds */
+/*      CMD_78_ENUM_NAME    reserved for future QOS cmds */
+/*      CMD_79_ENUM_NAME    reserved for future QOS cmds */
+
+
+
+/* CMD_LAST (keep this at the bottom of the cli command definition list) */
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+/* cmd IDs */
+typedef enum cli_cmd_tt {
+    CMD_00_NO_COMMAND = 0u,
+    
+#ifdef CMD_01_ENUM_NAME
+       CMD_01_ENUM_NAME,
+#endif
+#ifdef CMD_02_ENUM_NAME
+       CMD_02_ENUM_NAME,
+#endif
+#ifdef CMD_03_ENUM_NAME
+       CMD_03_ENUM_NAME,
+#endif
+#ifdef CMD_04_ENUM_NAME
+       CMD_04_ENUM_NAME,
+#endif
+#ifdef CMD_05_ENUM_NAME
+       CMD_05_ENUM_NAME,
+#endif
+#ifdef CMD_06_ENUM_NAME
+       CMD_06_ENUM_NAME,
+#endif
+#ifdef CMD_07_ENUM_NAME
+       CMD_07_ENUM_NAME,
+#endif
+#ifdef CMD_08_ENUM_NAME
+       CMD_08_ENUM_NAME,
+#endif
+#ifdef CMD_09_ENUM_NAME
+       CMD_09_ENUM_NAME,
+#endif
+
+#ifdef CMD_10_ENUM_NAME
+       CMD_10_ENUM_NAME,
+#endif
+#ifdef CMD_11_ENUM_NAME
+       CMD_11_ENUM_NAME,
+#endif
+#ifdef CMD_12_ENUM_NAME
+       CMD_12_ENUM_NAME,
+#endif
+#ifdef CMD_13_ENUM_NAME
+       CMD_13_ENUM_NAME,
+#endif
+#ifdef CMD_14_ENUM_NAME
+       CMD_14_ENUM_NAME,
+#endif
+#ifdef CMD_15_ENUM_NAME
+       CMD_15_ENUM_NAME,
+#endif
+#ifdef CMD_16_ENUM_NAME
+       CMD_16_ENUM_NAME,
+#endif
+#ifdef CMD_17_ENUM_NAME
+       CMD_17_ENUM_NAME,
+#endif
+#ifdef CMD_18_ENUM_NAME
+       CMD_18_ENUM_NAME,
+#endif
+#ifdef CMD_19_ENUM_NAME
+       CMD_19_ENUM_NAME,
+#endif
+
+#ifdef CMD_20_ENUM_NAME
+       CMD_20_ENUM_NAME,
+#endif
+#ifdef CMD_21_ENUM_NAME
+       CMD_21_ENUM_NAME,
+#endif
+#ifdef CMD_22_ENUM_NAME
+       CMD_22_ENUM_NAME,
+#endif
+#ifdef CMD_23_ENUM_NAME
+       CMD_23_ENUM_NAME,
+#endif
+#ifdef CMD_24_ENUM_NAME
+       CMD_24_ENUM_NAME,
+#endif
+#ifdef CMD_25_ENUM_NAME
+       CMD_25_ENUM_NAME,
+#endif
+#ifdef CMD_26_ENUM_NAME
+       CMD_26_ENUM_NAME,
+#endif
+#ifdef CMD_27_ENUM_NAME
+       CMD_27_ENUM_NAME,
+#endif
+#ifdef CMD_28_ENUM_NAME
+       CMD_28_ENUM_NAME,
+#endif
+#ifdef CMD_29_ENUM_NAME
+       CMD_29_ENUM_NAME,
+#endif
+
+#ifdef CMD_30_ENUM_NAME
+       CMD_30_ENUM_NAME,
+#endif
+#ifdef CMD_31_ENUM_NAME
+       CMD_31_ENUM_NAME,
+#endif
+#ifdef CMD_32_ENUM_NAME
+       CMD_32_ENUM_NAME,
+#endif
+#ifdef CMD_33_ENUM_NAME
+       CMD_33_ENUM_NAME,
+#endif
+#ifdef CMD_34_ENUM_NAME
+       CMD_34_ENUM_NAME,
+#endif
+#ifdef CMD_35_ENUM_NAME
+       CMD_35_ENUM_NAME,
+#endif
+#ifdef CMD_36_ENUM_NAME
+       CMD_36_ENUM_NAME,
+#endif
+#ifdef CMD_37_ENUM_NAME
+       CMD_37_ENUM_NAME,
+#endif
+#ifdef CMD_38_ENUM_NAME
+       CMD_38_ENUM_NAME,
+#endif
+#ifdef CMD_39_ENUM_NAME
+       CMD_39_ENUM_NAME,
+#endif
+    
+#ifdef CMD_40_ENUM_NAME
+       CMD_40_ENUM_NAME,
+#endif
+#ifdef CMD_41_ENUM_NAME
+       CMD_41_ENUM_NAME,
+#endif
+#ifdef CMD_42_ENUM_NAME
+       CMD_42_ENUM_NAME,
+#endif
+#ifdef CMD_43_ENUM_NAME
+       CMD_43_ENUM_NAME,
+#endif
+#ifdef CMD_44_ENUM_NAME
+       CMD_44_ENUM_NAME,
+#endif
+#ifdef CMD_45_ENUM_NAME
+       CMD_45_ENUM_NAME,
+#endif
+#ifdef CMD_46_ENUM_NAME
+       CMD_46_ENUM_NAME,
+#endif
+#ifdef CMD_47_ENUM_NAME
+       CMD_47_ENUM_NAME,
+#endif
+#ifdef CMD_48_ENUM_NAME
+       CMD_48_ENUM_NAME,
+#endif
+#ifdef CMD_49_ENUM_NAME
+       CMD_49_ENUM_NAME,
+#endif
+    
+#ifdef CMD_50_ENUM_NAME
+       CMD_50_ENUM_NAME,
+#endif
+#ifdef CMD_51_ENUM_NAME
+       CMD_51_ENUM_NAME,
+#endif
+#ifdef CMD_52_ENUM_NAME
+       CMD_52_ENUM_NAME,
+#endif
+#ifdef CMD_53_ENUM_NAME
+       CMD_53_ENUM_NAME,
+#endif
+#ifdef CMD_54_ENUM_NAME
+       CMD_54_ENUM_NAME,
+#endif
+#ifdef CMD_55_ENUM_NAME
+       CMD_55_ENUM_NAME,
+#endif
+#ifdef CMD_56_ENUM_NAME
+       CMD_56_ENUM_NAME,
+#endif
+#ifdef CMD_57_ENUM_NAME
+       CMD_57_ENUM_NAME,
+#endif
+#ifdef CMD_58_ENUM_NAME
+       CMD_58_ENUM_NAME,
+#endif
+#ifdef CMD_59_ENUM_NAME
+       CMD_59_ENUM_NAME,
+#endif
+
+#ifdef CMD_60_ENUM_NAME
+       CMD_60_ENUM_NAME,
+#endif
+#ifdef CMD_61_ENUM_NAME
+       CMD_61_ENUM_NAME,
+#endif
+#ifdef CMD_62_ENUM_NAME
+       CMD_62_ENUM_NAME,
+#endif
+#ifdef CMD_63_ENUM_NAME
+       CMD_63_ENUM_NAME,
+#endif
+#ifdef CMD_64_ENUM_NAME
+       CMD_64_ENUM_NAME,
+#endif
+#ifdef CMD_65_ENUM_NAME
+       CMD_65_ENUM_NAME,
+#endif
+#ifdef CMD_66_ENUM_NAME
+       CMD_66_ENUM_NAME,
+#endif
+#ifdef CMD_67_ENUM_NAME
+       CMD_67_ENUM_NAME,
+#endif
+#ifdef CMD_68_ENUM_NAME
+       CMD_68_ENUM_NAME,
+#endif
+#ifdef CMD_69_ENUM_NAME
+       CMD_69_ENUM_NAME,
+#endif
+
+#ifdef CMD_70_ENUM_NAME
+       CMD_70_ENUM_NAME,
+#endif
+#ifdef CMD_71_ENUM_NAME
+       CMD_71_ENUM_NAME,
+#endif
+#ifdef CMD_72_ENUM_NAME
+       CMD_72_ENUM_NAME,
+#endif
+#ifdef CMD_73_ENUM_NAME
+       CMD_73_ENUM_NAME,
+#endif
+#ifdef CMD_74_ENUM_NAME
+       CMD_74_ENUM_NAME,
+#endif
+#ifdef CMD_75_ENUM_NAME
+       CMD_75_ENUM_NAME,
+#endif
+#ifdef CMD_76_ENUM_NAME
+       CMD_76_ENUM_NAME,
+#endif
+#ifdef CMD_77_ENUM_NAME
+       CMD_77_ENUM_NAME,
+#endif
+#ifdef CMD_78_ENUM_NAME
+       CMD_78_ENUM_NAME,
+#endif
+#ifdef CMD_79_ENUM_NAME
+       CMD_79_ENUM_NAME,
+#endif
+
+#ifdef CMD_80_ENUM_NAME
+       CMD_80_ENUM_NAME,
+#endif
+#ifdef CMD_81_ENUM_NAME
+       CMD_81_ENUM_NAME,
+#endif
+#ifdef CMD_82_ENUM_NAME
+       CMD_82_ENUM_NAME,
+#endif
+#ifdef CMD_83_ENUM_NAME
+       CMD_83_ENUM_NAME,
+#endif
+#ifdef CMD_84_ENUM_NAME
+       CMD_84_ENUM_NAME,
+#endif
+#ifdef CMD_85_ENUM_NAME
+       CMD_85_ENUM_NAME,
+#endif
+#ifdef CMD_86_ENUM_NAME
+       CMD_86_ENUM_NAME,
+#endif
+#ifdef CMD_87_ENUM_NAME
+       CMD_87_ENUM_NAME,
+#endif
+#ifdef CMD_88_ENUM_NAME
+       CMD_88_ENUM_NAME,
+#endif
+#ifdef CMD_89_ENUM_NAME
+       CMD_89_ENUM_NAME,
+#endif
+
+#ifdef CMD_90_ENUM_NAME
+       CMD_90_ENUM_NAME,
+#endif
+#ifdef CMD_91_ENUM_NAME
+       CMD_91_ENUM_NAME,
+#endif
+#ifdef CMD_92_ENUM_NAME
+       CMD_92_ENUM_NAME,
+#endif
+#ifdef CMD_93_ENUM_NAME
+       CMD_93_ENUM_NAME,
+#endif
+#ifdef CMD_94_ENUM_NAME
+       CMD_94_ENUM_NAME,
+#endif
+#ifdef CMD_95_ENUM_NAME
+       CMD_95_ENUM_NAME,
+#endif
+#ifdef CMD_96_ENUM_NAME
+       CMD_96_ENUM_NAME,
+#endif
+#ifdef CMD_97_ENUM_NAME
+       CMD_97_ENUM_NAME,
+#endif
+#ifdef CMD_98_ENUM_NAME
+       CMD_98_ENUM_NAME,
+#endif
+#ifdef CMD_99_ENUM_NAME
+       CMD_99_ENUM_NAME,
+#endif
+
+    CMD_LN  /* length of the ID enum list */
+} cli_cmd_t;
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+bool cli_cmd_is_valid(uint16_t value);
+bool cli_cmd_is_not_valid(uint16_t value);
+
+int cli_cmd_execute(cli_cmd_t cmd, const cli_cmdargs_t* p_cmdargs);
+
+int cli_cmd_txt2cmd(cli_cmd_t* p_rtn_cmd, const char* p_txt);
+const char* cli_cmd_cmd2txt(cli_cmd_t cmd);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_cli_def_help.c b/sw/libfci_cli/src/libfci_cli_def_help.c
new file mode 100644
index 0000000..ebd8b21
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_def_help.c
@@ -0,0 +1,2469 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#include <stdint.h>
+#include <stdio.h>
+
+#include "libfci_cli_common.h"
+#include "libfci_cli_def_cmds.h"
+#include "libfci_cli_def_opts.h"
+#include "libfci_cli_def_optarg_keywords.h"
+
+/* ==== TESTMODE vars ====================================================== */
+
+#if !defined(NDEBUG)
+/* empty */
+#endif
+
+/* ==== TYPEDEFS & DATA : aux symbols ====================================== */
+
+#define TXT_DECOR_CMD    "---- Command -------------------\n"
+#define TXT_DECOR_DESCR  "---- Description ---------------\n"
+#define TXT_DECOR_OPT    "---- Options -------------------\n"
+
+
+#define TXT_PHYIF_KEYWORDS  \
+        "  Only the following hardcoded PHYIF names are accepted:\n"  \
+        "    "  TXT_PHYIF__EMAC0  "\n"  \
+        "    "  TXT_PHYIF__EMAC1  "\n"  \
+        "    "  TXT_PHYIF__EMAC2  "\n"  \
+        "    "  TXT_PHYIF__UTIL   "\n"  \
+		"    "  TXT_PHYIF__HIF_NOCPY  "  (valid only if supported by a driver)"  "\n"  \
+        "    "  TXT_PHYIF__HIF0   "\n"  \
+        "    "  TXT_PHYIF__HIF1   "\n"  \
+        "    "  TXT_PHYIF__HIF2   "\n"  \
+        "    "  TXT_PHYIF__HIF3   "\n"
+
+
+#define TXT_OPTARGS__PHYIF         TXT_PHYIF__EMAC2
+#define TXT_OPTARGS__ON_OFF        TXT_ON_OFF__ON  "|"  TXT_ON_OFF__OFF
+#define TXT_OPTARGS__MAC_ADDR      "00:22:bc:45:de:67|35-47-ed-6c-28-b0"
+#define TXT_OPTARGS__BD_ACTIONS    TXT_BD_ACTION__PUNT  "|0-3"
+#define TXT_OPTARGS__MR            "MyMirrorRule"
+#define TXT_OPTARGS__FP_TABLE      "MyFpTable"
+#define TXT_OPTARGS__FP_RULE       "MyFpRule"
+#define TXT_OPTARGS__U8_DEC        "0-255"
+#define TXT_OPTARGS__U8_HEX        "0x00-0xFF"
+#define TXT_OPTARGS__U16_DEC       "0-65535"
+#define TXT_OPTARGS__U16_HEX       "0x00-0xFFFF"
+#define TXT_OPTARGS__U32_DEC       "0-4294967295"
+#define TXT_OPTARGS__U32_HEX       "0x00-0xFFFFFFFF"
+#define TXT_OPTARGS__I32_DEC       "-2147483648 - 2147483647"
+
+
+
+/* ==== TYPEDEFS & DATA : opt binds and descriptions ======================= */
+/*
+    Binding local symbols to help texts from 'def_opts.h' (and providing descriptions).
+    
+    Search for keyword 'OPT_LAST' to get to the bottom of the opt help text list.
+    Search for keyword 'CMD_LAST' to get to the bottom of the cmd help text list.
+    
+    
+    Description of symbols
+    ----------------------
+    TXT_OPT__xx         TXT_HELP__aa=<...>  Symbol representing the given cli opt in help texts (and example arguments if applicable).
+                                            'TXT_HELP__aa' is expected to be a cli opt help text symbol from 'def_opts.h'.
+                                            
+    TXT_OPTDESCR__xx    TXT_OPT__xx \ ...   Verbose description of the given cli opt.
+    
+*/
+
+#define TXT_OPT__IP4                    TXT_HELP__IP4
+#define TXT_OPTDESCR__IP4               TXT_HELP__IP4  "\n"  \
+                                        "  IPv4 variant of the operation.\n"
+
+#define TXT_OPT__IP6                    TXT_HELP__IP6
+#define TXT_OPTDESCR__IP6               TXT_HELP__IP6  "\n"  \
+                                        "  IPv6 variant of the operation.\n"
+
+#define TXT_OPT__ALL                    TXT_HELP__ALL
+#define TXT_OPTDESCR__ALL               TXT_HELP__ALL  "\n"  \
+                                        "  Bulk variant of the operation.\n"
+
+#define TXT_OPT__HELP                   TXT_HELP__HELP
+#define TXT_OPTDESCR__HELP              TXT_HELP__HELP  "\n"  \
+                                        "  Prints help\n"
+
+#define TXT_OPT__VERBOSE                TXT_HELP__VERBOSE
+#define TXT_OPTDESCR__VERBOSE           TXT_HELP__VERBOSE  "\n"  \
+                                        "  Verbose variant of the operation (more info).\n"
+
+#define TXT_OPT__VERSION                TXT_HELP__VERSION
+#define TXT_OPTDESCR__VERSION           TXT_HELP__VERSION  "\n"  \
+                                        "  Prints application version.\n"
+
+#define TXT_OPT__INTERFACE_LOGIF        TXT_HELP__INTERFACE  "=<logif_name>"
+#define TXT_OPTDESCR__INTERFACE_LOGIF   TXT_HELP__INTERFACE  "=<MyLogif>"  "\n"  \
+                                        "  Name of the target logical interface.\n"
+
+#define TXT_OPT__INTERFACE_PHYIF        TXT_HELP__INTERFACE  "=<phyif_name>"
+#define TXT_OPTDESCR__INTERFACE_PHYIF   TXT_HELP__INTERFACE  "=<"  TXT_OPTARGS__PHYIF  ">"  "\n"  \
+                                        "  Name of the target physical interface.\n"  \
+                                        TXT_PHYIF_KEYWORDS
+
+#define TXT_OPT__PARENT                 TXT_HELP__PARENT  "=<phyif_name>"
+#define TXT_OPTDESCR__PARENT            TXT_HELP__PARENT  "=<"  TXT_OPTARGS__PHYIF  ">"  "\n"  \
+                                        "  Name of the parent physical interface.\n"   \
+                                        TXT_PHYIF_KEYWORDS
+
+#define TXT_OPT__MIRROR                 TXT_HELP__MIRROR  "=<phyif_name>"
+#define TXT_OPTDESCR__MIRROR            TXT_HELP__MIRROR  "=<"  TXT_OPTARGS__PHYIF  ">"  "\n"  \
+                                        "  Name of the physical interface which shall receive a copy of traffic.\n"  \
+                                        "  Use empty string (\"\") to disable (clear).\n"
+
+#define TXT_OPT__MODE                   TXT_HELP__MODE  "=<if_mode>"
+#define TXT_OPTDESCR__MODE              TXT_HELP__MODE  "=<"  TXT_IF_MODE__BRIDGE  "|"  TXT_IF_MODE__ROUTER  "|...>"  "\n"  \
+                                        "  Operating mode of the physical interface.\n"          \
+                                        "  Interface modes:\n"                      \
+                                        "    "  TXT_IF_MODE__DEFAULT          "\n"  \
+                                        "    "  TXT_IF_MODE__BRIDGE           "\n"  \
+                                        "    "  TXT_IF_MODE__ROUTER           "\n"  \
+                                        "    "  TXT_IF_MODE__VLAN_BRIDGE      "\n"  \
+                                        "    "  TXT_IF_MODE__FLEXIBLE_ROUTER  "\n"  \
+                                        "    "  TXT_IF_MODE__L2L3_BRIDGE      "\n"  \
+                                        "    "  TXT_IF_MODE__L2L3_VLAN_BRIDGE "\n"
+
+#define TXT_OPT__BLOCK_STATE            TXT_HELP__BLOCK_STATE  "=<block_state>"
+#define TXT_OPTDESCR__BLOCK_STATE       TXT_HELP__BLOCK_STATE  "=<"  TXT_IF_BLOCK_STATE__LEARN_ONLY  "|"  TXT_IF_BLOCK_STATE__FW_ONLY  "|...>"  "\n"  \
+                                        "  Blocking state of the physical interface (learning and forwarding).\n"  \
+                                        "  Block states:\n"                           \
+                                        "    "  TXT_IF_BLOCK_STATE__NORMAL      "\n"  \
+                                        "    "  TXT_IF_BLOCK_STATE__BLOCKED     "\n"  \
+                                        "    "  TXT_IF_BLOCK_STATE__LEARN_ONLY  "\n"  \
+                                        "    "  TXT_IF_BLOCK_STATE__FW_ONLY     "\n"
+
+#define TXT_OPT__ENABLE_IF              TXT_HELP__ENABLE
+#define TXT_OPTDESCR__ENABLE_IF         TXT_HELP__ENABLE  "\n"  \
+                                        "  Enables (\"ups\") the interface.\n"
+
+#define TXT_OPT__ENABLE_FW              TXT_HELP__ENABLE
+#define TXT_OPTDESCR__ENABLE_FW         TXT_HELP__ENABLE  "\n"  \
+                                        "  Enables the given FW feature.\n"
+
+#define TXT_OPT__DISABLE_IF             TXT_HELP__DISABLE
+#define TXT_OPTDESCR__DISABLE_IF        TXT_HELP__DISABLE  "\n"  \
+                                        "  Disables (\"downs\") the interface.\n"
+
+#define TXT_OPT__DISABLE_FW             TXT_HELP__DISABLE
+#define TXT_OPTDESCR__DISABLE_FW        TXT_HELP__DISABLE  "\n"  \
+                                        "  Disables the given FW feature.\n"
+
+#define TXT_OPT__DISABLE_FF             TXT_HELP__DISABLE
+#define TXT_OPTDESCR__DISABLE_FF        TXT_HELP__DISABLE  "\n"  \
+                                        "  Disables global FlexibleFilter.\n"
+
+#define TXT_OPT__PROMISC_PHYIF          TXT_HELP__PROMISC  "=<"  TXT_OPTARGS__ON_OFF  ">"
+#define TXT_OPTDESCR__PROMISC_PHYIF     TXT_HELP__PROMISC  "=<"  TXT_OPTARGS__ON_OFF  ">"  "\n"  \
+                                        "  Enables/disables promiscuous mode.\n"                 \
+                                        "  (accepts all traffic regardless of destination MAC)\n"
+
+#define TXT_OPT__PROMISC_LOGIF          TXT_HELP__PROMISC  "=<"  TXT_OPTARGS__ON_OFF  ">"
+#define TXT_OPTDESCR__PROMISC_LOGIF     TXT_HELP__PROMISC  "=<"  TXT_OPTARGS__ON_OFF  ">"  "\n"    \
+                                        "  Enables/disables promiscuous mode.\n"                   \
+                                        "  (accepts all traffic regardless of active match rules)\n"
+
+#define TXT_OPT__LOADBALANCE            TXT_HELP__LOADBALANCE  "=<"  TXT_OPTARGS__ON_OFF  ">"
+#define TXT_OPTDESCR__LOADBALANCE       TXT_HELP__LOADBALANCE  "=<"  TXT_OPTARGS__ON_OFF  ">"  "\n"      \
+                                        "  true  : interface is a member of a loadbalancing bucket.\n"   \
+                                        "  false : interface is NOT a member of a loadbalancing bucket.\n"
+
+#define TXT_OPT__MATCH_MODE             TXT_HELP__MATCH_MODE  "=<"  TXT_OR_AND__OR  "|"  TXT_OR_AND__AND  ">"
+#define TXT_OPTDESCR__MATCH_MODE        TXT_HELP__MATCH_MODE  "=<"  TXT_OR_AND__OR  "|"  TXT_OR_AND__AND  ">"  "\n"  \
+                                        "  Sets chaining mode of active match rules.\n"     \
+                                        "  Traffic passes matching process if:\n"           \
+                                        "    "  TXT_OR_AND__OR   "  : at least one active rule is satisfied\n"  \
+                                        "    "  TXT_OR_AND__AND  " : all active rules are satisfied\n"
+
+#define TXT_OPT__DISCARD_ON_MATCH       TXT_HELP__DISCARD_ON_MATCH  "=<"  TXT_OPTARGS__ON_OFF  ">"
+#define TXT_OPTDESCR__DISCARD_ON_MATCH  TXT_HELP__DISCARD_ON_MATCH  "=<"  TXT_OPTARGS__ON_OFF  ">"  "\n"     \
+                                        "  If enabled, then end action of matching process is inverted:\n"   \
+                                        "    --> if traffic passes the matching process, it is discarded\n"  \
+                                        "    --> if traffic fails the matching process, it is accepted\n"
+
+#define TXT_OPT__EGRESS                 TXT_HELP__EGRESS  "=<list_of_phyifs>"
+#define TXT_OPTDESCR__EGRESS            TXT_HELP__EGRESS  "=<"  TXT_PHYIF__EMAC0  ","  TXT_PHYIF__HIF2  ",...>"  "\n"  \
+                                        "  Comma separated list of egresses (physical interfaces) which shall receive a copy of the accepted traffic.\n"  \
+                                        "  Use empty string (\"\") to disable (clear).\n"  \
+                                        TXT_PHYIF_KEYWORDS
+
+#define TXT_OPT__MATCH_RULES            TXT_HELP__MATCH_RULES  "=<list_of_rules>"
+#define TXT_OPTDESCR__MATCH_RULES       TXT_HELP__MATCH_RULES  "=<"  TXT_MATCH_RULE__TYPE_ETH  ","  TXT_MATCH_RULE__VLAN  ",...>"  "\n"  \
+                                        "  Comma separated list of match rules.\n"                \
+                                        "  Use empty string (\"\") to disable (clear).\n"         \
+                                        "  Some rules require additional command line options.\n" \
+                                        "  Match rules:\n"                        \
+                                        "    "  TXT_MATCH_RULE__TYPE_ETH    "\n"  \
+                                        "    "  TXT_MATCH_RULE__TYPE_VLAN   "\n"  \
+                                        "    "  TXT_MATCH_RULE__TYPE_PPPOE  "\n"  \
+                                        "    "  TXT_MATCH_RULE__TYPE_ARP    "\n"  \
+                                        "    "  TXT_MATCH_RULE__TYPE_MCAST  "\n"  \
+                                        "    "  TXT_MATCH_RULE__TYPE_IP4    "\n"  \
+                                        "    "  TXT_MATCH_RULE__TYPE_IP6    "\n"  \
+                                        "    "  TXT_MATCH_RULE__TYPE_IPX    "\n"  \
+                                        "    "  TXT_MATCH_RULE__TYPE_BCAST  "\n"  \
+                                        "    "  TXT_MATCH_RULE__TYPE_UDP    "\n"  \
+                                        "    "  TXT_MATCH_RULE__TYPE_TCP    "\n"  \
+                                        "    "  TXT_MATCH_RULE__TYPE_ICMP   "\n"  \
+                                        "    "  TXT_MATCH_RULE__TYPE_IGMP   "\n"  \
+                                        "    "  TXT_MATCH_RULE__VLAN        " ; requires <"  TXT_HELP__VLAN        ">\n"  \
+                                        "    "  TXT_MATCH_RULE__PROTOCOL    " ; requires <"  TXT_HELP__PROTOCOL    ">\n"  \
+                                        "    "  TXT_MATCH_RULE__SPORT       " ; requires <"  TXT_HELP__SPORT       ">\n"  \
+                                        "    "  TXT_MATCH_RULE__DPORT       " ; requires <"  TXT_HELP__DPORT       ">\n"  \
+                                        "    "  TXT_MATCH_RULE__SIP6        " ; requires <"  TXT_HELP__SIP6        ">\n"  \
+                                        "    "  TXT_MATCH_RULE__DIP6        " ; requires <"  TXT_HELP__DIP6        ">\n"  \
+                                        "    "  TXT_MATCH_RULE__SIP         " ; requires <"  TXT_HELP__SIP         ">\n"  \
+                                        "    "  TXT_MATCH_RULE__DIP         " ; requires <"  TXT_HELP__DIP         ">\n"  \
+                                        "    "  TXT_MATCH_RULE__ETHER_TYPE  " ; requires <"  TXT_HELP__ETHTYPE     ">\n"  \
+                                        "    "  TXT_MATCH_RULE__FP_TABLE0   " ; requires <"  TXT_HELP__TABLE0      ">\n"  \
+                                        "    "  TXT_MATCH_RULE__FP_TABLE1   " ; requires <"  TXT_HELP__TABLE1      ">\n"  \
+                                        "    "  TXT_MATCH_RULE__SMAC        " ; requires <"  TXT_HELP__SMAC        ">\n"  \
+                                        "    "  TXT_MATCH_RULE__DMAC        " ; requires <"  TXT_HELP__DMAC        ">\n"  \
+                                        "    "  TXT_MATCH_RULE__HIF_COOKIE  " ; requires <"  TXT_HELP__HIF_COOKIE  ">\n"
+
+#define TXT_OPT__VLAN                   TXT_HELP__VLAN  "=<id>" 
+#define TXT_OPTDESCR__VLAN              TXT_HELP__VLAN  "=<"  TXT_OPTARGS__U16_DEC  ">"  "\n"  \
+                                        "  VLAN ID\n"
+
+#define TXT_OPT__VLAN_BD                TXT_HELP__VLAN  "=<id>" 
+#define TXT_OPTDESCR__VLAN_BD           TXT_HELP__VLAN  "=<"  TXT_OPTARGS__U16_DEC  ">"  "\n"  \
+                                        "  VLAN ID (used as a bridge domain identifier)\n"
+
+#define TXT_OPT__R_VLAN                 TXT_HELP__R_VLAN  "=<id>" 
+#define TXT_OPTDESCR__R_VLAN            TXT_HELP__R_VLAN  "=<"  TXT_OPTARGS__U16_DEC  ">"  "\n"  \
+                                        "  Reply direction: VLAN ID\n"
+
+#define TXT_OPT__PROTOCOL               TXT_HELP__PROTOCOL  "=<keyword|id>"
+#define TXT_OPTDESCR__PROTOCOL          TXT_HELP__PROTOCOL  "=<"  TXT_PROTOCOL__IPv6  "|"  TXT_OPTARGS__U8_DEC  "|"  TXT_OPTARGS__U8_HEX  ">"  "\n"  \
+                                        "  IANA Assigned Internet Protocol Number\n"  \
+                                        "  https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml\n"  \
+                                        "  Accepted input formats are protocol keyword or protocol ID.\n"               \
+                                        "  Protocols without keyword can be addressed only by protocol ID.\n"
+
+#define TXT_OPT__PROTOCOL_CNTKTMO       TXT_HELP__PROTOCOL  "=<"  TXT_PROTOCOL__TCP  "|"  TXT_PROTOCOL__UDP  "|0>"
+#define TXT_OPTDESCR__PROTOCOL_CNTKTMO  TXT_HELP__PROTOCOL  "=<"  TXT_PROTOCOL__TCP  "|"  TXT_PROTOCOL__UDP  "|0>"  "\n"  \
+                                        "  IANA Assigned Internet Protocol Number\n"    \
+                                        "  Only selected protocols are accepted by this command.\n"  \
+                                        "  The rest of protocols is summarily referred to as 'others' (value 0).\n"
+
+#define TXT_OPT__ETHTYPE                TXT_HELP__ETHTYPE  "=<id>"
+#define TXT_OPTDESCR__ETHTYPE           TXT_HELP__ETHTYPE  "=<"  TXT_OPTARGS__U16_DEC  "|"  TXT_OPTARGS__U16_HEX  ">"  "\n"  \
+                                        "  IANA \"EtherType number\" (IEEE 802)\n"     \
+                                        "  https://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.xhtml\n"  \
+
+#define TXT_OPT__MAC                    TXT_HELP__MAC  "=<mac_addr>"
+#define TXT_OPTDESCR__MAC               TXT_HELP__MAC  "=<"  TXT_OPTARGS__MAC_ADDR  ">"  "\n"  \
+                                        "  MAC address\n"
+
+#define TXT_OPT__SMAC                   TXT_HELP__SMAC  "=<mac_addr>"
+#define TXT_OPTDESCR__SMAC              TXT_HELP__SMAC  "=<"  TXT_OPTARGS__MAC_ADDR  ">"  "\n"  \
+                                        "  Source MAC address\n"
+
+#define TXT_OPT__DMAC                   TXT_HELP__DMAC  "=<mac_addr>"
+#define TXT_OPTDESCR__DMAC              TXT_HELP__DMAC  "=<"  TXT_OPTARGS__MAC_ADDR  ">"  "\n"  \
+                                        "  Destination MAC address\n"
+
+#define TXT_OPT__SIP                    TXT_HELP__SIP  "=<ipv4|ipv6>"
+#define TXT_OPTDESCR__SIP               TXT_HELP__SIP  "=<12.126.31.7|fd00::1>"  "\n"  \
+                                        "  Source IP address\n"
+
+#define TXT_OPT__SIP_LOGIF              TXT_HELP__SIP  "=<ipv4>"
+#define TXT_OPTDESCR__SIP_LOGIF         TXT_HELP__SIP  "=<12.126.31.7>"  "\n"  \
+                                        "  Source IP address (only IPv4 is accepted)\n"
+
+#define TXT_OPT__DIP                    TXT_HELP__DIP  "=<ipv4|ipv6>"
+#define TXT_OPTDESCR__DIP               TXT_HELP__DIP  "=<132.16.20.3|fc62::5>"  "\n"  \
+                                        "  Destination IP address\n"
+
+#define TXT_OPT__DIP_LOGIF              TXT_HELP__DIP  "=<ipv4>"
+#define TXT_OPTDESCR__DIP_LOGIF         TXT_HELP__DIP  "=<132.16.20.3>"  "\n"  \
+                                        "  Destination IP address (only IPv4 is accepted)\n"
+
+#define TXT_OPT__R_SIP                  TXT_HELP__R_SIP  "=<ipv4|ipv6>"
+#define TXT_OPTDESCR__R_SIP             TXT_HELP__R_SIP  "=<13.125.30.2|fe51::7>"  "\n"  \
+                                        "  Reply direction: source IP address (used for NAT)\n"
+
+#define TXT_OPT__R_DIP                  TXT_HELP__R_DIP  "=<ipv4|ipv6>"
+#define TXT_OPTDESCR__R_DIP             TXT_HELP__R_DIP  "=<112.37.52.9|fd14::2>"  "\n"  \
+                                        "  Reply direction: destination IP address (used for NAT)\n"
+
+#define TXT_OPT__SIP6                   TXT_HELP__SIP6  "=<ipv6>"
+#define TXT_OPTDESCR__SIP6              TXT_HELP__SIP6  "=<fd00::1>"  "\n"  \
+                                        "  Source IP address (only IPv6 is accepted)\n"
+
+#define TXT_OPT__DIP6                   TXT_HELP__DIP6  "=<ipv6>"
+#define TXT_OPTDESCR__DIP6              TXT_HELP__DIP6  "=<fc62::5>"  "\n"  \
+                                        "  Destination IP address (only IPv6 is accepted)\n"
+
+#define TXT_OPT__SPORT                  TXT_HELP__SPORT  "=<port>"
+#define TXT_OPTDESCR__SPORT             TXT_HELP__SPORT  "=<"  TXT_OPTARGS__U16_DEC  ">"  "\n"  \
+                                        "  Source port\n"
+
+#define TXT_OPT__DPORT                  TXT_HELP__DPORT  "=<port>"
+#define TXT_OPTDESCR__DPORT             TXT_HELP__DPORT  "=<"  TXT_OPTARGS__U16_DEC  ">"  "\n"  \
+                                        "  Destination port\n"
+
+#define TXT_OPT__R_SPORT                TXT_HELP__R_SPORT  "=<port>"
+#define TXT_OPTDESCR__R_SPORT           TXT_HELP__R_SPORT  "=<"  TXT_OPTARGS__U16_DEC  ">"  "\n"  \
+                                        "  Reply direction: source port (used for PAT)\n"
+
+#define TXT_OPT__R_DPORT                TXT_HELP__R_DPORT  "=<port>"
+#define TXT_OPTDESCR__R_DPORT           TXT_HELP__R_DPORT  "=<"  TXT_OPTARGS__U16_DEC  ">"  "\n"  \
+                                        "  Reply direction: destination port (used for PAT)\n"
+
+#define TXT_OPT__HIF_COOKIE             TXT_HELP__HIF_COOKIE  "=<hex_value>"
+#define TXT_OPTDESCR__HIF_COOKIE        TXT_HELP__HIF_COOKIE  "=<"  TXT_OPTARGS__U32_HEX  ">"  "\n"  \
+                                        "  Can be used to recognize which HIF sent the traffic.\n"   \
+                                        "  PFE driver in the host OS must be specifically configured to allow use of this feature.\n"
+
+#define TXT_OPT__TIMEOUT_CNTKTMO        TXT_HELP__TIMEOUT  "=<seconds>"
+#define TXT_OPTDESCR__TIMEOUT_CNTKTMO   TXT_HELP__TIMEOUT  "=<"  TXT_OPTARGS__U32_DEC  ">"  "\n"  \
+                                        "  For TCP and 'others': Timeout in seconds.\n"  \
+                                        "  For UDP:\n"                                   \
+                                        "    --> If ["  TXT_HELP__TIMEOUT2  "] is NOT utilized, then\n"  \
+                                        "        this value is applied on all kinds of UDP conntracks.\n"     \
+                                        "    --> If ["  TXT_HELP__TIMEOUT2  "] IS utilized, then \n"     \
+                                        "        this value is applied only on bidirectional UDP conntracks.\n"
+
+#define TXT_OPT__TIMEOUT2_CNTKTMO       TXT_HELP__TIMEOUT2  "=<seconds>"
+#define TXT_OPTDESCR__TIMEOUT2_CNTKTMO  TXT_HELP__TIMEOUT2  "=<"  TXT_OPTARGS__U32_DEC  ">"  "\n"  \
+                                        "  Timeout in seconds.\n"  \
+                                        "  This value is applied only on unidirectional UDP conntracks.\n"
+
+#define TXT_OPT__UCAST_HIT              TXT_HELP__UCAST_HIT  "=<action>"
+#define TXT_OPTDESCR__UCAST_HIT         TXT_HELP__UCAST_HIT  "=<"  TXT_OPTARGS__BD_ACTIONS ">"  "\n"  \
+                                        "  Action to be taken when unicast packet's destination MAC matches some MAC table entry.\n"  \
+                                        "  Actions:\n"  \
+                                        "    "  TXT_BD_ACTION__FORWARD  "\n"  \
+                                        "    "  TXT_BD_ACTION__FLOOD    "\n"  \
+                                        "    "  TXT_BD_ACTION__PUNT     "\n"  \
+                                        "    "  TXT_BD_ACTION__DISCARD  "\n"
+
+#define TXT_OPT__UCAST_MISS             TXT_HELP__UCAST_MISS  "=<action>"
+#define TXT_OPTDESCR__UCAST_MISS        TXT_HELP__UCAST_MISS  "=<"  TXT_OPTARGS__BD_ACTIONS ">"  "\n"  \
+                                        "  Action to be taken when unicast packet's destination MAC does not match any MAC table entry.\n"  \
+                                        "  Possible actions:\n"  \
+                                        "    Same as actions of  ["  TXT_HELP__UCAST_HIT  "]\n"
+
+#define TXT_OPT__MCAST_HIT              TXT_HELP__MCAST_HIT  "=<action>"
+#define TXT_OPTDESCR__MCAST_HIT         TXT_HELP__MCAST_HIT  "=<"  TXT_OPTARGS__BD_ACTIONS ">"  "\n"  \
+                                        "  Action to be taken when multicast packet's destination MAC matches some MAC table entry.\n"  \
+                                        "  Possible actions:\n"  \
+                                        "    Same as actions of  ["  TXT_HELP__UCAST_HIT  "]\n"
+
+#define TXT_OPT__MCAST_MISS             TXT_HELP__MCAST_MISS  "=<action>"
+#define TXT_OPTDESCR__MCAST_MISS        TXT_HELP__MCAST_MISS  "=<"  TXT_OPTARGS__BD_ACTIONS ">"  "\n"  \
+                                        "  Action to be taken when multicast packet's destination MAC does not match any MAC table entry.\n"  \
+                                        "  Possible actions:\n"  \
+                                        "    Same as actions of  ["  TXT_HELP__UCAST_HIT  "]\n"
+
+#define TXT_OPT__TAG                    TXT_HELP__TAG  "=<"  TXT_OPTARGS__ON_OFF  ">"
+#define TXT_OPTDESCR__TAG               TXT_HELP__TAG  "=<"  TXT_OPTARGS__ON_OFF  ">"  "\n"  \
+                                        "  Sets/unsets whether the traffic from the given interface has the VLAN tag retained/added ("  TXT_ON_OFF__ON  ")\n"  \
+                                        "  or has the VLAN tag removed ("  TXT_ON_OFF__OFF  ").\n"
+
+#define TXT_OPT__DEFAULT                TXT_HELP__DEFAULT
+#define TXT_OPTDESCR__DEFAULT           TXT_HELP__DEFAULT  "\n"  \
+                                        "  Sets the given bridge domain as a default bridge domain.\n"  \
+                                        "  Default bridge domain is used for packets which:\n"          \
+                                        "    --> don't have a VLAN TAG\n"                               \
+                                        "    --> have VLAN TAG matching the VLAN ID of the default domain.\n"
+
+#define TXT_OPT__FALLBACK               TXT_HELP__FALLBACK
+#define TXT_OPTDESCR__FALLBACK          TXT_HELP__FALLBACK  "\n"  \
+                                        "  Sets the given bridge domain as a fallback bridge domain.\n"             \
+                                        "  Fallback bridge domain is used for packets which do have a VLAN TAG,\n"  \
+                                        "  but their VLAN TAG does not match VLAN ID of any existing bridge domain.\n"
+
+#define TXT_OPT__4o6                    TXT_HELP__4o6
+#define TXT_OPTDESCR__4o6               TXT_HELP__4o6  "\n"  \
+                                        "  Specifies that the timeout is meant for IPv4 over IPv6 tunneling connections.\n"
+
+#define TXT_OPT__NO_REPLY               TXT_HELP__NO_REPLY
+#define TXT_OPTDESCR__NO_REPLY          TXT_HELP__NO_REPLY  "\n"  \
+                                        "  Specifies unidirectional conntrack - only the \"original direction\" route is created.\n"
+
+#define TXT_OPT__NO_ORIG                TXT_HELP__NO_ORIG
+#define TXT_OPTDESCR__NO_ORIG           TXT_HELP__NO_ORIG  "\n"  \
+                                        "  Specifies unidirectional conntrack - only the \"reply direction\" route is created.\n"
+
+#define TXT_OPT__ROUTE                  TXT_HELP__ROUTE  "=<id>"
+#define TXT_OPTDESCR__ROUTE             TXT_HELP__ROUTE  "=<"  TXT_OPTARGS__U32_DEC  ">"  "\n"  \
+                                        "  Route ID\n"
+
+#define TXT_OPT__R_ROUTE                TXT_HELP__R_ROUTE  "=<id>"
+#define TXT_OPTDESCR__R_ROUTE           TXT_HELP__R_ROUTE  "=<"  TXT_OPTARGS__U32_DEC  ">"  "\n"  \
+                                        "  Reply direction: route ID\n"
+
+#define TXT_OPT__INGRESS_MR0            TXT_HELP__INGRESS_MR0  "=<rule_name>"
+#define TXT_OPTDESCR__INGRESS_MR0       TXT_HELP__INGRESS_MR0  "=<"  TXT_OPTARGS__MR  ">"  "\n"  \
+                                        "  Mirror rule for the ingress mirror rule slot [0].\n"  \
+                                        "  Use empty string (\"\") to disable (clear).\n"
+
+#define TXT_OPT__INGRESS_MR1            TXT_HELP__INGRESS_MR1  "=<rule_name>"
+#define TXT_OPTDESCR__INGRESS_MR1       TXT_HELP__INGRESS_MR1  "=<"  TXT_OPTARGS__MR  ">"  "\n"  \
+                                        "  Mirror rule for the ingress mirror rule slot [1].\n"  \
+                                        "  Use empty string (\"\") to disable (clear).\n"
+
+#define TXT_OPT__EGRESS_MR0             TXT_HELP__EGRESS_MR0  "=<rule_name>"
+#define TXT_OPTDESCR__EGRESS_MR0        TXT_HELP__EGRESS_MR0  "=<"  TXT_OPTARGS__MR  ">"  "\n"  \
+                                        "  Mirror rule for the egress mirror rule slot [0].\n"  \
+                                        "  Use empty string (\"\") to disable (clear).\n"
+
+#define TXT_OPT__EGRESS_MR1             TXT_HELP__EGRESS_MR1  "=<rule_name>"
+#define TXT_OPTDESCR__EGRESS_MR1        TXT_HELP__EGRESS_MR1  "=<"  TXT_OPTARGS__MR  ">"  "\n"  \
+                                        "  Mirror rule for the egress mirror rule slot [1].\n"  \
+                                        "  Use empty string (\"\") to disable (clear).\n"
+
+#define TXT_OPT__FP_TABLE               TXT_HELP__TABLE  "=<table_name>"
+#define TXT_OPTDESCR__FP_TABLE          TXT_HELP__TABLE  "=<"  TXT_OPTARGS__FP_TABLE  ">"  "\n"  \
+                                        "  Name of a FlexibleParser table.\n"
+
+#define TXT_OPT__FLEXIBLE_FILTER        TXT_HELP__FLEXIBLE_FILTER  "=<table_name>"
+#define TXT_OPTDESCR__FLEXIBLE_FILTER   TXT_HELP__FLEXIBLE_FILTER  "=<"  TXT_OPTARGS__FP_TABLE  ">"  "\n"  \
+                                        "  Name of a FlexibleParser table which shall be set as a FlexibleFilter of the given physical interface.\n"  \
+                                        "  Use empty string (\"\") to disable (clear).\n"
+
+#define TXT_OPT__FP_TABLE0_LOGIF        TXT_HELP__TABLE0  "=<table_name>"
+#define TXT_OPTDESCR__FP_TABLE0_LOGIF   TXT_HELP__TABLE0  "=<"  TXT_OPTARGS__FP_TABLE  ">"  "\n"  \
+                                        "  Name of a FlexibleParser table for the parser slot [0].\n"  \
+
+#define TXT_OPT__FP_TABLE1_LOGIF        TXT_HELP__TABLE1  "=<table_name>"
+#define TXT_OPTDESCR__FP_TABLE1_LOGIF   TXT_HELP__TABLE1  "=<"  TXT_OPTARGS__FP_TABLE  ">"  "\n"  \
+                                        "  Name of a FlexibleParser table for the parser slot [1].\n"  \
+
+#define TXT_OPT__FP_RULE                TXT_HELP__RULE  "=<rule_name>"
+#define TXT_OPTDESCR__FP_RULE           TXT_HELP__RULE  "=<"  TXT_OPTARGS__FP_RULE  ">"  "\n"  \
+                                        "  Name of a FlexibleParser rule.\n"
+
+#define TXT_OPT__FP_NEXT_RULE           TXT_HELP__NEXT_RULE  "=<rule_name>"
+#define TXT_OPTDESCR__FP_NEXT_RULE      TXT_HELP__NEXT_RULE  "=<"  TXT_OPTARGS__FP_RULE  ">"  "\n"  \
+                                        "  Rule action: invoke the supplied FlexibleParser rule as the next processing rule.\n"
+
+#define TXT_OPT__DATA                   TXT_HELP__DATA  "=<hex_value>" 
+#define TXT_OPTDESCR__DATA              TXT_HELP__DATA  "=<"  TXT_OPTARGS__U32_HEX  ">"  "\n"  \
+                                        "  Expected data value (32bit hexadecimal).\n"
+
+#define TXT_OPT__MASK                   TXT_HELP__MASK  "=<hex_value>" 
+#define TXT_OPTDESCR__MASK              TXT_HELP__MASK  "=<"  TXT_OPTARGS__U32_HEX  ">"  "\n"  \
+                                        "  A bitmask to apply on processed data prior to data comparison (32bit hexadecimal).\n"
+
+#define TXT_OPT__LAYER                  TXT_HELP__LAYER  "=<L2|L3|L4>"
+#define TXT_OPTDESCR__LAYER             TXT_HELP__LAYER  "=<L2|L3|L4>"  "\n"  \
+                                        "  Base offset for further offset calculations.\n"  \
+                                        "  Possible base offsets:\n"                        \
+                                        "    "  TXT_OFFSET_FROM__L2  " : start from layer 2 header (from ETH frame header)\n"       \
+                                        "    "  TXT_OFFSET_FROM__L3  " : start from layer 3 header (e.g. from IP packet header)\n"  \
+                                        "    "  TXT_OFFSET_FROM__L4  " : start from layer 4 header (e.g. from TCP segment header)\n"
+
+#define TXT_OPT__OFFSET_FP              TXT_HELP__OFFSET  "=<value>"
+#define TXT_OPTDESCR__OFFSET_FP         TXT_HELP__OFFSET  "=<"  TXT_OPTARGS__U16_DEC  "|"  TXT_OPTARGS__U16_HEX  ">"  "\n"  \
+                                        "  Offset to the inspected data within the packet (added to the layer base offset).\n"
+
+#define TXT_OPT__INVERT_FP              TXT_HELP__INVERT
+#define TXT_OPTDESCR__INVERT_FP         TXT_HELP__INVERT  "\n"  \
+                                        "  Invert the result of a rule's matching process.\n"  \
+                                        "  If a raw data comparison yields 'true' but this flag is set, then "  \
+                                        "  the final result of a matching process will be 'false' (and vice versa).\n"
+
+#define TXT_OPT__ACCEPT_FP              TXT_HELP__ACCEPT
+#define TXT_OPTDESCR__ACCEPT_FP         TXT_HELP__ACCEPT  "\n"  \
+                                        "  Rule action: accept the packet\n"
+
+#define TXT_OPT__REJECT_FP              TXT_HELP__REJECT
+#define TXT_OPTDESCR__REJECT_FP         TXT_HELP__REJECT  "\n"  \
+                                        "  Rule action: reject the packet\n"
+
+#define TXT_OPT__POSITION_INSADD        TXT_HELP__POSITION  "=<value>"
+#define TXT_OPTDESCR__POSITION_INSADD   TXT_HELP__POSITION  "=<"  TXT_OPTARGS__U16_DEC  ">"  "\n"  \
+                                        "  Index where to insert the item.\n"                       \
+                                        "  (hint: indexing starts from the position 0)\n"           \
+                                        "  If this option is not utilized, then the item is automatically\n"  \
+                                        "  inserted as a last item of the table.\n"
+
+#define TXT_OPT__POSITION_REMDEL        TXT_HELP__POSITION  "=<value>"
+#define TXT_OPTDESCR__POSITION_REMDEL   TXT_HELP__POSITION  "=<"  TXT_OPTARGS__U16_DEC  ">"  "\n"  \
+                                        "  Index of the target item to destroy.\n"  \
+                                        "  (hint: indexing starts from position 0)\n"
+
+#define TXT_OPT__POSITION_PRINT         TXT_HELP__POSITION  "=<value>"
+#define TXT_OPTDESCR__POSITION_PRINT    TXT_HELP__POSITION  "=<"  TXT_OPTARGS__U16_DEC  ">"  "\n"  \
+                                        "  Index of the first item to print.\n"  \
+                                        "  Default value is 0 (start from the very first item of the table).\n"
+
+#define TXT_OPT__COUNT_PRINT            TXT_HELP__COUNT  "=<value>"
+#define TXT_OPTDESCR__COUNT_PRINT       TXT_HELP__COUNT  "=<"  TXT_OPTARGS__U16_DEC  ">"  "\n"  \
+                                        "  Count of items to print.\n"  \
+                                        "  Default value is 0 (print all available items).\n"
+
+#define TXT_OPT__SAD                    TXT_HELP__SAD  "=<idx>"
+#define TXT_OPTDESCR__SAD               TXT_HELP__SAD  "=<"  TXT_OPTARGS__U32_DEC  ">"  "\n"  \
+                                        "  Index into SAD (Security Association Database).\n"
+
+#define TXT_OPT__SPD_ACTION             TXT_HELP__SPD_ACTION  "=<action>"
+#define TXT_OPTDESCR__SPD_ACTION        TXT_HELP__SPD_ACTION  "=<BYPASS|1-4>"  "\n"  \
+                                        "  Action to be done on traffic which matches SPD criteria.\n"  \
+                                        "  Actions:\n"                         \
+                                        "    "  TXT_SPD_ACTION__DISCARD  "\n"  \
+                                        "    "  TXT_SPD_ACTION__BYPASS   "\n"  \
+                                        "    "  TXT_SPD_ACTION__ENCODE   " ; requires <"  TXT_HELP__SAD  ">\n"  \
+                                        "    "  TXT_SPD_ACTION__DECODE   " ; requires <"  TXT_HELP__SPI  ">\n"
+
+#define TXT_OPT__SPI                    TXT_HELP__SPI  "=<hex_value>"
+#define TXT_OPTDESCR__SPI               TXT_HELP__SPI  "=<"  TXT_OPTARGS__U32_HEX  ">"  "\n"  \
+                                        "  Security Parameter Index\n"
+
+#define TXT_OPT__VLAN_CONF              TXT_HELP__VLAN_CONF  "=<"  TXT_OPTARGS__ON_OFF  ">"
+#define TXT_OPTDESCR__VLAN_CONF         TXT_HELP__VLAN_CONF  "=<"  TXT_OPTARGS__ON_OFF  ">"  "\n"                   \
+                                        "  Enables/disables a strict VLAN conformance check.\n"                     \
+                                        "  When enabled, the interface automatically discards all traffic that \n"  \
+                                        "  is not strictly IEEE 802.1Q compliant.\n"
+
+#define TXT_OPT__PTP_CONF               TXT_HELP__PTP_CONF  "=<"  TXT_OPTARGS__ON_OFF  ">"
+#define TXT_OPTDESCR__PTP_CONF          TXT_HELP__PTP_CONF  "=<"  TXT_OPTARGS__ON_OFF  ">"  "\n"        \
+                                        "  Enables/disables a strict PTP conformance check.\n"          \
+                                        "  When enabled, the interface automatically discards all traffic that \n"  \
+                                        "  is not strictly IEEE 802.1AS compliant.\n"
+
+#define TXT_OPT__PTP_PROMISC            TXT_HELP__PTP_PROMISC  "=<"  TXT_OPTARGS__ON_OFF  ">"
+#define TXT_OPTDESCR__PTP_PROMISC       TXT_HELP__PTP_PROMISC  "=<"  TXT_OPTARGS__ON_OFF  ">"  "\n"  \
+                                        "  Enables/disables acceptance of PTP traffic even if ["  TXT_HELP__VLAN_CONF  "] flag is active.\n"
+
+#define TXT_OPT__LOOPBACK               TXT_HELP__LOOPBACK  "=<"  TXT_OPTARGS__ON_OFF  ">"
+#define TXT_OPTDESCR__LOOPBACK          TXT_HELP__LOOPBACK  "=<"  TXT_OPTARGS__ON_OFF  ">"  "\n"  \
+                                        "  Enables/disables loopback mode of the interface.\n"
+
+#define TXT_OPT__QINQ                   TXT_HELP__QINQ  "=<"  TXT_OPTARGS__ON_OFF  ">"
+#define TXT_OPTDESCR__QINQ              TXT_HELP__QINQ  "=<"  TXT_OPTARGS__ON_OFF  ">"  "\n"  \
+                                        "  Enables/disables processing of Q-in-Q traffic.\n"  \
+                                        "  If disabled, then traffic with multiple VLAN tags is automatically discarded.\n"
+
+#define TXT_OPT__LOCAL_STENT            TXT_HELP__LOCAL  "=<"  TXT_OPTARGS__ON_OFF  ">"
+#define TXT_OPTDESCR__LOCAL_STENT       TXT_HELP__LOCAL  "=<"  TXT_OPTARGS__ON_OFF  ">"  "\n"  \
+                                        "  Makes the static entry a LOCAL entry.\n"  \
+                                        "  If this flag is set, then: \n"            \
+                                        "    --> forwarding list is ignored \n"      \
+                                        "    --> if traffic's destination MAC matches the MAC of this static entry, then \n"  \
+                                        "        the traffic is passed to the IP router.\n"  \
+                                        "        (requires L2L3 mode on the ingress physical interface)\n"
+
+#define TXT_OPT__DISCARD_ON_MATCH_SRC       TXT_HELP__DISCARD_ON_MATCH_SRC  "=<"  TXT_OPTARGS__ON_OFF  ">"
+#define TXT_OPTDESCR__DISCARD_ON_MATCH_SRC  TXT_HELP__DISCARD_ON_MATCH_SRC  "=<"  TXT_OPTARGS__ON_OFF  ">"  "\n"  \
+                                            "  Discard traffic if its source MAC matches the MAC of this static entry.\n"
+
+#define TXT_OPT__DISCARD_ON_MATCH_DST       TXT_HELP__DISCARD_ON_MATCH_DST  "=<"  TXT_OPTARGS__ON_OFF  ">"
+#define TXT_OPTDESCR__DISCARD_ON_MATCH_DST  TXT_HELP__DISCARD_ON_MATCH_DST  "=<"  TXT_OPTARGS__ON_OFF  ">"  "\n"  \
+                                            "  Discard traffic if its destination MAC matches the MAC of this static entry.\n"
+
+#define TXT_OPT__FEATURE_FW             TXT_HELP__FEATURE  "=<feature_name>"
+#define TXT_OPTDESCR__FEATURE_FW        TXT_HELP__FEATURE  "=<ingress_vlan>"  "\n"  \
+                                        "  Name of a FW feature.\n"
+
+#define TXT_OPT__STATIC                 TXT_HELP__STATIC
+#define TXT_OPTDESCR__STATIC            TXT_HELP__STATIC  "\n"  \
+                                        "  Apply only on static entries.\n"
+
+#define TXT_OPT__DYNAMIC                TXT_HELP__DYNAMIC
+#define TXT_OPTDESCR__DYNAMIC           TXT_HELP__DYNAMIC  "\n"  \
+                                        "  Apply only on dynamic (learned) entries.\n"
+
+#define TXT_OPT__QUE                    TXT_HELP__QUE  "=<id>"
+#define TXT_OPTDESCR__QUE               TXT_HELP__QUE  "=<0-7>"  "\n"  \
+                                        "  Queue ID\n"
+
+#define TXT_OPT__SCH                    TXT_HELP__SCH  "=<id>"
+#define TXT_OPTDESCR__SCH               TXT_HELP__SCH  "=<0|1>"  "\n"  \
+                                        "  Scheduler ID\n"
+
+#define TXT_OPT__SHP                    TXT_HELP__SHP  "=<id>"
+#define TXT_OPTDESCR__SHP               TXT_HELP__SHP  "=<0-3>"  "\n"  \
+                                        "  Shaper ID\n"
+
+#define TXT_OPT__QUE_MODE               TXT_HELP__QUE_MODE  "=<mode>"
+#define TXT_OPTDESCR__QUE_MODE          TXT_HELP__QUE_MODE  "=<"  TXT_QUE_MODE__TAIL_DROP  ">"  "\n"  \
+                                        "  Queue mode\n"  \
+                                        "  Modes:\n"      \
+                                        "    "  TXT_QUE_MODE__DISABLED   "\n"  \
+                                        "    "  TXT_QUE_MODE__DEFAULT    "\n"  \
+                                        "    "  TXT_QUE_MODE__TAIL_DROP  "\n"  \
+                                        "    "  TXT_QUE_MODE__WRED       "\n"
+
+#define TXT_OPT__SCH_MODE               TXT_HELP__SCH_MODE  "=<mode>"
+#define TXT_OPTDESCR__SCH_MODE          TXT_HELP__SCH_MODE  "=<"  TXT_SCH_MODE__DISABLED  "|"  TXT_SCH_MODE__DATA_RATE  "|"  TXT_SCH_MODE__PACKET_RATE  ">"  "\n"  \
+                                        "  Scheduler mode\n"
+
+#define TXT_OPT__SHP_MODE               TXT_HELP__SHP_MODE  "=<mode>"
+#define TXT_OPTDESCR__SHP_MODE          TXT_HELP__SHP_MODE  "=<"  TXT_SHP_MODE__DISABLED  "|"  TXT_SHP_MODE__DATA_RATE  "|"  TXT_SHP_MODE__PACKET_RATE  ">"  "\n"  \
+                                        "  Shaper mode\n"
+
+#define TXT_OPT__THMIN                  TXT_HELP__THMIN  "=<value>"
+#define TXT_OPTDESCR__THMIN             TXT_HELP__THMIN  "=<0-255>"  "\n"  \
+                                        "  Minimal threshold value. Meaningful only for the following que modes:\n"  \
+                                        "    "  TXT_QUE_MODE__WRED  ": Number of packets in the queue where the lowest drop probability zone starts.\n"
+
+#define TXT_OPT__THMAX                  TXT_HELP__THMAX  "=<value>"
+#define TXT_OPTDESCR__THMAX             TXT_HELP__THMAX  "=<0-255>"  "\n"  \
+                                        "  Maximal threshold value. Meaningful only for the following que modes:\n"  \
+                                        "    "  TXT_QUE_MODE__TAIL_DROP  ": Max allowed number of packets in the queue.\n"  \
+                                        "    "  TXT_QUE_MODE__WRED       ": Number of packets in the queue above which the drop probability is always 100%.\n"
+
+#define TXT_OPT__ZPROB                  TXT_HELP__ZPROB  "=<list_of_percentages>"
+#define TXT_OPTDESCR__ZPROB             TXT_HELP__ZPROB  "=<10,30,K,50,...>"  "\n"  \
+                                        "  Comma separated list of percentages.\n"  \
+                                        "  Drop probabilities for probability zones. Meaningful only for queue mode "  TXT_QUE_MODE__WRED  ".\n"  \
+                                        "  Position of a value in the list corresponds with a zone (from zone [0] up to zone [N]).\n"  \
+                                        "  Zones which are not touched (when provided list is too short) and zones which are marked with 'K' (keep) are left unchanged.\n"  \
+                                        "  NOTE: Percentages are stored in a compressed format. Expect a certain inaccuracy of stored data (around +/- 3 units)."
+
+#define TXT_OPT__SCH_ALGO               TXT_HELP__SCH_ALGO  "=<algorithm>"
+#define TXT_OPTDESCR__SCH_ALGO          TXT_HELP__SCH_ALGO  "=<"  TXT_SCH_ALGO__DWRR  ">"  "\n"  \
+                                        "  Scheduler selection algorithm\n"  \
+                                        "  Algorithms:\n"  \
+                                        "    "  TXT_SCH_ALGO__PQ    "    (Priority Queue)\n"  \
+                                        "    "  TXT_SCH_ALGO__DWRR  "  (Deficit Weighted Round Robin)\n"  \
+                                        "    "  TXT_SCH_ALGO__RR    "    (Round Robin)\n"  \
+                                        "    "  TXT_SCH_ALGO__WRR   "   (Weighted Round Robin)\n"
+
+#define TXT_OPT__SCH_IN                 TXT_HELP__SCH_IN  "=<list_of_inputs>"
+#define TXT_OPTDESCR__SCH_IN            TXT_HELP__SCH_IN  "=<"  TXT_SCH_IN__QUE1  ":10,"  TXT_SCH_IN__QUE3  ":243,D,K,...>"  "\n"  \
+                                        "  Comma separated list of input sources and their weights.\n"  \
+                                        "  Input sources:\n"  \
+                                        "    "  TXT_SCH_IN__KEEP      "  (to keep the given scheduler input untouched)\n"  \
+                                        "    "  TXT_SCH_IN__DISABLED  "  (to disable the given scheduler input)\n"         \
+                                        "    "  TXT_SCH_IN__QUE0      "\n"  \
+                                        "    "  TXT_SCH_IN__QUE1      "\n"  \
+                                        "    "  TXT_SCH_IN__QUE2      "\n"  \
+                                        "    "  TXT_SCH_IN__QUE3      "\n"  \
+                                        "    "  TXT_SCH_IN__QUE4      "\n"  \
+                                        "    "  TXT_SCH_IN__QUE5      "\n"  \
+                                        "    "  TXT_SCH_IN__QUE6      "\n"  \
+                                        "    "  TXT_SCH_IN__QUE7      "\n"  \
+                                        "    "  TXT_SCH_IN__SCH0_OUT  "\n"
+
+#define TXT_OPT__SHP_POS                TXT_HELP__SHP_POS  "=<position>"
+#define TXT_OPTDESCR__SHP_POS           TXT_HELP__SHP_POS  "=<"  TXT_SHP_POS__SCH1_IN3  ">"  "\n"  \
+                                        "  Position of a shaper within the QoS configuration.\n"   \
+                                        "  Positions:\n"  \
+                                        "    "  TXT_SHP_POS__DISABLED  "\n"  \
+                                        "    "  TXT_SHP_POS__SCH0_IN0  ", "  TXT_SHP_POS__SCH0_IN1  " ... "  TXT_SHP_POS__SCH0_IN7  "\n"  \
+                                        "    "  TXT_SHP_POS__SCH1_IN0  ", "  TXT_SHP_POS__SCH1_IN1  " ... "  TXT_SHP_POS__SCH1_IN7  "\n"  \
+                                        "    "  TXT_SHP_POS__SCH1_OUT  "\n"
+
+#define TXT_OPT__ISL                    TXT_HELP__ISL  "=<value>"
+#define TXT_OPTDESCR__ISL               TXT_HELP__ISL  "=<"  TXT_OPTARGS__U32_DEC  ">"  "\n"  \
+                                        "  Idle slope [units per second].\n"  \
+                                        "  Units depend on currently set ["  TXT_HELP__SHP_MODE  "]:\n"  \
+                                        "    [bits per second]    (inaccuracy +/- 2400 units) for "  TXT_SHP_MODE__DATA_RATE    "\n"  \
+                                        "    [packets per second] (inaccuracy +/-  300 units) for "  TXT_SHP_MODE__PACKET_RATE  "\n"  \
+                                        "  NOTE: Idle slope is stored in a compressed format. Expect a certain inaccuracy of stored data.\n"
+
+#define TXT_OPT__CRMIN                  TXT_HELP__CRMIN  "=<value>"
+#define TXT_OPTDESCR__CRMIN             TXT_HELP__CRMIN  "=<"  TXT_OPTARGS__I32_DEC  ">"  "\n"  \
+                                        "  Minimal credit.\n"  \
+                                        "  Units depend on currently set ["  TXT_HELP__SHP_MODE  "]:\n"  \
+                                        "    [bytes]   for "  TXT_SHP_MODE__DATA_RATE    "\n"  \
+                                        "    [packets] for "  TXT_SHP_MODE__PACKET_RATE  "\n"
+
+#define TXT_OPT__CRMAX                  TXT_HELP__CRMAX  "=<value>"
+#define TXT_OPTDESCR__CRMAX             TXT_HELP__CRMAX  "=<"  TXT_OPTARGS__I32_DEC  ">"  "\n"  \
+                                        "  Maximal credit.\n"  \
+                                        "  Units depend on currently set ["  TXT_HELP__SHP_MODE  "]:\n"  \
+                                        "    [bytes]   for "  TXT_SHP_MODE__DATA_RATE    "\n"  \
+                                        "    [packets] for "  TXT_SHP_MODE__PACKET_RATE  "\n"
+
+#define TXT_OPT__TTL_DECR               TXT_HELP__TTL_DECR  "=<"  TXT_OPTARGS__ON_OFF  ">"
+#define TXT_OPTDESCR__TTL_DECR          TXT_HELP__TTL_DECR  "=<"  TXT_OPTARGS__ON_OFF  ">"  "\n"  \
+                                        "  Enable/disable TTL decrement.\n"
+
+#define TXT_OPT__DISCARD_IF_TTL_BELOW_2       TXT_HELP__DISCARD_IF_TTL_BELOW_2  "=<"  TXT_OPTARGS__ON_OFF  ">"
+#define TXT_OPTDESCR__DISCARD_IF_TTL_BELOW_2  TXT_HELP__DISCARD_IF_TTL_BELOW_2  "=<"  TXT_OPTARGS__ON_OFF  ">"  "\n"  \
+                                              "  Applicable only for interface modes which decrement TTL value of a packet.\n"  \
+                                              "  If the packet has TTL<2, then:\n"  \
+                                              "    "  TXT_ON_OFF__ON   "  : discard the packet\n"  \
+                                              "    "  TXT_ON_OFF__OFF  " : send the packet to a host\n"
+
+
+
+
+/*
+    Sanity check for opt help texts. When new opt is added, create a help text for the opt and remove its symbol from here.
+    And don't forget to check the pairing! ^_^
+*/
+#if (defined(OPT_102_TXT_HELP) || defined(OPT_103_TXT_HELP) || defined(OPT_104_TXT_HELP) || \
+     defined(OPT_105_TXT_HELP) || defined(OPT_106_TXT_HELP) || defined(OPT_107_TXT_HELP) || defined(OPT_108_TXT_HELP) || defined(OPT_109_TXT_HELP) || \
+     defined(OPT_110_TXT_HELP) || defined(OPT_111_TXT_HELP) || defined(OPT_112_TXT_HELP) || defined(OPT_113_TXT_HELP) || defined(OPT_114_TXT_HELP) || \
+     defined(OPT_115_TXT_HELP) || defined(OPT_116_TXT_HELP) || defined(OPT_117_TXT_HELP) || defined(OPT_118_TXT_HELP) || defined(OPT_119_TXT_HELP) || \
+     defined(OPT_120_TXT_HELP) || defined(OPT_121_TXT_HELP) || defined(OPT_122_TXT_HELP) || defined(OPT_123_TXT_HELP) || defined(OPT_124_TXT_HELP) || \
+     defined(OPT_125_TXT_HELP) || defined(OPT_126_TXT_HELP) || defined(OPT_127_TXT_HELP) || defined(OPT_128_TXT_HELP) || defined(OPT_129_TXT_HELP) || \
+     defined(OPT_130_TXT_HELP) || defined(OPT_131_TXT_HELP) || defined(OPT_132_TXT_HELP) || defined(OPT_133_TXT_HELP) || defined(OPT_134_TXT_HELP) || \
+     defined(OPT_135_TXT_HELP) || defined(OPT_136_TXT_HELP) || defined(OPT_137_TXT_HELP) || defined(OPT_138_TXT_HELP) || defined(OPT_139_TXT_HELP) || \
+     defined(OPT_140_TXT_HELP) || defined(OPT_141_TXT_HELP) || defined(OPT_142_TXT_HELP) || defined(OPT_143_TXT_HELP) || defined(OPT_144_TXT_HELP) || \
+     defined(OPT_145_TXT_HELP) || defined(OPT_146_TXT_HELP) || defined(OPT_147_TXT_HELP) || defined(OPT_148_TXT_HELP) || defined(OPT_149_TXT_HELP) || \
+     defined(OPT_150_TXT_HELP) || defined(OPT_151_TXT_HELP) || defined(OPT_152_TXT_HELP) || defined(OPT_153_TXT_HELP) || defined(OPT_154_TXT_HELP) || \
+     defined(OPT_155_TXT_HELP) || defined(OPT_156_TXT_HELP) || defined(OPT_157_TXT_HELP) || defined(OPT_158_TXT_HELP) || defined(OPT_159_TXT_HELP) || \
+     defined(OPT_160_TXT_HELP) || defined(OPT_161_TXT_HELP) || defined(OPT_162_TXT_HELP) || defined(OPT_163_TXT_HELP) || defined(OPT_164_TXT_HELP) || \
+     defined(OPT_165_TXT_HELP) || defined(OPT_166_TXT_HELP) || defined(OPT_167_TXT_HELP) || defined(OPT_168_TXT_HELP) || defined(OPT_169_TXT_HELP) || \
+     defined(OPT_170_TXT_HELP) || defined(OPT_171_TXT_HELP) || defined(OPT_172_TXT_HELP) || defined(OPT_173_TXT_HELP) || defined(OPT_174_TXT_HELP) || \
+     defined(OPT_175_TXT_HELP) || defined(OPT_176_TXT_HELP) || defined(OPT_177_TXT_HELP) || defined(OPT_178_TXT_HELP) || defined(OPT_179_TXT_HELP) || \
+     defined(OPT_180_TXT_HELP) || defined(OPT_181_TXT_HELP) || defined(OPT_182_TXT_HELP) || defined(OPT_183_TXT_HELP) || defined(OPT_184_TXT_HELP) || \
+     defined(OPT_185_TXT_HELP) || defined(OPT_186_TXT_HELP) || defined(OPT_187_TXT_HELP) || defined(OPT_188_TXT_HELP) || defined(OPT_189_TXT_HELP) || \
+     defined(OPT_190_TXT_HELP) || defined(OPT_191_TXT_HELP) || defined(OPT_192_TXT_HELP) || defined(OPT_193_TXT_HELP) || defined(OPT_194_TXT_HELP) || \
+     defined(OPT_195_TXT_HELP) || defined(OPT_196_TXT_HELP) || defined(OPT_197_TXT_HELP) || defined(OPT_198_TXT_HELP) || defined(OPT_199_TXT_HELP))
+#error Add help text for the new opt! (and remove the opt from this preprocessor check)
+#endif
+
+/* OPT_LAST (keep this at the bottom of the opt help text list) */
+
+/* ==== TYPEDEFS & DATA : cmd help texts =================================== */
+
+static const char *const txt_help_phyif_print[] =
+{
+    TXT_DECOR_CMD,
+    ""    "[1] phyif-print"         "   ",
+    "["   TXT_OPT__VERBOSE          "]  ",
+    "\n",
+    ""    "[2] phyif-print"         "   ",
+    "<"   TXT_OPT__INTERFACE_PHYIF  ">  ",
+    "["   TXT_OPT__VERBOSE          "]  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "[1] Print parameters of all existing physical interfaces.",
+    "\n",
+    ""    "[2] Print parameters of a selected physical interface.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__INTERFACE_PHYIF,
+    TXT_OPTDESCR__VERBOSE,
+    "\n",
+    
+    NULL
+};
+
+static const char *const txt_help_phyif_update[] =
+{
+    TXT_DECOR_CMD,
+    ""    "phyif-update"                   "   ",
+    "<"   TXT_OPT__INTERFACE_PHYIF         ">  ",
+    "[["  TXT_OPT__ENABLE_IF               "]|["  TXT_OPT__DISABLE_IF  "]]  ",
+    "["   TXT_OPT__PROMISC_PHYIF           "]  ",
+    "["   TXT_OPT__LOADBALANCE             "]  ",
+    "["   TXT_OPT__MODE                    "]  ",
+    "["   TXT_OPT__BLOCK_STATE             "]  ",
+    "["   TXT_OPT__FLEXIBLE_FILTER         "]  ",
+    "[["  TXT_OPT__MIRROR                  "]  ",
+    "["   TXT_OPT__VLAN_CONF               "]  ",
+    "["   TXT_OPT__PTP_CONF                "]  ",
+    "["   TXT_OPT__PTP_PROMISC             "]  ",
+    "["   TXT_OPT__QINQ                    "]  ",
+    "["   TXT_OPT__DISCARD_IF_TTL_BELOW_2  "]  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Update parameters of a physical interface.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__INTERFACE_PHYIF,
+    TXT_OPTDESCR__ENABLE_IF,
+    TXT_OPTDESCR__DISABLE_IF,
+    TXT_OPTDESCR__PROMISC_PHYIF,
+    TXT_OPTDESCR__LOADBALANCE,
+    TXT_OPTDESCR__MODE,
+    TXT_OPTDESCR__BLOCK_STATE,
+    TXT_OPTDESCR__FLEXIBLE_FILTER,
+    TXT_OPTDESCR__MIRROR,
+    TXT_OPTDESCR__VLAN_CONF,
+    TXT_OPTDESCR__PTP_CONF,
+    TXT_OPTDESCR__PTP_PROMISC,
+    TXT_OPTDESCR__QINQ,
+    TXT_OPTDESCR__DISCARD_IF_TTL_BELOW_2,
+    "\n",
+    
+    NULL
+};
+
+static const char *const txt_help_logif_print[] =
+{
+    TXT_DECOR_CMD,
+    ""    "[1] logif-print"         "   ",
+    "["   TXT_OPT__VERBOSE          "]  ",
+    "\n",
+    ""    "[2] logif-print"         "   ",
+    "<"   TXT_OPT__INTERFACE_LOGIF  ">  ",
+    "["   TXT_OPT__VERBOSE          "]  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "[1] Print parameters of all existing logical interfaces.",
+    "\n",
+    ""    "[2] Print parameters of a selected logical interface.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__INTERFACE_LOGIF,
+    TXT_OPTDESCR__VERBOSE,
+    "\n",
+    
+    NULL
+};
+
+static const char *const txt_help_logif_update[] =
+{
+    TXT_DECOR_CMD,
+    ""    "logif-update"             "   ",
+    "<"   TXT_OPT__INTERFACE_LOGIF   ">  ",
+    "[["  TXT_OPT__ENABLE_IF         "]|["  TXT_OPT__DISABLE_IF  "]]  ",
+    "["   TXT_OPT__PROMISC_LOGIF     "]  ",
+    "["   TXT_OPT__LOOPBACK          "]  ",
+    "["   TXT_OPT__EGRESS            "]  ",
+    "["   TXT_OPT__MATCH_MODE        "]  ",
+    "["   TXT_OPT__DISCARD_ON_MATCH  "]  ",
+    "["   TXT_OPT__MATCH_RULES       "]  ",
+    "[<rule-specific options (only if applicable)>]",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Update parameters of a logical interface."
+    "\n"
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__INTERFACE_LOGIF,
+    TXT_OPTDESCR__ENABLE_IF,
+    TXT_OPTDESCR__DISABLE_IF,
+    TXT_OPTDESCR__PROMISC_LOGIF,
+    TXT_OPTDESCR__LOOPBACK,
+    TXT_OPTDESCR__EGRESS,
+    TXT_OPTDESCR__MATCH_MODE,
+    TXT_OPTDESCR__DISCARD_ON_MATCH,
+    TXT_OPTDESCR__VLAN,
+    TXT_OPTDESCR__PROTOCOL,
+    TXT_OPTDESCR__SPORT,
+    TXT_OPTDESCR__DPORT,
+    TXT_OPTDESCR__SIP6,
+    TXT_OPTDESCR__DIP6,
+    TXT_OPTDESCR__SIP_LOGIF,
+    TXT_OPTDESCR__DIP_LOGIF,
+    TXT_OPTDESCR__ETHTYPE,
+    TXT_OPTDESCR__FP_TABLE0_LOGIF,
+    TXT_OPTDESCR__FP_TABLE1_LOGIF,
+    TXT_OPTDESCR__SMAC,
+    TXT_OPTDESCR__DMAC,
+    TXT_OPTDESCR__HIF_COOKIE,
+    TXT_OPTDESCR__MATCH_RULES,
+    "\n",
+    
+    NULL
+};
+
+static const char *const txt_help_logif_add[] =
+{
+    TXT_DECOR_CMD,
+    ""    "logif-add"               "   ",
+    "<"   TXT_OPT__INTERFACE_LOGIF  ">  ",
+    "<"   TXT_OPT__PARENT           ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Create a new logical interface."
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__INTERFACE_LOGIF,
+    TXT_OPTDESCR__PARENT,
+    "\n",
+    
+    NULL
+};
+
+static const char *const txt_help_logif_del[] =
+{
+    TXT_DECOR_CMD,
+    ""    "logif-del"               "   ",
+    "<"   TXT_OPT__INTERFACE_LOGIF  ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Destroy (delete) the target logical interface.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__INTERFACE_LOGIF,
+    "\n",
+    
+    NULL
+};
+
+static const char *const txt_help_bd_print[] =
+{
+    TXT_DECOR_CMD,
+    ""    "[1] bd-print"    "   ",
+    "["   TXT_OPT__VERBOSE  "]  ",
+    "\n",
+    ""    "[2] bd-print"    "   ",
+    "<"   TXT_OPT__VLAN_BD  ">  ",
+    "["   TXT_OPT__VERBOSE  "]  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "[1] Print parameters of all existing bridge domains.",
+    "\n",
+    ""    "[2] Print parameters of a selected bridge domain.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__VLAN_BD,
+    TXT_OPTDESCR__VERBOSE,
+    "\n",
+    
+    NULL
+};
+
+static const char *const txt_help_bd_update[] =
+{
+    TXT_DECOR_CMD,
+    ""   "bd-update"          "   ",
+    "<"  TXT_OPT__VLAN_BD     ">  ",
+    "["  TXT_OPT__UCAST_HIT   "]  ",
+    "["  TXT_OPT__UCAST_MISS  "]  ",
+    "["  TXT_OPT__MCAST_HIT   "]  ",
+    "["  TXT_OPT__MCAST_MISS  "]  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""   "Update parameters of a bridge domain.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__VLAN_BD,
+    TXT_OPTDESCR__UCAST_HIT,
+    TXT_OPTDESCR__UCAST_MISS,
+    TXT_OPTDESCR__MCAST_HIT,
+    TXT_OPTDESCR__MCAST_MISS,
+    "\n",
+    
+    NULL
+};
+
+static const char *const txt_help_bd_add[] =
+{
+    TXT_DECOR_CMD,
+    ""    "bd-add"          "   ",
+    "<"   TXT_OPT__VLAN_BD  ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Create a new bridge domain.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__VLAN_BD,
+    "\n",
+    
+    NULL
+};
+
+static const char *const txt_help_bd_del[] =
+{
+    TXT_DECOR_CMD,
+    ""    "bd-del"          "   ",
+    "<"   TXT_OPT__VLAN_BD  ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Destroy (delete) the target bridge domain.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__VLAN_BD,
+    "\n",
+    
+    NULL
+};
+
+static const char *const txt_help_bd_insif[] =
+{
+    TXT_DECOR_CMD,
+    ""    "bd-insif"                "   ",
+    "<"   TXT_OPT__VLAN_BD          ">  ",
+    "<"   TXT_OPT__INTERFACE_PHYIF  ">  ",
+    "["   TXT_OPT__TAG              "]  ",
+    "\n",
+    TXT_DECOR_DESCR
+    ""    "Insert physical interface into a bridge domain.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__VLAN_BD,
+    TXT_OPTDESCR__INTERFACE_PHYIF,
+    TXT_OPTDESCR__TAG,
+    "\n",
+    
+    NULL
+};
+
+static const char *const txt_help_bd_remif[] =
+{
+    TXT_DECOR_CMD,
+    ""    "bd-remif"                "   ",
+    "<"   TXT_OPT__VLAN_BD          ">  ",
+    "<"   TXT_OPT__INTERFACE_PHYIF  ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Remove physical interface from a bridge domain.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__VLAN_BD,
+    TXT_OPTDESCR__INTERFACE_PHYIF,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_bd_flush[] =
+{
+    TXT_DECOR_CMD,
+    ""    "[1] bd-flush"    "   ",
+    "<"   TXT_OPT__ALL      ">  ",
+    "\n",
+    ""    "[2] bd-flush"    "   ",
+    "<"   TXT_OPT__STATIC   ">  ",
+    "\n",
+    ""    "[3] bd-flush"    "   ",
+    "<"   TXT_OPT__DYNAMIC  ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "[1] Flush all MAC table entries of all bridge domains.",
+    "\n",
+    ""    "[2] Flush static MAC table entries of all bridge domains.",
+    "\n",
+    ""    "[3] Flush dynamic (learned) MAC table entries of all bridge domains.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__ALL,
+    TXT_OPTDESCR__STATIC,
+    TXT_OPTDESCR__DYNAMIC,
+    "\n",
+    
+    NULL
+};
+
+static const char *const txt_help_bd_stent_print[] =
+{
+    TXT_DECOR_CMD,
+    ""    "[1] bd-stent-print"  "   ",
+    "\n",
+    ""    "[2] bd-stent-print"  "   ",
+    "<"   TXT_OPT__VLAN_BD      ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "[1] Print all existing static entries (regardless of bridge domain affiliation).",
+    "\n",
+    ""    "[2] Print static entries associated with a particular bridge domain.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__VLAN_BD,
+    "\n",
+    
+    NULL
+};
+
+static const char *const txt_help_bd_stent_update[] =
+{
+    TXT_DECOR_CMD,
+    ""    "bd-stent-update"              "   ",
+    "<"   TXT_OPT__VLAN_BD               ">  ",
+    "<"   TXT_OPT__MAC                   ">  ",
+    "["   TXT_OPT__EGRESS                "]  ",
+    "["   TXT_OPT__LOCAL_STENT           "]  ",
+    "["   TXT_OPT__DISCARD_ON_MATCH_SRC  "]  ",
+    "["   TXT_OPT__DISCARD_ON_MATCH_DST  "]  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Update parameters of a static entry.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__VLAN_BD,
+    TXT_OPTDESCR__MAC,
+    TXT_OPTDESCR__EGRESS,
+    TXT_OPTDESCR__LOCAL_STENT,
+    TXT_OPTDESCR__DISCARD_ON_MATCH_SRC,
+    TXT_OPTDESCR__DISCARD_ON_MATCH_DST,
+    "\n",
+    
+    NULL
+};
+
+static const char *const txt_help_bd_stent_add[] =
+{
+    TXT_DECOR_CMD,
+    ""    "bd-stent-add"    "   ",
+    "<"   TXT_OPT__VLAN_BD  ">  ",
+    "<"   TXT_OPT__MAC      ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Create a new static entry.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__VLAN_BD,
+    TXT_OPTDESCR__MAC,
+    "\n",
+    
+    NULL
+};
+
+static const char *const txt_help_bd_stent_del[] =
+{
+    TXT_DECOR_CMD,
+    ""    "bd-stent-del"    "   ",
+    "<"   TXT_OPT__VLAN_BD  ">  ",
+    "<"   TXT_OPT__MAC      ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Destroy (delete) the target static entry.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__VLAN_BD,
+    TXT_OPTDESCR__MAC,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_fptable_print[] =
+{
+    TXT_DECOR_CMD,
+    ""    "fptable-print"          "   ",
+    "<"   TXT_OPT__FP_TABLE        ">  ",
+    "["   TXT_OPT__POSITION_PRINT  "]  ",
+    "["   TXT_OPT__COUNT_PRINT     "]  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Print content of a FlexibleParser table.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__FP_TABLE,
+    TXT_OPTDESCR__POSITION_PRINT,
+    TXT_OPTDESCR__COUNT_PRINT,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_fptable_add[] =
+{
+    TXT_DECOR_CMD,
+    ""    "fptable-add"      "   ",
+    "<"   TXT_OPT__FP_TABLE  ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Create a new FlexibleParser table.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__FP_TABLE,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_fptable_del[] =
+{
+    TXT_DECOR_CMD,
+    ""    "fptable-del"      "   ",
+    "<"   TXT_OPT__FP_TABLE  ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Destroy (delete) the target FlexibleParser table.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__FP_TABLE,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_fptable_insrule[] =
+{
+    TXT_DECOR_CMD,
+    ""    "fptable-insrule"         "   ",
+    "<"   TXT_OPT__FP_TABLE         ">  ",
+    "<"   TXT_OPT__FP_RULE          ">  ",
+    "["   TXT_OPT__POSITION_INSADD  "]  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Insert FlexibleParser rule into a FlexibleParser table.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__FP_TABLE,
+    TXT_OPTDESCR__FP_RULE,
+    TXT_OPTDESCR__POSITION_INSADD,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_fptable_remrule[] =
+{
+    TXT_DECOR_CMD,
+    ""    "fptable-remrule"   "   ",
+    "<"   TXT_OPT__FP_TABLE   ">  ",
+    "<"   TXT_OPT__FP_RULE    ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Remove FlexibleParser rule from a FlexibleParser table.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__FP_TABLE,
+    TXT_OPTDESCR__FP_RULE,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_fprule_print[] =
+{
+    TXT_DECOR_CMD,
+    ""    "[1] fprule-print"       "   ",
+    "["   TXT_OPT__POSITION_PRINT  "]  ",
+    "["   TXT_OPT__COUNT_PRINT     "]  ",
+    "\n",
+    ""    "[2] fprule-print"       "   ",
+    "<"   TXT_OPT__FP_RULE         ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "[1] Print all existing FlexibleParser rules (regardless of table affiliation).",
+    "\n",
+    ""    "[2] Print a selected FlexibleParser rule.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__FP_RULE,
+    TXT_OPTDESCR__POSITION_PRINT,
+    TXT_OPTDESCR__COUNT_PRINT,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_fprule_add[] =
+{
+    TXT_DECOR_CMD,
+    ""    "fprule-add"         "   ",
+    "<"   TXT_OPT__FP_RULE     ">  ",
+    "<"   TXT_OPT__DATA        ">  ",
+    "<"   TXT_OPT__MASK        ">  ",
+    "<"   TXT_OPT__OFFSET_FP   ">  ",
+    "<"   TXT_OPT__LAYER       ">  ",
+    "["   TXT_OPT__INVERT_FP   "]  ",
+    "<<"  TXT_OPT__ACCEPT_FP   ">|<"  TXT_OPT__REJECT_FP  ">|<"  TXT_OPT__FP_NEXT_RULE  ">>  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Create a new FlexibleParser rule."
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__FP_RULE,
+    TXT_OPTDESCR__DATA,
+    TXT_OPTDESCR__MASK,
+    TXT_OPTDESCR__OFFSET_FP,
+    TXT_OPTDESCR__LAYER,
+    TXT_OPTDESCR__INVERT_FP,
+    TXT_OPTDESCR__ACCEPT_FP,
+    TXT_OPTDESCR__REJECT_FP,
+    TXT_OPTDESCR__FP_NEXT_RULE,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_fprule_del[] =
+{
+    TXT_DECOR_CMD,
+    ""    "fprule-del"      "   ",
+    "<"   TXT_OPT__FP_RULE  ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Destroy (delete) the target FlexibleParser rule.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__FP_RULE,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_route_print[] =
+{
+    TXT_DECOR_CMD,
+    ""    "[1] route-print"  "   ",
+    "\n",
+    ""    "[2] route-print"  "   ",
+    "<"   TXT_OPT__IP4       ">  ",
+    "\n",
+    ""    "[3] route-print"  "   ",
+    "<"   TXT_OPT__IP6       ">  ",
+    "\n",
+    ""    "[4] route-print"  "   ",
+    "<"   TXT_OPT__ROUTE     ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "[1] Print parameters of all routes.",
+    "\n",
+    ""    "[2] Print parameters of all IPv4 routes.",
+    "\n",
+    ""    "[3] Print parameters of all IPv6 routes.",
+    "\n",
+    ""    "[4] Print parameters of a selected route.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__IP4,
+    TXT_OPTDESCR__IP6,
+    TXT_OPTDESCR__ROUTE,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_route_add[] =
+{
+    TXT_DECOR_CMD,
+    ""    "route-add"               "   ",
+    "<"   TXT_OPT__ROUTE            ">  ",
+    "<<"  TXT_OPT__IP4              ">|<"  TXT_OPT__IP6  ">  ",
+    "<"   TXT_OPT__DMAC             ">  ",
+    "<"   TXT_OPT__INTERFACE_PHYIF  ">  ",
+    "["   TXT_OPT__SMAC             "]  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Create a new route.",
+    "\n"
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__ROUTE,
+    TXT_OPTDESCR__IP4,
+    TXT_OPTDESCR__IP6,
+    TXT_OPTDESCR__DMAC,
+    TXT_OPTDESCR__INTERFACE_PHYIF,
+    TXT_OPTDESCR__SMAC,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_route_del[] =
+{
+    TXT_DECOR_CMD,
+    ""    "route-del"     "   ",
+    "<"   TXT_OPT__ROUTE  ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Destroy the target route.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__ROUTE,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_cntk_print[] =
+{
+    TXT_DECOR_CMD,
+    ""    "[1] cntk_print"  "   ",
+    "\n",
+    ""    "[2] cntk-print"  "   ",
+    "<"   TXT_OPT__IP4      ">  ",
+    "\n",
+    ""    "[3] cntk-print"  "   ",
+    "<"   TXT_OPT__IP6      ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "[1] Print parameters of all conntracks.",
+    "\n",
+    ""    "[2] Print parameters of all IPv4 conntracks.",
+    "\n",
+    ""    "[3] Print parameters of all IPv6 conntracks.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__IP4,
+    TXT_OPTDESCR__IP6,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_cntk_update[] =
+{
+    TXT_DECOR_CMD,
+    ""    "cntk-update"      "   ",
+    "<"   TXT_OPT__PROTOCOL  ">  ",
+    "<"   TXT_OPT__SIP       ">  ",
+    "<"   TXT_OPT__DIP       ">  ",
+    "<"   TXT_OPT__SPORT     ">  ",
+    "<"   TXT_OPT__DPORT     ">  ",
+    "["   TXT_OPT__TTL_DECR  "]  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Update parameters of a conntrack. Only TTL decrement flag can be updated.\n",
+    ""    "(the other parameters are used to identify the target conntrack)",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__PROTOCOL,
+    TXT_OPTDESCR__SIP,
+    TXT_OPTDESCR__DIP,
+    TXT_OPTDESCR__SPORT,
+    TXT_OPTDESCR__DPORT,
+    TXT_OPTDESCR__TTL_DECR,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_cntk_add[] =
+{
+    TXT_DECOR_CMD,
+    ""    "[1] cntk-add"      "   ",
+    "<"   TXT_OPT__PROTOCOL   ">  ",
+    "<"   TXT_OPT__SIP        ">  ",
+    "<"   TXT_OPT__DIP        ">  ",
+    "<"   TXT_OPT__SPORT      ">  ",
+    "<"   TXT_OPT__DPORT      ">  ",
+    "<"   TXT_OPT__ROUTE      ">  ",
+    "["   TXT_OPT__VLAN       "]  ",
+    "["   TXT_OPT__TTL_DECR   "]  ",
+    "[["  TXT_OPT__NO_REPLY   "]|["  TXT_OPT__NO_ORIG  "]  ",
+    "\n",
+    ""    "[2] cntk-add"      "   ",
+    "<"   TXT_OPT__PROTOCOL   ">  ",
+    "<"   TXT_OPT__SIP        ">  ",
+    "["   TXT_OPT__R_SIP      "]  ",
+    "<"   TXT_OPT__DIP        ">  ",
+    "["   TXT_OPT__R_DIP      "]  ",
+    "<"   TXT_OPT__SPORT      ">  ",
+    "["   TXT_OPT__R_SPORT    "]  ",
+    "<"   TXT_OPT__DPORT      ">  ",
+    "["   TXT_OPT__R_DPORT    "]  ",
+    "<"   TXT_OPT__ROUTE      ">  ",
+    "["   TXT_OPT__R_ROUTE    "]  ",
+    "["   TXT_OPT__VLAN       "]  ",
+    "["   TXT_OPT__R_VLAN     "]  ",
+    "["   TXT_OPT__TTL_DECR   "]  ",
+    "[["  TXT_OPT__NO_REPLY   "]|["  TXT_OPT__NO_ORIG  "]  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "[1] Create a new simple conntrack.\n"
+    ""    "    Supplied IP addresses must be either all IPv4, or all IPv6."
+    "\n",
+    ""    "[2] Create a new conntrack with NAT and/or PAT.\n"
+    ""    "    Supplied IP addresses must be either all IPv4, or all IPv6."
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__PROTOCOL,
+    TXT_OPTDESCR__SIP,
+    TXT_OPTDESCR__R_SIP,
+    TXT_OPTDESCR__DIP,
+    TXT_OPTDESCR__R_DIP,
+    TXT_OPTDESCR__SPORT,
+    TXT_OPTDESCR__R_SPORT,
+    TXT_OPTDESCR__DPORT,
+    TXT_OPTDESCR__R_DPORT,
+    TXT_OPTDESCR__ROUTE,
+    TXT_OPTDESCR__R_ROUTE,
+    TXT_OPTDESCR__VLAN,
+    TXT_OPTDESCR__R_VLAN,
+    TXT_OPTDESCR__TTL_DECR,
+    TXT_OPTDESCR__NO_REPLY,
+    TXT_OPTDESCR__NO_ORIG,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_cntk_del[] =
+{
+    TXT_DECOR_CMD,
+    ""    "cntk-del"         "   ",
+    "<"   TXT_OPT__PROTOCOL  ">  ",
+    "<"   TXT_OPT__SIP       ">  ",
+    "<"   TXT_OPT__DIP       ">  ",
+    "<"   TXT_OPT__SPORT     ">  ",
+    "<"   TXT_OPT__DPORT     ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Destroy the target conntrack.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__PROTOCOL,
+    TXT_OPTDESCR__SIP,
+    TXT_OPTDESCR__DIP,
+    TXT_OPTDESCR__SPORT,
+    TXT_OPTDESCR__DPORT,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_cntk_timeout[] =
+{
+    TXT_DECOR_CMD,
+    ""    "cntk-timeout"             "   ",
+    "<"   TXT_OPT__PROTOCOL_CNTKTMO  ">  ",
+    "<"   TXT_OPT__TIMEOUT_CNTKTMO   ">  ",
+    "["   TXT_OPT__TIMEOUT2_CNTKTMO  "]  ",
+    "["   TXT_OPT__4o6               "]  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    "Set timeout of IPv4 conntracks.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__PROTOCOL_CNTKTMO,
+    TXT_OPTDESCR__TIMEOUT_CNTKTMO,
+    TXT_OPTDESCR__TIMEOUT2_CNTKTMO,
+    TXT_OPTDESCR__4o6,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_route_and_cntk_reset[] =
+{
+    TXT_DECOR_CMD,
+    ""    "[1] route-and-cntk-reset"  "   ",
+    "<"   TXT_OPT__ALL                ">  ",
+    "\n",
+    ""    "[2] route-and-cntk-reset"  "   ",
+    "<"   TXT_OPT__IP4                ">  ",
+    "\n",
+    ""    "[3] route-and-cntk-reset"  "   ",
+    "<"   TXT_OPT__IP6                ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "[1] Reset (clear) all routes & conntracks.",
+    "\n",
+    ""    "[2] Reset (clear) only IPv4 routes & conntracks.",
+    "\n",
+    ""    "[3] Reset (clear) only IPv6 routes & conntracks.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__ALL,
+    TXT_OPTDESCR__IP4,
+    TXT_OPTDESCR__IP6,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_spd_print[] =
+{
+    TXT_DECOR_CMD,
+    ""    "spd-print"               "   ",
+    "<"   TXT_OPT__INTERFACE_PHYIF  ">  ",
+    "["   TXT_OPT__POSITION_PRINT   "]  ",
+    "["   TXT_OPT__COUNT_PRINT      "]  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Print all SecurityPolicies of the given physical interface.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__INTERFACE_PHYIF,
+    TXT_OPTDESCR__POSITION_PRINT,
+    TXT_OPTDESCR__COUNT_PRINT,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_spd_add[] =
+{
+    TXT_DECOR_CMD,
+    ""    "spd-add"                 "   ",
+    "<"   TXT_OPT__INTERFACE_PHYIF  ">  ",
+    "<"   TXT_OPT__PROTOCOL         ">  ",
+    "<"   TXT_OPT__SIP              ">  ",
+    "<"   TXT_OPT__DIP              ">  ",
+    "["   TXT_OPT__SPORT            "]  ",
+    "["   TXT_OPT__DPORT            "]  ",
+    "["   TXT_OPT__POSITION_INSADD  "]  ",
+    "<"   TXT_OPT__SPD_ACTION       ">  ",
+    "[<action-specific options (only if applicable)>]",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Create a new SecurityPolicy and insert it into SPD of the given physical interface.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__INTERFACE_PHYIF,
+    TXT_OPTDESCR__PROTOCOL,
+    TXT_OPTDESCR__SIP,
+    TXT_OPTDESCR__DIP,
+    TXT_OPTDESCR__SPORT,
+    TXT_OPTDESCR__DPORT,
+    TXT_OPTDESCR__POSITION_INSADD,
+    TXT_OPTDESCR__SAD,
+    TXT_OPTDESCR__SPI,
+    TXT_OPTDESCR__SPD_ACTION,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_spd_del[] =
+{
+    TXT_DECOR_CMD,
+    ""    "spd-del"                 "   ",
+    "<"   TXT_OPT__INTERFACE_PHYIF  ">  ",
+    "<"   TXT_OPT__POSITION_REMDEL  ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Destroy the target SecurityPolicy and remove it from SPD of the given physical interface.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__INTERFACE_PHYIF,
+    TXT_OPTDESCR__POSITION_REMDEL,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_fwfeat_print[] =
+{
+    TXT_DECOR_CMD,
+    ""    "[1] fwfeat-print"   "   ",
+    "\n",
+    ""    "[2] fwfeat-print"   "   ",
+    "<"   TXT_OPT__FEATURE_FW  ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "[1] Print all existing FW features.",
+    "\n",
+    ""    "[2] Print a selected FW feature.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__FEATURE_FW,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_fwfeat_set[] =
+{
+    TXT_DECOR_CMD,
+    ""    "fwfeat-set"         "   ",
+    "<"   TXT_OPT__FEATURE_FW  ">  ",
+    "<<"  TXT_OPT__ENABLE_FW   ">|<"  TXT_OPT__DISABLE_FW  ">>  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Enable or disable a FW feature.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__FEATURE_FW,
+    TXT_OPTDESCR__ENABLE_FW,
+    TXT_OPTDESCR__DISABLE_FW,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_qos_que_print[] =
+{
+    TXT_DECOR_CMD,
+    ""    "[1] qos-que-print"       "   ",
+    "<"   TXT_OPT__INTERFACE_PHYIF  ">  ",
+    "\n",
+    ""    "[2] qos-que-print"       "   ",
+    "<"   TXT_OPT__INTERFACE_PHYIF  ">  ",
+    "["   TXT_OPT__QUE              "]  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "[1] Print all QoS queues of the given physical interface.",
+    "\n",
+    ""    "[2] Print a selected QoS queue of the given physical interface.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__INTERFACE_PHYIF,
+    TXT_OPTDESCR__QUE,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_qos_que_update[] =
+{
+    TXT_DECOR_CMD,
+    ""    "qos-que-update"          "   ",
+    "<"   TXT_OPT__INTERFACE_PHYIF  ">  ",
+    "<"   TXT_OPT__QUE              ">  ",
+    "["   TXT_OPT__QUE_MODE         "]  ",
+    "["   TXT_OPT__THMIN            "]  ",
+    "["   TXT_OPT__THMAX            "]  ",
+    "["   TXT_OPT__ZPROB            "]  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Update parameters of a QoS queue.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__INTERFACE_PHYIF,
+    TXT_OPTDESCR__QUE,
+    TXT_OPTDESCR__QUE_MODE,
+    TXT_OPTDESCR__THMIN,
+    TXT_OPTDESCR__THMAX,
+    TXT_OPTDESCR__ZPROB,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_qos_sch_print[] =
+{
+    TXT_DECOR_CMD,
+    ""    "[1] qos-sch-print"       "   ",
+    "<"   TXT_OPT__INTERFACE_PHYIF  ">  ",
+    "\n",
+    ""    "[2] qos-sch-print"       "   ",
+    "<"   TXT_OPT__INTERFACE_PHYIF  ">  ",
+    "["   TXT_OPT__SCH              "]  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "[1] Print all QoS schedulers of the given physical interface.",
+    "\n",
+    ""    "[2] Print a selected QoS scheduler of the given physical interface.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__INTERFACE_PHYIF,
+    TXT_OPTDESCR__SCH,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_qos_sch_update[] =
+{
+    TXT_DECOR_CMD,
+    ""    "qos-sch-update"          "   ",
+    "<"   TXT_OPT__INTERFACE_PHYIF  ">  ",
+    "<"   TXT_OPT__SCH              ">  ",
+    "["   TXT_OPT__SCH_MODE         "]  ",
+    "["   TXT_OPT__SCH_ALGO         "]  ",
+    "["   TXT_OPT__SCH_IN           "]  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Update parameters of a QoS scheduler.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__INTERFACE_PHYIF,
+    TXT_OPTDESCR__SCH,
+    TXT_OPTDESCR__SCH_MODE,
+    TXT_OPTDESCR__SCH_ALGO,
+    TXT_OPTDESCR__SCH_IN,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_qos_shp_print[] =
+{
+    TXT_DECOR_CMD,
+    ""    "[1] qos-shp-print"       "   ",
+    "<"   TXT_OPT__INTERFACE_PHYIF  ">  ",
+    "\n",
+    ""    "[2] qos-shp-print"       "   ",
+    "<"   TXT_OPT__INTERFACE_PHYIF  ">  ",
+    "["   TXT_OPT__SHP              "]  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "[1] Print all QoS shapers of the given physical interface.",
+    "\n",
+    ""    "[2] Print a selected QoS shaper of the given physical interface.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__INTERFACE_PHYIF,
+    TXT_OPTDESCR__SHP,
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_qos_shp_update[] =
+{
+    TXT_DECOR_CMD,
+    ""    "qos-shp-update"          "   ",
+    "<"   TXT_OPT__INTERFACE_PHYIF  ">  ",
+    "<"   TXT_OPT__SHP              ">  ",
+    "["   TXT_OPT__SHP_MODE         "]  ",
+    "["   TXT_OPT__SHP_POS          "]  ",
+    "["   TXT_OPT__ISL              "]  ",
+    "["   TXT_OPT__CRMIN            "]  ",
+    "["   TXT_OPT__CRMAX            "]  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Update parameters of a QoS shaper.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__INTERFACE_PHYIF,
+    TXT_OPTDESCR__SHP,
+    TXT_OPTDESCR__SHP_MODE,
+    TXT_OPTDESCR__SHP_POS,
+    TXT_OPTDESCR__ISL,
+    TXT_OPTDESCR__CRMIN,
+    TXT_OPTDESCR__CRMAX,
+    "\n",
+    
+    NULL
+};
+
+
+
+
+
+
+
+
+/* CMD_LAST (keep this at the bottom of the cmd help text list) */
+
+/* special case of text array - list all available cmds */
+static const char *const txt_help_no_command[] =
+{
+  /* CMD_00_NO_COMMAND */
+  "General help\n"
+  "------------\n"
+  "Run the app with '<command> --help' to get a detailed info (and a list of valid options) for the given command.\n"
+  "Command list:\n",
+
+#ifdef CMD_01_ENUM_NAME
+ "  "  CMD_01_CLI_TXT  "\n",
+#endif
+#ifdef CMD_02_ENUM_NAME
+ "  "  CMD_02_CLI_TXT  "\n",
+#endif
+#ifdef CMD_03_ENUM_NAME
+ "  "  CMD_03_CLI_TXT  "\n",
+#endif
+#ifdef CMD_04_ENUM_NAME
+ "  "  CMD_04_CLI_TXT  "\n",
+#endif
+#ifdef CMD_05_ENUM_NAME
+ "  "  CMD_05_CLI_TXT  "\n",
+#endif
+#ifdef CMD_06_ENUM_NAME
+ "  "  CMD_06_CLI_TXT  "\n",
+#endif
+#ifdef CMD_07_ENUM_NAME
+ "  "  CMD_07_CLI_TXT  "\n",
+#endif
+#ifdef CMD_08_ENUM_NAME
+ "  "  CMD_08_CLI_TXT  "\n",
+#endif
+#ifdef CMD_09_ENUM_NAME
+ "  "  CMD_09_CLI_TXT  "\n",
+#endif
+
+#ifdef CMD_10_ENUM_NAME
+ "  "  CMD_10_CLI_TXT  "\n",
+#endif
+#ifdef CMD_11_ENUM_NAME
+ "  "  CMD_11_CLI_TXT  "\n",
+#endif
+#ifdef CMD_12_ENUM_NAME
+ "  "  CMD_12_CLI_TXT  "\n",
+#endif
+#ifdef CMD_13_ENUM_NAME
+ "  "  CMD_13_CLI_TXT  "\n",
+#endif
+#ifdef CMD_14_ENUM_NAME
+ "  "  CMD_14_CLI_TXT  "\n",
+#endif
+#ifdef CMD_15_ENUM_NAME
+ "  "  CMD_15_CLI_TXT  "\n",
+#endif
+#ifdef CMD_16_ENUM_NAME
+ "  "  CMD_16_CLI_TXT  "\n",
+#endif
+#ifdef CMD_17_ENUM_NAME
+ "  "  CMD_17_CLI_TXT  "\n",
+#endif
+#ifdef CMD_18_ENUM_NAME
+ "  "  CMD_18_CLI_TXT  "\n",
+#endif
+#ifdef CMD_19_ENUM_NAME
+ "  "  CMD_19_CLI_TXT  "\n",
+#endif
+
+#ifdef CMD_20_ENUM_NAME
+ "  "  CMD_20_CLI_TXT  "\n",
+#endif
+#ifdef CMD_21_ENUM_NAME
+ "  "  CMD_21_CLI_TXT  "\n",
+#endif
+#ifdef CMD_22_ENUM_NAME
+ "  "  CMD_22_CLI_TXT  "\n",
+#endif
+#ifdef CMD_23_ENUM_NAME
+ "  "  CMD_23_CLI_TXT  "\n",
+#endif
+#ifdef CMD_24_ENUM_NAME
+ "  "  CMD_24_CLI_TXT  "\n",
+#endif
+#ifdef CMD_25_ENUM_NAME
+ "  "  CMD_25_CLI_TXT  "\n",
+#endif
+#ifdef CMD_26_ENUM_NAME
+ "  "  CMD_26_CLI_TXT  "\n",
+#endif
+#ifdef CMD_27_ENUM_NAME
+ "  "  CMD_27_CLI_TXT  "\n",
+#endif
+#ifdef CMD_28_ENUM_NAME
+ "  "  CMD_28_CLI_TXT  "\n",
+#endif
+#ifdef CMD_29_ENUM_NAME
+ "  "  CMD_29_CLI_TXT  "\n",
+#endif
+
+#ifdef CMD_30_ENUM_NAME
+ "  "  CMD_30_CLI_TXT  "\n",
+#endif
+#ifdef CMD_31_ENUM_NAME
+ "  "  CMD_31_CLI_TXT  "\n",
+#endif
+#ifdef CMD_32_ENUM_NAME
+ "  "  CMD_32_CLI_TXT  "\n",
+#endif
+#ifdef CMD_33_ENUM_NAME
+ "  "  CMD_33_CLI_TXT  "\n",
+#endif
+#ifdef CMD_34_ENUM_NAME
+ "  "  CMD_34_CLI_TXT  "\n",
+#endif
+#ifdef CMD_35_ENUM_NAME
+ "  "  CMD_35_CLI_TXT  "\n",
+#endif
+#ifdef CMD_36_ENUM_NAME
+ "  "  CMD_36_CLI_TXT  "\n",
+#endif
+#ifdef CMD_37_ENUM_NAME
+ "  "  CMD_37_CLI_TXT  "\n",
+#endif
+#ifdef CMD_38_ENUM_NAME
+ "  "  CMD_38_CLI_TXT  "\n",
+#endif
+#ifdef CMD_39_ENUM_NAME
+ "  "  CMD_39_CLI_TXT  "\n",
+#endif
+
+#ifdef CMD_40_ENUM_NAME
+ "  "  CMD_40_CLI_TXT  "\n",
+#endif
+#ifdef CMD_41_ENUM_NAME
+ "  "  CMD_41_CLI_TXT  "\n",
+#endif
+#ifdef CMD_42_ENUM_NAME
+ "  "  CMD_42_CLI_TXT  "\n",
+#endif
+#ifdef CMD_43_ENUM_NAME
+ "  "  CMD_43_CLI_TXT  "\n",
+#endif
+#ifdef CMD_44_ENUM_NAME
+ "  "  CMD_44_CLI_TXT  "\n",
+#endif
+#ifdef CMD_45_ENUM_NAME
+ "  "  CMD_45_CLI_TXT  "\n",
+#endif
+#ifdef CMD_46_ENUM_NAME
+ "  "  CMD_46_CLI_TXT  "\n",
+#endif
+#ifdef CMD_47_ENUM_NAME
+ "  "  CMD_47_CLI_TXT  "\n",
+#endif
+#ifdef CMD_48_ENUM_NAME
+ "  "  CMD_48_CLI_TXT  "\n",
+#endif
+#ifdef CMD_49_ENUM_NAME
+ "  "  CMD_49_CLI_TXT  "\n",
+#endif
+
+#ifdef CMD_50_ENUM_NAME
+ "  "  CMD_50_CLI_TXT  "\n",
+#endif
+#ifdef CMD_51_ENUM_NAME
+ "  "  CMD_51_CLI_TXT  "\n",
+#endif
+#ifdef CMD_52_ENUM_NAME
+ "  "  CMD_52_CLI_TXT  "\n",
+#endif
+#ifdef CMD_53_ENUM_NAME
+ "  "  CMD_53_CLI_TXT  "\n",
+#endif
+#ifdef CMD_54_ENUM_NAME
+ "  "  CMD_54_CLI_TXT  "\n",
+#endif
+#ifdef CMD_55_ENUM_NAME
+ "  "  CMD_55_CLI_TXT  "\n",
+#endif
+#ifdef CMD_56_ENUM_NAME
+ "  "  CMD_56_CLI_TXT  "\n",
+#endif
+#ifdef CMD_57_ENUM_NAME
+ "  "  CMD_57_CLI_TXT  "\n",
+#endif
+#ifdef CMD_58_ENUM_NAME
+ "  "  CMD_58_CLI_TXT  "\n",
+#endif
+#ifdef CMD_59_ENUM_NAME
+ "  "  CMD_59_CLI_TXT  "\n",
+#endif
+
+#ifdef CMD_60_ENUM_NAME
+ "  "  CMD_60_CLI_TXT  "\n",
+#endif
+#ifdef CMD_61_ENUM_NAME
+ "  "  CMD_61_CLI_TXT  "\n",
+#endif
+#ifdef CMD_62_ENUM_NAME
+ "  "  CMD_62_CLI_TXT  "\n",
+#endif
+#ifdef CMD_63_ENUM_NAME
+ "  "  CMD_63_CLI_TXT  "\n",
+#endif
+#ifdef CMD_64_ENUM_NAME
+ "  "  CMD_64_CLI_TXT  "\n",
+#endif
+#ifdef CMD_65_ENUM_NAME
+ "  "  CMD_65_CLI_TXT  "\n",
+#endif
+#ifdef CMD_66_ENUM_NAME
+ "  "  CMD_66_CLI_TXT  "\n",
+#endif
+#ifdef CMD_67_ENUM_NAME
+ "  "  CMD_67_CLI_TXT  "\n",
+#endif
+#ifdef CMD_68_ENUM_NAME
+ "  "  CMD_68_CLI_TXT  "\n",
+#endif
+#ifdef CMD_69_ENUM_NAME
+ "  "  CMD_69_CLI_TXT  "\n",
+#endif
+
+#ifdef CMD_70_ENUM_NAME
+ "  "  CMD_70_CLI_TXT  "\n",
+#endif
+#ifdef CMD_71_ENUM_NAME
+ "  "  CMD_71_CLI_TXT  "\n",
+#endif
+#ifdef CMD_72_ENUM_NAME
+ "  "  CMD_72_CLI_TXT  "\n",
+#endif
+#ifdef CMD_73_ENUM_NAME
+ "  "  CMD_73_CLI_TXT  "\n",
+#endif
+#ifdef CMD_74_ENUM_NAME
+ "  "  CMD_74_CLI_TXT  "\n",
+#endif
+#ifdef CMD_75_ENUM_NAME
+ "  "  CMD_75_CLI_TXT  "\n",
+#endif
+#ifdef CMD_76_ENUM_NAME
+ "  "  CMD_76_CLI_TXT  "\n",
+#endif
+#ifdef CMD_77_ENUM_NAME
+ "  "  CMD_77_CLI_TXT  "\n",
+#endif
+#ifdef CMD_78_ENUM_NAME
+ "  "  CMD_78_CLI_TXT  "\n",
+#endif
+#ifdef CMD_79_ENUM_NAME
+ "  "  CMD_79_CLI_TXT  "\n",
+#endif
+
+#ifdef CMD_80_ENUM_NAME
+ "  "  CMD_80_CLI_TXT  "\n",
+#endif
+#ifdef CMD_81_ENUM_NAME
+ "  "  CMD_81_CLI_TXT  "\n",
+#endif
+#ifdef CMD_82_ENUM_NAME
+ "  "  CMD_82_CLI_TXT  "\n",
+#endif
+#ifdef CMD_83_ENUM_NAME
+ "  "  CMD_83_CLI_TXT  "\n",
+#endif
+#ifdef CMD_84_ENUM_NAME
+ "  "  CMD_84_CLI_TXT  "\n",
+#endif
+#ifdef CMD_85_ENUM_NAME
+ "  "  CMD_85_CLI_TXT  "\n",
+#endif
+#ifdef CMD_86_ENUM_NAME
+ "  "  CMD_86_CLI_TXT  "\n",
+#endif
+#ifdef CMD_87_ENUM_NAME
+ "  "  CMD_87_CLI_TXT  "\n",
+#endif
+#ifdef CMD_88_ENUM_NAME
+ "  "  CMD_88_CLI_TXT  "\n",
+#endif
+#ifdef CMD_89_ENUM_NAME
+ "  "  CMD_89_CLI_TXT  "\n",
+#endif
+
+#ifdef CMD_90_ENUM_NAME
+ "  "  CMD_90_CLI_TXT  "\n",
+#endif
+#ifdef CMD_91_ENUM_NAME
+ "  "  CMD_91_CLI_TXT  "\n",
+#endif
+#ifdef CMD_92_ENUM_NAME
+ "  "  CMD_92_CLI_TXT  "\n",
+#endif
+#ifdef CMD_93_ENUM_NAME
+ "  "  CMD_93_CLI_TXT  "\n",
+#endif
+#ifdef CMD_94_ENUM_NAME
+ "  "  CMD_94_CLI_TXT  "\n",
+#endif
+#ifdef CMD_95_ENUM_NAME
+ "  "  CMD_95_CLI_TXT  "\n",
+#endif
+#ifdef CMD_96_ENUM_NAME
+ "  "  CMD_96_CLI_TXT  "\n",
+#endif
+#ifdef CMD_97_ENUM_NAME
+ "  "  CMD_97_CLI_TXT  "\n",
+#endif
+#ifdef CMD_98_ENUM_NAME
+ "  "  CMD_98_CLI_TXT  "\n",
+#endif
+#ifdef CMD_99_ENUM_NAME
+ "  "  CMD_99_CLI_TXT  "\n",
+#endif
+
+    "\n",
+    NULL
+};
+
+
+/* array of help texts (indexed by 'cmd_t') */
+static const char *const *const txt_helps[] = 
+{
+    txt_help_no_command,  /* CMD_00_NO_COMMAND */
+    
+#ifdef CMD_01_ENUM_NAME
+       CMD_01_HELP,
+#endif
+#ifdef CMD_02_ENUM_NAME
+       CMD_02_HELP,
+#endif
+#ifdef CMD_03_ENUM_NAME
+       CMD_03_HELP,
+#endif
+#ifdef CMD_04_ENUM_NAME
+       CMD_04_HELP,
+#endif
+#ifdef CMD_05_ENUM_NAME
+       CMD_05_HELP,
+#endif
+#ifdef CMD_06_ENUM_NAME
+       CMD_06_HELP,
+#endif
+#ifdef CMD_07_ENUM_NAME
+       CMD_07_HELP,
+#endif
+#ifdef CMD_08_ENUM_NAME
+       CMD_08_HELP,
+#endif
+#ifdef CMD_09_ENUM_NAME
+       CMD_09_HELP,
+#endif
+
+#ifdef CMD_10_ENUM_NAME
+       CMD_10_HELP,
+#endif
+#ifdef CMD_11_ENUM_NAME
+       CMD_11_HELP,
+#endif
+#ifdef CMD_12_ENUM_NAME
+       CMD_12_HELP,
+#endif
+#ifdef CMD_13_ENUM_NAME
+       CMD_13_HELP,
+#endif
+#ifdef CMD_14_ENUM_NAME
+       CMD_14_HELP,
+#endif
+#ifdef CMD_15_ENUM_NAME
+       CMD_15_HELP,
+#endif
+#ifdef CMD_16_ENUM_NAME
+       CMD_16_HELP,
+#endif
+#ifdef CMD_17_ENUM_NAME
+       CMD_17_HELP,
+#endif
+#ifdef CMD_18_ENUM_NAME
+       CMD_18_HELP,
+#endif
+#ifdef CMD_19_ENUM_NAME
+       CMD_19_HELP,
+#endif
+
+#ifdef CMD_20_ENUM_NAME
+       CMD_20_HELP,
+#endif
+#ifdef CMD_21_ENUM_NAME
+       CMD_21_HELP,
+#endif
+#ifdef CMD_22_ENUM_NAME
+       CMD_22_HELP,
+#endif
+#ifdef CMD_23_ENUM_NAME
+       CMD_23_HELP,
+#endif
+#ifdef CMD_24_ENUM_NAME
+       CMD_24_HELP,
+#endif
+#ifdef CMD_25_ENUM_NAME
+       CMD_25_HELP,
+#endif
+#ifdef CMD_26_ENUM_NAME
+       CMD_26_HELP,
+#endif
+#ifdef CMD_27_ENUM_NAME
+       CMD_27_HELP,
+#endif
+#ifdef CMD_28_ENUM_NAME
+       CMD_28_HELP,
+#endif
+#ifdef CMD_29_ENUM_NAME
+       CMD_29_HELP,
+#endif
+
+#ifdef CMD_30_ENUM_NAME
+       CMD_30_HELP,
+#endif
+#ifdef CMD_31_ENUM_NAME
+       CMD_31_HELP,
+#endif
+#ifdef CMD_32_ENUM_NAME
+       CMD_32_HELP,
+#endif
+#ifdef CMD_33_ENUM_NAME
+       CMD_33_HELP,
+#endif
+#ifdef CMD_34_ENUM_NAME
+       CMD_34_HELP,
+#endif
+#ifdef CMD_35_ENUM_NAME
+       CMD_35_HELP,
+#endif
+#ifdef CMD_36_ENUM_NAME
+       CMD_36_HELP,
+#endif
+#ifdef CMD_37_ENUM_NAME
+       CMD_37_HELP,
+#endif
+#ifdef CMD_38_ENUM_NAME
+       CMD_38_HELP,
+#endif
+#ifdef CMD_39_ENUM_NAME
+       CMD_39_HELP,
+#endif
+
+#ifdef CMD_40_ENUM_NAME
+       CMD_40_HELP,
+#endif
+#ifdef CMD_41_ENUM_NAME
+       CMD_41_HELP,
+#endif
+#ifdef CMD_42_ENUM_NAME
+       CMD_42_HELP,
+#endif
+#ifdef CMD_43_ENUM_NAME
+       CMD_43_HELP,
+#endif
+#ifdef CMD_44_ENUM_NAME
+       CMD_44_HELP,
+#endif
+#ifdef CMD_45_ENUM_NAME
+       CMD_45_HELP,
+#endif
+#ifdef CMD_46_ENUM_NAME
+       CMD_46_HELP,
+#endif
+#ifdef CMD_47_ENUM_NAME
+       CMD_47_HELP,
+#endif
+#ifdef CMD_48_ENUM_NAME
+       CMD_48_HELP,
+#endif
+#ifdef CMD_49_ENUM_NAME
+       CMD_49_HELP,
+#endif
+
+#ifdef CMD_50_ENUM_NAME
+       CMD_50_HELP,
+#endif
+#ifdef CMD_51_ENUM_NAME
+       CMD_51_HELP,
+#endif
+#ifdef CMD_52_ENUM_NAME
+       CMD_52_HELP,
+#endif
+#ifdef CMD_53_ENUM_NAME
+       CMD_53_HELP,
+#endif
+#ifdef CMD_54_ENUM_NAME
+       CMD_54_HELP,
+#endif
+#ifdef CMD_55_ENUM_NAME
+       CMD_55_HELP,
+#endif
+#ifdef CMD_56_ENUM_NAME
+       CMD_56_HELP,
+#endif
+#ifdef CMD_57_ENUM_NAME
+       CMD_57_HELP,
+#endif
+#ifdef CMD_58_ENUM_NAME
+       CMD_58_HELP,
+#endif
+#ifdef CMD_59_ENUM_NAME
+       CMD_59_HELP,
+#endif
+
+#ifdef CMD_60_ENUM_NAME
+       CMD_60_HELP,
+#endif
+#ifdef CMD_61_ENUM_NAME
+       CMD_61_HELP,
+#endif
+#ifdef CMD_62_ENUM_NAME
+       CMD_62_HELP,
+#endif
+#ifdef CMD_63_ENUM_NAME
+       CMD_63_HELP,
+#endif
+#ifdef CMD_64_ENUM_NAME
+       CMD_64_HELP,
+#endif
+#ifdef CMD_65_ENUM_NAME
+       CMD_65_HELP,
+#endif
+#ifdef CMD_66_ENUM_NAME
+       CMD_66_HELP,
+#endif
+#ifdef CMD_67_ENUM_NAME
+       CMD_67_HELP,
+#endif
+#ifdef CMD_68_ENUM_NAME
+       CMD_68_HELP,
+#endif
+#ifdef CMD_69_ENUM_NAME
+       CMD_69_HELP,
+#endif
+
+#ifdef CMD_70_ENUM_NAME
+       CMD_70_HELP,
+#endif
+#ifdef CMD_71_ENUM_NAME
+       CMD_71_HELP,
+#endif
+#ifdef CMD_72_ENUM_NAME
+       CMD_72_HELP,
+#endif
+#ifdef CMD_73_ENUM_NAME
+       CMD_73_HELP,
+#endif
+#ifdef CMD_74_ENUM_NAME
+       CMD_74_HELP,
+#endif
+#ifdef CMD_75_ENUM_NAME
+       CMD_75_HELP,
+#endif
+#ifdef CMD_76_ENUM_NAME
+       CMD_76_HELP,
+#endif
+#ifdef CMD_77_ENUM_NAME
+       CMD_77_HELP,
+#endif
+#ifdef CMD_78_ENUM_NAME
+       CMD_78_HELP,
+#endif
+#ifdef CMD_79_ENUM_NAME
+       CMD_79_HELP,
+#endif
+
+#ifdef CMD_80_ENUM_NAME
+       CMD_80_HELP,
+#endif
+#ifdef CMD_81_ENUM_NAME
+       CMD_81_HELP,
+#endif
+#ifdef CMD_82_ENUM_NAME
+       CMD_82_HELP,
+#endif
+#ifdef CMD_83_ENUM_NAME
+       CMD_83_HELP,
+#endif
+#ifdef CMD_84_ENUM_NAME
+       CMD_84_HELP,
+#endif
+#ifdef CMD_85_ENUM_NAME
+       CMD_85_HELP,
+#endif
+#ifdef CMD_86_ENUM_NAME
+       CMD_86_HELP,
+#endif
+#ifdef CMD_87_ENUM_NAME
+       CMD_87_HELP,
+#endif
+#ifdef CMD_88_ENUM_NAME
+       CMD_88_HELP,
+#endif
+#ifdef CMD_89_ENUM_NAME
+       CMD_89_HELP,
+#endif
+
+#ifdef CMD_90_ENUM_NAME
+       CMD_90_HELP,
+#endif
+#ifdef CMD_91_ENUM_NAME
+       CMD_91_HELP,
+#endif
+#ifdef CMD_92_ENUM_NAME
+       CMD_92_HELP,
+#endif
+#ifdef CMD_93_ENUM_NAME
+       CMD_93_HELP,
+#endif
+#ifdef CMD_94_ENUM_NAME
+       CMD_94_HELP,
+#endif
+#ifdef CMD_95_ENUM_NAME
+       CMD_95_HELP,
+#endif
+#ifdef CMD_96_ENUM_NAME
+       CMD_96_HELP,
+#endif
+#ifdef CMD_97_ENUM_NAME
+       CMD_97_HELP,
+#endif
+#ifdef CMD_98_ENUM_NAME
+       CMD_98_HELP,
+#endif
+#ifdef CMD_99_ENUM_NAME
+       CMD_99_HELP,
+#endif
+};
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+void cli_print_help(uint16_t cmd)
+{
+    const char *const p_txt_invalid[] =
+    {
+        "__INVALID_ITEM__",
+        NULL        
+    };
+    
+    const char *const *const p_txt_help = (cli_cmd_is_not_valid(cmd) ? (p_txt_invalid) : (txt_helps[cmd]));
+    uint16_t i = UINT16_MAX;
+    while ((128u > (++i)) && (NULL != p_txt_help[i]))  /* limits of 128 is just to prevent endless loop in case of some problem */
+    {
+        printf("%s", p_txt_help[i]);
+    }
+}
+
+/* ==== TESTMODE constants ================================================= */
+
+#if !defined(NDEBUG)
+/* empty */
+#endif
+
+/* ========================================================================= */
diff --git a/sw/libfci_cli/src/libfci_cli_def_help.h b/sw/libfci_cli/src/libfci_cli_def_help.h
new file mode 100644
index 0000000..e70e7b4
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_def_help.h
@@ -0,0 +1,27 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef CLI_DEF_HELP_H_
+#define CLI_DEF_HELP_H_
+
+#include <stdint.h>
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+void cli_print_help(uint16_t cmd);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.c b/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.c
new file mode 100644
index 0000000..081ed59
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.c
@@ -0,0 +1,617 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#include <assert.h>
+#include <stdint.h>
+#include <limits.h>
+#include <string.h>
+#include "libfci_cli_common.h"
+#include "libfci_cli_def_optarg_keywords.h"
+
+/* ==== TESTMODE vars ====================================================== */
+
+#if !defined(NDEBUG)
+/* empty */
+#endif
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+#define TXT_INVALID_ITEM  "__INVALID_ITEM__"
+#define CALC_LN(ARRAY)    (sizeof(ARRAY) / sizeof(const char*))
+
+/* indexed by elements of 'fpp_phy_if_op_mode_t' */
+static const char *const txt_if_modes[] = 
+{
+    TXT_IF_MODE__DEFAULT,
+    TXT_IF_MODE__BRIDGE,
+    TXT_IF_MODE__ROUTER,
+    TXT_IF_MODE__VLAN_BRIDGE,
+    TXT_IF_MODE__FLEXIBLE_ROUTER,
+    TXT_IF_MODE__L2L3_BRIDGE,
+    TXT_IF_MODE__L2L3_VLAN_BRIDGE
+};
+#define IF_MODES_LN  CALC_LN(txt_if_modes)
+
+/* indexed by elements of 'fpp_phy_if_block_state_t' */
+static const char *const txt_if_block_states[] = 
+{
+    TXT_IF_BLOCK_STATE__NORMAL,
+    TXT_IF_BLOCK_STATE__BLOCKED,
+    TXT_IF_BLOCK_STATE__LEARN_ONLY,
+    TXT_IF_BLOCK_STATE__FW_ONLY
+};
+#define IF_BLOCK_STATES_LN  CALC_LN(txt_if_block_states)
+
+/* indexed by common boolean logic ^_^ */
+static const char *const txt_on_offs[] = 
+{
+    TXT_ON_OFF__OFF,
+    TXT_ON_OFF__ON
+};
+#define ON_OFFS_LN  CALC_LN(txt_on_offs)
+
+/* indexed by common boolean logic ^_^ */
+static const char *const txt_en_dises[] = 
+{
+    TXT_EN_DIS__DISABLED,
+    TXT_EN_DIS__ENABLED
+};
+#define EN_DISES_LN  CALC_LN(txt_en_dises)
+
+/* indexed by boolean logic of logif bit flag 'MATCH_OR' */
+static const char *const txt_or_ands[] = 
+{
+    TXT_OR_AND__AND,
+    TXT_OR_AND__OR
+};
+#define OR_ANDS_LN  CALC_LN(txt_or_ands)
+
+/* indexed by elements of 'pfe_ct_phy_if_id_t'. */
+/* WARNING: these texts should be exactly the same as hardcoded egress names in 'pfe_platform_master.c' */
+static const char *const txt_phyifs[] = 
+{
+    TXT_PHYIF__EMAC0,
+    TXT_PHYIF__EMAC1,
+    TXT_PHYIF__EMAC2,
+    TXT_PHYIF__HIF,
+    TXT_PHYIF__HIF_NOCPY,
+    TXT_PHYIF__UTIL,
+    TXT_PHYIF__HIF0,
+    TXT_PHYIF__HIF1,
+    TXT_PHYIF__HIF2,
+    TXT_PHYIF__HIF3
+};
+#define PHYIFS_LN  CALC_LN(txt_phyifs)
+
+/* based on element order of 'fpp_if_m_rules_t' */
+/* WARNING: elements of 'fpp_if_m_rules_t' are bitmasks, and thus CANNOT directly index this array */
+static const char *const txt_match_rules[] = 
+{
+    TXT_MATCH_RULE__TYPE_ETH,
+    TXT_MATCH_RULE__TYPE_VLAN,
+    TXT_MATCH_RULE__TYPE_PPPOE,
+    TXT_MATCH_RULE__TYPE_ARP,
+    TXT_MATCH_RULE__TYPE_MCAST,
+    TXT_MATCH_RULE__TYPE_IP4,
+    TXT_MATCH_RULE__TYPE_IP6,
+    TXT_MATCH_RULE__XXX_RES7_XXX,
+    TXT_MATCH_RULE__XXX_RES8_XXX,
+    TXT_MATCH_RULE__TYPE_IPX,
+    TXT_MATCH_RULE__TYPE_BCAST,
+    TXT_MATCH_RULE__TYPE_UDP,
+    TXT_MATCH_RULE__TYPE_TCP,
+    TXT_MATCH_RULE__TYPE_ICMP,
+    TXT_MATCH_RULE__TYPE_IGMP,
+    TXT_MATCH_RULE__VLAN,
+    TXT_MATCH_RULE__PROTOCOL,
+    TXT_MATCH_RULE__XXX_RES17_XXX,
+    TXT_MATCH_RULE__XXX_RES18_XXX,
+    TXT_MATCH_RULE__XXX_RES19_XXX,
+    TXT_MATCH_RULE__SPORT,
+    TXT_MATCH_RULE__DPORT,
+    TXT_MATCH_RULE__SIP6,
+    TXT_MATCH_RULE__DIP6,
+    TXT_MATCH_RULE__SIP,
+    TXT_MATCH_RULE__DIP,
+    TXT_MATCH_RULE__ETHER_TYPE,
+    TXT_MATCH_RULE__FP_TABLE0,  /* FP0 */
+    TXT_MATCH_RULE__FP_TABLE1,  /* FP1 */
+    TXT_MATCH_RULE__SMAC,
+    TXT_MATCH_RULE__DMAC,
+    TXT_MATCH_RULE__HIF_COOKIE
+};
+#define MATCH_RULES_LN  CALC_LN(txt_match_rules)
+
+/* indexed by IANA "Assigned Internet Protocol Number" elements */
+/* https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml */
+static const char txt_protocol_ahip[] = "'any host internal protocol'";
+static const char txt_protocol_aln[] = "'any local network'";
+static const char txt_protocol_adfs[] = "'any distributed file system'";
+static const char txt_protocol_apes[] = "'any private encryption scheme'";
+static const char txt_protocol_azhp[] = "'any zero hop protocol'";
+static const char txt_protocol_unass[] = "UNASSIGNED by IANA";
+static const char txt_protocol_tests[] = "EXPERIMENTS and TESTING range";
+static const char txt_protocol_res[] = "RESERVED by IANA";
+static const char *const txt_protocols[] = 
+{
+    TXT_PROTOCOL__HOPOPT,      TXT_PROTOCOL__ICMP,        TXT_PROTOCOL__IGMP,        TXT_PROTOCOL__GGP,        TXT_PROTOCOL__IPv4,
+    TXT_PROTOCOL__ST,          TXT_PROTOCOL__TCP,         TXT_PROTOCOL__CBT,         TXT_PROTOCOL__EGP,        TXT_PROTOCOL__IGP,
+    TXT_PROTOCOL__BBN_RCC_MON, TXT_PROTOCOL__NVP_II,      TXT_PROTOCOL__PUP,         TXT_PROTOCOL__ARGUS,      TXT_PROTOCOL__EMCON,
+    TXT_PROTOCOL__XNET,        TXT_PROTOCOL__CHAOS,       TXT_PROTOCOL__UDP,         TXT_PROTOCOL__MUX,        TXT_PROTOCOL__DCN_MEAS,
+    TXT_PROTOCOL__HMP,         TXT_PROTOCOL__PRM,         TXT_PROTOCOL__XNS_IDP,     TXT_PROTOCOL__TRUNK_1,    TXT_PROTOCOL__TRUNK_2,
+    TXT_PROTOCOL__LEAF_1,      TXT_PROTOCOL__LEAF_2,      TXT_PROTOCOL__RDP,         TXT_PROTOCOL__IRTP,       TXT_PROTOCOL__ISO_TP4,
+    TXT_PROTOCOL__NETBLT,      TXT_PROTOCOL__MFE_NSP,     TXT_PROTOCOL__MERIT_INP,   TXT_PROTOCOL__DCCP,       TXT_PROTOCOL__3PC,
+    TXT_PROTOCOL__IDPR,        TXT_PROTOCOL__XTP,         TXT_PROTOCOL__DDP,         TXT_PROTOCOL__IDPR_CMTP,  TXT_PROTOCOL__TP_PLUSPLUS,
+    TXT_PROTOCOL__IL,          TXT_PROTOCOL__IPv6,        TXT_PROTOCOL__SDRP,        TXT_PROTOCOL__IPv6_Route, TXT_PROTOCOL__IPv6_Frag,
+    TXT_PROTOCOL__IDRP,        TXT_PROTOCOL__RSVP,        TXT_PROTOCOL__GRE,         TXT_PROTOCOL__DSR,        TXT_PROTOCOL__BNA,
+
+    TXT_PROTOCOL__ESP,         TXT_PROTOCOL__AH,          TXT_PROTOCOL__I_NLSP,      TXT_PROTOCOL__SWIPE,      TXT_PROTOCOL__NARP,
+    TXT_PROTOCOL__MOBILE,      TXT_PROTOCOL__TLSP,        TXT_PROTOCOL__SKIP,        TXT_PROTOCOL__IPv6_ICMP,  TXT_PROTOCOL__IPv6_NoNxt,
+    TXT_PROTOCOL__IPv6_Opts,   txt_protocol_ahip,         TXT_PROTOCOL__CFTP,        txt_protocol_aln,         TXT_PROTOCOL__SAT_EXPAK,
+    TXT_PROTOCOL__KRYPTOLAN,   TXT_PROTOCOL__RVD,         TXT_PROTOCOL__IPPC,        txt_protocol_adfs,        TXT_PROTOCOL__SAT_MON,
+    TXT_PROTOCOL__VISA,        TXT_PROTOCOL__IPCV,        TXT_PROTOCOL__CPNX,        TXT_PROTOCOL__CPHB,       TXT_PROTOCOL__WSN,
+    TXT_PROTOCOL__PVP,         TXT_PROTOCOL__BR_SAT_MON,  TXT_PROTOCOL__SUN_ND,      TXT_PROTOCOL__WB_MON,     TXT_PROTOCOL__WB_EXPAK,
+    TXT_PROTOCOL__ISO_IP,      TXT_PROTOCOL__VMTP,        TXT_PROTOCOL__SECURE_VMTP, TXT_PROTOCOL__VINES,      TXT_PROTOCOL__IPTM,
+    TXT_PROTOCOL__NSFNET_IGP,  TXT_PROTOCOL__DGP,         TXT_PROTOCOL__TCF,         TXT_PROTOCOL__EIGRP,      TXT_PROTOCOL__OSPFIGP,
+    TXT_PROTOCOL__Sprite_RPC,  TXT_PROTOCOL__LARP,        TXT_PROTOCOL__MTP,         TXT_PROTOCOL__AX_25,      TXT_PROTOCOL__IPIP,
+    TXT_PROTOCOL__MICP,        TXT_PROTOCOL__SCC_SP,      TXT_PROTOCOL__ETHERIP,     TXT_PROTOCOL__ENCAP,      txt_protocol_apes,
+
+    TXT_PROTOCOL__GMTP,        TXT_PROTOCOL__IFMP,        TXT_PROTOCOL__PNNI,        TXT_PROTOCOL__PIM,        TXT_PROTOCOL__ARIS,
+    TXT_PROTOCOL__SCPS,        TXT_PROTOCOL__QNX,         TXT_PROTOCOL__AN,          TXT_PROTOCOL__IPComp,     TXT_PROTOCOL__SNP,
+    TXT_PROTOCOL__Compaq_Peer, TXT_PROTOCOL__IPX_in_IP,   TXT_PROTOCOL__VRRP,        TXT_PROTOCOL__PGM,        txt_protocol_azhp,
+    TXT_PROTOCOL__L2TP,        TXT_PROTOCOL__DDX,         TXT_PROTOCOL__IATP,        TXT_PROTOCOL__STP,        TXT_PROTOCOL__SRP,
+    TXT_PROTOCOL__UTI,         TXT_PROTOCOL__SMP,         TXT_PROTOCOL__SM,          TXT_PROTOCOL__PTP,        TXT_PROTOCOL__ISIS_over_IPv4,
+    TXT_PROTOCOL__FIRE,        TXT_PROTOCOL__CRTP,        TXT_PROTOCOL__CRUDP,       TXT_PROTOCOL__SSCOPMCE,   TXT_PROTOCOL__IPLT,
+    TXT_PROTOCOL__SPS,         TXT_PROTOCOL__PIPE,        TXT_PROTOCOL__SCTP,        TXT_PROTOCOL__FC,         TXT_PROTOCOL__RSVP_E2E_IGNORE,
+    TXT_PROTOCOL__Mobility_Header, TXT_PROTOCOL__UDPLite, TXT_PROTOCOL__MPLS_in_IP,  TXT_PROTOCOL__manet,      TXT_PROTOCOL__HIP,
+    TXT_PROTOCOL__Shim6,       TXT_PROTOCOL__WESP,        TXT_PROTOCOL__ROHC,        TXT_PROTOCOL__Ethernet
+};
+#define PROTOCOLS_LN  CALC_LN(txt_protocols)
+
+/* indexed by elements of 'fpp_fp_offset_from_t' */
+static const char *const txt_offset_froms[] = 
+{
+    TXT_OFFSET_FROM__XXX_RES0_XXX,
+    TXT_OFFSET_FROM__XXX_RES1_XXX,
+    TXT_OFFSET_FROM__L2,
+    TXT_OFFSET_FROM__L3,
+    TXT_OFFSET_FROM__L4
+};
+#define OFFSET_FROMS_LN  CALC_LN(txt_offset_froms)
+const uint8_t OFFSET_FROMS__MIN = (2u);
+const uint8_t OFFSET_FROMS__MAX = (OFFSET_FROMS_LN - 1u);
+
+/* indexed by elements of 'fpp_match_action_t' */
+static const char *const txt_match_actions[] = 
+{
+    TXT_MATCH_ACTION__ACCEPT,
+    TXT_MATCH_ACTION__REJECT,
+    TXT_MATCH_ACTION__NEXT_RULE
+};
+#define MATCH_ACTIONS_LN  CALC_LN(txt_match_actions)
+const uint8_t MATCH_ACTIONS__MAX = (MATCH_ACTIONS_LN - 1u);
+
+/* indexed by values of bridge actions (see doxygen for 'fpp_l2_bd_cmd_t.ucast_hit') */
+static const char *const txt_bd_actions[] = 
+{
+    TXT_BD_ACTION__FORWARD,
+    TXT_BD_ACTION__FLOOD,
+    TXT_BD_ACTION__PUNT,
+    TXT_BD_ACTION__DISCARD
+};
+#define BD_ACTIONS_LN  CALC_LN(txt_bd_actions)
+const uint8_t BD_ACTIONS__MAX = (BD_ACTIONS_LN - 1u);
+
+/* indexed by elements of 'fpp_spd_action_t' */
+static const char *const txt_spd_actions[] = 
+{
+    TXT_SPD_ACTION__XXX_RES0_XXX,
+    TXT_SPD_ACTION__DISCARD,
+    TXT_SPD_ACTION__BYPASS,
+    TXT_SPD_ACTION__ENCODE,
+    TXT_SPD_ACTION__DECODE
+};
+#define SPD_ACTIONS_LN  CALC_LN(txt_spd_actions)
+const uint8_t SPD_ACTIONS__MAX = (SPD_ACTIONS_LN - 1u);
+
+/* indexed by queue mode IDs (see doxygen for 'fpp_qos_queue_cmd_t.mode') */
+static const char *const txt_que_modes[] = 
+{
+    TXT_QUE_MODE__DISABLED,
+    TXT_QUE_MODE__DEFAULT,
+    TXT_QUE_MODE__TAIL_DROP,
+    TXT_QUE_MODE__WRED
+};
+#define QUE_MODES_LN  CALC_LN(txt_que_modes)
+
+/* indexed by scheduler mode IDs (see doxygen for 'fpp_qos_scheduler_cmd_t.mode') */
+static const char *const txt_sch_modes[] = 
+{
+    TXT_SCH_MODE__DISABLED,
+    TXT_SCH_MODE__DATA_RATE,
+    TXT_SCH_MODE__PACKET_RATE
+};
+#define SCH_MODES_LN  CALC_LN(txt_sch_modes)
+
+/* indexed by scheduler algorithm IDs (see doxygen for 'fpp_qos_scheduler_cmd_t.algo') */
+static const char *const txt_sch_algos[] = 
+{
+    TXT_SCH_ALGO__PQ,
+    TXT_SCH_ALGO__DWRR,
+    TXT_SCH_ALGO__RR,
+    TXT_SCH_ALGO__WRR
+};
+#define SCH_ALGOS_LN  CALC_LN(txt_sch_algos)
+
+/* indexed by scheduler input IDs (see doxygen for 'fpp_qos_scheduler_cmd_t.input' and 'fpp_qos_scheduler_cmd_t.input_src') */
+static const char *const txt_sch_ins[] = 
+{
+    TXT_SCH_IN__QUE0,
+    TXT_SCH_IN__QUE1,
+    TXT_SCH_IN__QUE2,
+    TXT_SCH_IN__QUE3,
+    TXT_SCH_IN__QUE4,
+    TXT_SCH_IN__QUE5,
+    TXT_SCH_IN__QUE6,
+    TXT_SCH_IN__QUE7,
+    TXT_SCH_IN__SCH0_OUT
+};
+#define SCH_INS_LN_  CALC_LN(txt_sch_ins)
+
+/* indexed by shaper mode IDs (see doxygen for 'fpp_qos_shaper_cmd_t.mode') */
+static const char *const txt_shp_modes[] = 
+{
+    TXT_SHP_MODE__DISABLED,
+    TXT_SHP_MODE__DATA_RATE,
+    TXT_SHP_MODE__PACKET_RATE
+};
+#define SHP_MODES_LN  CALC_LN(txt_shp_modes)
+
+/* indexed by shaper position IDs (see doxygen for 'fpp_qos_shaper_cmd_t.position') */
+static const char *const txt_shp_pos[] = 
+{
+    TXT_SHP_POS__SCH1_OUT,
+    TXT_SHP_POS__SCH1_IN0,
+    TXT_SHP_POS__SCH1_IN1,
+    TXT_SHP_POS__SCH1_IN2,
+    TXT_SHP_POS__SCH1_IN3,
+    TXT_SHP_POS__SCH1_IN4,
+    TXT_SHP_POS__SCH1_IN5,
+    TXT_SHP_POS__SCH1_IN6,
+    TXT_SHP_POS__SCH1_IN7,
+    TXT_SHP_POS__SCH0_IN0,
+    TXT_SHP_POS__SCH0_IN1,
+    TXT_SHP_POS__SCH0_IN2,
+    TXT_SHP_POS__SCH0_IN3,
+    TXT_SHP_POS__SCH0_IN4,
+    TXT_SHP_POS__SCH0_IN5,
+    TXT_SHP_POS__SCH0_IN6,
+    TXT_SHP_POS__SCH0_IN7
+};
+#define SHP_POS_LN  CALC_LN(txt_shp_pos) 
+
+
+
+/* ==== PRIVATE FUNCTIONS ================================================== */
+
+static int txt2value(uint8_t *p_rtn_value, const char *p_txt,
+                     const char *const p_txt_keywords[], const uint8_t keywords_ln, const uint8_t min)
+{
+    assert(NULL != p_rtn_value);
+    assert(NULL != p_txt);
+    assert(NULL != p_txt_keywords);
+    /* 'p_rtn_opt_is_valid' is allowed to be NULL */
+    
+    int rtn = CLI_ERR;
+    
+    uint8_t i = UINT8_MAX;  /* WARNING: intentional use of owf behavior */ 
+    while ((keywords_ln > (++i)) && (strcmp(p_txt_keywords[i], p_txt))) { /*  empty  */ };
+    if ((keywords_ln <= i) || (min > i))
+    {
+        rtn = CLI_ERR_INVARG;
+    }
+    else
+    {
+        *p_rtn_value = i;
+        rtn = CLI_OK;
+    }
+    
+    return (rtn);
+}
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+const char* cli_value2txt_if_mode(uint8_t value)
+{
+    return ((IF_MODES_LN <= value) ? (TXT_INVALID_ITEM) : (txt_if_modes[value]));
+}
+int cli_txt2value_if_mode(uint8_t* p_rtn_value, const char* p_txt)
+{
+    return txt2value(p_rtn_value, p_txt, txt_if_modes, IF_MODES_LN, 0u);
+}
+
+
+const char* cli_value2txt_if_block_state(uint8_t value)
+{
+    return ((IF_BLOCK_STATES_LN <= value) ? (TXT_INVALID_ITEM) : (txt_if_block_states[value]));
+}
+int cli_txt2value_if_block_state(uint8_t* p_rtn_value, const char* p_txt)
+{
+    return txt2value(p_rtn_value, p_txt, txt_if_block_states, IF_BLOCK_STATES_LN, 0u);
+}
+
+
+const char* cli_value2txt_on_off(uint8_t value)
+{
+    return ((ON_OFFS_LN <= value) ? (TXT_INVALID_ITEM) : (txt_on_offs[value]));
+}
+int cli_txt2value_on_off(uint8_t* p_rtn_value, const char* p_txt)
+{
+    return txt2value(p_rtn_value, p_txt, txt_on_offs, ON_OFFS_LN, 0u);
+}
+
+
+const char* cli_value2txt_en_dis(uint8_t value)
+{
+    return ((EN_DISES_LN <= value) ? (TXT_INVALID_ITEM) : (txt_en_dises[value]));
+}
+int cli_txt2value_en_dis(uint8_t* p_rtn_value, const char* p_txt)
+{
+    return txt2value(p_rtn_value, p_txt, txt_en_dises, EN_DISES_LN, 0u);
+}
+
+
+const char* cli_value2txt_or_and(uint8_t value)
+{
+    return ((OR_ANDS_LN <= value) ? (TXT_INVALID_ITEM) : (txt_or_ands[value]));
+}
+int cli_txt2value_or_and(uint8_t* p_rtn_value, const char* p_txt)
+{
+    return txt2value(p_rtn_value, p_txt, txt_or_ands, OR_ANDS_LN, 0u);
+}
+
+
+const char* cli_value2txt_phyif(uint8_t value)
+{
+    return ((PHYIFS_LN <= value) ? (TXT_INVALID_ITEM) : (txt_phyifs[value]));
+}
+int cli_txt2value_phyif(uint8_t* p_rtn_value, const char* p_txt)
+{
+    return txt2value(p_rtn_value, p_txt, txt_phyifs, PHYIFS_LN, 0u);
+}
+
+
+const char* cli_value2txt_match_rule(uint8_t value)
+{
+    return ((MATCH_RULES_LN <= value) ? (TXT_INVALID_ITEM) : (txt_match_rules[value]));
+}
+int cli_txt2value_match_rule(uint8_t* p_rtn_value, const char* p_txt)
+{
+    return txt2value(p_rtn_value, p_txt, txt_match_rules, MATCH_RULES_LN, 0u);
+}
+
+
+const char* cli_value2txt_protocol(uint8_t value)
+{
+    return ((PROTOCOLS_LN > value) ? (txt_protocols[value]) :
+           ((252u >= value) ? (txt_protocol_unass) : 
+           ((254u >= value) ? (txt_protocol_tests) :
+           ((255u == value) ? (txt_protocol_res) : (TXT_INVALID_ITEM)))));
+}
+int cli_txt2value_protocol(uint8_t* p_rtn_value, const char* p_txt)
+{
+    return txt2value(p_rtn_value, p_txt, txt_protocols, PROTOCOLS_LN, 0u);
+}
+
+
+const char* cli_value2txt_offset_from(uint8_t value)
+{
+    return ((OFFSET_FROMS_LN <= value) ? (TXT_INVALID_ITEM) : (txt_offset_froms[value]));
+}
+int cli_txt2value_offset_from(uint8_t* p_rtn_value, const char* p_txt)
+{
+    return txt2value(p_rtn_value, p_txt, txt_offset_froms, OFFSET_FROMS_LN, FP_OFFSET_FROM_L2_HEADER);
+}
+
+
+const char* cli_value2txt_match_action(uint8_t value)
+{
+    return ((MATCH_ACTIONS_LN <= value) ? (TXT_INVALID_ITEM) : (txt_match_actions[value]));
+}
+int cli_txt2value_match_action(uint8_t* p_rtn_value, const char* p_txt)
+{
+    return txt2value(p_rtn_value, p_txt, txt_match_actions, MATCH_ACTIONS_LN, 0u);
+}
+
+
+const char* cli_value2txt_bd_action(uint8_t value)
+{
+    return ((BD_ACTIONS_LN <= value) ? (TXT_INVALID_ITEM) : (txt_bd_actions[value]));
+}
+int cli_txt2value_bd_action(uint8_t* p_rtn_value, const char* p_txt)
+{
+    return txt2value(p_rtn_value, p_txt, txt_bd_actions, BD_ACTIONS_LN, 0u);
+}
+
+
+const char* cli_value2txt_spd_action(uint8_t value)
+{
+    return ((SPD_ACTIONS_LN <= value) ? (TXT_INVALID_ITEM) : (txt_spd_actions[value]));
+}
+int cli_txt2value_spd_action(uint8_t* p_rtn_value, const char* p_txt)
+{
+    return txt2value(p_rtn_value, p_txt, txt_spd_actions, SPD_ACTIONS_LN, 0u);
+}
+
+
+const char* cli_value2txt_que_mode(uint8_t value)
+{
+    return ((QUE_MODES_LN <= value) ? (TXT_INVALID_ITEM) : (txt_que_modes[value]));
+}
+int cli_txt2value_que_mode(uint8_t* p_rtn_value, const char* p_txt)
+{
+    return txt2value(p_rtn_value, p_txt, txt_que_modes, QUE_MODES_LN, 0u);
+}
+
+
+#define VAL_QUE_ZPROB__KEEP  (200u)
+bool cli_que_zprob_is_not_keep(uint8_t value)
+{
+    return (VAL_QUE_ZPROB__KEEP != value);
+}
+int cli_txt2value_que_zprob_keep(uint8_t* p_rtn_value, const char* p_txt)
+{
+    assert(NULL != p_rtn_value);
+    assert(NULL != p_txt);
+    
+    
+    int rtn = CLI_ERR_INVARG;
+    if (0 == strcmp(TXT_QUE_ZPROB__KEEP, p_txt))
+    {
+        *p_rtn_value = VAL_QUE_ZPROB__KEEP;
+        rtn = CLI_OK;
+    }
+    
+    return (rtn);
+}
+
+
+const char* cli_value2txt_sch_mode(uint8_t value)
+{
+    return ((SCH_MODES_LN <= value) ? (TXT_INVALID_ITEM) : (txt_sch_modes[value]));
+}
+int cli_txt2value_sch_mode(uint8_t* p_rtn_value, const char* p_txt)
+{
+    return txt2value(p_rtn_value, p_txt, txt_sch_modes, SCH_MODES_LN, 0u);
+}
+
+
+const char* cli_value2txt_sch_algo(uint8_t value)
+{
+    return ((SCH_ALGOS_LN <= value) ? (TXT_INVALID_ITEM) : (txt_sch_algos[value]));
+}
+int cli_txt2value_sch_algo(uint8_t* p_rtn_value, const char* p_txt)
+{
+    return txt2value(p_rtn_value, p_txt, txt_sch_algos, SCH_ALGOS_LN, 0u);
+}
+
+
+#define VAL_SCH_IN__DISABLED  (255u)
+#define VAL_SCH_IN__KEEP      (200u)
+bool cli_sch_in_is_not_dis(uint8_t value)
+{
+    return (VAL_SCH_IN__DISABLED != value);
+}
+bool cli_sch_in_is_not_keep(uint8_t value)
+{
+    return (VAL_SCH_IN__KEEP != value);
+}
+const char* cli_value2txt_sch_in(uint8_t value)
+{
+    return ((SCH_INS_LN_ > value) ? (txt_sch_ins[value]) :
+           ((VAL_SCH_IN__DISABLED == value) ? (TXT_SCH_IN__DISABLED) : (TXT_INVALID_ITEM)));
+    /* 'KEEP' element is cli-internal only (is not defined in libFCI) - no need to print it */
+}
+int cli_txt2value_sch_in(uint8_t* p_rtn_value, const char* p_txt)
+{
+    assert(NULL != p_rtn_value);
+    assert(NULL != p_txt);
+    
+    
+    int rtn = CLI_ERR;
+    if (0 == strcmp(TXT_SCH_IN__DISABLED, p_txt))
+    {
+        *p_rtn_value = VAL_SCH_IN__DISABLED;
+        rtn = CLI_OK;
+    }
+    else if (0 == strcmp(TXT_SCH_IN__KEEP, p_txt))  /* 'KEEP' element is cli-internal only (is not defined in libFCI) */
+    {
+        *p_rtn_value = VAL_SCH_IN__KEEP;
+        rtn = CLI_OK;
+    }
+    else
+    {
+        rtn = txt2value(p_rtn_value, p_txt, txt_sch_ins, SCH_INS_LN_, 0u);
+    }
+    
+    return (rtn);
+}
+
+
+const char* cli_value2txt_shp_mode(uint8_t value)
+{
+    return ((SHP_MODES_LN <= value) ? (TXT_INVALID_ITEM) : (txt_shp_modes[value]));
+}
+int cli_txt2value_shp_mode(uint8_t* p_rtn_value, const char* p_txt)
+{
+    return txt2value(p_rtn_value, p_txt, txt_shp_modes, SHP_MODES_LN, 0u);
+}
+
+
+#define VAL_SHP_POS__DISABLED  (255u)
+bool cli_shp_pos_is_not_dis(uint8_t value)
+{
+    return (VAL_SHP_POS__DISABLED != value);
+}
+const char* cli_value2txt_shp_pos(uint8_t value)
+{
+    return ((SHP_POS_LN > value) ? (txt_shp_pos[value]) :
+           ((VAL_SHP_POS__DISABLED == value) ? (TXT_SHP_POS__DISABLED) : (TXT_INVALID_ITEM)));
+}
+int cli_txt2value_shp_pos(uint8_t* p_rtn_value, const char* p_txt)
+{
+    assert(NULL != p_rtn_value);
+    assert(NULL != p_txt);
+    
+    
+    int rtn = CLI_ERR;
+    if (0 == strcmp(TXT_SHP_POS__DISABLED, p_txt))
+    {
+        *p_rtn_value = VAL_SHP_POS__DISABLED;
+        rtn = CLI_OK;
+    }
+    else
+    {
+        rtn = txt2value(p_rtn_value, p_txt, txt_shp_pos, SHP_POS_LN, 0u);
+    }
+    
+    return (rtn);
+}
+
+
+/* ==== TESTMODE constants ================================================= */
+
+#if !defined(NDEBUG)
+const uint8_t TEST_defkws__if_modes_ln         = IF_MODES_LN;
+const uint8_t TEST_defkws__if_block_states_ln  = IF_BLOCK_STATES_LN;
+const uint8_t TEST_defkws__on_offs_ln          = ON_OFFS_LN;
+const uint8_t TEST_defkws__en_dises_ln         = EN_DISES_LN;
+const uint8_t TEST_defkws__or_ands_ln          = OR_ANDS_LN;
+const uint8_t TEST_defkws__phyifs_ln           = PHYIFS_LN;
+const uint8_t TEST_defkws__match_rules_ln      = MATCH_RULES_LN;
+const uint8_t TEST_defkws__protocols_ln        = PROTOCOLS_LN;
+const uint8_t TEST_defkws__offset_froms_ln     = OFFSET_FROMS_LN;
+const uint8_t TEST_defkws__match_actions_ln    = MATCH_ACTIONS_LN;
+const uint8_t TEST_defkws__bd_actions_ln       = BD_ACTIONS_LN;
+const uint8_t TEST_defkws__spd_actions_ln      = SPD_ACTIONS_LN;
+const uint8_t TEST_defkws__que_modes_ln        = QUE_MODES_LN;
+const uint8_t TEST_defkws__sch_modes_ln        = SCH_MODES_LN;
+const uint8_t TEST_defkws__sch_algos_ln        = SCH_ALGOS_LN;
+const uint8_t TEST_defkws__sch_ins_ln          = SCH_INS_LN_;
+const uint8_t TEST_defkws__shp_modes_ln        = SHP_MODES_LN;
+const uint8_t TEST_defkws__shp_pos_ln          = SHP_POS_LN;
+#endif
+
+/* ========================================================================= */
diff --git a/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.h b/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.h
new file mode 100644
index 0000000..53df85b
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.h
@@ -0,0 +1,402 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef CLI_DEF_OPTARG_KEYWORDS_H_
+#define CLI_DEF_OPTARG_KEYWORDS_H_
+
+#include <stdint.h>
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+/*
+    NOTE: Purpose of defining the keywords here (as opposed to simply making them literals within respective arrays)
+          is to be able to use them in help texts.
+*/
+
+/* indexed by elements of 'fpp_phy_if_op_mode_t' */
+#define TXT_IF_MODE__DEFAULT           "DEFAULT"
+#define TXT_IF_MODE__BRIDGE            "BRIDGE"
+#define TXT_IF_MODE__ROUTER            "ROUTER"
+#define TXT_IF_MODE__VLAN_BRIDGE       "VLAN_BRIDGE"
+#define TXT_IF_MODE__FLEXIBLE_ROUTER   "FLEXIBLE_ROUTER"
+#define TXT_IF_MODE__L2L3_BRIDGE       "L2L3_BRIDGE"
+#define TXT_IF_MODE__L2L3_VLAN_BRIDGE  "L2L3_VLAN_BRIDGE"
+
+/* indexed by elements of 'fpp_phy_if_block_state_t' */
+#define TXT_IF_BLOCK_STATE__NORMAL      "NORMAL"
+#define TXT_IF_BLOCK_STATE__BLOCKED     "BLOCKED"
+#define TXT_IF_BLOCK_STATE__LEARN_ONLY  "LEARN_ONLY"
+#define TXT_IF_BLOCK_STATE__FW_ONLY     "FW_ONLY"
+
+/* indexed by common boolean logic ^_^ */
+#define TXT_ON_OFF__OFF  "OFF"
+#define TXT_ON_OFF__ON   "ON"
+
+/* indexed by common boolean logic ^_^ */
+#define TXT_EN_DIS__DISABLED  "DISABLED"
+#define TXT_EN_DIS__ENABLED   "ENABLED"
+
+/* indexed by boolean logic of logif bit flag 'MATCH_OR' */
+#define TXT_OR_AND__AND  "AND"
+#define TXT_OR_AND__OR   "OR"
+
+/* indexed by elements of 'pfe_ct_phy_if_id_t'. */
+/* WARNING: these texts should be exactly the same as hardcoded egress names in 'pfe_platform_master.c' */
+#define TXT_PHYIF__EMAC0      "emac0"
+#define TXT_PHYIF__EMAC1      "emac1"
+#define TXT_PHYIF__EMAC2      "emac2"
+#define TXT_PHYIF__HIF        "hif"
+#define TXT_PHYIF__HIF_NOCPY  "hifncpy"
+#define TXT_PHYIF__UTIL       "util"
+#define TXT_PHYIF__HIF0       "hif0"
+#define TXT_PHYIF__HIF1       "hif1"
+#define TXT_PHYIF__HIF2       "hif2"
+#define TXT_PHYIF__HIF3       "hif3"
+
+/* based on element order of 'fpp_if_m_rules_t' */
+/* WARNING: elements of 'fpp_if_m_rules_t' are bitmasks, and thus CANNOT directly index this array */
+#define TXT_MATCH_RULE__TYPE_ETH       "TYPE_ETH"
+#define TXT_MATCH_RULE__TYPE_VLAN      "TYPE_VLAN"
+#define TXT_MATCH_RULE__TYPE_PPPOE     "TYPE_PPPOE"
+#define TXT_MATCH_RULE__TYPE_ARP       "TYPE_ARP"
+#define TXT_MATCH_RULE__TYPE_MCAST     "TYPE_MCAST"
+#define TXT_MATCH_RULE__TYPE_IP4       "TYPE_IP4"
+#define TXT_MATCH_RULE__TYPE_IP6       "TYPE_IP6"
+#define TXT_MATCH_RULE__XXX_RES7_XXX   "__XXX_res7_XXX__"
+#define TXT_MATCH_RULE__XXX_RES8_XXX   "__XXX_res8_XXX__"
+#define TXT_MATCH_RULE__TYPE_IPX       "TYPE_IPX"
+#define TXT_MATCH_RULE__TYPE_BCAST     "TYPE_BCAST"
+#define TXT_MATCH_RULE__TYPE_UDP       "TYPE_UDP"
+#define TXT_MATCH_RULE__TYPE_TCP       "TYPE_TCP"
+#define TXT_MATCH_RULE__TYPE_ICMP      "TYPE_ICMP"
+#define TXT_MATCH_RULE__TYPE_IGMP      "TYPE_IGMP"
+#define TXT_MATCH_RULE__VLAN           "VLAN"
+#define TXT_MATCH_RULE__PROTOCOL       "PROTOCOL"
+#define TXT_MATCH_RULE__XXX_RES17_XXX  "__XXX_res17_XXX__"
+#define TXT_MATCH_RULE__XXX_RES18_XXX  "__XXX_res18_XXX__"
+#define TXT_MATCH_RULE__XXX_RES19_XXX  "__XXX_res19_XXX__"
+#define TXT_MATCH_RULE__SPORT          "SPORT"
+#define TXT_MATCH_RULE__DPORT          "DPORT"
+#define TXT_MATCH_RULE__SIP6           "SIP6"
+#define TXT_MATCH_RULE__DIP6           "DIP6"
+#define TXT_MATCH_RULE__SIP            "SIP"
+#define TXT_MATCH_RULE__DIP            "DIP"
+#define TXT_MATCH_RULE__ETHER_TYPE     "ETHER_TYPE"
+#define TXT_MATCH_RULE__FP_TABLE0      "FP_TABLE0"
+#define TXT_MATCH_RULE__FP_TABLE1      "FP_TABLE1"
+#define TXT_MATCH_RULE__SMAC           "SMAC"
+#define TXT_MATCH_RULE__DMAC           "DMAC"
+#define TXT_MATCH_RULE__HIF_COOKIE     "HIF_COOKIE"
+
+/* indexed by IANA "Assigned Internet Protocol Number" elements */
+/* https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml */
+#define TXT_PROTOCOL__HOPOPT           "HOPOPT"
+#define TXT_PROTOCOL__ICMP             "ICMP"
+#define TXT_PROTOCOL__IGMP             "IGMP"
+#define TXT_PROTOCOL__GGP              "GGP"
+#define TXT_PROTOCOL__IPv4             "IPv4"
+#define TXT_PROTOCOL__ST               "ST"
+#define TXT_PROTOCOL__TCP              "TCP"
+#define TXT_PROTOCOL__CBT              "CBT"
+#define TXT_PROTOCOL__EGP              "EGP"
+#define TXT_PROTOCOL__IGP              "IGP"
+#define TXT_PROTOCOL__BBN_RCC_MON      "BBN-RCC-MON"
+#define TXT_PROTOCOL__NVP_II           "NVP-II"
+#define TXT_PROTOCOL__PUP              "PUP"
+#define TXT_PROTOCOL__ARGUS            "ARGUS"
+#define TXT_PROTOCOL__EMCON            "EMCON"
+#define TXT_PROTOCOL__XNET             "XNET"
+#define TXT_PROTOCOL__CHAOS            "CHAOS"
+#define TXT_PROTOCOL__UDP              "UDP"
+#define TXT_PROTOCOL__MUX              "MUX"
+#define TXT_PROTOCOL__DCN_MEAS         "DCN-MEAS"
+#define TXT_PROTOCOL__HMP              "HMP"
+#define TXT_PROTOCOL__PRM              "PRM"
+#define TXT_PROTOCOL__XNS_IDP          "XNS-IDP"
+#define TXT_PROTOCOL__TRUNK_1          "TRUNK-1"
+#define TXT_PROTOCOL__TRUNK_2          "TRUNK-2"
+#define TXT_PROTOCOL__LEAF_1           "LEAF-1"
+#define TXT_PROTOCOL__LEAF_2           "LEAF-2"
+#define TXT_PROTOCOL__RDP              "RDP"
+#define TXT_PROTOCOL__IRTP             "IRTP"
+#define TXT_PROTOCOL__ISO_TP4          "ISO-TP4"
+#define TXT_PROTOCOL__NETBLT           "NETBLT"
+#define TXT_PROTOCOL__MFE_NSP          "MFE-NSP"
+#define TXT_PROTOCOL__MERIT_INP        "MERIT-INP"
+#define TXT_PROTOCOL__DCCP             "DCCP"
+#define TXT_PROTOCOL__3PC              "3PC"
+#define TXT_PROTOCOL__IDPR             "IDPR"
+#define TXT_PROTOCOL__XTP              "XTP"
+#define TXT_PROTOCOL__DDP              "DDP"
+#define TXT_PROTOCOL__IDPR_CMTP        "IDPR-CMTP"
+#define TXT_PROTOCOL__TP_PLUSPLUS      "TP++"
+#define TXT_PROTOCOL__IL               "IL"
+#define TXT_PROTOCOL__IPv6             "IPv6"
+#define TXT_PROTOCOL__SDRP             "SDRP"
+#define TXT_PROTOCOL__IPv6_Route       "IPv6-Route"
+#define TXT_PROTOCOL__IPv6_Frag        "IPv6-Frag"
+#define TXT_PROTOCOL__IDRP             "IDRP"
+#define TXT_PROTOCOL__RSVP             "RSVP"
+#define TXT_PROTOCOL__GRE              "GRE"
+#define TXT_PROTOCOL__DSR              "DSR"
+#define TXT_PROTOCOL__BNA              "BNA"
+#define TXT_PROTOCOL__ESP              "ESP"
+#define TXT_PROTOCOL__AH               "AH"
+#define TXT_PROTOCOL__I_NLSP           "I-NLSP"
+#define TXT_PROTOCOL__SWIPE            "SWIPE"
+#define TXT_PROTOCOL__NARP             "NARP"
+#define TXT_PROTOCOL__MOBILE           "MOBILE"
+#define TXT_PROTOCOL__TLSP             "TLSP"
+#define TXT_PROTOCOL__SKIP             "SKIP"
+#define TXT_PROTOCOL__IPv6_ICMP        "IPv6-ICMP"
+#define TXT_PROTOCOL__IPv6_NoNxt       "IPv6-NoNxt"
+#define TXT_PROTOCOL__IPv6_Opts        "IPv6-Opts"
+#define TXT_PROTOCOL__CFTP             "CFTP"
+#define TXT_PROTOCOL__SAT_EXPAK        "SAT-EXPAK"
+#define TXT_PROTOCOL__KRYPTOLAN        "KRYPTOLAN"
+#define TXT_PROTOCOL__RVD              "RVD"
+#define TXT_PROTOCOL__IPPC             "IPPC"
+#define TXT_PROTOCOL__SAT_MON          "SAT-MON"
+#define TXT_PROTOCOL__VISA             "VISA"
+#define TXT_PROTOCOL__IPCV             "IPCV"
+#define TXT_PROTOCOL__CPNX             "CPNX"
+#define TXT_PROTOCOL__CPHB             "CPHB"
+#define TXT_PROTOCOL__WSN              "WSN"
+#define TXT_PROTOCOL__PVP              "PVP"
+#define TXT_PROTOCOL__BR_SAT_MON       "BR-SAT-MON"
+#define TXT_PROTOCOL__SUN_ND           "SUN-ND"
+#define TXT_PROTOCOL__WB_MON           "WB-MON"
+#define TXT_PROTOCOL__WB_EXPAK         "WB-EXPAK"
+#define TXT_PROTOCOL__ISO_IP           "ISO-IP"
+#define TXT_PROTOCOL__VMTP             "VMTP"
+#define TXT_PROTOCOL__SECURE_VMTP      "SECURE-VMTP"
+#define TXT_PROTOCOL__VINES            "VINES"
+#define TXT_PROTOCOL__IPTM             "IPTM"
+#define TXT_PROTOCOL__NSFNET_IGP       "NSFNET-IGP"
+#define TXT_PROTOCOL__DGP              "DGP"
+#define TXT_PROTOCOL__TCF              "TCF"
+#define TXT_PROTOCOL__EIGRP            "EIGRP"
+#define TXT_PROTOCOL__OSPFIGP          "OSPFIGP"
+#define TXT_PROTOCOL__Sprite_RPC       "Sprite-RPC"
+#define TXT_PROTOCOL__LARP             "LARP"
+#define TXT_PROTOCOL__MTP              "MTP"
+#define TXT_PROTOCOL__AX_25            "AX.25"
+#define TXT_PROTOCOL__IPIP             "IPIP"
+#define TXT_PROTOCOL__MICP             "MICP"
+#define TXT_PROTOCOL__SCC_SP           "SCC-SP"
+#define TXT_PROTOCOL__ETHERIP          "ETHERIP"
+#define TXT_PROTOCOL__ENCAP            "ENCAP"
+#define TXT_PROTOCOL__GMTP             "GMTP"
+#define TXT_PROTOCOL__IFMP             "IFMP"
+#define TXT_PROTOCOL__PNNI             "PNNI"
+#define TXT_PROTOCOL__PIM              "PIM"
+#define TXT_PROTOCOL__ARIS             "ARIS"
+#define TXT_PROTOCOL__SCPS             "SCPS"
+#define TXT_PROTOCOL__QNX              "QNX"
+#define TXT_PROTOCOL__AN               "A/N"
+#define TXT_PROTOCOL__IPComp           "IPComp"
+#define TXT_PROTOCOL__SNP              "SNP"
+#define TXT_PROTOCOL__Compaq_Peer      "Compaq-Peer"
+#define TXT_PROTOCOL__IPX_in_IP        "IPX-in-IP"
+#define TXT_PROTOCOL__VRRP             "VRRP"
+#define TXT_PROTOCOL__PGM              "PGM"
+#define TXT_PROTOCOL__L2TP             "L2TP"
+#define TXT_PROTOCOL__DDX              "DDX"
+#define TXT_PROTOCOL__IATP             "IATP"
+#define TXT_PROTOCOL__STP              "STP"
+#define TXT_PROTOCOL__SRP              "SRP"
+#define TXT_PROTOCOL__UTI              "UTI"
+#define TXT_PROTOCOL__SMP              "SMP"
+#define TXT_PROTOCOL__SM               "SM"
+#define TXT_PROTOCOL__PTP              "PTP"
+#define TXT_PROTOCOL__ISIS_over_IPv4   "ISIS_over_IPv4"
+#define TXT_PROTOCOL__FIRE             "FIRE"
+#define TXT_PROTOCOL__CRTP             "CRTP"
+#define TXT_PROTOCOL__CRUDP            "CRUDP"
+#define TXT_PROTOCOL__SSCOPMCE         "SSCOPMCE"
+#define TXT_PROTOCOL__IPLT             "IPLT"
+#define TXT_PROTOCOL__SPS              "SPS"
+#define TXT_PROTOCOL__PIPE             "PIPE"
+#define TXT_PROTOCOL__SCTP             "SCTP"
+#define TXT_PROTOCOL__FC               "FC"
+#define TXT_PROTOCOL__RSVP_E2E_IGNORE  "RSVP-E2E-IGNORE"
+#define TXT_PROTOCOL__Mobility_Header  "Mobility_Header"
+#define TXT_PROTOCOL__UDPLite          "UDPLite"
+#define TXT_PROTOCOL__MPLS_in_IP       "MPLS-in-IP"
+#define TXT_PROTOCOL__manet            "manet"
+#define TXT_PROTOCOL__HIP              "HIP"
+#define TXT_PROTOCOL__Shim6            "Shim6"
+#define TXT_PROTOCOL__WESP             "WESP"
+#define TXT_PROTOCOL__ROHC             "ROHC"
+#define TXT_PROTOCOL__Ethernet         "Ethernet"
+
+/* indexed by elements of 'fpp_fp_offset_from_t' */
+#define TXT_OFFSET_FROM__XXX_RES0_XXX  "__XXX_res0_XXX__"
+#define TXT_OFFSET_FROM__XXX_RES1_XXX  "__XXX_res1_XXX__"
+#define TXT_OFFSET_FROM__L2            "L2"
+#define TXT_OFFSET_FROM__L3            "L3"
+#define TXT_OFFSET_FROM__L4            "L4"
+extern const uint8_t OFFSET_FROMS__MIN;
+extern const uint8_t OFFSET_FROMS__MAX;
+
+/* indexed by elements of 'fpp_fp_match_action_t' */
+#define TXT_MATCH_ACTION__ACCEPT     "ACCEPT"
+#define TXT_MATCH_ACTION__REJECT     "REJECT"
+#define TXT_MATCH_ACTION__NEXT_RULE  "NEXT_RULE"
+extern const uint8_t MATCH_ACTIONS__MAX;
+
+/* indexed by values of bridge actions (see doxygen for 'fpp_l2_bd_cmd_t.ucast_hit') */
+#define TXT_BD_ACTION__FORWARD  "FORWARD"
+#define TXT_BD_ACTION__FLOOD    "FLOOD"
+#define TXT_BD_ACTION__PUNT     "PUNT"
+#define TXT_BD_ACTION__DISCARD  "DISCARD"
+extern const uint8_t BD_ACTIONS__MAX;
+
+/* indexed by elements of 'fpp_spd_action_t' */
+#define TXT_SPD_ACTION__XXX_RES0_XXX  "__XXX_res0_XXX__"
+#define TXT_SPD_ACTION__DISCARD       "DISCARD"
+#define TXT_SPD_ACTION__BYPASS        "BYPASS"
+#define TXT_SPD_ACTION__ENCODE        "ENCODE"
+#define TXT_SPD_ACTION__DECODE        "DECODE"
+extern const uint8_t SPD_ACTIONS__MAX;
+
+/* indexed by queue mode IDs (see doxygen for 'fpp_qos_queue_cmd_t.mode') */
+#define TXT_QUE_MODE__DISABLED   "DISABLED"
+#define TXT_QUE_MODE__DEFAULT    "DEFAULT"
+#define TXT_QUE_MODE__TAIL_DROP  "TAIL_DROP"
+#define TXT_QUE_MODE__WRED       "WRED"
+
+/* special value for que_zprob (que_zprob is mainly numeric, but there is a special textual input option "KEEP" (meaning "do not change that particular value") */
+#define TXT_QUE_ZPROB__KEEP      "K"
+
+/* indexed by scheduler mode IDs (see doxygen for 'fpp_qos_scheduler_cmd_t.mode') */
+#define TXT_SCH_MODE__DISABLED     "DISABLED"
+#define TXT_SCH_MODE__DATA_RATE    "DATA_RATE"
+#define TXT_SCH_MODE__PACKET_RATE  "PACKET_RATE"
+
+/* indexed by scheduler algorithm IDs (see doxygen for 'fpp_qos_scheduler_cmd_t.algo') */
+#define TXT_SCH_ALGO__PQ    "PQ"
+#define TXT_SCH_ALGO__DWRR  "DWRR"
+#define TXT_SCH_ALGO__RR    "RR"
+#define TXT_SCH_ALGO__WRR   "WRR"
+
+/* indexed by scheduler input IDs (see doxygen for 'fpp_qos_scheduler_cmd_t.input' and 'fpp_qos_scheduler_cmd_t.input_src') */
+#define TXT_SCH_IN__QUE0      "que0"
+#define TXT_SCH_IN__QUE1      "que1"
+#define TXT_SCH_IN__QUE2      "que2"
+#define TXT_SCH_IN__QUE3      "que3"
+#define TXT_SCH_IN__QUE4      "que4"
+#define TXT_SCH_IN__QUE5      "que5"
+#define TXT_SCH_IN__QUE6      "que6"
+#define TXT_SCH_IN__QUE7      "que7"
+#define TXT_SCH_IN__SCH0_OUT  "sch0_out"
+    /* special elements; these are a part of input IDs, but are NOT indexed by input IDs */
+#define TXT_SCH_IN__DISABLED  "D"
+#define TXT_SCH_IN__KEEP      "K"
+
+
+/* indexed by shaper mode IDs (see doxygen for 'fpp_qos_shaper_cmd_t.mode') */
+#define TXT_SHP_MODE__DISABLED     "DISABLED"
+#define TXT_SHP_MODE__DATA_RATE    "DATA_RATE"
+#define TXT_SHP_MODE__PACKET_RATE  "PACKET_RATE"
+
+/* indexed by shaper position IDs (see doxygen for 'fpp_qos_shaper_cmd_t.position') */
+#define TXT_SHP_POS__SCH1_OUT  "sch1_out"
+#define TXT_SHP_POS__SCH1_IN0  "sch1_in0"
+#define TXT_SHP_POS__SCH1_IN1  "sch1_in1"
+#define TXT_SHP_POS__SCH1_IN2  "sch1_in2"
+#define TXT_SHP_POS__SCH1_IN3  "sch1_in3"
+#define TXT_SHP_POS__SCH1_IN4  "sch1_in4"
+#define TXT_SHP_POS__SCH1_IN5  "sch1_in5"
+#define TXT_SHP_POS__SCH1_IN6  "sch1_in6"
+#define TXT_SHP_POS__SCH1_IN7  "sch1_in7"
+#define TXT_SHP_POS__SCH0_IN0  "sch0_in0"
+#define TXT_SHP_POS__SCH0_IN1  "sch0_in1"
+#define TXT_SHP_POS__SCH0_IN2  "sch0_in2"
+#define TXT_SHP_POS__SCH0_IN3  "sch0_in3"
+#define TXT_SHP_POS__SCH0_IN4  "sch0_in4"
+#define TXT_SHP_POS__SCH0_IN5  "sch0_in5"
+#define TXT_SHP_POS__SCH0_IN6  "sch0_in6"
+#define TXT_SHP_POS__SCH0_IN7  "sch0_in7"
+    /* special elements; these are a part of shaper position IDs, but are NOT indexed by shaper position IDs */
+#define TXT_SHP_POS__DISABLED  "DISABLED"
+
+
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+const char* cli_value2txt_if_mode(uint8_t value);
+int         cli_txt2value_if_mode(uint8_t* p_rtn_value, const char* p_txt);
+
+const char* cli_value2txt_if_block_state(uint8_t value);
+int         cli_txt2value_if_block_state(uint8_t* p_rtn_value, const char* p_txt);
+
+const char* cli_value2txt_on_off(uint8_t value);
+int         cli_txt2value_on_off(uint8_t* p_rtn_value, const char* p_txt);
+
+const char* cli_value2txt_en_dis(uint8_t value);
+int         cli_txt2value_en_dis(uint8_t* p_rtn_value, const char* p_txt);
+
+const char* cli_value2txt_or_and(uint8_t value);
+int         cli_txt2value_or_and(uint8_t* p_rtn_value, const char* p_txt);
+
+const char* cli_value2txt_phyif(uint8_t value);
+int         cli_txt2value_phyif(uint8_t* p_rtn_value, const char* p_txt);
+
+const char* cli_value2txt_match_rule(uint8_t value);
+int         cli_txt2value_match_rule(uint8_t* p_rtn_value, const char* p_txt);
+
+const char* cli_value2txt_protocol(uint8_t value);
+int         cli_txt2value_protocol(uint8_t* p_rtn_value, const char* p_txt);
+
+const char* cli_value2txt_offset_from(uint8_t value);
+int         cli_txt2value_offset_from(uint8_t* p_rtn_value, const char* p_txt);
+
+const char* cli_value2txt_match_action(uint8_t value);
+int         cli_txt2value_match_action(uint8_t* p_rtn_value, const char* p_txt);
+
+const char* cli_value2txt_bd_action(uint8_t value);
+int         cli_txt2value_bd_action(uint8_t* p_rtn_value, const char* p_txt);
+
+const char* cli_value2txt_spd_action(uint8_t value);
+int         cli_txt2value_spd_action(uint8_t* p_rtn_value, const char* p_txt);
+
+const char* cli_value2txt_que_mode(uint8_t value);
+int         cli_txt2value_que_mode(uint8_t* p_rtn_value, const char* p_txt);
+
+bool        cli_que_zprob_is_not_keep(uint8_t value);
+int         cli_txt2value_que_zprob_keep(uint8_t* p_rtn_value, const char* p_txt);
+
+const char* cli_value2txt_sch_mode(uint8_t value);
+int         cli_txt2value_sch_mode(uint8_t* p_rtn_value, const char* p_txt);
+
+const char* cli_value2txt_sch_algo(uint8_t value);
+int         cli_txt2value_sch_algo(uint8_t* p_rtn_value, const char* p_txt);
+
+bool        cli_sch_in_is_not_dis(uint8_t value);
+bool        cli_sch_in_is_not_keep(uint8_t value);
+const char* cli_value2txt_sch_in(uint8_t value);
+int         cli_txt2value_sch_in(uint8_t* p_rtn_value, const char* p_txt);
+
+const char* cli_value2txt_shp_mode(uint8_t value);
+int         cli_txt2value_shp_mode(uint8_t* p_rtn_value, const char* p_txt);
+
+bool        cli_shp_pos_is_not_dis(uint8_t value);
+const char* cli_value2txt_shp_pos(uint8_t value);
+int         cli_txt2value_shp_pos(uint8_t* p_rtn_value, const char* p_txt);
+
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_cli_def_opts.c b/sw/libfci_cli/src/libfci_cli_def_opts.c
new file mode 100644
index 0000000..13acd64
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_def_opts.c
@@ -0,0 +1,8036 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#include <assert.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <string.h>
+#include <getopt.h>
+#include "libfci_cli_common.h"
+#include "libfci_cli_def_opts.h"
+
+/* ==== TESTMODE vars ====================================================== */
+
+#if !defined(NDEBUG)
+/* empty */
+#endif
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+/* shortopt - mapping defined items into optstring */
+static const char txt_shortopts[] = 
+{  
+    ':',  /* special flag: if set, then 'getopt()' fnc family will return ':' if opt argument is missing */
+    
+    /* OPT_00_NO_OPTION does not have a shortopt version */
+    
+#ifdef OPT_01_ENUM_NAME
+  #if (OPT_01_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_01_CLI_SHORT_CODE_CHR,
+    #if (OPT_01_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_02_ENUM_NAME
+  #if (OPT_02_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_02_CLI_SHORT_CODE_CHR,
+    #if (OPT_02_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_03_ENUM_NAME
+  #if (OPT_03_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_03_CLI_SHORT_CODE_CHR,
+    #if (OPT_03_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_04_ENUM_NAME
+  #if (OPT_04_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_04_CLI_SHORT_CODE_CHR,
+    #if (OPT_04_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_05_ENUM_NAME
+  #if (OPT_05_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_05_CLI_SHORT_CODE_CHR,
+    #if (OPT_05_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_06_ENUM_NAME
+  #if (OPT_06_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_06_CLI_SHORT_CODE_CHR,
+    #if (OPT_06_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_07_ENUM_NAME
+  #if (OPT_07_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_07_CLI_SHORT_CODE_CHR,
+    #if (OPT_07_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_08_ENUM_NAME
+  #if (OPT_08_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_08_CLI_SHORT_CODE_CHR,
+    #if (OPT_08_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_09_ENUM_NAME
+  #if (OPT_09_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_09_CLI_SHORT_CODE_CHR,
+    #if (OPT_09_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+    
+#ifdef OPT_10_ENUM_NAME
+  #if (OPT_10_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_10_CLI_SHORT_CODE_CHR,
+    #if (OPT_10_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_11_ENUM_NAME
+  #if (OPT_11_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_11_CLI_SHORT_CODE_CHR,
+    #if (OPT_11_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_12_ENUM_NAME
+  #if (OPT_12_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_12_CLI_SHORT_CODE_CHR,
+    #if (OPT_12_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_13_ENUM_NAME
+  #if (OPT_13_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_13_CLI_SHORT_CODE_CHR,
+    #if (OPT_13_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_14_ENUM_NAME
+  #if (OPT_14_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_14_CLI_SHORT_CODE_CHR,
+    #if (OPT_14_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_15_ENUM_NAME
+  #if (OPT_15_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_15_CLI_SHORT_CODE_CHR,
+    #if (OPT_15_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_16_ENUM_NAME
+  #if (OPT_16_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_16_CLI_SHORT_CODE_CHR,
+    #if (OPT_16_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_17_ENUM_NAME
+  #if (OPT_17_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_17_CLI_SHORT_CODE_CHR,
+    #if (OPT_17_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_18_ENUM_NAME
+  #if (OPT_18_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_18_CLI_SHORT_CODE_CHR,
+    #if (OPT_18_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_19_ENUM_NAME
+  #if (OPT_19_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_19_CLI_SHORT_CODE_CHR,
+    #if (OPT_19_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+    
+#ifdef OPT_20_ENUM_NAME
+  #if (OPT_20_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_20_CLI_SHORT_CODE_CHR,
+    #if (OPT_20_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_21_ENUM_NAME
+  #if (OPT_21_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_21_CLI_SHORT_CODE_CHR,
+    #if (OPT_21_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_22_ENUM_NAME
+  #if (OPT_22_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_22_CLI_SHORT_CODE_CHR,
+    #if (OPT_22_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_23_ENUM_NAME
+  #if (OPT_23_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_23_CLI_SHORT_CODE_CHR,
+    #if (OPT_23_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_24_ENUM_NAME
+  #if (OPT_24_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_24_CLI_SHORT_CODE_CHR,
+    #if (OPT_24_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_25_ENUM_NAME
+  #if (OPT_25_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_25_CLI_SHORT_CODE_CHR,
+    #if (OPT_25_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_26_ENUM_NAME
+  #if (OPT_26_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_26_CLI_SHORT_CODE_CHR,
+    #if (OPT_26_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_27_ENUM_NAME
+  #if (OPT_27_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_27_CLI_SHORT_CODE_CHR,
+    #if (OPT_27_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_28_ENUM_NAME
+  #if (OPT_28_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_28_CLI_SHORT_CODE_CHR,
+    #if (OPT_28_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_29_ENUM_NAME
+  #if (OPT_29_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_29_CLI_SHORT_CODE_CHR,
+    #if (OPT_29_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+    
+#ifdef OPT_30_ENUM_NAME
+  #if (OPT_30_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_30_CLI_SHORT_CODE_CHR,
+    #if (OPT_30_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_31_ENUM_NAME
+  #if (OPT_31_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_31_CLI_SHORT_CODE_CHR,
+    #if (OPT_31_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_32_ENUM_NAME
+  #if (OPT_32_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_32_CLI_SHORT_CODE_CHR,
+    #if (OPT_32_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_33_ENUM_NAME
+  #if (OPT_33_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_33_CLI_SHORT_CODE_CHR,
+    #if (OPT_33_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_34_ENUM_NAME
+  #if (OPT_34_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_34_CLI_SHORT_CODE_CHR,
+    #if (OPT_34_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_35_ENUM_NAME
+  #if (OPT_35_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_35_CLI_SHORT_CODE_CHR,
+    #if (OPT_35_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_36_ENUM_NAME
+  #if (OPT_36_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_36_CLI_SHORT_CODE_CHR,
+    #if (OPT_36_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_37_ENUM_NAME
+  #if (OPT_37_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_37_CLI_SHORT_CODE_CHR,
+    #if (OPT_37_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_38_ENUM_NAME
+  #if (OPT_38_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_38_CLI_SHORT_CODE_CHR,
+    #if (OPT_38_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_39_ENUM_NAME
+  #if (OPT_39_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_39_CLI_SHORT_CODE_CHR,
+    #if (OPT_39_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+    
+#ifdef OPT_40_ENUM_NAME
+  #if (OPT_40_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_40_CLI_SHORT_CODE_CHR,
+    #if (OPT_40_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_41_ENUM_NAME
+  #if (OPT_41_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_41_CLI_SHORT_CODE_CHR,
+    #if (OPT_41_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_42_ENUM_NAME
+  #if (OPT_42_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_42_CLI_SHORT_CODE_CHR,
+    #if (OPT_42_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_43_ENUM_NAME
+  #if (OPT_43_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_43_CLI_SHORT_CODE_CHR,
+    #if (OPT_43_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_44_ENUM_NAME
+  #if (OPT_44_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_44_CLI_SHORT_CODE_CHR,
+    #if (OPT_44_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_45_ENUM_NAME
+  #if (OPT_45_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_45_CLI_SHORT_CODE_CHR,
+    #if (OPT_45_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_46_ENUM_NAME
+  #if (OPT_46_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_46_CLI_SHORT_CODE_CHR,
+    #if (OPT_46_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_47_ENUM_NAME
+  #if (OPT_47_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_47_CLI_SHORT_CODE_CHR,
+    #if (OPT_47_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_48_ENUM_NAME
+  #if (OPT_48_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_48_CLI_SHORT_CODE_CHR,
+    #if (OPT_48_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_49_ENUM_NAME
+  #if (OPT_49_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_49_CLI_SHORT_CODE_CHR,
+    #if (OPT_49_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+    
+#ifdef OPT_50_ENUM_NAME
+  #if (OPT_50_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_50_CLI_SHORT_CODE_CHR,
+    #if (OPT_50_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_51_ENUM_NAME
+  #if (OPT_51_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_51_CLI_SHORT_CODE_CHR,
+    #if (OPT_51_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_52_ENUM_NAME
+  #if (OPT_52_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_52_CLI_SHORT_CODE_CHR,
+    #if (OPT_52_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_53_ENUM_NAME
+  #if (OPT_53_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_53_CLI_SHORT_CODE_CHR,
+    #if (OPT_53_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_54_ENUM_NAME
+  #if (OPT_54_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_54_CLI_SHORT_CODE_CHR,
+    #if (OPT_54_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_55_ENUM_NAME
+  #if (OPT_55_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_55_CLI_SHORT_CODE_CHR,
+    #if (OPT_55_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_56_ENUM_NAME
+  #if (OPT_56_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_56_CLI_SHORT_CODE_CHR,
+    #if (OPT_56_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_57_ENUM_NAME
+  #if (OPT_57_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_57_CLI_SHORT_CODE_CHR,
+    #if (OPT_57_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_58_ENUM_NAME
+  #if (OPT_58_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_58_CLI_SHORT_CODE_CHR,
+    #if (OPT_58_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_59_ENUM_NAME
+  #if (OPT_59_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_59_CLI_SHORT_CODE_CHR,
+    #if (OPT_59_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+    
+#ifdef OPT_60_ENUM_NAME
+  #if (OPT_60_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_60_CLI_SHORT_CODE_CHR,
+    #if (OPT_60_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_61_ENUM_NAME
+  #if (OPT_61_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_61_CLI_SHORT_CODE_CHR,
+    #if (OPT_61_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_62_ENUM_NAME
+  #if (OPT_62_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_62_CLI_SHORT_CODE_CHR,
+    #if (OPT_62_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_63_ENUM_NAME
+  #if (OPT_63_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_63_CLI_SHORT_CODE_CHR,
+    #if (OPT_63_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_64_ENUM_NAME
+  #if (OPT_64_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_64_CLI_SHORT_CODE_CHR,
+    #if (OPT_64_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_65_ENUM_NAME
+  #if (OPT_65_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_65_CLI_SHORT_CODE_CHR,
+    #if (OPT_65_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_66_ENUM_NAME
+  #if (OPT_66_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_66_CLI_SHORT_CODE_CHR,
+    #if (OPT_66_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_67_ENUM_NAME
+  #if (OPT_67_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_67_CLI_SHORT_CODE_CHR,
+    #if (OPT_67_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_68_ENUM_NAME
+  #if (OPT_68_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_68_CLI_SHORT_CODE_CHR,
+    #if (OPT_68_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_69_ENUM_NAME
+  #if (OPT_69_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_69_CLI_SHORT_CODE_CHR,
+    #if (OPT_69_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+    
+#ifdef OPT_70_ENUM_NAME
+  #if (OPT_70_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_70_CLI_SHORT_CODE_CHR,
+    #if (OPT_70_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_71_ENUM_NAME
+  #if (OPT_71_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_71_CLI_SHORT_CODE_CHR,
+    #if (OPT_71_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_72_ENUM_NAME
+  #if (OPT_72_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_72_CLI_SHORT_CODE_CHR,
+    #if (OPT_72_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_73_ENUM_NAME
+  #if (OPT_73_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_73_CLI_SHORT_CODE_CHR,
+    #if (OPT_73_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_74_ENUM_NAME
+  #if (OPT_74_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_74_CLI_SHORT_CODE_CHR,
+    #if (OPT_74_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_75_ENUM_NAME
+  #if (OPT_75_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_75_CLI_SHORT_CODE_CHR,
+    #if (OPT_75_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_76_ENUM_NAME
+  #if (OPT_76_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_76_CLI_SHORT_CODE_CHR,
+    #if (OPT_76_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_77_ENUM_NAME
+  #if (OPT_77_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_77_CLI_SHORT_CODE_CHR,
+    #if (OPT_77_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_78_ENUM_NAME
+  #if (OPT_78_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_78_CLI_SHORT_CODE_CHR,
+    #if (OPT_78_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_79_ENUM_NAME
+  #if (OPT_79_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_79_CLI_SHORT_CODE_CHR,
+    #if (OPT_79_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+    
+#ifdef OPT_80_ENUM_NAME
+  #if (OPT_80_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_80_CLI_SHORT_CODE_CHR,
+    #if (OPT_80_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_81_ENUM_NAME
+  #if (OPT_81_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_81_CLI_SHORT_CODE_CHR,
+    #if (OPT_81_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_82_ENUM_NAME
+  #if (OPT_82_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_82_CLI_SHORT_CODE_CHR,
+    #if (OPT_82_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_83_ENUM_NAME
+  #if (OPT_83_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_83_CLI_SHORT_CODE_CHR,
+    #if (OPT_83_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_84_ENUM_NAME
+  #if (OPT_84_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_84_CLI_SHORT_CODE_CHR,
+    #if (OPT_84_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_85_ENUM_NAME
+  #if (OPT_85_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_85_CLI_SHORT_CODE_CHR,
+    #if (OPT_85_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_86_ENUM_NAME
+  #if (OPT_86_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_86_CLI_SHORT_CODE_CHR,
+    #if (OPT_86_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_87_ENUM_NAME
+  #if (OPT_87_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_87_CLI_SHORT_CODE_CHR,
+    #if (OPT_87_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_88_ENUM_NAME
+  #if (OPT_88_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_88_CLI_SHORT_CODE_CHR,
+    #if (OPT_88_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_89_ENUM_NAME
+  #if (OPT_89_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_89_CLI_SHORT_CODE_CHR,
+    #if (OPT_89_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+    
+#ifdef OPT_90_ENUM_NAME
+  #if (OPT_90_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_90_CLI_SHORT_CODE_CHR,
+    #if (OPT_90_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_91_ENUM_NAME
+  #if (OPT_91_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_91_CLI_SHORT_CODE_CHR,
+    #if (OPT_91_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_92_ENUM_NAME
+  #if (OPT_92_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_92_CLI_SHORT_CODE_CHR,
+    #if (OPT_92_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_93_ENUM_NAME
+  #if (OPT_93_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_93_CLI_SHORT_CODE_CHR,
+    #if (OPT_93_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_94_ENUM_NAME
+  #if (OPT_94_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_94_CLI_SHORT_CODE_CHR,
+    #if (OPT_94_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_95_ENUM_NAME
+  #if (OPT_95_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_95_CLI_SHORT_CODE_CHR,
+    #if (OPT_95_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_96_ENUM_NAME
+  #if (OPT_96_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_96_CLI_SHORT_CODE_CHR,
+    #if (OPT_96_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_97_ENUM_NAME
+  #if (OPT_97_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_97_CLI_SHORT_CODE_CHR,
+    #if (OPT_97_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_98_ENUM_NAME
+  #if (OPT_98_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_98_CLI_SHORT_CODE_CHR,
+    #if (OPT_98_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_99_ENUM_NAME
+  #if (OPT_99_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_99_CLI_SHORT_CODE_CHR,
+    #if (OPT_99_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+    
+#ifdef OPT_100_ENUM_NAME
+  #if (OPT_100_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_100_CLI_SHORT_CODE_CHR,
+    #if (OPT_100_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_101_ENUM_NAME
+  #if (OPT_101_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_101_CLI_SHORT_CODE_CHR,
+    #if (OPT_101_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_102_ENUM_NAME
+  #if (OPT_102_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_102_CLI_SHORT_CODE_CHR,
+    #if (OPT_102_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_103_ENUM_NAME
+  #if (OPT_103_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_103_CLI_SHORT_CODE_CHR,
+    #if (OPT_103_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_104_ENUM_NAME
+  #if (OPT_104_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_104_CLI_SHORT_CODE_CHR,
+    #if (OPT_104_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_105_ENUM_NAME
+  #if (OPT_105_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_105_CLI_SHORT_CODE_CHR,
+    #if (OPT_105_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_106_ENUM_NAME
+  #if (OPT_106_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_106_CLI_SHORT_CODE_CHR,
+    #if (OPT_106_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_107_ENUM_NAME
+  #if (OPT_107_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_107_CLI_SHORT_CODE_CHR,
+    #if (OPT_107_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_108_ENUM_NAME
+  #if (OPT_108_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_108_CLI_SHORT_CODE_CHR,
+    #if (OPT_108_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_109_ENUM_NAME
+  #if (OPT_109_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_109_CLI_SHORT_CODE_CHR,
+    #if (OPT_109_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+    
+#ifdef OPT_110_ENUM_NAME
+  #if (OPT_110_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_110_CLI_SHORT_CODE_CHR,
+    #if (OPT_110_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_111_ENUM_NAME
+  #if (OPT_111_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_111_CLI_SHORT_CODE_CHR,
+    #if (OPT_111_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_112_ENUM_NAME
+  #if (OPT_112_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_112_CLI_SHORT_CODE_CHR,
+    #if (OPT_112_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_113_ENUM_NAME
+  #if (OPT_113_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_113_CLI_SHORT_CODE_CHR,
+    #if (OPT_113_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_114_ENUM_NAME
+  #if (OPT_114_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_114_CLI_SHORT_CODE_CHR,
+    #if (OPT_114_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_115_ENUM_NAME
+  #if (OPT_115_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_115_CLI_SHORT_CODE_CHR,
+    #if (OPT_115_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_116_ENUM_NAME
+  #if (OPT_116_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_116_CLI_SHORT_CODE_CHR,
+    #if (OPT_116_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_117_ENUM_NAME
+  #if (OPT_117_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_117_CLI_SHORT_CODE_CHR,
+    #if (OPT_117_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_118_ENUM_NAME
+  #if (OPT_118_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_118_CLI_SHORT_CODE_CHR,
+    #if (OPT_118_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_119_ENUM_NAME
+  #if (OPT_119_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_119_CLI_SHORT_CODE_CHR,
+    #if (OPT_119_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+    
+#ifdef OPT_120_ENUM_NAME
+  #if (OPT_120_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_120_CLI_SHORT_CODE_CHR,
+    #if (OPT_120_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_121_ENUM_NAME
+  #if (OPT_121_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_121_CLI_SHORT_CODE_CHR,
+    #if (OPT_121_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_122_ENUM_NAME
+  #if (OPT_122_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_122_CLI_SHORT_CODE_CHR,
+    #if (OPT_122_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_123_ENUM_NAME
+  #if (OPT_123_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_123_CLI_SHORT_CODE_CHR,
+    #if (OPT_123_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_124_ENUM_NAME
+  #if (OPT_124_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_124_CLI_SHORT_CODE_CHR,
+    #if (OPT_124_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_125_ENUM_NAME
+  #if (OPT_125_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_125_CLI_SHORT_CODE_CHR,
+    #if (OPT_125_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_126_ENUM_NAME
+  #if (OPT_126_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_126_CLI_SHORT_CODE_CHR,
+    #if (OPT_126_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_127_ENUM_NAME
+  #if (OPT_127_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_127_CLI_SHORT_CODE_CHR,
+    #if (OPT_127_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_128_ENUM_NAME
+  #if (OPT_128_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_128_CLI_SHORT_CODE_CHR,
+    #if (OPT_128_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_129_ENUM_NAME
+  #if (OPT_129_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_129_CLI_SHORT_CODE_CHR,
+    #if (OPT_129_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+    
+#ifdef OPT_130_ENUM_NAME
+  #if (OPT_130_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_130_CLI_SHORT_CODE_CHR,
+    #if (OPT_130_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_131_ENUM_NAME
+  #if (OPT_131_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_131_CLI_SHORT_CODE_CHR,
+    #if (OPT_131_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_132_ENUM_NAME
+  #if (OPT_132_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_132_CLI_SHORT_CODE_CHR,
+    #if (OPT_132_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_133_ENUM_NAME
+  #if (OPT_133_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_133_CLI_SHORT_CODE_CHR,
+    #if (OPT_133_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_134_ENUM_NAME
+  #if (OPT_134_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_134_CLI_SHORT_CODE_CHR,
+    #if (OPT_134_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_135_ENUM_NAME
+  #if (OPT_135_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_135_CLI_SHORT_CODE_CHR,
+    #if (OPT_135_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_136_ENUM_NAME
+  #if (OPT_136_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_136_CLI_SHORT_CODE_CHR,
+    #if (OPT_136_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_137_ENUM_NAME
+  #if (OPT_137_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_137_CLI_SHORT_CODE_CHR,
+    #if (OPT_137_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_138_ENUM_NAME
+  #if (OPT_138_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_138_CLI_SHORT_CODE_CHR,
+    #if (OPT_138_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_139_ENUM_NAME
+  #if (OPT_139_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_139_CLI_SHORT_CODE_CHR,
+    #if (OPT_139_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+    
+#ifdef OPT_140_ENUM_NAME
+  #if (OPT_140_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_140_CLI_SHORT_CODE_CHR,
+    #if (OPT_140_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_141_ENUM_NAME
+  #if (OPT_141_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_141_CLI_SHORT_CODE_CHR,
+    #if (OPT_141_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_142_ENUM_NAME
+  #if (OPT_142_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_142_CLI_SHORT_CODE_CHR,
+    #if (OPT_142_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_143_ENUM_NAME
+  #if (OPT_143_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_143_CLI_SHORT_CODE_CHR,
+    #if (OPT_143_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_144_ENUM_NAME
+  #if (OPT_144_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_144_CLI_SHORT_CODE_CHR,
+    #if (OPT_144_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_145_ENUM_NAME
+  #if (OPT_145_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_145_CLI_SHORT_CODE_CHR,
+    #if (OPT_145_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_146_ENUM_NAME
+  #if (OPT_146_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_146_CLI_SHORT_CODE_CHR,
+    #if (OPT_146_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_147_ENUM_NAME
+  #if (OPT_147_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_147_CLI_SHORT_CODE_CHR,
+    #if (OPT_147_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_148_ENUM_NAME
+  #if (OPT_148_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_148_CLI_SHORT_CODE_CHR,
+    #if (OPT_148_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_149_ENUM_NAME
+  #if (OPT_149_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_149_CLI_SHORT_CODE_CHR,
+    #if (OPT_149_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+    
+#ifdef OPT_150_ENUM_NAME
+  #if (OPT_150_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_150_CLI_SHORT_CODE_CHR,
+    #if (OPT_150_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_151_ENUM_NAME
+  #if (OPT_151_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_151_CLI_SHORT_CODE_CHR,
+    #if (OPT_151_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_152_ENUM_NAME
+  #if (OPT_152_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_152_CLI_SHORT_CODE_CHR,
+    #if (OPT_152_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_153_ENUM_NAME
+  #if (OPT_153_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_153_CLI_SHORT_CODE_CHR,
+    #if (OPT_153_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_154_ENUM_NAME
+  #if (OPT_154_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_154_CLI_SHORT_CODE_CHR,
+    #if (OPT_154_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_155_ENUM_NAME
+  #if (OPT_155_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_155_CLI_SHORT_CODE_CHR,
+    #if (OPT_155_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_156_ENUM_NAME
+  #if (OPT_156_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_156_CLI_SHORT_CODE_CHR,
+    #if (OPT_156_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_157_ENUM_NAME
+  #if (OPT_157_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_157_CLI_SHORT_CODE_CHR,
+    #if (OPT_157_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_158_ENUM_NAME
+  #if (OPT_158_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_158_CLI_SHORT_CODE_CHR,
+    #if (OPT_158_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_159_ENUM_NAME
+  #if (OPT_159_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_159_CLI_SHORT_CODE_CHR,
+    #if (OPT_159_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+    
+#ifdef OPT_160_ENUM_NAME
+  #if (OPT_160_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_160_CLI_SHORT_CODE_CHR,
+    #if (OPT_160_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_161_ENUM_NAME
+  #if (OPT_161_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_161_CLI_SHORT_CODE_CHR,
+    #if (OPT_161_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_162_ENUM_NAME
+  #if (OPT_162_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_162_CLI_SHORT_CODE_CHR,
+    #if (OPT_162_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_163_ENUM_NAME
+  #if (OPT_163_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_163_CLI_SHORT_CODE_CHR,
+    #if (OPT_163_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_164_ENUM_NAME
+  #if (OPT_164_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_164_CLI_SHORT_CODE_CHR,
+    #if (OPT_164_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_165_ENUM_NAME
+  #if (OPT_165_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_165_CLI_SHORT_CODE_CHR,
+    #if (OPT_165_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_166_ENUM_NAME
+  #if (OPT_166_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_166_CLI_SHORT_CODE_CHR,
+    #if (OPT_166_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_167_ENUM_NAME
+  #if (OPT_167_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_167_CLI_SHORT_CODE_CHR,
+    #if (OPT_167_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_168_ENUM_NAME
+  #if (OPT_168_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_168_CLI_SHORT_CODE_CHR,
+    #if (OPT_168_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_169_ENUM_NAME
+  #if (OPT_169_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_169_CLI_SHORT_CODE_CHR,
+    #if (OPT_169_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+    
+#ifdef OPT_170_ENUM_NAME
+  #if (OPT_170_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_170_CLI_SHORT_CODE_CHR,
+    #if (OPT_170_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_171_ENUM_NAME
+  #if (OPT_171_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_171_CLI_SHORT_CODE_CHR,
+    #if (OPT_171_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_172_ENUM_NAME
+  #if (OPT_172_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_172_CLI_SHORT_CODE_CHR,
+    #if (OPT_172_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_173_ENUM_NAME
+  #if (OPT_173_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_173_CLI_SHORT_CODE_CHR,
+    #if (OPT_173_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_174_ENUM_NAME
+  #if (OPT_174_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_174_CLI_SHORT_CODE_CHR,
+    #if (OPT_174_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_175_ENUM_NAME
+  #if (OPT_175_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_175_CLI_SHORT_CODE_CHR,
+    #if (OPT_175_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_176_ENUM_NAME
+  #if (OPT_176_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_176_CLI_SHORT_CODE_CHR,
+    #if (OPT_176_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_177_ENUM_NAME
+  #if (OPT_177_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_177_CLI_SHORT_CODE_CHR,
+    #if (OPT_177_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_178_ENUM_NAME
+  #if (OPT_178_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_178_CLI_SHORT_CODE_CHR,
+    #if (OPT_178_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_179_ENUM_NAME
+  #if (OPT_179_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_179_CLI_SHORT_CODE_CHR,
+    #if (OPT_179_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+    
+#ifdef OPT_180_ENUM_NAME
+  #if (OPT_180_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_180_CLI_SHORT_CODE_CHR,
+    #if (OPT_180_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_181_ENUM_NAME
+  #if (OPT_181_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_181_CLI_SHORT_CODE_CHR,
+    #if (OPT_181_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_182_ENUM_NAME
+  #if (OPT_182_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_182_CLI_SHORT_CODE_CHR,
+    #if (OPT_182_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_183_ENUM_NAME
+  #if (OPT_183_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_183_CLI_SHORT_CODE_CHR,
+    #if (OPT_183_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_184_ENUM_NAME
+  #if (OPT_184_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_184_CLI_SHORT_CODE_CHR,
+    #if (OPT_184_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_185_ENUM_NAME
+  #if (OPT_185_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_185_CLI_SHORT_CODE_CHR,
+    #if (OPT_185_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_186_ENUM_NAME
+  #if (OPT_186_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_186_CLI_SHORT_CODE_CHR,
+    #if (OPT_186_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_187_ENUM_NAME
+  #if (OPT_187_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_187_CLI_SHORT_CODE_CHR,
+    #if (OPT_187_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_188_ENUM_NAME
+  #if (OPT_188_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_188_CLI_SHORT_CODE_CHR,
+    #if (OPT_188_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_189_ENUM_NAME
+  #if (OPT_189_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_189_CLI_SHORT_CODE_CHR,
+    #if (OPT_189_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+    
+#ifdef OPT_190_ENUM_NAME
+  #if (OPT_190_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_190_CLI_SHORT_CODE_CHR,
+    #if (OPT_190_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_191_ENUM_NAME
+  #if (OPT_191_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_191_CLI_SHORT_CODE_CHR,
+    #if (OPT_191_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_192_ENUM_NAME
+  #if (OPT_192_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_192_CLI_SHORT_CODE_CHR,
+    #if (OPT_192_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_193_ENUM_NAME
+  #if (OPT_193_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_193_CLI_SHORT_CODE_CHR,
+    #if (OPT_193_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_194_ENUM_NAME
+  #if (OPT_194_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_194_CLI_SHORT_CODE_CHR,
+    #if (OPT_194_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_195_ENUM_NAME
+  #if (OPT_195_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_195_CLI_SHORT_CODE_CHR,
+    #if (OPT_195_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_196_ENUM_NAME
+  #if (OPT_196_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_196_CLI_SHORT_CODE_CHR,
+    #if (OPT_196_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_197_ENUM_NAME
+  #if (OPT_197_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_197_CLI_SHORT_CODE_CHR,
+    #if (OPT_197_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_198_ENUM_NAME
+  #if (OPT_198_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_198_CLI_SHORT_CODE_CHR,
+    #if (OPT_198_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+#ifdef OPT_199_ENUM_NAME
+  #if (OPT_199_CLI_SHORT_CODE_CHR != OPT_AUTO_CODE)
+       OPT_199_CLI_SHORT_CODE_CHR,
+    #if (OPT_199_HAS_ARG_CHR == 'y')
+       ':',
+    #endif
+  #endif
+#endif
+
+
+    0  /* terminator for 'txt_shortopts[]' */
+};
+
+
+/* longopt - auxiliary preprocessor symbols for REQ_ARG */
+/* OPT_00_NO_OPTION is hardcoded with REQ_ARG symbol '(no_argument)' */
+#ifdef OPT_01_ENUM_NAME
+  #if (OPT_01_HAS_ARG_CHR == 'y')
+    #define OPT_01_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_01_HAS_ARG_CHR == 'n')
+    #define OPT_01_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_02_ENUM_NAME
+  #if (OPT_02_HAS_ARG_CHR == 'y')
+    #define OPT_02_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_02_HAS_ARG_CHR == 'n')
+    #define OPT_02_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_03_ENUM_NAME
+  #if (OPT_03_HAS_ARG_CHR == 'y')
+    #define OPT_03_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_03_HAS_ARG_CHR == 'n')
+    #define OPT_03_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_04_ENUM_NAME
+  #if (OPT_04_HAS_ARG_CHR == 'y')
+    #define OPT_04_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_04_HAS_ARG_CHR == 'n')
+    #define OPT_04_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_05_ENUM_NAME
+  #if (OPT_05_HAS_ARG_CHR == 'y')
+    #define OPT_05_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_05_HAS_ARG_CHR == 'n')
+    #define OPT_05_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_06_ENUM_NAME
+  #if (OPT_06_HAS_ARG_CHR == 'y')
+    #define OPT_06_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_06_HAS_ARG_CHR == 'n')
+    #define OPT_06_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_07_ENUM_NAME
+  #if (OPT_07_HAS_ARG_CHR == 'y')
+    #define OPT_07_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_07_HAS_ARG_CHR == 'n')
+    #define OPT_07_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_08_ENUM_NAME
+  #if (OPT_08_HAS_ARG_CHR == 'y')
+    #define OPT_08_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_08_HAS_ARG_CHR == 'n')
+    #define OPT_08_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_09_ENUM_NAME
+  #if (OPT_09_HAS_ARG_CHR == 'y')
+    #define OPT_09_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_09_HAS_ARG_CHR == 'n')
+    #define OPT_09_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+
+#ifdef OPT_10_ENUM_NAME
+  #if (OPT_10_HAS_ARG_CHR == 'y')
+    #define OPT_10_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_10_HAS_ARG_CHR == 'n')
+    #define OPT_10_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_11_ENUM_NAME
+  #if (OPT_11_HAS_ARG_CHR == 'y')
+    #define OPT_11_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_11_HAS_ARG_CHR == 'n')
+    #define OPT_11_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_12_ENUM_NAME
+  #if (OPT_12_HAS_ARG_CHR == 'y')
+    #define OPT_12_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_12_HAS_ARG_CHR == 'n')
+    #define OPT_12_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_13_ENUM_NAME
+  #if (OPT_13_HAS_ARG_CHR == 'y')
+    #define OPT_13_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_13_HAS_ARG_CHR == 'n')
+    #define OPT_13_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_14_ENUM_NAME
+  #if (OPT_14_HAS_ARG_CHR == 'y')
+    #define OPT_14_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_14_HAS_ARG_CHR == 'n')
+    #define OPT_14_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_15_ENUM_NAME
+  #if (OPT_15_HAS_ARG_CHR == 'y')
+    #define OPT_15_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_15_HAS_ARG_CHR == 'n')
+    #define OPT_15_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_16_ENUM_NAME
+  #if (OPT_16_HAS_ARG_CHR == 'y')
+    #define OPT_16_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_16_HAS_ARG_CHR == 'n')
+    #define OPT_16_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_17_ENUM_NAME
+  #if (OPT_17_HAS_ARG_CHR == 'y')
+    #define OPT_17_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_17_HAS_ARG_CHR == 'n')
+    #define OPT_17_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_18_ENUM_NAME
+  #if (OPT_18_HAS_ARG_CHR == 'y')
+    #define OPT_18_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_18_HAS_ARG_CHR == 'n')
+    #define OPT_18_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_19_ENUM_NAME
+  #if (OPT_19_HAS_ARG_CHR == 'y')
+    #define OPT_19_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_19_HAS_ARG_CHR == 'n')
+    #define OPT_19_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+
+#ifdef OPT_20_ENUM_NAME
+  #if (OPT_20_HAS_ARG_CHR == 'y')
+    #define OPT_20_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_20_HAS_ARG_CHR == 'n')
+    #define OPT_20_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_21_ENUM_NAME
+  #if (OPT_21_HAS_ARG_CHR == 'y')
+    #define OPT_21_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_21_HAS_ARG_CHR == 'n')
+    #define OPT_21_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_22_ENUM_NAME
+  #if (OPT_22_HAS_ARG_CHR == 'y')
+    #define OPT_22_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_22_HAS_ARG_CHR == 'n')
+    #define OPT_22_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_23_ENUM_NAME
+  #if (OPT_23_HAS_ARG_CHR == 'y')
+    #define OPT_23_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_23_HAS_ARG_CHR == 'n')
+    #define OPT_23_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_24_ENUM_NAME
+  #if (OPT_24_HAS_ARG_CHR == 'y')
+    #define OPT_24_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_24_HAS_ARG_CHR == 'n')
+    #define OPT_24_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_25_ENUM_NAME
+  #if (OPT_25_HAS_ARG_CHR == 'y')
+    #define OPT_25_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_25_HAS_ARG_CHR == 'n')
+    #define OPT_25_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_26_ENUM_NAME
+  #if (OPT_26_HAS_ARG_CHR == 'y')
+    #define OPT_26_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_26_HAS_ARG_CHR == 'n')
+    #define OPT_26_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_27_ENUM_NAME
+  #if (OPT_27_HAS_ARG_CHR == 'y')
+    #define OPT_27_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_27_HAS_ARG_CHR == 'n')
+    #define OPT_27_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_28_ENUM_NAME
+  #if (OPT_28_HAS_ARG_CHR == 'y')
+    #define OPT_28_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_28_HAS_ARG_CHR == 'n')
+    #define OPT_28_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_29_ENUM_NAME
+  #if (OPT_29_HAS_ARG_CHR == 'y')
+    #define OPT_29_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_29_HAS_ARG_CHR == 'n')
+    #define OPT_29_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+
+#ifdef OPT_30_ENUM_NAME
+  #if (OPT_30_HAS_ARG_CHR == 'y')
+    #define OPT_30_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_30_HAS_ARG_CHR == 'n')
+    #define OPT_30_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_31_ENUM_NAME
+  #if (OPT_31_HAS_ARG_CHR == 'y')
+    #define OPT_31_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_31_HAS_ARG_CHR == 'n')
+    #define OPT_31_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_32_ENUM_NAME
+  #if (OPT_32_HAS_ARG_CHR == 'y')
+    #define OPT_32_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_32_HAS_ARG_CHR == 'n')
+    #define OPT_32_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_33_ENUM_NAME
+  #if (OPT_33_HAS_ARG_CHR == 'y')
+    #define OPT_33_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_33_HAS_ARG_CHR == 'n')
+    #define OPT_33_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_34_ENUM_NAME
+  #if (OPT_34_HAS_ARG_CHR == 'y')
+    #define OPT_34_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_34_HAS_ARG_CHR == 'n')
+    #define OPT_34_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_35_ENUM_NAME
+  #if (OPT_35_HAS_ARG_CHR == 'y')
+    #define OPT_35_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_35_HAS_ARG_CHR == 'n')
+    #define OPT_35_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_36_ENUM_NAME
+  #if (OPT_36_HAS_ARG_CHR == 'y')
+    #define OPT_36_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_36_HAS_ARG_CHR == 'n')
+    #define OPT_36_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_37_ENUM_NAME
+  #if (OPT_37_HAS_ARG_CHR == 'y')
+    #define OPT_37_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_37_HAS_ARG_CHR == 'n')
+    #define OPT_37_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_38_ENUM_NAME
+  #if (OPT_38_HAS_ARG_CHR == 'y')
+    #define OPT_38_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_38_HAS_ARG_CHR == 'n')
+    #define OPT_38_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_39_ENUM_NAME
+  #if (OPT_39_HAS_ARG_CHR == 'y')
+    #define OPT_39_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_39_HAS_ARG_CHR == 'n')
+    #define OPT_39_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+
+#ifdef OPT_40_ENUM_NAME
+  #if (OPT_40_HAS_ARG_CHR == 'y')
+    #define OPT_40_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_40_HAS_ARG_CHR == 'n')
+    #define OPT_40_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_41_ENUM_NAME
+  #if (OPT_41_HAS_ARG_CHR == 'y')
+    #define OPT_41_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_41_HAS_ARG_CHR == 'n')
+    #define OPT_41_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_42_ENUM_NAME
+  #if (OPT_42_HAS_ARG_CHR == 'y')
+    #define OPT_42_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_42_HAS_ARG_CHR == 'n')
+    #define OPT_42_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_43_ENUM_NAME
+  #if (OPT_43_HAS_ARG_CHR == 'y')
+    #define OPT_43_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_43_HAS_ARG_CHR == 'n')
+    #define OPT_43_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_44_ENUM_NAME
+  #if (OPT_44_HAS_ARG_CHR == 'y')
+    #define OPT_44_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_44_HAS_ARG_CHR == 'n')
+    #define OPT_44_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_45_ENUM_NAME
+  #if (OPT_45_HAS_ARG_CHR == 'y')
+    #define OPT_45_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_45_HAS_ARG_CHR == 'n')
+    #define OPT_45_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_46_ENUM_NAME
+  #if (OPT_46_HAS_ARG_CHR == 'y')
+    #define OPT_46_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_46_HAS_ARG_CHR == 'n')
+    #define OPT_46_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_47_ENUM_NAME
+  #if (OPT_47_HAS_ARG_CHR == 'y')
+    #define OPT_47_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_47_HAS_ARG_CHR == 'n')
+    #define OPT_47_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_48_ENUM_NAME
+  #if (OPT_48_HAS_ARG_CHR == 'y')
+    #define OPT_48_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_48_HAS_ARG_CHR == 'n')
+    #define OPT_48_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_49_ENUM_NAME
+  #if (OPT_49_HAS_ARG_CHR == 'y')
+    #define OPT_49_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_49_HAS_ARG_CHR == 'n')
+    #define OPT_49_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+
+#ifdef OPT_50_ENUM_NAME
+  #if (OPT_50_HAS_ARG_CHR == 'y')
+    #define OPT_50_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_50_HAS_ARG_CHR == 'n')
+    #define OPT_50_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_51_ENUM_NAME
+  #if (OPT_51_HAS_ARG_CHR == 'y')
+    #define OPT_51_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_51_HAS_ARG_CHR == 'n')
+    #define OPT_51_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_52_ENUM_NAME
+  #if (OPT_52_HAS_ARG_CHR == 'y')
+    #define OPT_52_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_52_HAS_ARG_CHR == 'n')
+    #define OPT_52_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_53_ENUM_NAME
+  #if (OPT_53_HAS_ARG_CHR == 'y')
+    #define OPT_53_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_53_HAS_ARG_CHR == 'n')
+    #define OPT_53_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_54_ENUM_NAME
+  #if (OPT_54_HAS_ARG_CHR == 'y')
+    #define OPT_54_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_54_HAS_ARG_CHR == 'n')
+    #define OPT_54_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_55_ENUM_NAME
+  #if (OPT_55_HAS_ARG_CHR == 'y')
+    #define OPT_55_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_55_HAS_ARG_CHR == 'n')
+    #define OPT_55_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_56_ENUM_NAME
+  #if (OPT_56_HAS_ARG_CHR == 'y')
+    #define OPT_56_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_56_HAS_ARG_CHR == 'n')
+    #define OPT_56_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_57_ENUM_NAME
+  #if (OPT_57_HAS_ARG_CHR == 'y')
+    #define OPT_57_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_57_HAS_ARG_CHR == 'n')
+    #define OPT_57_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_58_ENUM_NAME
+  #if (OPT_58_HAS_ARG_CHR == 'y')
+    #define OPT_58_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_58_HAS_ARG_CHR == 'n')
+    #define OPT_58_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_59_ENUM_NAME
+  #if (OPT_59_HAS_ARG_CHR == 'y')
+    #define OPT_59_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_59_HAS_ARG_CHR == 'n')
+    #define OPT_59_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+
+#ifdef OPT_60_ENUM_NAME
+  #if (OPT_60_HAS_ARG_CHR == 'y')
+    #define OPT_60_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_60_HAS_ARG_CHR == 'n')
+    #define OPT_60_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_61_ENUM_NAME
+  #if (OPT_61_HAS_ARG_CHR == 'y')
+    #define OPT_61_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_61_HAS_ARG_CHR == 'n')
+    #define OPT_61_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_62_ENUM_NAME
+  #if (OPT_62_HAS_ARG_CHR == 'y')
+    #define OPT_62_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_62_HAS_ARG_CHR == 'n')
+    #define OPT_62_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_63_ENUM_NAME
+  #if (OPT_63_HAS_ARG_CHR == 'y')
+    #define OPT_63_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_63_HAS_ARG_CHR == 'n')
+    #define OPT_63_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_64_ENUM_NAME
+  #if (OPT_64_HAS_ARG_CHR == 'y')
+    #define OPT_64_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_64_HAS_ARG_CHR == 'n')
+    #define OPT_64_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_65_ENUM_NAME
+  #if (OPT_65_HAS_ARG_CHR == 'y')
+    #define OPT_65_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_65_HAS_ARG_CHR == 'n')
+    #define OPT_65_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_66_ENUM_NAME
+  #if (OPT_66_HAS_ARG_CHR == 'y')
+    #define OPT_66_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_66_HAS_ARG_CHR == 'n')
+    #define OPT_66_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_67_ENUM_NAME
+  #if (OPT_67_HAS_ARG_CHR == 'y')
+    #define OPT_67_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_67_HAS_ARG_CHR == 'n')
+    #define OPT_67_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_68_ENUM_NAME
+  #if (OPT_68_HAS_ARG_CHR == 'y')
+    #define OPT_68_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_68_HAS_ARG_CHR == 'n')
+    #define OPT_68_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_69_ENUM_NAME
+  #if (OPT_69_HAS_ARG_CHR == 'y')
+    #define OPT_69_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_69_HAS_ARG_CHR == 'n')
+    #define OPT_69_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+
+#ifdef OPT_70_ENUM_NAME
+  #if (OPT_70_HAS_ARG_CHR == 'y')
+    #define OPT_70_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_70_HAS_ARG_CHR == 'n')
+    #define OPT_70_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_71_ENUM_NAME
+  #if (OPT_71_HAS_ARG_CHR == 'y')
+    #define OPT_71_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_71_HAS_ARG_CHR == 'n')
+    #define OPT_71_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_72_ENUM_NAME
+  #if (OPT_72_HAS_ARG_CHR == 'y')
+    #define OPT_72_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_72_HAS_ARG_CHR == 'n')
+    #define OPT_72_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_73_ENUM_NAME
+  #if (OPT_73_HAS_ARG_CHR == 'y')
+    #define OPT_73_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_73_HAS_ARG_CHR == 'n')
+    #define OPT_73_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_74_ENUM_NAME
+  #if (OPT_74_HAS_ARG_CHR == 'y')
+    #define OPT_74_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_74_HAS_ARG_CHR == 'n')
+    #define OPT_74_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_75_ENUM_NAME
+  #if (OPT_75_HAS_ARG_CHR == 'y')
+    #define OPT_75_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_75_HAS_ARG_CHR == 'n')
+    #define OPT_75_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_76_ENUM_NAME
+  #if (OPT_76_HAS_ARG_CHR == 'y')
+    #define OPT_76_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_76_HAS_ARG_CHR == 'n')
+    #define OPT_76_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_77_ENUM_NAME
+  #if (OPT_77_HAS_ARG_CHR == 'y')
+    #define OPT_77_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_77_HAS_ARG_CHR == 'n')
+    #define OPT_77_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_78_ENUM_NAME
+  #if (OPT_78_HAS_ARG_CHR == 'y')
+    #define OPT_78_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_78_HAS_ARG_CHR == 'n')
+    #define OPT_78_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_79_ENUM_NAME
+  #if (OPT_79_HAS_ARG_CHR == 'y')
+    #define OPT_79_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_79_HAS_ARG_CHR == 'n')
+    #define OPT_79_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+
+#ifdef OPT_80_ENUM_NAME
+  #if (OPT_80_HAS_ARG_CHR == 'y')
+    #define OPT_80_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_80_HAS_ARG_CHR == 'n')
+    #define OPT_80_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_81_ENUM_NAME
+  #if (OPT_81_HAS_ARG_CHR == 'y')
+    #define OPT_81_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_81_HAS_ARG_CHR == 'n')
+    #define OPT_81_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_82_ENUM_NAME
+  #if (OPT_82_HAS_ARG_CHR == 'y')
+    #define OPT_82_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_82_HAS_ARG_CHR == 'n')
+    #define OPT_82_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_83_ENUM_NAME
+  #if (OPT_83_HAS_ARG_CHR == 'y')
+    #define OPT_83_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_83_HAS_ARG_CHR == 'n')
+    #define OPT_83_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_84_ENUM_NAME
+  #if (OPT_84_HAS_ARG_CHR == 'y')
+    #define OPT_84_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_84_HAS_ARG_CHR == 'n')
+    #define OPT_84_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_85_ENUM_NAME
+  #if (OPT_85_HAS_ARG_CHR == 'y')
+    #define OPT_85_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_85_HAS_ARG_CHR == 'n')
+    #define OPT_85_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_86_ENUM_NAME
+  #if (OPT_86_HAS_ARG_CHR == 'y')
+    #define OPT_86_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_86_HAS_ARG_CHR == 'n')
+    #define OPT_86_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_87_ENUM_NAME
+  #if (OPT_87_HAS_ARG_CHR == 'y')
+    #define OPT_87_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_87_HAS_ARG_CHR == 'n')
+    #define OPT_87_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_88_ENUM_NAME
+  #if (OPT_88_HAS_ARG_CHR == 'y')
+    #define OPT_88_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_88_HAS_ARG_CHR == 'n')
+    #define OPT_88_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_89_ENUM_NAME
+  #if (OPT_89_HAS_ARG_CHR == 'y')
+    #define OPT_89_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_89_HAS_ARG_CHR == 'n')
+    #define OPT_89_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+
+#ifdef OPT_90_ENUM_NAME
+  #if (OPT_90_HAS_ARG_CHR == 'y')
+    #define OPT_90_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_90_HAS_ARG_CHR == 'n')
+    #define OPT_90_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_91_ENUM_NAME
+  #if (OPT_91_HAS_ARG_CHR == 'y')
+    #define OPT_91_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_91_HAS_ARG_CHR == 'n')
+    #define OPT_91_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_92_ENUM_NAME
+  #if (OPT_92_HAS_ARG_CHR == 'y')
+    #define OPT_92_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_92_HAS_ARG_CHR == 'n')
+    #define OPT_92_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_93_ENUM_NAME
+  #if (OPT_93_HAS_ARG_CHR == 'y')
+    #define OPT_93_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_93_HAS_ARG_CHR == 'n')
+    #define OPT_93_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_94_ENUM_NAME
+  #if (OPT_94_HAS_ARG_CHR == 'y')
+    #define OPT_94_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_94_HAS_ARG_CHR == 'n')
+    #define OPT_94_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_95_ENUM_NAME
+  #if (OPT_95_HAS_ARG_CHR == 'y')
+    #define OPT_95_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_95_HAS_ARG_CHR == 'n')
+    #define OPT_95_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_96_ENUM_NAME
+  #if (OPT_96_HAS_ARG_CHR == 'y')
+    #define OPT_96_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_96_HAS_ARG_CHR == 'n')
+    #define OPT_96_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_97_ENUM_NAME
+  #if (OPT_97_HAS_ARG_CHR == 'y')
+    #define OPT_97_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_97_HAS_ARG_CHR == 'n')
+    #define OPT_97_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_98_ENUM_NAME
+  #if (OPT_98_HAS_ARG_CHR == 'y')
+    #define OPT_98_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_98_HAS_ARG_CHR == 'n')
+    #define OPT_98_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_99_ENUM_NAME
+  #if (OPT_99_HAS_ARG_CHR == 'y')
+    #define OPT_99_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_99_HAS_ARG_CHR == 'n')
+    #define OPT_99_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+
+#ifdef OPT_100_ENUM_NAME
+  #if (OPT_100_HAS_ARG_CHR == 'y')
+    #define OPT_100_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_100_HAS_ARG_CHR == 'n')
+    #define OPT_100_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_101_ENUM_NAME
+  #if (OPT_101_HAS_ARG_CHR == 'y')
+    #define OPT_101_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_101_HAS_ARG_CHR == 'n')
+    #define OPT_101_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_102_ENUM_NAME
+  #if (OPT_102_HAS_ARG_CHR == 'y')
+    #define OPT_102_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_102_HAS_ARG_CHR == 'n')
+    #define OPT_102_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_103_ENUM_NAME
+  #if (OPT_103_HAS_ARG_CHR == 'y')
+    #define OPT_103_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_103_HAS_ARG_CHR == 'n')
+    #define OPT_103_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_104_ENUM_NAME
+  #if (OPT_104_HAS_ARG_CHR == 'y')
+    #define OPT_104_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_104_HAS_ARG_CHR == 'n')
+    #define OPT_104_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_105_ENUM_NAME
+  #if (OPT_105_HAS_ARG_CHR == 'y')
+    #define OPT_105_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_105_HAS_ARG_CHR == 'n')
+    #define OPT_105_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_106_ENUM_NAME
+  #if (OPT_106_HAS_ARG_CHR == 'y')
+    #define OPT_106_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_106_HAS_ARG_CHR == 'n')
+    #define OPT_106_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_107_ENUM_NAME
+  #if (OPT_107_HAS_ARG_CHR == 'y')
+    #define OPT_107_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_107_HAS_ARG_CHR == 'n')
+    #define OPT_107_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_108_ENUM_NAME
+  #if (OPT_108_HAS_ARG_CHR == 'y')
+    #define OPT_108_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_108_HAS_ARG_CHR == 'n')
+    #define OPT_108_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_109_ENUM_NAME
+  #if (OPT_109_HAS_ARG_CHR == 'y')
+    #define OPT_109_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_109_HAS_ARG_CHR == 'n')
+    #define OPT_109_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+
+#ifdef OPT_110_ENUM_NAME
+  #if (OPT_110_HAS_ARG_CHR == 'y')
+    #define OPT_110_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_110_HAS_ARG_CHR == 'n')
+    #define OPT_110_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_111_ENUM_NAME
+  #if (OPT_111_HAS_ARG_CHR == 'y')
+    #define OPT_111_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_111_HAS_ARG_CHR == 'n')
+    #define OPT_111_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_112_ENUM_NAME
+  #if (OPT_112_HAS_ARG_CHR == 'y')
+    #define OPT_112_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_112_HAS_ARG_CHR == 'n')
+    #define OPT_112_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_113_ENUM_NAME
+  #if (OPT_113_HAS_ARG_CHR == 'y')
+    #define OPT_113_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_113_HAS_ARG_CHR == 'n')
+    #define OPT_113_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_114_ENUM_NAME
+  #if (OPT_114_HAS_ARG_CHR == 'y')
+    #define OPT_114_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_114_HAS_ARG_CHR == 'n')
+    #define OPT_114_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_115_ENUM_NAME
+  #if (OPT_115_HAS_ARG_CHR == 'y')
+    #define OPT_115_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_115_HAS_ARG_CHR == 'n')
+    #define OPT_115_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_116_ENUM_NAME
+  #if (OPT_116_HAS_ARG_CHR == 'y')
+    #define OPT_116_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_116_HAS_ARG_CHR == 'n')
+    #define OPT_116_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_117_ENUM_NAME
+  #if (OPT_117_HAS_ARG_CHR == 'y')
+    #define OPT_117_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_117_HAS_ARG_CHR == 'n')
+    #define OPT_117_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_118_ENUM_NAME
+  #if (OPT_118_HAS_ARG_CHR == 'y')
+    #define OPT_118_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_118_HAS_ARG_CHR == 'n')
+    #define OPT_118_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_119_ENUM_NAME
+  #if (OPT_119_HAS_ARG_CHR == 'y')
+    #define OPT_119_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_119_HAS_ARG_CHR == 'n')
+    #define OPT_119_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+
+#ifdef OPT_120_ENUM_NAME
+  #if (OPT_120_HAS_ARG_CHR == 'y')
+    #define OPT_120_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_120_HAS_ARG_CHR == 'n')
+    #define OPT_120_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_121_ENUM_NAME
+  #if (OPT_121_HAS_ARG_CHR == 'y')
+    #define OPT_121_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_121_HAS_ARG_CHR == 'n')
+    #define OPT_121_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_122_ENUM_NAME
+  #if (OPT_122_HAS_ARG_CHR == 'y')
+    #define OPT_122_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_122_HAS_ARG_CHR == 'n')
+    #define OPT_122_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_123_ENUM_NAME
+  #if (OPT_123_HAS_ARG_CHR == 'y')
+    #define OPT_123_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_123_HAS_ARG_CHR == 'n')
+    #define OPT_123_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_124_ENUM_NAME
+  #if (OPT_124_HAS_ARG_CHR == 'y')
+    #define OPT_124_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_124_HAS_ARG_CHR == 'n')
+    #define OPT_124_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_125_ENUM_NAME
+  #if (OPT_125_HAS_ARG_CHR == 'y')
+    #define OPT_125_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_125_HAS_ARG_CHR == 'n')
+    #define OPT_125_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_126_ENUM_NAME
+  #if (OPT_126_HAS_ARG_CHR == 'y')
+    #define OPT_126_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_126_HAS_ARG_CHR == 'n')
+    #define OPT_126_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_127_ENUM_NAME
+  #if (OPT_127_HAS_ARG_CHR == 'y')
+    #define OPT_127_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_127_HAS_ARG_CHR == 'n')
+    #define OPT_127_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_128_ENUM_NAME
+  #if (OPT_128_HAS_ARG_CHR == 'y')
+    #define OPT_128_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_128_HAS_ARG_CHR == 'n')
+    #define OPT_128_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_129_ENUM_NAME
+  #if (OPT_129_HAS_ARG_CHR == 'y')
+    #define OPT_129_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_129_HAS_ARG_CHR == 'n')
+    #define OPT_129_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+
+#ifdef OPT_130_ENUM_NAME
+  #if (OPT_130_HAS_ARG_CHR == 'y')
+    #define OPT_130_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_130_HAS_ARG_CHR == 'n')
+    #define OPT_130_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_131_ENUM_NAME
+  #if (OPT_131_HAS_ARG_CHR == 'y')
+    #define OPT_131_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_131_HAS_ARG_CHR == 'n')
+    #define OPT_131_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_132_ENUM_NAME
+  #if (OPT_132_HAS_ARG_CHR == 'y')
+    #define OPT_132_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_132_HAS_ARG_CHR == 'n')
+    #define OPT_132_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_133_ENUM_NAME
+  #if (OPT_133_HAS_ARG_CHR == 'y')
+    #define OPT_133_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_133_HAS_ARG_CHR == 'n')
+    #define OPT_133_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_134_ENUM_NAME
+  #if (OPT_134_HAS_ARG_CHR == 'y')
+    #define OPT_134_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_134_HAS_ARG_CHR == 'n')
+    #define OPT_134_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_135_ENUM_NAME
+  #if (OPT_135_HAS_ARG_CHR == 'y')
+    #define OPT_135_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_135_HAS_ARG_CHR == 'n')
+    #define OPT_135_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_136_ENUM_NAME
+  #if (OPT_136_HAS_ARG_CHR == 'y')
+    #define OPT_136_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_136_HAS_ARG_CHR == 'n')
+    #define OPT_136_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_137_ENUM_NAME
+  #if (OPT_137_HAS_ARG_CHR == 'y')
+    #define OPT_137_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_137_HAS_ARG_CHR == 'n')
+    #define OPT_137_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_138_ENUM_NAME
+  #if (OPT_138_HAS_ARG_CHR == 'y')
+    #define OPT_138_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_138_HAS_ARG_CHR == 'n')
+    #define OPT_138_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_139_ENUM_NAME
+  #if (OPT_139_HAS_ARG_CHR == 'y')
+    #define OPT_139_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_139_HAS_ARG_CHR == 'n')
+    #define OPT_139_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+
+#ifdef OPT_140_ENUM_NAME
+  #if (OPT_140_HAS_ARG_CHR == 'y')
+    #define OPT_140_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_140_HAS_ARG_CHR == 'n')
+    #define OPT_140_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_141_ENUM_NAME
+  #if (OPT_141_HAS_ARG_CHR == 'y')
+    #define OPT_141_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_141_HAS_ARG_CHR == 'n')
+    #define OPT_141_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_142_ENUM_NAME
+  #if (OPT_142_HAS_ARG_CHR == 'y')
+    #define OPT_142_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_142_HAS_ARG_CHR == 'n')
+    #define OPT_142_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_143_ENUM_NAME
+  #if (OPT_143_HAS_ARG_CHR == 'y')
+    #define OPT_143_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_143_HAS_ARG_CHR == 'n')
+    #define OPT_143_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_144_ENUM_NAME
+  #if (OPT_144_HAS_ARG_CHR == 'y')
+    #define OPT_144_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_144_HAS_ARG_CHR == 'n')
+    #define OPT_144_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_145_ENUM_NAME
+  #if (OPT_145_HAS_ARG_CHR == 'y')
+    #define OPT_145_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_145_HAS_ARG_CHR == 'n')
+    #define OPT_145_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_146_ENUM_NAME
+  #if (OPT_146_HAS_ARG_CHR == 'y')
+    #define OPT_146_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_146_HAS_ARG_CHR == 'n')
+    #define OPT_146_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_147_ENUM_NAME
+  #if (OPT_147_HAS_ARG_CHR == 'y')
+    #define OPT_147_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_147_HAS_ARG_CHR == 'n')
+    #define OPT_147_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_148_ENUM_NAME
+  #if (OPT_148_HAS_ARG_CHR == 'y')
+    #define OPT_148_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_148_HAS_ARG_CHR == 'n')
+    #define OPT_148_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_149_ENUM_NAME
+  #if (OPT_149_HAS_ARG_CHR == 'y')
+    #define OPT_149_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_149_HAS_ARG_CHR == 'n')
+    #define OPT_149_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+
+#ifdef OPT_150_ENUM_NAME
+  #if (OPT_150_HAS_ARG_CHR == 'y')
+    #define OPT_150_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_150_HAS_ARG_CHR == 'n')
+    #define OPT_150_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_151_ENUM_NAME
+  #if (OPT_151_HAS_ARG_CHR == 'y')
+    #define OPT_151_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_151_HAS_ARG_CHR == 'n')
+    #define OPT_151_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_152_ENUM_NAME
+  #if (OPT_152_HAS_ARG_CHR == 'y')
+    #define OPT_152_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_152_HAS_ARG_CHR == 'n')
+    #define OPT_152_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_153_ENUM_NAME
+  #if (OPT_153_HAS_ARG_CHR == 'y')
+    #define OPT_153_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_153_HAS_ARG_CHR == 'n')
+    #define OPT_153_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_154_ENUM_NAME
+  #if (OPT_154_HAS_ARG_CHR == 'y')
+    #define OPT_154_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_154_HAS_ARG_CHR == 'n')
+    #define OPT_154_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_155_ENUM_NAME
+  #if (OPT_155_HAS_ARG_CHR == 'y')
+    #define OPT_155_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_155_HAS_ARG_CHR == 'n')
+    #define OPT_155_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_156_ENUM_NAME
+  #if (OPT_156_HAS_ARG_CHR == 'y')
+    #define OPT_156_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_156_HAS_ARG_CHR == 'n')
+    #define OPT_156_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_157_ENUM_NAME
+  #if (OPT_157_HAS_ARG_CHR == 'y')
+    #define OPT_157_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_157_HAS_ARG_CHR == 'n')
+    #define OPT_157_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_158_ENUM_NAME
+  #if (OPT_158_HAS_ARG_CHR == 'y')
+    #define OPT_158_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_158_HAS_ARG_CHR == 'n')
+    #define OPT_158_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_159_ENUM_NAME
+  #if (OPT_159_HAS_ARG_CHR == 'y')
+    #define OPT_159_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_159_HAS_ARG_CHR == 'n')
+    #define OPT_159_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+
+#ifdef OPT_160_ENUM_NAME
+  #if (OPT_160_HAS_ARG_CHR == 'y')
+    #define OPT_160_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_160_HAS_ARG_CHR == 'n')
+    #define OPT_160_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_161_ENUM_NAME
+  #if (OPT_161_HAS_ARG_CHR == 'y')
+    #define OPT_161_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_161_HAS_ARG_CHR == 'n')
+    #define OPT_161_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_162_ENUM_NAME
+  #if (OPT_162_HAS_ARG_CHR == 'y')
+    #define OPT_162_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_162_HAS_ARG_CHR == 'n')
+    #define OPT_162_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_163_ENUM_NAME
+  #if (OPT_163_HAS_ARG_CHR == 'y')
+    #define OPT_163_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_163_HAS_ARG_CHR == 'n')
+    #define OPT_163_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_164_ENUM_NAME
+  #if (OPT_164_HAS_ARG_CHR == 'y')
+    #define OPT_164_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_164_HAS_ARG_CHR == 'n')
+    #define OPT_164_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_165_ENUM_NAME
+  #if (OPT_165_HAS_ARG_CHR == 'y')
+    #define OPT_165_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_165_HAS_ARG_CHR == 'n')
+    #define OPT_165_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_166_ENUM_NAME
+  #if (OPT_166_HAS_ARG_CHR == 'y')
+    #define OPT_166_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_166_HAS_ARG_CHR == 'n')
+    #define OPT_166_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_167_ENUM_NAME
+  #if (OPT_167_HAS_ARG_CHR == 'y')
+    #define OPT_167_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_167_HAS_ARG_CHR == 'n')
+    #define OPT_167_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_168_ENUM_NAME
+  #if (OPT_168_HAS_ARG_CHR == 'y')
+    #define OPT_168_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_168_HAS_ARG_CHR == 'n')
+    #define OPT_168_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_169_ENUM_NAME
+  #if (OPT_169_HAS_ARG_CHR == 'y')
+    #define OPT_169_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_169_HAS_ARG_CHR == 'n')
+    #define OPT_169_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+
+#ifdef OPT_170_ENUM_NAME
+  #if (OPT_170_HAS_ARG_CHR == 'y')
+    #define OPT_170_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_170_HAS_ARG_CHR == 'n')
+    #define OPT_170_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_171_ENUM_NAME
+  #if (OPT_171_HAS_ARG_CHR == 'y')
+    #define OPT_171_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_171_HAS_ARG_CHR == 'n')
+    #define OPT_171_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_172_ENUM_NAME
+  #if (OPT_172_HAS_ARG_CHR == 'y')
+    #define OPT_172_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_172_HAS_ARG_CHR == 'n')
+    #define OPT_172_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_173_ENUM_NAME
+  #if (OPT_173_HAS_ARG_CHR == 'y')
+    #define OPT_173_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_173_HAS_ARG_CHR == 'n')
+    #define OPT_173_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_174_ENUM_NAME
+  #if (OPT_174_HAS_ARG_CHR == 'y')
+    #define OPT_174_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_174_HAS_ARG_CHR == 'n')
+    #define OPT_174_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_175_ENUM_NAME
+  #if (OPT_175_HAS_ARG_CHR == 'y')
+    #define OPT_175_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_175_HAS_ARG_CHR == 'n')
+    #define OPT_175_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_176_ENUM_NAME
+  #if (OPT_176_HAS_ARG_CHR == 'y')
+    #define OPT_176_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_176_HAS_ARG_CHR == 'n')
+    #define OPT_176_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_177_ENUM_NAME
+  #if (OPT_177_HAS_ARG_CHR == 'y')
+    #define OPT_177_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_177_HAS_ARG_CHR == 'n')
+    #define OPT_177_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_178_ENUM_NAME
+  #if (OPT_178_HAS_ARG_CHR == 'y')
+    #define OPT_178_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_178_HAS_ARG_CHR == 'n')
+    #define OPT_178_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_179_ENUM_NAME
+  #if (OPT_179_HAS_ARG_CHR == 'y')
+    #define OPT_179_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_179_HAS_ARG_CHR == 'n')
+    #define OPT_179_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+
+#ifdef OPT_180_ENUM_NAME
+  #if (OPT_180_HAS_ARG_CHR == 'y')
+    #define OPT_180_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_180_HAS_ARG_CHR == 'n')
+    #define OPT_180_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_181_ENUM_NAME
+  #if (OPT_181_HAS_ARG_CHR == 'y')
+    #define OPT_181_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_181_HAS_ARG_CHR == 'n')
+    #define OPT_181_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_182_ENUM_NAME
+  #if (OPT_182_HAS_ARG_CHR == 'y')
+    #define OPT_182_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_182_HAS_ARG_CHR == 'n')
+    #define OPT_182_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_183_ENUM_NAME
+  #if (OPT_183_HAS_ARG_CHR == 'y')
+    #define OPT_183_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_183_HAS_ARG_CHR == 'n')
+    #define OPT_183_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_184_ENUM_NAME
+  #if (OPT_184_HAS_ARG_CHR == 'y')
+    #define OPT_184_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_184_HAS_ARG_CHR == 'n')
+    #define OPT_184_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_185_ENUM_NAME
+  #if (OPT_185_HAS_ARG_CHR == 'y')
+    #define OPT_185_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_185_HAS_ARG_CHR == 'n')
+    #define OPT_185_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_186_ENUM_NAME
+  #if (OPT_186_HAS_ARG_CHR == 'y')
+    #define OPT_186_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_186_HAS_ARG_CHR == 'n')
+    #define OPT_186_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_187_ENUM_NAME
+  #if (OPT_187_HAS_ARG_CHR == 'y')
+    #define OPT_187_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_187_HAS_ARG_CHR == 'n')
+    #define OPT_187_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_188_ENUM_NAME
+  #if (OPT_188_HAS_ARG_CHR == 'y')
+    #define OPT_188_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_188_HAS_ARG_CHR == 'n')
+    #define OPT_188_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_189_ENUM_NAME
+  #if (OPT_189_HAS_ARG_CHR == 'y')
+    #define OPT_189_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_189_HAS_ARG_CHR == 'n')
+    #define OPT_189_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+
+#ifdef OPT_190_ENUM_NAME
+  #if (OPT_190_HAS_ARG_CHR == 'y')
+    #define OPT_190_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_190_HAS_ARG_CHR == 'n')
+    #define OPT_190_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_191_ENUM_NAME
+  #if (OPT_191_HAS_ARG_CHR == 'y')
+    #define OPT_191_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_191_HAS_ARG_CHR == 'n')
+    #define OPT_191_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_192_ENUM_NAME
+  #if (OPT_192_HAS_ARG_CHR == 'y')
+    #define OPT_192_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_192_HAS_ARG_CHR == 'n')
+    #define OPT_192_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_193_ENUM_NAME
+  #if (OPT_193_HAS_ARG_CHR == 'y')
+    #define OPT_193_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_193_HAS_ARG_CHR == 'n')
+    #define OPT_193_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_194_ENUM_NAME
+  #if (OPT_194_HAS_ARG_CHR == 'y')
+    #define OPT_194_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_194_HAS_ARG_CHR == 'n')
+    #define OPT_194_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_195_ENUM_NAME
+  #if (OPT_195_HAS_ARG_CHR == 'y')
+    #define OPT_195_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_195_HAS_ARG_CHR == 'n')
+    #define OPT_195_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_196_ENUM_NAME
+  #if (OPT_196_HAS_ARG_CHR == 'y')
+    #define OPT_196_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_196_HAS_ARG_CHR == 'n')
+    #define OPT_196_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_197_ENUM_NAME
+  #if (OPT_197_HAS_ARG_CHR == 'y')
+    #define OPT_197_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_197_HAS_ARG_CHR == 'n')
+    #define OPT_197_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_198_ENUM_NAME
+  #if (OPT_198_HAS_ARG_CHR == 'y')
+    #define OPT_198_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_198_HAS_ARG_CHR == 'n')
+    #define OPT_198_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+#ifdef OPT_199_ENUM_NAME
+  #if (OPT_199_HAS_ARG_CHR == 'y')
+    #define OPT_199_HAS_ARG_LONG  (required_argument)
+  #endif
+  #if (OPT_199_HAS_ARG_CHR == 'n')
+    #define OPT_199_HAS_ARG_LONG  (no_argument)
+  #endif
+#endif
+
+/* longopts - mapping defined items into longopt array */
+/* NOTE: remember, array is NOT INDEXED by 'cli_opt_t', because 'cli_opt_t' is NOT A CONSECUTIVE LIST */
+static const struct option longopts[] =
+{
+    {"no-option", no_argument, 0, OPT_00_NO_OPTION},
+
+#ifdef OPT_01_ENUM_NAME
+    #ifdef OPT_01_CLI_LONG_TXT_A
+          {OPT_01_CLI_LONG_TXT_A, OPT_01_HAS_ARG_LONG, 0, OPT_01_ENUM_NAME},
+    #endif
+    #ifdef OPT_01_CLI_LONG_TXT_B
+          {OPT_01_CLI_LONG_TXT_B, OPT_01_HAS_ARG_LONG, 0, OPT_01_ENUM_NAME},
+    #endif
+    #ifdef OPT_01_CLI_LONG_TXT_C
+          {OPT_01_CLI_LONG_TXT_C, OPT_01_HAS_ARG_LONG, 0, OPT_01_ENUM_NAME},
+    #endif
+    #ifdef OPT_01_CLI_LONG_TXT_D
+          {OPT_01_CLI_LONG_TXT_D, OPT_01_HAS_ARG_LONG, 0, OPT_01_ENUM_NAME},
+    #endif
+    #ifdef OPT_01_CLI_SHORT_CODE_TXT
+          {OPT_01_CLI_SHORT_CODE_TXT, OPT_01_HAS_ARG_LONG, 0, OPT_01_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_02_ENUM_NAME
+    #ifdef OPT_02_CLI_LONG_TXT_A
+          {OPT_02_CLI_LONG_TXT_A, OPT_02_HAS_ARG_LONG, 0, OPT_02_ENUM_NAME},
+    #endif
+    #ifdef OPT_02_CLI_LONG_TXT_B
+          {OPT_02_CLI_LONG_TXT_B, OPT_02_HAS_ARG_LONG, 0, OPT_02_ENUM_NAME},
+    #endif
+    #ifdef OPT_02_CLI_LONG_TXT_C
+          {OPT_02_CLI_LONG_TXT_C, OPT_02_HAS_ARG_LONG, 0, OPT_02_ENUM_NAME},
+    #endif
+    #ifdef OPT_02_CLI_LONG_TXT_D
+          {OPT_02_CLI_LONG_TXT_D, OPT_02_HAS_ARG_LONG, 0, OPT_02_ENUM_NAME},
+    #endif
+    #ifdef OPT_02_CLI_SHORT_CODE_TXT
+          {OPT_02_CLI_SHORT_CODE_TXT, OPT_02_HAS_ARG_LONG, 0, OPT_02_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_03_ENUM_NAME
+    #ifdef OPT_03_CLI_LONG_TXT_A
+          {OPT_03_CLI_LONG_TXT_A, OPT_03_HAS_ARG_LONG, 0, OPT_03_ENUM_NAME},
+    #endif
+    #ifdef OPT_03_CLI_LONG_TXT_B
+          {OPT_03_CLI_LONG_TXT_B, OPT_03_HAS_ARG_LONG, 0, OPT_03_ENUM_NAME},
+    #endif
+    #ifdef OPT_03_CLI_LONG_TXT_C
+          {OPT_03_CLI_LONG_TXT_C, OPT_03_HAS_ARG_LONG, 0, OPT_03_ENUM_NAME},
+    #endif
+    #ifdef OPT_03_CLI_LONG_TXT_D
+          {OPT_03_CLI_LONG_TXT_D, OPT_03_HAS_ARG_LONG, 0, OPT_03_ENUM_NAME},
+    #endif
+    #ifdef OPT_03_CLI_SHORT_CODE_TXT
+          {OPT_03_CLI_SHORT_CODE_TXT, OPT_03_HAS_ARG_LONG, 0, OPT_03_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_04_ENUM_NAME
+    #ifdef OPT_04_CLI_LONG_TXT_A
+          {OPT_04_CLI_LONG_TXT_A, OPT_04_HAS_ARG_LONG, 0, OPT_04_ENUM_NAME},
+    #endif
+    #ifdef OPT_04_CLI_LONG_TXT_B
+          {OPT_04_CLI_LONG_TXT_B, OPT_04_HAS_ARG_LONG, 0, OPT_04_ENUM_NAME},
+    #endif
+    #ifdef OPT_04_CLI_LONG_TXT_C
+          {OPT_04_CLI_LONG_TXT_C, OPT_04_HAS_ARG_LONG, 0, OPT_04_ENUM_NAME},
+    #endif
+    #ifdef OPT_04_CLI_LONG_TXT_D
+          {OPT_04_CLI_LONG_TXT_D, OPT_04_HAS_ARG_LONG, 0, OPT_04_ENUM_NAME},
+    #endif
+    #ifdef OPT_04_CLI_SHORT_CODE_TXT
+          {OPT_04_CLI_SHORT_CODE_TXT, OPT_04_HAS_ARG_LONG, 0, OPT_04_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_05_ENUM_NAME
+    #ifdef OPT_05_CLI_LONG_TXT_A
+          {OPT_05_CLI_LONG_TXT_A, OPT_05_HAS_ARG_LONG, 0, OPT_05_ENUM_NAME},
+    #endif
+    #ifdef OPT_05_CLI_LONG_TXT_B
+          {OPT_05_CLI_LONG_TXT_B, OPT_05_HAS_ARG_LONG, 0, OPT_05_ENUM_NAME},
+    #endif
+    #ifdef OPT_05_CLI_LONG_TXT_C
+          {OPT_05_CLI_LONG_TXT_C, OPT_05_HAS_ARG_LONG, 0, OPT_05_ENUM_NAME},
+    #endif
+    #ifdef OPT_05_CLI_LONG_TXT_D
+          {OPT_05_CLI_LONG_TXT_D, OPT_05_HAS_ARG_LONG, 0, OPT_05_ENUM_NAME},
+    #endif
+    #ifdef OPT_05_CLI_SHORT_CODE_TXT
+          {OPT_05_CLI_SHORT_CODE_TXT, OPT_05_HAS_ARG_LONG, 0, OPT_05_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_06_ENUM_NAME
+    #ifdef OPT_06_CLI_LONG_TXT_A
+          {OPT_06_CLI_LONG_TXT_A, OPT_06_HAS_ARG_LONG, 0, OPT_06_ENUM_NAME},
+    #endif
+    #ifdef OPT_06_CLI_LONG_TXT_B
+          {OPT_06_CLI_LONG_TXT_B, OPT_06_HAS_ARG_LONG, 0, OPT_06_ENUM_NAME},
+    #endif
+    #ifdef OPT_06_CLI_LONG_TXT_C
+          {OPT_06_CLI_LONG_TXT_C, OPT_06_HAS_ARG_LONG, 0, OPT_06_ENUM_NAME},
+    #endif
+    #ifdef OPT_06_CLI_LONG_TXT_D
+          {OPT_06_CLI_LONG_TXT_D, OPT_06_HAS_ARG_LONG, 0, OPT_06_ENUM_NAME},
+    #endif
+    #ifdef OPT_06_CLI_SHORT_CODE_TXT
+          {OPT_06_CLI_SHORT_CODE_TXT, OPT_06_HAS_ARG_LONG, 0, OPT_06_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_07_ENUM_NAME
+    #ifdef OPT_07_CLI_LONG_TXT_A
+          {OPT_07_CLI_LONG_TXT_A, OPT_07_HAS_ARG_LONG, 0, OPT_07_ENUM_NAME},
+    #endif
+    #ifdef OPT_07_CLI_LONG_TXT_B
+          {OPT_07_CLI_LONG_TXT_B, OPT_07_HAS_ARG_LONG, 0, OPT_07_ENUM_NAME},
+    #endif
+    #ifdef OPT_07_CLI_LONG_TXT_C
+          {OPT_07_CLI_LONG_TXT_C, OPT_07_HAS_ARG_LONG, 0, OPT_07_ENUM_NAME},
+    #endif
+    #ifdef OPT_07_CLI_LONG_TXT_D
+          {OPT_07_CLI_LONG_TXT_D, OPT_07_HAS_ARG_LONG, 0, OPT_07_ENUM_NAME},
+    #endif
+    #ifdef OPT_07_CLI_SHORT_CODE_TXT
+          {OPT_07_CLI_SHORT_CODE_TXT, OPT_07_HAS_ARG_LONG, 0, OPT_07_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_08_ENUM_NAME
+    #ifdef OPT_08_CLI_LONG_TXT_A
+          {OPT_08_CLI_LONG_TXT_A, OPT_08_HAS_ARG_LONG, 0, OPT_08_ENUM_NAME},
+    #endif
+    #ifdef OPT_08_CLI_LONG_TXT_B
+          {OPT_08_CLI_LONG_TXT_B, OPT_08_HAS_ARG_LONG, 0, OPT_08_ENUM_NAME},
+    #endif
+    #ifdef OPT_08_CLI_LONG_TXT_C
+          {OPT_08_CLI_LONG_TXT_C, OPT_08_HAS_ARG_LONG, 0, OPT_08_ENUM_NAME},
+    #endif
+    #ifdef OPT_08_CLI_LONG_TXT_D
+          {OPT_08_CLI_LONG_TXT_D, OPT_08_HAS_ARG_LONG, 0, OPT_08_ENUM_NAME},
+    #endif
+    #ifdef OPT_08_CLI_SHORT_CODE_TXT
+          {OPT_08_CLI_SHORT_CODE_TXT, OPT_08_HAS_ARG_LONG, 0, OPT_08_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_09_ENUM_NAME
+    #ifdef OPT_09_CLI_LONG_TXT_A
+          {OPT_09_CLI_LONG_TXT_A, OPT_09_HAS_ARG_LONG, 0, OPT_09_ENUM_NAME},
+    #endif
+    #ifdef OPT_09_CLI_LONG_TXT_B
+          {OPT_09_CLI_LONG_TXT_B, OPT_09_HAS_ARG_LONG, 0, OPT_09_ENUM_NAME},
+    #endif
+    #ifdef OPT_09_CLI_LONG_TXT_C
+          {OPT_09_CLI_LONG_TXT_C, OPT_09_HAS_ARG_LONG, 0, OPT_09_ENUM_NAME},
+    #endif
+    #ifdef OPT_09_CLI_LONG_TXT_D
+          {OPT_09_CLI_LONG_TXT_D, OPT_09_HAS_ARG_LONG, 0, OPT_09_ENUM_NAME},
+    #endif
+    #ifdef OPT_09_CLI_SHORT_CODE_TXT
+          {OPT_09_CLI_SHORT_CODE_TXT, OPT_09_HAS_ARG_LONG, 0, OPT_09_ENUM_NAME},
+    #endif
+#endif
+
+#ifdef OPT_10_ENUM_NAME
+    #ifdef OPT_10_CLI_LONG_TXT_A
+          {OPT_10_CLI_LONG_TXT_A, OPT_10_HAS_ARG_LONG, 0, OPT_10_ENUM_NAME},
+    #endif
+    #ifdef OPT_10_CLI_LONG_TXT_B
+          {OPT_10_CLI_LONG_TXT_B, OPT_10_HAS_ARG_LONG, 0, OPT_10_ENUM_NAME},
+    #endif
+    #ifdef OPT_10_CLI_LONG_TXT_C
+          {OPT_10_CLI_LONG_TXT_C, OPT_10_HAS_ARG_LONG, 0, OPT_10_ENUM_NAME},
+    #endif
+    #ifdef OPT_10_CLI_LONG_TXT_D
+          {OPT_10_CLI_LONG_TXT_D, OPT_10_HAS_ARG_LONG, 0, OPT_10_ENUM_NAME},
+    #endif
+    #ifdef OPT_10_CLI_SHORT_CODE_TXT
+          {OPT_10_CLI_SHORT_CODE_TXT, OPT_10_HAS_ARG_LONG, 0, OPT_10_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_11_ENUM_NAME
+    #ifdef OPT_11_CLI_LONG_TXT_A
+          {OPT_11_CLI_LONG_TXT_A, OPT_11_HAS_ARG_LONG, 0, OPT_11_ENUM_NAME},
+    #endif
+    #ifdef OPT_11_CLI_LONG_TXT_B
+          {OPT_11_CLI_LONG_TXT_B, OPT_11_HAS_ARG_LONG, 0, OPT_11_ENUM_NAME},
+    #endif
+    #ifdef OPT_11_CLI_LONG_TXT_C
+          {OPT_11_CLI_LONG_TXT_C, OPT_11_HAS_ARG_LONG, 0, OPT_11_ENUM_NAME},
+    #endif
+    #ifdef OPT_11_CLI_LONG_TXT_D
+          {OPT_11_CLI_LONG_TXT_D, OPT_11_HAS_ARG_LONG, 0, OPT_11_ENUM_NAME},
+    #endif
+    #ifdef OPT_11_CLI_SHORT_CODE_TXT
+          {OPT_11_CLI_SHORT_CODE_TXT, OPT_11_HAS_ARG_LONG, 0, OPT_11_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_12_ENUM_NAME
+    #ifdef OPT_12_CLI_LONG_TXT_A
+          {OPT_12_CLI_LONG_TXT_A, OPT_12_HAS_ARG_LONG, 0, OPT_12_ENUM_NAME},
+    #endif
+    #ifdef OPT_12_CLI_LONG_TXT_B
+          {OPT_12_CLI_LONG_TXT_B, OPT_12_HAS_ARG_LONG, 0, OPT_12_ENUM_NAME},
+    #endif
+    #ifdef OPT_12_CLI_LONG_TXT_C
+          {OPT_12_CLI_LONG_TXT_C, OPT_12_HAS_ARG_LONG, 0, OPT_12_ENUM_NAME},
+    #endif
+    #ifdef OPT_12_CLI_LONG_TXT_D
+          {OPT_12_CLI_LONG_TXT_D, OPT_12_HAS_ARG_LONG, 0, OPT_12_ENUM_NAME},
+    #endif
+    #ifdef OPT_12_CLI_SHORT_CODE_TXT
+          {OPT_12_CLI_SHORT_CODE_TXT, OPT_12_HAS_ARG_LONG, 0, OPT_12_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_13_ENUM_NAME
+    #ifdef OPT_13_CLI_LONG_TXT_A
+          {OPT_13_CLI_LONG_TXT_A, OPT_13_HAS_ARG_LONG, 0, OPT_13_ENUM_NAME},
+    #endif
+    #ifdef OPT_13_CLI_LONG_TXT_B
+          {OPT_13_CLI_LONG_TXT_B, OPT_13_HAS_ARG_LONG, 0, OPT_13_ENUM_NAME},
+    #endif
+    #ifdef OPT_13_CLI_LONG_TXT_C
+          {OPT_13_CLI_LONG_TXT_C, OPT_13_HAS_ARG_LONG, 0, OPT_13_ENUM_NAME},
+    #endif
+    #ifdef OPT_13_CLI_LONG_TXT_D
+          {OPT_13_CLI_LONG_TXT_D, OPT_13_HAS_ARG_LONG, 0, OPT_13_ENUM_NAME},
+    #endif
+    #ifdef OPT_13_CLI_SHORT_CODE_TXT
+          {OPT_13_CLI_SHORT_CODE_TXT, OPT_13_HAS_ARG_LONG, 0, OPT_13_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_14_ENUM_NAME
+    #ifdef OPT_14_CLI_LONG_TXT_A
+          {OPT_14_CLI_LONG_TXT_A, OPT_14_HAS_ARG_LONG, 0, OPT_14_ENUM_NAME},
+    #endif
+    #ifdef OPT_14_CLI_LONG_TXT_B
+          {OPT_14_CLI_LONG_TXT_B, OPT_14_HAS_ARG_LONG, 0, OPT_14_ENUM_NAME},
+    #endif
+    #ifdef OPT_14_CLI_LONG_TXT_C
+          {OPT_14_CLI_LONG_TXT_C, OPT_14_HAS_ARG_LONG, 0, OPT_14_ENUM_NAME},
+    #endif
+    #ifdef OPT_14_CLI_LONG_TXT_D
+          {OPT_14_CLI_LONG_TXT_D, OPT_14_HAS_ARG_LONG, 0, OPT_14_ENUM_NAME},
+    #endif
+    #ifdef OPT_14_CLI_SHORT_CODE_TXT
+          {OPT_14_CLI_SHORT_CODE_TXT, OPT_14_HAS_ARG_LONG, 0, OPT_14_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_15_ENUM_NAME
+    #ifdef OPT_15_CLI_LONG_TXT_A
+          {OPT_15_CLI_LONG_TXT_A, OPT_15_HAS_ARG_LONG, 0, OPT_15_ENUM_NAME},
+    #endif
+    #ifdef OPT_15_CLI_LONG_TXT_B
+          {OPT_15_CLI_LONG_TXT_B, OPT_15_HAS_ARG_LONG, 0, OPT_15_ENUM_NAME},
+    #endif
+    #ifdef OPT_15_CLI_LONG_TXT_C
+          {OPT_15_CLI_LONG_TXT_C, OPT_15_HAS_ARG_LONG, 0, OPT_15_ENUM_NAME},
+    #endif
+    #ifdef OPT_15_CLI_LONG_TXT_D
+          {OPT_15_CLI_LONG_TXT_D, OPT_15_HAS_ARG_LONG, 0, OPT_15_ENUM_NAME},
+    #endif
+    #ifdef OPT_15_CLI_SHORT_CODE_TXT
+          {OPT_15_CLI_SHORT_CODE_TXT, OPT_15_HAS_ARG_LONG, 0, OPT_15_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_16_ENUM_NAME
+    #ifdef OPT_16_CLI_LONG_TXT_A
+          {OPT_16_CLI_LONG_TXT_A, OPT_16_HAS_ARG_LONG, 0, OPT_16_ENUM_NAME},
+    #endif
+    #ifdef OPT_16_CLI_LONG_TXT_B
+          {OPT_16_CLI_LONG_TXT_B, OPT_16_HAS_ARG_LONG, 0, OPT_16_ENUM_NAME},
+    #endif
+    #ifdef OPT_16_CLI_LONG_TXT_C
+          {OPT_16_CLI_LONG_TXT_C, OPT_16_HAS_ARG_LONG, 0, OPT_16_ENUM_NAME},
+    #endif
+    #ifdef OPT_16_CLI_LONG_TXT_D
+          {OPT_16_CLI_LONG_TXT_D, OPT_16_HAS_ARG_LONG, 0, OPT_16_ENUM_NAME},
+    #endif
+    #ifdef OPT_16_CLI_SHORT_CODE_TXT
+          {OPT_16_CLI_SHORT_CODE_TXT, OPT_16_HAS_ARG_LONG, 0, OPT_16_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_17_ENUM_NAME
+    #ifdef OPT_17_CLI_LONG_TXT_A
+          {OPT_17_CLI_LONG_TXT_A, OPT_17_HAS_ARG_LONG, 0, OPT_17_ENUM_NAME},
+    #endif
+    #ifdef OPT_17_CLI_LONG_TXT_B
+          {OPT_17_CLI_LONG_TXT_B, OPT_17_HAS_ARG_LONG, 0, OPT_17_ENUM_NAME},
+    #endif
+    #ifdef OPT_17_CLI_LONG_TXT_C
+          {OPT_17_CLI_LONG_TXT_C, OPT_17_HAS_ARG_LONG, 0, OPT_17_ENUM_NAME},
+    #endif
+    #ifdef OPT_17_CLI_LONG_TXT_D
+          {OPT_17_CLI_LONG_TXT_D, OPT_17_HAS_ARG_LONG, 0, OPT_17_ENUM_NAME},
+    #endif
+    #ifdef OPT_17_CLI_SHORT_CODE_TXT
+          {OPT_17_CLI_SHORT_CODE_TXT, OPT_17_HAS_ARG_LONG, 0, OPT_17_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_18_ENUM_NAME
+    #ifdef OPT_18_CLI_LONG_TXT_A
+          {OPT_18_CLI_LONG_TXT_A, OPT_18_HAS_ARG_LONG, 0, OPT_18_ENUM_NAME},
+    #endif
+    #ifdef OPT_18_CLI_LONG_TXT_B
+          {OPT_18_CLI_LONG_TXT_B, OPT_18_HAS_ARG_LONG, 0, OPT_18_ENUM_NAME},
+    #endif
+    #ifdef OPT_18_CLI_LONG_TXT_C
+          {OPT_18_CLI_LONG_TXT_C, OPT_18_HAS_ARG_LONG, 0, OPT_18_ENUM_NAME},
+    #endif
+    #ifdef OPT_18_CLI_LONG_TXT_D
+          {OPT_18_CLI_LONG_TXT_D, OPT_18_HAS_ARG_LONG, 0, OPT_18_ENUM_NAME},
+    #endif
+    #ifdef OPT_18_CLI_SHORT_CODE_TXT
+          {OPT_18_CLI_SHORT_CODE_TXT, OPT_18_HAS_ARG_LONG, 0, OPT_18_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_19_ENUM_NAME
+    #ifdef OPT_19_CLI_LONG_TXT_A
+          {OPT_19_CLI_LONG_TXT_A, OPT_19_HAS_ARG_LONG, 0, OPT_19_ENUM_NAME},
+    #endif
+    #ifdef OPT_19_CLI_LONG_TXT_B
+          {OPT_19_CLI_LONG_TXT_B, OPT_19_HAS_ARG_LONG, 0, OPT_19_ENUM_NAME},
+    #endif
+    #ifdef OPT_19_CLI_LONG_TXT_C
+          {OPT_19_CLI_LONG_TXT_C, OPT_19_HAS_ARG_LONG, 0, OPT_19_ENUM_NAME},
+    #endif
+    #ifdef OPT_19_CLI_LONG_TXT_D
+          {OPT_19_CLI_LONG_TXT_D, OPT_19_HAS_ARG_LONG, 0, OPT_19_ENUM_NAME},
+    #endif
+    #ifdef OPT_19_CLI_SHORT_CODE_TXT
+          {OPT_19_CLI_SHORT_CODE_TXT, OPT_19_HAS_ARG_LONG, 0, OPT_19_ENUM_NAME},
+    #endif
+#endif
+
+#ifdef OPT_20_ENUM_NAME
+    #ifdef OPT_20_CLI_LONG_TXT_A
+          {OPT_20_CLI_LONG_TXT_A, OPT_20_HAS_ARG_LONG, 0, OPT_20_ENUM_NAME},
+    #endif
+    #ifdef OPT_20_CLI_LONG_TXT_B
+          {OPT_20_CLI_LONG_TXT_B, OPT_20_HAS_ARG_LONG, 0, OPT_20_ENUM_NAME},
+    #endif
+    #ifdef OPT_20_CLI_LONG_TXT_C
+          {OPT_20_CLI_LONG_TXT_C, OPT_20_HAS_ARG_LONG, 0, OPT_20_ENUM_NAME},
+    #endif
+    #ifdef OPT_20_CLI_LONG_TXT_D
+          {OPT_20_CLI_LONG_TXT_D, OPT_20_HAS_ARG_LONG, 0, OPT_20_ENUM_NAME},
+    #endif
+    #ifdef OPT_20_CLI_SHORT_CODE_TXT
+          {OPT_20_CLI_SHORT_CODE_TXT, OPT_20_HAS_ARG_LONG, 0, OPT_20_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_21_ENUM_NAME
+    #ifdef OPT_21_CLI_LONG_TXT_A
+          {OPT_21_CLI_LONG_TXT_A, OPT_21_HAS_ARG_LONG, 0, OPT_21_ENUM_NAME},
+    #endif
+    #ifdef OPT_21_CLI_LONG_TXT_B
+          {OPT_21_CLI_LONG_TXT_B, OPT_21_HAS_ARG_LONG, 0, OPT_21_ENUM_NAME},
+    #endif
+    #ifdef OPT_21_CLI_LONG_TXT_C
+          {OPT_21_CLI_LONG_TXT_C, OPT_21_HAS_ARG_LONG, 0, OPT_21_ENUM_NAME},
+    #endif
+    #ifdef OPT_21_CLI_LONG_TXT_D
+          {OPT_21_CLI_LONG_TXT_D, OPT_21_HAS_ARG_LONG, 0, OPT_21_ENUM_NAME},
+    #endif
+    #ifdef OPT_21_CLI_SHORT_CODE_TXT
+          {OPT_21_CLI_SHORT_CODE_TXT, OPT_21_HAS_ARG_LONG, 0, OPT_21_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_22_ENUM_NAME
+    #ifdef OPT_22_CLI_LONG_TXT_A
+          {OPT_22_CLI_LONG_TXT_A, OPT_22_HAS_ARG_LONG, 0, OPT_22_ENUM_NAME},
+    #endif
+    #ifdef OPT_22_CLI_LONG_TXT_B
+          {OPT_22_CLI_LONG_TXT_B, OPT_22_HAS_ARG_LONG, 0, OPT_22_ENUM_NAME},
+    #endif
+    #ifdef OPT_22_CLI_LONG_TXT_C
+          {OPT_22_CLI_LONG_TXT_C, OPT_22_HAS_ARG_LONG, 0, OPT_22_ENUM_NAME},
+    #endif
+    #ifdef OPT_22_CLI_LONG_TXT_D
+          {OPT_22_CLI_LONG_TXT_D, OPT_22_HAS_ARG_LONG, 0, OPT_22_ENUM_NAME},
+    #endif
+    #ifdef OPT_22_CLI_SHORT_CODE_TXT
+          {OPT_22_CLI_SHORT_CODE_TXT, OPT_22_HAS_ARG_LONG, 0, OPT_22_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_23_ENUM_NAME
+    #ifdef OPT_23_CLI_LONG_TXT_A
+          {OPT_23_CLI_LONG_TXT_A, OPT_23_HAS_ARG_LONG, 0, OPT_23_ENUM_NAME},
+    #endif
+    #ifdef OPT_23_CLI_LONG_TXT_B
+          {OPT_23_CLI_LONG_TXT_B, OPT_23_HAS_ARG_LONG, 0, OPT_23_ENUM_NAME},
+    #endif
+    #ifdef OPT_23_CLI_LONG_TXT_C
+          {OPT_23_CLI_LONG_TXT_C, OPT_23_HAS_ARG_LONG, 0, OPT_23_ENUM_NAME},
+    #endif
+    #ifdef OPT_23_CLI_LONG_TXT_D
+          {OPT_23_CLI_LONG_TXT_D, OPT_23_HAS_ARG_LONG, 0, OPT_23_ENUM_NAME},
+    #endif
+    #ifdef OPT_23_CLI_SHORT_CODE_TXT
+          {OPT_23_CLI_SHORT_CODE_TXT, OPT_23_HAS_ARG_LONG, 0, OPT_23_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_24_ENUM_NAME
+    #ifdef OPT_24_CLI_LONG_TXT_A
+          {OPT_24_CLI_LONG_TXT_A, OPT_24_HAS_ARG_LONG, 0, OPT_24_ENUM_NAME},
+    #endif
+    #ifdef OPT_24_CLI_LONG_TXT_B
+          {OPT_24_CLI_LONG_TXT_B, OPT_24_HAS_ARG_LONG, 0, OPT_24_ENUM_NAME},
+    #endif
+    #ifdef OPT_24_CLI_LONG_TXT_C
+          {OPT_24_CLI_LONG_TXT_C, OPT_24_HAS_ARG_LONG, 0, OPT_24_ENUM_NAME},
+    #endif
+    #ifdef OPT_24_CLI_LONG_TXT_D
+          {OPT_24_CLI_LONG_TXT_D, OPT_24_HAS_ARG_LONG, 0, OPT_24_ENUM_NAME},
+    #endif
+    #ifdef OPT_24_CLI_SHORT_CODE_TXT
+          {OPT_24_CLI_SHORT_CODE_TXT, OPT_24_HAS_ARG_LONG, 0, OPT_24_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_25_ENUM_NAME
+    #ifdef OPT_25_CLI_LONG_TXT_A
+          {OPT_25_CLI_LONG_TXT_A, OPT_25_HAS_ARG_LONG, 0, OPT_25_ENUM_NAME},
+    #endif
+    #ifdef OPT_25_CLI_LONG_TXT_B
+          {OPT_25_CLI_LONG_TXT_B, OPT_25_HAS_ARG_LONG, 0, OPT_25_ENUM_NAME},
+    #endif
+    #ifdef OPT_25_CLI_LONG_TXT_C
+          {OPT_25_CLI_LONG_TXT_C, OPT_25_HAS_ARG_LONG, 0, OPT_25_ENUM_NAME},
+    #endif
+    #ifdef OPT_25_CLI_LONG_TXT_D
+          {OPT_25_CLI_LONG_TXT_D, OPT_25_HAS_ARG_LONG, 0, OPT_25_ENUM_NAME},
+    #endif
+    #ifdef OPT_25_CLI_SHORT_CODE_TXT
+          {OPT_25_CLI_SHORT_CODE_TXT, OPT_25_HAS_ARG_LONG, 0, OPT_25_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_26_ENUM_NAME
+    #ifdef OPT_26_CLI_LONG_TXT_A
+          {OPT_26_CLI_LONG_TXT_A, OPT_26_HAS_ARG_LONG, 0, OPT_26_ENUM_NAME},
+    #endif
+    #ifdef OPT_26_CLI_LONG_TXT_B
+          {OPT_26_CLI_LONG_TXT_B, OPT_26_HAS_ARG_LONG, 0, OPT_26_ENUM_NAME},
+    #endif
+    #ifdef OPT_26_CLI_LONG_TXT_C
+          {OPT_26_CLI_LONG_TXT_C, OPT_26_HAS_ARG_LONG, 0, OPT_26_ENUM_NAME},
+    #endif
+    #ifdef OPT_26_CLI_LONG_TXT_D
+          {OPT_26_CLI_LONG_TXT_D, OPT_26_HAS_ARG_LONG, 0, OPT_26_ENUM_NAME},
+    #endif
+    #ifdef OPT_26_CLI_SHORT_CODE_TXT
+          {OPT_26_CLI_SHORT_CODE_TXT, OPT_26_HAS_ARG_LONG, 0, OPT_26_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_27_ENUM_NAME
+    #ifdef OPT_27_CLI_LONG_TXT_A
+          {OPT_27_CLI_LONG_TXT_A, OPT_27_HAS_ARG_LONG, 0, OPT_27_ENUM_NAME},
+    #endif
+    #ifdef OPT_27_CLI_LONG_TXT_B
+          {OPT_27_CLI_LONG_TXT_B, OPT_27_HAS_ARG_LONG, 0, OPT_27_ENUM_NAME},
+    #endif
+    #ifdef OPT_27_CLI_LONG_TXT_C
+          {OPT_27_CLI_LONG_TXT_C, OPT_27_HAS_ARG_LONG, 0, OPT_27_ENUM_NAME},
+    #endif
+    #ifdef OPT_27_CLI_LONG_TXT_D
+          {OPT_27_CLI_LONG_TXT_D, OPT_27_HAS_ARG_LONG, 0, OPT_27_ENUM_NAME},
+    #endif
+    #ifdef OPT_27_CLI_SHORT_CODE_TXT
+          {OPT_27_CLI_SHORT_CODE_TXT, OPT_27_HAS_ARG_LONG, 0, OPT_27_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_28_ENUM_NAME
+    #ifdef OPT_28_CLI_LONG_TXT_A
+          {OPT_28_CLI_LONG_TXT_A, OPT_28_HAS_ARG_LONG, 0, OPT_28_ENUM_NAME},
+    #endif
+    #ifdef OPT_28_CLI_LONG_TXT_B
+          {OPT_28_CLI_LONG_TXT_B, OPT_28_HAS_ARG_LONG, 0, OPT_28_ENUM_NAME},
+    #endif
+    #ifdef OPT_28_CLI_LONG_TXT_C
+          {OPT_28_CLI_LONG_TXT_C, OPT_28_HAS_ARG_LONG, 0, OPT_28_ENUM_NAME},
+    #endif
+    #ifdef OPT_28_CLI_LONG_TXT_D
+          {OPT_28_CLI_LONG_TXT_D, OPT_28_HAS_ARG_LONG, 0, OPT_28_ENUM_NAME},
+    #endif
+    #ifdef OPT_28_CLI_SHORT_CODE_TXT
+          {OPT_28_CLI_SHORT_CODE_TXT, OPT_28_HAS_ARG_LONG, 0, OPT_28_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_29_ENUM_NAME
+    #ifdef OPT_29_CLI_LONG_TXT_A
+          {OPT_29_CLI_LONG_TXT_A, OPT_29_HAS_ARG_LONG, 0, OPT_29_ENUM_NAME},
+    #endif
+    #ifdef OPT_29_CLI_LONG_TXT_B
+          {OPT_29_CLI_LONG_TXT_B, OPT_29_HAS_ARG_LONG, 0, OPT_29_ENUM_NAME},
+    #endif
+    #ifdef OPT_29_CLI_LONG_TXT_C
+          {OPT_29_CLI_LONG_TXT_C, OPT_29_HAS_ARG_LONG, 0, OPT_29_ENUM_NAME},
+    #endif
+    #ifdef OPT_29_CLI_LONG_TXT_D
+          {OPT_29_CLI_LONG_TXT_D, OPT_29_HAS_ARG_LONG, 0, OPT_29_ENUM_NAME},
+    #endif
+    #ifdef OPT_29_CLI_SHORT_CODE_TXT
+          {OPT_29_CLI_SHORT_CODE_TXT, OPT_29_HAS_ARG_LONG, 0, OPT_29_ENUM_NAME},
+    #endif
+#endif
+
+#ifdef OPT_30_ENUM_NAME
+    #ifdef OPT_30_CLI_LONG_TXT_A
+          {OPT_30_CLI_LONG_TXT_A, OPT_30_HAS_ARG_LONG, 0, OPT_30_ENUM_NAME},
+    #endif
+    #ifdef OPT_30_CLI_LONG_TXT_B
+          {OPT_30_CLI_LONG_TXT_B, OPT_30_HAS_ARG_LONG, 0, OPT_30_ENUM_NAME},
+    #endif
+    #ifdef OPT_30_CLI_LONG_TXT_C
+          {OPT_30_CLI_LONG_TXT_C, OPT_30_HAS_ARG_LONG, 0, OPT_30_ENUM_NAME},
+    #endif
+    #ifdef OPT_30_CLI_LONG_TXT_D
+          {OPT_30_CLI_LONG_TXT_D, OPT_30_HAS_ARG_LONG, 0, OPT_30_ENUM_NAME},
+    #endif
+    #ifdef OPT_30_CLI_SHORT_CODE_TXT
+          {OPT_30_CLI_SHORT_CODE_TXT, OPT_30_HAS_ARG_LONG, 0, OPT_30_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_31_ENUM_NAME
+    #ifdef OPT_31_CLI_LONG_TXT_A
+          {OPT_31_CLI_LONG_TXT_A, OPT_31_HAS_ARG_LONG, 0, OPT_31_ENUM_NAME},
+    #endif
+    #ifdef OPT_31_CLI_LONG_TXT_B
+          {OPT_31_CLI_LONG_TXT_B, OPT_31_HAS_ARG_LONG, 0, OPT_31_ENUM_NAME},
+    #endif
+    #ifdef OPT_31_CLI_LONG_TXT_C
+          {OPT_31_CLI_LONG_TXT_C, OPT_31_HAS_ARG_LONG, 0, OPT_31_ENUM_NAME},
+    #endif
+    #ifdef OPT_31_CLI_LONG_TXT_D
+          {OPT_31_CLI_LONG_TXT_D, OPT_31_HAS_ARG_LONG, 0, OPT_31_ENUM_NAME},
+    #endif
+    #ifdef OPT_31_CLI_SHORT_CODE_TXT
+          {OPT_31_CLI_SHORT_CODE_TXT, OPT_31_HAS_ARG_LONG, 0, OPT_31_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_32_ENUM_NAME
+    #ifdef OPT_32_CLI_LONG_TXT_A
+          {OPT_32_CLI_LONG_TXT_A, OPT_32_HAS_ARG_LONG, 0, OPT_32_ENUM_NAME},
+    #endif
+    #ifdef OPT_32_CLI_LONG_TXT_B
+          {OPT_32_CLI_LONG_TXT_B, OPT_32_HAS_ARG_LONG, 0, OPT_32_ENUM_NAME},
+    #endif
+    #ifdef OPT_32_CLI_LONG_TXT_C
+          {OPT_32_CLI_LONG_TXT_C, OPT_32_HAS_ARG_LONG, 0, OPT_32_ENUM_NAME},
+    #endif
+    #ifdef OPT_32_CLI_LONG_TXT_D
+          {OPT_32_CLI_LONG_TXT_D, OPT_32_HAS_ARG_LONG, 0, OPT_32_ENUM_NAME},
+    #endif
+    #ifdef OPT_32_CLI_SHORT_CODE_TXT
+          {OPT_32_CLI_SHORT_CODE_TXT, OPT_32_HAS_ARG_LONG, 0, OPT_32_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_33_ENUM_NAME
+    #ifdef OPT_33_CLI_LONG_TXT_A
+          {OPT_33_CLI_LONG_TXT_A, OPT_33_HAS_ARG_LONG, 0, OPT_33_ENUM_NAME},
+    #endif
+    #ifdef OPT_33_CLI_LONG_TXT_B
+          {OPT_33_CLI_LONG_TXT_B, OPT_33_HAS_ARG_LONG, 0, OPT_33_ENUM_NAME},
+    #endif
+    #ifdef OPT_33_CLI_LONG_TXT_C
+          {OPT_33_CLI_LONG_TXT_C, OPT_33_HAS_ARG_LONG, 0, OPT_33_ENUM_NAME},
+    #endif
+    #ifdef OPT_33_CLI_LONG_TXT_D
+          {OPT_33_CLI_LONG_TXT_D, OPT_33_HAS_ARG_LONG, 0, OPT_33_ENUM_NAME},
+    #endif
+    #ifdef OPT_33_CLI_SHORT_CODE_TXT
+          {OPT_33_CLI_SHORT_CODE_TXT, OPT_33_HAS_ARG_LONG, 0, OPT_33_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_34_ENUM_NAME
+    #ifdef OPT_34_CLI_LONG_TXT_A
+          {OPT_34_CLI_LONG_TXT_A, OPT_34_HAS_ARG_LONG, 0, OPT_34_ENUM_NAME},
+    #endif
+    #ifdef OPT_34_CLI_LONG_TXT_B
+          {OPT_34_CLI_LONG_TXT_B, OPT_34_HAS_ARG_LONG, 0, OPT_34_ENUM_NAME},
+    #endif
+    #ifdef OPT_34_CLI_LONG_TXT_C
+          {OPT_34_CLI_LONG_TXT_C, OPT_34_HAS_ARG_LONG, 0, OPT_34_ENUM_NAME},
+    #endif
+    #ifdef OPT_34_CLI_LONG_TXT_D
+          {OPT_34_CLI_LONG_TXT_D, OPT_34_HAS_ARG_LONG, 0, OPT_34_ENUM_NAME},
+    #endif
+    #ifdef OPT_34_CLI_SHORT_CODE_TXT
+          {OPT_34_CLI_SHORT_CODE_TXT, OPT_34_HAS_ARG_LONG, 0, OPT_34_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_35_ENUM_NAME
+    #ifdef OPT_35_CLI_LONG_TXT_A
+          {OPT_35_CLI_LONG_TXT_A, OPT_35_HAS_ARG_LONG, 0, OPT_35_ENUM_NAME},
+    #endif
+    #ifdef OPT_35_CLI_LONG_TXT_B
+          {OPT_35_CLI_LONG_TXT_B, OPT_35_HAS_ARG_LONG, 0, OPT_35_ENUM_NAME},
+    #endif
+    #ifdef OPT_35_CLI_LONG_TXT_C
+          {OPT_35_CLI_LONG_TXT_C, OPT_35_HAS_ARG_LONG, 0, OPT_35_ENUM_NAME},
+    #endif
+    #ifdef OPT_35_CLI_LONG_TXT_D
+          {OPT_35_CLI_LONG_TXT_D, OPT_35_HAS_ARG_LONG, 0, OPT_35_ENUM_NAME},
+    #endif
+    #ifdef OPT_35_CLI_SHORT_CODE_TXT
+          {OPT_35_CLI_SHORT_CODE_TXT, OPT_35_HAS_ARG_LONG, 0, OPT_35_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_36_ENUM_NAME
+    #ifdef OPT_36_CLI_LONG_TXT_A
+          {OPT_36_CLI_LONG_TXT_A, OPT_36_HAS_ARG_LONG, 0, OPT_36_ENUM_NAME},
+    #endif
+    #ifdef OPT_36_CLI_LONG_TXT_B
+          {OPT_36_CLI_LONG_TXT_B, OPT_36_HAS_ARG_LONG, 0, OPT_36_ENUM_NAME},
+    #endif
+    #ifdef OPT_36_CLI_LONG_TXT_C
+          {OPT_36_CLI_LONG_TXT_C, OPT_36_HAS_ARG_LONG, 0, OPT_36_ENUM_NAME},
+    #endif
+    #ifdef OPT_36_CLI_LONG_TXT_D
+          {OPT_36_CLI_LONG_TXT_D, OPT_36_HAS_ARG_LONG, 0, OPT_36_ENUM_NAME},
+    #endif
+    #ifdef OPT_36_CLI_SHORT_CODE_TXT
+          {OPT_36_CLI_SHORT_CODE_TXT, OPT_36_HAS_ARG_LONG, 0, OPT_36_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_37_ENUM_NAME
+    #ifdef OPT_37_CLI_LONG_TXT_A
+          {OPT_37_CLI_LONG_TXT_A, OPT_37_HAS_ARG_LONG, 0, OPT_37_ENUM_NAME},
+    #endif
+    #ifdef OPT_37_CLI_LONG_TXT_B
+          {OPT_37_CLI_LONG_TXT_B, OPT_37_HAS_ARG_LONG, 0, OPT_37_ENUM_NAME},
+    #endif
+    #ifdef OPT_37_CLI_LONG_TXT_C
+          {OPT_37_CLI_LONG_TXT_C, OPT_37_HAS_ARG_LONG, 0, OPT_37_ENUM_NAME},
+    #endif
+    #ifdef OPT_37_CLI_LONG_TXT_D
+          {OPT_37_CLI_LONG_TXT_D, OPT_37_HAS_ARG_LONG, 0, OPT_37_ENUM_NAME},
+    #endif
+    #ifdef OPT_37_CLI_SHORT_CODE_TXT
+          {OPT_37_CLI_SHORT_CODE_TXT, OPT_37_HAS_ARG_LONG, 0, OPT_37_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_38_ENUM_NAME
+    #ifdef OPT_38_CLI_LONG_TXT_A
+          {OPT_38_CLI_LONG_TXT_A, OPT_38_HAS_ARG_LONG, 0, OPT_38_ENUM_NAME},
+    #endif
+    #ifdef OPT_38_CLI_LONG_TXT_B
+          {OPT_38_CLI_LONG_TXT_B, OPT_38_HAS_ARG_LONG, 0, OPT_38_ENUM_NAME},
+    #endif
+    #ifdef OPT_38_CLI_LONG_TXT_C
+          {OPT_38_CLI_LONG_TXT_C, OPT_38_HAS_ARG_LONG, 0, OPT_38_ENUM_NAME},
+    #endif
+    #ifdef OPT_38_CLI_LONG_TXT_D
+          {OPT_38_CLI_LONG_TXT_D, OPT_38_HAS_ARG_LONG, 0, OPT_38_ENUM_NAME},
+    #endif
+    #ifdef OPT_38_CLI_SHORT_CODE_TXT
+          {OPT_38_CLI_SHORT_CODE_TXT, OPT_38_HAS_ARG_LONG, 0, OPT_38_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_39_ENUM_NAME
+    #ifdef OPT_39_CLI_LONG_TXT_A
+          {OPT_39_CLI_LONG_TXT_A, OPT_39_HAS_ARG_LONG, 0, OPT_39_ENUM_NAME},
+    #endif
+    #ifdef OPT_39_CLI_LONG_TXT_B
+          {OPT_39_CLI_LONG_TXT_B, OPT_39_HAS_ARG_LONG, 0, OPT_39_ENUM_NAME},
+    #endif
+    #ifdef OPT_39_CLI_LONG_TXT_C
+          {OPT_39_CLI_LONG_TXT_C, OPT_39_HAS_ARG_LONG, 0, OPT_39_ENUM_NAME},
+    #endif
+    #ifdef OPT_39_CLI_LONG_TXT_D
+          {OPT_39_CLI_LONG_TXT_D, OPT_39_HAS_ARG_LONG, 0, OPT_39_ENUM_NAME},
+    #endif
+    #ifdef OPT_39_CLI_SHORT_CODE_TXT
+          {OPT_39_CLI_SHORT_CODE_TXT, OPT_39_HAS_ARG_LONG, 0, OPT_39_ENUM_NAME},
+    #endif
+#endif
+
+#ifdef OPT_40_ENUM_NAME
+    #ifdef OPT_40_CLI_LONG_TXT_A
+          {OPT_40_CLI_LONG_TXT_A, OPT_40_HAS_ARG_LONG, 0, OPT_40_ENUM_NAME},
+    #endif
+    #ifdef OPT_40_CLI_LONG_TXT_B
+          {OPT_40_CLI_LONG_TXT_B, OPT_40_HAS_ARG_LONG, 0, OPT_40_ENUM_NAME},
+    #endif
+    #ifdef OPT_40_CLI_LONG_TXT_C
+          {OPT_40_CLI_LONG_TXT_C, OPT_40_HAS_ARG_LONG, 0, OPT_40_ENUM_NAME},
+    #endif
+    #ifdef OPT_40_CLI_LONG_TXT_D
+          {OPT_40_CLI_LONG_TXT_D, OPT_40_HAS_ARG_LONG, 0, OPT_40_ENUM_NAME},
+    #endif
+    #ifdef OPT_40_CLI_SHORT_CODE_TXT
+          {OPT_40_CLI_SHORT_CODE_TXT, OPT_40_HAS_ARG_LONG, 0, OPT_40_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_41_ENUM_NAME
+    #ifdef OPT_41_CLI_LONG_TXT_A
+          {OPT_41_CLI_LONG_TXT_A, OPT_41_HAS_ARG_LONG, 0, OPT_41_ENUM_NAME},
+    #endif
+    #ifdef OPT_41_CLI_LONG_TXT_B
+          {OPT_41_CLI_LONG_TXT_B, OPT_41_HAS_ARG_LONG, 0, OPT_41_ENUM_NAME},
+    #endif
+    #ifdef OPT_41_CLI_LONG_TXT_C
+          {OPT_41_CLI_LONG_TXT_C, OPT_41_HAS_ARG_LONG, 0, OPT_41_ENUM_NAME},
+    #endif
+    #ifdef OPT_41_CLI_LONG_TXT_D
+          {OPT_41_CLI_LONG_TXT_D, OPT_41_HAS_ARG_LONG, 0, OPT_41_ENUM_NAME},
+    #endif
+    #ifdef OPT_41_CLI_SHORT_CODE_TXT
+          {OPT_41_CLI_SHORT_CODE_TXT, OPT_41_HAS_ARG_LONG, 0, OPT_41_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_42_ENUM_NAME
+    #ifdef OPT_42_CLI_LONG_TXT_A
+          {OPT_42_CLI_LONG_TXT_A, OPT_42_HAS_ARG_LONG, 0, OPT_42_ENUM_NAME},
+    #endif
+    #ifdef OPT_42_CLI_LONG_TXT_B
+          {OPT_42_CLI_LONG_TXT_B, OPT_42_HAS_ARG_LONG, 0, OPT_42_ENUM_NAME},
+    #endif
+    #ifdef OPT_42_CLI_LONG_TXT_C
+          {OPT_42_CLI_LONG_TXT_C, OPT_42_HAS_ARG_LONG, 0, OPT_42_ENUM_NAME},
+    #endif
+    #ifdef OPT_42_CLI_LONG_TXT_D
+          {OPT_42_CLI_LONG_TXT_D, OPT_42_HAS_ARG_LONG, 0, OPT_42_ENUM_NAME},
+    #endif
+    #ifdef OPT_42_CLI_SHORT_CODE_TXT
+          {OPT_42_CLI_SHORT_CODE_TXT, OPT_42_HAS_ARG_LONG, 0, OPT_42_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_43_ENUM_NAME
+    #ifdef OPT_43_CLI_LONG_TXT_A
+          {OPT_43_CLI_LONG_TXT_A, OPT_43_HAS_ARG_LONG, 0, OPT_43_ENUM_NAME},
+    #endif
+    #ifdef OPT_43_CLI_LONG_TXT_B
+          {OPT_43_CLI_LONG_TXT_B, OPT_43_HAS_ARG_LONG, 0, OPT_43_ENUM_NAME},
+    #endif
+    #ifdef OPT_43_CLI_LONG_TXT_C
+          {OPT_43_CLI_LONG_TXT_C, OPT_43_HAS_ARG_LONG, 0, OPT_43_ENUM_NAME},
+    #endif
+    #ifdef OPT_43_CLI_LONG_TXT_D
+          {OPT_43_CLI_LONG_TXT_D, OPT_43_HAS_ARG_LONG, 0, OPT_43_ENUM_NAME},
+    #endif
+    #ifdef OPT_43_CLI_SHORT_CODE_TXT
+          {OPT_43_CLI_SHORT_CODE_TXT, OPT_43_HAS_ARG_LONG, 0, OPT_43_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_44_ENUM_NAME
+    #ifdef OPT_44_CLI_LONG_TXT_A
+          {OPT_44_CLI_LONG_TXT_A, OPT_44_HAS_ARG_LONG, 0, OPT_44_ENUM_NAME},
+    #endif
+    #ifdef OPT_44_CLI_LONG_TXT_B
+          {OPT_44_CLI_LONG_TXT_B, OPT_44_HAS_ARG_LONG, 0, OPT_44_ENUM_NAME},
+    #endif
+    #ifdef OPT_44_CLI_LONG_TXT_C
+          {OPT_44_CLI_LONG_TXT_C, OPT_44_HAS_ARG_LONG, 0, OPT_44_ENUM_NAME},
+    #endif
+    #ifdef OPT_44_CLI_LONG_TXT_D
+          {OPT_44_CLI_LONG_TXT_D, OPT_44_HAS_ARG_LONG, 0, OPT_44_ENUM_NAME},
+    #endif
+    #ifdef OPT_44_CLI_SHORT_CODE_TXT
+          {OPT_44_CLI_SHORT_CODE_TXT, OPT_44_HAS_ARG_LONG, 0, OPT_44_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_45_ENUM_NAME
+    #ifdef OPT_45_CLI_LONG_TXT_A
+          {OPT_45_CLI_LONG_TXT_A, OPT_45_HAS_ARG_LONG, 0, OPT_45_ENUM_NAME},
+    #endif
+    #ifdef OPT_45_CLI_LONG_TXT_B
+          {OPT_45_CLI_LONG_TXT_B, OPT_45_HAS_ARG_LONG, 0, OPT_45_ENUM_NAME},
+    #endif
+    #ifdef OPT_45_CLI_LONG_TXT_C
+          {OPT_45_CLI_LONG_TXT_C, OPT_45_HAS_ARG_LONG, 0, OPT_45_ENUM_NAME},
+    #endif
+    #ifdef OPT_45_CLI_LONG_TXT_D
+          {OPT_45_CLI_LONG_TXT_D, OPT_45_HAS_ARG_LONG, 0, OPT_45_ENUM_NAME},
+    #endif
+    #ifdef OPT_45_CLI_SHORT_CODE_TXT
+          {OPT_45_CLI_SHORT_CODE_TXT, OPT_45_HAS_ARG_LONG, 0, OPT_45_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_46_ENUM_NAME
+    #ifdef OPT_46_CLI_LONG_TXT_A
+          {OPT_46_CLI_LONG_TXT_A, OPT_46_HAS_ARG_LONG, 0, OPT_46_ENUM_NAME},
+    #endif
+    #ifdef OPT_46_CLI_LONG_TXT_B
+          {OPT_46_CLI_LONG_TXT_B, OPT_46_HAS_ARG_LONG, 0, OPT_46_ENUM_NAME},
+    #endif
+    #ifdef OPT_46_CLI_LONG_TXT_C
+          {OPT_46_CLI_LONG_TXT_C, OPT_46_HAS_ARG_LONG, 0, OPT_46_ENUM_NAME},
+    #endif
+    #ifdef OPT_46_CLI_LONG_TXT_D
+          {OPT_46_CLI_LONG_TXT_D, OPT_46_HAS_ARG_LONG, 0, OPT_46_ENUM_NAME},
+    #endif
+    #ifdef OPT_46_CLI_SHORT_CODE_TXT
+          {OPT_46_CLI_SHORT_CODE_TXT, OPT_46_HAS_ARG_LONG, 0, OPT_46_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_47_ENUM_NAME
+    #ifdef OPT_47_CLI_LONG_TXT_A
+          {OPT_47_CLI_LONG_TXT_A, OPT_47_HAS_ARG_LONG, 0, OPT_47_ENUM_NAME},
+    #endif
+    #ifdef OPT_47_CLI_LONG_TXT_B
+          {OPT_47_CLI_LONG_TXT_B, OPT_47_HAS_ARG_LONG, 0, OPT_47_ENUM_NAME},
+    #endif
+    #ifdef OPT_47_CLI_LONG_TXT_C
+          {OPT_47_CLI_LONG_TXT_C, OPT_47_HAS_ARG_LONG, 0, OPT_47_ENUM_NAME},
+    #endif
+    #ifdef OPT_47_CLI_LONG_TXT_D
+          {OPT_47_CLI_LONG_TXT_D, OPT_47_HAS_ARG_LONG, 0, OPT_47_ENUM_NAME},
+    #endif
+    #ifdef OPT_47_CLI_SHORT_CODE_TXT
+          {OPT_47_CLI_SHORT_CODE_TXT, OPT_47_HAS_ARG_LONG, 0, OPT_47_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_48_ENUM_NAME
+    #ifdef OPT_48_CLI_LONG_TXT_A
+          {OPT_48_CLI_LONG_TXT_A, OPT_48_HAS_ARG_LONG, 0, OPT_48_ENUM_NAME},
+    #endif
+    #ifdef OPT_48_CLI_LONG_TXT_B
+          {OPT_48_CLI_LONG_TXT_B, OPT_48_HAS_ARG_LONG, 0, OPT_48_ENUM_NAME},
+    #endif
+    #ifdef OPT_48_CLI_LONG_TXT_C
+          {OPT_48_CLI_LONG_TXT_C, OPT_48_HAS_ARG_LONG, 0, OPT_48_ENUM_NAME},
+    #endif
+    #ifdef OPT_48_CLI_LONG_TXT_D
+          {OPT_48_CLI_LONG_TXT_D, OPT_48_HAS_ARG_LONG, 0, OPT_48_ENUM_NAME},
+    #endif
+    #ifdef OPT_48_CLI_SHORT_CODE_TXT
+          {OPT_48_CLI_SHORT_CODE_TXT, OPT_48_HAS_ARG_LONG, 0, OPT_48_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_49_ENUM_NAME
+    #ifdef OPT_49_CLI_LONG_TXT_A
+          {OPT_49_CLI_LONG_TXT_A, OPT_49_HAS_ARG_LONG, 0, OPT_49_ENUM_NAME},
+    #endif
+    #ifdef OPT_49_CLI_LONG_TXT_B
+          {OPT_49_CLI_LONG_TXT_B, OPT_49_HAS_ARG_LONG, 0, OPT_49_ENUM_NAME},
+    #endif
+    #ifdef OPT_49_CLI_LONG_TXT_C
+          {OPT_49_CLI_LONG_TXT_C, OPT_49_HAS_ARG_LONG, 0, OPT_49_ENUM_NAME},
+    #endif
+    #ifdef OPT_49_CLI_LONG_TXT_D
+          {OPT_49_CLI_LONG_TXT_D, OPT_49_HAS_ARG_LONG, 0, OPT_49_ENUM_NAME},
+    #endif
+    #ifdef OPT_49_CLI_SHORT_CODE_TXT
+          {OPT_49_CLI_SHORT_CODE_TXT, OPT_49_HAS_ARG_LONG, 0, OPT_49_ENUM_NAME},
+    #endif
+#endif
+
+#ifdef OPT_50_ENUM_NAME
+    #ifdef OPT_50_CLI_LONG_TXT_A
+          {OPT_50_CLI_LONG_TXT_A, OPT_50_HAS_ARG_LONG, 0, OPT_50_ENUM_NAME},
+    #endif
+    #ifdef OPT_50_CLI_LONG_TXT_B
+          {OPT_50_CLI_LONG_TXT_B, OPT_50_HAS_ARG_LONG, 0, OPT_50_ENUM_NAME},
+    #endif
+    #ifdef OPT_50_CLI_LONG_TXT_C
+          {OPT_50_CLI_LONG_TXT_C, OPT_50_HAS_ARG_LONG, 0, OPT_50_ENUM_NAME},
+    #endif
+    #ifdef OPT_50_CLI_LONG_TXT_D
+          {OPT_50_CLI_LONG_TXT_D, OPT_50_HAS_ARG_LONG, 0, OPT_50_ENUM_NAME},
+    #endif
+    #ifdef OPT_50_CLI_SHORT_CODE_TXT
+          {OPT_50_CLI_SHORT_CODE_TXT, OPT_50_HAS_ARG_LONG, 0, OPT_50_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_51_ENUM_NAME
+    #ifdef OPT_51_CLI_LONG_TXT_A
+          {OPT_51_CLI_LONG_TXT_A, OPT_51_HAS_ARG_LONG, 0, OPT_51_ENUM_NAME},
+    #endif
+    #ifdef OPT_51_CLI_LONG_TXT_B
+          {OPT_51_CLI_LONG_TXT_B, OPT_51_HAS_ARG_LONG, 0, OPT_51_ENUM_NAME},
+    #endif
+    #ifdef OPT_51_CLI_LONG_TXT_C
+          {OPT_51_CLI_LONG_TXT_C, OPT_51_HAS_ARG_LONG, 0, OPT_51_ENUM_NAME},
+    #endif
+    #ifdef OPT_51_CLI_LONG_TXT_D
+          {OPT_51_CLI_LONG_TXT_D, OPT_51_HAS_ARG_LONG, 0, OPT_51_ENUM_NAME},
+    #endif
+    #ifdef OPT_51_CLI_SHORT_CODE_TXT
+          {OPT_51_CLI_SHORT_CODE_TXT, OPT_51_HAS_ARG_LONG, 0, OPT_51_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_52_ENUM_NAME
+    #ifdef OPT_52_CLI_LONG_TXT_A
+          {OPT_52_CLI_LONG_TXT_A, OPT_52_HAS_ARG_LONG, 0, OPT_52_ENUM_NAME},
+    #endif
+    #ifdef OPT_52_CLI_LONG_TXT_B
+          {OPT_52_CLI_LONG_TXT_B, OPT_52_HAS_ARG_LONG, 0, OPT_52_ENUM_NAME},
+    #endif
+    #ifdef OPT_52_CLI_LONG_TXT_C
+          {OPT_52_CLI_LONG_TXT_C, OPT_52_HAS_ARG_LONG, 0, OPT_52_ENUM_NAME},
+    #endif
+    #ifdef OPT_52_CLI_LONG_TXT_D
+          {OPT_52_CLI_LONG_TXT_D, OPT_52_HAS_ARG_LONG, 0, OPT_52_ENUM_NAME},
+    #endif
+    #ifdef OPT_52_CLI_SHORT_CODE_TXT
+          {OPT_52_CLI_SHORT_CODE_TXT, OPT_52_HAS_ARG_LONG, 0, OPT_52_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_53_ENUM_NAME
+    #ifdef OPT_53_CLI_LONG_TXT_A
+          {OPT_53_CLI_LONG_TXT_A, OPT_53_HAS_ARG_LONG, 0, OPT_53_ENUM_NAME},
+    #endif
+    #ifdef OPT_53_CLI_LONG_TXT_B
+          {OPT_53_CLI_LONG_TXT_B, OPT_53_HAS_ARG_LONG, 0, OPT_53_ENUM_NAME},
+    #endif
+    #ifdef OPT_53_CLI_LONG_TXT_C
+          {OPT_53_CLI_LONG_TXT_C, OPT_53_HAS_ARG_LONG, 0, OPT_53_ENUM_NAME},
+    #endif
+    #ifdef OPT_53_CLI_LONG_TXT_D
+          {OPT_53_CLI_LONG_TXT_D, OPT_53_HAS_ARG_LONG, 0, OPT_53_ENUM_NAME},
+    #endif
+    #ifdef OPT_53_CLI_SHORT_CODE_TXT
+          {OPT_53_CLI_SHORT_CODE_TXT, OPT_53_HAS_ARG_LONG, 0, OPT_53_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_54_ENUM_NAME
+    #ifdef OPT_54_CLI_LONG_TXT_A
+          {OPT_54_CLI_LONG_TXT_A, OPT_54_HAS_ARG_LONG, 0, OPT_54_ENUM_NAME},
+    #endif
+    #ifdef OPT_54_CLI_LONG_TXT_B
+          {OPT_54_CLI_LONG_TXT_B, OPT_54_HAS_ARG_LONG, 0, OPT_54_ENUM_NAME},
+    #endif
+    #ifdef OPT_54_CLI_LONG_TXT_C
+          {OPT_54_CLI_LONG_TXT_C, OPT_54_HAS_ARG_LONG, 0, OPT_54_ENUM_NAME},
+    #endif
+    #ifdef OPT_54_CLI_LONG_TXT_D
+          {OPT_54_CLI_LONG_TXT_D, OPT_54_HAS_ARG_LONG, 0, OPT_54_ENUM_NAME},
+    #endif
+    #ifdef OPT_54_CLI_SHORT_CODE_TXT
+          {OPT_54_CLI_SHORT_CODE_TXT, OPT_54_HAS_ARG_LONG, 0, OPT_54_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_55_ENUM_NAME
+    #ifdef OPT_55_CLI_LONG_TXT_A
+          {OPT_55_CLI_LONG_TXT_A, OPT_55_HAS_ARG_LONG, 0, OPT_55_ENUM_NAME},
+    #endif
+    #ifdef OPT_55_CLI_LONG_TXT_B
+          {OPT_55_CLI_LONG_TXT_B, OPT_55_HAS_ARG_LONG, 0, OPT_55_ENUM_NAME},
+    #endif
+    #ifdef OPT_55_CLI_LONG_TXT_C
+          {OPT_55_CLI_LONG_TXT_C, OPT_55_HAS_ARG_LONG, 0, OPT_55_ENUM_NAME},
+    #endif
+    #ifdef OPT_55_CLI_LONG_TXT_D
+          {OPT_55_CLI_LONG_TXT_D, OPT_55_HAS_ARG_LONG, 0, OPT_55_ENUM_NAME},
+    #endif
+    #ifdef OPT_55_CLI_SHORT_CODE_TXT
+          {OPT_55_CLI_SHORT_CODE_TXT, OPT_55_HAS_ARG_LONG, 0, OPT_55_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_56_ENUM_NAME
+    #ifdef OPT_56_CLI_LONG_TXT_A
+          {OPT_56_CLI_LONG_TXT_A, OPT_56_HAS_ARG_LONG, 0, OPT_56_ENUM_NAME},
+    #endif
+    #ifdef OPT_56_CLI_LONG_TXT_B
+          {OPT_56_CLI_LONG_TXT_B, OPT_56_HAS_ARG_LONG, 0, OPT_56_ENUM_NAME},
+    #endif
+    #ifdef OPT_56_CLI_LONG_TXT_C
+          {OPT_56_CLI_LONG_TXT_C, OPT_56_HAS_ARG_LONG, 0, OPT_56_ENUM_NAME},
+    #endif
+    #ifdef OPT_56_CLI_LONG_TXT_D
+          {OPT_56_CLI_LONG_TXT_D, OPT_56_HAS_ARG_LONG, 0, OPT_56_ENUM_NAME},
+    #endif
+    #ifdef OPT_56_CLI_SHORT_CODE_TXT
+          {OPT_56_CLI_SHORT_CODE_TXT, OPT_56_HAS_ARG_LONG, 0, OPT_56_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_57_ENUM_NAME
+    #ifdef OPT_57_CLI_LONG_TXT_A
+          {OPT_57_CLI_LONG_TXT_A, OPT_57_HAS_ARG_LONG, 0, OPT_57_ENUM_NAME},
+    #endif
+    #ifdef OPT_57_CLI_LONG_TXT_B
+          {OPT_57_CLI_LONG_TXT_B, OPT_57_HAS_ARG_LONG, 0, OPT_57_ENUM_NAME},
+    #endif
+    #ifdef OPT_57_CLI_LONG_TXT_C
+          {OPT_57_CLI_LONG_TXT_C, OPT_57_HAS_ARG_LONG, 0, OPT_57_ENUM_NAME},
+    #endif
+    #ifdef OPT_57_CLI_LONG_TXT_D
+          {OPT_57_CLI_LONG_TXT_D, OPT_57_HAS_ARG_LONG, 0, OPT_57_ENUM_NAME},
+    #endif
+    #ifdef OPT_57_CLI_SHORT_CODE_TXT
+          {OPT_57_CLI_SHORT_CODE_TXT, OPT_57_HAS_ARG_LONG, 0, OPT_57_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_58_ENUM_NAME
+    #ifdef OPT_58_CLI_LONG_TXT_A
+          {OPT_58_CLI_LONG_TXT_A, OPT_58_HAS_ARG_LONG, 0, OPT_58_ENUM_NAME},
+    #endif
+    #ifdef OPT_58_CLI_LONG_TXT_B
+          {OPT_58_CLI_LONG_TXT_B, OPT_58_HAS_ARG_LONG, 0, OPT_58_ENUM_NAME},
+    #endif
+    #ifdef OPT_58_CLI_LONG_TXT_C
+          {OPT_58_CLI_LONG_TXT_C, OPT_58_HAS_ARG_LONG, 0, OPT_58_ENUM_NAME},
+    #endif
+    #ifdef OPT_58_CLI_LONG_TXT_D
+          {OPT_58_CLI_LONG_TXT_D, OPT_58_HAS_ARG_LONG, 0, OPT_58_ENUM_NAME},
+    #endif
+    #ifdef OPT_58_CLI_SHORT_CODE_TXT
+          {OPT_58_CLI_SHORT_CODE_TXT, OPT_58_HAS_ARG_LONG, 0, OPT_58_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_59_ENUM_NAME
+    #ifdef OPT_59_CLI_LONG_TXT_A
+          {OPT_59_CLI_LONG_TXT_A, OPT_59_HAS_ARG_LONG, 0, OPT_59_ENUM_NAME},
+    #endif
+    #ifdef OPT_59_CLI_LONG_TXT_B
+          {OPT_59_CLI_LONG_TXT_B, OPT_59_HAS_ARG_LONG, 0, OPT_59_ENUM_NAME},
+    #endif
+    #ifdef OPT_59_CLI_LONG_TXT_C
+          {OPT_59_CLI_LONG_TXT_C, OPT_59_HAS_ARG_LONG, 0, OPT_59_ENUM_NAME},
+    #endif
+    #ifdef OPT_59_CLI_LONG_TXT_D
+          {OPT_59_CLI_LONG_TXT_D, OPT_59_HAS_ARG_LONG, 0, OPT_59_ENUM_NAME},
+    #endif
+    #ifdef OPT_59_CLI_SHORT_CODE_TXT
+          {OPT_59_CLI_SHORT_CODE_TXT, OPT_59_HAS_ARG_LONG, 0, OPT_59_ENUM_NAME},
+    #endif
+#endif
+
+#ifdef OPT_60_ENUM_NAME
+    #ifdef OPT_60_CLI_LONG_TXT_A
+          {OPT_60_CLI_LONG_TXT_A, OPT_60_HAS_ARG_LONG, 0, OPT_60_ENUM_NAME},
+    #endif
+    #ifdef OPT_60_CLI_LONG_TXT_B
+          {OPT_60_CLI_LONG_TXT_B, OPT_60_HAS_ARG_LONG, 0, OPT_60_ENUM_NAME},
+    #endif
+    #ifdef OPT_60_CLI_LONG_TXT_C
+          {OPT_60_CLI_LONG_TXT_C, OPT_60_HAS_ARG_LONG, 0, OPT_60_ENUM_NAME},
+    #endif
+    #ifdef OPT_60_CLI_LONG_TXT_D
+          {OPT_60_CLI_LONG_TXT_D, OPT_60_HAS_ARG_LONG, 0, OPT_60_ENUM_NAME},
+    #endif
+    #ifdef OPT_60_CLI_SHORT_CODE_TXT
+          {OPT_60_CLI_SHORT_CODE_TXT, OPT_60_HAS_ARG_LONG, 0, OPT_60_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_61_ENUM_NAME
+    #ifdef OPT_61_CLI_LONG_TXT_A
+          {OPT_61_CLI_LONG_TXT_A, OPT_61_HAS_ARG_LONG, 0, OPT_61_ENUM_NAME},
+    #endif
+    #ifdef OPT_61_CLI_LONG_TXT_B
+          {OPT_61_CLI_LONG_TXT_B, OPT_61_HAS_ARG_LONG, 0, OPT_61_ENUM_NAME},
+    #endif
+    #ifdef OPT_61_CLI_LONG_TXT_C
+          {OPT_61_CLI_LONG_TXT_C, OPT_61_HAS_ARG_LONG, 0, OPT_61_ENUM_NAME},
+    #endif
+    #ifdef OPT_61_CLI_LONG_TXT_D
+          {OPT_61_CLI_LONG_TXT_D, OPT_61_HAS_ARG_LONG, 0, OPT_61_ENUM_NAME},
+    #endif
+    #ifdef OPT_61_CLI_SHORT_CODE_TXT
+          {OPT_61_CLI_SHORT_CODE_TXT, OPT_61_HAS_ARG_LONG, 0, OPT_61_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_62_ENUM_NAME
+    #ifdef OPT_62_CLI_LONG_TXT_A
+          {OPT_62_CLI_LONG_TXT_A, OPT_62_HAS_ARG_LONG, 0, OPT_62_ENUM_NAME},
+    #endif
+    #ifdef OPT_62_CLI_LONG_TXT_B
+          {OPT_62_CLI_LONG_TXT_B, OPT_62_HAS_ARG_LONG, 0, OPT_62_ENUM_NAME},
+    #endif
+    #ifdef OPT_62_CLI_LONG_TXT_C
+          {OPT_62_CLI_LONG_TXT_C, OPT_62_HAS_ARG_LONG, 0, OPT_62_ENUM_NAME},
+    #endif
+    #ifdef OPT_62_CLI_LONG_TXT_D
+          {OPT_62_CLI_LONG_TXT_D, OPT_62_HAS_ARG_LONG, 0, OPT_62_ENUM_NAME},
+    #endif
+    #ifdef OPT_62_CLI_SHORT_CODE_TXT
+          {OPT_62_CLI_SHORT_CODE_TXT, OPT_62_HAS_ARG_LONG, 0, OPT_62_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_63_ENUM_NAME
+    #ifdef OPT_63_CLI_LONG_TXT_A
+          {OPT_63_CLI_LONG_TXT_A, OPT_63_HAS_ARG_LONG, 0, OPT_63_ENUM_NAME},
+    #endif
+    #ifdef OPT_63_CLI_LONG_TXT_B
+          {OPT_63_CLI_LONG_TXT_B, OPT_63_HAS_ARG_LONG, 0, OPT_63_ENUM_NAME},
+    #endif
+    #ifdef OPT_63_CLI_LONG_TXT_C
+          {OPT_63_CLI_LONG_TXT_C, OPT_63_HAS_ARG_LONG, 0, OPT_63_ENUM_NAME},
+    #endif
+    #ifdef OPT_63_CLI_LONG_TXT_D
+          {OPT_63_CLI_LONG_TXT_D, OPT_63_HAS_ARG_LONG, 0, OPT_63_ENUM_NAME},
+    #endif
+    #ifdef OPT_63_CLI_SHORT_CODE_TXT
+          {OPT_63_CLI_SHORT_CODE_TXT, OPT_63_HAS_ARG_LONG, 0, OPT_63_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_64_ENUM_NAME
+    #ifdef OPT_64_CLI_LONG_TXT_A
+          {OPT_64_CLI_LONG_TXT_A, OPT_64_HAS_ARG_LONG, 0, OPT_64_ENUM_NAME},
+    #endif
+    #ifdef OPT_64_CLI_LONG_TXT_B
+          {OPT_64_CLI_LONG_TXT_B, OPT_64_HAS_ARG_LONG, 0, OPT_64_ENUM_NAME},
+    #endif
+    #ifdef OPT_64_CLI_LONG_TXT_C
+          {OPT_64_CLI_LONG_TXT_C, OPT_64_HAS_ARG_LONG, 0, OPT_64_ENUM_NAME},
+    #endif
+    #ifdef OPT_64_CLI_LONG_TXT_D
+          {OPT_64_CLI_LONG_TXT_D, OPT_64_HAS_ARG_LONG, 0, OPT_64_ENUM_NAME},
+    #endif
+    #ifdef OPT_64_CLI_SHORT_CODE_TXT
+          {OPT_64_CLI_SHORT_CODE_TXT, OPT_64_HAS_ARG_LONG, 0, OPT_64_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_65_ENUM_NAME
+    #ifdef OPT_65_CLI_LONG_TXT_A
+          {OPT_65_CLI_LONG_TXT_A, OPT_65_HAS_ARG_LONG, 0, OPT_65_ENUM_NAME},
+    #endif
+    #ifdef OPT_65_CLI_LONG_TXT_B
+          {OPT_65_CLI_LONG_TXT_B, OPT_65_HAS_ARG_LONG, 0, OPT_65_ENUM_NAME},
+    #endif
+    #ifdef OPT_65_CLI_LONG_TXT_C
+          {OPT_65_CLI_LONG_TXT_C, OPT_65_HAS_ARG_LONG, 0, OPT_65_ENUM_NAME},
+    #endif
+    #ifdef OPT_65_CLI_LONG_TXT_D
+          {OPT_65_CLI_LONG_TXT_D, OPT_65_HAS_ARG_LONG, 0, OPT_65_ENUM_NAME},
+    #endif
+    #ifdef OPT_65_CLI_SHORT_CODE_TXT
+          {OPT_65_CLI_SHORT_CODE_TXT, OPT_65_HAS_ARG_LONG, 0, OPT_65_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_66_ENUM_NAME
+    #ifdef OPT_66_CLI_LONG_TXT_A
+          {OPT_66_CLI_LONG_TXT_A, OPT_66_HAS_ARG_LONG, 0, OPT_66_ENUM_NAME},
+    #endif
+    #ifdef OPT_66_CLI_LONG_TXT_B
+          {OPT_66_CLI_LONG_TXT_B, OPT_66_HAS_ARG_LONG, 0, OPT_66_ENUM_NAME},
+    #endif
+    #ifdef OPT_66_CLI_LONG_TXT_C
+          {OPT_66_CLI_LONG_TXT_C, OPT_66_HAS_ARG_LONG, 0, OPT_66_ENUM_NAME},
+    #endif
+    #ifdef OPT_66_CLI_LONG_TXT_D
+          {OPT_66_CLI_LONG_TXT_D, OPT_66_HAS_ARG_LONG, 0, OPT_66_ENUM_NAME},
+    #endif
+    #ifdef OPT_66_CLI_SHORT_CODE_TXT
+          {OPT_66_CLI_SHORT_CODE_TXT, OPT_66_HAS_ARG_LONG, 0, OPT_66_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_67_ENUM_NAME
+    #ifdef OPT_67_CLI_LONG_TXT_A
+          {OPT_67_CLI_LONG_TXT_A, OPT_67_HAS_ARG_LONG, 0, OPT_67_ENUM_NAME},
+    #endif
+    #ifdef OPT_67_CLI_LONG_TXT_B
+          {OPT_67_CLI_LONG_TXT_B, OPT_67_HAS_ARG_LONG, 0, OPT_67_ENUM_NAME},
+    #endif
+    #ifdef OPT_67_CLI_LONG_TXT_C
+          {OPT_67_CLI_LONG_TXT_C, OPT_67_HAS_ARG_LONG, 0, OPT_67_ENUM_NAME},
+    #endif
+    #ifdef OPT_67_CLI_LONG_TXT_D
+          {OPT_67_CLI_LONG_TXT_D, OPT_67_HAS_ARG_LONG, 0, OPT_67_ENUM_NAME},
+    #endif
+    #ifdef OPT_67_CLI_SHORT_CODE_TXT
+          {OPT_67_CLI_SHORT_CODE_TXT, OPT_67_HAS_ARG_LONG, 0, OPT_67_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_68_ENUM_NAME
+    #ifdef OPT_68_CLI_LONG_TXT_A
+          {OPT_68_CLI_LONG_TXT_A, OPT_68_HAS_ARG_LONG, 0, OPT_68_ENUM_NAME},
+    #endif
+    #ifdef OPT_68_CLI_LONG_TXT_B
+          {OPT_68_CLI_LONG_TXT_B, OPT_68_HAS_ARG_LONG, 0, OPT_68_ENUM_NAME},
+    #endif
+    #ifdef OPT_68_CLI_LONG_TXT_C
+          {OPT_68_CLI_LONG_TXT_C, OPT_68_HAS_ARG_LONG, 0, OPT_68_ENUM_NAME},
+    #endif
+    #ifdef OPT_68_CLI_LONG_TXT_D
+          {OPT_68_CLI_LONG_TXT_D, OPT_68_HAS_ARG_LONG, 0, OPT_68_ENUM_NAME},
+    #endif
+    #ifdef OPT_68_CLI_SHORT_CODE_TXT
+          {OPT_68_CLI_SHORT_CODE_TXT, OPT_68_HAS_ARG_LONG, 0, OPT_68_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_69_ENUM_NAME
+    #ifdef OPT_69_CLI_LONG_TXT_A
+          {OPT_69_CLI_LONG_TXT_A, OPT_69_HAS_ARG_LONG, 0, OPT_69_ENUM_NAME},
+    #endif
+    #ifdef OPT_69_CLI_LONG_TXT_B
+          {OPT_69_CLI_LONG_TXT_B, OPT_69_HAS_ARG_LONG, 0, OPT_69_ENUM_NAME},
+    #endif
+    #ifdef OPT_69_CLI_LONG_TXT_C
+          {OPT_69_CLI_LONG_TXT_C, OPT_69_HAS_ARG_LONG, 0, OPT_69_ENUM_NAME},
+    #endif
+    #ifdef OPT_69_CLI_LONG_TXT_D
+          {OPT_69_CLI_LONG_TXT_D, OPT_69_HAS_ARG_LONG, 0, OPT_69_ENUM_NAME},
+    #endif
+    #ifdef OPT_69_CLI_SHORT_CODE_TXT
+          {OPT_69_CLI_SHORT_CODE_TXT, OPT_69_HAS_ARG_LONG, 0, OPT_69_ENUM_NAME},
+    #endif
+#endif
+
+#ifdef OPT_70_ENUM_NAME
+    #ifdef OPT_70_CLI_LONG_TXT_A
+          {OPT_70_CLI_LONG_TXT_A, OPT_70_HAS_ARG_LONG, 0, OPT_70_ENUM_NAME},
+    #endif
+    #ifdef OPT_70_CLI_LONG_TXT_B
+          {OPT_70_CLI_LONG_TXT_B, OPT_70_HAS_ARG_LONG, 0, OPT_70_ENUM_NAME},
+    #endif
+    #ifdef OPT_70_CLI_LONG_TXT_C
+          {OPT_70_CLI_LONG_TXT_C, OPT_70_HAS_ARG_LONG, 0, OPT_70_ENUM_NAME},
+    #endif
+    #ifdef OPT_70_CLI_LONG_TXT_D
+          {OPT_70_CLI_LONG_TXT_D, OPT_70_HAS_ARG_LONG, 0, OPT_70_ENUM_NAME},
+    #endif
+    #ifdef OPT_70_CLI_SHORT_CODE_TXT
+          {OPT_70_CLI_SHORT_CODE_TXT, OPT_70_HAS_ARG_LONG, 0, OPT_70_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_71_ENUM_NAME
+    #ifdef OPT_71_CLI_LONG_TXT_A
+          {OPT_71_CLI_LONG_TXT_A, OPT_71_HAS_ARG_LONG, 0, OPT_71_ENUM_NAME},
+    #endif
+    #ifdef OPT_71_CLI_LONG_TXT_B
+          {OPT_71_CLI_LONG_TXT_B, OPT_71_HAS_ARG_LONG, 0, OPT_71_ENUM_NAME},
+    #endif
+    #ifdef OPT_71_CLI_LONG_TXT_C
+          {OPT_71_CLI_LONG_TXT_C, OPT_71_HAS_ARG_LONG, 0, OPT_71_ENUM_NAME},
+    #endif
+    #ifdef OPT_71_CLI_LONG_TXT_D
+          {OPT_71_CLI_LONG_TXT_D, OPT_71_HAS_ARG_LONG, 0, OPT_71_ENUM_NAME},
+    #endif
+    #ifdef OPT_71_CLI_SHORT_CODE_TXT
+          {OPT_71_CLI_SHORT_CODE_TXT, OPT_71_HAS_ARG_LONG, 0, OPT_71_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_72_ENUM_NAME
+    #ifdef OPT_72_CLI_LONG_TXT_A
+          {OPT_72_CLI_LONG_TXT_A, OPT_72_HAS_ARG_LONG, 0, OPT_72_ENUM_NAME},
+    #endif
+    #ifdef OPT_72_CLI_LONG_TXT_B
+          {OPT_72_CLI_LONG_TXT_B, OPT_72_HAS_ARG_LONG, 0, OPT_72_ENUM_NAME},
+    #endif
+    #ifdef OPT_72_CLI_LONG_TXT_C
+          {OPT_72_CLI_LONG_TXT_C, OPT_72_HAS_ARG_LONG, 0, OPT_72_ENUM_NAME},
+    #endif
+    #ifdef OPT_72_CLI_LONG_TXT_D
+          {OPT_72_CLI_LONG_TXT_D, OPT_72_HAS_ARG_LONG, 0, OPT_72_ENUM_NAME},
+    #endif
+    #ifdef OPT_72_CLI_SHORT_CODE_TXT
+          {OPT_72_CLI_SHORT_CODE_TXT, OPT_72_HAS_ARG_LONG, 0, OPT_72_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_73_ENUM_NAME
+    #ifdef OPT_73_CLI_LONG_TXT_A
+          {OPT_73_CLI_LONG_TXT_A, OPT_73_HAS_ARG_LONG, 0, OPT_73_ENUM_NAME},
+    #endif
+    #ifdef OPT_73_CLI_LONG_TXT_B
+          {OPT_73_CLI_LONG_TXT_B, OPT_73_HAS_ARG_LONG, 0, OPT_73_ENUM_NAME},
+    #endif
+    #ifdef OPT_73_CLI_LONG_TXT_C
+          {OPT_73_CLI_LONG_TXT_C, OPT_73_HAS_ARG_LONG, 0, OPT_73_ENUM_NAME},
+    #endif
+    #ifdef OPT_73_CLI_LONG_TXT_D
+          {OPT_73_CLI_LONG_TXT_D, OPT_73_HAS_ARG_LONG, 0, OPT_73_ENUM_NAME},
+    #endif
+    #ifdef OPT_73_CLI_SHORT_CODE_TXT
+          {OPT_73_CLI_SHORT_CODE_TXT, OPT_73_HAS_ARG_LONG, 0, OPT_73_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_74_ENUM_NAME
+    #ifdef OPT_74_CLI_LONG_TXT_A
+          {OPT_74_CLI_LONG_TXT_A, OPT_74_HAS_ARG_LONG, 0, OPT_74_ENUM_NAME},
+    #endif
+    #ifdef OPT_74_CLI_LONG_TXT_B
+          {OPT_74_CLI_LONG_TXT_B, OPT_74_HAS_ARG_LONG, 0, OPT_74_ENUM_NAME},
+    #endif
+    #ifdef OPT_74_CLI_LONG_TXT_C
+          {OPT_74_CLI_LONG_TXT_C, OPT_74_HAS_ARG_LONG, 0, OPT_74_ENUM_NAME},
+    #endif
+    #ifdef OPT_74_CLI_LONG_TXT_D
+          {OPT_74_CLI_LONG_TXT_D, OPT_74_HAS_ARG_LONG, 0, OPT_74_ENUM_NAME},
+    #endif
+    #ifdef OPT_74_CLI_SHORT_CODE_TXT
+          {OPT_74_CLI_SHORT_CODE_TXT, OPT_74_HAS_ARG_LONG, 0, OPT_74_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_75_ENUM_NAME
+    #ifdef OPT_75_CLI_LONG_TXT_A
+          {OPT_75_CLI_LONG_TXT_A, OPT_75_HAS_ARG_LONG, 0, OPT_75_ENUM_NAME},
+    #endif
+    #ifdef OPT_75_CLI_LONG_TXT_B
+          {OPT_75_CLI_LONG_TXT_B, OPT_75_HAS_ARG_LONG, 0, OPT_75_ENUM_NAME},
+    #endif
+    #ifdef OPT_75_CLI_LONG_TXT_C
+          {OPT_75_CLI_LONG_TXT_C, OPT_75_HAS_ARG_LONG, 0, OPT_75_ENUM_NAME},
+    #endif
+    #ifdef OPT_75_CLI_LONG_TXT_D
+          {OPT_75_CLI_LONG_TXT_D, OPT_75_HAS_ARG_LONG, 0, OPT_75_ENUM_NAME},
+    #endif
+    #ifdef OPT_75_CLI_SHORT_CODE_TXT
+          {OPT_75_CLI_SHORT_CODE_TXT, OPT_75_HAS_ARG_LONG, 0, OPT_75_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_76_ENUM_NAME
+    #ifdef OPT_76_CLI_LONG_TXT_A
+          {OPT_76_CLI_LONG_TXT_A, OPT_76_HAS_ARG_LONG, 0, OPT_76_ENUM_NAME},
+    #endif
+    #ifdef OPT_76_CLI_LONG_TXT_B
+          {OPT_76_CLI_LONG_TXT_B, OPT_76_HAS_ARG_LONG, 0, OPT_76_ENUM_NAME},
+    #endif
+    #ifdef OPT_76_CLI_LONG_TXT_C
+          {OPT_76_CLI_LONG_TXT_C, OPT_76_HAS_ARG_LONG, 0, OPT_76_ENUM_NAME},
+    #endif
+    #ifdef OPT_76_CLI_LONG_TXT_D
+          {OPT_76_CLI_LONG_TXT_D, OPT_76_HAS_ARG_LONG, 0, OPT_76_ENUM_NAME},
+    #endif
+    #ifdef OPT_76_CLI_SHORT_CODE_TXT
+          {OPT_76_CLI_SHORT_CODE_TXT, OPT_76_HAS_ARG_LONG, 0, OPT_76_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_77_ENUM_NAME
+    #ifdef OPT_77_CLI_LONG_TXT_A
+          {OPT_77_CLI_LONG_TXT_A, OPT_77_HAS_ARG_LONG, 0, OPT_77_ENUM_NAME},
+    #endif
+    #ifdef OPT_77_CLI_LONG_TXT_B
+          {OPT_77_CLI_LONG_TXT_B, OPT_77_HAS_ARG_LONG, 0, OPT_77_ENUM_NAME},
+    #endif
+    #ifdef OPT_77_CLI_LONG_TXT_C
+          {OPT_77_CLI_LONG_TXT_C, OPT_77_HAS_ARG_LONG, 0, OPT_77_ENUM_NAME},
+    #endif
+    #ifdef OPT_77_CLI_LONG_TXT_D
+          {OPT_77_CLI_LONG_TXT_D, OPT_77_HAS_ARG_LONG, 0, OPT_77_ENUM_NAME},
+    #endif
+    #ifdef OPT_77_CLI_SHORT_CODE_TXT
+          {OPT_77_CLI_SHORT_CODE_TXT, OPT_77_HAS_ARG_LONG, 0, OPT_77_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_78_ENUM_NAME
+    #ifdef OPT_78_CLI_LONG_TXT_A
+          {OPT_78_CLI_LONG_TXT_A, OPT_78_HAS_ARG_LONG, 0, OPT_78_ENUM_NAME},
+    #endif
+    #ifdef OPT_78_CLI_LONG_TXT_B
+          {OPT_78_CLI_LONG_TXT_B, OPT_78_HAS_ARG_LONG, 0, OPT_78_ENUM_NAME},
+    #endif
+    #ifdef OPT_78_CLI_LONG_TXT_C
+          {OPT_78_CLI_LONG_TXT_C, OPT_78_HAS_ARG_LONG, 0, OPT_78_ENUM_NAME},
+    #endif
+    #ifdef OPT_78_CLI_LONG_TXT_D
+          {OPT_78_CLI_LONG_TXT_D, OPT_78_HAS_ARG_LONG, 0, OPT_78_ENUM_NAME},
+    #endif
+    #ifdef OPT_78_CLI_SHORT_CODE_TXT
+          {OPT_78_CLI_SHORT_CODE_TXT, OPT_78_HAS_ARG_LONG, 0, OPT_78_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_79_ENUM_NAME
+    #ifdef OPT_79_CLI_LONG_TXT_A
+          {OPT_79_CLI_LONG_TXT_A, OPT_79_HAS_ARG_LONG, 0, OPT_79_ENUM_NAME},
+    #endif
+    #ifdef OPT_79_CLI_LONG_TXT_B
+          {OPT_79_CLI_LONG_TXT_B, OPT_79_HAS_ARG_LONG, 0, OPT_79_ENUM_NAME},
+    #endif
+    #ifdef OPT_79_CLI_LONG_TXT_C
+          {OPT_79_CLI_LONG_TXT_C, OPT_79_HAS_ARG_LONG, 0, OPT_79_ENUM_NAME},
+    #endif
+    #ifdef OPT_79_CLI_LONG_TXT_D
+          {OPT_79_CLI_LONG_TXT_D, OPT_79_HAS_ARG_LONG, 0, OPT_79_ENUM_NAME},
+    #endif
+    #ifdef OPT_79_CLI_SHORT_CODE_TXT
+          {OPT_79_CLI_SHORT_CODE_TXT, OPT_79_HAS_ARG_LONG, 0, OPT_79_ENUM_NAME},
+    #endif
+#endif
+
+#ifdef OPT_80_ENUM_NAME
+    #ifdef OPT_80_CLI_LONG_TXT_A
+          {OPT_80_CLI_LONG_TXT_A, OPT_80_HAS_ARG_LONG, 0, OPT_80_ENUM_NAME},
+    #endif
+    #ifdef OPT_80_CLI_LONG_TXT_B
+          {OPT_80_CLI_LONG_TXT_B, OPT_80_HAS_ARG_LONG, 0, OPT_80_ENUM_NAME},
+    #endif
+    #ifdef OPT_80_CLI_LONG_TXT_C
+          {OPT_80_CLI_LONG_TXT_C, OPT_80_HAS_ARG_LONG, 0, OPT_80_ENUM_NAME},
+    #endif
+    #ifdef OPT_80_CLI_LONG_TXT_D
+          {OPT_80_CLI_LONG_TXT_D, OPT_80_HAS_ARG_LONG, 0, OPT_80_ENUM_NAME},
+    #endif
+    #ifdef OPT_80_CLI_SHORT_CODE_TXT
+          {OPT_80_CLI_SHORT_CODE_TXT, OPT_80_HAS_ARG_LONG, 0, OPT_80_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_81_ENUM_NAME
+    #ifdef OPT_81_CLI_LONG_TXT_A
+          {OPT_81_CLI_LONG_TXT_A, OPT_81_HAS_ARG_LONG, 0, OPT_81_ENUM_NAME},
+    #endif
+    #ifdef OPT_81_CLI_LONG_TXT_B
+          {OPT_81_CLI_LONG_TXT_B, OPT_81_HAS_ARG_LONG, 0, OPT_81_ENUM_NAME},
+    #endif
+    #ifdef OPT_81_CLI_LONG_TXT_C
+          {OPT_81_CLI_LONG_TXT_C, OPT_81_HAS_ARG_LONG, 0, OPT_81_ENUM_NAME},
+    #endif
+    #ifdef OPT_81_CLI_LONG_TXT_D
+          {OPT_81_CLI_LONG_TXT_D, OPT_81_HAS_ARG_LONG, 0, OPT_81_ENUM_NAME},
+    #endif
+    #ifdef OPT_81_CLI_SHORT_CODE_TXT
+          {OPT_81_CLI_SHORT_CODE_TXT, OPT_81_HAS_ARG_LONG, 0, OPT_81_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_82_ENUM_NAME
+    #ifdef OPT_82_CLI_LONG_TXT_A
+          {OPT_82_CLI_LONG_TXT_A, OPT_82_HAS_ARG_LONG, 0, OPT_82_ENUM_NAME},
+    #endif
+    #ifdef OPT_82_CLI_LONG_TXT_B
+          {OPT_82_CLI_LONG_TXT_B, OPT_82_HAS_ARG_LONG, 0, OPT_82_ENUM_NAME},
+    #endif
+    #ifdef OPT_82_CLI_LONG_TXT_C
+          {OPT_82_CLI_LONG_TXT_C, OPT_82_HAS_ARG_LONG, 0, OPT_82_ENUM_NAME},
+    #endif
+    #ifdef OPT_82_CLI_LONG_TXT_D
+          {OPT_82_CLI_LONG_TXT_D, OPT_82_HAS_ARG_LONG, 0, OPT_82_ENUM_NAME},
+    #endif
+    #ifdef OPT_82_CLI_SHORT_CODE_TXT
+          {OPT_82_CLI_SHORT_CODE_TXT, OPT_82_HAS_ARG_LONG, 0, OPT_82_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_83_ENUM_NAME
+    #ifdef OPT_83_CLI_LONG_TXT_A
+          {OPT_83_CLI_LONG_TXT_A, OPT_83_HAS_ARG_LONG, 0, OPT_83_ENUM_NAME},
+    #endif
+    #ifdef OPT_83_CLI_LONG_TXT_B
+          {OPT_83_CLI_LONG_TXT_B, OPT_83_HAS_ARG_LONG, 0, OPT_83_ENUM_NAME},
+    #endif
+    #ifdef OPT_83_CLI_LONG_TXT_C
+          {OPT_83_CLI_LONG_TXT_C, OPT_83_HAS_ARG_LONG, 0, OPT_83_ENUM_NAME},
+    #endif
+    #ifdef OPT_83_CLI_LONG_TXT_D
+          {OPT_83_CLI_LONG_TXT_D, OPT_83_HAS_ARG_LONG, 0, OPT_83_ENUM_NAME},
+    #endif
+    #ifdef OPT_83_CLI_SHORT_CODE_TXT
+          {OPT_83_CLI_SHORT_CODE_TXT, OPT_83_HAS_ARG_LONG, 0, OPT_83_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_84_ENUM_NAME
+    #ifdef OPT_84_CLI_LONG_TXT_A
+          {OPT_84_CLI_LONG_TXT_A, OPT_84_HAS_ARG_LONG, 0, OPT_84_ENUM_NAME},
+    #endif
+    #ifdef OPT_84_CLI_LONG_TXT_B
+          {OPT_84_CLI_LONG_TXT_B, OPT_84_HAS_ARG_LONG, 0, OPT_84_ENUM_NAME},
+    #endif
+    #ifdef OPT_84_CLI_LONG_TXT_C
+          {OPT_84_CLI_LONG_TXT_C, OPT_84_HAS_ARG_LONG, 0, OPT_84_ENUM_NAME},
+    #endif
+    #ifdef OPT_84_CLI_LONG_TXT_D
+          {OPT_84_CLI_LONG_TXT_D, OPT_84_HAS_ARG_LONG, 0, OPT_84_ENUM_NAME},
+    #endif
+    #ifdef OPT_84_CLI_SHORT_CODE_TXT
+          {OPT_84_CLI_SHORT_CODE_TXT, OPT_84_HAS_ARG_LONG, 0, OPT_84_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_85_ENUM_NAME
+    #ifdef OPT_85_CLI_LONG_TXT_A
+          {OPT_85_CLI_LONG_TXT_A, OPT_85_HAS_ARG_LONG, 0, OPT_85_ENUM_NAME},
+    #endif
+    #ifdef OPT_85_CLI_LONG_TXT_B
+          {OPT_85_CLI_LONG_TXT_B, OPT_85_HAS_ARG_LONG, 0, OPT_85_ENUM_NAME},
+    #endif
+    #ifdef OPT_85_CLI_LONG_TXT_C
+          {OPT_85_CLI_LONG_TXT_C, OPT_85_HAS_ARG_LONG, 0, OPT_85_ENUM_NAME},
+    #endif
+    #ifdef OPT_85_CLI_LONG_TXT_D
+          {OPT_85_CLI_LONG_TXT_D, OPT_85_HAS_ARG_LONG, 0, OPT_85_ENUM_NAME},
+    #endif
+    #ifdef OPT_85_CLI_SHORT_CODE_TXT
+          {OPT_85_CLI_SHORT_CODE_TXT, OPT_85_HAS_ARG_LONG, 0, OPT_85_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_86_ENUM_NAME
+    #ifdef OPT_86_CLI_LONG_TXT_A
+          {OPT_86_CLI_LONG_TXT_A, OPT_86_HAS_ARG_LONG, 0, OPT_86_ENUM_NAME},
+    #endif
+    #ifdef OPT_86_CLI_LONG_TXT_B
+          {OPT_86_CLI_LONG_TXT_B, OPT_86_HAS_ARG_LONG, 0, OPT_86_ENUM_NAME},
+    #endif
+    #ifdef OPT_86_CLI_LONG_TXT_C
+          {OPT_86_CLI_LONG_TXT_C, OPT_86_HAS_ARG_LONG, 0, OPT_86_ENUM_NAME},
+    #endif
+    #ifdef OPT_86_CLI_LONG_TXT_D
+          {OPT_86_CLI_LONG_TXT_D, OPT_86_HAS_ARG_LONG, 0, OPT_86_ENUM_NAME},
+    #endif
+    #ifdef OPT_86_CLI_SHORT_CODE_TXT
+          {OPT_86_CLI_SHORT_CODE_TXT, OPT_86_HAS_ARG_LONG, 0, OPT_86_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_87_ENUM_NAME
+    #ifdef OPT_87_CLI_LONG_TXT_A
+          {OPT_87_CLI_LONG_TXT_A, OPT_87_HAS_ARG_LONG, 0, OPT_87_ENUM_NAME},
+    #endif
+    #ifdef OPT_87_CLI_LONG_TXT_B
+          {OPT_87_CLI_LONG_TXT_B, OPT_87_HAS_ARG_LONG, 0, OPT_87_ENUM_NAME},
+    #endif
+    #ifdef OPT_87_CLI_LONG_TXT_C
+          {OPT_87_CLI_LONG_TXT_C, OPT_87_HAS_ARG_LONG, 0, OPT_87_ENUM_NAME},
+    #endif
+    #ifdef OPT_87_CLI_LONG_TXT_D
+          {OPT_87_CLI_LONG_TXT_D, OPT_87_HAS_ARG_LONG, 0, OPT_87_ENUM_NAME},
+    #endif
+    #ifdef OPT_87_CLI_SHORT_CODE_TXT
+          {OPT_87_CLI_SHORT_CODE_TXT, OPT_87_HAS_ARG_LONG, 0, OPT_87_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_88_ENUM_NAME
+    #ifdef OPT_88_CLI_LONG_TXT_A
+          {OPT_88_CLI_LONG_TXT_A, OPT_88_HAS_ARG_LONG, 0, OPT_88_ENUM_NAME},
+    #endif
+    #ifdef OPT_88_CLI_LONG_TXT_B
+          {OPT_88_CLI_LONG_TXT_B, OPT_88_HAS_ARG_LONG, 0, OPT_88_ENUM_NAME},
+    #endif
+    #ifdef OPT_88_CLI_LONG_TXT_C
+          {OPT_88_CLI_LONG_TXT_C, OPT_88_HAS_ARG_LONG, 0, OPT_88_ENUM_NAME},
+    #endif
+    #ifdef OPT_88_CLI_LONG_TXT_D
+          {OPT_88_CLI_LONG_TXT_D, OPT_88_HAS_ARG_LONG, 0, OPT_88_ENUM_NAME},
+    #endif
+    #ifdef OPT_88_CLI_SHORT_CODE_TXT
+          {OPT_88_CLI_SHORT_CODE_TXT, OPT_88_HAS_ARG_LONG, 0, OPT_88_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_89_ENUM_NAME
+    #ifdef OPT_89_CLI_LONG_TXT_A
+          {OPT_89_CLI_LONG_TXT_A, OPT_89_HAS_ARG_LONG, 0, OPT_89_ENUM_NAME},
+    #endif
+    #ifdef OPT_89_CLI_LONG_TXT_B
+          {OPT_89_CLI_LONG_TXT_B, OPT_89_HAS_ARG_LONG, 0, OPT_89_ENUM_NAME},
+    #endif
+    #ifdef OPT_89_CLI_LONG_TXT_C
+          {OPT_89_CLI_LONG_TXT_C, OPT_89_HAS_ARG_LONG, 0, OPT_89_ENUM_NAME},
+    #endif
+    #ifdef OPT_89_CLI_LONG_TXT_D
+          {OPT_89_CLI_LONG_TXT_D, OPT_89_HAS_ARG_LONG, 0, OPT_89_ENUM_NAME},
+    #endif
+    #ifdef OPT_89_CLI_SHORT_CODE_TXT
+          {OPT_89_CLI_SHORT_CODE_TXT, OPT_89_HAS_ARG_LONG, 0, OPT_89_ENUM_NAME},
+    #endif
+#endif
+
+#ifdef OPT_90_ENUM_NAME
+    #ifdef OPT_90_CLI_LONG_TXT_A
+          {OPT_90_CLI_LONG_TXT_A, OPT_90_HAS_ARG_LONG, 0, OPT_90_ENUM_NAME},
+    #endif
+    #ifdef OPT_90_CLI_LONG_TXT_B
+          {OPT_90_CLI_LONG_TXT_B, OPT_90_HAS_ARG_LONG, 0, OPT_90_ENUM_NAME},
+    #endif
+    #ifdef OPT_90_CLI_LONG_TXT_C
+          {OPT_90_CLI_LONG_TXT_C, OPT_90_HAS_ARG_LONG, 0, OPT_90_ENUM_NAME},
+    #endif
+    #ifdef OPT_90_CLI_LONG_TXT_D
+          {OPT_90_CLI_LONG_TXT_D, OPT_90_HAS_ARG_LONG, 0, OPT_90_ENUM_NAME},
+    #endif
+    #ifdef OPT_90_CLI_SHORT_CODE_TXT
+          {OPT_90_CLI_SHORT_CODE_TXT, OPT_90_HAS_ARG_LONG, 0, OPT_90_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_91_ENUM_NAME
+    #ifdef OPT_91_CLI_LONG_TXT_A
+          {OPT_91_CLI_LONG_TXT_A, OPT_91_HAS_ARG_LONG, 0, OPT_91_ENUM_NAME},
+    #endif
+    #ifdef OPT_91_CLI_LONG_TXT_B
+          {OPT_91_CLI_LONG_TXT_B, OPT_91_HAS_ARG_LONG, 0, OPT_91_ENUM_NAME},
+    #endif
+    #ifdef OPT_91_CLI_LONG_TXT_C
+          {OPT_91_CLI_LONG_TXT_C, OPT_91_HAS_ARG_LONG, 0, OPT_91_ENUM_NAME},
+    #endif
+    #ifdef OPT_91_CLI_LONG_TXT_D
+          {OPT_91_CLI_LONG_TXT_D, OPT_91_HAS_ARG_LONG, 0, OPT_91_ENUM_NAME},
+    #endif
+    #ifdef OPT_91_CLI_SHORT_CODE_TXT
+          {OPT_91_CLI_SHORT_CODE_TXT, OPT_91_HAS_ARG_LONG, 0, OPT_91_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_92_ENUM_NAME
+    #ifdef OPT_92_CLI_LONG_TXT_A
+          {OPT_92_CLI_LONG_TXT_A, OPT_92_HAS_ARG_LONG, 0, OPT_92_ENUM_NAME},
+    #endif
+    #ifdef OPT_92_CLI_LONG_TXT_B
+          {OPT_92_CLI_LONG_TXT_B, OPT_92_HAS_ARG_LONG, 0, OPT_92_ENUM_NAME},
+    #endif
+    #ifdef OPT_92_CLI_LONG_TXT_C
+          {OPT_92_CLI_LONG_TXT_C, OPT_92_HAS_ARG_LONG, 0, OPT_92_ENUM_NAME},
+    #endif
+    #ifdef OPT_92_CLI_LONG_TXT_D
+          {OPT_92_CLI_LONG_TXT_D, OPT_92_HAS_ARG_LONG, 0, OPT_92_ENUM_NAME},
+    #endif
+    #ifdef OPT_92_CLI_SHORT_CODE_TXT
+          {OPT_92_CLI_SHORT_CODE_TXT, OPT_92_HAS_ARG_LONG, 0, OPT_92_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_93_ENUM_NAME
+    #ifdef OPT_93_CLI_LONG_TXT_A
+          {OPT_93_CLI_LONG_TXT_A, OPT_93_HAS_ARG_LONG, 0, OPT_93_ENUM_NAME},
+    #endif
+    #ifdef OPT_93_CLI_LONG_TXT_B
+          {OPT_93_CLI_LONG_TXT_B, OPT_93_HAS_ARG_LONG, 0, OPT_93_ENUM_NAME},
+    #endif
+    #ifdef OPT_93_CLI_LONG_TXT_C
+          {OPT_93_CLI_LONG_TXT_C, OPT_93_HAS_ARG_LONG, 0, OPT_93_ENUM_NAME},
+    #endif
+    #ifdef OPT_93_CLI_LONG_TXT_D
+          {OPT_93_CLI_LONG_TXT_D, OPT_93_HAS_ARG_LONG, 0, OPT_93_ENUM_NAME},
+    #endif
+    #ifdef OPT_93_CLI_SHORT_CODE_TXT
+          {OPT_93_CLI_SHORT_CODE_TXT, OPT_93_HAS_ARG_LONG, 0, OPT_93_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_94_ENUM_NAME
+    #ifdef OPT_94_CLI_LONG_TXT_A
+          {OPT_94_CLI_LONG_TXT_A, OPT_94_HAS_ARG_LONG, 0, OPT_94_ENUM_NAME},
+    #endif
+    #ifdef OPT_94_CLI_LONG_TXT_B
+          {OPT_94_CLI_LONG_TXT_B, OPT_94_HAS_ARG_LONG, 0, OPT_94_ENUM_NAME},
+    #endif
+    #ifdef OPT_94_CLI_LONG_TXT_C
+          {OPT_94_CLI_LONG_TXT_C, OPT_94_HAS_ARG_LONG, 0, OPT_94_ENUM_NAME},
+    #endif
+    #ifdef OPT_94_CLI_LONG_TXT_D
+          {OPT_94_CLI_LONG_TXT_D, OPT_94_HAS_ARG_LONG, 0, OPT_94_ENUM_NAME},
+    #endif
+    #ifdef OPT_94_CLI_SHORT_CODE_TXT
+          {OPT_94_CLI_SHORT_CODE_TXT, OPT_94_HAS_ARG_LONG, 0, OPT_94_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_95_ENUM_NAME
+    #ifdef OPT_95_CLI_LONG_TXT_A
+          {OPT_95_CLI_LONG_TXT_A, OPT_95_HAS_ARG_LONG, 0, OPT_95_ENUM_NAME},
+    #endif
+    #ifdef OPT_95_CLI_LONG_TXT_B
+          {OPT_95_CLI_LONG_TXT_B, OPT_95_HAS_ARG_LONG, 0, OPT_95_ENUM_NAME},
+    #endif
+    #ifdef OPT_95_CLI_LONG_TXT_C
+          {OPT_95_CLI_LONG_TXT_C, OPT_95_HAS_ARG_LONG, 0, OPT_95_ENUM_NAME},
+    #endif
+    #ifdef OPT_95_CLI_LONG_TXT_D
+          {OPT_95_CLI_LONG_TXT_D, OPT_95_HAS_ARG_LONG, 0, OPT_95_ENUM_NAME},
+    #endif
+    #ifdef OPT_95_CLI_SHORT_CODE_TXT
+          {OPT_95_CLI_SHORT_CODE_TXT, OPT_95_HAS_ARG_LONG, 0, OPT_95_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_96_ENUM_NAME
+    #ifdef OPT_96_CLI_LONG_TXT_A
+          {OPT_96_CLI_LONG_TXT_A, OPT_96_HAS_ARG_LONG, 0, OPT_96_ENUM_NAME},
+    #endif
+    #ifdef OPT_96_CLI_LONG_TXT_B
+          {OPT_96_CLI_LONG_TXT_B, OPT_96_HAS_ARG_LONG, 0, OPT_96_ENUM_NAME},
+    #endif
+    #ifdef OPT_96_CLI_LONG_TXT_C
+          {OPT_96_CLI_LONG_TXT_C, OPT_96_HAS_ARG_LONG, 0, OPT_96_ENUM_NAME},
+    #endif
+    #ifdef OPT_96_CLI_LONG_TXT_D
+          {OPT_96_CLI_LONG_TXT_D, OPT_96_HAS_ARG_LONG, 0, OPT_96_ENUM_NAME},
+    #endif
+    #ifdef OPT_96_CLI_SHORT_CODE_TXT
+          {OPT_96_CLI_SHORT_CODE_TXT, OPT_96_HAS_ARG_LONG, 0, OPT_96_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_97_ENUM_NAME
+    #ifdef OPT_97_CLI_LONG_TXT_A
+          {OPT_97_CLI_LONG_TXT_A, OPT_97_HAS_ARG_LONG, 0, OPT_97_ENUM_NAME},
+    #endif
+    #ifdef OPT_97_CLI_LONG_TXT_B
+          {OPT_97_CLI_LONG_TXT_B, OPT_97_HAS_ARG_LONG, 0, OPT_97_ENUM_NAME},
+    #endif
+    #ifdef OPT_97_CLI_LONG_TXT_C
+          {OPT_97_CLI_LONG_TXT_C, OPT_97_HAS_ARG_LONG, 0, OPT_97_ENUM_NAME},
+    #endif
+    #ifdef OPT_97_CLI_LONG_TXT_D
+          {OPT_97_CLI_LONG_TXT_D, OPT_97_HAS_ARG_LONG, 0, OPT_97_ENUM_NAME},
+    #endif
+    #ifdef OPT_97_CLI_SHORT_CODE_TXT
+          {OPT_97_CLI_SHORT_CODE_TXT, OPT_97_HAS_ARG_LONG, 0, OPT_97_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_98_ENUM_NAME
+    #ifdef OPT_98_CLI_LONG_TXT_A
+          {OPT_98_CLI_LONG_TXT_A, OPT_98_HAS_ARG_LONG, 0, OPT_98_ENUM_NAME},
+    #endif
+    #ifdef OPT_98_CLI_LONG_TXT_B
+          {OPT_98_CLI_LONG_TXT_B, OPT_98_HAS_ARG_LONG, 0, OPT_98_ENUM_NAME},
+    #endif
+    #ifdef OPT_98_CLI_LONG_TXT_C
+          {OPT_98_CLI_LONG_TXT_C, OPT_98_HAS_ARG_LONG, 0, OPT_98_ENUM_NAME},
+    #endif
+    #ifdef OPT_98_CLI_LONG_TXT_D
+          {OPT_98_CLI_LONG_TXT_D, OPT_98_HAS_ARG_LONG, 0, OPT_98_ENUM_NAME},
+    #endif
+    #ifdef OPT_98_CLI_SHORT_CODE_TXT
+          {OPT_98_CLI_SHORT_CODE_TXT, OPT_98_HAS_ARG_LONG, 0, OPT_98_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_99_ENUM_NAME
+    #ifdef OPT_99_CLI_LONG_TXT_A
+          {OPT_99_CLI_LONG_TXT_A, OPT_99_HAS_ARG_LONG, 0, OPT_99_ENUM_NAME},
+    #endif
+    #ifdef OPT_99_CLI_LONG_TXT_B
+          {OPT_99_CLI_LONG_TXT_B, OPT_99_HAS_ARG_LONG, 0, OPT_99_ENUM_NAME},
+    #endif
+    #ifdef OPT_99_CLI_LONG_TXT_C
+          {OPT_99_CLI_LONG_TXT_C, OPT_99_HAS_ARG_LONG, 0, OPT_99_ENUM_NAME},
+    #endif
+    #ifdef OPT_99_CLI_LONG_TXT_D
+          {OPT_99_CLI_LONG_TXT_D, OPT_99_HAS_ARG_LONG, 0, OPT_99_ENUM_NAME},
+    #endif
+    #ifdef OPT_99_CLI_SHORT_CODE_TXT
+          {OPT_99_CLI_SHORT_CODE_TXT, OPT_99_HAS_ARG_LONG, 0, OPT_99_ENUM_NAME},
+    #endif
+#endif
+
+#ifdef OPT_100_ENUM_NAME
+    #ifdef OPT_100_CLI_LONG_TXT_A
+          {OPT_100_CLI_LONG_TXT_A, OPT_100_HAS_ARG_LONG, 0, OPT_100_ENUM_NAME},
+    #endif
+    #ifdef OPT_100_CLI_LONG_TXT_B
+          {OPT_100_CLI_LONG_TXT_B, OPT_100_HAS_ARG_LONG, 0, OPT_100_ENUM_NAME},
+    #endif
+    #ifdef OPT_100_CLI_LONG_TXT_C
+          {OPT_100_CLI_LONG_TXT_C, OPT_100_HAS_ARG_LONG, 0, OPT_100_ENUM_NAME},
+    #endif
+    #ifdef OPT_100_CLI_LONG_TXT_D
+          {OPT_100_CLI_LONG_TXT_D, OPT_100_HAS_ARG_LONG, 0, OPT_100_ENUM_NAME},
+    #endif
+    #ifdef OPT_100_CLI_SHORT_CODE_TXT
+          {OPT_100_CLI_SHORT_CODE_TXT, OPT_100_HAS_ARG_LONG, 0, OPT_100_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_101_ENUM_NAME
+    #ifdef OPT_101_CLI_LONG_TXT_A
+          {OPT_101_CLI_LONG_TXT_A, OPT_101_HAS_ARG_LONG, 0, OPT_101_ENUM_NAME},
+    #endif
+    #ifdef OPT_101_CLI_LONG_TXT_B
+          {OPT_101_CLI_LONG_TXT_B, OPT_101_HAS_ARG_LONG, 0, OPT_101_ENUM_NAME},
+    #endif
+    #ifdef OPT_101_CLI_LONG_TXT_C
+          {OPT_101_CLI_LONG_TXT_C, OPT_101_HAS_ARG_LONG, 0, OPT_101_ENUM_NAME},
+    #endif
+    #ifdef OPT_101_CLI_LONG_TXT_D
+          {OPT_101_CLI_LONG_TXT_D, OPT_101_HAS_ARG_LONG, 0, OPT_101_ENUM_NAME},
+    #endif
+    #ifdef OPT_101_CLI_SHORT_CODE_TXT
+          {OPT_101_CLI_SHORT_CODE_TXT, OPT_101_HAS_ARG_LONG, 0, OPT_101_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_102_ENUM_NAME
+    #ifdef OPT_102_CLI_LONG_TXT_A
+          {OPT_102_CLI_LONG_TXT_A, OPT_102_HAS_ARG_LONG, 0, OPT_102_ENUM_NAME},
+    #endif
+    #ifdef OPT_102_CLI_LONG_TXT_B
+          {OPT_102_CLI_LONG_TXT_B, OPT_102_HAS_ARG_LONG, 0, OPT_102_ENUM_NAME},
+    #endif
+    #ifdef OPT_102_CLI_LONG_TXT_C
+          {OPT_102_CLI_LONG_TXT_C, OPT_102_HAS_ARG_LONG, 0, OPT_102_ENUM_NAME},
+    #endif
+    #ifdef OPT_102_CLI_LONG_TXT_D
+          {OPT_102_CLI_LONG_TXT_D, OPT_102_HAS_ARG_LONG, 0, OPT_102_ENUM_NAME},
+    #endif
+    #ifdef OPT_102_CLI_SHORT_CODE_TXT
+          {OPT_102_CLI_SHORT_CODE_TXT, OPT_102_HAS_ARG_LONG, 0, OPT_102_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_103_ENUM_NAME
+    #ifdef OPT_103_CLI_LONG_TXT_A
+          {OPT_103_CLI_LONG_TXT_A, OPT_103_HAS_ARG_LONG, 0, OPT_103_ENUM_NAME},
+    #endif
+    #ifdef OPT_103_CLI_LONG_TXT_B
+          {OPT_103_CLI_LONG_TXT_B, OPT_103_HAS_ARG_LONG, 0, OPT_103_ENUM_NAME},
+    #endif
+    #ifdef OPT_103_CLI_LONG_TXT_C
+          {OPT_103_CLI_LONG_TXT_C, OPT_103_HAS_ARG_LONG, 0, OPT_103_ENUM_NAME},
+    #endif
+    #ifdef OPT_103_CLI_LONG_TXT_D
+          {OPT_103_CLI_LONG_TXT_D, OPT_103_HAS_ARG_LONG, 0, OPT_103_ENUM_NAME},
+    #endif
+    #ifdef OPT_103_CLI_SHORT_CODE_TXT
+          {OPT_103_CLI_SHORT_CODE_TXT, OPT_103_HAS_ARG_LONG, 0, OPT_103_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_104_ENUM_NAME
+    #ifdef OPT_104_CLI_LONG_TXT_A
+          {OPT_104_CLI_LONG_TXT_A, OPT_104_HAS_ARG_LONG, 0, OPT_104_ENUM_NAME},
+    #endif
+    #ifdef OPT_104_CLI_LONG_TXT_B
+          {OPT_104_CLI_LONG_TXT_B, OPT_104_HAS_ARG_LONG, 0, OPT_104_ENUM_NAME},
+    #endif
+    #ifdef OPT_104_CLI_LONG_TXT_C
+          {OPT_104_CLI_LONG_TXT_C, OPT_104_HAS_ARG_LONG, 0, OPT_104_ENUM_NAME},
+    #endif
+    #ifdef OPT_104_CLI_LONG_TXT_D
+          {OPT_104_CLI_LONG_TXT_D, OPT_104_HAS_ARG_LONG, 0, OPT_104_ENUM_NAME},
+    #endif
+    #ifdef OPT_104_CLI_SHORT_CODE_TXT
+          {OPT_104_CLI_SHORT_CODE_TXT, OPT_104_HAS_ARG_LONG, 0, OPT_104_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_105_ENUM_NAME
+    #ifdef OPT_105_CLI_LONG_TXT_A
+          {OPT_105_CLI_LONG_TXT_A, OPT_105_HAS_ARG_LONG, 0, OPT_105_ENUM_NAME},
+    #endif
+    #ifdef OPT_105_CLI_LONG_TXT_B
+          {OPT_105_CLI_LONG_TXT_B, OPT_105_HAS_ARG_LONG, 0, OPT_105_ENUM_NAME},
+    #endif
+    #ifdef OPT_105_CLI_LONG_TXT_C
+          {OPT_105_CLI_LONG_TXT_C, OPT_105_HAS_ARG_LONG, 0, OPT_105_ENUM_NAME},
+    #endif
+    #ifdef OPT_105_CLI_LONG_TXT_D
+          {OPT_105_CLI_LONG_TXT_D, OPT_105_HAS_ARG_LONG, 0, OPT_105_ENUM_NAME},
+    #endif
+    #ifdef OPT_105_CLI_SHORT_CODE_TXT
+          {OPT_105_CLI_SHORT_CODE_TXT, OPT_105_HAS_ARG_LONG, 0, OPT_105_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_106_ENUM_NAME
+    #ifdef OPT_106_CLI_LONG_TXT_A
+          {OPT_106_CLI_LONG_TXT_A, OPT_106_HAS_ARG_LONG, 0, OPT_106_ENUM_NAME},
+    #endif
+    #ifdef OPT_106_CLI_LONG_TXT_B
+          {OPT_106_CLI_LONG_TXT_B, OPT_106_HAS_ARG_LONG, 0, OPT_106_ENUM_NAME},
+    #endif
+    #ifdef OPT_106_CLI_LONG_TXT_C
+          {OPT_106_CLI_LONG_TXT_C, OPT_106_HAS_ARG_LONG, 0, OPT_106_ENUM_NAME},
+    #endif
+    #ifdef OPT_106_CLI_LONG_TXT_D
+          {OPT_106_CLI_LONG_TXT_D, OPT_106_HAS_ARG_LONG, 0, OPT_106_ENUM_NAME},
+    #endif
+    #ifdef OPT_106_CLI_SHORT_CODE_TXT
+          {OPT_106_CLI_SHORT_CODE_TXT, OPT_106_HAS_ARG_LONG, 0, OPT_106_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_107_ENUM_NAME
+    #ifdef OPT_107_CLI_LONG_TXT_A
+          {OPT_107_CLI_LONG_TXT_A, OPT_107_HAS_ARG_LONG, 0, OPT_107_ENUM_NAME},
+    #endif
+    #ifdef OPT_107_CLI_LONG_TXT_B
+          {OPT_107_CLI_LONG_TXT_B, OPT_107_HAS_ARG_LONG, 0, OPT_107_ENUM_NAME},
+    #endif
+    #ifdef OPT_107_CLI_LONG_TXT_C
+          {OPT_107_CLI_LONG_TXT_C, OPT_107_HAS_ARG_LONG, 0, OPT_107_ENUM_NAME},
+    #endif
+    #ifdef OPT_107_CLI_LONG_TXT_D
+          {OPT_107_CLI_LONG_TXT_D, OPT_107_HAS_ARG_LONG, 0, OPT_107_ENUM_NAME},
+    #endif
+    #ifdef OPT_107_CLI_SHORT_CODE_TXT
+          {OPT_107_CLI_SHORT_CODE_TXT, OPT_107_HAS_ARG_LONG, 0, OPT_107_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_108_ENUM_NAME
+    #ifdef OPT_108_CLI_LONG_TXT_A
+          {OPT_108_CLI_LONG_TXT_A, OPT_108_HAS_ARG_LONG, 0, OPT_108_ENUM_NAME},
+    #endif
+    #ifdef OPT_108_CLI_LONG_TXT_B
+          {OPT_108_CLI_LONG_TXT_B, OPT_108_HAS_ARG_LONG, 0, OPT_108_ENUM_NAME},
+    #endif
+    #ifdef OPT_108_CLI_LONG_TXT_C
+          {OPT_108_CLI_LONG_TXT_C, OPT_108_HAS_ARG_LONG, 0, OPT_108_ENUM_NAME},
+    #endif
+    #ifdef OPT_108_CLI_LONG_TXT_D
+          {OPT_108_CLI_LONG_TXT_D, OPT_108_HAS_ARG_LONG, 0, OPT_108_ENUM_NAME},
+    #endif
+    #ifdef OPT_108_CLI_SHORT_CODE_TXT
+          {OPT_108_CLI_SHORT_CODE_TXT, OPT_108_HAS_ARG_LONG, 0, OPT_108_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_109_ENUM_NAME
+    #ifdef OPT_109_CLI_LONG_TXT_A
+          {OPT_109_CLI_LONG_TXT_A, OPT_109_HAS_ARG_LONG, 0, OPT_109_ENUM_NAME},
+    #endif
+    #ifdef OPT_109_CLI_LONG_TXT_B
+          {OPT_109_CLI_LONG_TXT_B, OPT_109_HAS_ARG_LONG, 0, OPT_109_ENUM_NAME},
+    #endif
+    #ifdef OPT_109_CLI_LONG_TXT_C
+          {OPT_109_CLI_LONG_TXT_C, OPT_109_HAS_ARG_LONG, 0, OPT_109_ENUM_NAME},
+    #endif
+    #ifdef OPT_109_CLI_LONG_TXT_D
+          {OPT_109_CLI_LONG_TXT_D, OPT_109_HAS_ARG_LONG, 0, OPT_109_ENUM_NAME},
+    #endif
+    #ifdef OPT_109_CLI_SHORT_CODE_TXT
+          {OPT_109_CLI_SHORT_CODE_TXT, OPT_109_HAS_ARG_LONG, 0, OPT_109_ENUM_NAME},
+    #endif
+#endif
+
+#ifdef OPT_110_ENUM_NAME
+    #ifdef OPT_110_CLI_LONG_TXT_A
+          {OPT_110_CLI_LONG_TXT_A, OPT_110_HAS_ARG_LONG, 0, OPT_110_ENUM_NAME},
+    #endif
+    #ifdef OPT_110_CLI_LONG_TXT_B
+          {OPT_110_CLI_LONG_TXT_B, OPT_110_HAS_ARG_LONG, 0, OPT_110_ENUM_NAME},
+    #endif
+    #ifdef OPT_110_CLI_LONG_TXT_C
+          {OPT_110_CLI_LONG_TXT_C, OPT_110_HAS_ARG_LONG, 0, OPT_110_ENUM_NAME},
+    #endif
+    #ifdef OPT_110_CLI_LONG_TXT_D
+          {OPT_110_CLI_LONG_TXT_D, OPT_110_HAS_ARG_LONG, 0, OPT_110_ENUM_NAME},
+    #endif
+    #ifdef OPT_110_CLI_SHORT_CODE_TXT
+          {OPT_110_CLI_SHORT_CODE_TXT, OPT_110_HAS_ARG_LONG, 0, OPT_110_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_111_ENUM_NAME
+    #ifdef OPT_111_CLI_LONG_TXT_A
+          {OPT_111_CLI_LONG_TXT_A, OPT_111_HAS_ARG_LONG, 0, OPT_111_ENUM_NAME},
+    #endif
+    #ifdef OPT_111_CLI_LONG_TXT_B
+          {OPT_111_CLI_LONG_TXT_B, OPT_111_HAS_ARG_LONG, 0, OPT_111_ENUM_NAME},
+    #endif
+    #ifdef OPT_111_CLI_LONG_TXT_C
+          {OPT_111_CLI_LONG_TXT_C, OPT_111_HAS_ARG_LONG, 0, OPT_111_ENUM_NAME},
+    #endif
+    #ifdef OPT_111_CLI_LONG_TXT_D
+          {OPT_111_CLI_LONG_TXT_D, OPT_111_HAS_ARG_LONG, 0, OPT_111_ENUM_NAME},
+    #endif
+    #ifdef OPT_111_CLI_SHORT_CODE_TXT
+          {OPT_111_CLI_SHORT_CODE_TXT, OPT_111_HAS_ARG_LONG, 0, OPT_111_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_112_ENUM_NAME
+    #ifdef OPT_112_CLI_LONG_TXT_A
+          {OPT_112_CLI_LONG_TXT_A, OPT_112_HAS_ARG_LONG, 0, OPT_112_ENUM_NAME},
+    #endif
+    #ifdef OPT_112_CLI_LONG_TXT_B
+          {OPT_112_CLI_LONG_TXT_B, OPT_112_HAS_ARG_LONG, 0, OPT_112_ENUM_NAME},
+    #endif
+    #ifdef OPT_112_CLI_LONG_TXT_C
+          {OPT_112_CLI_LONG_TXT_C, OPT_112_HAS_ARG_LONG, 0, OPT_112_ENUM_NAME},
+    #endif
+    #ifdef OPT_112_CLI_LONG_TXT_D
+          {OPT_112_CLI_LONG_TXT_D, OPT_112_HAS_ARG_LONG, 0, OPT_112_ENUM_NAME},
+    #endif
+    #ifdef OPT_112_CLI_SHORT_CODE_TXT
+          {OPT_112_CLI_SHORT_CODE_TXT, OPT_112_HAS_ARG_LONG, 0, OPT_112_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_113_ENUM_NAME
+    #ifdef OPT_113_CLI_LONG_TXT_A
+          {OPT_113_CLI_LONG_TXT_A, OPT_113_HAS_ARG_LONG, 0, OPT_113_ENUM_NAME},
+    #endif
+    #ifdef OPT_113_CLI_LONG_TXT_B
+          {OPT_113_CLI_LONG_TXT_B, OPT_113_HAS_ARG_LONG, 0, OPT_113_ENUM_NAME},
+    #endif
+    #ifdef OPT_113_CLI_LONG_TXT_C
+          {OPT_113_CLI_LONG_TXT_C, OPT_113_HAS_ARG_LONG, 0, OPT_113_ENUM_NAME},
+    #endif
+    #ifdef OPT_113_CLI_LONG_TXT_D
+          {OPT_113_CLI_LONG_TXT_D, OPT_113_HAS_ARG_LONG, 0, OPT_113_ENUM_NAME},
+    #endif
+    #ifdef OPT_113_CLI_SHORT_CODE_TXT
+          {OPT_113_CLI_SHORT_CODE_TXT, OPT_113_HAS_ARG_LONG, 0, OPT_113_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_114_ENUM_NAME
+    #ifdef OPT_114_CLI_LONG_TXT_A
+          {OPT_114_CLI_LONG_TXT_A, OPT_114_HAS_ARG_LONG, 0, OPT_114_ENUM_NAME},
+    #endif
+    #ifdef OPT_114_CLI_LONG_TXT_B
+          {OPT_114_CLI_LONG_TXT_B, OPT_114_HAS_ARG_LONG, 0, OPT_114_ENUM_NAME},
+    #endif
+    #ifdef OPT_114_CLI_LONG_TXT_C
+          {OPT_114_CLI_LONG_TXT_C, OPT_114_HAS_ARG_LONG, 0, OPT_114_ENUM_NAME},
+    #endif
+    #ifdef OPT_114_CLI_LONG_TXT_D
+          {OPT_114_CLI_LONG_TXT_D, OPT_114_HAS_ARG_LONG, 0, OPT_114_ENUM_NAME},
+    #endif
+    #ifdef OPT_114_CLI_SHORT_CODE_TXT
+          {OPT_114_CLI_SHORT_CODE_TXT, OPT_114_HAS_ARG_LONG, 0, OPT_114_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_115_ENUM_NAME
+    #ifdef OPT_115_CLI_LONG_TXT_A
+          {OPT_115_CLI_LONG_TXT_A, OPT_115_HAS_ARG_LONG, 0, OPT_115_ENUM_NAME},
+    #endif
+    #ifdef OPT_115_CLI_LONG_TXT_B
+          {OPT_115_CLI_LONG_TXT_B, OPT_115_HAS_ARG_LONG, 0, OPT_115_ENUM_NAME},
+    #endif
+    #ifdef OPT_115_CLI_LONG_TXT_C
+          {OPT_115_CLI_LONG_TXT_C, OPT_115_HAS_ARG_LONG, 0, OPT_115_ENUM_NAME},
+    #endif
+    #ifdef OPT_115_CLI_LONG_TXT_D
+          {OPT_115_CLI_LONG_TXT_D, OPT_115_HAS_ARG_LONG, 0, OPT_115_ENUM_NAME},
+    #endif
+    #ifdef OPT_115_CLI_SHORT_CODE_TXT
+          {OPT_115_CLI_SHORT_CODE_TXT, OPT_115_HAS_ARG_LONG, 0, OPT_115_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_116_ENUM_NAME
+    #ifdef OPT_116_CLI_LONG_TXT_A
+          {OPT_116_CLI_LONG_TXT_A, OPT_116_HAS_ARG_LONG, 0, OPT_116_ENUM_NAME},
+    #endif
+    #ifdef OPT_116_CLI_LONG_TXT_B
+          {OPT_116_CLI_LONG_TXT_B, OPT_116_HAS_ARG_LONG, 0, OPT_116_ENUM_NAME},
+    #endif
+    #ifdef OPT_116_CLI_LONG_TXT_C
+          {OPT_116_CLI_LONG_TXT_C, OPT_116_HAS_ARG_LONG, 0, OPT_116_ENUM_NAME},
+    #endif
+    #ifdef OPT_116_CLI_LONG_TXT_D
+          {OPT_116_CLI_LONG_TXT_D, OPT_116_HAS_ARG_LONG, 0, OPT_116_ENUM_NAME},
+    #endif
+    #ifdef OPT_116_CLI_SHORT_CODE_TXT
+          {OPT_116_CLI_SHORT_CODE_TXT, OPT_116_HAS_ARG_LONG, 0, OPT_116_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_117_ENUM_NAME
+    #ifdef OPT_117_CLI_LONG_TXT_A
+          {OPT_117_CLI_LONG_TXT_A, OPT_117_HAS_ARG_LONG, 0, OPT_117_ENUM_NAME},
+    #endif
+    #ifdef OPT_117_CLI_LONG_TXT_B
+          {OPT_117_CLI_LONG_TXT_B, OPT_117_HAS_ARG_LONG, 0, OPT_117_ENUM_NAME},
+    #endif
+    #ifdef OPT_117_CLI_LONG_TXT_C
+          {OPT_117_CLI_LONG_TXT_C, OPT_117_HAS_ARG_LONG, 0, OPT_117_ENUM_NAME},
+    #endif
+    #ifdef OPT_117_CLI_LONG_TXT_D
+          {OPT_117_CLI_LONG_TXT_D, OPT_117_HAS_ARG_LONG, 0, OPT_117_ENUM_NAME},
+    #endif
+    #ifdef OPT_117_CLI_SHORT_CODE_TXT
+          {OPT_117_CLI_SHORT_CODE_TXT, OPT_117_HAS_ARG_LONG, 0, OPT_117_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_118_ENUM_NAME
+    #ifdef OPT_118_CLI_LONG_TXT_A
+          {OPT_118_CLI_LONG_TXT_A, OPT_118_HAS_ARG_LONG, 0, OPT_118_ENUM_NAME},
+    #endif
+    #ifdef OPT_118_CLI_LONG_TXT_B
+          {OPT_118_CLI_LONG_TXT_B, OPT_118_HAS_ARG_LONG, 0, OPT_118_ENUM_NAME},
+    #endif
+    #ifdef OPT_118_CLI_LONG_TXT_C
+          {OPT_118_CLI_LONG_TXT_C, OPT_118_HAS_ARG_LONG, 0, OPT_118_ENUM_NAME},
+    #endif
+    #ifdef OPT_118_CLI_LONG_TXT_D
+          {OPT_118_CLI_LONG_TXT_D, OPT_118_HAS_ARG_LONG, 0, OPT_118_ENUM_NAME},
+    #endif
+    #ifdef OPT_118_CLI_SHORT_CODE_TXT
+          {OPT_118_CLI_SHORT_CODE_TXT, OPT_118_HAS_ARG_LONG, 0, OPT_118_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_119_ENUM_NAME
+    #ifdef OPT_119_CLI_LONG_TXT_A
+          {OPT_119_CLI_LONG_TXT_A, OPT_119_HAS_ARG_LONG, 0, OPT_119_ENUM_NAME},
+    #endif
+    #ifdef OPT_119_CLI_LONG_TXT_B
+          {OPT_119_CLI_LONG_TXT_B, OPT_119_HAS_ARG_LONG, 0, OPT_119_ENUM_NAME},
+    #endif
+    #ifdef OPT_119_CLI_LONG_TXT_C
+          {OPT_119_CLI_LONG_TXT_C, OPT_119_HAS_ARG_LONG, 0, OPT_119_ENUM_NAME},
+    #endif
+    #ifdef OPT_119_CLI_LONG_TXT_D
+          {OPT_119_CLI_LONG_TXT_D, OPT_119_HAS_ARG_LONG, 0, OPT_119_ENUM_NAME},
+    #endif
+    #ifdef OPT_119_CLI_SHORT_CODE_TXT
+          {OPT_119_CLI_SHORT_CODE_TXT, OPT_119_HAS_ARG_LONG, 0, OPT_119_ENUM_NAME},
+    #endif
+#endif
+
+#ifdef OPT_120_ENUM_NAME
+    #ifdef OPT_120_CLI_LONG_TXT_A
+          {OPT_120_CLI_LONG_TXT_A, OPT_120_HAS_ARG_LONG, 0, OPT_120_ENUM_NAME},
+    #endif
+    #ifdef OPT_120_CLI_LONG_TXT_B
+          {OPT_120_CLI_LONG_TXT_B, OPT_120_HAS_ARG_LONG, 0, OPT_120_ENUM_NAME},
+    #endif
+    #ifdef OPT_120_CLI_LONG_TXT_C
+          {OPT_120_CLI_LONG_TXT_C, OPT_120_HAS_ARG_LONG, 0, OPT_120_ENUM_NAME},
+    #endif
+    #ifdef OPT_120_CLI_LONG_TXT_D
+          {OPT_120_CLI_LONG_TXT_D, OPT_120_HAS_ARG_LONG, 0, OPT_120_ENUM_NAME},
+    #endif
+    #ifdef OPT_120_CLI_SHORT_CODE_TXT
+          {OPT_120_CLI_SHORT_CODE_TXT, OPT_120_HAS_ARG_LONG, 0, OPT_120_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_121_ENUM_NAME
+    #ifdef OPT_121_CLI_LONG_TXT_A
+          {OPT_121_CLI_LONG_TXT_A, OPT_121_HAS_ARG_LONG, 0, OPT_121_ENUM_NAME},
+    #endif
+    #ifdef OPT_121_CLI_LONG_TXT_B
+          {OPT_121_CLI_LONG_TXT_B, OPT_121_HAS_ARG_LONG, 0, OPT_121_ENUM_NAME},
+    #endif
+    #ifdef OPT_121_CLI_LONG_TXT_C
+          {OPT_121_CLI_LONG_TXT_C, OPT_121_HAS_ARG_LONG, 0, OPT_121_ENUM_NAME},
+    #endif
+    #ifdef OPT_121_CLI_LONG_TXT_D
+          {OPT_121_CLI_LONG_TXT_D, OPT_121_HAS_ARG_LONG, 0, OPT_121_ENUM_NAME},
+    #endif
+    #ifdef OPT_121_CLI_SHORT_CODE_TXT
+          {OPT_121_CLI_SHORT_CODE_TXT, OPT_121_HAS_ARG_LONG, 0, OPT_121_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_122_ENUM_NAME
+    #ifdef OPT_122_CLI_LONG_TXT_A
+          {OPT_122_CLI_LONG_TXT_A, OPT_122_HAS_ARG_LONG, 0, OPT_122_ENUM_NAME},
+    #endif
+    #ifdef OPT_122_CLI_LONG_TXT_B
+          {OPT_122_CLI_LONG_TXT_B, OPT_122_HAS_ARG_LONG, 0, OPT_122_ENUM_NAME},
+    #endif
+    #ifdef OPT_122_CLI_LONG_TXT_C
+          {OPT_122_CLI_LONG_TXT_C, OPT_122_HAS_ARG_LONG, 0, OPT_122_ENUM_NAME},
+    #endif
+    #ifdef OPT_122_CLI_LONG_TXT_D
+          {OPT_122_CLI_LONG_TXT_D, OPT_122_HAS_ARG_LONG, 0, OPT_122_ENUM_NAME},
+    #endif
+    #ifdef OPT_122_CLI_SHORT_CODE_TXT
+          {OPT_122_CLI_SHORT_CODE_TXT, OPT_122_HAS_ARG_LONG, 0, OPT_122_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_123_ENUM_NAME
+    #ifdef OPT_123_CLI_LONG_TXT_A
+          {OPT_123_CLI_LONG_TXT_A, OPT_123_HAS_ARG_LONG, 0, OPT_123_ENUM_NAME},
+    #endif
+    #ifdef OPT_123_CLI_LONG_TXT_B
+          {OPT_123_CLI_LONG_TXT_B, OPT_123_HAS_ARG_LONG, 0, OPT_123_ENUM_NAME},
+    #endif
+    #ifdef OPT_123_CLI_LONG_TXT_C
+          {OPT_123_CLI_LONG_TXT_C, OPT_123_HAS_ARG_LONG, 0, OPT_123_ENUM_NAME},
+    #endif
+    #ifdef OPT_123_CLI_LONG_TXT_D
+          {OPT_123_CLI_LONG_TXT_D, OPT_123_HAS_ARG_LONG, 0, OPT_123_ENUM_NAME},
+    #endif
+    #ifdef OPT_123_CLI_SHORT_CODE_TXT
+          {OPT_123_CLI_SHORT_CODE_TXT, OPT_123_HAS_ARG_LONG, 0, OPT_123_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_124_ENUM_NAME
+    #ifdef OPT_124_CLI_LONG_TXT_A
+          {OPT_124_CLI_LONG_TXT_A, OPT_124_HAS_ARG_LONG, 0, OPT_124_ENUM_NAME},
+    #endif
+    #ifdef OPT_124_CLI_LONG_TXT_B
+          {OPT_124_CLI_LONG_TXT_B, OPT_124_HAS_ARG_LONG, 0, OPT_124_ENUM_NAME},
+    #endif
+    #ifdef OPT_124_CLI_LONG_TXT_C
+          {OPT_124_CLI_LONG_TXT_C, OPT_124_HAS_ARG_LONG, 0, OPT_124_ENUM_NAME},
+    #endif
+    #ifdef OPT_124_CLI_LONG_TXT_D
+          {OPT_124_CLI_LONG_TXT_D, OPT_124_HAS_ARG_LONG, 0, OPT_124_ENUM_NAME},
+    #endif
+    #ifdef OPT_124_CLI_SHORT_CODE_TXT
+          {OPT_124_CLI_SHORT_CODE_TXT, OPT_124_HAS_ARG_LONG, 0, OPT_124_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_125_ENUM_NAME
+    #ifdef OPT_125_CLI_LONG_TXT_A
+          {OPT_125_CLI_LONG_TXT_A, OPT_125_HAS_ARG_LONG, 0, OPT_125_ENUM_NAME},
+    #endif
+    #ifdef OPT_125_CLI_LONG_TXT_B
+          {OPT_125_CLI_LONG_TXT_B, OPT_125_HAS_ARG_LONG, 0, OPT_125_ENUM_NAME},
+    #endif
+    #ifdef OPT_125_CLI_LONG_TXT_C
+          {OPT_125_CLI_LONG_TXT_C, OPT_125_HAS_ARG_LONG, 0, OPT_125_ENUM_NAME},
+    #endif
+    #ifdef OPT_125_CLI_LONG_TXT_D
+          {OPT_125_CLI_LONG_TXT_D, OPT_125_HAS_ARG_LONG, 0, OPT_125_ENUM_NAME},
+    #endif
+    #ifdef OPT_125_CLI_SHORT_CODE_TXT
+          {OPT_125_CLI_SHORT_CODE_TXT, OPT_125_HAS_ARG_LONG, 0, OPT_125_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_126_ENUM_NAME
+    #ifdef OPT_126_CLI_LONG_TXT_A
+          {OPT_126_CLI_LONG_TXT_A, OPT_126_HAS_ARG_LONG, 0, OPT_126_ENUM_NAME},
+    #endif
+    #ifdef OPT_126_CLI_LONG_TXT_B
+          {OPT_126_CLI_LONG_TXT_B, OPT_126_HAS_ARG_LONG, 0, OPT_126_ENUM_NAME},
+    #endif
+    #ifdef OPT_126_CLI_LONG_TXT_C
+          {OPT_126_CLI_LONG_TXT_C, OPT_126_HAS_ARG_LONG, 0, OPT_126_ENUM_NAME},
+    #endif
+    #ifdef OPT_126_CLI_LONG_TXT_D
+          {OPT_126_CLI_LONG_TXT_D, OPT_126_HAS_ARG_LONG, 0, OPT_126_ENUM_NAME},
+    #endif
+    #ifdef OPT_126_CLI_SHORT_CODE_TXT
+          {OPT_126_CLI_SHORT_CODE_TXT, OPT_126_HAS_ARG_LONG, 0, OPT_126_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_127_ENUM_NAME
+    #ifdef OPT_127_CLI_LONG_TXT_A
+          {OPT_127_CLI_LONG_TXT_A, OPT_127_HAS_ARG_LONG, 0, OPT_127_ENUM_NAME},
+    #endif
+    #ifdef OPT_127_CLI_LONG_TXT_B
+          {OPT_127_CLI_LONG_TXT_B, OPT_127_HAS_ARG_LONG, 0, OPT_127_ENUM_NAME},
+    #endif
+    #ifdef OPT_127_CLI_LONG_TXT_C
+          {OPT_127_CLI_LONG_TXT_C, OPT_127_HAS_ARG_LONG, 0, OPT_127_ENUM_NAME},
+    #endif
+    #ifdef OPT_127_CLI_LONG_TXT_D
+          {OPT_127_CLI_LONG_TXT_D, OPT_127_HAS_ARG_LONG, 0, OPT_127_ENUM_NAME},
+    #endif
+    #ifdef OPT_127_CLI_SHORT_CODE_TXT
+          {OPT_127_CLI_SHORT_CODE_TXT, OPT_127_HAS_ARG_LONG, 0, OPT_127_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_128_ENUM_NAME
+    #ifdef OPT_128_CLI_LONG_TXT_A
+          {OPT_128_CLI_LONG_TXT_A, OPT_128_HAS_ARG_LONG, 0, OPT_128_ENUM_NAME},
+    #endif
+    #ifdef OPT_128_CLI_LONG_TXT_B
+          {OPT_128_CLI_LONG_TXT_B, OPT_128_HAS_ARG_LONG, 0, OPT_128_ENUM_NAME},
+    #endif
+    #ifdef OPT_128_CLI_LONG_TXT_C
+          {OPT_128_CLI_LONG_TXT_C, OPT_128_HAS_ARG_LONG, 0, OPT_128_ENUM_NAME},
+    #endif
+    #ifdef OPT_128_CLI_LONG_TXT_D
+          {OPT_128_CLI_LONG_TXT_D, OPT_128_HAS_ARG_LONG, 0, OPT_128_ENUM_NAME},
+    #endif
+    #ifdef OPT_128_CLI_SHORT_CODE_TXT
+          {OPT_128_CLI_SHORT_CODE_TXT, OPT_128_HAS_ARG_LONG, 0, OPT_128_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_129_ENUM_NAME
+    #ifdef OPT_129_CLI_LONG_TXT_A
+          {OPT_129_CLI_LONG_TXT_A, OPT_129_HAS_ARG_LONG, 0, OPT_129_ENUM_NAME},
+    #endif
+    #ifdef OPT_129_CLI_LONG_TXT_B
+          {OPT_129_CLI_LONG_TXT_B, OPT_129_HAS_ARG_LONG, 0, OPT_129_ENUM_NAME},
+    #endif
+    #ifdef OPT_129_CLI_LONG_TXT_C
+          {OPT_129_CLI_LONG_TXT_C, OPT_129_HAS_ARG_LONG, 0, OPT_129_ENUM_NAME},
+    #endif
+    #ifdef OPT_129_CLI_LONG_TXT_D
+          {OPT_129_CLI_LONG_TXT_D, OPT_129_HAS_ARG_LONG, 0, OPT_129_ENUM_NAME},
+    #endif
+    #ifdef OPT_129_CLI_SHORT_CODE_TXT
+          {OPT_129_CLI_SHORT_CODE_TXT, OPT_129_HAS_ARG_LONG, 0, OPT_129_ENUM_NAME},
+    #endif
+#endif
+
+#ifdef OPT_130_ENUM_NAME
+    #ifdef OPT_130_CLI_LONG_TXT_A
+          {OPT_130_CLI_LONG_TXT_A, OPT_130_HAS_ARG_LONG, 0, OPT_130_ENUM_NAME},
+    #endif
+    #ifdef OPT_130_CLI_LONG_TXT_B
+          {OPT_130_CLI_LONG_TXT_B, OPT_130_HAS_ARG_LONG, 0, OPT_130_ENUM_NAME},
+    #endif
+    #ifdef OPT_130_CLI_LONG_TXT_C
+          {OPT_130_CLI_LONG_TXT_C, OPT_130_HAS_ARG_LONG, 0, OPT_130_ENUM_NAME},
+    #endif
+    #ifdef OPT_130_CLI_LONG_TXT_D
+          {OPT_130_CLI_LONG_TXT_D, OPT_130_HAS_ARG_LONG, 0, OPT_130_ENUM_NAME},
+    #endif
+    #ifdef OPT_130_CLI_SHORT_CODE_TXT
+          {OPT_130_CLI_SHORT_CODE_TXT, OPT_130_HAS_ARG_LONG, 0, OPT_130_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_131_ENUM_NAME
+    #ifdef OPT_131_CLI_LONG_TXT_A
+          {OPT_131_CLI_LONG_TXT_A, OPT_131_HAS_ARG_LONG, 0, OPT_131_ENUM_NAME},
+    #endif
+    #ifdef OPT_131_CLI_LONG_TXT_B
+          {OPT_131_CLI_LONG_TXT_B, OPT_131_HAS_ARG_LONG, 0, OPT_131_ENUM_NAME},
+    #endif
+    #ifdef OPT_131_CLI_LONG_TXT_C
+          {OPT_131_CLI_LONG_TXT_C, OPT_131_HAS_ARG_LONG, 0, OPT_131_ENUM_NAME},
+    #endif
+    #ifdef OPT_131_CLI_LONG_TXT_D
+          {OPT_131_CLI_LONG_TXT_D, OPT_131_HAS_ARG_LONG, 0, OPT_131_ENUM_NAME},
+    #endif
+    #ifdef OPT_131_CLI_SHORT_CODE_TXT
+          {OPT_131_CLI_SHORT_CODE_TXT, OPT_131_HAS_ARG_LONG, 0, OPT_131_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_132_ENUM_NAME
+    #ifdef OPT_132_CLI_LONG_TXT_A
+          {OPT_132_CLI_LONG_TXT_A, OPT_132_HAS_ARG_LONG, 0, OPT_132_ENUM_NAME},
+    #endif
+    #ifdef OPT_132_CLI_LONG_TXT_B
+          {OPT_132_CLI_LONG_TXT_B, OPT_132_HAS_ARG_LONG, 0, OPT_132_ENUM_NAME},
+    #endif
+    #ifdef OPT_132_CLI_LONG_TXT_C
+          {OPT_132_CLI_LONG_TXT_C, OPT_132_HAS_ARG_LONG, 0, OPT_132_ENUM_NAME},
+    #endif
+    #ifdef OPT_132_CLI_LONG_TXT_D
+          {OPT_132_CLI_LONG_TXT_D, OPT_132_HAS_ARG_LONG, 0, OPT_132_ENUM_NAME},
+    #endif
+    #ifdef OPT_132_CLI_SHORT_CODE_TXT
+          {OPT_132_CLI_SHORT_CODE_TXT, OPT_132_HAS_ARG_LONG, 0, OPT_132_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_133_ENUM_NAME
+    #ifdef OPT_133_CLI_LONG_TXT_A
+          {OPT_133_CLI_LONG_TXT_A, OPT_133_HAS_ARG_LONG, 0, OPT_133_ENUM_NAME},
+    #endif
+    #ifdef OPT_133_CLI_LONG_TXT_B
+          {OPT_133_CLI_LONG_TXT_B, OPT_133_HAS_ARG_LONG, 0, OPT_133_ENUM_NAME},
+    #endif
+    #ifdef OPT_133_CLI_LONG_TXT_C
+          {OPT_133_CLI_LONG_TXT_C, OPT_133_HAS_ARG_LONG, 0, OPT_133_ENUM_NAME},
+    #endif
+    #ifdef OPT_133_CLI_LONG_TXT_D
+          {OPT_133_CLI_LONG_TXT_D, OPT_133_HAS_ARG_LONG, 0, OPT_133_ENUM_NAME},
+    #endif
+    #ifdef OPT_133_CLI_SHORT_CODE_TXT
+          {OPT_133_CLI_SHORT_CODE_TXT, OPT_133_HAS_ARG_LONG, 0, OPT_133_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_134_ENUM_NAME
+    #ifdef OPT_134_CLI_LONG_TXT_A
+          {OPT_134_CLI_LONG_TXT_A, OPT_134_HAS_ARG_LONG, 0, OPT_134_ENUM_NAME},
+    #endif
+    #ifdef OPT_134_CLI_LONG_TXT_B
+          {OPT_134_CLI_LONG_TXT_B, OPT_134_HAS_ARG_LONG, 0, OPT_134_ENUM_NAME},
+    #endif
+    #ifdef OPT_134_CLI_LONG_TXT_C
+          {OPT_134_CLI_LONG_TXT_C, OPT_134_HAS_ARG_LONG, 0, OPT_134_ENUM_NAME},
+    #endif
+    #ifdef OPT_134_CLI_LONG_TXT_D
+          {OPT_134_CLI_LONG_TXT_D, OPT_134_HAS_ARG_LONG, 0, OPT_134_ENUM_NAME},
+    #endif
+    #ifdef OPT_134_CLI_SHORT_CODE_TXT
+          {OPT_134_CLI_SHORT_CODE_TXT, OPT_134_HAS_ARG_LONG, 0, OPT_134_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_135_ENUM_NAME
+    #ifdef OPT_135_CLI_LONG_TXT_A
+          {OPT_135_CLI_LONG_TXT_A, OPT_135_HAS_ARG_LONG, 0, OPT_135_ENUM_NAME},
+    #endif
+    #ifdef OPT_135_CLI_LONG_TXT_B
+          {OPT_135_CLI_LONG_TXT_B, OPT_135_HAS_ARG_LONG, 0, OPT_135_ENUM_NAME},
+    #endif
+    #ifdef OPT_135_CLI_LONG_TXT_C
+          {OPT_135_CLI_LONG_TXT_C, OPT_135_HAS_ARG_LONG, 0, OPT_135_ENUM_NAME},
+    #endif
+    #ifdef OPT_135_CLI_LONG_TXT_D
+          {OPT_135_CLI_LONG_TXT_D, OPT_135_HAS_ARG_LONG, 0, OPT_135_ENUM_NAME},
+    #endif
+    #ifdef OPT_135_CLI_SHORT_CODE_TXT
+          {OPT_135_CLI_SHORT_CODE_TXT, OPT_135_HAS_ARG_LONG, 0, OPT_135_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_136_ENUM_NAME
+    #ifdef OPT_136_CLI_LONG_TXT_A
+          {OPT_136_CLI_LONG_TXT_A, OPT_136_HAS_ARG_LONG, 0, OPT_136_ENUM_NAME},
+    #endif
+    #ifdef OPT_136_CLI_LONG_TXT_B
+          {OPT_136_CLI_LONG_TXT_B, OPT_136_HAS_ARG_LONG, 0, OPT_136_ENUM_NAME},
+    #endif
+    #ifdef OPT_136_CLI_LONG_TXT_C
+          {OPT_136_CLI_LONG_TXT_C, OPT_136_HAS_ARG_LONG, 0, OPT_136_ENUM_NAME},
+    #endif
+    #ifdef OPT_136_CLI_LONG_TXT_D
+          {OPT_136_CLI_LONG_TXT_D, OPT_136_HAS_ARG_LONG, 0, OPT_136_ENUM_NAME},
+    #endif
+    #ifdef OPT_136_CLI_SHORT_CODE_TXT
+          {OPT_136_CLI_SHORT_CODE_TXT, OPT_136_HAS_ARG_LONG, 0, OPT_136_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_137_ENUM_NAME
+    #ifdef OPT_137_CLI_LONG_TXT_A
+          {OPT_137_CLI_LONG_TXT_A, OPT_137_HAS_ARG_LONG, 0, OPT_137_ENUM_NAME},
+    #endif
+    #ifdef OPT_137_CLI_LONG_TXT_B
+          {OPT_137_CLI_LONG_TXT_B, OPT_137_HAS_ARG_LONG, 0, OPT_137_ENUM_NAME},
+    #endif
+    #ifdef OPT_137_CLI_LONG_TXT_C
+          {OPT_137_CLI_LONG_TXT_C, OPT_137_HAS_ARG_LONG, 0, OPT_137_ENUM_NAME},
+    #endif
+    #ifdef OPT_137_CLI_LONG_TXT_D
+          {OPT_137_CLI_LONG_TXT_D, OPT_137_HAS_ARG_LONG, 0, OPT_137_ENUM_NAME},
+    #endif
+    #ifdef OPT_137_CLI_SHORT_CODE_TXT
+          {OPT_137_CLI_SHORT_CODE_TXT, OPT_137_HAS_ARG_LONG, 0, OPT_137_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_138_ENUM_NAME
+    #ifdef OPT_138_CLI_LONG_TXT_A
+          {OPT_138_CLI_LONG_TXT_A, OPT_138_HAS_ARG_LONG, 0, OPT_138_ENUM_NAME},
+    #endif
+    #ifdef OPT_138_CLI_LONG_TXT_B
+          {OPT_138_CLI_LONG_TXT_B, OPT_138_HAS_ARG_LONG, 0, OPT_138_ENUM_NAME},
+    #endif
+    #ifdef OPT_138_CLI_LONG_TXT_C
+          {OPT_138_CLI_LONG_TXT_C, OPT_138_HAS_ARG_LONG, 0, OPT_138_ENUM_NAME},
+    #endif
+    #ifdef OPT_138_CLI_LONG_TXT_D
+          {OPT_138_CLI_LONG_TXT_D, OPT_138_HAS_ARG_LONG, 0, OPT_138_ENUM_NAME},
+    #endif
+    #ifdef OPT_138_CLI_SHORT_CODE_TXT
+          {OPT_138_CLI_SHORT_CODE_TXT, OPT_138_HAS_ARG_LONG, 0, OPT_138_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_139_ENUM_NAME
+    #ifdef OPT_139_CLI_LONG_TXT_A
+          {OPT_139_CLI_LONG_TXT_A, OPT_139_HAS_ARG_LONG, 0, OPT_139_ENUM_NAME},
+    #endif
+    #ifdef OPT_139_CLI_LONG_TXT_B
+          {OPT_139_CLI_LONG_TXT_B, OPT_139_HAS_ARG_LONG, 0, OPT_139_ENUM_NAME},
+    #endif
+    #ifdef OPT_139_CLI_LONG_TXT_C
+          {OPT_139_CLI_LONG_TXT_C, OPT_139_HAS_ARG_LONG, 0, OPT_139_ENUM_NAME},
+    #endif
+    #ifdef OPT_139_CLI_LONG_TXT_D
+          {OPT_139_CLI_LONG_TXT_D, OPT_139_HAS_ARG_LONG, 0, OPT_139_ENUM_NAME},
+    #endif
+    #ifdef OPT_139_CLI_SHORT_CODE_TXT
+          {OPT_139_CLI_SHORT_CODE_TXT, OPT_139_HAS_ARG_LONG, 0, OPT_139_ENUM_NAME},
+    #endif
+#endif
+
+#ifdef OPT_140_ENUM_NAME
+    #ifdef OPT_140_CLI_LONG_TXT_A
+          {OPT_140_CLI_LONG_TXT_A, OPT_140_HAS_ARG_LONG, 0, OPT_140_ENUM_NAME},
+    #endif
+    #ifdef OPT_140_CLI_LONG_TXT_B
+          {OPT_140_CLI_LONG_TXT_B, OPT_140_HAS_ARG_LONG, 0, OPT_140_ENUM_NAME},
+    #endif
+    #ifdef OPT_140_CLI_LONG_TXT_C
+          {OPT_140_CLI_LONG_TXT_C, OPT_140_HAS_ARG_LONG, 0, OPT_140_ENUM_NAME},
+    #endif
+    #ifdef OPT_140_CLI_LONG_TXT_D
+          {OPT_140_CLI_LONG_TXT_D, OPT_140_HAS_ARG_LONG, 0, OPT_140_ENUM_NAME},
+    #endif
+    #ifdef OPT_140_CLI_SHORT_CODE_TXT
+          {OPT_140_CLI_SHORT_CODE_TXT, OPT_140_HAS_ARG_LONG, 0, OPT_140_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_141_ENUM_NAME
+    #ifdef OPT_141_CLI_LONG_TXT_A
+          {OPT_141_CLI_LONG_TXT_A, OPT_141_HAS_ARG_LONG, 0, OPT_141_ENUM_NAME},
+    #endif
+    #ifdef OPT_141_CLI_LONG_TXT_B
+          {OPT_141_CLI_LONG_TXT_B, OPT_141_HAS_ARG_LONG, 0, OPT_141_ENUM_NAME},
+    #endif
+    #ifdef OPT_141_CLI_LONG_TXT_C
+          {OPT_141_CLI_LONG_TXT_C, OPT_141_HAS_ARG_LONG, 0, OPT_141_ENUM_NAME},
+    #endif
+    #ifdef OPT_141_CLI_LONG_TXT_D
+          {OPT_141_CLI_LONG_TXT_D, OPT_141_HAS_ARG_LONG, 0, OPT_141_ENUM_NAME},
+    #endif
+    #ifdef OPT_141_CLI_SHORT_CODE_TXT
+          {OPT_141_CLI_SHORT_CODE_TXT, OPT_141_HAS_ARG_LONG, 0, OPT_141_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_142_ENUM_NAME
+    #ifdef OPT_142_CLI_LONG_TXT_A
+          {OPT_142_CLI_LONG_TXT_A, OPT_142_HAS_ARG_LONG, 0, OPT_142_ENUM_NAME},
+    #endif
+    #ifdef OPT_142_CLI_LONG_TXT_B
+          {OPT_142_CLI_LONG_TXT_B, OPT_142_HAS_ARG_LONG, 0, OPT_142_ENUM_NAME},
+    #endif
+    #ifdef OPT_142_CLI_LONG_TXT_C
+          {OPT_142_CLI_LONG_TXT_C, OPT_142_HAS_ARG_LONG, 0, OPT_142_ENUM_NAME},
+    #endif
+    #ifdef OPT_142_CLI_LONG_TXT_D
+          {OPT_142_CLI_LONG_TXT_D, OPT_142_HAS_ARG_LONG, 0, OPT_142_ENUM_NAME},
+    #endif
+    #ifdef OPT_142_CLI_SHORT_CODE_TXT
+          {OPT_142_CLI_SHORT_CODE_TXT, OPT_142_HAS_ARG_LONG, 0, OPT_142_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_143_ENUM_NAME
+    #ifdef OPT_143_CLI_LONG_TXT_A
+          {OPT_143_CLI_LONG_TXT_A, OPT_143_HAS_ARG_LONG, 0, OPT_143_ENUM_NAME},
+    #endif
+    #ifdef OPT_143_CLI_LONG_TXT_B
+          {OPT_143_CLI_LONG_TXT_B, OPT_143_HAS_ARG_LONG, 0, OPT_143_ENUM_NAME},
+    #endif
+    #ifdef OPT_143_CLI_LONG_TXT_C
+          {OPT_143_CLI_LONG_TXT_C, OPT_143_HAS_ARG_LONG, 0, OPT_143_ENUM_NAME},
+    #endif
+    #ifdef OPT_143_CLI_LONG_TXT_D
+          {OPT_143_CLI_LONG_TXT_D, OPT_143_HAS_ARG_LONG, 0, OPT_143_ENUM_NAME},
+    #endif
+    #ifdef OPT_143_CLI_SHORT_CODE_TXT
+          {OPT_143_CLI_SHORT_CODE_TXT, OPT_143_HAS_ARG_LONG, 0, OPT_143_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_144_ENUM_NAME
+    #ifdef OPT_144_CLI_LONG_TXT_A
+          {OPT_144_CLI_LONG_TXT_A, OPT_144_HAS_ARG_LONG, 0, OPT_144_ENUM_NAME},
+    #endif
+    #ifdef OPT_144_CLI_LONG_TXT_B
+          {OPT_144_CLI_LONG_TXT_B, OPT_144_HAS_ARG_LONG, 0, OPT_144_ENUM_NAME},
+    #endif
+    #ifdef OPT_144_CLI_LONG_TXT_C
+          {OPT_144_CLI_LONG_TXT_C, OPT_144_HAS_ARG_LONG, 0, OPT_144_ENUM_NAME},
+    #endif
+    #ifdef OPT_144_CLI_LONG_TXT_D
+          {OPT_144_CLI_LONG_TXT_D, OPT_144_HAS_ARG_LONG, 0, OPT_144_ENUM_NAME},
+    #endif
+    #ifdef OPT_144_CLI_SHORT_CODE_TXT
+          {OPT_144_CLI_SHORT_CODE_TXT, OPT_144_HAS_ARG_LONG, 0, OPT_144_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_145_ENUM_NAME
+    #ifdef OPT_145_CLI_LONG_TXT_A
+          {OPT_145_CLI_LONG_TXT_A, OPT_145_HAS_ARG_LONG, 0, OPT_145_ENUM_NAME},
+    #endif
+    #ifdef OPT_145_CLI_LONG_TXT_B
+          {OPT_145_CLI_LONG_TXT_B, OPT_145_HAS_ARG_LONG, 0, OPT_145_ENUM_NAME},
+    #endif
+    #ifdef OPT_145_CLI_LONG_TXT_C
+          {OPT_145_CLI_LONG_TXT_C, OPT_145_HAS_ARG_LONG, 0, OPT_145_ENUM_NAME},
+    #endif
+    #ifdef OPT_145_CLI_LONG_TXT_D
+          {OPT_145_CLI_LONG_TXT_D, OPT_145_HAS_ARG_LONG, 0, OPT_145_ENUM_NAME},
+    #endif
+    #ifdef OPT_145_CLI_SHORT_CODE_TXT
+          {OPT_145_CLI_SHORT_CODE_TXT, OPT_145_HAS_ARG_LONG, 0, OPT_145_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_146_ENUM_NAME
+    #ifdef OPT_146_CLI_LONG_TXT_A
+          {OPT_146_CLI_LONG_TXT_A, OPT_146_HAS_ARG_LONG, 0, OPT_146_ENUM_NAME},
+    #endif
+    #ifdef OPT_146_CLI_LONG_TXT_B
+          {OPT_146_CLI_LONG_TXT_B, OPT_146_HAS_ARG_LONG, 0, OPT_146_ENUM_NAME},
+    #endif
+    #ifdef OPT_146_CLI_LONG_TXT_C
+          {OPT_146_CLI_LONG_TXT_C, OPT_146_HAS_ARG_LONG, 0, OPT_146_ENUM_NAME},
+    #endif
+    #ifdef OPT_146_CLI_LONG_TXT_D
+          {OPT_146_CLI_LONG_TXT_D, OPT_146_HAS_ARG_LONG, 0, OPT_146_ENUM_NAME},
+    #endif
+    #ifdef OPT_146_CLI_SHORT_CODE_TXT
+          {OPT_146_CLI_SHORT_CODE_TXT, OPT_146_HAS_ARG_LONG, 0, OPT_146_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_147_ENUM_NAME
+    #ifdef OPT_147_CLI_LONG_TXT_A
+          {OPT_147_CLI_LONG_TXT_A, OPT_147_HAS_ARG_LONG, 0, OPT_147_ENUM_NAME},
+    #endif
+    #ifdef OPT_147_CLI_LONG_TXT_B
+          {OPT_147_CLI_LONG_TXT_B, OPT_147_HAS_ARG_LONG, 0, OPT_147_ENUM_NAME},
+    #endif
+    #ifdef OPT_147_CLI_LONG_TXT_C
+          {OPT_147_CLI_LONG_TXT_C, OPT_147_HAS_ARG_LONG, 0, OPT_147_ENUM_NAME},
+    #endif
+    #ifdef OPT_147_CLI_LONG_TXT_D
+          {OPT_147_CLI_LONG_TXT_D, OPT_147_HAS_ARG_LONG, 0, OPT_147_ENUM_NAME},
+    #endif
+    #ifdef OPT_147_CLI_SHORT_CODE_TXT
+          {OPT_147_CLI_SHORT_CODE_TXT, OPT_147_HAS_ARG_LONG, 0, OPT_147_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_148_ENUM_NAME
+    #ifdef OPT_148_CLI_LONG_TXT_A
+          {OPT_148_CLI_LONG_TXT_A, OPT_148_HAS_ARG_LONG, 0, OPT_148_ENUM_NAME},
+    #endif
+    #ifdef OPT_148_CLI_LONG_TXT_B
+          {OPT_148_CLI_LONG_TXT_B, OPT_148_HAS_ARG_LONG, 0, OPT_148_ENUM_NAME},
+    #endif
+    #ifdef OPT_148_CLI_LONG_TXT_C
+          {OPT_148_CLI_LONG_TXT_C, OPT_148_HAS_ARG_LONG, 0, OPT_148_ENUM_NAME},
+    #endif
+    #ifdef OPT_148_CLI_LONG_TXT_D
+          {OPT_148_CLI_LONG_TXT_D, OPT_148_HAS_ARG_LONG, 0, OPT_148_ENUM_NAME},
+    #endif
+    #ifdef OPT_148_CLI_SHORT_CODE_TXT
+          {OPT_148_CLI_SHORT_CODE_TXT, OPT_148_HAS_ARG_LONG, 0, OPT_148_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_149_ENUM_NAME
+    #ifdef OPT_149_CLI_LONG_TXT_A
+          {OPT_149_CLI_LONG_TXT_A, OPT_149_HAS_ARG_LONG, 0, OPT_149_ENUM_NAME},
+    #endif
+    #ifdef OPT_149_CLI_LONG_TXT_B
+          {OPT_149_CLI_LONG_TXT_B, OPT_149_HAS_ARG_LONG, 0, OPT_149_ENUM_NAME},
+    #endif
+    #ifdef OPT_149_CLI_LONG_TXT_C
+          {OPT_149_CLI_LONG_TXT_C, OPT_149_HAS_ARG_LONG, 0, OPT_149_ENUM_NAME},
+    #endif
+    #ifdef OPT_149_CLI_LONG_TXT_D
+          {OPT_149_CLI_LONG_TXT_D, OPT_149_HAS_ARG_LONG, 0, OPT_149_ENUM_NAME},
+    #endif
+    #ifdef OPT_149_CLI_SHORT_CODE_TXT
+          {OPT_149_CLI_SHORT_CODE_TXT, OPT_149_HAS_ARG_LONG, 0, OPT_149_ENUM_NAME},
+    #endif
+#endif
+
+#ifdef OPT_150_ENUM_NAME
+    #ifdef OPT_150_CLI_LONG_TXT_A
+          {OPT_150_CLI_LONG_TXT_A, OPT_150_HAS_ARG_LONG, 0, OPT_150_ENUM_NAME},
+    #endif
+    #ifdef OPT_150_CLI_LONG_TXT_B
+          {OPT_150_CLI_LONG_TXT_B, OPT_150_HAS_ARG_LONG, 0, OPT_150_ENUM_NAME},
+    #endif
+    #ifdef OPT_150_CLI_LONG_TXT_C
+          {OPT_150_CLI_LONG_TXT_C, OPT_150_HAS_ARG_LONG, 0, OPT_150_ENUM_NAME},
+    #endif
+    #ifdef OPT_150_CLI_LONG_TXT_D
+          {OPT_150_CLI_LONG_TXT_D, OPT_150_HAS_ARG_LONG, 0, OPT_150_ENUM_NAME},
+    #endif
+    #ifdef OPT_150_CLI_SHORT_CODE_TXT
+          {OPT_150_CLI_SHORT_CODE_TXT, OPT_150_HAS_ARG_LONG, 0, OPT_150_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_151_ENUM_NAME
+    #ifdef OPT_151_CLI_LONG_TXT_A
+          {OPT_151_CLI_LONG_TXT_A, OPT_151_HAS_ARG_LONG, 0, OPT_151_ENUM_NAME},
+    #endif
+    #ifdef OPT_151_CLI_LONG_TXT_B
+          {OPT_151_CLI_LONG_TXT_B, OPT_151_HAS_ARG_LONG, 0, OPT_151_ENUM_NAME},
+    #endif
+    #ifdef OPT_151_CLI_LONG_TXT_C
+          {OPT_151_CLI_LONG_TXT_C, OPT_151_HAS_ARG_LONG, 0, OPT_151_ENUM_NAME},
+    #endif
+    #ifdef OPT_151_CLI_LONG_TXT_D
+          {OPT_151_CLI_LONG_TXT_D, OPT_151_HAS_ARG_LONG, 0, OPT_151_ENUM_NAME},
+    #endif
+    #ifdef OPT_151_CLI_SHORT_CODE_TXT
+          {OPT_151_CLI_SHORT_CODE_TXT, OPT_151_HAS_ARG_LONG, 0, OPT_151_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_152_ENUM_NAME
+    #ifdef OPT_152_CLI_LONG_TXT_A
+          {OPT_152_CLI_LONG_TXT_A, OPT_152_HAS_ARG_LONG, 0, OPT_152_ENUM_NAME},
+    #endif
+    #ifdef OPT_152_CLI_LONG_TXT_B
+          {OPT_152_CLI_LONG_TXT_B, OPT_152_HAS_ARG_LONG, 0, OPT_152_ENUM_NAME},
+    #endif
+    #ifdef OPT_152_CLI_LONG_TXT_C
+          {OPT_152_CLI_LONG_TXT_C, OPT_152_HAS_ARG_LONG, 0, OPT_152_ENUM_NAME},
+    #endif
+    #ifdef OPT_152_CLI_LONG_TXT_D
+          {OPT_152_CLI_LONG_TXT_D, OPT_152_HAS_ARG_LONG, 0, OPT_152_ENUM_NAME},
+    #endif
+    #ifdef OPT_152_CLI_SHORT_CODE_TXT
+          {OPT_152_CLI_SHORT_CODE_TXT, OPT_152_HAS_ARG_LONG, 0, OPT_152_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_153_ENUM_NAME
+    #ifdef OPT_153_CLI_LONG_TXT_A
+          {OPT_153_CLI_LONG_TXT_A, OPT_153_HAS_ARG_LONG, 0, OPT_153_ENUM_NAME},
+    #endif
+    #ifdef OPT_153_CLI_LONG_TXT_B
+          {OPT_153_CLI_LONG_TXT_B, OPT_153_HAS_ARG_LONG, 0, OPT_153_ENUM_NAME},
+    #endif
+    #ifdef OPT_153_CLI_LONG_TXT_C
+          {OPT_153_CLI_LONG_TXT_C, OPT_153_HAS_ARG_LONG, 0, OPT_153_ENUM_NAME},
+    #endif
+    #ifdef OPT_153_CLI_LONG_TXT_D
+          {OPT_153_CLI_LONG_TXT_D, OPT_153_HAS_ARG_LONG, 0, OPT_153_ENUM_NAME},
+    #endif
+    #ifdef OPT_153_CLI_SHORT_CODE_TXT
+          {OPT_153_CLI_SHORT_CODE_TXT, OPT_153_HAS_ARG_LONG, 0, OPT_153_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_154_ENUM_NAME
+    #ifdef OPT_154_CLI_LONG_TXT_A
+          {OPT_154_CLI_LONG_TXT_A, OPT_154_HAS_ARG_LONG, 0, OPT_154_ENUM_NAME},
+    #endif
+    #ifdef OPT_154_CLI_LONG_TXT_B
+          {OPT_154_CLI_LONG_TXT_B, OPT_154_HAS_ARG_LONG, 0, OPT_154_ENUM_NAME},
+    #endif
+    #ifdef OPT_154_CLI_LONG_TXT_C
+          {OPT_154_CLI_LONG_TXT_C, OPT_154_HAS_ARG_LONG, 0, OPT_154_ENUM_NAME},
+    #endif
+    #ifdef OPT_154_CLI_LONG_TXT_D
+          {OPT_154_CLI_LONG_TXT_D, OPT_154_HAS_ARG_LONG, 0, OPT_154_ENUM_NAME},
+    #endif
+    #ifdef OPT_154_CLI_SHORT_CODE_TXT
+          {OPT_154_CLI_SHORT_CODE_TXT, OPT_154_HAS_ARG_LONG, 0, OPT_154_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_155_ENUM_NAME
+    #ifdef OPT_155_CLI_LONG_TXT_A
+          {OPT_155_CLI_LONG_TXT_A, OPT_155_HAS_ARG_LONG, 0, OPT_155_ENUM_NAME},
+    #endif
+    #ifdef OPT_155_CLI_LONG_TXT_B
+          {OPT_155_CLI_LONG_TXT_B, OPT_155_HAS_ARG_LONG, 0, OPT_155_ENUM_NAME},
+    #endif
+    #ifdef OPT_155_CLI_LONG_TXT_C
+          {OPT_155_CLI_LONG_TXT_C, OPT_155_HAS_ARG_LONG, 0, OPT_155_ENUM_NAME},
+    #endif
+    #ifdef OPT_155_CLI_LONG_TXT_D
+          {OPT_155_CLI_LONG_TXT_D, OPT_155_HAS_ARG_LONG, 0, OPT_155_ENUM_NAME},
+    #endif
+    #ifdef OPT_155_CLI_SHORT_CODE_TXT
+          {OPT_155_CLI_SHORT_CODE_TXT, OPT_155_HAS_ARG_LONG, 0, OPT_155_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_156_ENUM_NAME
+    #ifdef OPT_156_CLI_LONG_TXT_A
+          {OPT_156_CLI_LONG_TXT_A, OPT_156_HAS_ARG_LONG, 0, OPT_156_ENUM_NAME},
+    #endif
+    #ifdef OPT_156_CLI_LONG_TXT_B
+          {OPT_156_CLI_LONG_TXT_B, OPT_156_HAS_ARG_LONG, 0, OPT_156_ENUM_NAME},
+    #endif
+    #ifdef OPT_156_CLI_LONG_TXT_C
+          {OPT_156_CLI_LONG_TXT_C, OPT_156_HAS_ARG_LONG, 0, OPT_156_ENUM_NAME},
+    #endif
+    #ifdef OPT_156_CLI_LONG_TXT_D
+          {OPT_156_CLI_LONG_TXT_D, OPT_156_HAS_ARG_LONG, 0, OPT_156_ENUM_NAME},
+    #endif
+    #ifdef OPT_156_CLI_SHORT_CODE_TXT
+          {OPT_156_CLI_SHORT_CODE_TXT, OPT_156_HAS_ARG_LONG, 0, OPT_156_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_157_ENUM_NAME
+    #ifdef OPT_157_CLI_LONG_TXT_A
+          {OPT_157_CLI_LONG_TXT_A, OPT_157_HAS_ARG_LONG, 0, OPT_157_ENUM_NAME},
+    #endif
+    #ifdef OPT_157_CLI_LONG_TXT_B
+          {OPT_157_CLI_LONG_TXT_B, OPT_157_HAS_ARG_LONG, 0, OPT_157_ENUM_NAME},
+    #endif
+    #ifdef OPT_157_CLI_LONG_TXT_C
+          {OPT_157_CLI_LONG_TXT_C, OPT_157_HAS_ARG_LONG, 0, OPT_157_ENUM_NAME},
+    #endif
+    #ifdef OPT_157_CLI_LONG_TXT_D
+          {OPT_157_CLI_LONG_TXT_D, OPT_157_HAS_ARG_LONG, 0, OPT_157_ENUM_NAME},
+    #endif
+    #ifdef OPT_157_CLI_SHORT_CODE_TXT
+          {OPT_157_CLI_SHORT_CODE_TXT, OPT_157_HAS_ARG_LONG, 0, OPT_157_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_158_ENUM_NAME
+    #ifdef OPT_158_CLI_LONG_TXT_A
+          {OPT_158_CLI_LONG_TXT_A, OPT_158_HAS_ARG_LONG, 0, OPT_158_ENUM_NAME},
+    #endif
+    #ifdef OPT_158_CLI_LONG_TXT_B
+          {OPT_158_CLI_LONG_TXT_B, OPT_158_HAS_ARG_LONG, 0, OPT_158_ENUM_NAME},
+    #endif
+    #ifdef OPT_158_CLI_LONG_TXT_C
+          {OPT_158_CLI_LONG_TXT_C, OPT_158_HAS_ARG_LONG, 0, OPT_158_ENUM_NAME},
+    #endif
+    #ifdef OPT_158_CLI_LONG_TXT_D
+          {OPT_158_CLI_LONG_TXT_D, OPT_158_HAS_ARG_LONG, 0, OPT_158_ENUM_NAME},
+    #endif
+    #ifdef OPT_158_CLI_SHORT_CODE_TXT
+          {OPT_158_CLI_SHORT_CODE_TXT, OPT_158_HAS_ARG_LONG, 0, OPT_158_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_159_ENUM_NAME
+    #ifdef OPT_159_CLI_LONG_TXT_A
+          {OPT_159_CLI_LONG_TXT_A, OPT_159_HAS_ARG_LONG, 0, OPT_159_ENUM_NAME},
+    #endif
+    #ifdef OPT_159_CLI_LONG_TXT_B
+          {OPT_159_CLI_LONG_TXT_B, OPT_159_HAS_ARG_LONG, 0, OPT_159_ENUM_NAME},
+    #endif
+    #ifdef OPT_159_CLI_LONG_TXT_C
+          {OPT_159_CLI_LONG_TXT_C, OPT_159_HAS_ARG_LONG, 0, OPT_159_ENUM_NAME},
+    #endif
+    #ifdef OPT_159_CLI_LONG_TXT_D
+          {OPT_159_CLI_LONG_TXT_D, OPT_159_HAS_ARG_LONG, 0, OPT_159_ENUM_NAME},
+    #endif
+    #ifdef OPT_159_CLI_SHORT_CODE_TXT
+          {OPT_159_CLI_SHORT_CODE_TXT, OPT_159_HAS_ARG_LONG, 0, OPT_159_ENUM_NAME},
+    #endif
+#endif
+
+#ifdef OPT_160_ENUM_NAME
+    #ifdef OPT_160_CLI_LONG_TXT_A
+          {OPT_160_CLI_LONG_TXT_A, OPT_160_HAS_ARG_LONG, 0, OPT_160_ENUM_NAME},
+    #endif
+    #ifdef OPT_160_CLI_LONG_TXT_B
+          {OPT_160_CLI_LONG_TXT_B, OPT_160_HAS_ARG_LONG, 0, OPT_160_ENUM_NAME},
+    #endif
+    #ifdef OPT_160_CLI_LONG_TXT_C
+          {OPT_160_CLI_LONG_TXT_C, OPT_160_HAS_ARG_LONG, 0, OPT_160_ENUM_NAME},
+    #endif
+    #ifdef OPT_160_CLI_LONG_TXT_D
+          {OPT_160_CLI_LONG_TXT_D, OPT_160_HAS_ARG_LONG, 0, OPT_160_ENUM_NAME},
+    #endif
+    #ifdef OPT_160_CLI_SHORT_CODE_TXT
+          {OPT_160_CLI_SHORT_CODE_TXT, OPT_160_HAS_ARG_LONG, 0, OPT_160_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_161_ENUM_NAME
+    #ifdef OPT_161_CLI_LONG_TXT_A
+          {OPT_161_CLI_LONG_TXT_A, OPT_161_HAS_ARG_LONG, 0, OPT_161_ENUM_NAME},
+    #endif
+    #ifdef OPT_161_CLI_LONG_TXT_B
+          {OPT_161_CLI_LONG_TXT_B, OPT_161_HAS_ARG_LONG, 0, OPT_161_ENUM_NAME},
+    #endif
+    #ifdef OPT_161_CLI_LONG_TXT_C
+          {OPT_161_CLI_LONG_TXT_C, OPT_161_HAS_ARG_LONG, 0, OPT_161_ENUM_NAME},
+    #endif
+    #ifdef OPT_161_CLI_LONG_TXT_D
+          {OPT_161_CLI_LONG_TXT_D, OPT_161_HAS_ARG_LONG, 0, OPT_161_ENUM_NAME},
+    #endif
+    #ifdef OPT_161_CLI_SHORT_CODE_TXT
+          {OPT_161_CLI_SHORT_CODE_TXT, OPT_161_HAS_ARG_LONG, 0, OPT_161_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_162_ENUM_NAME
+    #ifdef OPT_162_CLI_LONG_TXT_A
+          {OPT_162_CLI_LONG_TXT_A, OPT_162_HAS_ARG_LONG, 0, OPT_162_ENUM_NAME},
+    #endif
+    #ifdef OPT_162_CLI_LONG_TXT_B
+          {OPT_162_CLI_LONG_TXT_B, OPT_162_HAS_ARG_LONG, 0, OPT_162_ENUM_NAME},
+    #endif
+    #ifdef OPT_162_CLI_LONG_TXT_C
+          {OPT_162_CLI_LONG_TXT_C, OPT_162_HAS_ARG_LONG, 0, OPT_162_ENUM_NAME},
+    #endif
+    #ifdef OPT_162_CLI_LONG_TXT_D
+          {OPT_162_CLI_LONG_TXT_D, OPT_162_HAS_ARG_LONG, 0, OPT_162_ENUM_NAME},
+    #endif
+    #ifdef OPT_162_CLI_SHORT_CODE_TXT
+          {OPT_162_CLI_SHORT_CODE_TXT, OPT_162_HAS_ARG_LONG, 0, OPT_162_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_163_ENUM_NAME
+    #ifdef OPT_163_CLI_LONG_TXT_A
+          {OPT_163_CLI_LONG_TXT_A, OPT_163_HAS_ARG_LONG, 0, OPT_163_ENUM_NAME},
+    #endif
+    #ifdef OPT_163_CLI_LONG_TXT_B
+          {OPT_163_CLI_LONG_TXT_B, OPT_163_HAS_ARG_LONG, 0, OPT_163_ENUM_NAME},
+    #endif
+    #ifdef OPT_163_CLI_LONG_TXT_C
+          {OPT_163_CLI_LONG_TXT_C, OPT_163_HAS_ARG_LONG, 0, OPT_163_ENUM_NAME},
+    #endif
+    #ifdef OPT_163_CLI_LONG_TXT_D
+          {OPT_163_CLI_LONG_TXT_D, OPT_163_HAS_ARG_LONG, 0, OPT_163_ENUM_NAME},
+    #endif
+    #ifdef OPT_163_CLI_SHORT_CODE_TXT
+          {OPT_163_CLI_SHORT_CODE_TXT, OPT_163_HAS_ARG_LONG, 0, OPT_163_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_164_ENUM_NAME
+    #ifdef OPT_164_CLI_LONG_TXT_A
+          {OPT_164_CLI_LONG_TXT_A, OPT_164_HAS_ARG_LONG, 0, OPT_164_ENUM_NAME},
+    #endif
+    #ifdef OPT_164_CLI_LONG_TXT_B
+          {OPT_164_CLI_LONG_TXT_B, OPT_164_HAS_ARG_LONG, 0, OPT_164_ENUM_NAME},
+    #endif
+    #ifdef OPT_164_CLI_LONG_TXT_C
+          {OPT_164_CLI_LONG_TXT_C, OPT_164_HAS_ARG_LONG, 0, OPT_164_ENUM_NAME},
+    #endif
+    #ifdef OPT_164_CLI_LONG_TXT_D
+          {OPT_164_CLI_LONG_TXT_D, OPT_164_HAS_ARG_LONG, 0, OPT_164_ENUM_NAME},
+    #endif
+    #ifdef OPT_164_CLI_SHORT_CODE_TXT
+          {OPT_164_CLI_SHORT_CODE_TXT, OPT_164_HAS_ARG_LONG, 0, OPT_164_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_165_ENUM_NAME
+    #ifdef OPT_165_CLI_LONG_TXT_A
+          {OPT_165_CLI_LONG_TXT_A, OPT_165_HAS_ARG_LONG, 0, OPT_165_ENUM_NAME},
+    #endif
+    #ifdef OPT_165_CLI_LONG_TXT_B
+          {OPT_165_CLI_LONG_TXT_B, OPT_165_HAS_ARG_LONG, 0, OPT_165_ENUM_NAME},
+    #endif
+    #ifdef OPT_165_CLI_LONG_TXT_C
+          {OPT_165_CLI_LONG_TXT_C, OPT_165_HAS_ARG_LONG, 0, OPT_165_ENUM_NAME},
+    #endif
+    #ifdef OPT_165_CLI_LONG_TXT_D
+          {OPT_165_CLI_LONG_TXT_D, OPT_165_HAS_ARG_LONG, 0, OPT_165_ENUM_NAME},
+    #endif
+    #ifdef OPT_165_CLI_SHORT_CODE_TXT
+          {OPT_165_CLI_SHORT_CODE_TXT, OPT_165_HAS_ARG_LONG, 0, OPT_165_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_166_ENUM_NAME
+    #ifdef OPT_166_CLI_LONG_TXT_A
+          {OPT_166_CLI_LONG_TXT_A, OPT_166_HAS_ARG_LONG, 0, OPT_166_ENUM_NAME},
+    #endif
+    #ifdef OPT_166_CLI_LONG_TXT_B
+          {OPT_166_CLI_LONG_TXT_B, OPT_166_HAS_ARG_LONG, 0, OPT_166_ENUM_NAME},
+    #endif
+    #ifdef OPT_166_CLI_LONG_TXT_C
+          {OPT_166_CLI_LONG_TXT_C, OPT_166_HAS_ARG_LONG, 0, OPT_166_ENUM_NAME},
+    #endif
+    #ifdef OPT_166_CLI_LONG_TXT_D
+          {OPT_166_CLI_LONG_TXT_D, OPT_166_HAS_ARG_LONG, 0, OPT_166_ENUM_NAME},
+    #endif
+    #ifdef OPT_166_CLI_SHORT_CODE_TXT
+          {OPT_166_CLI_SHORT_CODE_TXT, OPT_166_HAS_ARG_LONG, 0, OPT_166_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_167_ENUM_NAME
+    #ifdef OPT_167_CLI_LONG_TXT_A
+          {OPT_167_CLI_LONG_TXT_A, OPT_167_HAS_ARG_LONG, 0, OPT_167_ENUM_NAME},
+    #endif
+    #ifdef OPT_167_CLI_LONG_TXT_B
+          {OPT_167_CLI_LONG_TXT_B, OPT_167_HAS_ARG_LONG, 0, OPT_167_ENUM_NAME},
+    #endif
+    #ifdef OPT_167_CLI_LONG_TXT_C
+          {OPT_167_CLI_LONG_TXT_C, OPT_167_HAS_ARG_LONG, 0, OPT_167_ENUM_NAME},
+    #endif
+    #ifdef OPT_167_CLI_LONG_TXT_D
+          {OPT_167_CLI_LONG_TXT_D, OPT_167_HAS_ARG_LONG, 0, OPT_167_ENUM_NAME},
+    #endif
+    #ifdef OPT_167_CLI_SHORT_CODE_TXT
+          {OPT_167_CLI_SHORT_CODE_TXT, OPT_167_HAS_ARG_LONG, 0, OPT_167_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_168_ENUM_NAME
+    #ifdef OPT_168_CLI_LONG_TXT_A
+          {OPT_168_CLI_LONG_TXT_A, OPT_168_HAS_ARG_LONG, 0, OPT_168_ENUM_NAME},
+    #endif
+    #ifdef OPT_168_CLI_LONG_TXT_B
+          {OPT_168_CLI_LONG_TXT_B, OPT_168_HAS_ARG_LONG, 0, OPT_168_ENUM_NAME},
+    #endif
+    #ifdef OPT_168_CLI_LONG_TXT_C
+          {OPT_168_CLI_LONG_TXT_C, OPT_168_HAS_ARG_LONG, 0, OPT_168_ENUM_NAME},
+    #endif
+    #ifdef OPT_168_CLI_LONG_TXT_D
+          {OPT_168_CLI_LONG_TXT_D, OPT_168_HAS_ARG_LONG, 0, OPT_168_ENUM_NAME},
+    #endif
+    #ifdef OPT_168_CLI_SHORT_CODE_TXT
+          {OPT_168_CLI_SHORT_CODE_TXT, OPT_168_HAS_ARG_LONG, 0, OPT_168_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_169_ENUM_NAME
+    #ifdef OPT_169_CLI_LONG_TXT_A
+          {OPT_169_CLI_LONG_TXT_A, OPT_169_HAS_ARG_LONG, 0, OPT_169_ENUM_NAME},
+    #endif
+    #ifdef OPT_169_CLI_LONG_TXT_B
+          {OPT_169_CLI_LONG_TXT_B, OPT_169_HAS_ARG_LONG, 0, OPT_169_ENUM_NAME},
+    #endif
+    #ifdef OPT_169_CLI_LONG_TXT_C
+          {OPT_169_CLI_LONG_TXT_C, OPT_169_HAS_ARG_LONG, 0, OPT_169_ENUM_NAME},
+    #endif
+    #ifdef OPT_169_CLI_LONG_TXT_D
+          {OPT_169_CLI_LONG_TXT_D, OPT_169_HAS_ARG_LONG, 0, OPT_169_ENUM_NAME},
+    #endif
+    #ifdef OPT_169_CLI_SHORT_CODE_TXT
+          {OPT_169_CLI_SHORT_CODE_TXT, OPT_169_HAS_ARG_LONG, 0, OPT_169_ENUM_NAME},
+    #endif
+#endif
+
+#ifdef OPT_170_ENUM_NAME
+    #ifdef OPT_170_CLI_LONG_TXT_A
+          {OPT_170_CLI_LONG_TXT_A, OPT_170_HAS_ARG_LONG, 0, OPT_170_ENUM_NAME},
+    #endif
+    #ifdef OPT_170_CLI_LONG_TXT_B
+          {OPT_170_CLI_LONG_TXT_B, OPT_170_HAS_ARG_LONG, 0, OPT_170_ENUM_NAME},
+    #endif
+    #ifdef OPT_170_CLI_LONG_TXT_C
+          {OPT_170_CLI_LONG_TXT_C, OPT_170_HAS_ARG_LONG, 0, OPT_170_ENUM_NAME},
+    #endif
+    #ifdef OPT_170_CLI_LONG_TXT_D
+          {OPT_170_CLI_LONG_TXT_D, OPT_170_HAS_ARG_LONG, 0, OPT_170_ENUM_NAME},
+    #endif
+    #ifdef OPT_170_CLI_SHORT_CODE_TXT
+          {OPT_170_CLI_SHORT_CODE_TXT, OPT_170_HAS_ARG_LONG, 0, OPT_170_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_171_ENUM_NAME
+    #ifdef OPT_171_CLI_LONG_TXT_A
+          {OPT_171_CLI_LONG_TXT_A, OPT_171_HAS_ARG_LONG, 0, OPT_171_ENUM_NAME},
+    #endif
+    #ifdef OPT_171_CLI_LONG_TXT_B
+          {OPT_171_CLI_LONG_TXT_B, OPT_171_HAS_ARG_LONG, 0, OPT_171_ENUM_NAME},
+    #endif
+    #ifdef OPT_171_CLI_LONG_TXT_C
+          {OPT_171_CLI_LONG_TXT_C, OPT_171_HAS_ARG_LONG, 0, OPT_171_ENUM_NAME},
+    #endif
+    #ifdef OPT_171_CLI_LONG_TXT_D
+          {OPT_171_CLI_LONG_TXT_D, OPT_171_HAS_ARG_LONG, 0, OPT_171_ENUM_NAME},
+    #endif
+    #ifdef OPT_171_CLI_SHORT_CODE_TXT
+          {OPT_171_CLI_SHORT_CODE_TXT, OPT_171_HAS_ARG_LONG, 0, OPT_171_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_172_ENUM_NAME
+    #ifdef OPT_172_CLI_LONG_TXT_A
+          {OPT_172_CLI_LONG_TXT_A, OPT_172_HAS_ARG_LONG, 0, OPT_172_ENUM_NAME},
+    #endif
+    #ifdef OPT_172_CLI_LONG_TXT_B
+          {OPT_172_CLI_LONG_TXT_B, OPT_172_HAS_ARG_LONG, 0, OPT_172_ENUM_NAME},
+    #endif
+    #ifdef OPT_172_CLI_LONG_TXT_C
+          {OPT_172_CLI_LONG_TXT_C, OPT_172_HAS_ARG_LONG, 0, OPT_172_ENUM_NAME},
+    #endif
+    #ifdef OPT_172_CLI_LONG_TXT_D
+          {OPT_172_CLI_LONG_TXT_D, OPT_172_HAS_ARG_LONG, 0, OPT_172_ENUM_NAME},
+    #endif
+    #ifdef OPT_172_CLI_SHORT_CODE_TXT
+          {OPT_172_CLI_SHORT_CODE_TXT, OPT_172_HAS_ARG_LONG, 0, OPT_172_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_173_ENUM_NAME
+    #ifdef OPT_173_CLI_LONG_TXT_A
+          {OPT_173_CLI_LONG_TXT_A, OPT_173_HAS_ARG_LONG, 0, OPT_173_ENUM_NAME},
+    #endif
+    #ifdef OPT_173_CLI_LONG_TXT_B
+          {OPT_173_CLI_LONG_TXT_B, OPT_173_HAS_ARG_LONG, 0, OPT_173_ENUM_NAME},
+    #endif
+    #ifdef OPT_173_CLI_LONG_TXT_C
+          {OPT_173_CLI_LONG_TXT_C, OPT_173_HAS_ARG_LONG, 0, OPT_173_ENUM_NAME},
+    #endif
+    #ifdef OPT_173_CLI_LONG_TXT_D
+          {OPT_173_CLI_LONG_TXT_D, OPT_173_HAS_ARG_LONG, 0, OPT_173_ENUM_NAME},
+    #endif
+    #ifdef OPT_173_CLI_SHORT_CODE_TXT
+          {OPT_173_CLI_SHORT_CODE_TXT, OPT_173_HAS_ARG_LONG, 0, OPT_173_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_174_ENUM_NAME
+    #ifdef OPT_174_CLI_LONG_TXT_A
+          {OPT_174_CLI_LONG_TXT_A, OPT_174_HAS_ARG_LONG, 0, OPT_174_ENUM_NAME},
+    #endif
+    #ifdef OPT_174_CLI_LONG_TXT_B
+          {OPT_174_CLI_LONG_TXT_B, OPT_174_HAS_ARG_LONG, 0, OPT_174_ENUM_NAME},
+    #endif
+    #ifdef OPT_174_CLI_LONG_TXT_C
+          {OPT_174_CLI_LONG_TXT_C, OPT_174_HAS_ARG_LONG, 0, OPT_174_ENUM_NAME},
+    #endif
+    #ifdef OPT_174_CLI_LONG_TXT_D
+          {OPT_174_CLI_LONG_TXT_D, OPT_174_HAS_ARG_LONG, 0, OPT_174_ENUM_NAME},
+    #endif
+    #ifdef OPT_174_CLI_SHORT_CODE_TXT
+          {OPT_174_CLI_SHORT_CODE_TXT, OPT_174_HAS_ARG_LONG, 0, OPT_174_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_175_ENUM_NAME
+    #ifdef OPT_175_CLI_LONG_TXT_A
+          {OPT_175_CLI_LONG_TXT_A, OPT_175_HAS_ARG_LONG, 0, OPT_175_ENUM_NAME},
+    #endif
+    #ifdef OPT_175_CLI_LONG_TXT_B
+          {OPT_175_CLI_LONG_TXT_B, OPT_175_HAS_ARG_LONG, 0, OPT_175_ENUM_NAME},
+    #endif
+    #ifdef OPT_175_CLI_LONG_TXT_C
+          {OPT_175_CLI_LONG_TXT_C, OPT_175_HAS_ARG_LONG, 0, OPT_175_ENUM_NAME},
+    #endif
+    #ifdef OPT_175_CLI_LONG_TXT_D
+          {OPT_175_CLI_LONG_TXT_D, OPT_175_HAS_ARG_LONG, 0, OPT_175_ENUM_NAME},
+    #endif
+    #ifdef OPT_175_CLI_SHORT_CODE_TXT
+          {OPT_175_CLI_SHORT_CODE_TXT, OPT_175_HAS_ARG_LONG, 0, OPT_175_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_176_ENUM_NAME
+    #ifdef OPT_176_CLI_LONG_TXT_A
+          {OPT_176_CLI_LONG_TXT_A, OPT_176_HAS_ARG_LONG, 0, OPT_176_ENUM_NAME},
+    #endif
+    #ifdef OPT_176_CLI_LONG_TXT_B
+          {OPT_176_CLI_LONG_TXT_B, OPT_176_HAS_ARG_LONG, 0, OPT_176_ENUM_NAME},
+    #endif
+    #ifdef OPT_176_CLI_LONG_TXT_C
+          {OPT_176_CLI_LONG_TXT_C, OPT_176_HAS_ARG_LONG, 0, OPT_176_ENUM_NAME},
+    #endif
+    #ifdef OPT_176_CLI_LONG_TXT_D
+          {OPT_176_CLI_LONG_TXT_D, OPT_176_HAS_ARG_LONG, 0, OPT_176_ENUM_NAME},
+    #endif
+    #ifdef OPT_176_CLI_SHORT_CODE_TXT
+          {OPT_176_CLI_SHORT_CODE_TXT, OPT_176_HAS_ARG_LONG, 0, OPT_176_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_177_ENUM_NAME
+    #ifdef OPT_177_CLI_LONG_TXT_A
+          {OPT_177_CLI_LONG_TXT_A, OPT_177_HAS_ARG_LONG, 0, OPT_177_ENUM_NAME},
+    #endif
+    #ifdef OPT_177_CLI_LONG_TXT_B
+          {OPT_177_CLI_LONG_TXT_B, OPT_177_HAS_ARG_LONG, 0, OPT_177_ENUM_NAME},
+    #endif
+    #ifdef OPT_177_CLI_LONG_TXT_C
+          {OPT_177_CLI_LONG_TXT_C, OPT_177_HAS_ARG_LONG, 0, OPT_177_ENUM_NAME},
+    #endif
+    #ifdef OPT_177_CLI_LONG_TXT_D
+          {OPT_177_CLI_LONG_TXT_D, OPT_177_HAS_ARG_LONG, 0, OPT_177_ENUM_NAME},
+    #endif
+    #ifdef OPT_177_CLI_SHORT_CODE_TXT
+          {OPT_177_CLI_SHORT_CODE_TXT, OPT_177_HAS_ARG_LONG, 0, OPT_177_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_178_ENUM_NAME
+    #ifdef OPT_178_CLI_LONG_TXT_A
+          {OPT_178_CLI_LONG_TXT_A, OPT_178_HAS_ARG_LONG, 0, OPT_178_ENUM_NAME},
+    #endif
+    #ifdef OPT_178_CLI_LONG_TXT_B
+          {OPT_178_CLI_LONG_TXT_B, OPT_178_HAS_ARG_LONG, 0, OPT_178_ENUM_NAME},
+    #endif
+    #ifdef OPT_178_CLI_LONG_TXT_C
+          {OPT_178_CLI_LONG_TXT_C, OPT_178_HAS_ARG_LONG, 0, OPT_178_ENUM_NAME},
+    #endif
+    #ifdef OPT_178_CLI_LONG_TXT_D
+          {OPT_178_CLI_LONG_TXT_D, OPT_178_HAS_ARG_LONG, 0, OPT_178_ENUM_NAME},
+    #endif
+    #ifdef OPT_178_CLI_SHORT_CODE_TXT
+          {OPT_178_CLI_SHORT_CODE_TXT, OPT_178_HAS_ARG_LONG, 0, OPT_178_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_179_ENUM_NAME
+    #ifdef OPT_179_CLI_LONG_TXT_A
+          {OPT_179_CLI_LONG_TXT_A, OPT_179_HAS_ARG_LONG, 0, OPT_179_ENUM_NAME},
+    #endif
+    #ifdef OPT_179_CLI_LONG_TXT_B
+          {OPT_179_CLI_LONG_TXT_B, OPT_179_HAS_ARG_LONG, 0, OPT_179_ENUM_NAME},
+    #endif
+    #ifdef OPT_179_CLI_LONG_TXT_C
+          {OPT_179_CLI_LONG_TXT_C, OPT_179_HAS_ARG_LONG, 0, OPT_179_ENUM_NAME},
+    #endif
+    #ifdef OPT_179_CLI_LONG_TXT_D
+          {OPT_179_CLI_LONG_TXT_D, OPT_179_HAS_ARG_LONG, 0, OPT_179_ENUM_NAME},
+    #endif
+    #ifdef OPT_179_CLI_SHORT_CODE_TXT
+          {OPT_179_CLI_SHORT_CODE_TXT, OPT_179_HAS_ARG_LONG, 0, OPT_179_ENUM_NAME},
+    #endif
+#endif
+
+#ifdef OPT_180_ENUM_NAME
+    #ifdef OPT_180_CLI_LONG_TXT_A
+          {OPT_180_CLI_LONG_TXT_A, OPT_180_HAS_ARG_LONG, 0, OPT_180_ENUM_NAME},
+    #endif
+    #ifdef OPT_180_CLI_LONG_TXT_B
+          {OPT_180_CLI_LONG_TXT_B, OPT_180_HAS_ARG_LONG, 0, OPT_180_ENUM_NAME},
+    #endif
+    #ifdef OPT_180_CLI_LONG_TXT_C
+          {OPT_180_CLI_LONG_TXT_C, OPT_180_HAS_ARG_LONG, 0, OPT_180_ENUM_NAME},
+    #endif
+    #ifdef OPT_180_CLI_LONG_TXT_D
+          {OPT_180_CLI_LONG_TXT_D, OPT_180_HAS_ARG_LONG, 0, OPT_180_ENUM_NAME},
+    #endif
+    #ifdef OPT_180_CLI_SHORT_CODE_TXT
+          {OPT_180_CLI_SHORT_CODE_TXT, OPT_180_HAS_ARG_LONG, 0, OPT_180_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_181_ENUM_NAME
+    #ifdef OPT_181_CLI_LONG_TXT_A
+          {OPT_181_CLI_LONG_TXT_A, OPT_181_HAS_ARG_LONG, 0, OPT_181_ENUM_NAME},
+    #endif
+    #ifdef OPT_181_CLI_LONG_TXT_B
+          {OPT_181_CLI_LONG_TXT_B, OPT_181_HAS_ARG_LONG, 0, OPT_181_ENUM_NAME},
+    #endif
+    #ifdef OPT_181_CLI_LONG_TXT_C
+          {OPT_181_CLI_LONG_TXT_C, OPT_181_HAS_ARG_LONG, 0, OPT_181_ENUM_NAME},
+    #endif
+    #ifdef OPT_181_CLI_LONG_TXT_D
+          {OPT_181_CLI_LONG_TXT_D, OPT_181_HAS_ARG_LONG, 0, OPT_181_ENUM_NAME},
+    #endif
+    #ifdef OPT_181_CLI_SHORT_CODE_TXT
+          {OPT_181_CLI_SHORT_CODE_TXT, OPT_181_HAS_ARG_LONG, 0, OPT_181_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_182_ENUM_NAME
+    #ifdef OPT_182_CLI_LONG_TXT_A
+          {OPT_182_CLI_LONG_TXT_A, OPT_182_HAS_ARG_LONG, 0, OPT_182_ENUM_NAME},
+    #endif
+    #ifdef OPT_182_CLI_LONG_TXT_B
+          {OPT_182_CLI_LONG_TXT_B, OPT_182_HAS_ARG_LONG, 0, OPT_182_ENUM_NAME},
+    #endif
+    #ifdef OPT_182_CLI_LONG_TXT_C
+          {OPT_182_CLI_LONG_TXT_C, OPT_182_HAS_ARG_LONG, 0, OPT_182_ENUM_NAME},
+    #endif
+    #ifdef OPT_182_CLI_LONG_TXT_D
+          {OPT_182_CLI_LONG_TXT_D, OPT_182_HAS_ARG_LONG, 0, OPT_182_ENUM_NAME},
+    #endif
+    #ifdef OPT_182_CLI_SHORT_CODE_TXT
+          {OPT_182_CLI_SHORT_CODE_TXT, OPT_182_HAS_ARG_LONG, 0, OPT_182_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_183_ENUM_NAME
+    #ifdef OPT_183_CLI_LONG_TXT_A
+          {OPT_183_CLI_LONG_TXT_A, OPT_183_HAS_ARG_LONG, 0, OPT_183_ENUM_NAME},
+    #endif
+    #ifdef OPT_183_CLI_LONG_TXT_B
+          {OPT_183_CLI_LONG_TXT_B, OPT_183_HAS_ARG_LONG, 0, OPT_183_ENUM_NAME},
+    #endif
+    #ifdef OPT_183_CLI_LONG_TXT_C
+          {OPT_183_CLI_LONG_TXT_C, OPT_183_HAS_ARG_LONG, 0, OPT_183_ENUM_NAME},
+    #endif
+    #ifdef OPT_183_CLI_LONG_TXT_D
+          {OPT_183_CLI_LONG_TXT_D, OPT_183_HAS_ARG_LONG, 0, OPT_183_ENUM_NAME},
+    #endif
+    #ifdef OPT_183_CLI_SHORT_CODE_TXT
+          {OPT_183_CLI_SHORT_CODE_TXT, OPT_183_HAS_ARG_LONG, 0, OPT_183_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_184_ENUM_NAME
+    #ifdef OPT_184_CLI_LONG_TXT_A
+          {OPT_184_CLI_LONG_TXT_A, OPT_184_HAS_ARG_LONG, 0, OPT_184_ENUM_NAME},
+    #endif
+    #ifdef OPT_184_CLI_LONG_TXT_B
+          {OPT_184_CLI_LONG_TXT_B, OPT_184_HAS_ARG_LONG, 0, OPT_184_ENUM_NAME},
+    #endif
+    #ifdef OPT_184_CLI_LONG_TXT_C
+          {OPT_184_CLI_LONG_TXT_C, OPT_184_HAS_ARG_LONG, 0, OPT_184_ENUM_NAME},
+    #endif
+    #ifdef OPT_184_CLI_LONG_TXT_D
+          {OPT_184_CLI_LONG_TXT_D, OPT_184_HAS_ARG_LONG, 0, OPT_184_ENUM_NAME},
+    #endif
+    #ifdef OPT_184_CLI_SHORT_CODE_TXT
+          {OPT_184_CLI_SHORT_CODE_TXT, OPT_184_HAS_ARG_LONG, 0, OPT_184_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_185_ENUM_NAME
+    #ifdef OPT_185_CLI_LONG_TXT_A
+          {OPT_185_CLI_LONG_TXT_A, OPT_185_HAS_ARG_LONG, 0, OPT_185_ENUM_NAME},
+    #endif
+    #ifdef OPT_185_CLI_LONG_TXT_B
+          {OPT_185_CLI_LONG_TXT_B, OPT_185_HAS_ARG_LONG, 0, OPT_185_ENUM_NAME},
+    #endif
+    #ifdef OPT_185_CLI_LONG_TXT_C
+          {OPT_185_CLI_LONG_TXT_C, OPT_185_HAS_ARG_LONG, 0, OPT_185_ENUM_NAME},
+    #endif
+    #ifdef OPT_185_CLI_LONG_TXT_D
+          {OPT_185_CLI_LONG_TXT_D, OPT_185_HAS_ARG_LONG, 0, OPT_185_ENUM_NAME},
+    #endif
+    #ifdef OPT_185_CLI_SHORT_CODE_TXT
+          {OPT_185_CLI_SHORT_CODE_TXT, OPT_185_HAS_ARG_LONG, 0, OPT_185_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_186_ENUM_NAME
+    #ifdef OPT_186_CLI_LONG_TXT_A
+          {OPT_186_CLI_LONG_TXT_A, OPT_186_HAS_ARG_LONG, 0, OPT_186_ENUM_NAME},
+    #endif
+    #ifdef OPT_186_CLI_LONG_TXT_B
+          {OPT_186_CLI_LONG_TXT_B, OPT_186_HAS_ARG_LONG, 0, OPT_186_ENUM_NAME},
+    #endif
+    #ifdef OPT_186_CLI_LONG_TXT_C
+          {OPT_186_CLI_LONG_TXT_C, OPT_186_HAS_ARG_LONG, 0, OPT_186_ENUM_NAME},
+    #endif
+    #ifdef OPT_186_CLI_LONG_TXT_D
+          {OPT_186_CLI_LONG_TXT_D, OPT_186_HAS_ARG_LONG, 0, OPT_186_ENUM_NAME},
+    #endif
+    #ifdef OPT_186_CLI_SHORT_CODE_TXT
+          {OPT_186_CLI_SHORT_CODE_TXT, OPT_186_HAS_ARG_LONG, 0, OPT_186_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_187_ENUM_NAME
+    #ifdef OPT_187_CLI_LONG_TXT_A
+          {OPT_187_CLI_LONG_TXT_A, OPT_187_HAS_ARG_LONG, 0, OPT_187_ENUM_NAME},
+    #endif
+    #ifdef OPT_187_CLI_LONG_TXT_B
+          {OPT_187_CLI_LONG_TXT_B, OPT_187_HAS_ARG_LONG, 0, OPT_187_ENUM_NAME},
+    #endif
+    #ifdef OPT_187_CLI_LONG_TXT_C
+          {OPT_187_CLI_LONG_TXT_C, OPT_187_HAS_ARG_LONG, 0, OPT_187_ENUM_NAME},
+    #endif
+    #ifdef OPT_187_CLI_LONG_TXT_D
+          {OPT_187_CLI_LONG_TXT_D, OPT_187_HAS_ARG_LONG, 0, OPT_187_ENUM_NAME},
+    #endif
+    #ifdef OPT_187_CLI_SHORT_CODE_TXT
+          {OPT_187_CLI_SHORT_CODE_TXT, OPT_187_HAS_ARG_LONG, 0, OPT_187_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_188_ENUM_NAME
+    #ifdef OPT_188_CLI_LONG_TXT_A
+          {OPT_188_CLI_LONG_TXT_A, OPT_188_HAS_ARG_LONG, 0, OPT_188_ENUM_NAME},
+    #endif
+    #ifdef OPT_188_CLI_LONG_TXT_B
+          {OPT_188_CLI_LONG_TXT_B, OPT_188_HAS_ARG_LONG, 0, OPT_188_ENUM_NAME},
+    #endif
+    #ifdef OPT_188_CLI_LONG_TXT_C
+          {OPT_188_CLI_LONG_TXT_C, OPT_188_HAS_ARG_LONG, 0, OPT_188_ENUM_NAME},
+    #endif
+    #ifdef OPT_188_CLI_LONG_TXT_D
+          {OPT_188_CLI_LONG_TXT_D, OPT_188_HAS_ARG_LONG, 0, OPT_188_ENUM_NAME},
+    #endif
+    #ifdef OPT_188_CLI_SHORT_CODE_TXT
+          {OPT_188_CLI_SHORT_CODE_TXT, OPT_188_HAS_ARG_LONG, 0, OPT_188_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_189_ENUM_NAME
+    #ifdef OPT_189_CLI_LONG_TXT_A
+          {OPT_189_CLI_LONG_TXT_A, OPT_189_HAS_ARG_LONG, 0, OPT_189_ENUM_NAME},
+    #endif
+    #ifdef OPT_189_CLI_LONG_TXT_B
+          {OPT_189_CLI_LONG_TXT_B, OPT_189_HAS_ARG_LONG, 0, OPT_189_ENUM_NAME},
+    #endif
+    #ifdef OPT_189_CLI_LONG_TXT_C
+          {OPT_189_CLI_LONG_TXT_C, OPT_189_HAS_ARG_LONG, 0, OPT_189_ENUM_NAME},
+    #endif
+    #ifdef OPT_189_CLI_LONG_TXT_D
+          {OPT_189_CLI_LONG_TXT_D, OPT_189_HAS_ARG_LONG, 0, OPT_189_ENUM_NAME},
+    #endif
+    #ifdef OPT_189_CLI_SHORT_CODE_TXT
+          {OPT_189_CLI_SHORT_CODE_TXT, OPT_189_HAS_ARG_LONG, 0, OPT_189_ENUM_NAME},
+    #endif
+#endif
+
+#ifdef OPT_190_ENUM_NAME
+    #ifdef OPT_190_CLI_LONG_TXT_A
+          {OPT_190_CLI_LONG_TXT_A, OPT_190_HAS_ARG_LONG, 0, OPT_190_ENUM_NAME},
+    #endif
+    #ifdef OPT_190_CLI_LONG_TXT_B
+          {OPT_190_CLI_LONG_TXT_B, OPT_190_HAS_ARG_LONG, 0, OPT_190_ENUM_NAME},
+    #endif
+    #ifdef OPT_190_CLI_LONG_TXT_C
+          {OPT_190_CLI_LONG_TXT_C, OPT_190_HAS_ARG_LONG, 0, OPT_190_ENUM_NAME},
+    #endif
+    #ifdef OPT_190_CLI_LONG_TXT_D
+          {OPT_190_CLI_LONG_TXT_D, OPT_190_HAS_ARG_LONG, 0, OPT_190_ENUM_NAME},
+    #endif
+    #ifdef OPT_190_CLI_SHORT_CODE_TXT
+          {OPT_190_CLI_SHORT_CODE_TXT, OPT_190_HAS_ARG_LONG, 0, OPT_190_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_191_ENUM_NAME
+    #ifdef OPT_191_CLI_LONG_TXT_A
+          {OPT_191_CLI_LONG_TXT_A, OPT_191_HAS_ARG_LONG, 0, OPT_191_ENUM_NAME},
+    #endif
+    #ifdef OPT_191_CLI_LONG_TXT_B
+          {OPT_191_CLI_LONG_TXT_B, OPT_191_HAS_ARG_LONG, 0, OPT_191_ENUM_NAME},
+    #endif
+    #ifdef OPT_191_CLI_LONG_TXT_C
+          {OPT_191_CLI_LONG_TXT_C, OPT_191_HAS_ARG_LONG, 0, OPT_191_ENUM_NAME},
+    #endif
+    #ifdef OPT_191_CLI_LONG_TXT_D
+          {OPT_191_CLI_LONG_TXT_D, OPT_191_HAS_ARG_LONG, 0, OPT_191_ENUM_NAME},
+    #endif
+    #ifdef OPT_191_CLI_SHORT_CODE_TXT
+          {OPT_191_CLI_SHORT_CODE_TXT, OPT_191_HAS_ARG_LONG, 0, OPT_191_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_192_ENUM_NAME
+    #ifdef OPT_192_CLI_LONG_TXT_A
+          {OPT_192_CLI_LONG_TXT_A, OPT_192_HAS_ARG_LONG, 0, OPT_192_ENUM_NAME},
+    #endif
+    #ifdef OPT_192_CLI_LONG_TXT_B
+          {OPT_192_CLI_LONG_TXT_B, OPT_192_HAS_ARG_LONG, 0, OPT_192_ENUM_NAME},
+    #endif
+    #ifdef OPT_192_CLI_LONG_TXT_C
+          {OPT_192_CLI_LONG_TXT_C, OPT_192_HAS_ARG_LONG, 0, OPT_192_ENUM_NAME},
+    #endif
+    #ifdef OPT_192_CLI_LONG_TXT_D
+          {OPT_192_CLI_LONG_TXT_D, OPT_192_HAS_ARG_LONG, 0, OPT_192_ENUM_NAME},
+    #endif
+    #ifdef OPT_192_CLI_SHORT_CODE_TXT
+          {OPT_192_CLI_SHORT_CODE_TXT, OPT_192_HAS_ARG_LONG, 0, OPT_192_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_193_ENUM_NAME
+    #ifdef OPT_193_CLI_LONG_TXT_A
+          {OPT_193_CLI_LONG_TXT_A, OPT_193_HAS_ARG_LONG, 0, OPT_193_ENUM_NAME},
+    #endif
+    #ifdef OPT_193_CLI_LONG_TXT_B
+          {OPT_193_CLI_LONG_TXT_B, OPT_193_HAS_ARG_LONG, 0, OPT_193_ENUM_NAME},
+    #endif
+    #ifdef OPT_193_CLI_LONG_TXT_C
+          {OPT_193_CLI_LONG_TXT_C, OPT_193_HAS_ARG_LONG, 0, OPT_193_ENUM_NAME},
+    #endif
+    #ifdef OPT_193_CLI_LONG_TXT_D
+          {OPT_193_CLI_LONG_TXT_D, OPT_193_HAS_ARG_LONG, 0, OPT_193_ENUM_NAME},
+    #endif
+    #ifdef OPT_193_CLI_SHORT_CODE_TXT
+          {OPT_193_CLI_SHORT_CODE_TXT, OPT_193_HAS_ARG_LONG, 0, OPT_193_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_194_ENUM_NAME
+    #ifdef OPT_194_CLI_LONG_TXT_A
+          {OPT_194_CLI_LONG_TXT_A, OPT_194_HAS_ARG_LONG, 0, OPT_194_ENUM_NAME},
+    #endif
+    #ifdef OPT_194_CLI_LONG_TXT_B
+          {OPT_194_CLI_LONG_TXT_B, OPT_194_HAS_ARG_LONG, 0, OPT_194_ENUM_NAME},
+    #endif
+    #ifdef OPT_194_CLI_LONG_TXT_C
+          {OPT_194_CLI_LONG_TXT_C, OPT_194_HAS_ARG_LONG, 0, OPT_194_ENUM_NAME},
+    #endif
+    #ifdef OPT_194_CLI_LONG_TXT_D
+          {OPT_194_CLI_LONG_TXT_D, OPT_194_HAS_ARG_LONG, 0, OPT_194_ENUM_NAME},
+    #endif
+    #ifdef OPT_194_CLI_SHORT_CODE_TXT
+          {OPT_194_CLI_SHORT_CODE_TXT, OPT_194_HAS_ARG_LONG, 0, OPT_194_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_195_ENUM_NAME
+    #ifdef OPT_195_CLI_LONG_TXT_A
+          {OPT_195_CLI_LONG_TXT_A, OPT_195_HAS_ARG_LONG, 0, OPT_195_ENUM_NAME},
+    #endif
+    #ifdef OPT_195_CLI_LONG_TXT_B
+          {OPT_195_CLI_LONG_TXT_B, OPT_195_HAS_ARG_LONG, 0, OPT_195_ENUM_NAME},
+    #endif
+    #ifdef OPT_195_CLI_LONG_TXT_C
+          {OPT_195_CLI_LONG_TXT_C, OPT_195_HAS_ARG_LONG, 0, OPT_195_ENUM_NAME},
+    #endif
+    #ifdef OPT_195_CLI_LONG_TXT_D
+          {OPT_195_CLI_LONG_TXT_D, OPT_195_HAS_ARG_LONG, 0, OPT_195_ENUM_NAME},
+    #endif
+    #ifdef OPT_195_CLI_SHORT_CODE_TXT
+          {OPT_195_CLI_SHORT_CODE_TXT, OPT_195_HAS_ARG_LONG, 0, OPT_195_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_196_ENUM_NAME
+    #ifdef OPT_196_CLI_LONG_TXT_A
+          {OPT_196_CLI_LONG_TXT_A, OPT_196_HAS_ARG_LONG, 0, OPT_196_ENUM_NAME},
+    #endif
+    #ifdef OPT_196_CLI_LONG_TXT_B
+          {OPT_196_CLI_LONG_TXT_B, OPT_196_HAS_ARG_LONG, 0, OPT_196_ENUM_NAME},
+    #endif
+    #ifdef OPT_196_CLI_LONG_TXT_C
+          {OPT_196_CLI_LONG_TXT_C, OPT_196_HAS_ARG_LONG, 0, OPT_196_ENUM_NAME},
+    #endif
+    #ifdef OPT_196_CLI_LONG_TXT_D
+          {OPT_196_CLI_LONG_TXT_D, OPT_196_HAS_ARG_LONG, 0, OPT_196_ENUM_NAME},
+    #endif
+    #ifdef OPT_196_CLI_SHORT_CODE_TXT
+          {OPT_196_CLI_SHORT_CODE_TXT, OPT_196_HAS_ARG_LONG, 0, OPT_196_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_197_ENUM_NAME
+    #ifdef OPT_197_CLI_LONG_TXT_A
+          {OPT_197_CLI_LONG_TXT_A, OPT_197_HAS_ARG_LONG, 0, OPT_197_ENUM_NAME},
+    #endif
+    #ifdef OPT_197_CLI_LONG_TXT_B
+          {OPT_197_CLI_LONG_TXT_B, OPT_197_HAS_ARG_LONG, 0, OPT_197_ENUM_NAME},
+    #endif
+    #ifdef OPT_197_CLI_LONG_TXT_C
+          {OPT_197_CLI_LONG_TXT_C, OPT_197_HAS_ARG_LONG, 0, OPT_197_ENUM_NAME},
+    #endif
+    #ifdef OPT_197_CLI_LONG_TXT_D
+          {OPT_197_CLI_LONG_TXT_D, OPT_197_HAS_ARG_LONG, 0, OPT_197_ENUM_NAME},
+    #endif
+    #ifdef OPT_197_CLI_SHORT_CODE_TXT
+          {OPT_197_CLI_SHORT_CODE_TXT, OPT_197_HAS_ARG_LONG, 0, OPT_197_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_198_ENUM_NAME
+    #ifdef OPT_198_CLI_LONG_TXT_A
+          {OPT_198_CLI_LONG_TXT_A, OPT_198_HAS_ARG_LONG, 0, OPT_198_ENUM_NAME},
+    #endif
+    #ifdef OPT_198_CLI_LONG_TXT_B
+          {OPT_198_CLI_LONG_TXT_B, OPT_198_HAS_ARG_LONG, 0, OPT_198_ENUM_NAME},
+    #endif
+    #ifdef OPT_198_CLI_LONG_TXT_C
+          {OPT_198_CLI_LONG_TXT_C, OPT_198_HAS_ARG_LONG, 0, OPT_198_ENUM_NAME},
+    #endif
+    #ifdef OPT_198_CLI_LONG_TXT_D
+          {OPT_198_CLI_LONG_TXT_D, OPT_198_HAS_ARG_LONG, 0, OPT_198_ENUM_NAME},
+    #endif
+    #ifdef OPT_198_CLI_SHORT_CODE_TXT
+          {OPT_198_CLI_SHORT_CODE_TXT, OPT_198_HAS_ARG_LONG, 0, OPT_198_ENUM_NAME},
+    #endif
+#endif
+#ifdef OPT_199_ENUM_NAME
+    #ifdef OPT_199_CLI_LONG_TXT_A
+          {OPT_199_CLI_LONG_TXT_A, OPT_199_HAS_ARG_LONG, 0, OPT_199_ENUM_NAME},
+    #endif
+    #ifdef OPT_199_CLI_LONG_TXT_B
+          {OPT_199_CLI_LONG_TXT_B, OPT_199_HAS_ARG_LONG, 0, OPT_199_ENUM_NAME},
+    #endif
+    #ifdef OPT_199_CLI_LONG_TXT_C
+          {OPT_199_CLI_LONG_TXT_C, OPT_199_HAS_ARG_LONG, 0, OPT_199_ENUM_NAME},
+    #endif
+    #ifdef OPT_199_CLI_LONG_TXT_D
+          {OPT_199_CLI_LONG_TXT_D, OPT_199_HAS_ARG_LONG, 0, OPT_199_ENUM_NAME},
+    #endif
+    #ifdef OPT_199_CLI_SHORT_CODE_TXT
+          {OPT_199_CLI_SHORT_CODE_TXT, OPT_199_HAS_ARG_LONG, 0, OPT_199_ENUM_NAME},
+    #endif
+#endif
+
+    {0, 0, 0, 0}  /* required per 'getopt()' fnc family specifications */
+};
+
+
+typedef struct opt_props_tt {
+    const char*  p_txt_help;
+    uint32_t     incompat_grps;  /* bitset */
+} opt_props_t;
+
+#define TXT_HELP_INVALID_ITEM  "__INVALID_ITEM__"
+
+/* ==== PRIVATE FUNCTIONS ================================================== */
+
+static opt_props_t opt_get_props(cli_opt_t opt)
+{
+    opt_props_t props = {TXT_HELP_INVALID_ITEM, OPT_GRP_NONE};
+    
+    /* cannot be done done via array indexing, because cli_opt_t IS NOT A CONSECUTIVE LIST */
+    switch (opt)
+    {
+        case OPT_00_NO_OPTION:
+            props.p_txt_help    = "";
+            props.incompat_grps = OPT_GRP_NONE;
+        break;
+        
+      #ifdef OPT_01_ENUM_NAME
+        case OPT_01_ENUM_NAME:
+            props.p_txt_help    = OPT_01_TXT_HELP;
+            props.incompat_grps = OPT_01_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_02_ENUM_NAME
+        case OPT_02_ENUM_NAME:
+            props.p_txt_help    = OPT_02_TXT_HELP;
+            props.incompat_grps = OPT_02_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_03_ENUM_NAME
+        case OPT_03_ENUM_NAME:
+            props.p_txt_help    = OPT_03_TXT_HELP;
+            props.incompat_grps = OPT_03_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_04_ENUM_NAME
+        case OPT_04_ENUM_NAME:
+            props.p_txt_help    = OPT_04_TXT_HELP;
+            props.incompat_grps = OPT_04_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_05_ENUM_NAME
+        case OPT_05_ENUM_NAME:
+            props.p_txt_help    = OPT_05_TXT_HELP;
+            props.incompat_grps = OPT_05_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_06_ENUM_NAME
+        case OPT_06_ENUM_NAME:
+            props.p_txt_help    = OPT_06_TXT_HELP;
+            props.incompat_grps = OPT_06_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_07_ENUM_NAME
+        case OPT_07_ENUM_NAME:
+            props.p_txt_help    = OPT_07_TXT_HELP;
+            props.incompat_grps = OPT_07_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_08_ENUM_NAME
+        case OPT_08_ENUM_NAME:
+            props.p_txt_help    = OPT_08_TXT_HELP;
+            props.incompat_grps = OPT_08_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_09_ENUM_NAME
+        case OPT_09_ENUM_NAME:
+            props.p_txt_help    = OPT_09_TXT_HELP;
+            props.incompat_grps = OPT_09_INCOMPAT_GRPS;
+        break;
+      #endif
+        
+      #ifdef OPT_10_ENUM_NAME
+        case OPT_10_ENUM_NAME:
+            props.p_txt_help    = OPT_10_TXT_HELP;
+            props.incompat_grps = OPT_10_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_11_ENUM_NAME
+        case OPT_11_ENUM_NAME:
+            props.p_txt_help    = OPT_11_TXT_HELP;
+            props.incompat_grps = OPT_11_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_12_ENUM_NAME
+        case OPT_12_ENUM_NAME:
+            props.p_txt_help    = OPT_12_TXT_HELP;
+            props.incompat_grps = OPT_12_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_13_ENUM_NAME
+        case OPT_13_ENUM_NAME:
+            props.p_txt_help    = OPT_13_TXT_HELP;
+            props.incompat_grps = OPT_13_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_14_ENUM_NAME
+        case OPT_14_ENUM_NAME:
+            props.p_txt_help    = OPT_14_TXT_HELP;
+            props.incompat_grps = OPT_14_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_15_ENUM_NAME
+        case OPT_15_ENUM_NAME:
+            props.p_txt_help    = OPT_15_TXT_HELP;
+            props.incompat_grps = OPT_15_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_16_ENUM_NAME
+        case OPT_16_ENUM_NAME:
+            props.p_txt_help    = OPT_16_TXT_HELP;
+            props.incompat_grps = OPT_16_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_17_ENUM_NAME
+        case OPT_17_ENUM_NAME:
+            props.p_txt_help    = OPT_17_TXT_HELP;
+            props.incompat_grps = OPT_17_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_18_ENUM_NAME
+        case OPT_18_ENUM_NAME:
+            props.p_txt_help    = OPT_18_TXT_HELP;
+            props.incompat_grps = OPT_18_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_19_ENUM_NAME
+        case OPT_19_ENUM_NAME:
+            props.p_txt_help    = OPT_19_TXT_HELP;
+            props.incompat_grps = OPT_19_INCOMPAT_GRPS;
+        break;
+      #endif
+        
+      #ifdef OPT_20_ENUM_NAME
+        case OPT_20_ENUM_NAME:
+            props.p_txt_help    = OPT_20_TXT_HELP;
+            props.incompat_grps = OPT_20_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_21_ENUM_NAME
+        case OPT_21_ENUM_NAME:
+            props.p_txt_help    = OPT_21_TXT_HELP;
+            props.incompat_grps = OPT_21_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_22_ENUM_NAME
+        case OPT_22_ENUM_NAME:
+            props.p_txt_help    = OPT_22_TXT_HELP;
+            props.incompat_grps = OPT_22_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_23_ENUM_NAME
+        case OPT_23_ENUM_NAME:
+            props.p_txt_help    = OPT_23_TXT_HELP;
+            props.incompat_grps = OPT_23_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_24_ENUM_NAME
+        case OPT_24_ENUM_NAME:
+            props.p_txt_help    = OPT_24_TXT_HELP;
+            props.incompat_grps = OPT_24_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_25_ENUM_NAME
+        case OPT_25_ENUM_NAME:
+            props.p_txt_help    = OPT_25_TXT_HELP;
+            props.incompat_grps = OPT_25_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_26_ENUM_NAME
+        case OPT_26_ENUM_NAME:
+            props.p_txt_help    = OPT_26_TXT_HELP;
+            props.incompat_grps = OPT_26_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_27_ENUM_NAME
+        case OPT_27_ENUM_NAME:
+            props.p_txt_help    = OPT_27_TXT_HELP;
+            props.incompat_grps = OPT_27_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_28_ENUM_NAME
+        case OPT_28_ENUM_NAME:
+            props.p_txt_help    = OPT_28_TXT_HELP;
+            props.incompat_grps = OPT_28_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_29_ENUM_NAME
+        case OPT_29_ENUM_NAME:
+            props.p_txt_help    = OPT_29_TXT_HELP;
+            props.incompat_grps = OPT_29_INCOMPAT_GRPS;
+        break;
+      #endif
+      
+      #ifdef OPT_30_ENUM_NAME
+        case OPT_30_ENUM_NAME:
+            props.p_txt_help    = OPT_30_TXT_HELP;
+            props.incompat_grps = OPT_30_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_31_ENUM_NAME
+        case OPT_31_ENUM_NAME:
+            props.p_txt_help    = OPT_31_TXT_HELP;
+            props.incompat_grps = OPT_31_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_32_ENUM_NAME
+        case OPT_32_ENUM_NAME:
+            props.p_txt_help    = OPT_32_TXT_HELP;
+            props.incompat_grps = OPT_32_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_33_ENUM_NAME
+        case OPT_33_ENUM_NAME:
+            props.p_txt_help    = OPT_33_TXT_HELP;
+            props.incompat_grps = OPT_33_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_34_ENUM_NAME
+        case OPT_34_ENUM_NAME:
+            props.p_txt_help    = OPT_34_TXT_HELP;
+            props.incompat_grps = OPT_34_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_35_ENUM_NAME
+        case OPT_35_ENUM_NAME:
+            props.p_txt_help    = OPT_35_TXT_HELP;
+            props.incompat_grps = OPT_35_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_36_ENUM_NAME
+        case OPT_36_ENUM_NAME:
+            props.p_txt_help    = OPT_36_TXT_HELP;
+            props.incompat_grps = OPT_36_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_37_ENUM_NAME
+        case OPT_37_ENUM_NAME:
+            props.p_txt_help    = OPT_37_TXT_HELP;
+            props.incompat_grps = OPT_37_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_38_ENUM_NAME
+        case OPT_38_ENUM_NAME:
+            props.p_txt_help    = OPT_38_TXT_HELP;
+            props.incompat_grps = OPT_38_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_39_ENUM_NAME
+        case OPT_39_ENUM_NAME:
+            props.p_txt_help    = OPT_39_TXT_HELP;
+            props.incompat_grps = OPT_39_INCOMPAT_GRPS;
+        break;
+      #endif
+        
+      #ifdef OPT_40_ENUM_NAME
+        case OPT_40_ENUM_NAME:
+            props.p_txt_help    = OPT_40_TXT_HELP;
+            props.incompat_grps = OPT_40_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_41_ENUM_NAME
+        case OPT_41_ENUM_NAME:
+            props.p_txt_help    = OPT_41_TXT_HELP;
+            props.incompat_grps = OPT_41_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_42_ENUM_NAME
+        case OPT_42_ENUM_NAME:
+            props.p_txt_help    = OPT_42_TXT_HELP;
+            props.incompat_grps = OPT_42_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_43_ENUM_NAME
+        case OPT_43_ENUM_NAME:
+            props.p_txt_help    = OPT_43_TXT_HELP;
+            props.incompat_grps = OPT_43_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_44_ENUM_NAME
+        case OPT_44_ENUM_NAME:
+            props.p_txt_help    = OPT_44_TXT_HELP;
+            props.incompat_grps = OPT_44_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_45_ENUM_NAME
+        case OPT_45_ENUM_NAME:
+            props.p_txt_help    = OPT_45_TXT_HELP;
+            props.incompat_grps = OPT_45_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_46_ENUM_NAME
+        case OPT_46_ENUM_NAME:
+            props.p_txt_help    = OPT_46_TXT_HELP;
+            props.incompat_grps = OPT_46_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_47_ENUM_NAME
+        case OPT_47_ENUM_NAME:
+            props.p_txt_help    = OPT_47_TXT_HELP;
+            props.incompat_grps = OPT_47_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_48_ENUM_NAME
+        case OPT_48_ENUM_NAME:
+            props.p_txt_help    = OPT_48_TXT_HELP;
+            props.incompat_grps = OPT_48_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_49_ENUM_NAME
+        case OPT_49_ENUM_NAME:
+            props.p_txt_help    = OPT_49_TXT_HELP;
+            props.incompat_grps = OPT_49_INCOMPAT_GRPS;
+        break;
+      #endif
+        
+      #ifdef OPT_50_ENUM_NAME
+        case OPT_50_ENUM_NAME:
+            props.p_txt_help    = OPT_50_TXT_HELP;
+            props.incompat_grps = OPT_50_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_51_ENUM_NAME
+        case OPT_51_ENUM_NAME:
+            props.p_txt_help    = OPT_51_TXT_HELP;
+            props.incompat_grps = OPT_51_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_52_ENUM_NAME
+        case OPT_52_ENUM_NAME:
+            props.p_txt_help    = OPT_52_TXT_HELP;
+            props.incompat_grps = OPT_52_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_53_ENUM_NAME
+        case OPT_53_ENUM_NAME:
+            props.p_txt_help    = OPT_53_TXT_HELP;
+            props.incompat_grps = OPT_53_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_54_ENUM_NAME
+        case OPT_54_ENUM_NAME:
+            props.p_txt_help    = OPT_54_TXT_HELP;
+            props.incompat_grps = OPT_54_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_55_ENUM_NAME
+        case OPT_55_ENUM_NAME:
+            props.p_txt_help    = OPT_55_TXT_HELP;
+            props.incompat_grps = OPT_55_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_56_ENUM_NAME
+        case OPT_56_ENUM_NAME:
+            props.p_txt_help    = OPT_56_TXT_HELP;
+            props.incompat_grps = OPT_56_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_57_ENUM_NAME
+        case OPT_57_ENUM_NAME:
+            props.p_txt_help    = OPT_57_TXT_HELP;
+            props.incompat_grps = OPT_57_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_58_ENUM_NAME
+        case OPT_58_ENUM_NAME:
+            props.p_txt_help    = OPT_58_TXT_HELP;
+            props.incompat_grps = OPT_58_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_59_ENUM_NAME
+        case OPT_59_ENUM_NAME:
+            props.p_txt_help    = OPT_59_TXT_HELP;
+            props.incompat_grps = OPT_59_INCOMPAT_GRPS;
+        break;
+      #endif
+        
+      #ifdef OPT_60_ENUM_NAME
+        case OPT_60_ENUM_NAME:
+            props.p_txt_help    = OPT_60_TXT_HELP;
+            props.incompat_grps = OPT_60_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_61_ENUM_NAME
+        case OPT_61_ENUM_NAME:
+            props.p_txt_help    = OPT_61_TXT_HELP;
+            props.incompat_grps = OPT_61_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_62_ENUM_NAME
+        case OPT_62_ENUM_NAME:
+            props.p_txt_help    = OPT_62_TXT_HELP;
+            props.incompat_grps = OPT_62_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_63_ENUM_NAME
+        case OPT_63_ENUM_NAME:
+            props.p_txt_help    = OPT_63_TXT_HELP;
+            props.incompat_grps = OPT_63_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_64_ENUM_NAME
+        case OPT_64_ENUM_NAME:
+            props.p_txt_help    = OPT_64_TXT_HELP;
+            props.incompat_grps = OPT_64_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_65_ENUM_NAME
+        case OPT_65_ENUM_NAME:
+            props.p_txt_help    = OPT_65_TXT_HELP;
+            props.incompat_grps = OPT_65_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_66_ENUM_NAME
+        case OPT_66_ENUM_NAME:
+            props.p_txt_help    = OPT_66_TXT_HELP;
+            props.incompat_grps = OPT_66_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_67_ENUM_NAME
+        case OPT_67_ENUM_NAME:
+            props.p_txt_help    = OPT_67_TXT_HELP;
+            props.incompat_grps = OPT_67_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_68_ENUM_NAME
+        case OPT_68_ENUM_NAME:
+            props.p_txt_help    = OPT_68_TXT_HELP;
+            props.incompat_grps = OPT_68_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_69_ENUM_NAME
+        case OPT_69_ENUM_NAME:
+            props.p_txt_help    = OPT_69_TXT_HELP;
+            props.incompat_grps = OPT_69_INCOMPAT_GRPS;
+        break;
+      #endif
+        
+      #ifdef OPT_70_ENUM_NAME
+        case OPT_70_ENUM_NAME:
+            props.p_txt_help    = OPT_70_TXT_HELP;
+            props.incompat_grps = OPT_70_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_71_ENUM_NAME
+        case OPT_71_ENUM_NAME:
+            props.p_txt_help    = OPT_71_TXT_HELP;
+            props.incompat_grps = OPT_71_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_72_ENUM_NAME
+        case OPT_72_ENUM_NAME:
+            props.p_txt_help    = OPT_72_TXT_HELP;
+            props.incompat_grps = OPT_72_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_73_ENUM_NAME
+        case OPT_73_ENUM_NAME:
+            props.p_txt_help    = OPT_73_TXT_HELP;
+            props.incompat_grps = OPT_73_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_74_ENUM_NAME
+        case OPT_74_ENUM_NAME:
+            props.p_txt_help    = OPT_74_TXT_HELP;
+            props.incompat_grps = OPT_74_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_75_ENUM_NAME
+        case OPT_75_ENUM_NAME:
+            props.p_txt_help    = OPT_75_TXT_HELP;
+            props.incompat_grps = OPT_75_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_76_ENUM_NAME
+        case OPT_76_ENUM_NAME:
+            props.p_txt_help    = OPT_76_TXT_HELP;
+            props.incompat_grps = OPT_76_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_77_ENUM_NAME
+        case OPT_77_ENUM_NAME:
+            props.p_txt_help    = OPT_77_TXT_HELP;
+            props.incompat_grps = OPT_77_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_78_ENUM_NAME
+        case OPT_78_ENUM_NAME:
+            props.p_txt_help    = OPT_78_TXT_HELP;
+            props.incompat_grps = OPT_78_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_79_ENUM_NAME
+        case OPT_79_ENUM_NAME:
+            props.p_txt_help    = OPT_79_TXT_HELP;
+            props.incompat_grps = OPT_79_INCOMPAT_GRPS;
+        break;
+      #endif
+        
+      #ifdef OPT_80_ENUM_NAME
+        case OPT_80_ENUM_NAME:
+            props.p_txt_help    = OPT_80_TXT_HELP;
+            props.incompat_grps = OPT_80_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_81_ENUM_NAME
+        case OPT_81_ENUM_NAME:
+            props.p_txt_help    = OPT_81_TXT_HELP;
+            props.incompat_grps = OPT_81_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_82_ENUM_NAME
+        case OPT_82_ENUM_NAME:
+            props.p_txt_help    = OPT_82_TXT_HELP;
+            props.incompat_grps = OPT_82_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_83_ENUM_NAME
+        case OPT_83_ENUM_NAME:
+            props.p_txt_help    = OPT_83_TXT_HELP;
+            props.incompat_grps = OPT_83_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_84_ENUM_NAME
+        case OPT_84_ENUM_NAME:
+            props.p_txt_help    = OPT_84_TXT_HELP;
+            props.incompat_grps = OPT_84_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_85_ENUM_NAME
+        case OPT_85_ENUM_NAME:
+            props.p_txt_help    = OPT_85_TXT_HELP;
+            props.incompat_grps = OPT_85_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_86_ENUM_NAME
+        case OPT_86_ENUM_NAME:
+            props.p_txt_help    = OPT_86_TXT_HELP;
+            props.incompat_grps = OPT_86_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_87_ENUM_NAME
+        case OPT_87_ENUM_NAME:
+            props.p_txt_help    = OPT_87_TXT_HELP;
+            props.incompat_grps = OPT_87_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_88_ENUM_NAME
+        case OPT_88_ENUM_NAME:
+            props.p_txt_help    = OPT_88_TXT_HELP;
+            props.incompat_grps = OPT_88_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_89_ENUM_NAME
+        case OPT_89_ENUM_NAME:
+            props.p_txt_help    = OPT_89_TXT_HELP;
+            props.incompat_grps = OPT_89_INCOMPAT_GRPS;
+        break;
+      #endif
+        
+      #ifdef OPT_90_ENUM_NAME
+        case OPT_90_ENUM_NAME:
+            props.p_txt_help    = OPT_90_TXT_HELP;
+            props.incompat_grps = OPT_90_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_91_ENUM_NAME
+        case OPT_91_ENUM_NAME:
+            props.p_txt_help    = OPT_91_TXT_HELP;
+            props.incompat_grps = OPT_91_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_92_ENUM_NAME
+        case OPT_92_ENUM_NAME:
+            props.p_txt_help    = OPT_92_TXT_HELP;
+            props.incompat_grps = OPT_92_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_93_ENUM_NAME
+        case OPT_93_ENUM_NAME:
+            props.p_txt_help    = OPT_93_TXT_HELP;
+            props.incompat_grps = OPT_93_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_94_ENUM_NAME
+        case OPT_94_ENUM_NAME:
+            props.p_txt_help    = OPT_94_TXT_HELP;
+            props.incompat_grps = OPT_94_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_95_ENUM_NAME
+        case OPT_95_ENUM_NAME:
+            props.p_txt_help    = OPT_95_TXT_HELP;
+            props.incompat_grps = OPT_95_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_96_ENUM_NAME
+        case OPT_96_ENUM_NAME:
+            props.p_txt_help    = OPT_96_TXT_HELP;
+            props.incompat_grps = OPT_96_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_97_ENUM_NAME
+        case OPT_97_ENUM_NAME:
+            props.p_txt_help    = OPT_97_TXT_HELP;
+            props.incompat_grps = OPT_97_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_98_ENUM_NAME
+        case OPT_98_ENUM_NAME:
+            props.p_txt_help    = OPT_98_TXT_HELP;
+            props.incompat_grps = OPT_98_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_99_ENUM_NAME
+        case OPT_99_ENUM_NAME:
+            props.p_txt_help    = OPT_99_TXT_HELP;
+            props.incompat_grps = OPT_99_INCOMPAT_GRPS;
+        break;
+      #endif
+        
+      #ifdef OPT_100_ENUM_NAME
+        case OPT_100_ENUM_NAME:
+            props.p_txt_help    = OPT_100_TXT_HELP;
+            props.incompat_grps = OPT_100_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_101_ENUM_NAME
+        case OPT_101_ENUM_NAME:
+            props.p_txt_help    = OPT_101_TXT_HELP;
+            props.incompat_grps = OPT_101_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_102_ENUM_NAME
+        case OPT_102_ENUM_NAME:
+            props.p_txt_help    = OPT_102_TXT_HELP;
+            props.incompat_grps = OPT_102_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_103_ENUM_NAME
+        case OPT_103_ENUM_NAME:
+            props.p_txt_help    = OPT_103_TXT_HELP;
+            props.incompat_grps = OPT_103_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_104_ENUM_NAME
+        case OPT_104_ENUM_NAME:
+            props.p_txt_help    = OPT_104_TXT_HELP;
+            props.incompat_grps = OPT_104_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_105_ENUM_NAME
+        case OPT_105_ENUM_NAME:
+            props.p_txt_help    = OPT_105_TXT_HELP;
+            props.incompat_grps = OPT_105_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_106_ENUM_NAME
+        case OPT_106_ENUM_NAME:
+            props.p_txt_help    = OPT_106_TXT_HELP;
+            props.incompat_grps = OPT_106_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_107_ENUM_NAME
+        case OPT_107_ENUM_NAME:
+            props.p_txt_help    = OPT_107_TXT_HELP;
+            props.incompat_grps = OPT_107_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_108_ENUM_NAME
+        case OPT_108_ENUM_NAME:
+            props.p_txt_help    = OPT_108_TXT_HELP;
+            props.incompat_grps = OPT_108_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_109_ENUM_NAME
+        case OPT_109_ENUM_NAME:
+            props.p_txt_help    = OPT_109_TXT_HELP;
+            props.incompat_grps = OPT_109_INCOMPAT_GRPS;
+        break;
+      #endif
+        
+      #ifdef OPT_110_ENUM_NAME
+        case OPT_110_ENUM_NAME:
+            props.p_txt_help    = OPT_110_TXT_HELP;
+            props.incompat_grps = OPT_110_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_111_ENUM_NAME
+        case OPT_111_ENUM_NAME:
+            props.p_txt_help    = OPT_111_TXT_HELP;
+            props.incompat_grps = OPT_111_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_112_ENUM_NAME
+        case OPT_112_ENUM_NAME:
+            props.p_txt_help    = OPT_112_TXT_HELP;
+            props.incompat_grps = OPT_112_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_113_ENUM_NAME
+        case OPT_113_ENUM_NAME:
+            props.p_txt_help    = OPT_113_TXT_HELP;
+            props.incompat_grps = OPT_113_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_114_ENUM_NAME
+        case OPT_114_ENUM_NAME:
+            props.p_txt_help    = OPT_114_TXT_HELP;
+            props.incompat_grps = OPT_114_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_115_ENUM_NAME
+        case OPT_115_ENUM_NAME:
+            props.p_txt_help    = OPT_115_TXT_HELP;
+            props.incompat_grps = OPT_115_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_116_ENUM_NAME
+        case OPT_116_ENUM_NAME:
+            props.p_txt_help    = OPT_116_TXT_HELP;
+            props.incompat_grps = OPT_116_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_117_ENUM_NAME
+        case OPT_117_ENUM_NAME:
+            props.p_txt_help    = OPT_117_TXT_HELP;
+            props.incompat_grps = OPT_117_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_118_ENUM_NAME
+        case OPT_118_ENUM_NAME:
+            props.p_txt_help    = OPT_118_TXT_HELP;
+            props.incompat_grps = OPT_118_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_119_ENUM_NAME
+        case OPT_119_ENUM_NAME:
+            props.p_txt_help    = OPT_119_TXT_HELP;
+            props.incompat_grps = OPT_119_INCOMPAT_GRPS;
+        break;
+      #endif
+        
+      #ifdef OPT_120_ENUM_NAME
+        case OPT_120_ENUM_NAME:
+            props.p_txt_help    = OPT_120_TXT_HELP;
+            props.incompat_grps = OPT_120_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_121_ENUM_NAME
+        case OPT_121_ENUM_NAME:
+            props.p_txt_help    = OPT_121_TXT_HELP;
+            props.incompat_grps = OPT_121_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_122_ENUM_NAME
+        case OPT_122_ENUM_NAME:
+            props.p_txt_help    = OPT_122_TXT_HELP;
+            props.incompat_grps = OPT_122_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_123_ENUM_NAME
+        case OPT_123_ENUM_NAME:
+            props.p_txt_help    = OPT_123_TXT_HELP;
+            props.incompat_grps = OPT_123_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_124_ENUM_NAME
+        case OPT_124_ENUM_NAME:
+            props.p_txt_help    = OPT_124_TXT_HELP;
+            props.incompat_grps = OPT_124_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_125_ENUM_NAME
+        case OPT_125_ENUM_NAME:
+            props.p_txt_help    = OPT_125_TXT_HELP;
+            props.incompat_grps = OPT_125_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_126_ENUM_NAME
+        case OPT_126_ENUM_NAME:
+            props.p_txt_help    = OPT_126_TXT_HELP;
+            props.incompat_grps = OPT_126_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_127_ENUM_NAME
+        case OPT_127_ENUM_NAME:
+            props.p_txt_help    = OPT_127_TXT_HELP;
+            props.incompat_grps = OPT_127_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_128_ENUM_NAME
+        case OPT_128_ENUM_NAME:
+            props.p_txt_help    = OPT_128_TXT_HELP;
+            props.incompat_grps = OPT_128_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_129_ENUM_NAME
+        case OPT_129_ENUM_NAME:
+            props.p_txt_help    = OPT_129_TXT_HELP;
+            props.incompat_grps = OPT_129_INCOMPAT_GRPS;
+        break;
+      #endif
+      
+      #ifdef OPT_130_ENUM_NAME
+        case OPT_130_ENUM_NAME:
+            props.p_txt_help    = OPT_130_TXT_HELP;
+            props.incompat_grps = OPT_130_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_131_ENUM_NAME
+        case OPT_131_ENUM_NAME:
+            props.p_txt_help    = OPT_131_TXT_HELP;
+            props.incompat_grps = OPT_131_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_132_ENUM_NAME
+        case OPT_132_ENUM_NAME:
+            props.p_txt_help    = OPT_132_TXT_HELP;
+            props.incompat_grps = OPT_132_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_133_ENUM_NAME
+        case OPT_133_ENUM_NAME:
+            props.p_txt_help    = OPT_133_TXT_HELP;
+            props.incompat_grps = OPT_133_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_134_ENUM_NAME
+        case OPT_134_ENUM_NAME:
+            props.p_txt_help    = OPT_134_TXT_HELP;
+            props.incompat_grps = OPT_134_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_135_ENUM_NAME
+        case OPT_135_ENUM_NAME:
+            props.p_txt_help    = OPT_135_TXT_HELP;
+            props.incompat_grps = OPT_135_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_136_ENUM_NAME
+        case OPT_136_ENUM_NAME:
+            props.p_txt_help    = OPT_136_TXT_HELP;
+            props.incompat_grps = OPT_136_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_137_ENUM_NAME
+        case OPT_137_ENUM_NAME:
+            props.p_txt_help    = OPT_137_TXT_HELP;
+            props.incompat_grps = OPT_137_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_138_ENUM_NAME
+        case OPT_138_ENUM_NAME:
+            props.p_txt_help    = OPT_138_TXT_HELP;
+            props.incompat_grps = OPT_138_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_139_ENUM_NAME
+        case OPT_139_ENUM_NAME:
+            props.p_txt_help    = OPT_139_TXT_HELP;
+            props.incompat_grps = OPT_139_INCOMPAT_GRPS;
+        break;
+      #endif
+        
+      #ifdef OPT_140_ENUM_NAME
+        case OPT_140_ENUM_NAME:
+            props.p_txt_help    = OPT_140_TXT_HELP;
+            props.incompat_grps = OPT_140_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_141_ENUM_NAME
+        case OPT_141_ENUM_NAME:
+            props.p_txt_help    = OPT_141_TXT_HELP;
+            props.incompat_grps = OPT_141_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_142_ENUM_NAME
+        case OPT_142_ENUM_NAME:
+            props.p_txt_help    = OPT_142_TXT_HELP;
+            props.incompat_grps = OPT_142_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_143_ENUM_NAME
+        case OPT_143_ENUM_NAME:
+            props.p_txt_help    = OPT_143_TXT_HELP;
+            props.incompat_grps = OPT_143_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_144_ENUM_NAME
+        case OPT_144_ENUM_NAME:
+            props.p_txt_help    = OPT_144_TXT_HELP;
+            props.incompat_grps = OPT_144_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_145_ENUM_NAME
+        case OPT_145_ENUM_NAME:
+            props.p_txt_help    = OPT_145_TXT_HELP;
+            props.incompat_grps = OPT_145_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_146_ENUM_NAME
+        case OPT_146_ENUM_NAME:
+            props.p_txt_help    = OPT_146_TXT_HELP;
+            props.incompat_grps = OPT_146_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_147_ENUM_NAME
+        case OPT_147_ENUM_NAME:
+            props.p_txt_help    = OPT_147_TXT_HELP;
+            props.incompat_grps = OPT_147_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_148_ENUM_NAME
+        case OPT_148_ENUM_NAME:
+            props.p_txt_help    = OPT_148_TXT_HELP;
+            props.incompat_grps = OPT_148_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_149_ENUM_NAME
+        case OPT_149_ENUM_NAME:
+            props.p_txt_help    = OPT_149_TXT_HELP;
+            props.incompat_grps = OPT_149_INCOMPAT_GRPS;
+        break;
+      #endif
+        
+      #ifdef OPT_150_ENUM_NAME
+        case OPT_150_ENUM_NAME:
+            props.p_txt_help    = OPT_150_TXT_HELP;
+            props.incompat_grps = OPT_150_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_151_ENUM_NAME
+        case OPT_151_ENUM_NAME:
+            props.p_txt_help    = OPT_151_TXT_HELP;
+            props.incompat_grps = OPT_151_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_152_ENUM_NAME
+        case OPT_152_ENUM_NAME:
+            props.p_txt_help    = OPT_152_TXT_HELP;
+            props.incompat_grps = OPT_152_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_153_ENUM_NAME
+        case OPT_153_ENUM_NAME:
+            props.p_txt_help    = OPT_153_TXT_HELP;
+            props.incompat_grps = OPT_153_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_154_ENUM_NAME
+        case OPT_154_ENUM_NAME:
+            props.p_txt_help    = OPT_154_TXT_HELP;
+            props.incompat_grps = OPT_154_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_155_ENUM_NAME
+        case OPT_155_ENUM_NAME:
+            props.p_txt_help    = OPT_155_TXT_HELP;
+            props.incompat_grps = OPT_155_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_156_ENUM_NAME
+        case OPT_156_ENUM_NAME:
+            props.p_txt_help    = OPT_156_TXT_HELP;
+            props.incompat_grps = OPT_156_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_157_ENUM_NAME
+        case OPT_157_ENUM_NAME:
+            props.p_txt_help    = OPT_157_TXT_HELP;
+            props.incompat_grps = OPT_157_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_158_ENUM_NAME
+        case OPT_158_ENUM_NAME:
+            props.p_txt_help    = OPT_158_TXT_HELP;
+            props.incompat_grps = OPT_158_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_159_ENUM_NAME
+        case OPT_159_ENUM_NAME:
+            props.p_txt_help    = OPT_159_TXT_HELP;
+            props.incompat_grps = OPT_159_INCOMPAT_GRPS;
+        break;
+      #endif
+        
+      #ifdef OPT_160_ENUM_NAME
+        case OPT_160_ENUM_NAME:
+            props.p_txt_help    = OPT_160_TXT_HELP;
+            props.incompat_grps = OPT_160_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_161_ENUM_NAME
+        case OPT_161_ENUM_NAME:
+            props.p_txt_help    = OPT_161_TXT_HELP;
+            props.incompat_grps = OPT_161_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_162_ENUM_NAME
+        case OPT_162_ENUM_NAME:
+            props.p_txt_help    = OPT_162_TXT_HELP;
+            props.incompat_grps = OPT_162_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_163_ENUM_NAME
+        case OPT_163_ENUM_NAME:
+            props.p_txt_help    = OPT_163_TXT_HELP;
+            props.incompat_grps = OPT_163_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_164_ENUM_NAME
+        case OPT_164_ENUM_NAME:
+            props.p_txt_help    = OPT_164_TXT_HELP;
+            props.incompat_grps = OPT_164_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_165_ENUM_NAME
+        case OPT_165_ENUM_NAME:
+            props.p_txt_help    = OPT_165_TXT_HELP;
+            props.incompat_grps = OPT_165_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_166_ENUM_NAME
+        case OPT_166_ENUM_NAME:
+            props.p_txt_help    = OPT_166_TXT_HELP;
+            props.incompat_grps = OPT_166_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_167_ENUM_NAME
+        case OPT_167_ENUM_NAME:
+            props.p_txt_help    = OPT_167_TXT_HELP;
+            props.incompat_grps = OPT_167_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_168_ENUM_NAME
+        case OPT_168_ENUM_NAME:
+            props.p_txt_help    = OPT_168_TXT_HELP;
+            props.incompat_grps = OPT_168_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_169_ENUM_NAME
+        case OPT_169_ENUM_NAME:
+            props.p_txt_help    = OPT_169_TXT_HELP;
+            props.incompat_grps = OPT_169_INCOMPAT_GRPS;
+        break;
+      #endif
+        
+      #ifdef OPT_170_ENUM_NAME
+        case OPT_170_ENUM_NAME:
+            props.p_txt_help    = OPT_170_TXT_HELP;
+            props.incompat_grps = OPT_170_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_171_ENUM_NAME
+        case OPT_171_ENUM_NAME:
+            props.p_txt_help    = OPT_171_TXT_HELP;
+            props.incompat_grps = OPT_171_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_172_ENUM_NAME
+        case OPT_172_ENUM_NAME:
+            props.p_txt_help    = OPT_172_TXT_HELP;
+            props.incompat_grps = OPT_172_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_173_ENUM_NAME
+        case OPT_173_ENUM_NAME:
+            props.p_txt_help    = OPT_173_TXT_HELP;
+            props.incompat_grps = OPT_173_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_174_ENUM_NAME
+        case OPT_174_ENUM_NAME:
+            props.p_txt_help    = OPT_174_TXT_HELP;
+            props.incompat_grps = OPT_174_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_175_ENUM_NAME
+        case OPT_175_ENUM_NAME:
+            props.p_txt_help    = OPT_175_TXT_HELP;
+            props.incompat_grps = OPT_175_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_176_ENUM_NAME
+        case OPT_176_ENUM_NAME:
+            props.p_txt_help    = OPT_176_TXT_HELP;
+            props.incompat_grps = OPT_176_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_177_ENUM_NAME
+        case OPT_177_ENUM_NAME:
+            props.p_txt_help    = OPT_177_TXT_HELP;
+            props.incompat_grps = OPT_177_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_178_ENUM_NAME
+        case OPT_178_ENUM_NAME:
+            props.p_txt_help    = OPT_178_TXT_HELP;
+            props.incompat_grps = OPT_178_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_179_ENUM_NAME
+        case OPT_179_ENUM_NAME:
+            props.p_txt_help    = OPT_179_TXT_HELP;
+            props.incompat_grps = OPT_179_INCOMPAT_GRPS;
+        break;
+      #endif
+        
+      #ifdef OPT_180_ENUM_NAME
+        case OPT_180_ENUM_NAME:
+            props.p_txt_help    = OPT_180_TXT_HELP;
+            props.incompat_grps = OPT_180_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_181_ENUM_NAME
+        case OPT_181_ENUM_NAME:
+            props.p_txt_help    = OPT_181_TXT_HELP;
+            props.incompat_grps = OPT_181_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_182_ENUM_NAME
+        case OPT_182_ENUM_NAME:
+            props.p_txt_help    = OPT_182_TXT_HELP;
+            props.incompat_grps = OPT_182_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_183_ENUM_NAME
+        case OPT_183_ENUM_NAME:
+            props.p_txt_help    = OPT_183_TXT_HELP;
+            props.incompat_grps = OPT_183_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_184_ENUM_NAME
+        case OPT_184_ENUM_NAME:
+            props.p_txt_help    = OPT_184_TXT_HELP;
+            props.incompat_grps = OPT_184_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_185_ENUM_NAME
+        case OPT_185_ENUM_NAME:
+            props.p_txt_help    = OPT_185_TXT_HELP;
+            props.incompat_grps = OPT_185_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_186_ENUM_NAME
+        case OPT_186_ENUM_NAME:
+            props.p_txt_help    = OPT_186_TXT_HELP;
+            props.incompat_grps = OPT_186_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_187_ENUM_NAME
+        case OPT_187_ENUM_NAME:
+            props.p_txt_help    = OPT_187_TXT_HELP;
+            props.incompat_grps = OPT_187_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_188_ENUM_NAME
+        case OPT_188_ENUM_NAME:
+            props.p_txt_help    = OPT_188_TXT_HELP;
+            props.incompat_grps = OPT_188_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_189_ENUM_NAME
+        case OPT_189_ENUM_NAME:
+            props.p_txt_help    = OPT_189_TXT_HELP;
+            props.incompat_grps = OPT_189_INCOMPAT_GRPS;
+        break;
+      #endif
+        
+      #ifdef OPT_190_ENUM_NAME
+        case OPT_190_ENUM_NAME:
+            props.p_txt_help    = OPT_190_TXT_HELP;
+            props.incompat_grps = OPT_190_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_191_ENUM_NAME
+        case OPT_191_ENUM_NAME:
+            props.p_txt_help    = OPT_191_TXT_HELP;
+            props.incompat_grps = OPT_191_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_192_ENUM_NAME
+        case OPT_192_ENUM_NAME:
+            props.p_txt_help    = OPT_192_TXT_HELP;
+            props.incompat_grps = OPT_192_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_193_ENUM_NAME
+        case OPT_193_ENUM_NAME:
+            props.p_txt_help    = OPT_193_TXT_HELP;
+            props.incompat_grps = OPT_193_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_194_ENUM_NAME
+        case OPT_194_ENUM_NAME:
+            props.p_txt_help    = OPT_194_TXT_HELP;
+            props.incompat_grps = OPT_194_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_195_ENUM_NAME
+        case OPT_195_ENUM_NAME:
+            props.p_txt_help    = OPT_195_TXT_HELP;
+            props.incompat_grps = OPT_195_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_196_ENUM_NAME
+        case OPT_196_ENUM_NAME:
+            props.p_txt_help    = OPT_196_TXT_HELP;
+            props.incompat_grps = OPT_196_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_197_ENUM_NAME
+        case OPT_197_ENUM_NAME:
+            props.p_txt_help    = OPT_197_TXT_HELP;
+            props.incompat_grps = OPT_197_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_198_ENUM_NAME
+        case OPT_198_ENUM_NAME:
+            props.p_txt_help    = OPT_198_TXT_HELP;
+            props.incompat_grps = OPT_198_INCOMPAT_GRPS;
+        break;
+      #endif
+      #ifdef OPT_199_ENUM_NAME
+        case OPT_199_ENUM_NAME:
+            props.p_txt_help    = OPT_199_TXT_HELP;
+            props.incompat_grps = OPT_199_INCOMPAT_GRPS;
+        break;
+      #endif
+
+        default:
+            props.p_txt_help    = TXT_HELP_INVALID_ITEM;
+            props.incompat_grps = OPT_GRP_NONE;
+        break;
+    }
+    
+    return (props);
+}
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+const struct option* cli_get_longopts(void)
+{
+    return (longopts);
+}
+
+const char* cli_get_txt_shortopts(void)
+{
+    return (txt_shortopts);
+}
+
+
+inline const char* cli_opt_get_txt_help(cli_opt_t opt)
+{
+    return (opt_get_props(opt).p_txt_help);
+}
+
+inline uint32_t cli_opt_get_incompat_grps(cli_opt_t opt)
+{
+    return (opt_get_props(opt).incompat_grps);
+}
+
+
+
+
+
+
+
+
+/* ==== TYPEDEFS & DATA : MANDOPT ========================================== */
+
+static const char* txt_mandopts[MANDOPT_OPTS_LN] = {NULL};
+
+/* ==== PUBLIC FUNCTIONS : MANDOPT ========================================= */
+
+void cli_mandopt_print(const char* p_txt_delim)
+{
+    assert(NULL != p_txt_delim);
+    
+    
+    const char* p_txt_tmp = "";  /* there should be no delimiter in front of the very first item */
+    for (uint8_t i = 0u; (MANDOPT_OPTS_LN > i); (++i))
+    {
+        const char* p_txt_opt = txt_mandopts[i];
+        if ((NULL != p_txt_opt) && ('\0' != (p_txt_opt[0])))
+        {
+            printf("%s%s", p_txt_tmp, p_txt_opt);
+            p_txt_tmp = p_txt_delim;
+        }
+    }
+    printf("\n");
+}
+
+void cli_mandopt_clear(void)
+{
+    for(uint8_t i = 0u; (MANDOPT_OPTS_LN > i); (++i))
+    {
+        txt_mandopts[i] = NULL;
+    }
+}
+
+int cli_mandopt_check(const mandopt_t* p_mandopts, const uint8_t mandopts_ln)
+{
+    assert(NULL != p_mandopts);
+    
+    
+    int rtn = CLI_ERR;
+    
+    uint8_t i = UINT8_MAX;  /* WARNING: intentional use of owf behavior */ 
+    while ((mandopts_ln > (++i)) && (p_mandopts[i].is_valid)) { /* empty */ };
+    if (mandopts_ln <= i)
+    {
+        /* all items are valid */
+        rtn = CLI_OK;
+    }
+    else
+    {
+        /* invalid item encountered */
+        const mandopt_t *const p_item = (p_mandopts + i);
+        if (NULL == (p_item->p_mandopt_optbuf))
+        {
+            /* NULL optbuf == use single opt */
+            txt_mandopts[0] = cli_opt_get_txt_help(p_item->opt);
+        }
+        else
+        {
+            /* non-NULL optbuf == use optbuf data */
+            for(uint8_t i = 0u; (MANDOPT_OPTS_LN > i); (++i))
+            {
+                txt_mandopts[i] = cli_opt_get_txt_help(p_item->p_mandopt_optbuf->opts[i]);
+            }
+        }
+        rtn = CLI_ERR_MISSING_MANDOPT;
+    }
+    
+    return (rtn);
+}
+
+/* ==== TESTMODE constants ================================================= */
+
+#if !defined(NDEBUG)
+const char *const TEST_defopts__p_txt_shortopts = txt_shortopts;
+const struct option *const TEST_defopts__p_longopts = longopts;
+
+const char *const *const TEST_defopts__p_txt_mandopts = txt_mandopts;
+#endif
+
+/* ========================================================================= */
diff --git a/sw/libfci_cli/src/libfci_cli_def_opts.h b/sw/libfci_cli/src/libfci_cli_def_opts.h
new file mode 100644
index 0000000..2c81178
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_def_opts.h
@@ -0,0 +1,4670 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef CLI_DEF_OPTS_H_
+#define CLI_DEF_OPTS_H_
+
+/* ==== DEFINITIONS : INCOMPATIBILITY GROUPS =============================== */
+
+/* 
+    There are mutually incompatible cli opts (e.g.: --enable/--disable).
+    Such incompatible opts can be viewed as "group members" of an incompatibility group.
+    Within the group, only one "group member" opt can be legally detected and parsed within the apps's cli input.
+    
+    If one "group member" opt was already detected/parsed and later another "group member" opt from the same group 
+    is detected during the given cli input parsing session, then an error shoud be raised (incompatible opts detected).
+    
+    Handling of incompatibility groups is implemented locally in the parser function.
+    To allow easier group management, IDs of incompatibility groups are declared here (and not in the parse fnc).
+    Each incompatibility group is represented by:
+      --> an ID key in the enum
+      --> a bitflag macro (to be used in CLI OPT definitions)
+      
+    Bitflag macros are used in cli opt definitions (see below).
+    Bitflag macros are expected to be at least 32bit wide.
+*/ 
+typedef enum cli_opt_incompat_grp_tt {
+    OPT_GRP_NONE = 0uL,
+    
+    OPT_GRP_IP4IP6_ID,
+    OPT_GRP_ENDIS_ID,
+    OPT_GRP_NOREPLY_NOORIG_ID,
+    OPT_GRP_ARN_ID,
+    OPT_GRP_STATDYN_ID,
+    
+    OPT_GRP_LN
+} cli_opt_incompat_grp_t;
+#define OPT_GRP_IP4IP6          (1uL << OPT_GRP_IP4IP6_ID)
+#define OPT_GRP_ENDIS           (1uL << OPT_GRP_ENDIS_ID)
+#define OPT_GRP_NOREPLY_NOORIG  (1uL << OPT_GRP_NOREPLY_NOORIG_ID)
+#define OPT_GRP_ARN             (1uL << OPT_GRP_ARN_ID)
+#define OPT_GRP_STATDYN         (1uL << OPT_GRP_STATDYN_ID)
+
+
+/* ==== DEFINITIONS : CLI OPTS ============================================= */
+/* 
+    For each cli option, fill the necessary info here.
+    Do NOT include any *.h files here. It should not be needed.
+    
+    Opts have to be parsed via getopt_long() fnc.
+    Opts usually (not always) correspond to some member of the 'cmdargs_t' superstructure.
+    
+    OPT_00_NO_OPTION is hardcoded.
+    
+    Search for keyword 'OPT_LAST' to get to the bottom of the cli option definition list.
+    
+    
+    Description of a cli opt definition (xx is a number from 01 to 99)
+    ------------------------------------------------------------------
+    OPT_xx_ENUM_NAME        OPT_MY_TEST         This enum key is automatically created and associated
+                                                with the given cli opt.
+                                                
+    OPT_xx_OPT_PARSE        opt_parse_my_test   Name of a static function which is invoked when this cli opt
+                                                (and optionally its argument) is to be parsed from the input txt vector.
+                                                The function is expected to be in the 'cli_parser.c' file.
+                                                The function is expected to conform to the following prototype:
+                                                static int opt_parse_my_test(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg);
+                                                
+    OPT_xx_HAS_ARG          y                   Does this cli opt expect an argument?
+                                                  y : yes
+                                                  n : no
+                                                
+    OPT_xx_INCOMPAT_GRPS    OPT_GRP_NONE        Incompatibility groups this cli opt belongs to.
+                                                Example:
+                                                  OPT_GRP_NONE
+                                                  OPT_GRP_IP4IP6
+                                                 (OPT_GRP_IP4IP6 | OPT_GRP_ENDIS)
+                                                
+    OPT_xx_CLI_SHORT_CODE   m                   Command-line text which represents a given cli opt.
+                                                This is a "short opt" representation;
+                                                a single letter/digit with one leading dash (-m).
+                                                See documentation of a getopt() fnc family.
+                                                If the given cli opt does not have a shortopt variant,
+                                                then a generic OPT_AUTO_CODE should be used.
+                                                IMPORTANT: If the given cli opt uses a shortopt variant, then
+                                                           the used letter/digit must NOT be enclosed
+                                                           in any quotation marks.
+                                                           Reason: Based on user experience, it is beneficial to create
+                                                                   a single-letter longopt version as well (--m).
+                                                                   To do so automatically via C preprocessor,
+                                                                   the letter/digit must NOT be enclosed in any quotation marks.
+                                                
+    OPT_xx_CLI_LONG_TXT_A   "my-test"           Command-line text which represents a given cli opt.
+                                                This is a "long opt"; a text with two leading dashes (--my-test).
+                                                See documentation of a getopt() fnc family.
+                                                Up to 4 different longopt texts for the given cli opt are supported,
+                                                labled by suffixes _A,_B,_C,_D.
+                                                
+    OPT_xx_TXT_HELP         "-m|--m|--my-test"  A help text, documenting all text representations of the given cli opt.
+                                                NOTE: This text is created manually, but is expected to contain all
+                                                      command-line text representations of the given cli opt.
+                                                      PAY ATTENTION AND FILL PROPERLY!
+                                                      Failure to do so results in incorrect help texts and
+                                                      (very probably) some tedious support E-mail conversations.
+                                                
+    ...............     TXT_HELP__MY_TEST \     Named (not numbered) help text symbol.
+    OPT_xx_TXT_HELP                             Tied with the corresponding numbered help text symbol.
+                                                Intended to be used in "def_help.c" source, to prevent
+                                                from shifting help texts if the given opt gets renumbered.
+                                                The backslash is a line-joiner (must be the last char of the line).
+*/
+#define OPT_AUTO_CODE  (1000)
+
+
+#define OPT_01_ENUM_NAME         OPT_IP4
+#define OPT_01_OPT_PARSE         opt_parse_ip4
+#define OPT_01_HAS_ARG           n
+#define OPT_01_INCOMPAT_GRPS     OPT_GRP_IP4IP6
+#define OPT_01_CLI_SHORT_CODE    4
+#define OPT_01_CLI_LONG_TXT_A    "ip4"
+#define OPT_01_TXT_HELP          "-4|--4|--ip4"
+#define                          TXT_HELP__IP4 \
+        OPT_01_TXT_HELP
+
+
+#define OPT_02_ENUM_NAME         OPT_IP6
+#define OPT_02_OPT_PARSE         opt_parse_ip6
+#define OPT_02_HAS_ARG           n
+#define OPT_02_INCOMPAT_GRPS     OPT_GRP_IP4IP6
+#define OPT_02_CLI_SHORT_CODE    6
+#define OPT_02_CLI_LONG_TXT_A    "ip6"
+#define OPT_02_TXT_HELP          "-6|--6|--ip6"
+#define                          TXT_HELP__IP6 \
+        OPT_02_TXT_HELP
+
+
+#define OPT_03_ENUM_NAME         OPT_ALL
+#define OPT_03_OPT_PARSE         opt_parse_all
+#define OPT_03_HAS_ARG           n
+#define OPT_03_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_03_CLI_SHORT_CODE    a
+#define OPT_03_CLI_LONG_TXT_A    "all"
+#define OPT_03_TXT_HELP          "-a|--a|--all"
+#define                          TXT_HELP__ALL \
+        OPT_03_TXT_HELP
+
+
+#define OPT_04_ENUM_NAME         OPT_HELP
+#define OPT_04_OPT_PARSE         opt_parse_help
+#define OPT_04_HAS_ARG           n
+#define OPT_04_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_04_CLI_SHORT_CODE    h
+#define OPT_04_CLI_LONG_TXT_A    "help"
+#define OPT_04_TXT_HELP          "-h|--h|--help"
+#define                          TXT_HELP__HELP \
+        OPT_04_TXT_HELP
+
+
+#define OPT_05_ENUM_NAME         OPT_VERBOSE
+#define OPT_05_OPT_PARSE         opt_parse_verbose
+#define OPT_05_HAS_ARG           n
+#define OPT_05_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_05_CLI_SHORT_CODE    v
+#define OPT_05_CLI_LONG_TXT_A    "verbose"
+#define OPT_05_TXT_HELP          "-v|--v|--verbose"
+#define                          TXT_HELP__VERBOSE \
+        OPT_05_TXT_HELP
+
+
+#define OPT_06_ENUM_NAME         OPT_VERSION
+#define OPT_06_OPT_PARSE         opt_parse_version
+#define OPT_06_HAS_ARG           n
+#define OPT_06_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_06_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_06_CLI_LONG_TXT_A    "version"
+#define OPT_06_TXT_HELP          "--version"
+#define                          TXT_HELP__VERSION \
+        OPT_06_TXT_HELP
+
+
+#define OPT_07_ENUM_NAME         OPT_INTERFACE
+#define OPT_07_OPT_PARSE         opt_parse_interface
+#define OPT_07_HAS_ARG           y
+#define OPT_07_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_07_CLI_SHORT_CODE    i
+#define OPT_07_CLI_LONG_TXT_A    "interface"
+#define OPT_07_TXT_HELP          "-i|--i|--interface"
+#define                          TXT_HELP__INTERFACE \
+        OPT_07_TXT_HELP
+
+
+#define OPT_08_ENUM_NAME         OPT_PARENT
+#define OPT_08_OPT_PARSE         opt_parse_parent
+#define OPT_08_HAS_ARG           y
+#define OPT_08_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_08_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_08_CLI_LONG_TXT_A    "parent"
+#define OPT_08_TXT_HELP          "--parent"
+#define                          TXT_HELP__PARENT \
+        OPT_08_TXT_HELP
+
+
+#define OPT_09_ENUM_NAME         OPT_MIRROR
+#define OPT_09_OPT_PARSE         opt_parse_mirror
+#define OPT_09_HAS_ARG           y
+#define OPT_09_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_09_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_09_CLI_LONG_TXT_A    "mirror"
+#define OPT_09_TXT_HELP          "--mirror"
+#define                          TXT_HELP__MIRROR \
+        OPT_09_TXT_HELP
+
+
+#define OPT_10_ENUM_NAME         OPT_MODE
+#define OPT_10_OPT_PARSE         opt_parse_mode
+#define OPT_10_HAS_ARG           y
+#define OPT_10_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_10_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_10_CLI_LONG_TXT_A    "mode"
+#define OPT_10_TXT_HELP          "--mode"
+#define                          TXT_HELP__MODE \
+        OPT_10_TXT_HELP
+
+
+#define OPT_11_ENUM_NAME         OPT_BLOCK_STATE
+#define OPT_11_OPT_PARSE         opt_parse_block_state
+#define OPT_11_HAS_ARG           y
+#define OPT_11_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_11_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_11_CLI_LONG_TXT_A    "bs"
+#define OPT_11_CLI_LONG_TXT_B    "block-state"
+#define OPT_11_TXT_HELP          "--bs|--block-state"
+#define                          TXT_HELP__BLOCK_STATE \
+        OPT_11_TXT_HELP
+
+
+#define OPT_12_ENUM_NAME         OPT_ENABLE
+#define OPT_12_OPT_PARSE         opt_parse_enable
+#define OPT_12_HAS_ARG           n
+#define OPT_12_INCOMPAT_GRPS     OPT_GRP_ENDIS
+#define OPT_12_CLI_SHORT_CODE    E
+#define OPT_12_CLI_LONG_TXT_A    "enable"
+#define OPT_12_TXT_HELP          "-E|--E|--enable"
+#define                          TXT_HELP__ENABLE \
+        OPT_12_TXT_HELP
+
+
+#define OPT_13_ENUM_NAME         OPT_DISABLE
+#define OPT_13_OPT_PARSE         opt_parse_disable
+#define OPT_13_HAS_ARG           n
+#define OPT_13_INCOMPAT_GRPS     OPT_GRP_ENDIS
+#define OPT_13_CLI_SHORT_CODE    D
+#define OPT_13_CLI_LONG_TXT_A    "disable"
+#define OPT_13_TXT_HELP          "-D|--D|--disable"
+#define                          TXT_HELP__DISABLE \
+        OPT_13_TXT_HELP
+
+
+#define OPT_14_ENUM_NAME         OPT_PROMISC
+#define OPT_14_OPT_PARSE         opt_parse_promisc
+#define OPT_14_HAS_ARG           y
+#define OPT_14_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_14_CLI_SHORT_CODE    P
+#define OPT_14_CLI_LONG_TXT_A    "promisc"
+#define OPT_14_TXT_HELP          "-P|--P|--promisc"
+#define                          TXT_HELP__PROMISC \
+        OPT_14_TXT_HELP
+
+
+#define OPT_15_ENUM_NAME         OPT_LOADBALANCE
+#define OPT_15_OPT_PARSE         opt_parse_loadbalance
+#define OPT_15_HAS_ARG           y
+#define OPT_15_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_15_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_15_CLI_LONG_TXT_A    "lb"
+#define OPT_15_CLI_LONG_TXT_B    "loadbalance"
+#define OPT_15_TXT_HELP          "--lb|--loadbalance"
+#define                          TXT_HELP__LOADBALANCE \
+        OPT_15_TXT_HELP
+
+
+#define OPT_16_ENUM_NAME         OPT_MATCH_MODE
+#define OPT_16_OPT_PARSE         opt_parse_match_mode
+#define OPT_16_HAS_ARG           y
+#define OPT_16_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_16_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_16_CLI_LONG_TXT_A    "match-mode"
+#define OPT_16_TXT_HELP          "--match-mode"
+#define                          TXT_HELP__MATCH_MODE \
+        OPT_16_TXT_HELP
+
+
+#define OPT_17_ENUM_NAME         OPT_DISCARD_ON_MATCH
+#define OPT_17_OPT_PARSE         opt_parse_discard_on_match
+#define OPT_17_HAS_ARG           y
+#define OPT_17_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_17_CLI_SHORT_CODE    X
+#define OPT_17_CLI_LONG_TXT_A    "discard-on-match"
+#define OPT_17_TXT_HELP          "-X|--X|--discard-on-match"
+#define                          TXT_HELP__DISCARD_ON_MATCH \
+        OPT_17_TXT_HELP
+
+
+#define OPT_18_ENUM_NAME         OPT_EGRESS
+#define OPT_18_OPT_PARSE         opt_parse_egress
+#define OPT_18_HAS_ARG           y
+#define OPT_18_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_18_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_18_CLI_LONG_TXT_A    "egress"
+#define OPT_18_TXT_HELP          "--egress"
+#define                          TXT_HELP__EGRESS \
+        OPT_18_TXT_HELP
+
+
+#define OPT_19_ENUM_NAME         OPT_MATCH_RULES
+#define OPT_19_OPT_PARSE         opt_parse_match_rules
+#define OPT_19_HAS_ARG           y
+#define OPT_19_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_19_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_19_CLI_LONG_TXT_A    "mr"
+#define OPT_19_CLI_LONG_TXT_B    "match-rules"
+#define OPT_19_TXT_HELP          "--mr|--match-rules"
+#define                          TXT_HELP__MATCH_RULES \
+        OPT_19_TXT_HELP
+
+
+#define OPT_20_ENUM_NAME         OPT_VLAN
+#define OPT_20_OPT_PARSE         opt_parse_vlan
+#define OPT_20_HAS_ARG           y
+#define OPT_20_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_20_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_20_CLI_LONG_TXT_A    "vlan"
+#define OPT_20_TXT_HELP          "--vlan"
+#define                          TXT_HELP__VLAN \
+        OPT_20_TXT_HELP
+
+
+#define OPT_21_ENUM_NAME         OPT_PROTOCOL
+#define OPT_21_OPT_PARSE         opt_parse_protocol
+#define OPT_21_HAS_ARG           y
+#define OPT_21_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_21_CLI_SHORT_CODE    p
+#define OPT_21_CLI_LONG_TXT_A    "proto"
+#define OPT_21_CLI_LONG_TXT_B    "protocol"
+#define OPT_21_TXT_HELP          "-p|--p|--proto|--protocol"
+#define                          TXT_HELP__PROTOCOL \
+        OPT_21_TXT_HELP
+
+
+#define OPT_22_ENUM_NAME         OPT_ETHTYPE
+#define OPT_22_OPT_PARSE         opt_parse_ethtype
+#define OPT_22_HAS_ARG           y
+#define OPT_22_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_22_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_22_CLI_LONG_TXT_A    "et"
+#define OPT_22_CLI_LONG_TXT_B    "ether-type"
+#define OPT_22_TXT_HELP          "--et|--ether-type"
+#define                          TXT_HELP__ETHTYPE \
+        OPT_22_TXT_HELP
+
+
+#define OPT_23_ENUM_NAME         OPT_MAC
+#define OPT_23_OPT_PARSE         opt_parse_mac
+#define OPT_23_HAS_ARG           y
+#define OPT_23_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_23_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_23_CLI_LONG_TXT_A    "mac"
+#define OPT_23_CLI_LONG_TXT_B    "mac"
+#define OPT_23_TXT_HELP          "--mac"
+#define                          TXT_HELP__MAC \
+        OPT_23_TXT_HELP
+
+
+#define OPT_24_ENUM_NAME         OPT_SMAC
+#define OPT_24_OPT_PARSE         opt_parse_smac
+#define OPT_24_HAS_ARG           y
+#define OPT_24_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_24_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_24_CLI_LONG_TXT_A    "smac"
+#define OPT_24_CLI_LONG_TXT_B    "src-mac"
+#define OPT_24_TXT_HELP          "--smac|--src-mac"
+#define                          TXT_HELP__SMAC \
+        OPT_24_TXT_HELP
+
+
+#define OPT_25_ENUM_NAME         OPT_DMAC
+#define OPT_25_OPT_PARSE         opt_parse_dmac
+#define OPT_25_HAS_ARG           y
+#define OPT_25_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_25_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_25_CLI_LONG_TXT_A    "dmac"
+#define OPT_25_CLI_LONG_TXT_B    "dst-mac"
+#define OPT_25_TXT_HELP          "--dmac|--dst-mac"
+#define                          TXT_HELP__DMAC \
+        OPT_25_TXT_HELP
+
+
+#define OPT_26_ENUM_NAME         OPT_SIP
+#define OPT_26_OPT_PARSE         opt_parse_sip
+#define OPT_26_HAS_ARG           y
+#define OPT_26_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_26_CLI_SHORT_CODE    s
+#define OPT_26_CLI_LONG_TXT_A    "sip"
+#define OPT_26_CLI_LONG_TXT_B    "src"
+#define OPT_26_TXT_HELP          "-s|--s|--sip|--src"
+#define                          TXT_HELP__SIP \
+        OPT_26_TXT_HELP
+
+
+#define OPT_27_ENUM_NAME         OPT_DIP
+#define OPT_27_OPT_PARSE         opt_parse_dip
+#define OPT_27_HAS_ARG           y
+#define OPT_27_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_27_CLI_SHORT_CODE    d
+#define OPT_27_CLI_LONG_TXT_A    "dip"
+#define OPT_27_CLI_LONG_TXT_B    "dst"
+#define OPT_27_TXT_HELP          "-d|--d|--dip|--dst"
+#define                          TXT_HELP__DIP \
+        OPT_27_TXT_HELP
+
+
+#define OPT_28_ENUM_NAME         OPT_R_SIP
+#define OPT_28_OPT_PARSE         opt_parse_r_sip
+#define OPT_28_HAS_ARG           y
+#define OPT_28_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_28_CLI_SHORT_CODE    r
+#define OPT_28_CLI_LONG_TXT_A    "r-sip"
+#define OPT_28_CLI_LONG_TXT_B    "r-src"
+#define OPT_28_TXT_HELP          "-r|--r|--r-sip|--r-src"
+#define                          TXT_HELP__R_SIP \
+        OPT_28_TXT_HELP
+
+
+#define OPT_29_ENUM_NAME         OPT_R_DIP
+#define OPT_29_OPT_PARSE         opt_parse_r_dip
+#define OPT_29_HAS_ARG           y
+#define OPT_29_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_29_CLI_SHORT_CODE    q
+#define OPT_29_CLI_LONG_TXT_A    "r-dip"
+#define OPT_29_CLI_LONG_TXT_B    "r-dst"
+#define OPT_29_TXT_HELP          "-q|--q|--r-dip|--r-dst"
+#define                          TXT_HELP__R_DIP \
+        OPT_29_TXT_HELP
+
+
+#define OPT_30_ENUM_NAME         OPT_SIP6
+#define OPT_30_OPT_PARSE         opt_parse_sip6
+#define OPT_30_HAS_ARG           y
+#define OPT_30_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_30_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_30_CLI_LONG_TXT_A    "s6"
+#define OPT_30_CLI_LONG_TXT_B    "sip6"
+#define OPT_30_CLI_LONG_TXT_C    "src6"
+#define OPT_30_TXT_HELP          "--s6|--sip6|--src6"
+#define                          TXT_HELP__SIP6 \
+        OPT_30_TXT_HELP
+
+
+#define OPT_31_ENUM_NAME         OPT_DIP6
+#define OPT_31_OPT_PARSE         opt_parse_dip6
+#define OPT_31_HAS_ARG           y
+#define OPT_31_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_31_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_31_CLI_LONG_TXT_A    "d6"
+#define OPT_31_CLI_LONG_TXT_B    "dip6"
+#define OPT_31_CLI_LONG_TXT_C    "dst6"
+#define OPT_31_TXT_HELP          "--d6|--dip6|--dst6"
+#define                          TXT_HELP__DIP6 \
+        OPT_31_TXT_HELP
+
+
+#define OPT_32_ENUM_NAME         OPT_SPORT
+#define OPT_32_OPT_PARSE         opt_parse_sport
+#define OPT_32_HAS_ARG           y
+#define OPT_32_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_32_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_32_CLI_LONG_TXT_A    "sport"
+#define OPT_32_CLI_LONG_TXT_B    "src-port"
+#define OPT_32_TXT_HELP          "--sport|--src-port"
+#define                          TXT_HELP__SPORT \
+        OPT_32_TXT_HELP
+
+
+#define OPT_33_ENUM_NAME         OPT_DPORT
+#define OPT_33_OPT_PARSE         opt_parse_dport
+#define OPT_33_HAS_ARG           y
+#define OPT_33_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_33_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_33_CLI_LONG_TXT_A    "dport"
+#define OPT_33_CLI_LONG_TXT_B    "dst-port"
+#define OPT_33_TXT_HELP          "--dport|--dst-port"
+#define                          TXT_HELP__DPORT \
+        OPT_33_TXT_HELP
+
+
+#define OPT_34_ENUM_NAME         OPT_R_SPORT
+#define OPT_34_OPT_PARSE         opt_parse_r_sport
+#define OPT_34_HAS_ARG           y
+#define OPT_34_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_34_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_34_CLI_LONG_TXT_A    "r-sport"
+#define OPT_34_CLI_LONG_TXT_B    "r-src-port"
+#define OPT_34_TXT_HELP          "--r-sport|--r-src-port"
+#define                          TXT_HELP__R_SPORT \
+        OPT_34_TXT_HELP
+
+
+#define OPT_35_ENUM_NAME         OPT_R_DPORT
+#define OPT_35_OPT_PARSE         opt_parse_r_dport
+#define OPT_35_HAS_ARG           y
+#define OPT_35_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_35_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_35_CLI_LONG_TXT_A    "r-dport"
+#define OPT_35_CLI_LONG_TXT_B    "r-dst-port"
+#define OPT_35_TXT_HELP          "--r-dport|--r-dst-port"
+#define                          TXT_HELP__R_DPORT \
+        OPT_35_TXT_HELP
+
+
+#define OPT_36_ENUM_NAME         OPT_HIF_COOKIE
+#define OPT_36_OPT_PARSE         opt_parse_hif_cookie
+#define OPT_36_HAS_ARG           y
+#define OPT_36_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_36_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_36_CLI_LONG_TXT_A    "hifc"
+#define OPT_36_CLI_LONG_TXT_B    "hif-cookie"
+#define OPT_36_TXT_HELP          "--hifc|--hif-cookie"
+#define                          TXT_HELP__HIF_COOKIE \
+        OPT_36_TXT_HELP
+
+
+#define OPT_37_ENUM_NAME         OPT_TIMEOUT
+#define OPT_37_OPT_PARSE         opt_parse_timeout
+#define OPT_37_HAS_ARG           y
+#define OPT_37_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_37_CLI_SHORT_CODE    w
+#define OPT_37_CLI_LONG_TXT_A    "timeout"
+#define OPT_37_TXT_HELP          "-w|--w|--timeout"
+#define                          TXT_HELP__TIMEOUT \
+        OPT_37_TXT_HELP
+
+
+#define OPT_38_ENUM_NAME         OPT_TIMEOUT2
+#define OPT_38_OPT_PARSE         opt_parse_timeout2
+#define OPT_38_HAS_ARG           y
+#define OPT_38_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_38_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_38_CLI_LONG_TXT_A    "w2"
+#define OPT_38_CLI_LONG_TXT_B    "timeout2"
+#define OPT_38_TXT_HELP          "--w2|--timeout2"
+#define                          TXT_HELP__TIMEOUT2 \
+        OPT_38_TXT_HELP
+
+
+#define OPT_39_ENUM_NAME         OPT_UCAST_HIT
+#define OPT_39_OPT_PARSE         opt_parse_ucast_hit
+#define OPT_39_HAS_ARG           y
+#define OPT_39_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_39_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_39_CLI_LONG_TXT_A    "uh"
+#define OPT_39_CLI_LONG_TXT_B    "ucast-hit"
+#define OPT_39_TXT_HELP          "--uh|--ucast-hit"
+#define                          TXT_HELP__UCAST_HIT \
+        OPT_39_TXT_HELP
+
+
+#define OPT_40_ENUM_NAME         OPT_UCAST_MISS
+#define OPT_40_OPT_PARSE         opt_parse_ucast_miss
+#define OPT_40_HAS_ARG           y
+#define OPT_40_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_40_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_40_CLI_LONG_TXT_A    "um"
+#define OPT_40_CLI_LONG_TXT_B    "ucast-miss"
+#define OPT_40_TXT_HELP          "--um|--ucast-miss"
+#define                          TXT_HELP__UCAST_MISS \
+        OPT_40_TXT_HELP
+
+
+#define OPT_41_ENUM_NAME         OPT_MCAST_HIT
+#define OPT_41_OPT_PARSE         opt_parse_mcast_hit
+#define OPT_41_HAS_ARG           y
+#define OPT_41_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_41_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_41_CLI_LONG_TXT_A    "mh"
+#define OPT_41_CLI_LONG_TXT_B    "mcast-hit"
+#define OPT_41_TXT_HELP          "--mh|--mcast-hit"
+#define                          TXT_HELP__MCAST_HIT \
+        OPT_41_TXT_HELP
+
+
+#define OPT_42_ENUM_NAME         OPT_MCAST_MISS
+#define OPT_42_OPT_PARSE         opt_parse_mcast_miss
+#define OPT_42_HAS_ARG           y
+#define OPT_42_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_42_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_42_CLI_LONG_TXT_A    "mm"
+#define OPT_42_CLI_LONG_TXT_B    "mcast-miss"
+#define OPT_42_TXT_HELP          "--mm|--mcast-miss"
+#define                          TXT_HELP__MCAST_MISS \
+        OPT_42_TXT_HELP
+
+
+#define OPT_43_ENUM_NAME         OPT_TAG
+#define OPT_43_OPT_PARSE         opt_parse_tag
+#define OPT_43_HAS_ARG           y
+#define OPT_43_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_43_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_43_CLI_LONG_TXT_A    "tag"
+#define OPT_43_TXT_HELP          "--tag"
+#define                          TXT_HELP__TAG \
+        OPT_43_TXT_HELP
+
+
+#define OPT_44_ENUM_NAME         OPT_DEFAULT
+#define OPT_44_OPT_PARSE         opt_parse_default
+#define OPT_44_HAS_ARG           n
+#define OPT_44_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_44_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_44_CLI_LONG_TXT_A    "def"
+#define OPT_44_CLI_LONG_TXT_B    "default"
+#define OPT_44_TXT_HELP          "--def|--default"
+#define                          TXT_HELP__DEFAULT \
+        OPT_44_TXT_HELP
+
+
+#define OPT_45_ENUM_NAME         OPT_FALLBACK
+#define OPT_45_OPT_PARSE         opt_parse_fallback
+#define OPT_45_HAS_ARG           n
+#define OPT_45_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_45_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_45_CLI_LONG_TXT_A    "fbk"
+#define OPT_45_CLI_LONG_TXT_B    "fallback"
+#define OPT_45_TXT_HELP          "--fbk|--fallback"
+#define                          TXT_HELP__FALLBACK \
+        OPT_45_TXT_HELP
+
+
+#define OPT_46_ENUM_NAME         OPT_4o6
+#define OPT_46_OPT_PARSE         opt_parse_4o6
+#define OPT_46_HAS_ARG           n
+#define OPT_46_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_46_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_46_CLI_LONG_TXT_A    "4o6"
+#define OPT_46_TXT_HELP          "--4o6"
+#define                          TXT_HELP__4o6 \
+        OPT_46_TXT_HELP
+
+
+#define OPT_47_ENUM_NAME         OPT_NO_REPLY
+#define OPT_47_OPT_PARSE         opt_parse_no_reply
+#define OPT_47_HAS_ARG           n
+#define OPT_47_INCOMPAT_GRPS     OPT_GRP_NOREPLY_NOORIG
+#define OPT_47_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_47_CLI_LONG_TXT_A    "no-reply"
+#define OPT_47_TXT_HELP          "--no-reply"
+#define                          TXT_HELP__NO_REPLY \
+        OPT_47_TXT_HELP
+
+
+#define OPT_48_ENUM_NAME         OPT_NO_ORIG
+#define OPT_48_OPT_PARSE         opt_parse_no_orig
+#define OPT_48_HAS_ARG           n
+#define OPT_48_INCOMPAT_GRPS     OPT_GRP_NOREPLY_NOORIG
+#define OPT_48_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_48_CLI_LONG_TXT_A    "no-orig"
+#define OPT_48_TXT_HELP          "--no-orig"
+#define                          TXT_HELP__NO_ORIG \
+        OPT_48_TXT_HELP
+
+
+#define OPT_49_ENUM_NAME         OPT_ROUTE
+#define OPT_49_OPT_PARSE         opt_parse_route
+#define OPT_49_HAS_ARG           y
+#define OPT_49_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_49_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_49_CLI_LONG_TXT_A    "rt"
+#define OPT_49_CLI_LONG_TXT_B    "route"
+#define OPT_49_TXT_HELP          "--rt|--route"
+#define                          TXT_HELP__ROUTE \
+        OPT_49_TXT_HELP
+
+
+#define OPT_50_ENUM_NAME         OPT_R_ROUTE
+#define OPT_50_OPT_PARSE         opt_parse_r_route
+#define OPT_50_HAS_ARG           y
+#define OPT_50_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_50_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_50_CLI_LONG_TXT_A    "r-rt"
+#define OPT_50_CLI_LONG_TXT_B    "r-route"
+#define OPT_50_TXT_HELP          "--r-rt|--r-route"
+#define                          TXT_HELP__R_ROUTE \
+        OPT_50_TXT_HELP
+
+
+#define OPT_51_ENUM_NAME         OPT_INGRESS_MR0
+#define OPT_51_OPT_PARSE         opt_parse_ingress_mr0
+#define OPT_51_HAS_ARG           y
+#define OPT_51_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_51_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_51_CLI_LONG_TXT_A    "inmr0"
+#define OPT_51_CLI_LONG_TXT_B    "ingress-mr0"
+#define OPT_51_TXT_HELP          "--inmr0|--ingress-mr0"
+#define                          TXT_HELP__INGRESS_MR0 \
+        OPT_51_TXT_HELP
+
+
+#define OPT_52_ENUM_NAME         OPT_INGRESS_MR1
+#define OPT_52_OPT_PARSE         opt_parse_ingress_mr1
+#define OPT_52_HAS_ARG           y
+#define OPT_52_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_52_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_52_CLI_LONG_TXT_A    "inmr1"
+#define OPT_52_CLI_LONG_TXT_B    "ingress-mr1"
+#define OPT_52_TXT_HELP          "--inmr1|--ingress-mr1"
+#define                          TXT_HELP__INGRESS_MR1 \
+        OPT_52_TXT_HELP
+
+
+#define OPT_53_ENUM_NAME         OPT_EGRESS_MR0
+#define OPT_53_OPT_PARSE         opt_parse_egress_mr0
+#define OPT_53_HAS_ARG           y
+#define OPT_53_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_53_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_53_CLI_LONG_TXT_A    "egmr0"
+#define OPT_53_CLI_LONG_TXT_B    "egress-mr0"
+#define OPT_53_TXT_HELP          "--egmr0|--egress-mr0"
+#define                          TXT_HELP__EGRESS_MR0 \
+        OPT_53_TXT_HELP
+
+
+#define OPT_54_ENUM_NAME         OPT_EGRESS_MR1
+#define OPT_54_OPT_PARSE         opt_parse_egress_mr1
+#define OPT_54_HAS_ARG           y
+#define OPT_54_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_54_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_54_CLI_LONG_TXT_A    "egmr1"
+#define OPT_54_CLI_LONG_TXT_B    "egress-mr1"
+#define OPT_54_TXT_HELP          "--emr1|--egress-mr1"
+#define                          TXT_HELP__EGRESS_MR1 \
+        OPT_54_TXT_HELP
+
+
+#define OPT_55_ENUM_NAME         OPT_TABLE
+#define OPT_55_OPT_PARSE         opt_parse_table
+#define OPT_55_HAS_ARG           y
+#define OPT_55_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_55_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_55_CLI_LONG_TXT_A    "tb"
+#define OPT_55_CLI_LONG_TXT_B    "table"
+#define OPT_55_TXT_HELP          "--tb|--table"
+#define                          TXT_HELP__TABLE \
+        OPT_55_TXT_HELP
+
+
+#define OPT_56_ENUM_NAME         OPT_TABLE0
+#define OPT_56_OPT_PARSE         opt_parse_table0
+#define OPT_56_HAS_ARG           y
+#define OPT_56_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_56_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_56_CLI_LONG_TXT_A    "tb0"
+#define OPT_56_CLI_LONG_TXT_B    "table0"
+#define OPT_56_TXT_HELP          "--tb0|--table0"
+#define                          TXT_HELP__TABLE0 \
+        OPT_56_TXT_HELP
+
+
+#define OPT_57_ENUM_NAME         OPT_TABLE1
+#define OPT_57_OPT_PARSE         opt_parse_table1
+#define OPT_57_HAS_ARG           y
+#define OPT_57_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_57_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_57_CLI_LONG_TXT_A    "tb1"
+#define OPT_57_CLI_LONG_TXT_B    "table1"
+#define OPT_57_TXT_HELP          "--tb1|--table1"
+#define                          TXT_HELP__TABLE1 \
+        OPT_57_TXT_HELP
+
+
+#define OPT_58_ENUM_NAME         OPT_RULE
+#define OPT_58_OPT_PARSE         opt_parse_rule
+#define OPT_58_HAS_ARG           y
+#define OPT_58_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_58_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_58_CLI_LONG_TXT_A    "rl"
+#define OPT_58_CLI_LONG_TXT_B    "rule"
+#define OPT_58_TXT_HELP          "--rl|--rule"
+#define                          TXT_HELP__RULE \
+        OPT_58_TXT_HELP
+
+
+#define OPT_59_ENUM_NAME         OPT_NEXT_RULE
+#define OPT_59_OPT_PARSE         opt_parse_next_rule
+#define OPT_59_HAS_ARG           y
+#define OPT_59_INCOMPAT_GRPS     OPT_GRP_ARN
+#define OPT_59_CLI_SHORT_CODE    N
+#define OPT_59_CLI_LONG_TXT_A    "next-rule"
+#define OPT_59_TXT_HELP          "-N|--N|--next-rule"
+#define                          TXT_HELP__NEXT_RULE \
+        OPT_59_TXT_HELP
+
+
+#define OPT_60_ENUM_NAME         OPT_DATA
+#define OPT_60_OPT_PARSE         opt_parse_data
+#define OPT_60_HAS_ARG           y
+#define OPT_60_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_60_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_60_CLI_LONG_TXT_A    "data"
+#define OPT_60_TXT_HELP          "--data"
+#define                          TXT_HELP__DATA \
+        OPT_60_TXT_HELP
+
+
+#define OPT_61_ENUM_NAME         OPT_MASK
+#define OPT_61_OPT_PARSE         opt_parse_mask
+#define OPT_61_HAS_ARG           y
+#define OPT_61_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_61_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_61_CLI_LONG_TXT_A    "mask"
+#define OPT_61_TXT_HELP          "--mask"
+#define                          TXT_HELP__MASK \
+        OPT_61_TXT_HELP
+
+
+#define OPT_62_ENUM_NAME         OPT_LAYER
+#define OPT_62_OPT_PARSE         opt_parse_layer
+#define OPT_62_HAS_ARG           y
+#define OPT_62_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_62_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_62_CLI_LONG_TXT_A    "layer"
+#define OPT_62_TXT_HELP          "--layer"
+#define                          TXT_HELP__LAYER \
+        OPT_62_TXT_HELP
+
+
+#define OPT_63_ENUM_NAME         OPT_OFFSET
+#define OPT_63_OPT_PARSE         opt_parse_offset
+#define OPT_63_HAS_ARG           y
+#define OPT_63_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_63_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_63_CLI_LONG_TXT_A    "ofs"
+#define OPT_63_CLI_LONG_TXT_B    "offset"
+#define OPT_63_TXT_HELP          "--ofs|--offset"
+#define                          TXT_HELP__OFFSET \
+        OPT_63_TXT_HELP
+
+
+#define OPT_64_ENUM_NAME         OPT_INVERT
+#define OPT_64_OPT_PARSE         opt_parse_invert
+#define OPT_64_HAS_ARG           n
+#define OPT_64_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_64_CLI_SHORT_CODE    I
+#define OPT_64_CLI_LONG_TXT_A    "invert"
+#define OPT_64_TXT_HELP          "-I|--I|--invert"
+#define                          TXT_HELP__INVERT \
+        OPT_64_TXT_HELP
+
+
+#define OPT_65_ENUM_NAME         OPT_ACCEPT
+#define OPT_65_OPT_PARSE         opt_parse_accept
+#define OPT_65_HAS_ARG           n
+#define OPT_65_INCOMPAT_GRPS     OPT_GRP_ARN
+#define OPT_65_CLI_SHORT_CODE    A
+#define OPT_65_CLI_LONG_TXT_A    "accept"
+#define OPT_65_TXT_HELP          "-A|--A|--accept"
+#define                          TXT_HELP__ACCEPT \
+        OPT_65_TXT_HELP
+
+
+#define OPT_66_ENUM_NAME         OPT_REJECT
+#define OPT_66_OPT_PARSE         opt_parse_reject
+#define OPT_66_HAS_ARG           n
+#define OPT_66_INCOMPAT_GRPS     OPT_GRP_ARN
+#define OPT_66_CLI_SHORT_CODE    R
+#define OPT_66_CLI_LONG_TXT_A    "reject"
+#define OPT_66_TXT_HELP          "-R|--R|--reject"
+#define                          TXT_HELP__REJECT \
+        OPT_66_TXT_HELP
+
+
+#define OPT_67_ENUM_NAME         OPT_POSITION
+#define OPT_67_OPT_PARSE         opt_parse_position
+#define OPT_67_HAS_ARG           y
+#define OPT_67_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_67_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_67_CLI_LONG_TXT_A    "pos"
+#define OPT_67_CLI_LONG_TXT_B    "position"
+#define OPT_67_TXT_HELP          "--pos|--position"
+#define                          TXT_HELP__POSITION \
+        OPT_67_TXT_HELP
+
+
+#define OPT_68_ENUM_NAME         OPT_COUNT
+#define OPT_68_OPT_PARSE         opt_parse_count
+#define OPT_68_HAS_ARG           y
+#define OPT_68_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_68_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_68_CLI_LONG_TXT_A    "count"
+#define OPT_68_TXT_HELP          "--count"
+#define                          TXT_HELP__COUNT \
+        OPT_68_TXT_HELP
+
+
+#define OPT_69_ENUM_NAME         OPT_SAD
+#define OPT_69_OPT_PARSE         opt_parse_sad
+#define OPT_69_HAS_ARG           y
+#define OPT_69_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_69_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_69_CLI_LONG_TXT_A    "sad"
+#define OPT_69_TXT_HELP          "--sad"
+#define                          TXT_HELP__SAD \
+        OPT_69_TXT_HELP
+
+
+#define OPT_70_ENUM_NAME         OPT_SPD_ACTION
+#define OPT_70_OPT_PARSE         opt_parse_spd_action
+#define OPT_70_HAS_ARG           y
+#define OPT_70_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_70_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_70_CLI_LONG_TXT_A    "spdact"
+#define OPT_70_CLI_LONG_TXT_B    "spd-action"
+#define OPT_70_TXT_HELP          "--spdact|--spd-action"
+#define                          TXT_HELP__SPD_ACTION \
+        OPT_70_TXT_HELP
+
+
+#define OPT_71_ENUM_NAME         OPT_SPI
+#define OPT_71_OPT_PARSE         opt_parse_spi
+#define OPT_71_HAS_ARG           y
+#define OPT_71_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_71_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_71_CLI_LONG_TXT_A    "spi"
+#define OPT_71_TXT_HELP          "--spi"
+#define                          TXT_HELP__SPI \
+        OPT_71_TXT_HELP
+
+
+#define OPT_72_ENUM_NAME         OPT_FLEXIBLE_FILTER
+#define OPT_72_OPT_PARSE         opt_parse_flexible_filter
+#define OPT_72_HAS_ARG           y
+#define OPT_72_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_72_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_72_CLI_LONG_TXT_A    "ff"
+#define OPT_72_CLI_LONG_TXT_B    "flexible-filter"
+#define OPT_72_TXT_HELP          "--ff|--flexible-filter"
+#define                          TXT_HELP__FLEXIBLE_FILTER \
+        OPT_72_TXT_HELP
+
+
+#define OPT_73_ENUM_NAME         OPT_VLAN_CONF
+#define OPT_73_OPT_PARSE         opt_parse_vlan_conf
+#define OPT_73_HAS_ARG           y
+#define OPT_73_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_73_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_73_CLI_LONG_TXT_A    "vlan-conf"
+#define OPT_73_TXT_HELP          "--vlan-conf"
+#define                          TXT_HELP__VLAN_CONF \
+        OPT_73_TXT_HELP
+
+
+#define OPT_74_ENUM_NAME         OPT_PTP_CONF
+#define OPT_74_OPT_PARSE         opt_parse_ptp_conf
+#define OPT_74_HAS_ARG           y
+#define OPT_74_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_74_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_74_CLI_LONG_TXT_A    "ptp-conf"
+#define OPT_74_TXT_HELP          "--ptp-conf"
+#define                          TXT_HELP__PTP_CONF \
+        OPT_74_TXT_HELP
+
+
+#define OPT_75_ENUM_NAME         OPT_PTP_PROMISC
+#define OPT_75_OPT_PARSE         opt_parse_ptp_promisc
+#define OPT_75_HAS_ARG           y
+#define OPT_75_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_75_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_75_CLI_LONG_TXT_A    "ptp-promisc"
+#define OPT_75_TXT_HELP          "--ptp-promisc"
+#define                          TXT_HELP__PTP_PROMISC \
+        OPT_75_TXT_HELP
+
+
+#define OPT_76_ENUM_NAME         OPT_LOOPBACK
+#define OPT_76_OPT_PARSE         opt_parse_loopback
+#define OPT_76_HAS_ARG           y
+#define OPT_76_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_76_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_76_CLI_LONG_TXT_A    "loopback"
+#define OPT_76_TXT_HELP          "--loopback"
+#define                          TXT_HELP__LOOPBACK \
+        OPT_76_TXT_HELP
+
+
+#define OPT_77_ENUM_NAME         OPT_QINQ
+#define OPT_77_OPT_PARSE         opt_parse_qinq
+#define OPT_77_HAS_ARG           y
+#define OPT_77_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_77_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_77_CLI_LONG_TXT_A    "qinq"
+#define OPT_77_CLI_LONG_TXT_B    "q-in-q"
+#define OPT_77_TXT_HELP          "--qinq|--q-in-q"
+#define                          TXT_HELP__QINQ \
+        OPT_77_TXT_HELP
+
+
+#define OPT_78_ENUM_NAME         OPT_LOCAL
+#define OPT_78_OPT_PARSE         opt_parse_local
+#define OPT_78_HAS_ARG           y
+#define OPT_78_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_78_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_78_CLI_LONG_TXT_A    "local"
+#define OPT_78_TXT_HELP          "--local"
+#define                          TXT_HELP__LOCAL \
+        OPT_78_TXT_HELP
+
+
+#define OPT_79_ENUM_NAME         OPT_DISCARD_ON_MATCH_SRC
+#define OPT_79_OPT_PARSE         opt_parse_discard_on_match_src
+#define OPT_79_HAS_ARG           y
+#define OPT_79_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_79_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_79_CLI_LONG_TXT_A    "X-src"
+#define OPT_79_CLI_LONG_TXT_B    "discard-on-match-src"
+#define OPT_79_TXT_HELP          "--X-src|--discard-on-match-src"
+#define                          TXT_HELP__DISCARD_ON_MATCH_SRC \
+        OPT_79_TXT_HELP
+
+
+#define OPT_80_ENUM_NAME         OPT_DISCARD_ON_MATCH_DST
+#define OPT_80_OPT_PARSE         opt_parse_discard_on_match_dst
+#define OPT_80_HAS_ARG           y
+#define OPT_80_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_80_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_80_CLI_LONG_TXT_A    "X-dst"
+#define OPT_80_CLI_LONG_TXT_B    "discard-on-match-dst"
+#define OPT_80_TXT_HELP          "--X-dst|--discard-on-match-dst"
+#define                          TXT_HELP__DISCARD_ON_MATCH_DST \
+        OPT_80_TXT_HELP
+
+
+#define OPT_81_ENUM_NAME         OPT_FEATURE
+#define OPT_81_OPT_PARSE         opt_parse_feature
+#define OPT_81_HAS_ARG           y
+#define OPT_81_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_81_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_81_CLI_LONG_TXT_A    "feat"
+#define OPT_81_CLI_LONG_TXT_B    "feature"
+#define OPT_81_TXT_HELP          "--feat|--feature"
+#define                          TXT_HELP__FEATURE \
+        OPT_81_TXT_HELP
+
+
+#define OPT_82_ENUM_NAME         OPT_STATIC
+#define OPT_82_OPT_PARSE         opt_parse_static
+#define OPT_82_HAS_ARG           n
+#define OPT_82_INCOMPAT_GRPS     OPT_GRP_STATDYN
+#define OPT_82_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_82_CLI_LONG_TXT_A    "stent"
+#define OPT_82_CLI_LONG_TXT_B    "static"
+#define OPT_82_TXT_HELP          "--stent|--static"
+#define                          TXT_HELP__STATIC \
+        OPT_82_TXT_HELP
+
+
+#define OPT_83_ENUM_NAME         OPT_DYNAMIC
+#define OPT_83_OPT_PARSE         opt_parse_dynamic
+#define OPT_83_HAS_ARG           n
+#define OPT_83_INCOMPAT_GRPS     OPT_GRP_STATDYN
+#define OPT_83_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_83_CLI_LONG_TXT_A    "dent"
+#define OPT_83_CLI_LONG_TXT_B    "dynamic"
+#define OPT_83_TXT_HELP          "--dent|--dynamic"
+#define                          TXT_HELP__DYNAMIC \
+        OPT_83_TXT_HELP
+
+
+#define OPT_84_ENUM_NAME         OPT_QUE
+#define OPT_84_OPT_PARSE         opt_parse_que
+#define OPT_84_HAS_ARG           y
+#define OPT_84_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_84_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_84_CLI_LONG_TXT_A    "que"
+#define OPT_84_TXT_HELP          "--que"
+#define                          TXT_HELP__QUE \
+        OPT_84_TXT_HELP
+
+
+#define OPT_85_ENUM_NAME         OPT_SCH
+#define OPT_85_OPT_PARSE         opt_parse_sch
+#define OPT_85_HAS_ARG           y
+#define OPT_85_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_85_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_85_CLI_LONG_TXT_A    "sch"
+#define OPT_85_TXT_HELP          "--sch"
+#define                          TXT_HELP__SCH \
+        OPT_85_TXT_HELP
+
+
+#define OPT_86_ENUM_NAME         OPT_SHP
+#define OPT_86_OPT_PARSE         opt_parse_shp
+#define OPT_86_HAS_ARG           y
+#define OPT_86_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_86_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_86_CLI_LONG_TXT_A    "shp"
+#define OPT_86_TXT_HELP          "--shp"
+#define                          TXT_HELP__SHP \
+        OPT_86_TXT_HELP
+
+
+#define OPT_87_ENUM_NAME         OPT_QUE_MODE
+#define OPT_87_OPT_PARSE         opt_parse_que_mode
+#define OPT_87_HAS_ARG           y
+#define OPT_87_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_87_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_87_CLI_LONG_TXT_A    "que-mode"
+#define OPT_87_CLI_LONG_TXT_B    "qdisc"
+#define OPT_87_TXT_HELP          "--que-mode|--qdisc"
+#define                          TXT_HELP__QUE_MODE \
+        OPT_87_TXT_HELP
+
+
+#define OPT_88_ENUM_NAME         OPT_SCH_MODE
+#define OPT_88_OPT_PARSE         opt_parse_sch_mode
+#define OPT_88_HAS_ARG           y
+#define OPT_88_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_88_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_88_CLI_LONG_TXT_A    "sch-mode"
+#define OPT_88_TXT_HELP          "--sch-mode"
+#define                          TXT_HELP__SCH_MODE \
+        OPT_88_TXT_HELP
+
+
+#define OPT_89_ENUM_NAME         OPT_SHP_MODE
+#define OPT_89_OPT_PARSE         opt_parse_shp_mode
+#define OPT_89_HAS_ARG           y
+#define OPT_89_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_89_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_89_CLI_LONG_TXT_A    "shp-mode"
+#define OPT_89_TXT_HELP          "--shp-mode"
+#define                          TXT_HELP__SHP_MODE \
+        OPT_89_TXT_HELP
+
+
+#define OPT_90_ENUM_NAME         OPT_THMIN
+#define OPT_90_OPT_PARSE         opt_parse_thmin
+#define OPT_90_HAS_ARG           y
+#define OPT_90_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_90_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_90_CLI_LONG_TXT_A    "thmin"
+#define OPT_90_CLI_LONG_TXT_B    "thld-min"
+#define OPT_90_TXT_HELP          "--thmin|--thld-min"
+#define                          TXT_HELP__THMIN \
+        OPT_90_TXT_HELP
+
+
+#define OPT_91_ENUM_NAME         OPT_THMAX
+#define OPT_91_OPT_PARSE         opt_parse_thmax
+#define OPT_91_HAS_ARG           y
+#define OPT_91_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_91_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_91_CLI_LONG_TXT_A    "thmax"
+#define OPT_91_CLI_LONG_TXT_B    "thld-max"
+#define OPT_91_TXT_HELP          "--thmax|--thld-max"
+#define                          TXT_HELP__THMAX \
+        OPT_91_TXT_HELP
+
+
+#define OPT_92_ENUM_NAME         OPT_ZPROB
+#define OPT_92_OPT_PARSE         opt_parse_zprob
+#define OPT_92_HAS_ARG           y
+#define OPT_92_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_92_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_92_CLI_LONG_TXT_A    "zprob"
+#define OPT_92_TXT_HELP          "--zprob"
+#define                          TXT_HELP__ZPROB \
+        OPT_92_TXT_HELP
+
+
+#define OPT_93_ENUM_NAME         OPT_SCH_ALGO
+#define OPT_93_OPT_PARSE         opt_parse_sch_algo
+#define OPT_93_HAS_ARG           y
+#define OPT_93_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_93_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_93_CLI_LONG_TXT_A    "sch-algo"
+#define OPT_93_TXT_HELP          "--sch-algo"
+#define                          TXT_HELP__SCH_ALGO \
+        OPT_93_TXT_HELP
+
+
+#define OPT_94_ENUM_NAME         OPT_SCH_IN
+#define OPT_94_OPT_PARSE         opt_parse_sch_in
+#define OPT_94_HAS_ARG           y
+#define OPT_94_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_94_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_94_CLI_LONG_TXT_A    "sch-in"
+#define OPT_94_TXT_HELP          "--sch-in"
+#define                          TXT_HELP__SCH_IN \
+        OPT_94_TXT_HELP
+
+
+#define OPT_95_ENUM_NAME         OPT_SHP_POS
+#define OPT_95_OPT_PARSE         opt_parse_shp_pos
+#define OPT_95_HAS_ARG           y
+#define OPT_95_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_95_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_95_CLI_LONG_TXT_A    "shp-pos"
+#define OPT_95_TXT_HELP          "--shp-pos"
+#define                          TXT_HELP__SHP_POS \
+        OPT_95_TXT_HELP
+
+
+#define OPT_96_ENUM_NAME         OPT_ISL
+#define OPT_96_OPT_PARSE         opt_parse_isl
+#define OPT_96_HAS_ARG           y
+#define OPT_96_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_96_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_96_CLI_LONG_TXT_A    "isl"
+#define OPT_96_TXT_HELP          "--isl"
+#define                          TXT_HELP__ISL \
+        OPT_96_TXT_HELP
+
+
+#define OPT_97_ENUM_NAME         OPT_CRMIN
+#define OPT_97_OPT_PARSE         opt_parse_crmin
+#define OPT_97_HAS_ARG           y
+#define OPT_97_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_97_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_97_CLI_LONG_TXT_A    "crmin"
+#define OPT_97_CLI_LONG_TXT_B    "credit-min"
+#define OPT_97_TXT_HELP          "--crmin|--credit-min"
+#define                          TXT_HELP__CRMIN \
+        OPT_97_TXT_HELP
+
+
+#define OPT_98_ENUM_NAME         OPT_CRMAX
+#define OPT_98_OPT_PARSE         opt_parse_crmax
+#define OPT_98_HAS_ARG           y
+#define OPT_98_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_98_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_98_CLI_LONG_TXT_A    "crmax"
+#define OPT_98_CLI_LONG_TXT_B    "credit-max"
+#define OPT_98_TXT_HELP          "--crmax|--credit-max"
+#define                          TXT_HELP__CRMAX \
+        OPT_98_TXT_HELP
+
+
+#define OPT_99_ENUM_NAME         OPT_R_VLAN
+#define OPT_99_OPT_PARSE         opt_parse_r_vlan
+#define OPT_99_HAS_ARG           y
+#define OPT_99_INCOMPAT_GRPS     OPT_GRP_NONE
+#define OPT_99_CLI_SHORT_CODE    OPT_AUTO_CODE
+#define OPT_99_CLI_LONG_TXT_A    "r-vlan"
+#define OPT_99_TXT_HELP          "--r-vlan"
+#define                          TXT_HELP__R_VLAN \
+        OPT_99_TXT_HELP
+
+
+#define OPT_100_ENUM_NAME        OPT_TTL_DECR
+#define OPT_100_OPT_PARSE        opt_parse_ttl_decr
+#define OPT_100_HAS_ARG          y
+#define OPT_100_INCOMPAT_GRPS    OPT_GRP_NONE
+#define OPT_100_CLI_SHORT_CODE   OPT_AUTO_CODE
+#define OPT_100_CLI_LONG_TXT_A   "ttl-decr"
+#define OPT_100_CLI_LONG_TXT_B   "decr-ttl"
+#define OPT_100_TXT_HELP         "--ttl-decr | --decr-ttl"
+#define                          TXT_HELP__TTL_DECR \
+        OPT_100_TXT_HELP
+
+
+#define OPT_101_ENUM_NAME        OPT_DISCARD_IF_TTL_BELOW_2
+#define OPT_101_OPT_PARSE        opt_parse_discard_if_ttl_below_2
+#define OPT_101_HAS_ARG          y
+#define OPT_101_INCOMPAT_GRPS    OPT_GRP_NONE
+#define OPT_101_CLI_SHORT_CODE   OPT_AUTO_CODE
+#define OPT_101_CLI_LONG_TXT_A   "X-ttl"
+#define OPT_101_CLI_LONG_TXT_B   "discard-if-ttl-below-2"
+#define OPT_101_TXT_HELP         "--X-ttl | --discard-if-ttl-below-2"
+#define                          TXT_HELP__DISCARD_IF_TTL_BELOW_2 \
+        OPT_101_TXT_HELP
+
+
+
+
+
+/* OPT_LAST (keep this at the bottom of the cli option definition list) */
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+/* symbols for automatically generated content */
+#define OPT_MC_STR_AUX(ARG)          #ARG
+#define OPT_MC_STR(ARG)              OPT_MC_STR_AUX(ARG)
+#define OPT_MC_CCAT_AUX(ARG1, ARG2)  ARG1 ## ARG2
+#define OPT_MC_CCAT(ARG1, ARG2)      OPT_MC_CCAT_AUX(ARG1, ARG2)
+#define OPT_CHR_0  '0'
+#define OPT_CHR_1  '1'
+#define OPT_CHR_2  '2'
+#define OPT_CHR_3  '3'
+#define OPT_CHR_4  '4'
+#define OPT_CHR_5  '5'
+#define OPT_CHR_6  '6'
+#define OPT_CHR_7  '7'
+#define OPT_CHR_8  '8'
+#define OPT_CHR_9  '9'
+#define OPT_CHR_a  'a'
+#define OPT_CHR_b  'b'
+#define OPT_CHR_c  'c'
+#define OPT_CHR_d  'd'
+#define OPT_CHR_e  'e'
+#define OPT_CHR_f  'f'
+#define OPT_CHR_g  'g'
+#define OPT_CHR_h  'h'
+#define OPT_CHR_i  'i'
+#define OPT_CHR_j  'j'
+#define OPT_CHR_k  'k'
+#define OPT_CHR_l  'l'
+#define OPT_CHR_m  'm'
+#define OPT_CHR_n  'n'
+#define OPT_CHR_o  'o'
+#define OPT_CHR_p  'p'
+#define OPT_CHR_q  'q'
+#define OPT_CHR_r  'r'
+#define OPT_CHR_s  's'
+#define OPT_CHR_t  't'
+#define OPT_CHR_u  'u'
+#define OPT_CHR_v  'v'
+#define OPT_CHR_w  'w'
+#define OPT_CHR_x  'x'
+#define OPT_CHR_y  'y'
+#define OPT_CHR_z  'z'
+#define OPT_CHR_A  'A'
+#define OPT_CHR_B  'B'
+#define OPT_CHR_C  'C'
+#define OPT_CHR_D  'D'
+#define OPT_CHR_E  'E'
+#define OPT_CHR_F  'F'
+#define OPT_CHR_G  'G'
+#define OPT_CHR_H  'H'
+#define OPT_CHR_I  'I'
+#define OPT_CHR_J  'J'
+#define OPT_CHR_K  'K'
+#define OPT_CHR_L  'L'
+#define OPT_CHR_M  'M'
+#define OPT_CHR_N  'N'
+#define OPT_CHR_O  'O'
+#define OPT_CHR_P  'P'
+#define OPT_CHR_Q  'Q'
+#define OPT_CHR_R  'R'
+#define OPT_CHR_S  'S'
+#define OPT_CHR_T  'T'
+#define OPT_CHR_U  'U'
+#define OPT_CHR_V  'V'
+#define OPT_CHR_W  'W'
+#define OPT_CHR_X  'X'
+#define OPT_CHR_Y  'Y'
+#define OPT_CHR_Z  'Z'
+
+
+#ifdef OPT_01_ENUM_NAME
+  #define OPT_01_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_01_HAS_ARG)
+  #if (OPT_01_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_01_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_01_CLI_SHORT_CODE)
+    #define OPT_01_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_01_CLI_SHORT_CODE)
+  #else
+    #define OPT_01_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_02_ENUM_NAME
+  #define OPT_02_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_02_HAS_ARG)
+  #if (OPT_02_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_02_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_02_CLI_SHORT_CODE)
+    #define OPT_02_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_02_CLI_SHORT_CODE)
+  #else
+    #define OPT_02_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_03_ENUM_NAME
+  #define OPT_03_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_03_HAS_ARG)
+  #if (OPT_03_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_03_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_03_CLI_SHORT_CODE)
+    #define OPT_03_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_03_CLI_SHORT_CODE)
+  #else
+    #define OPT_03_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_04_ENUM_NAME
+  #define OPT_04_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_04_HAS_ARG)
+  #if (OPT_04_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_04_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_04_CLI_SHORT_CODE)
+    #define OPT_04_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_04_CLI_SHORT_CODE)
+  #else
+    #define OPT_04_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_05_ENUM_NAME
+  #define OPT_05_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_05_HAS_ARG)
+  #if (OPT_05_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_05_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_05_CLI_SHORT_CODE)
+    #define OPT_05_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_05_CLI_SHORT_CODE)
+  #else
+    #define OPT_05_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_06_ENUM_NAME
+  #define OPT_06_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_06_HAS_ARG)
+  #if (OPT_06_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_06_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_06_CLI_SHORT_CODE)
+    #define OPT_06_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_06_CLI_SHORT_CODE)
+  #else
+    #define OPT_06_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_07_ENUM_NAME
+  #define OPT_07_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_07_HAS_ARG)
+  #if (OPT_07_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_07_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_07_CLI_SHORT_CODE)
+    #define OPT_07_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_07_CLI_SHORT_CODE)
+  #else
+    #define OPT_07_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_08_ENUM_NAME
+  #define OPT_08_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_08_HAS_ARG)
+  #if (OPT_08_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_08_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_08_CLI_SHORT_CODE)
+    #define OPT_08_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_08_CLI_SHORT_CODE)
+  #else
+    #define OPT_08_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_09_ENUM_NAME
+  #define OPT_09_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_09_HAS_ARG)
+  #if (OPT_09_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_09_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_09_CLI_SHORT_CODE)
+    #define OPT_09_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_09_CLI_SHORT_CODE)
+  #else
+    #define OPT_09_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+
+#ifdef OPT_10_ENUM_NAME
+  #define OPT_10_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_10_HAS_ARG)
+  #if (OPT_10_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_10_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_10_CLI_SHORT_CODE)
+    #define OPT_10_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_10_CLI_SHORT_CODE)
+  #else
+    #define OPT_10_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_11_ENUM_NAME
+  #define OPT_11_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_11_HAS_ARG)
+  #if (OPT_11_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_11_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_11_CLI_SHORT_CODE)
+    #define OPT_11_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_11_CLI_SHORT_CODE)
+  #else
+    #define OPT_11_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_12_ENUM_NAME
+  #define OPT_12_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_12_HAS_ARG)
+  #if (OPT_12_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_12_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_12_CLI_SHORT_CODE)
+    #define OPT_12_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_12_CLI_SHORT_CODE)
+  #else
+    #define OPT_12_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_13_ENUM_NAME
+  #define OPT_13_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_13_HAS_ARG)
+  #if (OPT_13_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_13_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_13_CLI_SHORT_CODE)
+    #define OPT_13_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_13_CLI_SHORT_CODE)
+  #else
+    #define OPT_13_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_14_ENUM_NAME
+  #define OPT_14_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_14_HAS_ARG)
+  #if (OPT_14_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_14_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_14_CLI_SHORT_CODE)
+    #define OPT_14_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_14_CLI_SHORT_CODE)
+  #else
+    #define OPT_14_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_15_ENUM_NAME
+  #define OPT_15_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_15_HAS_ARG)
+  #if (OPT_15_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_15_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_15_CLI_SHORT_CODE)
+    #define OPT_15_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_15_CLI_SHORT_CODE)
+  #else
+    #define OPT_15_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_16_ENUM_NAME
+  #define OPT_16_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_16_HAS_ARG)
+  #if (OPT_16_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_16_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_16_CLI_SHORT_CODE)
+    #define OPT_16_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_16_CLI_SHORT_CODE)
+  #else
+    #define OPT_16_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_17_ENUM_NAME
+  #define OPT_17_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_17_HAS_ARG)
+  #if (OPT_17_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_17_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_17_CLI_SHORT_CODE)
+    #define OPT_17_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_17_CLI_SHORT_CODE)
+  #else
+    #define OPT_17_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_18_ENUM_NAME
+  #define OPT_18_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_18_HAS_ARG)
+  #if (OPT_18_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_18_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_18_CLI_SHORT_CODE)
+    #define OPT_18_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_18_CLI_SHORT_CODE)
+  #else
+    #define OPT_18_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_19_ENUM_NAME
+  #define OPT_19_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_19_HAS_ARG)
+  #if (OPT_19_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_19_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_19_CLI_SHORT_CODE)
+    #define OPT_19_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_19_CLI_SHORT_CODE)
+  #else
+    #define OPT_19_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+
+#ifdef OPT_20_ENUM_NAME
+  #define OPT_20_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_20_HAS_ARG)
+  #if (OPT_20_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_20_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_20_CLI_SHORT_CODE)
+    #define OPT_20_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_20_CLI_SHORT_CODE)
+  #else
+    #define OPT_20_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_21_ENUM_NAME
+  #define OPT_21_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_21_HAS_ARG)
+  #if (OPT_21_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_21_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_21_CLI_SHORT_CODE)
+    #define OPT_21_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_21_CLI_SHORT_CODE)
+  #else
+    #define OPT_21_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_22_ENUM_NAME
+  #define OPT_22_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_22_HAS_ARG)
+  #if (OPT_22_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_22_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_22_CLI_SHORT_CODE)
+    #define OPT_22_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_22_CLI_SHORT_CODE)
+  #else
+    #define OPT_22_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_23_ENUM_NAME
+  #define OPT_23_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_23_HAS_ARG)
+  #if (OPT_23_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_23_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_23_CLI_SHORT_CODE)
+    #define OPT_23_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_23_CLI_SHORT_CODE)
+  #else
+    #define OPT_23_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_24_ENUM_NAME
+  #define OPT_24_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_24_HAS_ARG)
+  #if (OPT_24_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_24_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_24_CLI_SHORT_CODE)
+    #define OPT_24_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_24_CLI_SHORT_CODE)
+  #else
+    #define OPT_24_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_25_ENUM_NAME
+  #define OPT_25_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_25_HAS_ARG)
+  #if (OPT_25_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_25_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_25_CLI_SHORT_CODE)
+    #define OPT_25_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_25_CLI_SHORT_CODE)
+  #else
+    #define OPT_25_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_26_ENUM_NAME
+  #define OPT_26_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_26_HAS_ARG)
+  #if (OPT_26_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_26_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_26_CLI_SHORT_CODE)
+    #define OPT_26_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_26_CLI_SHORT_CODE)
+  #else
+    #define OPT_26_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_27_ENUM_NAME
+  #define OPT_27_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_27_HAS_ARG)
+  #if (OPT_27_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_27_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_27_CLI_SHORT_CODE)
+    #define OPT_27_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_27_CLI_SHORT_CODE)
+  #else
+    #define OPT_27_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_28_ENUM_NAME
+  #define OPT_28_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_28_HAS_ARG)
+  #if (OPT_28_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_28_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_28_CLI_SHORT_CODE)
+    #define OPT_28_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_28_CLI_SHORT_CODE)
+  #else
+    #define OPT_28_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_29_ENUM_NAME
+  #define OPT_29_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_29_HAS_ARG)
+  #if (OPT_29_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_29_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_29_CLI_SHORT_CODE)
+    #define OPT_29_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_29_CLI_SHORT_CODE)
+  #else
+    #define OPT_29_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+
+#ifdef OPT_30_ENUM_NAME
+  #define OPT_30_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_30_HAS_ARG)
+  #if (OPT_30_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_30_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_30_CLI_SHORT_CODE)
+    #define OPT_30_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_30_CLI_SHORT_CODE)
+  #else
+    #define OPT_30_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_31_ENUM_NAME
+  #define OPT_31_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_31_HAS_ARG)
+  #if (OPT_31_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_31_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_31_CLI_SHORT_CODE)
+    #define OPT_31_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_31_CLI_SHORT_CODE)
+  #else
+    #define OPT_31_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_32_ENUM_NAME
+  #define OPT_32_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_32_HAS_ARG)
+  #if (OPT_32_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_32_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_32_CLI_SHORT_CODE)
+    #define OPT_32_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_32_CLI_SHORT_CODE)
+  #else
+    #define OPT_32_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_33_ENUM_NAME
+  #define OPT_33_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_33_HAS_ARG)
+  #if (OPT_33_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_33_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_33_CLI_SHORT_CODE)
+    #define OPT_33_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_33_CLI_SHORT_CODE)
+  #else
+    #define OPT_33_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_34_ENUM_NAME
+  #define OPT_34_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_34_HAS_ARG)
+  #if (OPT_34_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_34_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_34_CLI_SHORT_CODE)
+    #define OPT_34_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_34_CLI_SHORT_CODE)
+  #else
+    #define OPT_34_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_35_ENUM_NAME
+  #define OPT_35_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_35_HAS_ARG)
+  #if (OPT_35_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_35_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_35_CLI_SHORT_CODE)
+    #define OPT_35_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_35_CLI_SHORT_CODE)
+  #else
+    #define OPT_35_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_36_ENUM_NAME
+  #define OPT_36_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_36_HAS_ARG)
+  #if (OPT_36_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_36_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_36_CLI_SHORT_CODE)
+    #define OPT_36_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_36_CLI_SHORT_CODE)
+  #else
+    #define OPT_36_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_37_ENUM_NAME
+  #define OPT_37_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_37_HAS_ARG)
+  #if (OPT_37_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_37_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_37_CLI_SHORT_CODE)
+    #define OPT_37_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_37_CLI_SHORT_CODE)
+  #else
+    #define OPT_37_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_38_ENUM_NAME
+  #define OPT_38_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_38_HAS_ARG)
+  #if (OPT_38_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_38_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_38_CLI_SHORT_CODE)
+    #define OPT_38_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_38_CLI_SHORT_CODE)
+  #else
+    #define OPT_38_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_39_ENUM_NAME
+  #define OPT_39_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_39_HAS_ARG)
+  #if (OPT_39_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_39_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_39_CLI_SHORT_CODE)
+    #define OPT_39_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_39_CLI_SHORT_CODE)
+  #else
+    #define OPT_39_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+
+#ifdef OPT_40_ENUM_NAME
+  #define OPT_40_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_40_HAS_ARG)
+  #if (OPT_40_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_40_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_40_CLI_SHORT_CODE)
+    #define OPT_40_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_40_CLI_SHORT_CODE)
+  #else
+    #define OPT_40_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_41_ENUM_NAME
+  #define OPT_41_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_41_HAS_ARG)
+  #if (OPT_41_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_41_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_41_CLI_SHORT_CODE)
+    #define OPT_41_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_41_CLI_SHORT_CODE)
+  #else
+    #define OPT_41_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_42_ENUM_NAME
+  #define OPT_42_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_42_HAS_ARG)
+  #if (OPT_42_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_42_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_42_CLI_SHORT_CODE)
+    #define OPT_42_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_42_CLI_SHORT_CODE)
+  #else
+    #define OPT_42_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_43_ENUM_NAME
+  #define OPT_43_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_43_HAS_ARG)
+  #if (OPT_43_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_43_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_43_CLI_SHORT_CODE)
+    #define OPT_43_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_43_CLI_SHORT_CODE)
+  #else
+    #define OPT_43_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_44_ENUM_NAME
+  #define OPT_44_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_44_HAS_ARG)
+  #if (OPT_44_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_44_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_44_CLI_SHORT_CODE)
+    #define OPT_44_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_44_CLI_SHORT_CODE)
+  #else
+    #define OPT_44_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_45_ENUM_NAME
+  #define OPT_45_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_45_HAS_ARG)
+  #if (OPT_45_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_45_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_45_CLI_SHORT_CODE)
+    #define OPT_45_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_45_CLI_SHORT_CODE)
+  #else
+    #define OPT_45_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_46_ENUM_NAME
+  #define OPT_46_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_46_HAS_ARG)
+  #if (OPT_46_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_46_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_46_CLI_SHORT_CODE)
+    #define OPT_46_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_46_CLI_SHORT_CODE)
+  #else
+    #define OPT_46_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_47_ENUM_NAME
+  #define OPT_47_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_47_HAS_ARG)
+  #if (OPT_47_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_47_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_47_CLI_SHORT_CODE)
+    #define OPT_47_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_47_CLI_SHORT_CODE)
+  #else
+    #define OPT_47_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_48_ENUM_NAME
+  #define OPT_48_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_48_HAS_ARG)
+  #if (OPT_48_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_48_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_48_CLI_SHORT_CODE)
+    #define OPT_48_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_48_CLI_SHORT_CODE)
+  #else
+    #define OPT_48_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_49_ENUM_NAME
+  #define OPT_49_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_49_HAS_ARG)
+  #if (OPT_49_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_49_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_49_CLI_SHORT_CODE)
+    #define OPT_49_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_49_CLI_SHORT_CODE)
+  #else
+    #define OPT_49_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+
+#ifdef OPT_50_ENUM_NAME
+  #define OPT_50_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_50_HAS_ARG)
+  #if (OPT_50_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_50_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_50_CLI_SHORT_CODE)
+    #define OPT_50_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_50_CLI_SHORT_CODE)
+  #else
+    #define OPT_50_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_51_ENUM_NAME
+  #define OPT_51_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_51_HAS_ARG)
+  #if (OPT_51_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_51_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_51_CLI_SHORT_CODE)
+    #define OPT_51_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_51_CLI_SHORT_CODE)
+  #else
+    #define OPT_51_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_52_ENUM_NAME
+  #define OPT_52_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_52_HAS_ARG)
+  #if (OPT_52_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_52_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_52_CLI_SHORT_CODE)
+    #define OPT_52_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_52_CLI_SHORT_CODE)
+  #else
+    #define OPT_52_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_53_ENUM_NAME
+  #define OPT_53_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_53_HAS_ARG)
+  #if (OPT_53_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_53_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_53_CLI_SHORT_CODE)
+    #define OPT_53_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_53_CLI_SHORT_CODE)
+  #else
+    #define OPT_53_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_54_ENUM_NAME
+  #define OPT_54_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_54_HAS_ARG)
+  #if (OPT_54_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_54_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_54_CLI_SHORT_CODE)
+    #define OPT_54_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_54_CLI_SHORT_CODE)
+  #else
+    #define OPT_54_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_55_ENUM_NAME
+  #define OPT_55_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_55_HAS_ARG)
+  #if (OPT_55_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_55_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_55_CLI_SHORT_CODE)
+    #define OPT_55_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_55_CLI_SHORT_CODE)
+  #else
+    #define OPT_55_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_56_ENUM_NAME
+  #define OPT_56_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_56_HAS_ARG)
+  #if (OPT_56_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_56_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_56_CLI_SHORT_CODE)
+    #define OPT_56_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_56_CLI_SHORT_CODE)
+  #else
+    #define OPT_56_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_57_ENUM_NAME
+  #define OPT_57_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_57_HAS_ARG)
+  #if (OPT_57_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_57_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_57_CLI_SHORT_CODE)
+    #define OPT_57_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_57_CLI_SHORT_CODE)
+  #else
+    #define OPT_57_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_58_ENUM_NAME
+  #define OPT_58_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_58_HAS_ARG)
+  #if (OPT_58_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_58_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_58_CLI_SHORT_CODE)
+    #define OPT_58_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_58_CLI_SHORT_CODE)
+  #else
+    #define OPT_58_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_59_ENUM_NAME
+  #define OPT_59_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_59_HAS_ARG)
+  #if (OPT_59_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_59_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_59_CLI_SHORT_CODE)
+    #define OPT_59_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_59_CLI_SHORT_CODE)
+  #else
+    #define OPT_59_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+
+#ifdef OPT_60_ENUM_NAME
+  #define OPT_60_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_60_HAS_ARG)
+  #if (OPT_60_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_60_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_60_CLI_SHORT_CODE)
+    #define OPT_60_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_60_CLI_SHORT_CODE)
+  #else
+    #define OPT_60_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_61_ENUM_NAME
+  #define OPT_61_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_61_HAS_ARG)
+  #if (OPT_61_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_61_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_61_CLI_SHORT_CODE)
+    #define OPT_61_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_61_CLI_SHORT_CODE)
+  #else
+    #define OPT_61_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_62_ENUM_NAME
+  #define OPT_62_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_62_HAS_ARG)
+  #if (OPT_62_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_62_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_62_CLI_SHORT_CODE)
+    #define OPT_62_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_62_CLI_SHORT_CODE)
+  #else
+    #define OPT_62_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_63_ENUM_NAME
+  #define OPT_63_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_63_HAS_ARG)
+  #if (OPT_63_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_63_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_63_CLI_SHORT_CODE)
+    #define OPT_63_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_63_CLI_SHORT_CODE)
+  #else
+    #define OPT_63_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_64_ENUM_NAME
+  #define OPT_64_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_64_HAS_ARG)
+  #if (OPT_64_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_64_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_64_CLI_SHORT_CODE)
+    #define OPT_64_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_64_CLI_SHORT_CODE)
+  #else
+    #define OPT_64_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_65_ENUM_NAME
+  #define OPT_65_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_65_HAS_ARG)
+  #if (OPT_65_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_65_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_65_CLI_SHORT_CODE)
+    #define OPT_65_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_65_CLI_SHORT_CODE)
+  #else
+    #define OPT_65_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_66_ENUM_NAME
+  #define OPT_66_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_66_HAS_ARG)
+  #if (OPT_66_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_66_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_66_CLI_SHORT_CODE)
+    #define OPT_66_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_66_CLI_SHORT_CODE)
+  #else
+    #define OPT_66_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_67_ENUM_NAME
+  #define OPT_67_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_67_HAS_ARG)
+  #if (OPT_67_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_67_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_67_CLI_SHORT_CODE)
+    #define OPT_67_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_67_CLI_SHORT_CODE)
+  #else
+    #define OPT_67_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_68_ENUM_NAME
+  #define OPT_68_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_68_HAS_ARG)
+  #if (OPT_68_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_68_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_68_CLI_SHORT_CODE)
+    #define OPT_68_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_68_CLI_SHORT_CODE)
+  #else
+    #define OPT_68_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_69_ENUM_NAME
+  #define OPT_69_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_69_HAS_ARG)
+  #if (OPT_69_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_69_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_69_CLI_SHORT_CODE)
+    #define OPT_69_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_69_CLI_SHORT_CODE)
+  #else
+    #define OPT_69_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+
+#ifdef OPT_70_ENUM_NAME
+  #define OPT_70_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_70_HAS_ARG)
+  #if (OPT_70_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_70_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_70_CLI_SHORT_CODE)
+    #define OPT_70_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_70_CLI_SHORT_CODE)
+  #else
+    #define OPT_70_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_71_ENUM_NAME
+  #define OPT_71_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_71_HAS_ARG)
+  #if (OPT_71_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_71_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_71_CLI_SHORT_CODE)
+    #define OPT_71_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_71_CLI_SHORT_CODE)
+  #else
+    #define OPT_71_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_72_ENUM_NAME
+  #define OPT_72_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_72_HAS_ARG)
+  #if (OPT_72_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_72_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_72_CLI_SHORT_CODE)
+    #define OPT_72_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_72_CLI_SHORT_CODE)
+  #else
+    #define OPT_72_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_73_ENUM_NAME
+  #define OPT_73_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_73_HAS_ARG)
+  #if (OPT_73_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_73_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_73_CLI_SHORT_CODE)
+    #define OPT_73_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_73_CLI_SHORT_CODE)
+  #else
+    #define OPT_73_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_74_ENUM_NAME
+  #define OPT_74_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_74_HAS_ARG)
+  #if (OPT_74_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_74_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_74_CLI_SHORT_CODE)
+    #define OPT_74_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_74_CLI_SHORT_CODE)
+  #else
+    #define OPT_74_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_75_ENUM_NAME
+  #define OPT_75_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_75_HAS_ARG)
+  #if (OPT_75_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_75_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_75_CLI_SHORT_CODE)
+    #define OPT_75_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_75_CLI_SHORT_CODE)
+  #else
+    #define OPT_75_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_76_ENUM_NAME
+  #define OPT_76_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_76_HAS_ARG)
+  #if (OPT_76_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_76_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_76_CLI_SHORT_CODE)
+    #define OPT_76_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_76_CLI_SHORT_CODE)
+  #else
+    #define OPT_76_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_77_ENUM_NAME
+  #define OPT_77_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_77_HAS_ARG)
+  #if (OPT_77_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_77_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_77_CLI_SHORT_CODE)
+    #define OPT_77_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_77_CLI_SHORT_CODE)
+  #else
+    #define OPT_77_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_78_ENUM_NAME
+  #define OPT_78_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_78_HAS_ARG)
+  #if (OPT_78_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_78_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_78_CLI_SHORT_CODE)
+    #define OPT_78_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_78_CLI_SHORT_CODE)
+  #else
+    #define OPT_78_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_79_ENUM_NAME
+  #define OPT_79_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_79_HAS_ARG)
+  #if (OPT_79_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_79_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_79_CLI_SHORT_CODE)
+    #define OPT_79_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_79_CLI_SHORT_CODE)
+  #else
+    #define OPT_79_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+
+#ifdef OPT_80_ENUM_NAME
+  #define OPT_80_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_80_HAS_ARG)
+  #if (OPT_80_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_80_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_80_CLI_SHORT_CODE)
+    #define OPT_80_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_80_CLI_SHORT_CODE)
+  #else
+    #define OPT_80_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_81_ENUM_NAME
+  #define OPT_81_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_81_HAS_ARG)
+  #if (OPT_81_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_81_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_81_CLI_SHORT_CODE)
+    #define OPT_81_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_81_CLI_SHORT_CODE)
+  #else
+    #define OPT_81_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_82_ENUM_NAME
+  #define OPT_82_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_82_HAS_ARG)
+  #if (OPT_82_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_82_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_82_CLI_SHORT_CODE)
+    #define OPT_82_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_82_CLI_SHORT_CODE)
+  #else
+    #define OPT_82_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_83_ENUM_NAME
+  #define OPT_83_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_83_HAS_ARG)
+  #if (OPT_83_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_83_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_83_CLI_SHORT_CODE)
+    #define OPT_83_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_83_CLI_SHORT_CODE)
+  #else
+    #define OPT_83_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_84_ENUM_NAME
+  #define OPT_84_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_84_HAS_ARG)
+  #if (OPT_84_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_84_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_84_CLI_SHORT_CODE)
+    #define OPT_84_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_84_CLI_SHORT_CODE)
+  #else
+    #define OPT_84_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_85_ENUM_NAME
+  #define OPT_85_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_85_HAS_ARG)
+  #if (OPT_85_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_85_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_85_CLI_SHORT_CODE)
+    #define OPT_85_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_85_CLI_SHORT_CODE)
+  #else
+    #define OPT_85_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_86_ENUM_NAME
+  #define OPT_86_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_86_HAS_ARG)
+  #if (OPT_86_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_86_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_86_CLI_SHORT_CODE)
+    #define OPT_86_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_86_CLI_SHORT_CODE)
+  #else
+    #define OPT_86_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_87_ENUM_NAME
+  #define OPT_87_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_87_HAS_ARG)
+  #if (OPT_87_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_87_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_87_CLI_SHORT_CODE)
+    #define OPT_87_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_87_CLI_SHORT_CODE)
+  #else
+    #define OPT_87_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_88_ENUM_NAME
+  #define OPT_88_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_88_HAS_ARG)
+  #if (OPT_88_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_88_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_88_CLI_SHORT_CODE)
+    #define OPT_88_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_88_CLI_SHORT_CODE)
+  #else
+    #define OPT_88_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_89_ENUM_NAME
+  #define OPT_89_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_89_HAS_ARG)
+  #if (OPT_89_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_89_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_89_CLI_SHORT_CODE)
+    #define OPT_89_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_89_CLI_SHORT_CODE)
+  #else
+    #define OPT_89_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+
+#ifdef OPT_90_ENUM_NAME
+  #define OPT_90_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_90_HAS_ARG)
+  #if (OPT_90_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_90_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_90_CLI_SHORT_CODE)
+    #define OPT_90_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_90_CLI_SHORT_CODE)
+  #else
+    #define OPT_90_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_91_ENUM_NAME
+  #define OPT_91_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_91_HAS_ARG)
+  #if (OPT_91_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_91_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_91_CLI_SHORT_CODE)
+    #define OPT_91_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_91_CLI_SHORT_CODE)
+  #else
+    #define OPT_91_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_92_ENUM_NAME
+  #define OPT_92_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_92_HAS_ARG)
+  #if (OPT_92_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_92_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_92_CLI_SHORT_CODE)
+    #define OPT_92_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_92_CLI_SHORT_CODE)
+  #else
+    #define OPT_92_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_93_ENUM_NAME
+  #define OPT_93_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_93_HAS_ARG)
+  #if (OPT_93_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_93_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_93_CLI_SHORT_CODE)
+    #define OPT_93_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_93_CLI_SHORT_CODE)
+  #else
+    #define OPT_93_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_94_ENUM_NAME
+  #define OPT_94_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_94_HAS_ARG)
+  #if (OPT_94_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_94_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_94_CLI_SHORT_CODE)
+    #define OPT_94_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_94_CLI_SHORT_CODE)
+  #else
+    #define OPT_94_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_95_ENUM_NAME
+  #define OPT_95_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_95_HAS_ARG)
+  #if (OPT_95_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_95_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_95_CLI_SHORT_CODE)
+    #define OPT_95_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_95_CLI_SHORT_CODE)
+  #else
+    #define OPT_95_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_96_ENUM_NAME
+  #define OPT_96_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_96_HAS_ARG)
+  #if (OPT_96_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_96_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_96_CLI_SHORT_CODE)
+    #define OPT_96_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_96_CLI_SHORT_CODE)
+  #else
+    #define OPT_96_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_97_ENUM_NAME
+  #define OPT_97_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_97_HAS_ARG)
+  #if (OPT_97_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_97_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_97_CLI_SHORT_CODE)
+    #define OPT_97_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_97_CLI_SHORT_CODE)
+  #else
+    #define OPT_97_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_98_ENUM_NAME
+  #define OPT_98_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_98_HAS_ARG)
+  #if (OPT_98_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_98_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_98_CLI_SHORT_CODE)
+    #define OPT_98_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_98_CLI_SHORT_CODE)
+  #else
+    #define OPT_98_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_99_ENUM_NAME
+  #define OPT_99_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_99_HAS_ARG)
+  #if (OPT_99_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_99_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_99_CLI_SHORT_CODE)
+    #define OPT_99_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_99_CLI_SHORT_CODE)
+  #else
+    #define OPT_99_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+
+#ifdef OPT_100_ENUM_NAME
+  #define OPT_100_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_100_HAS_ARG)
+  #if (OPT_100_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_100_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_100_CLI_SHORT_CODE)
+    #define OPT_100_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_100_CLI_SHORT_CODE)
+  #else
+    #define OPT_100_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_101_ENUM_NAME
+  #define OPT_101_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_101_HAS_ARG)
+  #if (OPT_101_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_101_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_101_CLI_SHORT_CODE)
+    #define OPT_101_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_101_CLI_SHORT_CODE)
+  #else
+    #define OPT_101_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_102_ENUM_NAME
+  #define OPT_102_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_102_HAS_ARG)
+  #if (OPT_102_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_102_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_102_CLI_SHORT_CODE)
+    #define OPT_102_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_102_CLI_SHORT_CODE)
+  #else
+    #define OPT_102_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_103_ENUM_NAME
+  #define OPT_103_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_103_HAS_ARG)
+  #if (OPT_103_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_103_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_103_CLI_SHORT_CODE)
+    #define OPT_103_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_103_CLI_SHORT_CODE)
+  #else
+    #define OPT_103_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_104_ENUM_NAME
+  #define OPT_104_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_104_HAS_ARG)
+  #if (OPT_104_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_104_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_104_CLI_SHORT_CODE)
+    #define OPT_104_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_104_CLI_SHORT_CODE)
+  #else
+    #define OPT_104_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_105_ENUM_NAME
+  #define OPT_105_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_105_HAS_ARG)
+  #if (OPT_105_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_105_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_105_CLI_SHORT_CODE)
+    #define OPT_105_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_105_CLI_SHORT_CODE)
+  #else
+    #define OPT_105_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_106_ENUM_NAME
+  #define OPT_106_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_106_HAS_ARG)
+  #if (OPT_106_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_106_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_106_CLI_SHORT_CODE)
+    #define OPT_106_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_106_CLI_SHORT_CODE)
+  #else
+    #define OPT_106_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_107_ENUM_NAME
+  #define OPT_107_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_107_HAS_ARG)
+  #if (OPT_107_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_107_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_107_CLI_SHORT_CODE)
+    #define OPT_107_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_107_CLI_SHORT_CODE)
+  #else
+    #define OPT_107_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_108_ENUM_NAME
+  #define OPT_108_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_108_HAS_ARG)
+  #if (OPT_108_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_108_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_108_CLI_SHORT_CODE)
+    #define OPT_108_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_108_CLI_SHORT_CODE)
+  #else
+    #define OPT_108_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_109_ENUM_NAME
+  #define OPT_109_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_109_HAS_ARG)
+  #if (OPT_109_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_109_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_109_CLI_SHORT_CODE)
+    #define OPT_109_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_109_CLI_SHORT_CODE)
+  #else
+    #define OPT_109_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+
+#ifdef OPT_110_ENUM_NAME
+  #define OPT_110_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_110_HAS_ARG)
+  #if (OPT_110_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_110_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_110_CLI_SHORT_CODE)
+    #define OPT_110_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_110_CLI_SHORT_CODE)
+  #else
+    #define OPT_110_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_111_ENUM_NAME
+  #define OPT_111_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_111_HAS_ARG)
+  #if (OPT_111_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_111_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_111_CLI_SHORT_CODE)
+    #define OPT_111_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_111_CLI_SHORT_CODE)
+  #else
+    #define OPT_111_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_112_ENUM_NAME
+  #define OPT_112_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_112_HAS_ARG)
+  #if (OPT_112_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_112_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_112_CLI_SHORT_CODE)
+    #define OPT_112_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_112_CLI_SHORT_CODE)
+  #else
+    #define OPT_112_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_113_ENUM_NAME
+  #define OPT_113_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_113_HAS_ARG)
+  #if (OPT_113_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_113_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_113_CLI_SHORT_CODE)
+    #define OPT_113_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_113_CLI_SHORT_CODE)
+  #else
+    #define OPT_113_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_114_ENUM_NAME
+  #define OPT_114_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_114_HAS_ARG)
+  #if (OPT_114_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_114_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_114_CLI_SHORT_CODE)
+    #define OPT_114_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_114_CLI_SHORT_CODE)
+  #else
+    #define OPT_114_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_115_ENUM_NAME
+  #define OPT_115_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_115_HAS_ARG)
+  #if (OPT_115_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_115_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_115_CLI_SHORT_CODE)
+    #define OPT_115_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_115_CLI_SHORT_CODE)
+  #else
+    #define OPT_115_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_116_ENUM_NAME
+  #define OPT_116_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_116_HAS_ARG)
+  #if (OPT_116_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_116_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_116_CLI_SHORT_CODE)
+    #define OPT_116_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_116_CLI_SHORT_CODE)
+  #else
+    #define OPT_116_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_117_ENUM_NAME
+  #define OPT_117_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_117_HAS_ARG)
+  #if (OPT_117_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_117_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_117_CLI_SHORT_CODE)
+    #define OPT_117_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_117_CLI_SHORT_CODE)
+  #else
+    #define OPT_117_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_118_ENUM_NAME
+  #define OPT_118_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_118_HAS_ARG)
+  #if (OPT_118_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_118_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_118_CLI_SHORT_CODE)
+    #define OPT_118_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_118_CLI_SHORT_CODE)
+  #else
+    #define OPT_118_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_119_ENUM_NAME
+  #define OPT_119_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_119_HAS_ARG)
+  #if (OPT_119_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_119_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_119_CLI_SHORT_CODE)
+    #define OPT_119_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_119_CLI_SHORT_CODE)
+  #else
+    #define OPT_119_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+
+#ifdef OPT_120_ENUM_NAME
+  #define OPT_120_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_120_HAS_ARG)
+  #if (OPT_120_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_120_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_120_CLI_SHORT_CODE)
+    #define OPT_120_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_120_CLI_SHORT_CODE)
+  #else
+    #define OPT_120_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_121_ENUM_NAME
+  #define OPT_121_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_121_HAS_ARG)
+  #if (OPT_121_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_121_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_121_CLI_SHORT_CODE)
+    #define OPT_121_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_121_CLI_SHORT_CODE)
+  #else
+    #define OPT_121_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_122_ENUM_NAME
+  #define OPT_122_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_122_HAS_ARG)
+  #if (OPT_122_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_122_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_122_CLI_SHORT_CODE)
+    #define OPT_122_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_122_CLI_SHORT_CODE)
+  #else
+    #define OPT_122_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_123_ENUM_NAME
+  #define OPT_123_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_123_HAS_ARG)
+  #if (OPT_123_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_123_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_123_CLI_SHORT_CODE)
+    #define OPT_123_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_123_CLI_SHORT_CODE)
+  #else
+    #define OPT_123_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_124_ENUM_NAME
+  #define OPT_124_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_124_HAS_ARG)
+  #if (OPT_124_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_124_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_124_CLI_SHORT_CODE)
+    #define OPT_124_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_124_CLI_SHORT_CODE)
+  #else
+    #define OPT_124_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_125_ENUM_NAME
+  #define OPT_125_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_125_HAS_ARG)
+  #if (OPT_125_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_125_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_125_CLI_SHORT_CODE)
+    #define OPT_125_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_125_CLI_SHORT_CODE)
+  #else
+    #define OPT_125_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_126_ENUM_NAME
+  #define OPT_126_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_126_HAS_ARG)
+  #if (OPT_126_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_126_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_126_CLI_SHORT_CODE)
+    #define OPT_126_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_126_CLI_SHORT_CODE)
+  #else
+    #define OPT_126_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_127_ENUM_NAME
+  #define OPT_127_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_127_HAS_ARG)
+  #if (OPT_127_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_127_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_127_CLI_SHORT_CODE)
+    #define OPT_127_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_127_CLI_SHORT_CODE)
+  #else
+    #define OPT_127_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_128_ENUM_NAME
+  #define OPT_128_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_128_HAS_ARG)
+  #if (OPT_128_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_128_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_128_CLI_SHORT_CODE)
+    #define OPT_128_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_128_CLI_SHORT_CODE)
+  #else
+    #define OPT_128_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_129_ENUM_NAME
+  #define OPT_129_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_129_HAS_ARG)
+  #if (OPT_129_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_129_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_129_CLI_SHORT_CODE)
+    #define OPT_129_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_129_CLI_SHORT_CODE)
+  #else
+    #define OPT_129_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+
+#ifdef OPT_130_ENUM_NAME
+  #define OPT_130_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_130_HAS_ARG)
+  #if (OPT_130_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_130_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_130_CLI_SHORT_CODE)
+    #define OPT_130_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_130_CLI_SHORT_CODE)
+  #else
+    #define OPT_130_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_131_ENUM_NAME
+  #define OPT_131_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_131_HAS_ARG)
+  #if (OPT_131_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_131_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_131_CLI_SHORT_CODE)
+    #define OPT_131_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_131_CLI_SHORT_CODE)
+  #else
+    #define OPT_131_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_132_ENUM_NAME
+  #define OPT_132_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_132_HAS_ARG)
+  #if (OPT_132_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_132_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_132_CLI_SHORT_CODE)
+    #define OPT_132_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_132_CLI_SHORT_CODE)
+  #else
+    #define OPT_132_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_133_ENUM_NAME
+  #define OPT_133_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_133_HAS_ARG)
+  #if (OPT_133_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_133_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_133_CLI_SHORT_CODE)
+    #define OPT_133_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_133_CLI_SHORT_CODE)
+  #else
+    #define OPT_133_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_134_ENUM_NAME
+  #define OPT_134_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_134_HAS_ARG)
+  #if (OPT_134_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_134_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_134_CLI_SHORT_CODE)
+    #define OPT_134_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_134_CLI_SHORT_CODE)
+  #else
+    #define OPT_134_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_135_ENUM_NAME
+  #define OPT_135_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_135_HAS_ARG)
+  #if (OPT_135_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_135_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_135_CLI_SHORT_CODE)
+    #define OPT_135_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_135_CLI_SHORT_CODE)
+  #else
+    #define OPT_135_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_136_ENUM_NAME
+  #define OPT_136_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_136_HAS_ARG)
+  #if (OPT_136_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_136_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_136_CLI_SHORT_CODE)
+    #define OPT_136_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_136_CLI_SHORT_CODE)
+  #else
+    #define OPT_136_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_137_ENUM_NAME
+  #define OPT_137_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_137_HAS_ARG)
+  #if (OPT_137_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_137_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_137_CLI_SHORT_CODE)
+    #define OPT_137_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_137_CLI_SHORT_CODE)
+  #else
+    #define OPT_137_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_138_ENUM_NAME
+  #define OPT_138_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_138_HAS_ARG)
+  #if (OPT_138_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_138_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_138_CLI_SHORT_CODE)
+    #define OPT_138_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_138_CLI_SHORT_CODE)
+  #else
+    #define OPT_138_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_139_ENUM_NAME
+  #define OPT_139_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_139_HAS_ARG)
+  #if (OPT_139_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_139_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_139_CLI_SHORT_CODE)
+    #define OPT_139_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_139_CLI_SHORT_CODE)
+  #else
+    #define OPT_139_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+
+#ifdef OPT_140_ENUM_NAME
+  #define OPT_140_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_140_HAS_ARG)
+  #if (OPT_140_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_140_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_140_CLI_SHORT_CODE)
+    #define OPT_140_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_140_CLI_SHORT_CODE)
+  #else
+    #define OPT_140_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_141_ENUM_NAME
+  #define OPT_141_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_141_HAS_ARG)
+  #if (OPT_141_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_141_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_141_CLI_SHORT_CODE)
+    #define OPT_141_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_141_CLI_SHORT_CODE)
+  #else
+    #define OPT_141_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_142_ENUM_NAME
+  #define OPT_142_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_142_HAS_ARG)
+  #if (OPT_142_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_142_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_142_CLI_SHORT_CODE)
+    #define OPT_142_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_142_CLI_SHORT_CODE)
+  #else
+    #define OPT_142_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_143_ENUM_NAME
+  #define OPT_143_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_143_HAS_ARG)
+  #if (OPT_143_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_143_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_143_CLI_SHORT_CODE)
+    #define OPT_143_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_143_CLI_SHORT_CODE)
+  #else
+    #define OPT_143_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_144_ENUM_NAME
+  #define OPT_144_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_144_HAS_ARG)
+  #if (OPT_144_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_144_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_144_CLI_SHORT_CODE)
+    #define OPT_144_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_144_CLI_SHORT_CODE)
+  #else
+    #define OPT_144_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_145_ENUM_NAME
+  #define OPT_145_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_145_HAS_ARG)
+  #if (OPT_145_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_145_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_145_CLI_SHORT_CODE)
+    #define OPT_145_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_145_CLI_SHORT_CODE)
+  #else
+    #define OPT_145_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_146_ENUM_NAME
+  #define OPT_146_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_146_HAS_ARG)
+  #if (OPT_146_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_146_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_146_CLI_SHORT_CODE)
+    #define OPT_146_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_146_CLI_SHORT_CODE)
+  #else
+    #define OPT_146_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_147_ENUM_NAME
+  #define OPT_147_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_147_HAS_ARG)
+  #if (OPT_147_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_147_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_147_CLI_SHORT_CODE)
+    #define OPT_147_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_147_CLI_SHORT_CODE)
+  #else
+    #define OPT_147_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_148_ENUM_NAME
+  #define OPT_148_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_148_HAS_ARG)
+  #if (OPT_148_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_148_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_148_CLI_SHORT_CODE)
+    #define OPT_148_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_148_CLI_SHORT_CODE)
+  #else
+    #define OPT_148_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_149_ENUM_NAME
+  #define OPT_149_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_149_HAS_ARG)
+  #if (OPT_149_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_149_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_149_CLI_SHORT_CODE)
+    #define OPT_149_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_149_CLI_SHORT_CODE)
+  #else
+    #define OPT_149_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+
+#ifdef OPT_150_ENUM_NAME
+  #define OPT_150_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_150_HAS_ARG)
+  #if (OPT_150_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_150_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_150_CLI_SHORT_CODE)
+    #define OPT_150_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_150_CLI_SHORT_CODE)
+  #else
+    #define OPT_150_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_151_ENUM_NAME
+  #define OPT_151_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_151_HAS_ARG)
+  #if (OPT_151_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_151_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_151_CLI_SHORT_CODE)
+    #define OPT_151_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_151_CLI_SHORT_CODE)
+  #else
+    #define OPT_151_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_152_ENUM_NAME
+  #define OPT_152_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_152_HAS_ARG)
+  #if (OPT_152_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_152_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_152_CLI_SHORT_CODE)
+    #define OPT_152_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_152_CLI_SHORT_CODE)
+  #else
+    #define OPT_152_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_153_ENUM_NAME
+  #define OPT_153_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_153_HAS_ARG)
+  #if (OPT_153_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_153_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_153_CLI_SHORT_CODE)
+    #define OPT_153_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_153_CLI_SHORT_CODE)
+  #else
+    #define OPT_153_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_154_ENUM_NAME
+  #define OPT_154_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_154_HAS_ARG)
+  #if (OPT_154_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_154_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_154_CLI_SHORT_CODE)
+    #define OPT_154_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_154_CLI_SHORT_CODE)
+  #else
+    #define OPT_154_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_155_ENUM_NAME
+  #define OPT_155_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_155_HAS_ARG)
+  #if (OPT_155_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_155_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_155_CLI_SHORT_CODE)
+    #define OPT_155_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_155_CLI_SHORT_CODE)
+  #else
+    #define OPT_155_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_156_ENUM_NAME
+  #define OPT_156_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_156_HAS_ARG)
+  #if (OPT_156_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_156_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_156_CLI_SHORT_CODE)
+    #define OPT_156_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_156_CLI_SHORT_CODE)
+  #else
+    #define OPT_156_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_157_ENUM_NAME
+  #define OPT_157_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_157_HAS_ARG)
+  #if (OPT_157_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_157_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_157_CLI_SHORT_CODE)
+    #define OPT_157_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_157_CLI_SHORT_CODE)
+  #else
+    #define OPT_157_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_158_ENUM_NAME
+  #define OPT_158_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_158_HAS_ARG)
+  #if (OPT_158_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_158_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_158_CLI_SHORT_CODE)
+    #define OPT_158_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_158_CLI_SHORT_CODE)
+  #else
+    #define OPT_158_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_159_ENUM_NAME
+  #define OPT_159_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_159_HAS_ARG)
+  #if (OPT_159_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_159_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_159_CLI_SHORT_CODE)
+    #define OPT_159_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_159_CLI_SHORT_CODE)
+  #else
+    #define OPT_159_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+
+#ifdef OPT_160_ENUM_NAME
+  #define OPT_160_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_160_HAS_ARG)
+  #if (OPT_160_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_160_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_160_CLI_SHORT_CODE)
+    #define OPT_160_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_160_CLI_SHORT_CODE)
+  #else
+    #define OPT_160_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_161_ENUM_NAME
+  #define OPT_161_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_161_HAS_ARG)
+  #if (OPT_161_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_161_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_161_CLI_SHORT_CODE)
+    #define OPT_161_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_161_CLI_SHORT_CODE)
+  #else
+    #define OPT_161_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_162_ENUM_NAME
+  #define OPT_162_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_162_HAS_ARG)
+  #if (OPT_162_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_162_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_162_CLI_SHORT_CODE)
+    #define OPT_162_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_162_CLI_SHORT_CODE)
+  #else
+    #define OPT_162_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_163_ENUM_NAME
+  #define OPT_163_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_163_HAS_ARG)
+  #if (OPT_163_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_163_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_163_CLI_SHORT_CODE)
+    #define OPT_163_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_163_CLI_SHORT_CODE)
+  #else
+    #define OPT_163_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_164_ENUM_NAME
+  #define OPT_164_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_164_HAS_ARG)
+  #if (OPT_164_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_164_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_164_CLI_SHORT_CODE)
+    #define OPT_164_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_164_CLI_SHORT_CODE)
+  #else
+    #define OPT_164_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_165_ENUM_NAME
+  #define OPT_165_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_165_HAS_ARG)
+  #if (OPT_165_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_165_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_165_CLI_SHORT_CODE)
+    #define OPT_165_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_165_CLI_SHORT_CODE)
+  #else
+    #define OPT_165_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_166_ENUM_NAME
+  #define OPT_166_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_166_HAS_ARG)
+  #if (OPT_166_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_166_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_166_CLI_SHORT_CODE)
+    #define OPT_166_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_166_CLI_SHORT_CODE)
+  #else
+    #define OPT_166_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_167_ENUM_NAME
+  #define OPT_167_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_167_HAS_ARG)
+  #if (OPT_167_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_167_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_167_CLI_SHORT_CODE)
+    #define OPT_167_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_167_CLI_SHORT_CODE)
+  #else
+    #define OPT_167_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_168_ENUM_NAME
+  #define OPT_168_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_168_HAS_ARG)
+  #if (OPT_168_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_168_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_168_CLI_SHORT_CODE)
+    #define OPT_168_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_168_CLI_SHORT_CODE)
+  #else
+    #define OPT_168_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_169_ENUM_NAME
+  #define OPT_169_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_169_HAS_ARG)
+  #if (OPT_169_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_169_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_169_CLI_SHORT_CODE)
+    #define OPT_169_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_169_CLI_SHORT_CODE)
+  #else
+    #define OPT_169_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+
+#ifdef OPT_170_ENUM_NAME
+  #define OPT_170_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_170_HAS_ARG)
+  #if (OPT_170_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_170_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_170_CLI_SHORT_CODE)
+    #define OPT_170_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_170_CLI_SHORT_CODE)
+  #else
+    #define OPT_170_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_171_ENUM_NAME
+  #define OPT_171_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_171_HAS_ARG)
+  #if (OPT_171_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_171_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_171_CLI_SHORT_CODE)
+    #define OPT_171_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_171_CLI_SHORT_CODE)
+  #else
+    #define OPT_171_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_172_ENUM_NAME
+  #define OPT_172_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_172_HAS_ARG)
+  #if (OPT_172_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_172_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_172_CLI_SHORT_CODE)
+    #define OPT_172_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_172_CLI_SHORT_CODE)
+  #else
+    #define OPT_172_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_173_ENUM_NAME
+  #define OPT_173_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_173_HAS_ARG)
+  #if (OPT_173_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_173_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_173_CLI_SHORT_CODE)
+    #define OPT_173_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_173_CLI_SHORT_CODE)
+  #else
+    #define OPT_173_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_174_ENUM_NAME
+  #define OPT_174_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_174_HAS_ARG)
+  #if (OPT_174_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_174_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_174_CLI_SHORT_CODE)
+    #define OPT_174_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_174_CLI_SHORT_CODE)
+  #else
+    #define OPT_174_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_175_ENUM_NAME
+  #define OPT_175_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_175_HAS_ARG)
+  #if (OPT_175_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_175_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_175_CLI_SHORT_CODE)
+    #define OPT_175_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_175_CLI_SHORT_CODE)
+  #else
+    #define OPT_175_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_176_ENUM_NAME
+  #define OPT_176_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_176_HAS_ARG)
+  #if (OPT_176_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_176_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_176_CLI_SHORT_CODE)
+    #define OPT_176_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_176_CLI_SHORT_CODE)
+  #else
+    #define OPT_176_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_177_ENUM_NAME
+  #define OPT_177_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_177_HAS_ARG)
+  #if (OPT_177_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_177_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_177_CLI_SHORT_CODE)
+    #define OPT_177_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_177_CLI_SHORT_CODE)
+  #else
+    #define OPT_177_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_178_ENUM_NAME
+  #define OPT_178_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_178_HAS_ARG)
+  #if (OPT_178_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_178_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_178_CLI_SHORT_CODE)
+    #define OPT_178_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_178_CLI_SHORT_CODE)
+  #else
+    #define OPT_178_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_179_ENUM_NAME
+  #define OPT_179_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_179_HAS_ARG)
+  #if (OPT_179_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_179_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_179_CLI_SHORT_CODE)
+    #define OPT_179_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_179_CLI_SHORT_CODE)
+  #else
+    #define OPT_179_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+
+#ifdef OPT_180_ENUM_NAME
+  #define OPT_180_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_180_HAS_ARG)
+  #if (OPT_180_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_180_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_180_CLI_SHORT_CODE)
+    #define OPT_180_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_180_CLI_SHORT_CODE)
+  #else
+    #define OPT_180_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_181_ENUM_NAME
+  #define OPT_181_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_181_HAS_ARG)
+  #if (OPT_181_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_181_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_181_CLI_SHORT_CODE)
+    #define OPT_181_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_181_CLI_SHORT_CODE)
+  #else
+    #define OPT_181_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_182_ENUM_NAME
+  #define OPT_182_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_182_HAS_ARG)
+  #if (OPT_182_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_182_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_182_CLI_SHORT_CODE)
+    #define OPT_182_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_182_CLI_SHORT_CODE)
+  #else
+    #define OPT_182_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_183_ENUM_NAME
+  #define OPT_183_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_183_HAS_ARG)
+  #if (OPT_183_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_183_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_183_CLI_SHORT_CODE)
+    #define OPT_183_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_183_CLI_SHORT_CODE)
+  #else
+    #define OPT_183_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_184_ENUM_NAME
+  #define OPT_184_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_184_HAS_ARG)
+  #if (OPT_184_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_184_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_184_CLI_SHORT_CODE)
+    #define OPT_184_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_184_CLI_SHORT_CODE)
+  #else
+    #define OPT_184_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_185_ENUM_NAME
+  #define OPT_185_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_185_HAS_ARG)
+  #if (OPT_185_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_185_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_185_CLI_SHORT_CODE)
+    #define OPT_185_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_185_CLI_SHORT_CODE)
+  #else
+    #define OPT_185_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_186_ENUM_NAME
+  #define OPT_186_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_186_HAS_ARG)
+  #if (OPT_186_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_186_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_186_CLI_SHORT_CODE)
+    #define OPT_186_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_186_CLI_SHORT_CODE)
+  #else
+    #define OPT_186_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_187_ENUM_NAME
+  #define OPT_187_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_187_HAS_ARG)
+  #if (OPT_187_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_187_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_187_CLI_SHORT_CODE)
+    #define OPT_187_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_187_CLI_SHORT_CODE)
+  #else
+    #define OPT_187_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_188_ENUM_NAME
+  #define OPT_188_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_188_HAS_ARG)
+  #if (OPT_188_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_188_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_188_CLI_SHORT_CODE)
+    #define OPT_188_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_188_CLI_SHORT_CODE)
+  #else
+    #define OPT_188_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_189_ENUM_NAME
+  #define OPT_189_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_189_HAS_ARG)
+  #if (OPT_189_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_189_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_189_CLI_SHORT_CODE)
+    #define OPT_189_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_189_CLI_SHORT_CODE)
+  #else
+    #define OPT_189_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+
+#ifdef OPT_190_ENUM_NAME
+  #define OPT_190_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_190_HAS_ARG)
+  #if (OPT_190_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_190_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_190_CLI_SHORT_CODE)
+    #define OPT_190_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_190_CLI_SHORT_CODE)
+  #else
+    #define OPT_190_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_191_ENUM_NAME
+  #define OPT_191_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_191_HAS_ARG)
+  #if (OPT_191_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_191_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_191_CLI_SHORT_CODE)
+    #define OPT_191_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_191_CLI_SHORT_CODE)
+  #else
+    #define OPT_191_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_192_ENUM_NAME
+  #define OPT_192_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_192_HAS_ARG)
+  #if (OPT_192_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_192_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_192_CLI_SHORT_CODE)
+    #define OPT_192_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_192_CLI_SHORT_CODE)
+  #else
+    #define OPT_192_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_193_ENUM_NAME
+  #define OPT_193_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_193_HAS_ARG)
+  #if (OPT_193_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_193_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_193_CLI_SHORT_CODE)
+    #define OPT_193_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_193_CLI_SHORT_CODE)
+  #else
+    #define OPT_193_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_194_ENUM_NAME
+  #define OPT_194_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_194_HAS_ARG)
+  #if (OPT_194_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_194_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_194_CLI_SHORT_CODE)
+    #define OPT_194_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_194_CLI_SHORT_CODE)
+  #else
+    #define OPT_194_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_195_ENUM_NAME
+  #define OPT_195_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_195_HAS_ARG)
+  #if (OPT_195_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_195_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_195_CLI_SHORT_CODE)
+    #define OPT_195_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_195_CLI_SHORT_CODE)
+  #else
+    #define OPT_195_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_196_ENUM_NAME
+  #define OPT_196_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_196_HAS_ARG)
+  #if (OPT_196_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_196_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_196_CLI_SHORT_CODE)
+    #define OPT_196_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_196_CLI_SHORT_CODE)
+  #else
+    #define OPT_196_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_197_ENUM_NAME
+  #define OPT_197_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_197_HAS_ARG)
+  #if (OPT_197_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_197_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_197_CLI_SHORT_CODE)
+    #define OPT_197_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_197_CLI_SHORT_CODE)
+  #else
+    #define OPT_197_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_198_ENUM_NAME
+  #define OPT_198_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_198_HAS_ARG)
+  #if (OPT_198_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_198_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_198_CLI_SHORT_CODE)
+    #define OPT_198_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_198_CLI_SHORT_CODE)
+  #else
+    #define OPT_198_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+#ifdef OPT_199_ENUM_NAME
+  #define OPT_199_HAS_ARG_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_199_HAS_ARG)
+  #if (OPT_199_CLI_SHORT_CODE != OPT_AUTO_CODE)
+    #define OPT_199_CLI_SHORT_CODE_CHR  OPT_MC_CCAT(OPT_CHR_, OPT_199_CLI_SHORT_CODE)
+    #define OPT_199_CLI_SHORT_CODE_TXT  OPT_MC_STR(OPT_199_CLI_SHORT_CODE)
+  #else
+    #define OPT_199_CLI_SHORT_CODE_CHR  OPT_AUTO_CODE
+  #endif
+#endif
+
+
+/* opt IDs */
+/*
+    WARNING: This enum is NOT A CONSECUTIVE LIST.
+             There are irregularities in numbering.
+             Do NOT use this enum as array indices!
+*/
+typedef enum cli_opt_tt {
+    OPT_00_NO_OPTION = 0,
+    OPT_NONE = 0,
+    
+#ifdef OPT_01_ENUM_NAME
+  #if (OPT_01_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_01_ENUM_NAME = 1001,
+  #else
+       OPT_01_ENUM_NAME = OPT_01_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_02_ENUM_NAME
+  #if (OPT_02_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_02_ENUM_NAME = 1002,
+  #else
+       OPT_02_ENUM_NAME = OPT_02_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_03_ENUM_NAME
+  #if (OPT_03_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_03_ENUM_NAME = 1003,
+  #else
+       OPT_03_ENUM_NAME = OPT_03_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_04_ENUM_NAME
+  #if (OPT_04_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_04_ENUM_NAME = 1004,
+  #else
+       OPT_04_ENUM_NAME = OPT_04_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_05_ENUM_NAME
+  #if (OPT_05_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_05_ENUM_NAME = 1005,
+  #else
+       OPT_05_ENUM_NAME = OPT_05_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_06_ENUM_NAME
+  #if (OPT_06_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_06_ENUM_NAME = 1006,
+  #else
+       OPT_06_ENUM_NAME = OPT_06_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_07_ENUM_NAME
+  #if (OPT_07_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_07_ENUM_NAME = 1007,
+  #else
+       OPT_07_ENUM_NAME = OPT_07_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_08_ENUM_NAME
+  #if (OPT_08_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_08_ENUM_NAME = 1008,
+  #else
+       OPT_08_ENUM_NAME = OPT_08_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_09_ENUM_NAME
+  #if (OPT_09_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_09_ENUM_NAME = 1009,
+  #else
+       OPT_09_ENUM_NAME = OPT_09_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+
+#ifdef OPT_10_ENUM_NAME
+  #if (OPT_10_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_10_ENUM_NAME = 1010,
+  #else
+       OPT_10_ENUM_NAME = OPT_10_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_11_ENUM_NAME
+  #if (OPT_11_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_11_ENUM_NAME = 1011,
+  #else
+       OPT_11_ENUM_NAME = OPT_11_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_12_ENUM_NAME
+  #if (OPT_12_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_12_ENUM_NAME = 1012,
+  #else
+       OPT_12_ENUM_NAME = OPT_12_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_13_ENUM_NAME
+  #if (OPT_13_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_13_ENUM_NAME = 1013,
+  #else
+       OPT_13_ENUM_NAME = OPT_13_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_14_ENUM_NAME
+  #if (OPT_14_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_14_ENUM_NAME = 1014,
+  #else
+       OPT_14_ENUM_NAME = OPT_14_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_15_ENUM_NAME
+  #if (OPT_15_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_15_ENUM_NAME = 1015,
+  #else
+       OPT_15_ENUM_NAME = OPT_15_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_16_ENUM_NAME
+  #if (OPT_16_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_16_ENUM_NAME = 1016,
+  #else
+       OPT_16_ENUM_NAME = OPT_16_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_17_ENUM_NAME
+  #if (OPT_17_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_17_ENUM_NAME = 1017,
+  #else
+       OPT_17_ENUM_NAME = OPT_17_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_18_ENUM_NAME
+  #if (OPT_18_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_18_ENUM_NAME = 1018,
+  #else
+       OPT_18_ENUM_NAME = OPT_18_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_19_ENUM_NAME
+  #if (OPT_19_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_19_ENUM_NAME = 1019,
+  #else
+       OPT_19_ENUM_NAME = OPT_19_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+
+#ifdef OPT_20_ENUM_NAME
+  #if (OPT_20_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_20_ENUM_NAME = 1020,
+  #else
+       OPT_20_ENUM_NAME = OPT_20_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_21_ENUM_NAME
+  #if (OPT_21_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_21_ENUM_NAME = 1021,
+  #else
+       OPT_21_ENUM_NAME = OPT_21_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_22_ENUM_NAME
+  #if (OPT_22_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_22_ENUM_NAME = 1022,
+  #else
+       OPT_22_ENUM_NAME = OPT_22_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_23_ENUM_NAME
+  #if (OPT_23_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_23_ENUM_NAME = 1023,
+  #else
+       OPT_23_ENUM_NAME = OPT_23_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_24_ENUM_NAME
+  #if (OPT_24_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_24_ENUM_NAME = 1024,
+  #else
+       OPT_24_ENUM_NAME = OPT_24_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_25_ENUM_NAME
+  #if (OPT_25_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_25_ENUM_NAME = 1025,
+  #else
+       OPT_25_ENUM_NAME = OPT_25_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_26_ENUM_NAME
+  #if (OPT_26_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_26_ENUM_NAME = 1026,
+  #else
+       OPT_26_ENUM_NAME = OPT_26_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_27_ENUM_NAME
+  #if (OPT_27_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_27_ENUM_NAME = 1027,
+  #else
+       OPT_27_ENUM_NAME = OPT_27_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_28_ENUM_NAME
+  #if (OPT_28_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_28_ENUM_NAME = 1028,
+  #else
+       OPT_28_ENUM_NAME = OPT_28_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_29_ENUM_NAME
+  #if (OPT_29_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_29_ENUM_NAME = 1029,
+  #else
+       OPT_29_ENUM_NAME = OPT_29_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+
+#ifdef OPT_30_ENUM_NAME
+  #if (OPT_30_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_30_ENUM_NAME = 1030,
+  #else
+       OPT_30_ENUM_NAME = OPT_30_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_31_ENUM_NAME
+  #if (OPT_31_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_31_ENUM_NAME = 1031,
+  #else
+       OPT_31_ENUM_NAME = OPT_31_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_32_ENUM_NAME
+  #if (OPT_32_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_32_ENUM_NAME = 1032,
+  #else
+       OPT_32_ENUM_NAME = OPT_32_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_33_ENUM_NAME
+  #if (OPT_33_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_33_ENUM_NAME = 1033,
+  #else
+       OPT_33_ENUM_NAME = OPT_33_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_34_ENUM_NAME
+  #if (OPT_34_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_34_ENUM_NAME = 1034,
+  #else
+       OPT_34_ENUM_NAME = OPT_34_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_35_ENUM_NAME
+  #if (OPT_35_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_35_ENUM_NAME = 1035,
+  #else
+       OPT_35_ENUM_NAME = OPT_35_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_36_ENUM_NAME
+  #if (OPT_36_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_36_ENUM_NAME = 1036,
+  #else
+       OPT_36_ENUM_NAME = OPT_36_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_37_ENUM_NAME
+  #if (OPT_37_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_37_ENUM_NAME = 1037,
+  #else
+       OPT_37_ENUM_NAME = OPT_37_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_38_ENUM_NAME
+  #if (OPT_38_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_38_ENUM_NAME = 1038,
+  #else
+       OPT_38_ENUM_NAME = OPT_38_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_39_ENUM_NAME
+  #if (OPT_39_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_39_ENUM_NAME = 1039,
+  #else
+       OPT_39_ENUM_NAME = OPT_39_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+
+#ifdef OPT_40_ENUM_NAME
+  #if (OPT_40_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_40_ENUM_NAME = 1040,
+  #else
+       OPT_40_ENUM_NAME = OPT_40_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_41_ENUM_NAME
+  #if (OPT_41_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_41_ENUM_NAME = 1041,
+  #else
+       OPT_41_ENUM_NAME = OPT_41_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_42_ENUM_NAME
+  #if (OPT_42_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_42_ENUM_NAME = 1042,
+  #else
+       OPT_42_ENUM_NAME = OPT_42_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_43_ENUM_NAME
+  #if (OPT_43_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_43_ENUM_NAME = 1043,
+  #else
+       OPT_43_ENUM_NAME = OPT_43_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_44_ENUM_NAME
+  #if (OPT_44_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_44_ENUM_NAME = 1044,
+  #else
+       OPT_44_ENUM_NAME = OPT_44_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_45_ENUM_NAME
+  #if (OPT_45_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_45_ENUM_NAME = 1045,
+  #else
+       OPT_45_ENUM_NAME = OPT_45_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_46_ENUM_NAME
+  #if (OPT_46_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_46_ENUM_NAME = 1046,
+  #else
+       OPT_46_ENUM_NAME = OPT_46_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_47_ENUM_NAME
+  #if (OPT_47_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_47_ENUM_NAME = 1047,
+  #else
+       OPT_47_ENUM_NAME = OPT_47_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_48_ENUM_NAME
+  #if (OPT_48_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_48_ENUM_NAME = 1048,
+  #else
+       OPT_48_ENUM_NAME = OPT_48_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_49_ENUM_NAME
+  #if (OPT_49_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_49_ENUM_NAME = 1049,
+  #else
+       OPT_49_ENUM_NAME = OPT_49_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+
+#ifdef OPT_50_ENUM_NAME
+  #if (OPT_50_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_50_ENUM_NAME = 1050,
+  #else
+       OPT_50_ENUM_NAME = OPT_50_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_51_ENUM_NAME
+  #if (OPT_51_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_51_ENUM_NAME = 1051,
+  #else
+       OPT_51_ENUM_NAME = OPT_51_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_52_ENUM_NAME
+  #if (OPT_52_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_52_ENUM_NAME = 1052,
+  #else
+       OPT_52_ENUM_NAME = OPT_52_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_53_ENUM_NAME
+  #if (OPT_53_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_53_ENUM_NAME = 1053,
+  #else
+       OPT_53_ENUM_NAME = OPT_53_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_54_ENUM_NAME
+  #if (OPT_54_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_54_ENUM_NAME = 1054,
+  #else
+       OPT_54_ENUM_NAME = OPT_54_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_55_ENUM_NAME
+  #if (OPT_55_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_55_ENUM_NAME = 1055,
+  #else
+       OPT_55_ENUM_NAME = OPT_55_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_56_ENUM_NAME
+  #if (OPT_56_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_56_ENUM_NAME = 1056,
+  #else
+       OPT_56_ENUM_NAME = OPT_56_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_57_ENUM_NAME
+  #if (OPT_57_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_57_ENUM_NAME = 1057,
+  #else
+       OPT_57_ENUM_NAME = OPT_57_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_58_ENUM_NAME
+  #if (OPT_58_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_58_ENUM_NAME = 1058,
+  #else
+       OPT_58_ENUM_NAME = OPT_58_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_59_ENUM_NAME
+  #if (OPT_59_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_59_ENUM_NAME = 1059,
+  #else
+       OPT_59_ENUM_NAME = OPT_59_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+
+#ifdef OPT_60_ENUM_NAME
+  #if (OPT_60_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_60_ENUM_NAME = 1060,
+  #else
+       OPT_60_ENUM_NAME = OPT_60_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_61_ENUM_NAME
+  #if (OPT_61_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_61_ENUM_NAME = 1061,
+  #else
+       OPT_61_ENUM_NAME = OPT_61_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_62_ENUM_NAME
+  #if (OPT_62_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_62_ENUM_NAME = 1062,
+  #else
+       OPT_62_ENUM_NAME = OPT_62_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_63_ENUM_NAME
+  #if (OPT_63_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_63_ENUM_NAME = 1063,
+  #else
+       OPT_63_ENUM_NAME = OPT_63_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_64_ENUM_NAME
+  #if (OPT_64_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_64_ENUM_NAME = 1064,
+  #else
+       OPT_64_ENUM_NAME = OPT_64_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_65_ENUM_NAME
+  #if (OPT_65_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_65_ENUM_NAME = 1065,
+  #else
+       OPT_65_ENUM_NAME = OPT_65_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_66_ENUM_NAME
+  #if (OPT_66_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_66_ENUM_NAME = 1066,
+  #else
+       OPT_66_ENUM_NAME = OPT_66_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_67_ENUM_NAME
+  #if (OPT_67_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_67_ENUM_NAME = 1067,
+  #else
+       OPT_67_ENUM_NAME = OPT_67_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_68_ENUM_NAME
+  #if (OPT_68_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_68_ENUM_NAME = 1068,
+  #else
+       OPT_68_ENUM_NAME = OPT_68_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_69_ENUM_NAME
+  #if (OPT_69_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_69_ENUM_NAME = 1069,
+  #else
+       OPT_69_ENUM_NAME = OPT_69_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+
+#ifdef OPT_70_ENUM_NAME
+  #if (OPT_70_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_70_ENUM_NAME = 1070,
+  #else
+       OPT_70_ENUM_NAME = OPT_70_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_71_ENUM_NAME
+  #if (OPT_71_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_71_ENUM_NAME = 1071,
+  #else
+       OPT_71_ENUM_NAME = OPT_71_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_72_ENUM_NAME
+  #if (OPT_72_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_72_ENUM_NAME = 1072,
+  #else
+       OPT_72_ENUM_NAME = OPT_72_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_73_ENUM_NAME
+  #if (OPT_73_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_73_ENUM_NAME = 1073,
+  #else
+       OPT_73_ENUM_NAME = OPT_73_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_74_ENUM_NAME
+  #if (OPT_74_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_74_ENUM_NAME = 1074,
+  #else
+       OPT_74_ENUM_NAME = OPT_74_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_75_ENUM_NAME
+  #if (OPT_75_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_75_ENUM_NAME = 1075,
+  #else
+       OPT_75_ENUM_NAME = OPT_75_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_76_ENUM_NAME
+  #if (OPT_76_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_76_ENUM_NAME = 1076,
+  #else
+       OPT_76_ENUM_NAME = OPT_76_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_77_ENUM_NAME
+  #if (OPT_77_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_77_ENUM_NAME = 1077,
+  #else
+       OPT_77_ENUM_NAME = OPT_77_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_78_ENUM_NAME
+  #if (OPT_78_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_78_ENUM_NAME = 1078,
+  #else
+       OPT_78_ENUM_NAME = OPT_78_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_79_ENUM_NAME
+  #if (OPT_79_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_79_ENUM_NAME = 1079,
+  #else
+       OPT_79_ENUM_NAME = OPT_79_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+
+#ifdef OPT_80_ENUM_NAME
+  #if (OPT_80_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_80_ENUM_NAME = 1080,
+  #else
+       OPT_80_ENUM_NAME = OPT_80_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_81_ENUM_NAME
+  #if (OPT_81_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_81_ENUM_NAME = 1081,
+  #else
+       OPT_81_ENUM_NAME = OPT_81_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_82_ENUM_NAME
+  #if (OPT_82_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_82_ENUM_NAME = 1082,
+  #else
+       OPT_82_ENUM_NAME = OPT_82_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_83_ENUM_NAME
+  #if (OPT_83_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_83_ENUM_NAME = 1083,
+  #else
+       OPT_83_ENUM_NAME = OPT_83_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_84_ENUM_NAME
+  #if (OPT_84_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_84_ENUM_NAME = 1084,
+  #else
+       OPT_84_ENUM_NAME = OPT_84_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_85_ENUM_NAME
+  #if (OPT_85_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_85_ENUM_NAME = 1085,
+  #else
+       OPT_85_ENUM_NAME = OPT_85_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_86_ENUM_NAME
+  #if (OPT_86_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_86_ENUM_NAME = 1086,
+  #else
+       OPT_86_ENUM_NAME = OPT_86_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_87_ENUM_NAME
+  #if (OPT_87_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_87_ENUM_NAME = 1087,
+  #else
+       OPT_87_ENUM_NAME = OPT_87_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_88_ENUM_NAME
+  #if (OPT_88_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_88_ENUM_NAME = 1088,
+  #else
+       OPT_88_ENUM_NAME = OPT_88_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_89_ENUM_NAME
+  #if (OPT_89_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_89_ENUM_NAME = 1089,
+  #else
+       OPT_89_ENUM_NAME = OPT_89_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+
+#ifdef OPT_90_ENUM_NAME
+  #if (OPT_90_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_90_ENUM_NAME = 1090,
+  #else
+       OPT_90_ENUM_NAME = OPT_90_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_91_ENUM_NAME
+  #if (OPT_91_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_91_ENUM_NAME = 1091,
+  #else
+       OPT_91_ENUM_NAME = OPT_91_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_92_ENUM_NAME
+  #if (OPT_92_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_92_ENUM_NAME = 1092,
+  #else
+       OPT_92_ENUM_NAME = OPT_92_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_93_ENUM_NAME
+  #if (OPT_93_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_93_ENUM_NAME = 1093,
+  #else
+       OPT_93_ENUM_NAME = OPT_93_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_94_ENUM_NAME
+  #if (OPT_94_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_94_ENUM_NAME = 1094,
+  #else
+       OPT_94_ENUM_NAME = OPT_94_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_95_ENUM_NAME
+  #if (OPT_95_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_95_ENUM_NAME = 1095,
+  #else
+       OPT_95_ENUM_NAME = OPT_95_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_96_ENUM_NAME
+  #if (OPT_96_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_96_ENUM_NAME = 1096,
+  #else
+       OPT_96_ENUM_NAME = OPT_96_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_97_ENUM_NAME
+  #if (OPT_97_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_97_ENUM_NAME = 1097,
+  #else
+       OPT_97_ENUM_NAME = OPT_97_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_98_ENUM_NAME
+  #if (OPT_98_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_98_ENUM_NAME = 1098,
+  #else
+       OPT_98_ENUM_NAME = OPT_98_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_99_ENUM_NAME
+  #if (OPT_99_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_99_ENUM_NAME = 1099,
+  #else
+       OPT_99_ENUM_NAME = OPT_99_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+
+#ifdef OPT_100_ENUM_NAME
+  #if (OPT_100_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_100_ENUM_NAME = 1100,
+  #else
+       OPT_100_ENUM_NAME = OPT_100_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_101_ENUM_NAME
+  #if (OPT_101_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_101_ENUM_NAME = 1101,
+  #else
+       OPT_101_ENUM_NAME = OPT_101_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_102_ENUM_NAME
+  #if (OPT_102_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_102_ENUM_NAME = 1102,
+  #else
+       OPT_102_ENUM_NAME = OPT_102_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_103_ENUM_NAME
+  #if (OPT_103_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_103_ENUM_NAME = 1103,
+  #else
+       OPT_103_ENUM_NAME = OPT_103_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_104_ENUM_NAME
+  #if (OPT_104_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_104_ENUM_NAME = 1104,
+  #else
+       OPT_104_ENUM_NAME = OPT_104_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_105_ENUM_NAME
+  #if (OPT_105_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_105_ENUM_NAME = 1105,
+  #else
+       OPT_105_ENUM_NAME = OPT_105_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_106_ENUM_NAME
+  #if (OPT_106_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_106_ENUM_NAME = 1106,
+  #else
+       OPT_106_ENUM_NAME = OPT_106_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_107_ENUM_NAME
+  #if (OPT_107_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_107_ENUM_NAME = 1107,
+  #else
+       OPT_107_ENUM_NAME = OPT_107_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_108_ENUM_NAME
+  #if (OPT_108_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_108_ENUM_NAME = 1108,
+  #else
+       OPT_108_ENUM_NAME = OPT_108_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_109_ENUM_NAME
+  #if (OPT_109_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_109_ENUM_NAME = 1109,
+  #else
+       OPT_109_ENUM_NAME = OPT_109_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+
+#ifdef OPT_110_ENUM_NAME
+  #if (OPT_110_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_110_ENUM_NAME = 1110,
+  #else
+       OPT_110_ENUM_NAME = OPT_110_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_111_ENUM_NAME
+  #if (OPT_111_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_111_ENUM_NAME = 1111,
+  #else
+       OPT_111_ENUM_NAME = OPT_111_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_112_ENUM_NAME
+  #if (OPT_112_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_112_ENUM_NAME = 1112,
+  #else
+       OPT_112_ENUM_NAME = OPT_112_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_113_ENUM_NAME
+  #if (OPT_113_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_113_ENUM_NAME = 1113,
+  #else
+       OPT_113_ENUM_NAME = OPT_113_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_114_ENUM_NAME
+  #if (OPT_114_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_114_ENUM_NAME = 1114,
+  #else
+       OPT_114_ENUM_NAME = OPT_114_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_115_ENUM_NAME
+  #if (OPT_115_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_115_ENUM_NAME = 1115,
+  #else
+       OPT_115_ENUM_NAME = OPT_115_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_116_ENUM_NAME
+  #if (OPT_116_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_116_ENUM_NAME = 1116,
+  #else
+       OPT_116_ENUM_NAME = OPT_116_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_117_ENUM_NAME
+  #if (OPT_117_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_117_ENUM_NAME = 1117,
+  #else
+       OPT_117_ENUM_NAME = OPT_117_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_118_ENUM_NAME
+  #if (OPT_118_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_118_ENUM_NAME = 1118,
+  #else
+       OPT_118_ENUM_NAME = OPT_118_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_119_ENUM_NAME
+  #if (OPT_119_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_119_ENUM_NAME = 1119,
+  #else
+       OPT_119_ENUM_NAME = OPT_119_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+
+#ifdef OPT_120_ENUM_NAME
+  #if (OPT_120_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_120_ENUM_NAME = 1120,
+  #else
+       OPT_120_ENUM_NAME = OPT_120_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_121_ENUM_NAME
+  #if (OPT_121_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_121_ENUM_NAME = 1121,
+  #else
+       OPT_121_ENUM_NAME = OPT_121_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_122_ENUM_NAME
+  #if (OPT_122_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_122_ENUM_NAME = 1122,
+  #else
+       OPT_122_ENUM_NAME = OPT_122_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_123_ENUM_NAME
+  #if (OPT_123_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_123_ENUM_NAME = 1123,
+  #else
+       OPT_123_ENUM_NAME = OPT_123_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_124_ENUM_NAME
+  #if (OPT_124_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_124_ENUM_NAME = 1124,
+  #else
+       OPT_124_ENUM_NAME = OPT_124_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_125_ENUM_NAME
+  #if (OPT_125_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_125_ENUM_NAME = 1125,
+  #else
+       OPT_125_ENUM_NAME = OPT_125_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_126_ENUM_NAME
+  #if (OPT_126_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_126_ENUM_NAME = 1126,
+  #else
+       OPT_126_ENUM_NAME = OPT_126_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_127_ENUM_NAME
+  #if (OPT_127_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_127_ENUM_NAME = 1127,
+  #else
+       OPT_127_ENUM_NAME = OPT_127_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_128_ENUM_NAME
+  #if (OPT_128_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_128_ENUM_NAME = 1128,
+  #else
+       OPT_128_ENUM_NAME = OPT_128_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_129_ENUM_NAME
+  #if (OPT_129_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_129_ENUM_NAME = 1129,
+  #else
+       OPT_129_ENUM_NAME = OPT_129_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+
+#ifdef OPT_130_ENUM_NAME
+  #if (OPT_130_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_130_ENUM_NAME = 1130,
+  #else
+       OPT_130_ENUM_NAME = OPT_130_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_131_ENUM_NAME
+  #if (OPT_131_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_131_ENUM_NAME = 1131,
+  #else
+       OPT_131_ENUM_NAME = OPT_131_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_132_ENUM_NAME
+  #if (OPT_132_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_132_ENUM_NAME = 1132,
+  #else
+       OPT_132_ENUM_NAME = OPT_132_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_133_ENUM_NAME
+  #if (OPT_133_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_133_ENUM_NAME = 1133,
+  #else
+       OPT_133_ENUM_NAME = OPT_133_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_134_ENUM_NAME
+  #if (OPT_134_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_134_ENUM_NAME = 1134,
+  #else
+       OPT_134_ENUM_NAME = OPT_134_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_135_ENUM_NAME
+  #if (OPT_135_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_135_ENUM_NAME = 1135,
+  #else
+       OPT_135_ENUM_NAME = OPT_135_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_136_ENUM_NAME
+  #if (OPT_136_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_136_ENUM_NAME = 1136,
+  #else
+       OPT_136_ENUM_NAME = OPT_136_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_137_ENUM_NAME
+  #if (OPT_137_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_137_ENUM_NAME = 1137,
+  #else
+       OPT_137_ENUM_NAME = OPT_137_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_138_ENUM_NAME
+  #if (OPT_138_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_138_ENUM_NAME = 1138,
+  #else
+       OPT_138_ENUM_NAME = OPT_138_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_139_ENUM_NAME
+  #if (OPT_139_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_139_ENUM_NAME = 1139,
+  #else
+       OPT_139_ENUM_NAME = OPT_139_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+
+#ifdef OPT_140_ENUM_NAME
+  #if (OPT_140_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_140_ENUM_NAME = 1140,
+  #else
+       OPT_140_ENUM_NAME = OPT_140_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_141_ENUM_NAME
+  #if (OPT_141_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_141_ENUM_NAME = 1141,
+  #else
+       OPT_141_ENUM_NAME = OPT_141_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_142_ENUM_NAME
+  #if (OPT_142_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_142_ENUM_NAME = 1142,
+  #else
+       OPT_142_ENUM_NAME = OPT_142_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_143_ENUM_NAME
+  #if (OPT_143_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_143_ENUM_NAME = 1143,
+  #else
+       OPT_143_ENUM_NAME = OPT_143_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_144_ENUM_NAME
+  #if (OPT_144_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_144_ENUM_NAME = 1144,
+  #else
+       OPT_144_ENUM_NAME = OPT_144_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_145_ENUM_NAME
+  #if (OPT_145_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_145_ENUM_NAME = 1145,
+  #else
+       OPT_145_ENUM_NAME = OPT_145_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_146_ENUM_NAME
+  #if (OPT_146_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_146_ENUM_NAME = 1146,
+  #else
+       OPT_146_ENUM_NAME = OPT_146_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_147_ENUM_NAME
+  #if (OPT_147_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_147_ENUM_NAME = 1147,
+  #else
+       OPT_147_ENUM_NAME = OPT_147_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_148_ENUM_NAME
+  #if (OPT_148_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_148_ENUM_NAME = 1148,
+  #else
+       OPT_148_ENUM_NAME = OPT_148_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_149_ENUM_NAME
+  #if (OPT_149_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_149_ENUM_NAME = 1149,
+  #else
+       OPT_149_ENUM_NAME = OPT_149_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+
+#ifdef OPT_150_ENUM_NAME
+  #if (OPT_150_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_150_ENUM_NAME = 1150,
+  #else
+       OPT_150_ENUM_NAME = OPT_150_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_151_ENUM_NAME
+  #if (OPT_151_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_151_ENUM_NAME = 1151,
+  #else
+       OPT_151_ENUM_NAME = OPT_151_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_152_ENUM_NAME
+  #if (OPT_152_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_152_ENUM_NAME = 1152,
+  #else
+       OPT_152_ENUM_NAME = OPT_152_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_153_ENUM_NAME
+  #if (OPT_153_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_153_ENUM_NAME = 1153,
+  #else
+       OPT_153_ENUM_NAME = OPT_153_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_154_ENUM_NAME
+  #if (OPT_154_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_154_ENUM_NAME = 1154,
+  #else
+       OPT_154_ENUM_NAME = OPT_154_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_155_ENUM_NAME
+  #if (OPT_155_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_155_ENUM_NAME = 1155,
+  #else
+       OPT_155_ENUM_NAME = OPT_155_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_156_ENUM_NAME
+  #if (OPT_156_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_156_ENUM_NAME = 1156,
+  #else
+       OPT_156_ENUM_NAME = OPT_156_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_157_ENUM_NAME
+  #if (OPT_157_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_157_ENUM_NAME = 1157,
+  #else
+       OPT_157_ENUM_NAME = OPT_157_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_158_ENUM_NAME
+  #if (OPT_158_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_158_ENUM_NAME = 1158,
+  #else
+       OPT_158_ENUM_NAME = OPT_158_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_159_ENUM_NAME
+  #if (OPT_159_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_159_ENUM_NAME = 1159,
+  #else
+       OPT_159_ENUM_NAME = OPT_159_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+
+#ifdef OPT_160_ENUM_NAME
+  #if (OPT_160_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_160_ENUM_NAME = 1160,
+  #else
+       OPT_160_ENUM_NAME = OPT_160_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_161_ENUM_NAME
+  #if (OPT_161_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_161_ENUM_NAME = 1161,
+  #else
+       OPT_161_ENUM_NAME = OPT_161_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_162_ENUM_NAME
+  #if (OPT_162_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_162_ENUM_NAME = 1162,
+  #else
+       OPT_162_ENUM_NAME = OPT_162_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_163_ENUM_NAME
+  #if (OPT_163_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_163_ENUM_NAME = 1163,
+  #else
+       OPT_163_ENUM_NAME = OPT_163_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_164_ENUM_NAME
+  #if (OPT_164_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_164_ENUM_NAME = 1164,
+  #else
+       OPT_164_ENUM_NAME = OPT_164_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_165_ENUM_NAME
+  #if (OPT_165_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_165_ENUM_NAME = 1165,
+  #else
+       OPT_165_ENUM_NAME = OPT_165_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_166_ENUM_NAME
+  #if (OPT_166_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_166_ENUM_NAME = 1166,
+  #else
+       OPT_166_ENUM_NAME = OPT_166_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_167_ENUM_NAME
+  #if (OPT_167_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_167_ENUM_NAME = 1167,
+  #else
+       OPT_167_ENUM_NAME = OPT_167_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_168_ENUM_NAME
+  #if (OPT_168_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_168_ENUM_NAME = 1168,
+  #else
+       OPT_168_ENUM_NAME = OPT_168_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_169_ENUM_NAME
+  #if (OPT_169_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_169_ENUM_NAME = 1169,
+  #else
+       OPT_169_ENUM_NAME = OPT_169_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+
+#ifdef OPT_170_ENUM_NAME
+  #if (OPT_170_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_170_ENUM_NAME = 1170,
+  #else
+       OPT_170_ENUM_NAME = OPT_170_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_171_ENUM_NAME
+  #if (OPT_171_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_171_ENUM_NAME = 1171,
+  #else
+       OPT_171_ENUM_NAME = OPT_171_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_172_ENUM_NAME
+  #if (OPT_172_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_172_ENUM_NAME = 1172,
+  #else
+       OPT_172_ENUM_NAME = OPT_172_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_173_ENUM_NAME
+  #if (OPT_173_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_173_ENUM_NAME = 1173,
+  #else
+       OPT_173_ENUM_NAME = OPT_173_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_174_ENUM_NAME
+  #if (OPT_174_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_174_ENUM_NAME = 1174,
+  #else
+       OPT_174_ENUM_NAME = OPT_174_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_175_ENUM_NAME
+  #if (OPT_175_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_175_ENUM_NAME = 1175,
+  #else
+       OPT_175_ENUM_NAME = OPT_175_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_176_ENUM_NAME
+  #if (OPT_176_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_176_ENUM_NAME = 1176,
+  #else
+       OPT_176_ENUM_NAME = OPT_176_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_177_ENUM_NAME
+  #if (OPT_177_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_177_ENUM_NAME = 1177,
+  #else
+       OPT_177_ENUM_NAME = OPT_177_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_178_ENUM_NAME
+  #if (OPT_178_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_178_ENUM_NAME = 1178,
+  #else
+       OPT_178_ENUM_NAME = OPT_178_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_179_ENUM_NAME
+  #if (OPT_179_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_179_ENUM_NAME = 1179,
+  #else
+       OPT_179_ENUM_NAME = OPT_179_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+
+#ifdef OPT_180_ENUM_NAME
+  #if (OPT_180_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_180_ENUM_NAME = 1180,
+  #else
+       OPT_180_ENUM_NAME = OPT_180_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_181_ENUM_NAME
+  #if (OPT_181_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_181_ENUM_NAME = 1181,
+  #else
+       OPT_181_ENUM_NAME = OPT_181_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_182_ENUM_NAME
+  #if (OPT_182_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_182_ENUM_NAME = 1182,
+  #else
+       OPT_182_ENUM_NAME = OPT_182_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_183_ENUM_NAME
+  #if (OPT_183_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_183_ENUM_NAME = 1183,
+  #else
+       OPT_183_ENUM_NAME = OPT_183_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_184_ENUM_NAME
+  #if (OPT_184_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_184_ENUM_NAME = 1184,
+  #else
+       OPT_184_ENUM_NAME = OPT_184_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_185_ENUM_NAME
+  #if (OPT_185_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_185_ENUM_NAME = 1185,
+  #else
+       OPT_185_ENUM_NAME = OPT_185_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_186_ENUM_NAME
+  #if (OPT_186_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_186_ENUM_NAME = 1186,
+  #else
+       OPT_186_ENUM_NAME = OPT_186_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_187_ENUM_NAME
+  #if (OPT_187_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_187_ENUM_NAME = 1187,
+  #else
+       OPT_187_ENUM_NAME = OPT_187_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_188_ENUM_NAME
+  #if (OPT_188_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_188_ENUM_NAME = 1188,
+  #else
+       OPT_188_ENUM_NAME = OPT_188_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_189_ENUM_NAME
+  #if (OPT_189_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_189_ENUM_NAME = 1189,
+  #else
+       OPT_189_ENUM_NAME = OPT_189_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+
+#ifdef OPT_190_ENUM_NAME
+  #if (OPT_190_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_190_ENUM_NAME = 1190,
+  #else
+       OPT_190_ENUM_NAME = OPT_190_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_191_ENUM_NAME
+  #if (OPT_191_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_191_ENUM_NAME = 1191,
+  #else
+       OPT_191_ENUM_NAME = OPT_191_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_192_ENUM_NAME
+  #if (OPT_192_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_192_ENUM_NAME = 1192,
+  #else
+       OPT_192_ENUM_NAME = OPT_192_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_193_ENUM_NAME
+  #if (OPT_193_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_193_ENUM_NAME = 1193,
+  #else
+       OPT_193_ENUM_NAME = OPT_193_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_194_ENUM_NAME
+  #if (OPT_194_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_194_ENUM_NAME = 1194,
+  #else
+       OPT_194_ENUM_NAME = OPT_194_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_195_ENUM_NAME
+  #if (OPT_195_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_195_ENUM_NAME = 1195,
+  #else
+       OPT_195_ENUM_NAME = OPT_195_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_196_ENUM_NAME
+  #if (OPT_196_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_196_ENUM_NAME = 1196,
+  #else
+       OPT_196_ENUM_NAME = OPT_196_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_197_ENUM_NAME
+  #if (OPT_197_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_197_ENUM_NAME = 1197,
+  #else
+       OPT_197_ENUM_NAME = OPT_197_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_198_ENUM_NAME
+  #if (OPT_198_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_198_ENUM_NAME = 1198,
+  #else
+       OPT_198_ENUM_NAME = OPT_198_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+#ifdef OPT_199_ENUM_NAME
+  #if (OPT_199_CLI_SHORT_CODE_CHR == OPT_AUTO_CODE)
+       OPT_199_ENUM_NAME = 1199,
+  #else
+       OPT_199_ENUM_NAME = OPT_199_CLI_SHORT_CODE_CHR,
+  #endif
+#endif
+
+
+
+
+
+    /* NOTE: no 'OPT_LN' here, because this enum IS NOT A CONSECUTIVE LIST */
+
+} cli_opt_t;
+
+/* ==== TYPEDEFS & DATA : MANDOPT ========================================== */
+/*
+    This feature is meant to be used within cli cmd callbacks, to provide a unified method for 
+    checking if user provided all those cli opts which are considered mandatory for the given cli cmd.
+    
+    How to use this feature in cmd callbacks:
+        [1] Locally define an array of mandopt_t elements (a map of mandatory cli opts and associated conditions).
+        [2] Pass it to the mandopt_check() fnc.
+        
+    Example 1 - each mandopt element is tied with one cli opt
+        const mandopt_t mandopts[] =
+        {
+            {OPT_INTERFACE, NULL, (p_args.if_name.is_valid)},
+            {OPT_PARENT   , NULL, (p_args.if_name_parent.is_valid)},
+        };
+        rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+        
+    Example 2 - some mandopt element is tied with multiple cli opts
+        const mandopt_optbuf_t multiple_opts = {{OPT_ACCEPT, OPT_REJECT, OPT_NEXT_RULE}};
+        const mandopt_t mandopts[] =
+        {
+            {OPT_RULE, NULL,            (p_args.ruleA0_name.is_valid)},
+            {OPT_NONE, &multiple_opts, ((p_args.accept.is_valid) || 
+                                        (p_args.reject.is_valid) ||
+                                        (p_args.ruleB0_name.is_valid))},
+        };
+        rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+*/
+
+#define MANDOPT_OPTS_LN  (4u)
+typedef struct mandopt_buf_tt {
+    cli_opt_t opts[MANDOPT_OPTS_LN];
+} mandopt_optbuf_t;
+
+typedef struct mandopt_tt {
+    cli_opt_t opt;
+    const mandopt_optbuf_t* p_mandopt_optbuf;
+    bool is_valid;
+} mandopt_t;
+
+#define MANDOPTS_CALC_LN(MANDOPTS)  (uint8_t)(sizeof(MANDOPTS)/sizeof(mandopt_t))
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+const struct option* cli_get_longopts(void);
+const char* cli_get_txt_shortopts(void);
+
+const char* cli_opt_get_txt_help(cli_opt_t opt);
+uint32_t cli_opt_get_incompat_grps(cli_opt_t opt);
+
+
+
+
+void cli_mandopt_print(const char* p_txt_delim);
+void cli_mandopt_clear(void);
+int cli_mandopt_check(const mandopt_t* p_mandopts, const uint8_t mandopts_ln);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_cli_parser.c b/sw/libfci_cli/src/libfci_cli_parser.c
new file mode 100644
index 0000000..86b2ac9
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_parser.c
@@ -0,0 +1,3843 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#include <assert.h>
+#include <inttypes.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <limits.h>
+#include <string.h>
+#include <getopt.h>
+#include <sys/socket.h>  /* required by QNX */
+#include <netinet/in.h>  /* required by QNX */
+#include <arpa/inet.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+
+#include "libfci_cli_common.h"
+#include "libfci_cli_def_cmds.h"
+#include "libfci_cli_def_opts.h"
+#include "libfci_cli_def_optarg_keywords.h"
+#include "libfci_cli_def_help.h"
+
+#include "libfci_cli_parser.h"
+
+/* ==== TESTMODE vars ====================================================== */
+
+#if !defined(NDEBUG)
+const char* TEST_parser__p_txt_opt = NULL;
+cli_cmd_t TEST_parser__cmd4exec = CMD_LN;
+#endif
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+#define BASE_DEC  (10)
+#define BASE_HEX  (16)
+
+typedef enum loopstage_tt {
+    LOOP_PRE = 0u,
+    LOOP_BODY,
+    LOOP_POST
+} loopstage_t;
+typedef int (*cb_txt2value_t)(uint8_t* p_rtn_value, const char* p_txt);
+typedef int (*cb_loop_t)(void* p_rtn_void, char* p_txt, const cb_txt2value_t p_cb_txt2value, loopstage_t loopstage, uint8_t i);
+
+static void set_if_rtn_ok(int rtn_from_caller, bool* p_is_valid);
+
+static int cli_txt2bool_on_off(bool* p_rtn_value, const char* p_txt);
+static int cli_txt2bdaction(uint8_t* p_rtn_value, const char* p_txt);
+
+static int cli_txtcpy_if_name(char* p_rtn_buf, const char* p_txt);
+static int cli_txtcpy_table_name(char* p_rtn_buf, const char* p_txt);
+static int cli_txtcpy_rule_name(char* p_rtn_buf, const char* p_txt);
+static int cli_txtcpy_feature_name(char* p_rtn_buf, const char* p_txt);
+
+static int cli_txt2num_u8(uint8_t* p_rtn_num, const char* p_txt, int base,
+                          const uint8_t min, const uint8_t max);
+static int cli_txt2num_u16(uint16_t* p_rtn_num, const char* p_txt, int base,
+                           const uint16_t min, const uint16_t max);
+static int cli_txt2num_u32(uint32_t* p_rtn_num, const char* p_txt, int base,
+                           const uint32_t min, const uint32_t max);
+
+static int cli_txt2num_i32(int32_t* p_rtn_num, const char* p_txt, int base,
+                           const int32_t min, const int32_t max);
+
+static int cli_txt2bitset32(uint32_t* p_rtn_bitset, const char* p_txt, const cb_txt2value_t p_cb_txt2value);
+static int cli_txt2zprobs(uint8_t* p_rtn_zprobs, const char* p_txt);
+static int cli_txt2sch_ins(struct sch_in_tt* p_rtn_struct_with_sch_ins, const char* p_txt);
+
+static int cli_txt2mac(uint8_t* p_rtn_mac, const char* p_txt);
+static int cli_txt2ip(bool* p_rtn_is6, uint32_t* p_rtn_ip, const char* p_txt);
+
+
+/* ==== PRIVATE FUNCTIONS : opt_parse ======================================= */
+/*
+    Place your opt_parse callback functions here.
+    Names of these opt_parse callback functions should be part of opt definitions in 'def_opts.h'.
+    Search for keyword 'OPT_LAST' to get to the bottom of this section.
+*/
+
+static int opt_parse_ip4(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    UNUSED(p_txt_optarg);  /* just to suppress gcc warning */
+    
+    
+    p_rtn_cmdargs->ip4.is_valid = true;
+    return (CLI_OK);
+}
+
+static int opt_parse_ip6(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    UNUSED(p_txt_optarg);  /* just to suppress gcc warning */
+    
+    
+    p_rtn_cmdargs->ip6.is_valid = true;
+    return (CLI_OK);
+}
+
+static int opt_parse_all(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    UNUSED(p_txt_optarg);  /* just to suppress gcc warning */
+    
+    
+    p_rtn_cmdargs->all.is_valid = true;
+    return (CLI_OK);
+}
+
+static int opt_parse_help(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    UNUSED(p_txt_optarg);  /* just to suppress gcc warning */
+    
+    
+    p_rtn_cmdargs->help.is_valid = true;
+    return (CLI_OK);
+}
+
+static int opt_parse_verbose(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    UNUSED(p_txt_optarg);  /* just to suppress gcc warning */
+    
+    
+    p_rtn_cmdargs->verbose.is_valid = true;
+    return (CLI_OK);
+}
+
+static int opt_parse_version(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    UNUSED(p_txt_optarg);  /* just to suppress gcc warning */
+    
+    
+    p_rtn_cmdargs->version.is_valid = true;
+    return (CLI_OK);
+}
+
+static int opt_parse_interface(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->if_name.is_valid);
+    char* p_txt      =  (p_rtn_cmdargs->if_name.txt);
+    
+    rtn = cli_txtcpy_if_name(p_txt, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_parent(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->if_name_parent.is_valid);
+    char* p_txt      =  (p_rtn_cmdargs->if_name_parent.txt);
+    
+    rtn = cli_txtcpy_if_name(p_txt, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_mirror(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->if_name_mirror.is_valid);
+    char* p_txt      =  (p_rtn_cmdargs->if_name_mirror.txt);
+    
+    rtn = cli_txtcpy_if_name(p_txt, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_mode(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool*              p_is_valid = &(p_rtn_cmdargs->if_mode.is_valid);
+    fpp_phy_if_op_mode_t* p_value = &(p_rtn_cmdargs->if_mode.value);
+    
+    {
+        /* parse input */
+        uint8_t tmp_value = 0u;
+        rtn = cli_txt2value_if_mode(&tmp_value, p_txt_optarg);
+        
+        /* assign data */
+        if (CLI_OK == rtn)
+        {
+            *p_value = tmp_value;  /* WARNING: cast to enum */
+        }
+    }
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_block_state(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool*                  p_is_valid = &(p_rtn_cmdargs->if_block_state.is_valid);
+    fpp_phy_if_block_state_t* p_value = &(p_rtn_cmdargs->if_block_state.value);
+    
+    {
+        /* parse input */
+        uint8_t tmp_value = 0u;
+        rtn = cli_txt2value_if_block_state(&tmp_value, p_txt_optarg);
+        
+        /* assign data */
+        if (CLI_OK == rtn)
+        {
+            *p_value = tmp_value;  /* WARNING: cast to enum */
+        }
+    }
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_enable(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    UNUSED(p_txt_optarg);  /* just to suppress gcc warning */
+    
+    
+    p_rtn_cmdargs->enable_noreply.is_valid = true;
+    return (CLI_OK);
+}
+
+static int opt_parse_no_reply(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    UNUSED(p_txt_optarg);  /* just to suppress gcc warning */
+    
+    
+    p_rtn_cmdargs->enable_noreply.is_valid = true;
+    return (CLI_OK);
+}
+
+static int opt_parse_disable(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    UNUSED(p_txt_optarg);  /* just to suppress gcc warning */
+    
+    
+    p_rtn_cmdargs->disable_noorig.is_valid = true;
+    return (CLI_OK);
+}
+
+static int opt_parse_no_orig(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    UNUSED(p_txt_optarg);  /* just to suppress gcc warning */
+    
+    
+    p_rtn_cmdargs->disable_noorig.is_valid = true;
+    return (CLI_OK);
+}
+
+static int opt_parse_promisc(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->promisc.is_valid);
+    bool* p_is_on    = &(p_rtn_cmdargs->promisc.is_on);
+    
+    rtn = cli_txt2bool_on_off(p_is_on, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_loadbalance(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->loadbalance__ttl_decr.is_valid);
+    bool* p_is_on    = &(p_rtn_cmdargs->loadbalance__ttl_decr.is_on);
+    
+    rtn = cli_txt2bool_on_off(p_is_on, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_ttl_decr(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->loadbalance__ttl_decr.is_valid);
+    bool* p_is_on    = &(p_rtn_cmdargs->loadbalance__ttl_decr.is_on);
+    
+    rtn = cli_txt2bool_on_off(p_is_on, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_match_mode(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->match_mode.is_valid);
+    bool* p_is_or    = &(p_rtn_cmdargs->match_mode.is_or);
+    
+    {
+        /* parse input */
+        uint8_t tmp_value = 0u;
+        rtn = cli_txt2value_or_and(&tmp_value, p_txt_optarg);
+        
+        /* assign data */
+        if (CLI_OK == rtn)
+        {
+            *p_is_or = (bool)(tmp_value);
+        }
+    }
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_discard_on_match(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->discard_on_match.is_valid);
+    bool* p_is_on    = &(p_rtn_cmdargs->discard_on_match.is_on);
+    
+    rtn = cli_txt2bool_on_off(p_is_on, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_egress(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid   = &(p_rtn_cmdargs->egress.is_valid);
+    uint32_t* p_bitset = &(p_rtn_cmdargs->egress.bitset);
+    
+    rtn = cli_txt2bitset32(p_bitset, p_txt_optarg, cli_txt2value_phyif);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_match_rules(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    assert(sizeof(fpp_if_m_rules_t) == sizeof(uint32_t));
+    
+    
+    int rtn = CLI_ERR;
+    bool*           p_is_valid = &(p_rtn_cmdargs->match_rules.is_valid);
+    fpp_if_m_rules_t* p_bitset = &(p_rtn_cmdargs->match_rules.bitset);
+    
+    {
+        /* parse input */
+        uint32_t tmp_bitset = 0u;
+        rtn = cli_txt2bitset32(&tmp_bitset, p_txt_optarg, cli_txt2value_match_rule);
+        
+        /* assign data */
+        if(CLI_OK == rtn)
+        {
+            *p_bitset = tmp_bitset;  /* WARNING: cast to enum */
+        }
+    }
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_vlan(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->vlan.is_valid);
+    uint16_t* p_value = &(p_rtn_cmdargs->vlan.value);
+    
+    rtn = cli_txt2num_u16(p_value, p_txt_optarg, BASE_DEC, 0u, UINT16_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_r_vlan(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->vlan2.is_valid);
+    uint16_t* p_value = &(p_rtn_cmdargs->vlan2.value);
+    
+    rtn = cli_txt2num_u16(p_value, p_txt_optarg, BASE_DEC, 0u, UINT16_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_protocol(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->protocol.is_valid);
+    uint8_t* p_value = &(p_rtn_cmdargs->protocol.value);
+    
+    rtn = cli_txt2value_protocol(p_value, p_txt_optarg);
+    if (CLI_OK != rtn)
+    {
+        rtn = cli_txt2num_u8(p_value, p_txt_optarg, BASE_DEC, 0u, UINT8_MAX);
+    }
+    if (CLI_OK != rtn)
+    {
+        rtn = cli_txt2num_u8(p_value, p_txt_optarg, BASE_HEX, 0u, UINT8_MAX);
+    }
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_ethtype(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->count_ethtype.is_valid);
+    uint16_t* p_value = &(p_rtn_cmdargs->count_ethtype.value);
+    
+    rtn = cli_txt2num_u16(p_value, p_txt_optarg, BASE_DEC, 0u, UINT16_MAX);
+    if (CLI_OK != rtn)
+    {
+        rtn = cli_txt2num_u16(p_value, p_txt_optarg, BASE_HEX, 0u, UINT16_MAX);
+    }
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_count(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->count_ethtype.is_valid);
+    uint16_t* p_value = &(p_rtn_cmdargs->count_ethtype.value);
+    
+    rtn = cli_txt2num_u16(p_value, p_txt_optarg, BASE_DEC, 0u, UINT16_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_mac(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->smac.is_valid);
+    uint8_t* p_mac   =  (p_rtn_cmdargs->smac.arr);
+    
+    rtn = cli_txt2mac(p_mac, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_smac(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->smac.is_valid);
+    uint8_t* p_mac   =  (p_rtn_cmdargs->smac.arr);
+    
+    rtn = cli_txt2mac(p_mac, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_dmac(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->dmac.is_valid);
+    uint8_t* p_mac   =  (p_rtn_cmdargs->dmac.arr);
+    
+    rtn = cli_txt2mac(p_mac, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_sip(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->sip.is_valid);
+    bool* p_is6      = &(p_rtn_cmdargs->sip.is6);
+    uint32_t* p_ip   =  (p_rtn_cmdargs->sip.arr);
+    
+    rtn = cli_txt2ip(p_is6, p_ip, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_dip(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->dip.is_valid);
+    bool* p_is6      = &(p_rtn_cmdargs->dip.is6);
+    uint32_t* p_ip   =  (p_rtn_cmdargs->dip.arr);
+    
+    rtn = cli_txt2ip(p_is6, p_ip, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_r_sip(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->sip2.is_valid);
+    bool* p_is6      = &(p_rtn_cmdargs->sip2.is6);
+    uint32_t* p_ip   =  (p_rtn_cmdargs->sip2.arr);
+    
+    rtn = cli_txt2ip(p_is6, p_ip, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_r_dip(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->dip2.is_valid);
+    bool* p_is6      = &(p_rtn_cmdargs->dip2.is6);
+    uint32_t* p_ip   =  (p_rtn_cmdargs->dip2.arr);
+    
+    rtn = cli_txt2ip(p_is6, p_ip, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_sip6(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->sip2.is_valid);
+    bool* p_is6      = &(p_rtn_cmdargs->sip2.is6);
+    uint32_t* p_ip   =  (p_rtn_cmdargs->sip2.arr);
+    
+    rtn = cli_txt2ip(p_is6, p_ip, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_dip6(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->dip2.is_valid);
+    bool* p_is6      = &(p_rtn_cmdargs->dip2.is6);
+    uint32_t* p_ip   =  (p_rtn_cmdargs->dip2.arr);
+    
+    rtn = cli_txt2ip(p_is6, p_ip, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_sport(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->sport.is_valid);
+    uint16_t* p_value = &(p_rtn_cmdargs->sport.value);
+    
+    rtn = cli_txt2num_u16(p_value, p_txt_optarg, BASE_DEC, 0u, UINT16_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_dport(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->dport.is_valid);
+    uint16_t* p_value = &(p_rtn_cmdargs->dport.value);
+    
+    rtn = cli_txt2num_u16(p_value, p_txt_optarg, BASE_DEC, 0u, UINT16_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_r_sport(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->sport2.is_valid);
+    uint16_t* p_value = &(p_rtn_cmdargs->sport2.value);
+    
+    rtn = cli_txt2num_u16(p_value, p_txt_optarg, BASE_DEC, 0u, UINT16_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_r_dport(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->dport2.is_valid);
+    uint16_t* p_value = &(p_rtn_cmdargs->dport2.value);
+    
+    rtn = cli_txt2num_u16(p_value, p_txt_optarg, BASE_DEC, 0u, UINT16_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_hif_cookie(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->data_hifc_sad.is_valid);
+    uint32_t* p_value = &(p_rtn_cmdargs->data_hifc_sad.value);
+    
+    rtn = cli_txt2num_u32(p_value, p_txt_optarg, BASE_HEX, 0u, UINT32_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_data(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->data_hifc_sad.is_valid);
+    uint32_t* p_value = &(p_rtn_cmdargs->data_hifc_sad.value);
+    
+    rtn = cli_txt2num_u32(p_value, p_txt_optarg, BASE_HEX, 0u, UINT32_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_sad(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->data_hifc_sad.is_valid);
+    uint32_t* p_value = &(p_rtn_cmdargs->data_hifc_sad.value);
+    
+    rtn = cli_txt2num_u32(p_value, p_txt_optarg, BASE_DEC, 0u, UINT32_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_mask(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->mask_spi.is_valid);
+    uint32_t* p_value = &(p_rtn_cmdargs->mask_spi.value);
+    
+    rtn = cli_txt2num_u32(p_value, p_txt_optarg, BASE_HEX, 0u, UINT32_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_spi(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->mask_spi.is_valid);
+    uint32_t* p_value = &(p_rtn_cmdargs->mask_spi.value);
+    
+    rtn = cli_txt2num_u32(p_value, p_txt_optarg, BASE_HEX, 0u, UINT32_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_timeout(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->timeout.is_valid);
+    uint32_t* p_value = &(p_rtn_cmdargs->timeout.value);
+    
+    rtn = cli_txt2num_u32(p_value, p_txt_optarg, BASE_DEC, 0u, UINT32_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_timeout2(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->timeout2.is_valid);
+    uint32_t* p_value = &(p_rtn_cmdargs->timeout2.value);
+    
+    rtn = cli_txt2num_u32(p_value, p_txt_optarg, BASE_DEC, 0u, UINT32_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_ucast_hit(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->ucast_hit.is_valid);
+    uint8_t* p_value = &(p_rtn_cmdargs->ucast_hit.value);
+    
+    rtn = cli_txt2bdaction(p_value, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_ucast_miss(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->ucast_miss.is_valid);
+    uint8_t* p_value = &(p_rtn_cmdargs->ucast_miss.value);
+    
+    rtn = cli_txt2bdaction(p_value, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_mcast_hit(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->mcast_hit.is_valid);
+    uint8_t* p_value = &(p_rtn_cmdargs->mcast_hit.value);
+    
+    rtn = cli_txt2bdaction(p_value, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_mcast_miss(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->mcast_miss.is_valid);
+    uint8_t* p_value = &(p_rtn_cmdargs->mcast_miss.value);
+    
+    rtn = cli_txt2bdaction(p_value, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_tag(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->tag.is_valid);
+    bool* p_is_on    = &(p_rtn_cmdargs->tag.is_on);
+    
+    rtn = cli_txt2bool_on_off(p_is_on, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_default(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    UNUSED(p_txt_optarg);  /* just to suppress gcc warning */
+    
+    
+    p_rtn_cmdargs->default0.is_valid = true;
+    return (CLI_OK);
+}
+
+static int opt_parse_fallback(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    UNUSED(p_txt_optarg);  /* just to suppress gcc warning */
+    
+    
+    p_rtn_cmdargs->fallback_4o6.is_valid = true;
+    return (CLI_OK);
+}
+
+static int opt_parse_4o6(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    UNUSED(p_txt_optarg);  /* just to suppress gcc warning */
+    
+    
+    p_rtn_cmdargs->fallback_4o6.is_valid = true;
+    return (CLI_OK);
+}
+
+static int opt_parse_route(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->route.is_valid);
+    uint32_t* p_value = &(p_rtn_cmdargs->route.value);
+    
+    rtn = cli_txt2num_u32(p_value, p_txt_optarg, BASE_DEC, 0u, UINT32_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_r_route(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->route2.is_valid);
+    uint32_t* p_value = &(p_rtn_cmdargs->route2.value);
+    
+    rtn = cli_txt2num_u32(p_value, p_txt_optarg, BASE_DEC, 0u, UINT32_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_ingress_mr0(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->ruleA0_name.is_valid);
+    char* p_txt      =  (p_rtn_cmdargs->ruleA0_name.txt);
+    
+    rtn = cli_txtcpy_table_name(p_txt, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_ingress_mr1(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->ruleA1_name.is_valid);
+    char* p_txt      =  (p_rtn_cmdargs->ruleA1_name.txt);
+    
+    rtn = cli_txtcpy_table_name(p_txt, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_egress_mr0(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->ruleB0_name.is_valid);
+    char* p_txt      =  (p_rtn_cmdargs->ruleB0_name.txt);
+    
+    rtn = cli_txtcpy_table_name(p_txt, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_egress_mr1(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->ruleB1_name.is_valid);
+    char* p_txt      =  (p_rtn_cmdargs->ruleB1_name.txt);
+    
+    rtn = cli_txtcpy_table_name(p_txt, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_table(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->table0_name.is_valid);
+    char* p_txt      =  (p_rtn_cmdargs->table0_name.txt);
+    
+    rtn = cli_txtcpy_table_name(p_txt, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_table0(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->table0_name.is_valid);
+    char* p_txt      =  (p_rtn_cmdargs->table0_name.txt);
+    
+    rtn = cli_txtcpy_table_name(p_txt, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_flexible_filter(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->table0_name.is_valid);
+    char* p_txt      =  (p_rtn_cmdargs->table0_name.txt);
+    
+    rtn = cli_txtcpy_table_name(p_txt, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_table1(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->table1_name.is_valid);
+    char* p_txt      =  (p_rtn_cmdargs->table1_name.txt);
+    
+    rtn = cli_txtcpy_table_name(p_txt, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_rule(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->ruleA0_name.is_valid);
+    char* p_txt      =  (p_rtn_cmdargs->ruleA0_name.txt);
+    
+    rtn = cli_txtcpy_rule_name(p_txt, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_next_rule(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->ruleB0_name.is_valid);
+    char* p_txt      =  (p_rtn_cmdargs->ruleB0_name.txt);
+    
+    rtn = cli_txtcpy_rule_name(p_txt, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_layer(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool*              p_is_valid = &(p_rtn_cmdargs->layer.is_valid);
+    fpp_fp_offset_from_t* p_value = &(p_rtn_cmdargs->layer.value);
+    
+    {
+        /* parse input */
+        uint8_t tmp_value = 0u;
+        rtn = cli_txt2value_offset_from(&tmp_value, p_txt_optarg);
+        if (CLI_OK != rtn)
+        {
+            rtn = cli_txt2num_u8(&tmp_value, p_txt_optarg, BASE_DEC, OFFSET_FROMS__MIN, OFFSET_FROMS__MAX);
+        }
+        
+        /* assign data */
+        if (CLI_OK == rtn)
+        {
+            *p_value = tmp_value;  /* WARNING: cast to enum */
+        }
+    }
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_offset(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->offset.is_valid);
+    uint16_t* p_value = &(p_rtn_cmdargs->offset.value);
+    
+    rtn = cli_txt2num_u16(p_value, p_txt_optarg, BASE_DEC, 0u, UINT16_MAX);
+    if (CLI_OK != rtn)
+    {
+        rtn = cli_txt2num_u16(p_value, p_txt_optarg, BASE_HEX, 0u, UINT16_MAX);
+    }
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_position(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->offset.is_valid);
+    uint16_t* p_value = &(p_rtn_cmdargs->offset.value);
+    
+    rtn = cli_txt2num_u16(p_value, p_txt_optarg, BASE_DEC, 0u, UINT16_MAX);
+    if (CLI_OK != rtn)
+    {
+        rtn = cli_txt2num_u16(p_value, p_txt_optarg, BASE_HEX, 0u, UINT16_MAX);
+    }
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_invert(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    UNUSED(p_txt_optarg);  /* just to suppress gcc warning */
+    
+    
+    p_rtn_cmdargs->invert.is_valid = true;
+    return (CLI_OK);
+}
+
+static int opt_parse_accept(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    UNUSED(p_txt_optarg);  /* just to suppress gcc warning */
+    
+    
+    p_rtn_cmdargs->accept.is_valid = true;
+    return (CLI_OK);
+}
+
+static int opt_parse_reject(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    UNUSED(p_txt_optarg);  /* just to suppress gcc warning */
+    
+    
+    p_rtn_cmdargs->reject.is_valid = true;
+    return (CLI_OK);
+}
+
+static int opt_parse_spd_action(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool*          p_is_valid = &(p_rtn_cmdargs->spd_action.is_valid);
+    fpp_spd_action_t* p_value = &(p_rtn_cmdargs->spd_action.value);
+    
+    {
+        /* parse input */
+        uint8_t tmp_value = 0u;
+        rtn = cli_txt2value_spd_action(&tmp_value, p_txt_optarg);
+        
+        /* assign data */
+        if (CLI_OK == rtn)
+        {
+            *p_value = tmp_value;  /* WARNING: cast to enum */
+        }
+    }
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_vlan_conf(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->vlan_conf__x_src.is_valid);
+    bool* p_is_on    = &(p_rtn_cmdargs->vlan_conf__x_src.is_on);
+    
+    rtn = cli_txt2bool_on_off(p_is_on, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_discard_on_match_src(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->vlan_conf__x_src.is_valid);
+    bool* p_is_on    = &(p_rtn_cmdargs->vlan_conf__x_src.is_on);
+    
+    rtn = cli_txt2bool_on_off(p_is_on, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_ptp_conf(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->ptp_conf__x_dst.is_valid);
+    bool* p_is_on    = &(p_rtn_cmdargs->ptp_conf__x_dst.is_on);
+    
+    rtn = cli_txt2bool_on_off(p_is_on, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_discard_on_match_dst(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->ptp_conf__x_dst.is_valid);
+    bool* p_is_on    = &(p_rtn_cmdargs->ptp_conf__x_dst.is_on);
+    
+    rtn = cli_txt2bool_on_off(p_is_on, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_ptp_promisc(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->ptp_promisc.is_valid);
+    bool* p_is_on    = &(p_rtn_cmdargs->ptp_promisc.is_on);
+    
+    rtn = cli_txt2bool_on_off(p_is_on, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_loopback(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->loopback.is_valid);
+    bool* p_is_on    = &(p_rtn_cmdargs->loopback.is_on);
+    
+    rtn = cli_txt2bool_on_off(p_is_on, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_qinq(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->qinq.is_valid);
+    bool* p_is_on    = &(p_rtn_cmdargs->qinq.is_on);
+    
+    rtn = cli_txt2bool_on_off(p_is_on, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_local(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->local.is_valid);
+    bool* p_is_on    = &(p_rtn_cmdargs->local.is_on);
+    
+    rtn = cli_txt2bool_on_off(p_is_on, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_feature(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->feature_name.is_valid);
+    char* p_txt      =  (p_rtn_cmdargs->feature_name.txt);
+    
+    rtn = cli_txtcpy_feature_name(p_txt, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_static(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    UNUSED(p_txt_optarg);  /* just to suppress gcc warning */
+    
+    
+    p_rtn_cmdargs->static0.is_valid = true;
+    return (CLI_OK);
+}
+
+static int opt_parse_dynamic(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    UNUSED(p_txt_optarg);  /* just to suppress gcc warning */
+    
+    
+    p_rtn_cmdargs->dynamic0.is_valid = true;
+    return (CLI_OK);
+}
+
+static int opt_parse_que(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->que_sch_shp.is_valid);
+    uint8_t* p_value = &(p_rtn_cmdargs->que_sch_shp.value);
+    
+    rtn = cli_txt2num_u8(p_value, p_txt_optarg, BASE_DEC, 0u, UINT8_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_sch(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->que_sch_shp.is_valid);
+    uint8_t* p_value = &(p_rtn_cmdargs->que_sch_shp.value);
+    
+    rtn = cli_txt2num_u8(p_value, p_txt_optarg, BASE_DEC, 0u, UINT8_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_shp(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->que_sch_shp.is_valid);
+    uint8_t* p_value = &(p_rtn_cmdargs->que_sch_shp.value);
+    
+    rtn = cli_txt2num_u8(p_value, p_txt_optarg, BASE_DEC, 0u, UINT8_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_que_mode(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->que_sch_shp_mode.is_valid);
+    uint8_t* p_value = &(p_rtn_cmdargs->que_sch_shp_mode.value);
+    
+    rtn = cli_txt2value_que_mode(p_value, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_sch_mode(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->que_sch_shp_mode.is_valid);
+    uint8_t* p_value = &(p_rtn_cmdargs->que_sch_shp_mode.value);
+    
+    rtn = cli_txt2value_sch_mode(p_value, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_shp_mode(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->que_sch_shp_mode.is_valid);
+    uint8_t* p_value = &(p_rtn_cmdargs->que_sch_shp_mode.value);
+    
+    rtn = cli_txt2value_shp_mode(p_value, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_thmin(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->thmin.is_valid);
+    uint32_t* p_value = &(p_rtn_cmdargs->thmin.value);
+    
+    rtn = cli_txt2num_u32(p_value, p_txt_optarg, BASE_DEC, 0u, 255u);  /* according to FCI Reference, max queue depth is 255 */
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_thmax(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->thmax.is_valid);
+    uint32_t* p_value = &(p_rtn_cmdargs->thmax.value);
+    
+    rtn = cli_txt2num_u32(p_value, p_txt_optarg, BASE_DEC, 0u, 255u);  /* according to FCI Reference, max queue depth is 255 */
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_zprob(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->zprob.is_valid);
+    uint8_t* p_arr   =  (p_rtn_cmdargs->zprob.arr);
+    
+    rtn = cli_txt2zprobs(p_arr, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_sch_algo(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->sch_algo.is_valid);
+    uint8_t* p_value = &(p_rtn_cmdargs->sch_algo.value);
+    
+    rtn = cli_txt2value_sch_algo(p_value, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_sch_in(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool*          p_is_valid  = &(p_rtn_cmdargs->sch_in.is_valid);
+    struct sch_in_tt* p_struct = &(p_rtn_cmdargs->sch_in);
+    
+    rtn = cli_txt2sch_ins(p_struct, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_shp_pos(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->shp_pos.is_valid);
+    uint8_t* p_value = &(p_rtn_cmdargs->shp_pos.value);
+    
+    rtn = cli_txt2value_shp_pos(p_value, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_isl(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid  = &(p_rtn_cmdargs->isl.is_valid);
+    uint32_t* p_value = &(p_rtn_cmdargs->isl.value);
+    
+    rtn = cli_txt2num_u32(p_value, p_txt_optarg, BASE_DEC, 0u, UINT32_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_crmin(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->crmin.is_valid);
+    int32_t* p_value = &(p_rtn_cmdargs->crmin.value);
+    
+    rtn = cli_txt2num_i32(p_value, p_txt_optarg, BASE_DEC, INT32_MIN, INT32_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_crmax(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->crmax.is_valid);
+    int32_t* p_value = &(p_rtn_cmdargs->crmax.value);
+    
+    rtn = cli_txt2num_i32(p_value, p_txt_optarg, BASE_DEC, INT32_MIN, INT32_MAX);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+static int opt_parse_discard_if_ttl_below_2(cli_cmdargs_t* p_rtn_cmdargs, const char* p_txt_optarg)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_optarg);
+    
+    
+    int rtn = CLI_ERR;
+    bool* p_is_valid = &(p_rtn_cmdargs->discard_if_ttl_below_2.is_valid);
+    bool* p_is_on    = &(p_rtn_cmdargs->discard_if_ttl_below_2.is_on);
+    
+    rtn = cli_txt2bool_on_off(p_is_on, p_txt_optarg);
+    
+    set_if_rtn_ok(rtn, p_is_valid);
+    return (rtn);
+}
+
+
+
+
+
+
+
+
+
+
+
+/* OPT_LAST (keep this at the bottom of the opt_parse section) */
+
+/* ==== PRIVATE FUNCTIONS : misc =========================================== */
+
+static void set_if_rtn_ok(int rtn_from_caller, bool* p_is_valid)
+{
+    assert(NULL != p_is_valid);
+    if (CLI_OK == rtn_from_caller)
+    {
+        *p_is_valid = true;
+    }
+}
+
+static int cli_txt2bool_on_off(bool* p_rtn_value, const char* p_txt)
+{
+    assert(NULL != p_rtn_value);
+    assert(NULL != p_txt);
+    
+    
+    /* parse input */
+    uint8_t tmp_value = 0u;
+    int rtn = cli_txt2value_on_off(&tmp_value, p_txt);
+    
+    /* assign data */
+    if (CLI_OK == rtn)
+    {
+        *p_rtn_value = (bool)(tmp_value);
+    }
+    
+    return (rtn);
+}
+
+static int cli_txt2bdaction(uint8_t* p_rtn_value, const char* p_txt)
+{
+    assert(NULL != p_rtn_value);
+    assert(NULL != p_txt);
+    
+    
+    int rtn = cli_txt2value_bd_action(p_rtn_value, p_txt);
+    if (CLI_OK != rtn)
+    {
+        rtn = cli_txt2num_u8(p_rtn_value, p_txt, BASE_DEC, 0u, BD_ACTIONS__MAX);
+    }
+    
+    return (rtn);
+}
+
+/* ==== PRIVATE FUNCTIONS : txtcpy ========================================= */
+
+static int txtcpy(char* p_rtn_buf, const char* p_txt, const uint16_t buf_ln)
+{
+    assert(NULL != p_rtn_buf);
+    assert(NULL != p_txt);
+    
+    
+    int rtn = CLI_ERR;
+    
+    if ('-' == p_txt[0])
+    {
+        /* 
+            If argument of an opt is missing in the input txt vector, then the next element in the txt vector
+            (usually the next opt) is erroneously assumed to be the argument.
+            For opts with non-txt target argument, this issue is "good enough" detectable (conversion from txt will fail).
+            For opts with txt target argument, detection is a bit difficult.
+            
+            Ergo, for opts with txt target argument, a check for leading '-' character was decided to be "good enough".
+            WARNING: This solution assumes that no valid txt target argument contains '-' as a leading character.
+        */
+        rtn = CLI_ERR_INVARG;
+    }    
+    else
+    {
+        if ((strlen(p_txt) + 1u) > buf_ln)  /* +1 for the string terminator */
+        {
+            rtn = CLI_ERR_INVARG;
+        }
+        else
+        {
+            strcpy(p_rtn_buf, p_txt);
+            rtn = CLI_OK;
+        }
+    }
+    
+    return (rtn);
+}
+
+inline static int cli_txtcpy_if_name(char* p_rtn_buf, const char* p_txt)
+{
+    return txtcpy(p_rtn_buf, p_txt, IF_NAME_TXT_LN);
+}
+
+inline static int cli_txtcpy_table_name(char* p_rtn_buf, const char* p_txt)
+{
+    return txtcpy(p_rtn_buf, p_txt, TABLE_NAME_TXT_LN);
+}
+
+inline static int cli_txtcpy_rule_name(char* p_rtn_buf, const char* p_txt)
+{
+    return cli_txtcpy_table_name(p_rtn_buf, p_txt);  /* rule names use same parameters as table names */
+}
+
+inline static int cli_txtcpy_feature_name(char* p_rtn_buf, const char* p_txt)
+{
+    return txtcpy(p_rtn_buf, p_txt, FEATURE_NAME_TXT_LN);
+}
+
+/* ==== PRIVATE FUNCTIONS : txt2num (unsigned) ============================= */
+
+static int txt2num_ull(unsigned long long* p_rtn_num, const char* p_txt, int base,
+                       const unsigned long long min, const unsigned long long max)
+{
+    assert(NULL != p_rtn_num);
+    assert(NULL != p_txt);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* if HEX base, enforce leading '0x...' or '0X...' to prevent input ambiguity (from user's POV) */
+    if (BASE_HEX == base)
+    {
+        rtn = (('0' == p_txt[0]) && (('x' == p_txt[1]) || ('X' == p_txt[1]))) ? (CLI_OK) : (CLI_ERR_INVARG);
+    }
+    else
+    {
+        rtn = CLI_OK;
+    }
+    
+    /* convert the input */
+    /* maximal expected size is u32 */
+    /* unsigned long long conversion chosen in order to detect negative inputs (yields too large values for u32) */
+    if (CLI_OK == rtn)
+    {
+        char* p_end = NULL;
+        unsigned long long tmp_num = strtoull(p_txt, &p_end, base);
+        if ((p_txt == p_end) || ('\0' != (*p_end)))  /* assumes that input is a single standalone number */
+        {
+            rtn = CLI_ERR_INVARG;
+        }
+        else if ((min > tmp_num) || (max < tmp_num))
+        {
+            rtn = CLI_ERR_INVARG;
+        }
+        else
+        {
+            *p_rtn_num = tmp_num;
+            rtn = CLI_OK;
+        }
+    }
+    
+    return (rtn);
+}
+
+static int cli_txt2num_u8(uint8_t* p_rtn_num, const char* p_txt, int base,
+                          const uint8_t min, const uint8_t max)
+{
+    assert(NULL != p_rtn_num);
+    unsigned long long tmp_num = 0u;
+    int rtn = txt2num_ull(&tmp_num, p_txt, base, min, max);
+    if (CLI_OK == rtn)
+    {
+        *p_rtn_num = tmp_num;  /* WARNING: implicit narrowing cast */
+    }
+    return (rtn);
+}
+
+static int cli_txt2num_u16(uint16_t* p_rtn_num, const char* p_txt, int base,
+                           const uint16_t min, const uint16_t max)
+{
+    assert(NULL != p_rtn_num);
+    unsigned long long tmp_num = 0u;
+    int rtn = txt2num_ull(&tmp_num, p_txt, base, min, max);
+    if (CLI_OK == rtn)
+    {
+        *p_rtn_num = tmp_num;  /* WARNING: implicit narrowing cast */
+    }
+    return (rtn);
+}
+
+static int cli_txt2num_u32(uint32_t* p_rtn_num, const char* p_txt, int base,
+                           const uint32_t min, const uint32_t max)
+{
+    assert(NULL != p_rtn_num);
+    unsigned long long tmp_num = 0u;
+    int rtn = txt2num_ull(&tmp_num, p_txt, base, min, max);
+    if (CLI_OK == rtn)
+    {
+        *p_rtn_num = tmp_num;  /* WARNING: implicit narrowing cast */
+    }
+    return (rtn);
+}
+
+/* ==== PRIVATE FUNCTIONS : txt2num (signed) =============================== */
+
+static int txt2num_ll(long long* p_rtn_num, const char* p_txt, int base,
+                      const long long min, const long long max)
+{
+    assert(NULL != p_rtn_num);
+    assert(NULL != p_txt);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* if HEX base, enforce leading '0x...' or '0X...' to prevent input ambiguity (from user's POV) */
+    if (BASE_HEX == base)
+    {
+        rtn = (('0' == p_txt[0]) && (('x' == p_txt[1]) || ('X' == p_txt[1]))) ? (CLI_OK) : (CLI_ERR_INVARG);
+    }
+    else
+    {
+        rtn = CLI_OK;
+    }
+    
+    /* convert the input */
+    /* maximal expected size is i32 */
+    /* long long conversion chosen in order to detect negative inputs (yields too large values for i32) */
+    if (CLI_OK == rtn)
+    {
+        char* p_end = NULL;
+        long long tmp_num = strtoll(p_txt, &p_end, base);
+        if ((p_txt == p_end) || ('\0' != (*p_end)))  /* assumes that input is a single standalone number */
+        {
+            rtn = CLI_ERR_INVARG;
+        }
+        else if ((min > tmp_num) || (max < tmp_num))
+        {
+            rtn = CLI_ERR_INVARG;
+        }
+        else
+        {
+            *p_rtn_num = tmp_num;
+            rtn = CLI_OK;
+        }
+    }
+    
+    return (rtn);
+}
+
+static int cli_txt2num_i32(int32_t* p_rtn_num, const char* p_txt, int base,
+                           const int32_t min, const int32_t max)
+{
+    assert(NULL != p_rtn_num);
+    long long tmp_num = 0u;
+    int rtn = txt2num_ll(&tmp_num, p_txt, base, min, max);
+    if (CLI_OK == rtn)
+    {
+        *p_rtn_num = tmp_num;  /* WARNING: implicit narrowing cast */
+    }
+    return (rtn);
+}
+
+/* ==== PRIVATE FUNCTIONS : parse_substrings =============================== */
+
+static int parse_substrings(void* p_rtn_void, const char* p_txt, const cb_txt2value_t p_cb_txt2value,
+                            const cb_loop_t p_cb_loop, const uint8_t max_count)
+{
+    assert(NULL != p_rtn_void);
+    assert(NULL != p_txt);
+    assert(NULL != p_cb_loop);
+    /* 'p_cb_txt2value' is allowed to be NULL */
+    
+    
+    int rtn = CLI_ERR;
+    char* p_txt_mutable = NULL;
+    
+    /* malloc a local modifiable copy of 'p_txt', because even if 'p_txt' was modifiable, it could still point to a literal --> problems galore */
+    {
+        const size_t ln = (strlen(p_txt) + 1u);
+        p_txt_mutable = malloc(ln * sizeof(char));
+        if (NULL == p_txt_mutable)
+        {
+            rtn = CLI_ERR_INVPTR;
+        }
+        else
+        {
+            memcpy(p_txt_mutable, p_txt, ln);
+            rtn = CLI_OK;  /* greenlight execution of the next sub-block */
+        }
+    }
+    
+    /* run the target loop */
+    if (CLI_OK == rtn)
+    {
+        uint8_t i = UINT8_MAX;  /* WARNING: intentional use of owf behavior */
+        char* p_txt_token_next = strtok(p_txt_mutable, ",");
+        
+        /* loop_pre */
+        if (CLI_OK == rtn)
+        {
+            rtn = p_cb_loop(p_rtn_void, "", p_cb_txt2value, LOOP_PRE, 0u);
+        }
+        
+        /* loop_body */
+        while ((max_count > (++i)) && (CLI_OK == rtn) && (NULL != p_txt_token_next))
+        {
+            /* some strtok() implementations improperly react on "3rd party" modifications of the CURRENT substring */
+            /* work-around is to use the "current - 1" substring */
+            char* p_txt_token = p_txt_token_next;
+            p_txt_token_next = strtok(NULL, ",");
+            rtn = p_cb_loop(p_rtn_void, p_txt_token, p_cb_txt2value, LOOP_BODY, i);
+        }
+        /* local post-loop check that there are no more substrings left */
+        if ((max_count <= i) && (NULL != p_txt_token_next))
+        {
+            rtn = CLI_ERR_INVARG;
+        }
+        
+        /* loop_post */
+        if (CLI_OK == rtn)
+        {
+            rtn = p_cb_loop(p_rtn_void, "", p_cb_txt2value, LOOP_POST, i);
+        }
+    }
+    
+    /* free the malloc'd memory (do not hide behind rtn check) */
+    if (NULL != p_txt_mutable)  /* better safe than sorry; some C-runtimes crash when NULL ptr is freed */
+    {
+        free(p_txt_mutable);
+    }
+    
+    return (rtn);
+}
+
+/* ==== PRIVATE FUNCTIONS : txt2bitset ===================================== */
+
+#define BITSET32_LN  32u
+
+/* param 'i' refers to loop counter from 'parse_substrings()' fnc */
+static int loop_bitset32(void* p_rtn_void, char* p_txt, const cb_txt2value_t p_cb_txt2value, loopstage_t loopstage, uint8_t i)
+{
+    assert(NULL != p_rtn_void);
+    assert(NULL != p_cb_txt2value);
+    /* 'p_txt' is allowed to be NULL */
+    
+    
+    int rtn = CLI_ERR;
+    uint32_t *const p_rtn_value = (uint32_t*)(p_rtn_void);
+    
+    if (LOOP_PRE == loopstage)
+    {
+        *p_rtn_value = 0u;
+        rtn = CLI_OK;
+    }
+    else if ((LOOP_BODY == loopstage) && (NULL != p_txt))
+    {
+        UNUSED(i);  /* bitset flags in the cli optarg string can be listed in random order; precise index is therefore useless */
+        uint8_t bitpos = 0u;
+        
+        /* get bitpos */
+        rtn = p_cb_txt2value(&bitpos, p_txt);
+        if (CLI_OK != rtn)
+        {
+            /* if txt2value fails, then maybe the txt token is directly a bitpos idx (some numeric value) */
+            rtn = cli_txt2num_u8(&bitpos, p_txt, BASE_DEC, 0u, BITSET32_LN);
+        }
+        
+        /* apply bitpos */
+        if (CLI_OK == rtn)
+        {
+            if (BITSET32_LN <= bitpos)
+            {
+                rtn = CLI_ERR_INVARG;
+            }
+            else
+            {
+                *p_rtn_value |= (1uL << bitpos);  /* directly accessing rtn memory! */
+            }
+        }
+    }
+    else if (LOOP_POST == loopstage)
+    {
+        /* empty */
+        rtn = CLI_OK;
+    }
+    else
+    {
+        rtn = CLI_ERR;
+    }
+    
+    return (rtn);
+}
+
+static int cli_txt2bitset32(uint32_t* p_rtn_bitset, const char* p_txt, const cb_txt2value_t p_cb_txt2value)
+{
+    assert(NULL != p_rtn_bitset);
+    uint32_t tmp_bitset = 0u;
+    int rtn = parse_substrings(&tmp_bitset, p_txt, p_cb_txt2value, loop_bitset32, BITSET32_LN);
+    if (CLI_OK == rtn)
+    {
+        *p_rtn_bitset = tmp_bitset;
+    }
+    return (rtn);
+}
+
+/* ==== PRIVATE FUNCTIONS : txt2zprobs ===================================== */
+
+/* param 'i' refers to loop counter from 'parse_substrings()' fnc */
+static int loop_zprobs(void* p_rtn_void, char* p_txt, const cb_txt2value_t p_cb_txt2value, loopstage_t loopstage, uint8_t i)
+{
+    assert(NULL != p_rtn_void);
+    UNUSED(p_cb_txt2value);
+    /* 'p_txt' is allowed to be NULL */
+    
+    
+    int rtn = CLI_ERR;
+    uint8_t *const p_rtn_value = (uint8_t*)(p_rtn_void) + i;  /* during LOOP_BODY, access directly the array element in question */
+    
+    if (LOOP_PRE == loopstage)
+    {
+        uint8_t keep = 0u;
+        rtn = cli_txt2value_que_zprob_keep(&keep, TXT_QUE_ZPROB__KEEP);
+        if (CLI_OK == rtn)
+        {
+            memset(p_rtn_value, keep, (sizeof(uint8_t) * ZPROBS_LN));
+        }
+    }
+    else if ((LOOP_BODY == loopstage) && (NULL != p_txt))
+    {
+        rtn = cli_txt2value_que_zprob_keep(p_rtn_value, p_txt);
+        if (CLI_OK != rtn)
+        {
+            rtn = cli_txt2num_u8(p_rtn_value, p_txt, BASE_DEC, 0u, 100u);  /* percentage */
+        }
+    }
+    else if (LOOP_POST == loopstage)
+    {
+        /* empty */
+        rtn = CLI_OK;
+    }
+    else
+    {
+        rtn = CLI_ERR;
+    }
+    
+    return (rtn);
+}
+
+static int cli_txt2zprobs(uint8_t* p_rtn_zprobs, const char* p_txt)
+{
+    return parse_substrings(p_rtn_zprobs, p_txt, NULL, loop_zprobs, ZPROBS_LN);
+}
+
+/* ==== PRIVATE FUNCTIONS : txt2sch_ins ==================================== */
+
+/* param 'i' refers to loop counter from 'parse_substrings()' fnc */
+static int loop_sch_ins(void* p_rtn_void, char* p_txt, const cb_txt2value_t p_cb_txt2value, loopstage_t loopstage, uint8_t i)
+{
+    assert(NULL != p_rtn_void);
+    UNUSED(p_cb_txt2value);
+    /* 'p_txt' is allowed to be NULL */
+    
+    
+    int rtn = CLI_ERR;
+    struct sch_in_tt *const p_rtn_struct_with_sch_ins = (struct sch_in_tt*)(p_rtn_void);
+    
+    if (LOOP_PRE == loopstage)
+    {
+        uint8_t keep = 0u;
+        rtn = cli_txt2value_sch_in(&keep, TXT_SCH_IN__KEEP);
+        if (CLI_OK == rtn)
+        {
+            memset((p_rtn_struct_with_sch_ins->arr_src), keep, (sizeof(uint8_t) * SCH_INS_LN));
+            memset((p_rtn_struct_with_sch_ins->arr_w), 0, (sizeof(uint32_t) * SCH_INS_LN));
+        }
+    }
+    else if ((LOOP_BODY == loopstage) && (NULL != p_txt))
+    {
+        uint8_t  *const p_rtn_src = (p_rtn_struct_with_sch_ins->arr_src + i);
+        uint32_t *const p_rtn_w   = (p_rtn_struct_with_sch_ins->arr_w   + i);
+        
+        /* split the input string */
+        char* p_txt_src = p_txt;
+        char* p_txt_w   = strchr(p_txt, ':');  /* ':' is a separator between the input keyword and the input weight */
+        if (NULL != p_txt_w)
+        {
+            *p_txt_w++ = '\0';  /* if the string is valid, then it has at least two elements: non-NULL [0] element and NULL [1] element */
+        }
+        
+        /* input src */
+        rtn = cli_txt2value_sch_in(p_rtn_src, p_txt_src);
+        
+        /* input weight */
+        if ((CLI_OK == rtn) && cli_sch_in_is_not_dis(*p_rtn_src) && cli_sch_in_is_not_keep(*p_rtn_src))
+        {  
+            if (NULL != p_txt_w)
+            {
+                rtn = cli_txt2num_u32(p_rtn_w, p_txt_w, BASE_DEC, 0u, UINT32_MAX);
+            }
+            else
+            {
+                rtn = CLI_ERR_INVARG;
+            }
+        }
+    }
+    else if (LOOP_POST == loopstage)
+    {
+        /* empty */
+        rtn = CLI_OK;
+    }
+    else
+    {
+        rtn = CLI_ERR;
+    }
+    
+    return (rtn);
+}
+
+static int cli_txt2sch_ins(struct sch_in_tt* p_rtn_struct_with_sch_ins, const char* p_txt)
+{
+    return parse_substrings(p_rtn_struct_with_sch_ins, p_txt, NULL, loop_sch_ins, SCH_INS_LN);
+}
+
+/* ==== PRIVATE FUNCTIONS : txt2mac ===================================== */
+
+#define T2M_DELIMS_LN  (MAC_BYTES_LN - 1u)  /* there is no delimiter after the last byte of the mac address */
+#define T2M_FMT_DELIM  "%2[-:]"
+static int cli_txt2mac(uint8_t* p_rtn_mac, const char* p_txt)
+{
+    assert(NULL != p_rtn_mac);
+    assert(NULL != p_txt);
+    /* 'p_rtn_is_valid' is allowed to be NULL */
+    #if (MAC_BYTES_LN != 6u)
+    #error Unexpected MAC_BYTES_LN value! If not '6', then change 'sscanf()' parameters accordingly!
+    #endif
+    
+    int rtn = CLI_ERR;
+    
+    /*
+        WARNING: Size of the second dimension is expected to be (delim_width + 1).
+                 Delim width is a width of a sscanf() specifier from the T2M_FMT_DELIM macro.
+    */
+    char txt_delims[T2M_DELIMS_LN][3] = {'\0'};
+    uint8_t tmp_mac[MAC_BYTES_LN] = {0u};
+    
+    /* convert from txt input */
+    rtn = (MAC_STRLEN != strlen(p_txt)) ? (CLI_ERR_INVARG) : (CLI_OK);
+    if (CLI_OK == rtn)
+    {
+        const int item_cnt = sscanf(p_txt,  "%2"SCNx8  T2M_FMT_DELIM  "%2"SCNx8  T2M_FMT_DELIM  "%2"SCNx8  T2M_FMT_DELIM
+                                            "%2"SCNx8  T2M_FMT_DELIM  "%2"SCNx8  T2M_FMT_DELIM  "%2"SCNx8,
+                                            (tmp_mac + 0), txt_delims[0],
+                                            (tmp_mac + 1), txt_delims[1],
+                                            (tmp_mac + 2), txt_delims[2],
+                                            (tmp_mac + 3), txt_delims[3],
+                                            (tmp_mac + 4), txt_delims[4],
+                                            (tmp_mac + 5));  /* no delims expected after the last mac byte */
+        rtn = ((MAC_BYTES_LN + T2M_DELIMS_LN) != item_cnt) ? (CLI_ERR_INVARG) : (CLI_OK);
+    }
+    
+    /* check delimiters ; correctly parsed txt input has no more than ONE non-null character per each delimiter */
+    if (CLI_OK == rtn)
+    {
+        uint8_t i = UINT8_MAX;  /* WARNING: intentional use of owf behavior */
+        while ((T2M_DELIMS_LN > (++i)) && ('\0' == txt_delims[i][1])) { /* empty */ }
+        if (T2M_DELIMS_LN > i)
+        {
+            /* some delim was not correct */
+            rtn = CLI_ERR_INVARG;
+        }
+    }
+    
+    /* assign return data */
+    if (CLI_OK == rtn)
+    {    
+        memcpy(p_rtn_mac, tmp_mac, MAC_BYTES_LN);
+    }
+    
+    return (rtn);
+}
+
+/* ==== PRIVATE FUNCTIONS : txt2ip ===================================== */
+
+static int cli_txt2ip(bool* p_rtn_is6, uint32_t* p_rtn_ip, const char* p_txt)
+{
+    assert(NULL != p_rtn_ip);
+    assert(NULL != p_rtn_is6);
+    assert(NULL != p_txt);
+    /* 'p_rtn_is_valid' is allowed to be NULL */
+    #if (IP6_U32S_LN != 4u)
+    #error Unexpected IP6_U32S_LN value! If not '4', then check whether the 'tmp_ip' is large enough for IPv6 output of 'inet_pton()'!
+    #endif
+    
+    
+    int rtn = CLI_ERR;
+    bool tmp_is6 = false;
+    uint32_t tmp_ip[IP6_U32S_LN] = {0uL};
+    
+    /* convert from input */
+    if (1 == inet_pton(AF_INET, p_txt, tmp_ip))
+    {
+        tmp_is6 = false;
+        rtn = CLI_OK;
+    }
+    else if (1 == inet_pton(AF_INET6, p_txt, tmp_ip))
+    {
+        tmp_is6 = true;
+        rtn = CLI_OK;
+    }
+    else
+    {
+        rtn = CLI_ERR_INVARG;
+    }
+    
+    /* assign return data */
+    if (CLI_OK == rtn)
+    {
+        *p_rtn_is6 = tmp_is6;
+        
+        /* 'inet_pton()' returns in network order, but result of this fnc is expected in host order */
+        for (uint8_t i = 0u; (IP6_U32S_LN > i); (++i))
+        {
+            p_rtn_ip[i] = ntohl(tmp_ip[i]);
+        }
+    }
+    
+    return (rtn);
+}
+
+/* ==== PRIVATE FUNCTIONS : parsers ======================================== */
+
+static int cmd_parse(cli_cmd_t* p_rtn_cmd, const char* p_txt_cmd)
+{   
+    assert(NULL != p_rtn_cmd);
+    assert(NULL != p_txt_cmd);
+    
+    
+    int rtn = CLI_ERR;
+    cli_cmd_t tmp_cmd = CMD_00_NO_COMMAND;
+    
+    rtn = cli_cmd_txt2cmd(&tmp_cmd, p_txt_cmd);
+    
+    /* special case: possible opts-only invocation if following conditions fulfilled */
+    if ((CLI_ERR_INVCMD == rtn) && ('-' == p_txt_cmd[0]))
+    {
+        tmp_cmd = CMD_00_NO_COMMAND;
+        rtn = CLI_OK;  /* NOTE: rtn reset */
+    }
+    
+    /*  print error message if something went wrong  */
+    if (CLI_OK != rtn)
+    {
+        const char* p_txt_err = "";
+        switch (rtn)
+        {
+            case CLI_ERR_INVPTR:
+                p_txt_err = "Invalid pointer while parsing a command name.\n"
+                            "SERIOUS! NOTIFY A DEVELOPER!";
+            break;
+            
+            case CLI_ERR_INVCMD:
+                p_txt_err = "Unknown command.\n"
+                            "Use option '--help' to get a list of all available commands.";
+            break;
+            
+            default:
+                p_txt_err = "Something unexpected happened while parsing a command name.\n"
+                            "Check your input and try again. If the problem persists, notify a developer.";
+            break;
+        }
+        cli_print_error(rtn, p_txt_err);
+    }
+    
+    /* assign return data */
+    if (CLI_OK == rtn)
+    {
+        *p_rtn_cmd = tmp_cmd;
+    }
+    
+    return (rtn);
+}
+
+/* WARNING: argument 'p_txt_vec' must NOT be const, otherwise 'getopt()' fnc family will induce UB! */
+static int opts_parse(cli_cmdargs_t* p_rtn_cmdargs, char* p_txt_vec[], int vec_ln)
+{
+    assert(NULL != p_rtn_cmdargs);
+    assert(NULL != p_txt_vec);
+    
+    
+    int rtn = CLI_OK;  /* NOTE: initial OK is required for the 'getopt()' processing loop to start properly */
+    
+    memset(p_rtn_cmdargs, 0, sizeof(cli_cmdargs_t));
+    
+    const char* p_txt_opt = "__NOITEM__";
+    const char* p_txt_opt_addit = "";   /* WARNING: must be initiated by "" to prevent malformed error texts */
+    
+    /*
+        Ptr array for incompatibility checks of processed cli opt (see 'def_opts.h').
+        Each array element is a slot for one incompat grp.
+        When a cli opt from some incompat grp is encountered, a ptr to the opt's txt is stored in this array.
+        Then, if another cli opt from the same incompat grp is encountered, an error is raised and ptr is used for error message.
+    */
+    const char* txt_incompat_grps[OPT_GRP_LN] = {NULL};
+    
+    #if !defined(NDEBUG)
+    TEST_parser__p_txt_opt = NULL;
+    #endif
+    
+    /* glorious 'getopt()' processing */
+    int opt_code = 0;
+    const struct option* p_longopts = cli_get_longopts();
+    const char* p_txt_shortopts = cli_get_txt_shortopts();
+    optind = 1;  /* global var of 'getopt()' fnc family ; must be manually reset each time a new input txt vector is to be parsed */
+    while ((CLI_OK == rtn) && (-1 != opt_code))
+    {
+        const int optind_curr = optind;  /* store idx of the currently processed element, because 'getopt()' invocation will set optind as idx of the NEXT element */
+        p_txt_opt = (((optind_curr >= 1) && (optind_curr < vec_ln)) ? (p_txt_vec[optind_curr]) : "__INVIDX__");
+        
+        opt_code = getopt_long(vec_ln, p_txt_vec, p_txt_shortopts, p_longopts, NULL);
+        
+        #if !defined(NDEBUG)
+        TEST_parser__p_txt_opt = p_txt_opt;
+        #endif
+        
+        
+        /* 
+            special custom checks
+           
+            [1] Invalidate (mark as unknown) those input txt vector elements, which have valid shortopt syntax
+                but are longer than 2 characters. This is done to remove the possibility of erroneously interpreting
+                a longopt as multiple shortopts folded into one txt element.
+                Such a situation can happen by accident if there is only one leading '-' character in front of a longopt.
+               
+            [2] BUGFIX for a specific 'longopt()' corner case:
+                If the very last element of the input txt vector is a longopt which requires an argument,
+                and if by mistake no argument is supplied (no arg is present within the element itself),
+                then 'getopt()' sets its global 'optarg' ptr to point to some seemingly random address.
+                FIXED via bound-checking the 'optarg' destination address in case it is a non-NULL value when
+                      the very last element of the input txt vector is processed.
+        */
+        if ((NULL != p_txt_opt) && (-1 != opt_code))
+        {
+            const size_t ln = strlen(p_txt_opt);
+            
+            if ((2u < ln) && ('-' == p_txt_opt[0]) && ('-' != p_txt_opt[1]))
+            {
+                opt_code = '?';
+            }
+            
+            if ((NULL != optarg) && ((optind_curr + 1) >= vec_ln) && ((optarg < p_txt_opt) || (optarg > (p_txt_opt + ln))))
+            {
+                opt_code = ':';
+            }
+        }
+        
+        
+        /* incompatibility checks of processed cli opt */
+        if (-1 != opt_code)
+        {
+            uint32_t grps = cli_opt_get_incompat_grps(opt_code);
+            if (0uL != grps)
+            {
+                assert((CHAR_BIT * sizeof(uint32_t)) > OPT_GRP_LN);  /* to prevent potential UB */
+                for (uint32_t i = 0uL; (OPT_GRP_LN > i); (++i))
+                {
+                    if (grps & (1uL << i))
+                    {
+                        if (NULL != txt_incompat_grps[i])
+                        {
+                            p_txt_opt_addit = txt_incompat_grps[i];
+                            rtn = CLI_ERR_INCOMPATIBLE_OPTS;
+                        }
+                        else
+                        {
+                            txt_incompat_grps[i] = p_txt_opt;
+                            rtn = CLI_OK;
+                        }
+                    }
+                }
+            }
+        }
+        
+        /*
+            opt parsing
+            Parse fncs for particular opts are at the beginning of this source file.
+            Binding between OPT_xx_OPT_PARSE symbols and parse fncs is specified in 'def_opts.h'.
+            This code here should not need any modifications when a new opt is added...
+        */
+        if (CLI_OK == rtn)
+        {
+            switch (opt_code)
+            {
+              #ifdef OPT_01_ENUM_NAME
+                case OPT_01_ENUM_NAME:
+                    rtn = OPT_01_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_02_ENUM_NAME
+                case OPT_02_ENUM_NAME:
+                    rtn = OPT_02_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_03_ENUM_NAME
+                case OPT_03_ENUM_NAME:
+                    rtn = OPT_03_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_04_ENUM_NAME
+                case OPT_04_ENUM_NAME:
+                    rtn = OPT_04_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_05_ENUM_NAME
+                case OPT_05_ENUM_NAME:
+                    rtn = OPT_05_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_06_ENUM_NAME
+                case OPT_06_ENUM_NAME:
+                    rtn = OPT_06_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_07_ENUM_NAME
+                case OPT_07_ENUM_NAME:
+                    rtn = OPT_07_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_08_ENUM_NAME
+                case OPT_08_ENUM_NAME:
+                    rtn = OPT_08_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_09_ENUM_NAME
+                case OPT_09_ENUM_NAME:
+                    rtn = OPT_09_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+                
+              #ifdef OPT_10_ENUM_NAME
+                case OPT_10_ENUM_NAME:
+                    rtn = OPT_10_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_11_ENUM_NAME
+                case OPT_11_ENUM_NAME:
+                    rtn = OPT_11_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_12_ENUM_NAME
+                case OPT_12_ENUM_NAME:
+                    rtn = OPT_12_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_13_ENUM_NAME
+                case OPT_13_ENUM_NAME:
+                    rtn = OPT_13_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_14_ENUM_NAME
+                case OPT_14_ENUM_NAME:
+                    rtn = OPT_14_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_15_ENUM_NAME
+                case OPT_15_ENUM_NAME:
+                    rtn = OPT_15_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_16_ENUM_NAME
+                case OPT_16_ENUM_NAME:
+                    rtn = OPT_16_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_17_ENUM_NAME
+                case OPT_17_ENUM_NAME:
+                    rtn = OPT_17_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_18_ENUM_NAME
+                case OPT_18_ENUM_NAME:
+                    rtn = OPT_18_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_19_ENUM_NAME
+                case OPT_19_ENUM_NAME:
+                    rtn = OPT_19_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+                
+              #ifdef OPT_20_ENUM_NAME
+                case OPT_20_ENUM_NAME:
+                    rtn = OPT_20_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_21_ENUM_NAME
+                case OPT_21_ENUM_NAME:
+                    rtn = OPT_21_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_22_ENUM_NAME
+                case OPT_22_ENUM_NAME:
+                    rtn = OPT_22_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_23_ENUM_NAME
+                case OPT_23_ENUM_NAME:
+                    rtn = OPT_23_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_24_ENUM_NAME
+                case OPT_24_ENUM_NAME:
+                    rtn = OPT_24_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_25_ENUM_NAME
+                case OPT_25_ENUM_NAME:
+                    rtn = OPT_25_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_26_ENUM_NAME
+                case OPT_26_ENUM_NAME:
+                    rtn = OPT_26_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_27_ENUM_NAME
+                case OPT_27_ENUM_NAME:
+                    rtn = OPT_27_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_28_ENUM_NAME
+                case OPT_28_ENUM_NAME:
+                    rtn = OPT_28_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_29_ENUM_NAME
+                case OPT_29_ENUM_NAME:
+                    rtn = OPT_29_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+                
+              #ifdef OPT_30_ENUM_NAME
+                case OPT_30_ENUM_NAME:
+                    rtn = OPT_30_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_31_ENUM_NAME
+                case OPT_31_ENUM_NAME:
+                    rtn = OPT_31_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_32_ENUM_NAME
+                case OPT_32_ENUM_NAME:
+                    rtn = OPT_32_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_33_ENUM_NAME
+                case OPT_33_ENUM_NAME:
+                    rtn = OPT_33_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_34_ENUM_NAME
+                case OPT_34_ENUM_NAME:
+                    rtn = OPT_34_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_35_ENUM_NAME
+                case OPT_35_ENUM_NAME:
+                    rtn = OPT_35_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_36_ENUM_NAME
+                case OPT_36_ENUM_NAME:
+                    rtn = OPT_36_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_37_ENUM_NAME
+                case OPT_37_ENUM_NAME:
+                    rtn = OPT_37_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_38_ENUM_NAME
+                case OPT_38_ENUM_NAME:
+                    rtn = OPT_38_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_39_ENUM_NAME
+                case OPT_39_ENUM_NAME:
+                    rtn = OPT_39_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+                
+              #ifdef OPT_40_ENUM_NAME
+                case OPT_40_ENUM_NAME:
+                    rtn = OPT_40_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_41_ENUM_NAME
+                case OPT_41_ENUM_NAME:
+                    rtn = OPT_41_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_42_ENUM_NAME
+                case OPT_42_ENUM_NAME:
+                    rtn = OPT_42_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_43_ENUM_NAME
+                case OPT_43_ENUM_NAME:
+                    rtn = OPT_43_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_44_ENUM_NAME
+                case OPT_44_ENUM_NAME:
+                    rtn = OPT_44_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_45_ENUM_NAME
+                case OPT_45_ENUM_NAME:
+                    rtn = OPT_45_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_46_ENUM_NAME
+                case OPT_46_ENUM_NAME:
+                    rtn = OPT_46_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_47_ENUM_NAME
+                case OPT_47_ENUM_NAME:
+                    rtn = OPT_47_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_48_ENUM_NAME
+                case OPT_48_ENUM_NAME:
+                    rtn = OPT_48_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_49_ENUM_NAME
+                case OPT_49_ENUM_NAME:
+                    rtn = OPT_49_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+                
+              #ifdef OPT_50_ENUM_NAME
+                case OPT_50_ENUM_NAME:
+                    rtn = OPT_50_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_51_ENUM_NAME
+                case OPT_51_ENUM_NAME:
+                    rtn = OPT_51_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_52_ENUM_NAME
+                case OPT_52_ENUM_NAME:
+                    rtn = OPT_52_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_53_ENUM_NAME
+                case OPT_53_ENUM_NAME:
+                    rtn = OPT_53_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_54_ENUM_NAME
+                case OPT_54_ENUM_NAME:
+                    rtn = OPT_54_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_55_ENUM_NAME
+                case OPT_55_ENUM_NAME:
+                    rtn = OPT_55_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_56_ENUM_NAME
+                case OPT_56_ENUM_NAME:
+                    rtn = OPT_56_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_57_ENUM_NAME
+                case OPT_57_ENUM_NAME:
+                    rtn = OPT_57_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_58_ENUM_NAME
+                case OPT_58_ENUM_NAME:
+                    rtn = OPT_58_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_59_ENUM_NAME
+                case OPT_59_ENUM_NAME:
+                    rtn = OPT_59_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+                
+              #ifdef OPT_60_ENUM_NAME
+                case OPT_60_ENUM_NAME:
+                    rtn = OPT_60_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_61_ENUM_NAME
+                case OPT_61_ENUM_NAME:
+                    rtn = OPT_61_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_62_ENUM_NAME
+                case OPT_62_ENUM_NAME:
+                    rtn = OPT_62_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_63_ENUM_NAME
+                case OPT_63_ENUM_NAME:
+                    rtn = OPT_63_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_64_ENUM_NAME
+                case OPT_64_ENUM_NAME:
+                    rtn = OPT_64_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_65_ENUM_NAME
+                case OPT_65_ENUM_NAME:
+                    rtn = OPT_65_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_66_ENUM_NAME
+                case OPT_66_ENUM_NAME:
+                    rtn = OPT_66_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_67_ENUM_NAME
+                case OPT_67_ENUM_NAME:
+                    rtn = OPT_67_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_68_ENUM_NAME
+                case OPT_68_ENUM_NAME:
+                    rtn = OPT_68_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_69_ENUM_NAME
+                case OPT_69_ENUM_NAME:
+                    rtn = OPT_69_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+                
+              #ifdef OPT_70_ENUM_NAME
+                case OPT_70_ENUM_NAME:
+                    rtn = OPT_70_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_71_ENUM_NAME
+                case OPT_71_ENUM_NAME:
+                    rtn = OPT_71_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_72_ENUM_NAME
+                case OPT_72_ENUM_NAME:
+                    rtn = OPT_72_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_73_ENUM_NAME
+                case OPT_73_ENUM_NAME:
+                    rtn = OPT_73_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_74_ENUM_NAME
+                case OPT_74_ENUM_NAME:
+                    rtn = OPT_74_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_75_ENUM_NAME
+                case OPT_75_ENUM_NAME:
+                    rtn = OPT_75_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_76_ENUM_NAME
+                case OPT_76_ENUM_NAME:
+                    rtn = OPT_76_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_77_ENUM_NAME
+                case OPT_77_ENUM_NAME:
+                    rtn = OPT_77_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_78_ENUM_NAME
+                case OPT_78_ENUM_NAME:
+                    rtn = OPT_78_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_79_ENUM_NAME
+                case OPT_79_ENUM_NAME:
+                    rtn = OPT_79_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+                
+              #ifdef OPT_80_ENUM_NAME
+                case OPT_80_ENUM_NAME:
+                    rtn = OPT_80_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_81_ENUM_NAME
+                case OPT_81_ENUM_NAME:
+                    rtn = OPT_81_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_82_ENUM_NAME
+                case OPT_82_ENUM_NAME:
+                    rtn = OPT_82_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_83_ENUM_NAME
+                case OPT_83_ENUM_NAME:
+                    rtn = OPT_83_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_84_ENUM_NAME
+                case OPT_84_ENUM_NAME:
+                    rtn = OPT_84_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_85_ENUM_NAME
+                case OPT_85_ENUM_NAME:
+                    rtn = OPT_85_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_86_ENUM_NAME
+                case OPT_86_ENUM_NAME:
+                    rtn = OPT_86_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_87_ENUM_NAME
+                case OPT_87_ENUM_NAME:
+                    rtn = OPT_87_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_88_ENUM_NAME
+                case OPT_88_ENUM_NAME:
+                    rtn = OPT_88_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_89_ENUM_NAME
+                case OPT_89_ENUM_NAME:
+                    rtn = OPT_89_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+                
+              #ifdef OPT_90_ENUM_NAME
+                case OPT_90_ENUM_NAME:
+                    rtn = OPT_90_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_91_ENUM_NAME
+                case OPT_91_ENUM_NAME:
+                    rtn = OPT_91_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_92_ENUM_NAME
+                case OPT_92_ENUM_NAME:
+                    rtn = OPT_92_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_93_ENUM_NAME
+                case OPT_93_ENUM_NAME:
+                    rtn = OPT_93_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_94_ENUM_NAME
+                case OPT_94_ENUM_NAME:
+                    rtn = OPT_94_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_95_ENUM_NAME
+                case OPT_95_ENUM_NAME:
+                    rtn = OPT_95_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_96_ENUM_NAME
+                case OPT_96_ENUM_NAME:
+                    rtn = OPT_96_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_97_ENUM_NAME
+                case OPT_97_ENUM_NAME:
+                    rtn = OPT_97_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_98_ENUM_NAME
+                case OPT_98_ENUM_NAME:
+                    rtn = OPT_98_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_99_ENUM_NAME
+                case OPT_99_ENUM_NAME:
+                    rtn = OPT_99_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              
+              #ifdef OPT_100_ENUM_NAME
+                case OPT_100_ENUM_NAME:
+                    rtn = OPT_100_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif              
+              #ifdef OPT_101_ENUM_NAME
+                case OPT_101_ENUM_NAME:
+                    rtn = OPT_101_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_102_ENUM_NAME
+                case OPT_102_ENUM_NAME:
+                    rtn = OPT_102_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_103_ENUM_NAME
+                case OPT_103_ENUM_NAME:
+                    rtn = OPT_103_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_104_ENUM_NAME
+                case OPT_104_ENUM_NAME:
+                    rtn = OPT_104_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_105_ENUM_NAME
+                case OPT_105_ENUM_NAME:
+                    rtn = OPT_105_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_106_ENUM_NAME
+                case OPT_106_ENUM_NAME:
+                    rtn = OPT_106_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_107_ENUM_NAME
+                case OPT_107_ENUM_NAME:
+                    rtn = OPT_107_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_108_ENUM_NAME
+                case OPT_108_ENUM_NAME:
+                    rtn = OPT_108_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_109_ENUM_NAME
+                case OPT_109_ENUM_NAME:
+                    rtn = OPT_109_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+                
+              #ifdef OPT_110_ENUM_NAME
+                case OPT_110_ENUM_NAME:
+                    rtn = OPT_110_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_111_ENUM_NAME
+                case OPT_111_ENUM_NAME:
+                    rtn = OPT_111_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_112_ENUM_NAME
+                case OPT_112_ENUM_NAME:
+                    rtn = OPT_112_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_113_ENUM_NAME
+                case OPT_113_ENUM_NAME:
+                    rtn = OPT_113_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_114_ENUM_NAME
+                case OPT_114_ENUM_NAME:
+                    rtn = OPT_114_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_115_ENUM_NAME
+                case OPT_115_ENUM_NAME:
+                    rtn = OPT_115_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_116_ENUM_NAME
+                case OPT_116_ENUM_NAME:
+                    rtn = OPT_116_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_117_ENUM_NAME
+                case OPT_117_ENUM_NAME:
+                    rtn = OPT_117_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_118_ENUM_NAME
+                case OPT_118_ENUM_NAME:
+                    rtn = OPT_118_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_119_ENUM_NAME
+                case OPT_119_ENUM_NAME:
+                    rtn = OPT_119_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+                
+              #ifdef OPT_120_ENUM_NAME
+                case OPT_120_ENUM_NAME:
+                    rtn = OPT_120_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_121_ENUM_NAME
+                case OPT_121_ENUM_NAME:
+                    rtn = OPT_121_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_122_ENUM_NAME
+                case OPT_122_ENUM_NAME:
+                    rtn = OPT_122_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_123_ENUM_NAME
+                case OPT_123_ENUM_NAME:
+                    rtn = OPT_123_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_124_ENUM_NAME
+                case OPT_124_ENUM_NAME:
+                    rtn = OPT_124_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_125_ENUM_NAME
+                case OPT_125_ENUM_NAME:
+                    rtn = OPT_125_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_126_ENUM_NAME
+                case OPT_126_ENUM_NAME:
+                    rtn = OPT_126_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_127_ENUM_NAME
+                case OPT_127_ENUM_NAME:
+                    rtn = OPT_127_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_128_ENUM_NAME
+                case OPT_128_ENUM_NAME:
+                    rtn = OPT_128_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_129_ENUM_NAME
+                case OPT_129_ENUM_NAME:
+                    rtn = OPT_129_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+                
+              #ifdef OPT_130_ENUM_NAME
+                case OPT_130_ENUM_NAME:
+                    rtn = OPT_130_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_131_ENUM_NAME
+                case OPT_131_ENUM_NAME:
+                    rtn = OPT_131_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_132_ENUM_NAME
+                case OPT_132_ENUM_NAME:
+                    rtn = OPT_132_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_133_ENUM_NAME
+                case OPT_133_ENUM_NAME:
+                    rtn = OPT_133_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_134_ENUM_NAME
+                case OPT_134_ENUM_NAME:
+                    rtn = OPT_134_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_135_ENUM_NAME
+                case OPT_135_ENUM_NAME:
+                    rtn = OPT_135_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_136_ENUM_NAME
+                case OPT_136_ENUM_NAME:
+                    rtn = OPT_136_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_137_ENUM_NAME
+                case OPT_137_ENUM_NAME:
+                    rtn = OPT_137_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_138_ENUM_NAME
+                case OPT_138_ENUM_NAME:
+                    rtn = OPT_138_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_139_ENUM_NAME
+                case OPT_139_ENUM_NAME:
+                    rtn = OPT_139_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+                
+              #ifdef OPT_140_ENUM_NAME
+                case OPT_140_ENUM_NAME:
+                    rtn = OPT_140_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_141_ENUM_NAME
+                case OPT_141_ENUM_NAME:
+                    rtn = OPT_141_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_142_ENUM_NAME
+                case OPT_142_ENUM_NAME:
+                    rtn = OPT_142_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_143_ENUM_NAME
+                case OPT_143_ENUM_NAME:
+                    rtn = OPT_143_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_144_ENUM_NAME
+                case OPT_144_ENUM_NAME:
+                    rtn = OPT_144_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_145_ENUM_NAME
+                case OPT_145_ENUM_NAME:
+                    rtn = OPT_145_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_146_ENUM_NAME
+                case OPT_146_ENUM_NAME:
+                    rtn = OPT_146_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_147_ENUM_NAME
+                case OPT_147_ENUM_NAME:
+                    rtn = OPT_147_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_148_ENUM_NAME
+                case OPT_148_ENUM_NAME:
+                    rtn = OPT_148_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_149_ENUM_NAME
+                case OPT_149_ENUM_NAME:
+                    rtn = OPT_149_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+                
+              #ifdef OPT_150_ENUM_NAME
+                case OPT_150_ENUM_NAME:
+                    rtn = OPT_150_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_151_ENUM_NAME
+                case OPT_151_ENUM_NAME:
+                    rtn = OPT_151_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_152_ENUM_NAME
+                case OPT_152_ENUM_NAME:
+                    rtn = OPT_152_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_153_ENUM_NAME
+                case OPT_153_ENUM_NAME:
+                    rtn = OPT_153_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_154_ENUM_NAME
+                case OPT_154_ENUM_NAME:
+                    rtn = OPT_154_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_155_ENUM_NAME
+                case OPT_155_ENUM_NAME:
+                    rtn = OPT_155_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_156_ENUM_NAME
+                case OPT_156_ENUM_NAME:
+                    rtn = OPT_156_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_157_ENUM_NAME
+                case OPT_157_ENUM_NAME:
+                    rtn = OPT_157_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_158_ENUM_NAME
+                case OPT_158_ENUM_NAME:
+                    rtn = OPT_158_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_159_ENUM_NAME
+                case OPT_159_ENUM_NAME:
+                    rtn = OPT_159_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+                
+              #ifdef OPT_160_ENUM_NAME
+                case OPT_160_ENUM_NAME:
+                    rtn = OPT_160_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_161_ENUM_NAME
+                case OPT_161_ENUM_NAME:
+                    rtn = OPT_161_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_162_ENUM_NAME
+                case OPT_162_ENUM_NAME:
+                    rtn = OPT_162_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_163_ENUM_NAME
+                case OPT_163_ENUM_NAME:
+                    rtn = OPT_163_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_164_ENUM_NAME
+                case OPT_164_ENUM_NAME:
+                    rtn = OPT_164_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_165_ENUM_NAME
+                case OPT_165_ENUM_NAME:
+                    rtn = OPT_165_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_166_ENUM_NAME
+                case OPT_166_ENUM_NAME:
+                    rtn = OPT_166_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_167_ENUM_NAME
+                case OPT_167_ENUM_NAME:
+                    rtn = OPT_167_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_168_ENUM_NAME
+                case OPT_168_ENUM_NAME:
+                    rtn = OPT_168_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_169_ENUM_NAME
+                case OPT_169_ENUM_NAME:
+                    rtn = OPT_169_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+                
+              #ifdef OPT_170_ENUM_NAME
+                case OPT_170_ENUM_NAME:
+                    rtn = OPT_170_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_171_ENUM_NAME
+                case OPT_171_ENUM_NAME:
+                    rtn = OPT_171_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_172_ENUM_NAME
+                case OPT_172_ENUM_NAME:
+                    rtn = OPT_172_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_173_ENUM_NAME
+                case OPT_173_ENUM_NAME:
+                    rtn = OPT_173_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_174_ENUM_NAME
+                case OPT_174_ENUM_NAME:
+                    rtn = OPT_174_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_175_ENUM_NAME
+                case OPT_175_ENUM_NAME:
+                    rtn = OPT_175_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_176_ENUM_NAME
+                case OPT_176_ENUM_NAME:
+                    rtn = OPT_176_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_177_ENUM_NAME
+                case OPT_177_ENUM_NAME:
+                    rtn = OPT_177_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_178_ENUM_NAME
+                case OPT_178_ENUM_NAME:
+                    rtn = OPT_178_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_179_ENUM_NAME
+                case OPT_179_ENUM_NAME:
+                    rtn = OPT_179_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+                
+              #ifdef OPT_180_ENUM_NAME
+                case OPT_180_ENUM_NAME:
+                    rtn = OPT_180_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_181_ENUM_NAME
+                case OPT_181_ENUM_NAME:
+                    rtn = OPT_181_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_182_ENUM_NAME
+                case OPT_182_ENUM_NAME:
+                    rtn = OPT_182_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_183_ENUM_NAME
+                case OPT_183_ENUM_NAME:
+                    rtn = OPT_183_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_184_ENUM_NAME
+                case OPT_184_ENUM_NAME:
+                    rtn = OPT_184_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_185_ENUM_NAME
+                case OPT_185_ENUM_NAME:
+                    rtn = OPT_185_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_186_ENUM_NAME
+                case OPT_186_ENUM_NAME:
+                    rtn = OPT_186_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_187_ENUM_NAME
+                case OPT_187_ENUM_NAME:
+                    rtn = OPT_187_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_188_ENUM_NAME
+                case OPT_188_ENUM_NAME:
+                    rtn = OPT_188_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_189_ENUM_NAME
+                case OPT_189_ENUM_NAME:
+                    rtn = OPT_189_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+                
+              #ifdef OPT_190_ENUM_NAME
+                case OPT_190_ENUM_NAME:
+                    rtn = OPT_190_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_191_ENUM_NAME
+                case OPT_191_ENUM_NAME:
+                    rtn = OPT_191_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_192_ENUM_NAME
+                case OPT_192_ENUM_NAME:
+                    rtn = OPT_192_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_193_ENUM_NAME
+                case OPT_193_ENUM_NAME:
+                    rtn = OPT_193_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_194_ENUM_NAME
+                case OPT_194_ENUM_NAME:
+                    rtn = OPT_194_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_195_ENUM_NAME
+                case OPT_195_ENUM_NAME:
+                    rtn = OPT_195_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_196_ENUM_NAME
+                case OPT_196_ENUM_NAME:
+                    rtn = OPT_196_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_197_ENUM_NAME
+                case OPT_197_ENUM_NAME:
+                    rtn = OPT_197_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_198_ENUM_NAME
+                case OPT_198_ENUM_NAME:
+                    rtn = OPT_198_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+              #ifdef OPT_199_ENUM_NAME
+                case OPT_199_ENUM_NAME:
+                    rtn = OPT_199_OPT_PARSE (p_rtn_cmdargs, optarg);
+                break;
+              #endif
+                
+                case -1:  /* parsing is finished */
+                    /* empty */
+                break;
+                
+                case ':':  /* missing argument */
+                    rtn = CLI_ERR_INVARG;
+                break;
+                
+                case '?':  /* unknown or invalid option */
+                    rtn = CLI_ERR_INVOPT;
+                break;
+                
+                default:
+                    rtn = CLI_ERR;
+                break;
+            }
+        }
+    }
+    
+    /* raise error if there are some non-opt elements left in the 'pa_txt_vec' */
+    /* such non-opt elements are often in fact opts, which are (by input mistake) missing the leading '-' or '--' */
+    if ((CLI_OK == rtn) && (optind < vec_ln))
+    {
+        p_txt_opt = p_txt_vec[optind];
+        p_txt_opt_addit = "";
+        rtn = CLI_ERR_NONOPT;
+    }
+    
+    /* reset 'getopt()' fnc family internal static variables (do not hide behind rtn check) */
+    /* WARNING: This hack is crucial in order to ensure that 'getopt()' fnc family behaves correctly each time new input txt vector is scanned. */
+    while(-1 != getopt_long(vec_ln, p_txt_vec, p_txt_shortopts, p_longopts, NULL)) { /* empty */ };
+
+    /*  print error message if something went wrong  */
+    if (CLI_OK != rtn)
+    {  
+        const char* p_txt_err = "";
+        switch (rtn)
+        {
+            case CLI_ERR_INVPTR:
+                p_txt_err = "Invalid pointer while parsing the option '%s%s'.\n"
+                            "SERIOUS! NOTIFY A DEVELOPER!";
+            break;
+            
+            case CLI_ERR_INVOPT:
+                p_txt_err = "Unknown option '%s%s'. (maybe check leading '-' or '--'?)\n"
+                            "Use '<command> --help' to get a detailed info (and a list of valid options) for the given command.";
+            break;
+            
+            case CLI_ERR_INVARG:
+                p_txt_err = "Invalid or missing argument(s) for the option '%s%s'.\n"
+                            "If not missing, then maybe wrong upper/lower case? Or something too small/large/long?";
+            break;
+            
+            case CLI_ERR_NONOPT:
+                p_txt_err = "Non-option argument '%s%s' detected. (maybe it's just missing the '-' or '--'?)";
+            break;
+            
+            case CLI_ERR_INCOMPATIBLE_OPTS:
+                p_txt_err = "Options '%s' and '%s' cannot be used at the same time.";
+            break;
+            
+            default:
+                p_txt_err = "Something unexpected happened while parsing the option '%s%s'.\n"
+                            "Check your input and try again. If the problem persists, notify a developer.";
+            break;
+        }
+        cli_print_error(rtn, p_txt_err, p_txt_opt, p_txt_opt_addit);
+    }
+    
+    /* just for debug/test purposes; this call passes 'cmdargs' data to unit tests */
+    #if !defined(NDEBUG)
+    cli_cmd_execute(CMD_00_NO_COMMAND, p_rtn_cmdargs);
+    #endif
+    
+    return (rtn);
+}
+
+static int cmd_execute(cli_cmd_t cmd, const cli_cmdargs_t* p_cmdargs)
+{
+    assert(NULL != p_cmdargs);
+    
+    
+    int rtn = CLI_ERR;
+    
+    /* NOTE: The situation 'app started with no cli arguments' is NOT HANDLED HERE (probably handled in main()) */
+    /*       That is intentional. It allows this fnc to handle session mode if needed (no input == do nothing) */
+    if ((CMD_00_NO_COMMAND == cmd) && (p_cmdargs->version.is_valid))
+    {
+        cli_print_app_version();
+        rtn = CLI_OK;
+    }
+    else if (p_cmdargs->help.is_valid)
+    {
+        /* special execution path for help texts */
+        if ((CMD_00_NO_COMMAND == cmd) && (p_cmdargs->verbose.is_valid))
+        {
+            /* print all help texts (Great Wall of text ^_^) */
+            cli_print_app_version();
+            for (uint16_t i = 0u; (CMD_LN > i); (++i))
+            {
+                cli_print_help(i);
+            }
+        }
+        else
+        {
+            /* print help text for a particular command */
+            cli_print_help(cmd);    
+        }
+        rtn = CLI_OK;
+    }
+    else
+    {
+        /* standard execution path */
+        rtn = cli_cmd_execute(cmd, p_cmdargs);
+    }
+    
+    /* print error message if something went wrong */
+    if (CLI_OK != rtn)
+    {
+        const char* p_txt_err = "";
+        bool do_mandopt_print = false;
+        switch (rtn)
+        {
+            /* errors of the libFCI_cli app */
+            
+            case CLI_ERR_INVPTR:
+                p_txt_err = "Invalid pointer during execution of the command.\n"
+                            "SERIOUS! NOTIFY A DEVELOPER!";
+            break;
+            
+            case CLI_ERR_INVCMD:
+                p_txt_err = "Unknown command (execution stage)."
+                            "\nSERIOUS! NOTIFY A DEVELOPER!";
+            break;
+            
+            case CLI_ERR_INVARG:
+                p_txt_err = "Invalid argument of some option.\n"
+                            "Use '<command> --help' to get a detailed info (and a list of valid options) for the given command.";
+            break;
+            
+            case CLI_ERR_MISSING_MANDOPT:
+                /* NOTE: This error code utilizes a mandopt feature to print extra info (missing opts) */
+                p_txt_err = "Command is missing the following mandatory options:";
+                do_mandopt_print = true;
+            break;
+            
+            case CLI_ERR_WRONG_IP_TYPE:
+                if (CMD_LOGIF_UPDATE == cmd)
+                {
+                    p_txt_err = "Wrong IP address type (IPv4/IPv6) as an argument of some option. Check the following:\n"
+                                "  --> ("  TXT_HELP__SIP  ") and ("  TXT_HELP__DIP  ") accept only IPv4 argument.\n"
+                                "  --> ("  TXT_HELP__SIP6  ") and ("  TXT_HELP__DIP6  ") accept only IPv6 argument.\n";
+                }
+                else
+                {
+                    p_txt_err = "Wrong IP address type (IPv4/IPv6) as an argument of some option.";
+                }
+            break;
+            
+            case CLI_ERR_INCOMPATIBLE_IPS:
+                p_txt_err = "Incompatible IP addresses.\n"
+                            "All IP addresses must be of a same type - either all IPv4, or all IPv6.";
+            break;
+            
+            /* errors of the libFCI library */
+            
+            case FPP_ERR_IF_ENTRY_ALREADY_REGISTERED:
+                p_txt_err = "Requested interface name is already registered.";
+            break;
+            
+            case FPP_ERR_IF_ENTRY_NOT_FOUND:
+                p_txt_err = "Requested target/parent/mirror interface not found.\n"
+                            "Is the target/parent/mirror name correct?\n"
+                            "Does the target/parent/mirror interface exist?";
+            break;
+            
+            case FPP_ERR_L2_BD_ALREADY_REGISTERED:
+                p_txt_err = "Requested bridge domain is already registered.";
+            break;
+            
+            case FPP_ERR_L2_BD_NOT_FOUND:
+                p_txt_err = "Requested bridge domain not found.\n"
+                            "Is the VLAN ID correct?";
+            break;
+            
+            case FPP_ERR_L2_STATIC_ENT_ALREADY_REGISTERED:
+                p_txt_err = "Requested static entry is already registered.";
+            break;
+            
+            case FPP_ERR_L2_STATIC_EN_NOT_FOUND:
+                p_txt_err = "Requested static entry not found.\n"
+                            "Is the VLAN ID correct?\n"
+                            "Is the MAC correct?";
+            break;
+            
+            case FPP_ERR_IF_MATCH_UPDATE_FAILED:
+                p_txt_err = "Failed to update logical interface match rules. Maybe incompatible versions of libFCI and driver?";
+            break;
+            
+            case FPP_ERR_RT_ENTRY_ALREADY_REGISTERED:
+                p_txt_err = "Requested route is already registered.";
+            break;
+            
+            case FPP_ERR_RT_ENTRY_NOT_FOUND:
+                p_txt_err = "Requested route not found.\n"
+                            "Is the route ID correct?";
+            break;
+            
+            case FPP_ERR_CT_ENTRY_NOT_FOUND:
+                p_txt_err = "Requested conntrack not found.\n"
+                            "Are all options filled correctly?";
+            break;
+            
+            case (-2):
+                if (CMD_LOGIF_UPDATE == cmd)
+                {
+                    p_txt_err = "If there was an attempt to set FP_TABLE0 or FP_TABLE1, then no FP table of the given name was found.\n"
+                                "If no such attempt was made, then something unexpected happened during execution of the command.";
+                }
+                else if (CMD_LOGIF_DEL == cmd)
+                {
+                    p_txt_err = "No interface of the given name was found.";
+                }
+                else
+                {
+                    p_txt_err = "Something unexpected happened during execution of the command.\n"
+                                "Check your input and try again. If the problem persists, notify a developer.";
+                }
+            break;
+            
+            default:
+                p_txt_err = "Something unexpected happened during execution of the command.\n"
+                            "Check your input and try again. If the problem persists, notify a developer.";
+            break;
+        }
+        cli_print_error(rtn, "%s", p_txt_err);
+        
+        if (do_mandopt_print)
+        {
+            cli_mandopt_print("  or  ");
+            cli_mandopt_clear();
+        }
+    }
+    
+    /* print confirmation message if all OK */
+    if (CLI_OK == rtn)
+    {
+        printf("Command successfully executed.\n");
+    }
+    
+    return (rtn);
+}
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+void cli_print_app_version(void)
+{
+    printf("app version: "  LIBFCI_CLI_VERSION
+           " ("  PFE_CT_H_MD5  " ; "  GLOBAL_VERSION_CONTROL_ID  " ; "  __DATE__ " "  __TIME__  ")"
+           " ["  LIBFCI_CLI_TARGET_OS  "]\n");
+}
+
+/* NOTE: argument 'p_txt_vec' is expected to follow the argv convention (element [0] exists, but fnc ignores it) */
+/* WARNING: argument 'p_txt_vec' must NOT be const, otherwise 'getopt()' fnc family induces UB! */
+int cli_parse_and_execute(char* p_txt_vec[], int vec_ln)
+{
+    int rtn = CLI_ERR;
+    cli_cmd_t cmd = CMD_00_NO_COMMAND;
+    cli_cmdargs_t cmdargs = {0};
+    
+    #if !defined(NDEBUG)
+    TEST_parser__cmd4exec = CMD_LN;
+    #endif
+    
+    /* always check 'p_txt_vec' and its elements; it can originate outside of this app and thus cannnot be trusted */
+    if (0 > vec_ln)
+    {
+        rtn = CLI_ERR;
+        cli_print_error(rtn, "Negative length of the input text vector (vec_ln=%d).", vec_ln);
+    }
+    else if (NULL == p_txt_vec)
+    {
+        rtn = CLI_ERR_INVPTR;
+        cli_print_error(rtn, "Invalid pointer to the input text vector.");
+    }
+    else
+    {
+        /* check input text vector for any potential NULL elements */
+        int i = -1;
+        while((vec_ln > (++i)) && (NULL != p_txt_vec[i])) { /* empty */ };
+        if (vec_ln > i)
+        {
+            rtn = CLI_ERR_INVPTR;
+            cli_print_error(rtn, "Invalid pointer within the input text vector (element [%d]).", i);
+        }
+        else
+        {
+            rtn = CLI_OK;  /* greenlight execution of the next sub-block */
+        }
+    }
+    
+    /* further inspection is allowed only if input txt vector sufficiently long */
+    if (2 <= vec_ln)
+    {
+        /* cmd */
+        if ((CLI_OK == rtn))
+        {
+            rtn = cmd_parse(&cmd, p_txt_vec[1]);  /* element [1] assumed to be a cmd (usually it is) */
+        }
+        
+        /* cmdargs from opts */
+        if ((CLI_OK == rtn))
+        {
+            /*
+                NOTE: Following 'if' statement is a workaround to ignore a cmd element, if it exists.
+                      Implemented because some 'getopt()' fnc family implementations
+                      wrongly adhere to strict POSIX behavior as the default one.
+            */
+            if (CMD_00_NO_COMMAND != cmd)
+            {
+                vec_ln--;
+                p_txt_vec++;
+            }
+            
+            rtn = opts_parse(&cmdargs, p_txt_vec, vec_ln);
+        }
+        
+        /* execute */
+        if (CLI_OK == rtn)
+        {   
+            rtn = cmd_execute(cmd, &cmdargs);
+            
+            #if !defined(NDEBUG)
+            TEST_parser__cmd4exec = cmd;
+            #endif
+        }
+    }
+
+    return (rtn);
+}
+
+/* ==== TESTMODE constants ================================================= */
+
+#if !defined(NDEBUG)
+/* empty */
+#endif
+
+/* ========================================================================= */
diff --git a/sw/libfci_cli/src/libfci_cli_parser.h b/sw/libfci_cli/src/libfci_cli_parser.h
new file mode 100644
index 0000000..88b1f0a
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_parser.h
@@ -0,0 +1,27 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef LIBFCI_CLI_PARSER_H_
+#define LIBFCI_CLI_PARSER_H_
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+void cli_print_app_version(void);
+
+int cli_parse_and_execute(char* pp_txtarr[], int arrln);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_cli_print_helpers.c b/sw/libfci_cli/src/libfci_cli_print_helpers.c
new file mode 100644
index 0000000..e1d52f0
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_print_helpers.c
@@ -0,0 +1,137 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#include <assert.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include "libfci_cli_print_helpers.h"
+
+/* ==== TESTMODE vars ====================================================== */
+
+#if !defined(NDEBUG)
+/* empty */
+#endif
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+void cli_print_bitset32(uint32_t bitset, const char* p_txt_delim, const char* (*p_value2txt)(uint8_t value),
+                        const char* p_txt_nothing_found)
+{
+    assert(NULL != p_txt_delim);
+    assert(NULL != p_value2txt);
+    assert(NULL != p_txt_nothing_found);
+    
+    
+    if (0uL == bitset)
+    {
+        printf("%s", p_txt_nothing_found);
+    }
+    else
+    {
+        const char* p_txt_tmp = "";  /* there should be no delimiter in front of the very first item */
+        for(uint8_t i = 0u; (32u > i); (++i))
+        {
+            if (bitset & (1uL << i))
+            {
+                printf("%s%s", p_txt_tmp, p_value2txt(i));
+                p_txt_tmp = p_txt_delim;
+            }
+        }
+    }
+}
+
+void cli_print_tablenames(const char (*p_tablenames)[TABLE_NAME_TXT_LN], const uint8_t tablenames_ln,
+                          const char* p_txt_delim, const char* p_txt_nothing_found)
+{
+    assert(NULL != p_tablenames);
+    assert(NULL != p_txt_delim);
+    assert(NULL != p_txt_nothing_found);
+    
+    
+    bool nothing_found = true;
+    const char* p_txt_tmp = "";  /* there should be no delimiter in front of the very first item */
+    for (uint8_t i = 0u; (tablenames_ln > i); (++i))
+    {
+        if ((NULL != p_tablenames[i]) && ('\0' != p_tablenames[i][0]))
+        {
+            printf("%s%s", p_txt_tmp, p_tablenames[i]);
+            p_txt_tmp = p_txt_delim;
+            nothing_found = false;
+        }
+    }
+    
+    if (nothing_found)
+    {
+        printf("%s", p_txt_nothing_found);
+    }
+}
+
+void cli_print_mac(const uint8_t* p_mac)
+{
+    assert(NULL != p_mac);
+    #if (MAC_BYTES_LN != 6u)
+    #error Unexpected MAC_BYTES_LN value! If not '6', then change 'printf()' parameters accordingly!
+    #endif
+    
+    
+    printf("%02"PRIx8  ":%02"PRIx8  ":%02"PRIx8  ":%02"PRIx8  ":%02"PRIx8  ":%02"PRIx8,
+           p_mac[0], p_mac[1], p_mac[2], p_mac[3], p_mac[4], p_mac[5]);
+}
+
+void cli_print_ip4(uint32_t ip4, bool is_fixed_width)
+{    
+    /* WARNING: little endian assumed */
+    const uint8_t* p = (const uint8_t*)(&ip4);
+    int padding = 0;  /* NOTE: native data type to comply with 'printf()' conventions (asterisk specifier) */
+    if (is_fixed_width)
+    {
+        for (uint8_t i = 0u; ((sizeof(uint32_t)) > i); (++i))
+        {
+            padding += ((10 > p[i]) ? (2) :
+                       ((100 > p[i]) ? (1) : 0));
+        }
+    }
+    
+    printf("%"PRIu8  ".%"PRIu8  ".%"PRIu8  ".%"PRIu8  "%-*s",
+           p[3], p[2], p[1], p[0], padding, "");
+}
+
+void cli_print_ip6(const uint32_t *p_ip6)
+{
+    assert(NULL != p_ip6);
+    #if (IP6_U32S_LN != 4u)
+    #error Unexpected IP6_U32S_LN value! If not '4', then change 'printf()' parameters accordingly!
+    #endif
+    
+    
+    /* WARNING: little endian assumed */
+    const uint8_t* p = (const uint8_t*)(p_ip6);
+    printf("%02"PRIx8  "%02"PRIx8  ":%02"PRIx8  "%02"PRIx8 ":"
+           "%02"PRIx8  "%02"PRIx8  ":%02"PRIx8  "%02"PRIx8 ":"
+           "%02"PRIx8  "%02"PRIx8  ":%02"PRIx8  "%02"PRIx8 ":"
+           "%02"PRIx8  "%02"PRIx8  ":%02"PRIx8  "%02"PRIx8,
+           p[3] , p[2] , p[1] , p[0],
+           p[7] , p[6] , p[5] , p[4],
+           p[11], p[10], p[9] , p[8],
+           p[15], p[14], p[13], p[12]);
+}
+
+/* ==== TESTMODE constants ================================================= */
+
+#if !defined(NDEBUG)
+/* empty */
+#endif
+
+/* ========================================================================= */
diff --git a/sw/libfci_cli/src/libfci_cli_print_helpers.h b/sw/libfci_cli/src/libfci_cli_print_helpers.h
new file mode 100644
index 0000000..0864959
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_print_helpers.h
@@ -0,0 +1,34 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef CLI_PRINT_HELPERS_H_
+#define CLI_PRINT_HELPERS_H_
+
+#include <stdint.h>
+#include "libfci_cli_common.h"
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+void cli_print_bitset32(uint32_t bitset, const char* p_txt_delim, const char* (*p_value2txt)(uint8_t value),
+                        const char* p_txt_nothing_found);
+void cli_print_tablenames(const char (*p_tablenames)[TABLE_NAME_TXT_LN], const uint8_t tablenames_ln,
+                          const char* p_txt_delim, const char* p_txt_nothing_found);
+void cli_print_mac(const uint8_t* p_mac);
+void cli_print_ip4(uint32_t ip4, bool is_fixed_width);
+void cli_print_ip6(const uint32_t* p_ip6);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_interface/fci_common.c b/sw/libfci_cli/src/libfci_interface/fci_common.c
new file mode 100644
index 0000000..e515121
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_interface/fci_common.c
@@ -0,0 +1,162 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <string.h>
+#include <stddef.h>
+#include <arpa/inet.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+#include "fci_common.h"
+ 
+ 
+/* ==== PUBLIC FUNCTIONS =================================================== */
+ 
+ 
+/*
+ * @brief          Network-to-host (ntoh) function for enum datatypes.
+ * @param[in,out]  p_rtn  The value which is to be converted to the host byte order.
+ * @param[in]      size   Size of the value datatype (in bytes).
+ */
+void ntoh_enum(void* p_rtn, size_t size)
+{
+    assert(NULL != p_rtn);
+    
+    switch (size)
+    {
+        case (sizeof(uint16_t)):
+            *((uint16_t*)p_rtn) = ntohs(*((uint16_t*)p_rtn));
+        break;
+        
+        case (sizeof(uint32_t)):
+            *((uint32_t*)p_rtn) = ntohl(*((uint32_t*)p_rtn));
+        break;
+        
+        default:
+            /* do nothing ; 'uint8_t' falls into this category as well */
+        break;
+    }
+}
+ 
+ 
+/*
+ * @brief          Host-to-network (hton) function for enum datatypes.
+ * @param[in,out]  p_rtn  The value which is to be converted to the network byte order.
+ * @param[in]      size   Size of the value datatype (in bytes).
+ */
+void hton_enum(void* p_rtn, size_t size)
+{
+    assert(NULL != p_rtn);
+    
+    switch (size)
+    {
+        case (sizeof(uint16_t)):
+            *((uint16_t*)p_rtn) = htons(*((uint16_t*)p_rtn));
+        break;
+        
+        case (sizeof(uint32_t)):
+            *((uint32_t*)p_rtn) = htonl(*((uint32_t*)p_rtn));
+        break;
+        
+        default:
+            /* do nothing ; 'uint8_t' falls into this category as well */
+        break;
+    }
+}
+ 
+ 
+/*
+ * @brief       Check and set text
+ * @param[out]  p_dst   Destination text array (to be modified).
+ * @param[in]   p_src   Source text array.
+ *                      Can be NULL or empty (""). If NULL or empty, then
+ *                      the destination text array is zeroed.
+ * @param[in]   dst_ln  Size of the destination text array.
+ * @return      FPP_ERR_OK : Function executed successfully.
+ *              other      : Some error occured (represented by the respective error code).
+ */
+int set_text(char* p_dst, const char* p_src, const uint_fast16_t dst_ln)
+{
+    assert(NULL != p_dst);
+    assert(0u != dst_ln);
+    /* 'p_src' is allowed to be NULL */
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    if ((NULL == p_src) || ('\0' == p_src[0]))
+    {
+        /* zeroify dst */
+        memset(p_dst, 0, dst_ln);
+        rtn = FPP_ERR_OK;
+    }
+    else if ((strlen(p_src) + 1u) > dst_ln)
+    {
+        rtn = FPP_ERR_FCI_INVTXTLN;
+    }
+    else
+    {
+        /* set dst */
+        strncpy(p_dst, p_src, dst_ln);
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Lock the interface database for exclusive access by this FCI client.
+ * @details    The interface database is stored in the PFE.
+ *             For details, see FCI API Reference, description of FPP_CMD_IF_LOCK_SESSION.
+ * @param[in]  p_cl  FCI client instance
+ * @return     FPP_ERR_OK : Lock successful
+ *             other      : Lock not successful
+ */
+int fci_if_session_lock(FCI_CLIENT* p_cl)
+{
+    assert(NULL != p_cl);
+    return fci_write(p_cl, FPP_CMD_IF_LOCK_SESSION, 0u, NULL);
+}
+ 
+ 
+/*
+ * @brief      Unlock the interface database's exclusive access lock.
+ * @param[in]  p_cl  FCI client instance
+ * @param[in]  rtn   Caller's current return value
+ * @return     If caller provides NON-ZERO rtn, then 
+ *             this function returns the provided rtn value.
+ *             If caller provides ZERO rtn, then return values are:
+ *             FPP_ERR_OK : Unlock successful
+ *             other      : Unlock not successful
+ */
+int fci_if_session_unlock(FCI_CLIENT* p_cl, int rtn)
+{
+    assert(NULL != p_cl);
+    
+    
+    int rtn_unlock = fci_write(p_cl, FPP_CMD_IF_UNLOCK_SESSION, 0u, NULL);    
+    rtn = ((FPP_ERR_OK == rtn) ? (rtn_unlock) : (rtn));
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_interface/fci_common.h b/sw/libfci_cli/src/libfci_interface/fci_common.h
new file mode 100644
index 0000000..7fd221e
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_interface/fci_common.h
@@ -0,0 +1,41 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef FCI_COMMON_H_
+#define FCI_COMMON_H_
+
+#include <stdint.h>
+#include "libfci.h"
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+/* return codes (extends libfci 'FPP_ERR_' return code family) */
+#define FPP_ERR_FCI           (-1101)
+#define FPP_ERR_FCI_INVPTR    (-1102)
+#define FPP_ERR_FCI_INVTXTLN  (-1103)
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+void ntoh_enum(void* p_rtn, size_t size);
+void hton_enum(void* p_rtn, size_t size);
+
+int set_text(char* p_dst, const char* p_src, const uint_fast16_t dst_ln);
+
+int fci_if_session_lock(FCI_CLIENT* p_cl);
+int fci_if_session_unlock(FCI_CLIENT* p_cl, int rtn);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_interface/fci_ep.c b/sw/libfci_cli/src/libfci_interface/fci_ep.c
new file mode 100644
index 0000000..6132efb
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_interface/fci_ep.c
@@ -0,0 +1,72 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <string.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+#include "fci_common.h"
+#include "fci_ep.h"
+ 
+ 
+/* ==== PUBLIC FUNCTIONS =================================================== */
+ 
+ 
+/*
+ * @brief       Open connection to an FCI endpoint as a command-mode FCI client.
+ * @details     Command-mode client can send FCI commands.
+ * @param[out]  pp_rtn_cl  The newly created FCI client.
+ * @return      FPP_ERR_OK : The FCI client was successfully created.
+ *              other      : Failed to create the FCI client.
+ */
+int fci_ep_open_in_cmd_mode(FCI_CLIENT** pp_rtn_cl)
+{  
+    assert(NULL != pp_rtn_cl);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    FCI_CLIENT* p_cl = fci_open(FCI_CLIENT_DEFAULT, FCI_GROUP_NONE);
+    if (NULL == p_cl)
+    {
+        rtn = FPP_ERR_FCI;
+    }
+    else
+    {
+        *pp_rtn_cl = p_cl;
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Close connection to the FCI endpoint and destroy the FCI client.
+ * @param[in]  p_cl  The FCI client to be destroyed.
+ * @return     FPP_ERR_OK : The FCI client was successfully destroyed.
+ *             other      : Failed to destroy the FCI client instance.
+ */
+int fci_ep_close(FCI_CLIENT* p_cl)
+{
+    assert(NULL != p_cl);
+    return fci_close(p_cl);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_interface/fci_ep.h b/sw/libfci_cli/src/libfci_interface/fci_ep.h
new file mode 100644
index 0000000..a6f70a3
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_interface/fci_ep.h
@@ -0,0 +1,29 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef FCI_EP_H_
+#define FCI_EP_H_
+
+#include <stdint.h>
+#include "libfci.h"
+
+/* ==== PUBLIC FUNCTIONS =================================================== */
+
+int fci_ep_open_in_cmd_mode(FCI_CLIENT** pp_rtn_cl);
+int fci_ep_close(FCI_CLIENT* p_cl);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_interface/fci_fp.c b/sw/libfci_cli/src/libfci_interface/fci_fp.c
new file mode 100644
index 0000000..535efe3
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_interface/fci_fp.c
@@ -0,0 +1,715 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <string.h>
+#include <arpa/inet.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+#include "fci_common.h"
+#include "fci_fp.h"
+ 
+ 
+/* ==== PRIVATE FUNCTIONS ================================================== */
+ 
+ 
+/*
+ * @brief          Network-to-host (ntoh) function for a FP rule properties struct.
+ * @param[in,out]  p_rtn_rule_props  The FP rule properties struct to be converted.
+ */
+static void ntoh_rule_props(fpp_fp_rule_props_t* p_rtn_rule_props)
+{
+    assert(NULL != p_rtn_rule_props);
+    
+    
+    p_rtn_rule_props->data = ntohl(p_rtn_rule_props->data);
+    p_rtn_rule_props->mask = ntohl(p_rtn_rule_props->mask);
+    p_rtn_rule_props->offset = ntohs(p_rtn_rule_props->offset);
+    ntoh_enum(&(p_rtn_rule_props->match_action), sizeof(fpp_fp_rule_match_action_t));
+    ntoh_enum(&(p_rtn_rule_props->offset_from), sizeof(fpp_fp_offset_from_t));
+}
+ 
+ 
+/*
+ * @brief          Host-to-network (hton) function for a FP rule properties struct.
+ * @param[in,out]  p_rtn_rule_props  The FP rule properties struct to be converted.
+ */
+static void hton_rule_props(fpp_fp_rule_props_t* p_rtn_rule_props)
+{
+    assert(NULL != p_rtn_rule_props);
+    
+    
+    p_rtn_rule_props->data = htonl(p_rtn_rule_props->data);
+    p_rtn_rule_props->mask = htonl(p_rtn_rule_props->mask);
+    p_rtn_rule_props->offset = htons(p_rtn_rule_props->offset);
+    hton_enum(&(p_rtn_rule_props->match_action), sizeof(fpp_fp_rule_match_action_t));
+    hton_enum(&(p_rtn_rule_props->offset_from), sizeof(fpp_fp_offset_from_t));
+}
+ 
+ 
+/*
+ * @brief          Host-to-network (hton) function for a FP table struct when a rule is
+ *                 inserted into the table.
+ * @param[in,out]  p_rtn_table  The FP table struct to be converted.
+ */
+static void hton_table(fpp_fp_table_cmd_t* p_rtn_table)
+{
+    assert(NULL != p_rtn_table);
+    p_rtn_table->table_info.t.position = htons(p_rtn_table->table_info.t.position);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested FP rule
+ *              from the PFE. Identify the rule by its name.
+ * @param[in]   p_cl         FCI client instance
+ * @param[out]  p_rtn_rule   Space for data from the PFE.
+ * @param[out]  p_rtn_idx    Space for index of the requested FP rule (from the PFE).
+ *                           This is a generic index of the given rule in a common pool of
+ *                           FP rules. It has no ties to any FP table.
+ *                           Can be NULL. If NULL, then no index is stored.
+ * @param[in]   p_rule_name  Name of the requested FP rule.
+ *                           Names of FP rules are user-defined. See fci_fp_rule_add().
+ * @return      FPP_ERR_OK : Requested FP rule was found.
+ *                           A copy of its configuration was stored into p_rtn_rule.
+ *                           Its index in a common pool of FP rules was stored into p_rtn_idx.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No data copied.
+ */
+int fci_fp_rule_get_by_name(FCI_CLIENT* p_cl, fpp_fp_rule_cmd_t* p_rtn_rule, 
+                            uint16_t* p_rtn_idx, const char* p_rule_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_rule);
+    assert(NULL != p_rule_name);
+    /* 'p_rtn_index' is allowed to be NULL */
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_fp_rule_cmd_t cmd_to_fci = {0};
+    fpp_fp_rule_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    uint16_t idx = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_FP_RULE,
+                    sizeof(fpp_fp_rule_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    ntoh_rule_props(&(reply_from_fci.r));  /* set correct byte order of rule properties */
+    
+    /* query loop (with the search condition) */
+    while ((FPP_ERR_OK == rtn) && strcmp(p_rule_name, (char*)(reply_from_fci.r.rule_name)))
+    {
+        idx++;
+        
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_FP_RULE,
+                        sizeof(fpp_fp_rule_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        ntoh_rule_props(&(reply_from_fci.r));  /* set correct byte order of rule properties */
+    }
+    
+    /* if search successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_rule = reply_from_fci;
+        if (NULL != p_rtn_idx)
+        {
+            *p_rtn_idx = idx;
+        }
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in the PFE ======= */
+ 
+ 
+/*
+ * @brief       Use FCI calls to create a new FP rule in the PFE.
+ * @param[in]   p_cl         FCI client instance
+ * @param[in]   p_rule_name  Name of the new FP rule.
+ *                           The name is user-defined.
+ * @param[in]   p_rule_data  Configuration data for the new FP rule.
+ *                           To create a new FP rule, a local data struct must be created,
+ *                           configured and then passed to this function.
+ *                           See [localdata] functions to learn more.
+ * @return      FPP_ERR_OK : New FP rule was created.
+ *              other      : Some error occured (represented by the respective error code).
+ */
+int fci_fp_rule_add(FCI_CLIENT* p_cl, const char* p_rule_name,
+                    const fpp_fp_rule_cmd_t* p_rule_data)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rule_name);
+    assert(NULL != p_rule_data);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_fp_rule_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci = *p_rule_data;
+    rtn = set_text((char*)(cmd_to_fci.r.rule_name), p_rule_name, IFNAMSIZ);
+    
+    /* send data */
+    if (FPP_ERR_OK == rtn)
+    {
+        hton_rule_props(&(cmd_to_fci.r));  /* set correct byte order of rule properties */
+        cmd_to_fci.action = FPP_ACTION_REGISTER;
+        rtn = fci_write(p_cl, FPP_CMD_FP_RULE, sizeof(fpp_fp_rule_cmd_t), 
+                                              (unsigned short*)(&cmd_to_fci));
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Use FCI calls to destroy the target FP rule in the PFE.
+ * @param[in]  p_cl         FCI client instance
+ * @param[in]  p_rule_name  Name of the FP rule to destroy.
+ * @return     FPP_ERR_OK : FP rule was destroyed.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_fp_rule_del(FCI_CLIENT* p_cl, const char* p_rule_name)
+{
+    assert(NULL != p_cl);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_fp_rule_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    rtn = set_text((char*)(cmd_to_fci.r.rule_name), p_rule_name, IFNAMSIZ);
+    
+    /* send data */
+    if (FPP_ERR_OK == rtn)
+    {
+        hton_rule_props(&(cmd_to_fci.r));  /* set correct byte order of rule properties */
+        cmd_to_fci.action = FPP_ACTION_DEREGISTER;
+        rtn = fci_write(p_cl, FPP_CMD_FP_RULE, sizeof(fpp_fp_rule_cmd_t), 
+                                              (unsigned short*)(&cmd_to_fci));
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to create a new FP table in the PFE.
+ * @param[in]   p_cl          FCI client instance
+ * @param[in]   p_table_name  Name of the new FP table.
+ *                            The name is user-defined.
+ * @return      FPP_ERR_OK : New FP table was created.
+ *              other      : Some error occured (represented by the respective error code).
+ */
+int fci_fp_table_add(FCI_CLIENT* p_cl, const char* p_table_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_table_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_fp_table_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    rtn = set_text((char*)(cmd_to_fci.table_info.t.table_name), p_table_name, IFNAMSIZ);
+    
+    /* send data */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* only text was set, no need to change byte order */
+        cmd_to_fci.action = FPP_ACTION_REGISTER;
+        rtn = fci_write(p_cl, FPP_CMD_FP_TABLE, sizeof(fpp_fp_table_cmd_t), 
+                                               (unsigned short*)(&cmd_to_fci));
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Use FCI calls to destroy the target FP table in the PFE.
+ * @param[in]  p_cl          FCI client instance
+ * @param[in]  p_table_name  Name of the FP table to destroy.
+ * @return     FPP_ERR_OK : FP table was destroyed.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_fp_table_del(FCI_CLIENT* p_cl, const char* p_table_name)
+{
+    assert(NULL != p_cl);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_fp_table_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    rtn = set_text((char*)(cmd_to_fci.table_info.t.table_name), p_table_name, IFNAMSIZ);
+    
+    /* send data */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* only text was set, no need to change byte order */
+        cmd_to_fci.action = FPP_ACTION_DEREGISTER;
+        rtn = fci_write(p_cl, FPP_CMD_FP_TABLE, sizeof(fpp_fp_table_cmd_t), 
+                                               (unsigned short*)(&cmd_to_fci));
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to insert a FP rule at given position of a FP table in the PFE.
+ * @param[in]   p_cl          FCI client instance
+ * @param[in]   p_table_name  Name of an existing FP table.
+ * @param[in]   p_rule_name   Name of an existing FP rule.
+ * @param[in]   position      Index where to insert the rule. Starts at 0.
+ * @return      FPP_ERR_OK : The rule was successfully inserted into the table.
+ *              other      : Some error occured (represented by the respective error code).
+ */
+int fci_fp_table_insert_rule(FCI_CLIENT* p_cl, const char* p_table_name, 
+                             const char* p_rule_name, uint16_t position)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_table_name);
+    assert(NULL != p_rule_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_fp_table_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    rtn = set_text((char*)(cmd_to_fci.table_info.t.table_name), p_table_name, IFNAMSIZ);
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = set_text((char*)(cmd_to_fci.table_info.t.rule_name), p_rule_name, IFNAMSIZ);
+    }
+    if (FPP_ERR_OK == rtn)
+    {
+        cmd_to_fci.table_info.t.position = position;
+    }
+    
+    /* send data */
+    if (FPP_ERR_OK == rtn)
+    {
+        hton_table(&cmd_to_fci);  /* set correct byte order */
+        cmd_to_fci.action = FPP_ACTION_USE_RULE;
+        rtn = fci_write(p_cl, FPP_CMD_FP_TABLE, sizeof(fpp_fp_table_cmd_t), 
+                                               (unsigned short*)(&cmd_to_fci));
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to remove a FP rule from a FP table in the PFE.
+ * @param[in]   p_cl          FCI client instance
+ * @param[in]   p_table_name  Name of an existing FP table.
+ * @param[in]   p_rule_name   Name of an existing FP rule.
+ * @return      FPP_ERR_OK : The rule was successfully removed from the table.
+ *              other      : Some error occured (represented by the respective error code).
+ */
+int fci_fp_table_remove_rule(FCI_CLIENT* p_cl, const char* p_table_name, 
+                             const char* p_rule_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_table_name);
+    assert(NULL != p_rule_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_fp_table_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    rtn = set_text((char*)(cmd_to_fci.table_info.t.table_name), p_table_name, IFNAMSIZ);
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = set_text((char*)(cmd_to_fci.table_info.t.rule_name), p_rule_name, IFNAMSIZ);
+    }
+    
+    /* send data */
+    if (FPP_ERR_OK == rtn)
+    {
+        hton_table(&cmd_to_fci);  /* set correct byte order */
+        cmd_to_fci.action = FPP_ACTION_UNUSE_RULE;
+        rtn = fci_write(p_cl, FPP_CMD_FP_TABLE, sizeof(fpp_fp_table_cmd_t), 
+                                               (unsigned short*)(&cmd_to_fci));
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+/*
+ * @defgroup    localdata_fprule  [localdata_fprule]
+ * @brief:      Functions marked as [localdata_fprule] guarantee that 
+ *              only local data are accessed.
+ * @details:    These functions do not make any FCI calls.
+ *              If some local data modifications are made, then after all local data changes
+ *              are done and finished, call fci_fp_rule_add() to 
+ *              create a new FP rule with given configuration in the PFE.
+ */
+ 
+ 
+/*
+ * @brief          Set data template of a FP rule.
+ * @details        [localdata_fprule]
+ * @param[in,out]  p_rule  Local data to be modified.
+ *                         For FP rules, there are no "initial data" to be obtained from PFE.
+ *                         Simply declare a local data struct and configure it.
+ * @param[in]      data    Data template (value)
+ *                         This value will be compared with a selected value from 
+ *                         the inspected traffic.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_fp_rule_ld_set_data(fpp_fp_rule_cmd_t* p_rule, uint32_t data)
+{
+    assert(NULL != p_rule);
+    p_rule->r.data = data;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set bitmask of a FP rule.
+ * @details        [localdata_fprule]
+ * @param[in,out]  p_rule  Local data to be modified.
+ *                         For FP rules, there are no "initial data" to be obtained from PFE.
+ *                         Simply declare a local data struct and configure it.
+ * @param[in]      mask    Bitmask for more precise data selection.
+ *                         This bitmask is applied on the selected 32bit value from
+ *                         the inspected traffic.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_fp_rule_ld_set_mask(fpp_fp_rule_cmd_t* p_rule, uint32_t mask)
+{
+    assert(NULL != p_rule);
+    p_rule->r.mask = mask;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set offset and base for offset ("offset from") of a FP rule.
+ * @details        [localdata_fprule]
+ * @param[in,out]  p_rule  Local data to be modified.
+ *                         For FP rules, there are no "initial data" to be obtained from PFE.
+ *                         Simply declare a local data struct and configure it.
+ * @param[in]      offset  Offset (in bytes) into traffic's data.
+ *                         This offset is applied from the respective base ("offset_from").
+ *                         A 32bit data value which lies on the offset is the value selected
+ *                         for comparison under the given FP rule.
+ * @param[in]      offset_from  The base for offset calculation.
+ *                              See description of fpp_fp_offset_from_t type 
+ *                              in the FCI API Reference.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_fp_rule_ld_set_offset(fpp_fp_rule_cmd_t* p_rule, uint16_t offset, 
+                              fpp_fp_offset_from_t offset_from)
+{
+    assert(NULL != p_rule);
+    p_rule->r.offset = offset;
+    p_rule->r.offset_from = offset_from;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset inverted mode of FP rule match evaluation.
+ * @details        [localdata_fprule]
+ * @param[in,out]  p_rule  Local data to be modified.
+ *                         For FP rules, there are no "initial data" to be obtained from PFE.
+ *                         Simply declare a local data struct and configure it.
+ * @param[in]      invert  A request to set/unset the inverted mode of evaluation.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_fp_rule_ld_set_invert(fpp_fp_rule_cmd_t* p_rule, bool invert)
+{
+    assert(NULL != p_rule);
+    p_rule->r.invert = invert;  /* NOTE: Implicit cast of bool to uintX_t */
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set action to be done if inspected traffic satisfies the given FP rule.
+ * @details        [localdata_fprule]
+ * @param[in,out]  p_rule  Local data to be modified.
+ *                         For FP rules, there are no "initial data" to be obtained from PFE.
+ *                         Simply declare a local data struct and configure it.
+ * @param[in]      match_action      An action to be done.
+ *                                   See description of fpp_fp_rule_match_action_t type
+ *                                   in the FCI API Reference.
+ * @param[in]      p_next_rule_name  Name of the next FP rule to execute.
+ *                                   Is meaningful only if the match action is FP_NEXT_RULE.
+ *                                   Can be NULL. If NULL or "" (empty string), 
+ *                                   then no rule is set as the next rule.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_fp_rule_ld_set_match_action(fpp_fp_rule_cmd_t* p_rule, 
+                                    fpp_fp_rule_match_action_t match_action,
+                                    const char* p_next_rule_name)
+{
+    assert(NULL != p_rule);
+    /* 'p_next_rule_name' is allowed to be NULL */
+    
+    p_rule->r.match_action = match_action;
+    return set_text((char*)(p_rule->r.next_rule_name), p_next_rule_name, IFNAMSIZ);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all FP rules of a given FP table in the PFE.
+ *             Execute a print function for each reported FP rule.
+ * @param[in]  p_cl           FCI client instance
+ * @param[in]  p_cb_print     Callback print function.
+ *                            --> If the callback returns zero, then all is OK and 
+ *                                the next FP rule in table is picked for a print process.
+ *                            --> If the callback returns non-zero, then some problem is 
+ *                                assumed and this function terminates prematurely.
+ * @param[in]  p_table_name   Name of a FP table.
+ *                            Names of FP tables are user-defined. See fci_fp_table_add().
+ * @param[in]  position_init  Start invoking callback print function from 
+ *                            this position in the table.
+ *                            If 0, start from the very first FP rule in the table.
+ * @param[in]  count          Print only this count of FP rules, then end.
+ *                            If 0, keep printing FP rules till the end of the table.
+ * @return     FPP_ERR_OK : Successfully iterated through FP rules of the given FP table.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_fp_table_print(FCI_CLIENT* p_cl, fci_fp_rule_cb_print_t p_cb_print, 
+                       const char* p_table_name, uint16_t position_init, uint16_t count)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    assert(NULL != p_table_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_fp_table_cmd_t cmd_to_fci = {0};
+    fpp_fp_table_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    rtn = set_text((char*)(cmd_to_fci.table_info.t.table_name), p_table_name, IFNAMSIZ);
+    if (0u == count)  /* if 0, set max possible count of items */
+    {
+        count--;  /* WARNING: intentional use of owf behavior */
+    }
+    
+    /*  do the query  */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* start query process */
+        cmd_to_fci.action = FPP_ACTION_QUERY;
+        rtn = fci_query(p_cl, FPP_CMD_FP_TABLE,
+                        sizeof(fpp_fp_table_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        ntoh_rule_props(&(reply_from_fci.table_info.r));  /* set correct byte order */
+    
+        /* query loop */
+        uint16_t position = 0u;
+        while ((FPP_ERR_OK == rtn) && (0u != count))
+        {
+            if (position >= position_init)
+            {
+                rtn = p_cb_print(&(reply_from_fci.table_info.r), position);
+                count--;
+            }
+            
+            position++;
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+                rtn = fci_query(p_cl, FPP_CMD_FP_TABLE,
+                                sizeof(fpp_fp_table_cmd_t), (unsigned short*)(&cmd_to_fci),
+                                &reply_length, (unsigned short*)(&reply_from_fci));
+                ntoh_rule_props(&(reply_from_fci.table_info.r));  /* set correct byte order */
+            }
+        }
+        
+        /* query loop runs till there are no more FP rules to report */
+        /* the following error is therefore OK and expected (it ends the query loop) */
+        if (FPP_ERR_FP_RULE_NOT_FOUND == rtn)
+        {
+            rtn = FPP_ERR_OK;
+        }
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all existing FP rules in the PFE (regardless
+ *             of table affiliation). Execute a print function for each reported FP rule.
+ * @param[in]  p_cl           FCI client instance
+ * @param[in]  p_cb_print     Callback print function.
+ *                            --> If the callback returns zero, then all is OK and 
+ *                                the next FP rule is picked for a print process.
+ *                            --> If the callback returns non-zero, then some problem is 
+ *                                assumed and this function terminates prematurely.
+ * @param[in]  idx_init       Start invoking callback print function from 
+ *                            this index of FP rule query.
+ *                            If 0, start from the very first queried FP rule.
+ * @param[in]  count          Print only this count of FP rules, then end.
+ *                            If 0, keep printing FP rules till there is no more available.
+ * @return     FPP_ERR_OK : Successfully iterated through FP rules.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_fp_rule_print_all(FCI_CLIENT* p_cl, fci_fp_rule_cb_print_t p_cb_print, 
+                          uint16_t idx_init, uint16_t count)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_fp_rule_cmd_t cmd_to_fci = {0};
+    fpp_fp_rule_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    if (0u == count)  /* if 0, set max possible count of items */
+    {
+        count--;  /* WARNING: intentional use of owf behavior */
+    }
+    
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_FP_RULE,
+                    sizeof(fpp_fp_rule_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    ntoh_rule_props(&(reply_from_fci.r));  /* set correct byte order */
+
+    /* query loop */
+    uint16_t idx = 0u;
+    while ((FPP_ERR_OK == rtn) && (0u != count))
+    {
+        if (idx >= idx_init)
+        {
+            rtn = p_cb_print(&(reply_from_fci.r), idx);
+            count--;
+        }
+        
+        idx++;
+        
+        if (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+            rtn = fci_query(p_cl, FPP_CMD_FP_RULE,
+                            sizeof(fpp_fp_rule_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            ntoh_rule_props(&(reply_from_fci.r));  /* set correct byte order */
+        }
+    }
+    
+    /* query loop runs till there are no more FP rules to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_FP_RULE_NOT_FOUND == rtn)
+    {
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all FP rules in the PFE (regardless
+ *              of table affiliation).
+ * @param[in]   p_cl         FCI client instance
+ * @param[out]  p_rtn_count  Space to store the count of FP rules.
+ * @return      FPP_ERR_OK : Successfully counted FP rules.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No count was stored.
+ */
+int fci_fp_rule_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_count);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_fp_rule_cmd_t cmd_to_fci = {0};
+    fpp_fp_rule_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    uint16_t count = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_FP_RULE,
+                    sizeof(fpp_fp_rule_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    /* no need to set correct byte order (we are just counting FP rules) */
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        count++;
+        
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_FP_RULE,
+                        sizeof(fpp_fp_rule_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        /* no need to set correct byte order (we are just counting FP rules) */
+    }
+    
+    /* query loop runs till there are no more FP rules to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_FP_RULE_NOT_FOUND == rtn)
+    {
+        *p_rtn_count = count;
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_interface/fci_fp.h b/sw/libfci_cli/src/libfci_interface/fci_fp.h
new file mode 100644
index 0000000..1882951
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_interface/fci_fp.h
@@ -0,0 +1,58 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef FCI_FP_H_
+#define FCI_FP_H_
+
+#include "fpp_ext.h"
+#include "libfci.h"
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+typedef int (*fci_fp_rule_cb_print_t)(const fpp_fp_rule_props_t* p_rule_props, uint16_t position);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
+
+int fci_fp_rule_get_by_name(FCI_CLIENT* p_cl, fpp_fp_rule_cmd_t* p_rtn_rule, uint16_t* p_rtn_idx, const char* p_rule_name);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in the PFE ======= */
+
+int fci_fp_rule_add(FCI_CLIENT* p_cl, const char* p_rule_name, const fpp_fp_rule_cmd_t* p_rule_data);
+int fci_fp_rule_del(FCI_CLIENT* p_cl, const char* p_rule_name);
+
+int fci_fp_table_add(FCI_CLIENT* p_cl, const char* p_table_name);
+int fci_fp_table_del(FCI_CLIENT* p_cl, const char* p_table_name);
+int fci_fp_table_insert_rule(FCI_CLIENT* p_cl, const char* p_table_name, const char* p_rule_name, uint16_t position);
+int fci_fp_table_remove_rule(FCI_CLIENT* p_cl, const char* p_table_name, const char* p_rule_name);
+
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+
+int fci_fp_rule_ld_set_data(fpp_fp_rule_cmd_t* p_rule, uint32_t data);
+int fci_fp_rule_ld_set_mask(fpp_fp_rule_cmd_t* p_rule, uint32_t mask);
+int fci_fp_rule_ld_set_offset(fpp_fp_rule_cmd_t* p_rule, uint16_t offset, fpp_fp_offset_from_t offset_from);
+int fci_fp_rule_ld_set_invert(fpp_fp_rule_cmd_t* p_rule, bool invert);
+int fci_fp_rule_ld_set_match_action(fpp_fp_rule_cmd_t* p_rule, fpp_fp_rule_match_action_t match_action,
+                                    const char* p_next_rule_name);
+
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+
+int fci_fp_table_print(FCI_CLIENT* p_cl, fci_fp_rule_cb_print_t p_cb_print, const char* p_table_name,
+                       uint16_t position_init, uint16_t count);
+int fci_fp_rule_print_all(FCI_CLIENT* p_cl, fci_fp_rule_cb_print_t p_cb_print, uint16_t idx_init, uint16_t count);
+int fci_fp_rule_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_interface/fci_fwfeat.c b/sw/libfci_cli/src/libfci_interface/fci_fwfeat.c
new file mode 100644
index 0000000..c1f68a5
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_interface/fci_fwfeat.c
@@ -0,0 +1,235 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <string.h>
+#include <arpa/inet.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+#include "fci_common.h"
+#include "fci_fwfeat.h"
+ 
+ 
+/* ==== PRIVATE FUNCTIONS ================================================== */
+ 
+/* empty */
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested FW feature
+ *              from the PFE. Identify the FW feature by its name.
+ * @param[in]   p_cl         FCI client instance
+ * @param[out]  p_rtn_fwfeat Space for data from the PFE.
+ * @param[in]   p_name       Name of the requested FW feature.
+ * @return      FPP_ERR_OK : Requested FW feature was found.
+ *                           A copy of its configuration was stored into p_rtn_fwfeat.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No data copied.
+ */
+int fci_fwfeat_get_by_name(FCI_CLIENT* p_cl, fpp_fw_features_cmd_t* p_rtn_fwfeat, 
+                           const char* p_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_fwfeat);
+    assert(NULL != p_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_fw_features_cmd_t cmd_to_fci = {0};
+    fpp_fw_features_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_FW_FEATURE,
+                        sizeof(fpp_fw_features_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /* query loop (with the search condition) */
+    while ((FPP_ERR_OK == rtn) && (strcmp(p_name, reply_from_fci.name)))
+    {
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_FW_FEATURE,
+                        sizeof(fpp_fw_features_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    }
+    
+    /* if search successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_fwfeat = reply_from_fci;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
+ 
+ 
+/*
+ * @brief      Use FCI calls to enable/disable a target FW feature in the PFE.
+ * @param[in]  p_cl     FCI client instance
+ * @param[in]  p_name   Name of the requested FW feature.
+ * @param[in]  enable   A request to set/unset the FW feature.
+ * @return     FPP_ERR_OK : FW feature was successfully enabled/disabled in the PFE.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_fwfeat_set(FCI_CLIENT* p_cl, const char* p_name, bool enable)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_fw_features_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    rtn = set_text((cmd_to_fci.name), p_name, (FPP_FEATURE_NAME_SIZE + 1));
+    if (FPP_ERR_OK == rtn)
+    {
+        cmd_to_fci.val = enable;  /* NOTE: Implicit cast from bool to uintX_t */
+    }
+    
+    /* send data */
+    if (FPP_ERR_OK == rtn)
+    {
+        cmd_to_fci.action = FPP_ACTION_UPDATE;
+        rtn = fci_write(p_cl, FPP_CMD_FW_FEATURE, sizeof(fpp_fw_features_cmd_t), 
+                                                 (unsigned short*)(&cmd_to_fci));
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all FW features in the PFE and
+ *             execute a callback print function for each reported FW feature.
+ * @param[in]  p_cl        FCI client instance
+ * @param[in]  p_cb_print  Callback print function.
+ *                         --> If the callback returns zero, then all is OK and 
+ *                             the next FW feature is picked for a print process.
+ *                         --> If the callback returns non-zero, then some problem is 
+ *                             assumed and this function terminates prematurely.
+ * @return     FPP_ERR_OK : Successfully iterated through FW features.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_fwfeat_print_all(FCI_CLIENT* p_cl, fci_fwfeat_cb_print_t p_cb_print)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_fw_features_cmd_t cmd_to_fci = {0};
+    fpp_fw_features_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_FW_FEATURE,
+                    sizeof(fpp_fw_features_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+        
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        rtn = p_cb_print(&reply_from_fci);
+        
+        if (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+            rtn = fci_query(p_cl, FPP_CMD_FW_FEATURE,
+                            sizeof(fpp_fw_features_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+        }
+    }
+    
+    /* query loop runs till there are no more FW features to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_ENTRY_NOT_FOUND == rtn)
+    {
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all FW features in the PFE.
+ * @param[in]   p_cl         FCI client instance
+ * @param[out]  p_rtn_count  Space to store the count of FW features.
+ * @return      FPP_ERR_OK : Successfully counted FW features.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No count was stored.
+ */
+int fci_fwfeat_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_count);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_fw_features_cmd_t cmd_to_fci = {0};
+    fpp_fw_features_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    uint16_t count = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_FW_FEATURE,
+                    sizeof(fpp_fw_features_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        count++;
+        
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_FW_FEATURE,
+                        sizeof(fpp_fw_features_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    }
+    
+    /* query loop runs till there are no more FW features to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_ENTRY_NOT_FOUND == rtn)
+    {
+        *p_rtn_count = count;
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_interface/fci_fwfeat.h b/sw/libfci_cli/src/libfci_interface/fci_fwfeat.h
new file mode 100644
index 0000000..028ee53
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_interface/fci_fwfeat.h
@@ -0,0 +1,41 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef FCI_SPD_H_
+#define FCI_SPD_H_
+
+#include "fpp_ext.h"
+#include "libfci.h"
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+typedef int (*fci_fwfeat_cb_print_t)(const fpp_fw_features_cmd_t* p_fwfeat);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
+
+int fci_fwfeat_get_by_name(FCI_CLIENT* p_cl, fpp_fw_features_cmd_t* p_rtn_fwfeat, const char* p_name);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
+
+int fci_fwfeat_set(FCI_CLIENT* p_cl, const char* p_name, bool enable);
+
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+
+int fci_fwfeat_print_all(FCI_CLIENT* p_cl, fci_fwfeat_cb_print_t p_cb_print);
+int fci_fwfeat_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_interface/fci_l2_bd.c b/sw/libfci_cli/src/libfci_interface/fci_l2_bd.c
new file mode 100644
index 0000000..2224d28
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_interface/fci_l2_bd.c
@@ -0,0 +1,1193 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <string.h>
+#include <arpa/inet.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+#include "fci_common.h"
+#include "fci_l2_bd.h"
+ 
+ 
+/* ==== PRIVATE FUNCTIONS ================================================== */
+ 
+ 
+/*
+ * @brief          Network-to-host (ntoh) function for a bridge domain struct.
+ * @param[in,out]  p_rtn_bd  The bridge domain struct to be converted.
+ */
+static void ntoh_bd(fpp_l2_bd_cmd_t* p_rtn_bd)
+{
+    assert(NULL != p_rtn_bd);
+    
+    
+    p_rtn_bd->vlan = ntohs(p_rtn_bd->vlan);
+    p_rtn_bd->if_list = ntohl(p_rtn_bd->if_list);
+    p_rtn_bd->untag_if_list = ntohl(p_rtn_bd->untag_if_list);
+    ntoh_enum(&(p_rtn_bd->flags), sizeof(fpp_l2_bd_flags_t));
+}
+ 
+ 
+/*
+ * @brief          Host-to-network (hton) function for a bridge domain struct.
+ * @param[in,out]  p_rtn_bd  The bridge domain struct to be converted.
+ */
+static void hton_bd(fpp_l2_bd_cmd_t* p_rtn_bd)
+{
+    assert(NULL != p_rtn_bd);
+    
+    
+    p_rtn_bd->vlan = htons(p_rtn_bd->vlan);
+    p_rtn_bd->if_list = htonl(p_rtn_bd->if_list);
+    p_rtn_bd->untag_if_list = htonl(p_rtn_bd->untag_if_list);
+    hton_enum(&(p_rtn_bd->flags), sizeof(fpp_l2_bd_flags_t));
+}
+ 
+ 
+/*
+ * @brief          Network-to-host (ntoh) function for a static entry struct.
+ * @param[in,out]  p_rtn_stent  The static entry struct to be converted.
+ */
+static void ntoh_stent(fpp_l2_static_ent_cmd_t* p_rtn_stent)
+{
+    assert(NULL != p_rtn_stent);
+    
+    
+    p_rtn_stent->vlan = ntohs(p_rtn_stent->vlan);
+    p_rtn_stent->forward_list = ntohl(p_rtn_stent->forward_list);
+}
+ 
+ 
+/*
+ * @brief          Host-to-network (hton) function for a static entry struct.
+ * @param[in,out]  p_rtn_bd  The static entry struct to be converted.
+ */
+static void hton_stent(fpp_l2_static_ent_cmd_t* p_rtn_stent)
+{
+    assert(NULL != p_rtn_stent);
+    
+    
+    p_rtn_stent->vlan = htons(p_rtn_stent->vlan);
+    p_rtn_stent->forward_list = htonl(p_rtn_stent->forward_list);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested bridge domain
+ *              from the PFE. Identify the domain by its VLAN ID.
+ * @param[in]   p_cl      FCI client instance
+ * @param[out]  p_rtn_bd  Space for data from the PFE.
+ * @param[in]   vlan      VLAN ID of the requested bridge domain.
+ * @return      FPP_ERR_OK : Requested bridge domain was found.
+ *                           A copy of its configuration was stored into p_rtn_bd.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No data copied.
+ */
+int fci_l2_bd_get_by_vlan(FCI_CLIENT* p_cl, fpp_l2_bd_cmd_t* p_rtn_bd, uint16_t vlan)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_bd);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_l2_bd_cmd_t cmd_to_fci = {0};
+    fpp_l2_bd_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_L2_BD,
+                    sizeof(fpp_l2_bd_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    ntoh_bd(&reply_from_fci);  /* set correct byte order */
+    
+    /* query loop (with the search condition) */
+    while ((FPP_ERR_OK == rtn) && (vlan != (reply_from_fci.vlan)))
+    {
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_L2_BD,
+                        sizeof(fpp_l2_bd_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        ntoh_bd(&reply_from_fci);  /* set correct byte order */
+    }
+    
+    /* if search successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_bd = reply_from_fci;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested static entry
+ *              from the PFE. Identify the entry by VLAN ID of the parent bridge domain and
+ *              by MAC address of the entry.
+ * @param[in]   p_cl      FCI client instance
+ * @param[out]  p_rtn_stent  Space for data from the PFE.
+ * @param[in]   vlan         VLAN ID of the parent bridge domain.
+ * @param[in]   p_mac        MAC address of the requested static entry.
+ * @return      FPP_ERR_OK : Requested static entry was found.
+ *                           A copy of its configuration was stored into p_rtn_stent.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No data copied.
+ */
+int fci_l2_stent_get_by_vlanmac(FCI_CLIENT* p_cl, fpp_l2_static_ent_cmd_t* p_rtn_stent,
+                                uint16_t vlan, const uint8_t p_mac[6])
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_stent);
+    assert(NULL != p_mac);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_l2_static_ent_cmd_t cmd_to_fci = {0};
+    fpp_l2_static_ent_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
+                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    ntoh_stent(&reply_from_fci);  /* set correct byte order */
+    
+    /* query loop (with the search condition) */
+    while ((FPP_ERR_OK == rtn) &&
+          !((vlan == reply_from_fci.vlan) && (0 == memcmp(p_mac, reply_from_fci.mac, 6))))
+    {
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
+                        sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        ntoh_stent(&reply_from_fci);  /* set correct byte order */
+    }
+    
+    /* if search successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_stent = reply_from_fci;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
+ 
+ 
+/*
+ * @brief          Use FCI calls to update configuration of a target bridge domain
+ *                 in the PFE.
+ * @param[in]      p_cl  FCI client instance
+ * @param[in,out]  p_bd  Data struct which represents a new configuration of 
+ *                       the target bridge domain.
+ *                       Initial data can be obtained via fci_l2_bd_get_by_vlan().
+ * @return         FPP_ERR_OK : Configuration of the target bridge domain was
+ *                              successfully updated in the PFE.
+ *                              Local data struct was automatically updated with 
+ *                              readback data from the PFE.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data struct not updated.
+ */
+int fci_l2_bd_update(FCI_CLIENT* p_cl, fpp_l2_bd_cmd_t* p_bd)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_bd);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_l2_bd_cmd_t cmd_to_fci = (*p_bd);
+    
+    /* send data */
+    hton_bd(&cmd_to_fci);  /* set correct byte order */
+    cmd_to_fci.action = FPP_ACTION_UPDATE;
+    rtn = fci_write(p_cl, FPP_CMD_L2_BD, sizeof(fpp_l2_bd_cmd_t), 
+                                        (unsigned short*)(&cmd_to_fci));
+    
+    /* read back and update caller data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_l2_bd_get_by_vlan(p_cl, p_bd, (p_bd->vlan));
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief          Use FCI calls to update configuration of a target static entry
+ *                 in the PFE.
+ * @param[in]      p_cl  FCI client instance
+ * @param[in,out]  p_stent  Data struct which represents a new configuration of 
+ *                          the target static entry.
+ *                          Initial data can be obtained via fci_l2_stent_get_by_vlanmac().
+ * @return         FPP_ERR_OK : Configuration of the target static entry was
+ *                              successfully updated in the PFE.
+ *                              Local data struct was automatically updated with 
+ *                              readback data from the PFE.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data struct not updated.
+ */
+int fci_l2_stent_update(FCI_CLIENT* p_cl, fpp_l2_static_ent_cmd_t* p_stent)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_stent);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_l2_static_ent_cmd_t cmd_to_fci = (*p_stent);
+    
+    /* send data */
+    hton_stent(&cmd_to_fci);  /* set correct byte order */
+    cmd_to_fci.action = FPP_ACTION_UPDATE;
+    rtn = fci_write(p_cl, FPP_CMD_L2_STATIC_ENT, sizeof(fpp_l2_static_ent_cmd_t), 
+                                                (unsigned short*)(&cmd_to_fci));
+    
+    /* read back and update caller data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_l2_stent_get_by_vlanmac(p_cl, p_stent, (p_stent->vlan), (p_stent->mac));
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief          Use FCI calls to flush static entries from MAC tables of 
+ *                 all bridge domains in the PFE.
+ * @param[in]      p_cl  FCI client instance
+ * @return         FPP_ERR_OK : Static entries of all bridge domains were 
+ *                              successfully flushed in the PFE.
+ *                 other      : Some error occured (represented by the respective error code).
+ */
+int fci_l2_flush_static(FCI_CLIENT* p_cl)
+{
+    assert(NULL != p_cl);
+    return fci_write(p_cl, FPP_CMD_L2_FLUSH_STATIC, 0u, NULL);
+}
+ 
+ 
+/*
+ * @brief          Use FCI calls to flush dynamically learned entries from MAC tables of
+ *                 all bridge domains in the PFE.
+ * @param[in]      p_cl  FCI client instance
+ * @return         FPP_ERR_OK : Learned entries of all bridge domains were
+ *                              successfully flushed in the PFE.
+ *                 other      : Some error occured (represented by the respective error code).
+ */
+int fci_l2_flush_learned(FCI_CLIENT* p_cl)
+{
+    assert(NULL != p_cl);
+    return fci_write(p_cl, FPP_CMD_L2_FLUSH_LEARNED, 0u, NULL);
+}
+ 
+ 
+/*
+ * @brief          Use FCI calls to flush all entries from MAC tables of 
+ *                 all bridge domains in the PFE.
+ * @param[in]      p_cl  FCI client instance
+ * @return         FPP_ERR_OK : All entries of all bridge domains were
+ *                              successfully flushed in the PFE.
+ *                 other      : Some error occured (represented by the respective error code).
+ */
+int fci_l2_flush_all(FCI_CLIENT* p_cl)
+{
+    assert(NULL != p_cl);
+    return fci_write(p_cl, FPP_CMD_L2_FLUSH_ALL, 0u, NULL);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in the PFE ======= */
+ 
+ 
+/*
+ * @brief       Use FCI calls to create a new bridge domain in the PFE.
+ * @param[in]   p_cl      FCI client instance
+ * @param[out]  p_rtn_if  Space for data from the PFE.
+ *                        Will contain a copy of configuration data of 
+ *                        the newly created bridge domain.
+ *                        Can be NULL. If NULL, then there is no local data to fill.
+ * @param[in]   vlan      VLAN ID of the new bridge domain.
+ * @return      FPP_ERR_OK : New bridge domain was created.
+ *                           If applicable, then its configuration data were 
+ *                           copied into p_rtn_bd.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No data copied.
+ */
+int fci_l2_bd_add(FCI_CLIENT* p_cl, fpp_l2_bd_cmd_t* p_rtn_bd, uint16_t vlan)
+{
+    assert(NULL != p_cl);
+    /* 'p_rtn_bd' is allowed to be NULL */
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_l2_bd_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci.vlan = vlan;
+    cmd_to_fci.ucast_hit  = 3u;  /* 3 == discard */
+    cmd_to_fci.ucast_miss = 3u;  /* 3 == discard */
+    cmd_to_fci.mcast_hit  = 3u;  /* 3 == discard */
+    cmd_to_fci.mcast_miss = 3u;  /* 3 == discard */
+    
+    /* send data */
+    hton_bd(&cmd_to_fci);  /* set correct byte order */
+    cmd_to_fci.action = FPP_ACTION_REGISTER;
+    rtn = fci_write(p_cl, FPP_CMD_L2_BD, sizeof(fpp_l2_bd_cmd_t), 
+                                        (unsigned short*)(&cmd_to_fci));
+    
+    /* read back and update caller data (if applicable) */
+    if ((FPP_ERR_OK == rtn) && (NULL != p_rtn_bd))
+    {
+        rtn = fci_l2_bd_get_by_vlan(p_cl, p_rtn_bd, vlan);
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Use FCI calls to destroy the target bridge domain in the PFE.
+ * @param[in]  p_cl    FCI client instance
+ * @param[in]  vlan    VLAN ID of the bridge domain to destroy.
+ * @return     FPP_ERR_OK : Bridge domain was destroyed.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_l2_bd_del(FCI_CLIENT* p_cl, uint16_t vlan)
+{
+    assert(NULL != p_cl);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_l2_bd_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci.vlan = vlan;
+    
+    /* send data */
+    hton_bd(&cmd_to_fci);  /* set correct byte order */
+    cmd_to_fci.action = FPP_ACTION_DEREGISTER;
+    rtn = fci_write(p_cl, FPP_CMD_L2_BD, sizeof(fpp_l2_bd_cmd_t), 
+                                        (unsigned short*)(&cmd_to_fci));
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to create a new static entry in the PFE.
+ *              The new entry is associated with a provided parent bridge domain.
+ * @param[in]   p_cl      FCI client instance
+ * @param[out]  p_rtn_stent  Space for data from the PFE.
+ *                           Will contain a copy of configuration data of 
+ *                           the newly created static entry.
+ *                           Can be NULL. If NULL, then there is no local data to fill.
+ * @param[in]   vlan         VLAN ID of the parent bridge domain.
+ * @param[in]   p_mac        MAC address of the new static entry.
+ * @return      FPP_ERR_OK : New static entry was created.
+ *                           If applicable, then its configuration data were 
+ *                           copied into p_rtn_stent.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No data copied.
+ */
+int fci_l2_stent_add(FCI_CLIENT* p_cl, fpp_l2_static_ent_cmd_t* p_rtn_stent,
+                     uint16_t vlan, const uint8_t p_mac[6])
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_mac);
+    /* 'p_rtn_stent' is allowed to be NULL */
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_l2_static_ent_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci.vlan  = vlan;
+    memcpy(cmd_to_fci.mac, p_mac, 6);
+    
+    /* send data */
+    hton_stent(&cmd_to_fci);  /* set correct byte order */
+    cmd_to_fci.action = FPP_ACTION_REGISTER;
+    rtn = fci_write(p_cl, FPP_CMD_L2_STATIC_ENT, sizeof(fpp_l2_static_ent_cmd_t),
+                                                (unsigned short*)(&cmd_to_fci));
+    
+    /* read back and update caller data (if applicable) */
+    if ((FPP_ERR_OK == rtn) && (NULL != p_rtn_stent))
+    {
+        rtn = fci_l2_stent_get_by_vlanmac(p_cl, p_rtn_stent, vlan, p_mac);
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Use FCI calls to destroy the target static entry in the PFE.
+ * @param[in]  p_cl    FCI client instance
+ * @param[in]  vlan    VLAN ID of the parent bridge domain.
+ * @param[in]  p_mac   MAC address of the static entry to be destroyed.
+ * @return     FPP_ERR_OK : Static entry was destroyed.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_l2_stent_del(FCI_CLIENT* p_cl, uint16_t vlan, const uint8_t p_mac[6])
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_mac);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_l2_static_ent_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci.vlan = vlan;
+    memcpy(cmd_to_fci.mac, p_mac, 6);
+    
+    /* send data */
+    hton_stent(&cmd_to_fci);  /* set correct byte order */
+    cmd_to_fci.action = FPP_ACTION_DEREGISTER;
+    rtn = fci_write(p_cl, FPP_CMD_L2_STATIC_ENT, sizeof(fpp_l2_static_ent_cmd_t),
+                                                (unsigned short*)(&cmd_to_fci));
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+/*
+ * @defgroup    localdata_bd  [localdata_bd]
+ * @brief:      Functions marked as [localdata_bd] guarantee that 
+ *              only local data are accessed.
+ * @details:    These functions do not make any FCI calls.
+ *              If some local data modifications are made, then after all local data changes
+ *              are done and finished, call fci_l2_bd_update() to
+ *              update configuration of the real bridge domain in the PFE.
+ */
+ 
+ 
+/*
+ * @brief          Set action to be done if unicast packet's destination MAC is
+ *                 found (hit) in a bridge domain's MAC table.
+ * @details        [localdata_bd]
+ * @param[in,out]  p_bd  Local data to be modified.
+ *                       Initial data can be obtained via fci_l2_bd_get_by_vlan().
+ * @param[in]      hit_action   New action.
+ *                              For details about bridge domain hit/miss actions, see
+ *                              description of ucast_hit in the FCI API Reference.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_l2_bd_ld_set_ucast_hit(fpp_l2_bd_cmd_t* p_bd, uint8_t hit_action)
+{
+    assert(NULL != p_bd);
+    p_bd->ucast_hit = hit_action;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set action to be done if unicast packet's destination MAC is NOT
+ *                 found (miss) in a bridge domain's MAC table.
+ * @details        [localdata_bd]
+ * @param[in,out]  p_bd  Local data to be modified.
+ *                       Initial data can be obtained via fci_l2_bd_get_by_vlan().
+ * @param[in]      miss_action  New action.
+ *                              For details about bridge domain hit/miss actions, see
+ *                              description of ucast_hit in the FCI API Reference.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_l2_bd_ld_set_ucast_miss(fpp_l2_bd_cmd_t* p_bd, uint8_t miss_action)
+{
+    assert(NULL != p_bd);
+    p_bd->ucast_miss = miss_action;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set action to be done if multicast packet's destination MAC is 
+ *                 found (hit) in a bridge domain's MAC table.
+ * @details        [localdata_bd]
+ * @param[in,out]  p_bd  Local data to be modified.
+ *                       Initial data can be obtained via fci_l2_bd_get_by_vlan().
+ * @param[in]      hit_action   New action.
+ *                              For details about bridge domain hit/miss actions, see
+ *                              description of ucast_hit in the FCI API Reference.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_l2_bd_ld_set_mcast_hit(fpp_l2_bd_cmd_t* p_bd, uint8_t hit_action)
+{
+    assert(NULL != p_bd);
+    p_bd->mcast_hit = hit_action;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set action to be done if multicast packet's destination MAC is NOT
+ *                 found (miss) in a bridge domain's MAC table.
+ * @details        [localdata_bd]
+ * @param[in,out]  p_bd  Local data to be modified.
+ *                       Initial data can be obtained via fci_l2_bd_get_by_vlan().
+ * @param[in]      hit_action   New action.
+ *                              For details about bridge domain hit/miss actions, see
+ *                              description of ucast_hit in the FCI API Reference.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_l2_bd_ld_set_mcast_miss(fpp_l2_bd_cmd_t* p_bd, uint8_t miss_action)
+{
+    assert(NULL != p_bd);
+    p_bd->mcast_miss = miss_action;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Insert a physical interface into a bridge domain.
+ * @details        [localdata_bd]
+ * @param[in,out]  p_bd  Local data to be modified.
+ *                       Initial data can be obtained via fci_l2_bd_get_by_vlan().
+ * @param[in]      phyif_id  Physical interface ID
+ *                           IDs of physical interfaces are hardcoded.
+ *                           See the FCI API Reference, chapter Interface Management.
+ * @param[in]      add_vlan_tag  A request to tag (true) or untag (false) a traffic from 
+ *                               the given physical interface.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_l2_bd_ld_insert_phyif(fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id, bool add_vlan_tag)
+{
+    assert(NULL != p_bd);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    if (32uL > phyif_id)  /* a check to prevent undefined behavior */
+    {
+        const uint32_t phyif_bitmask = (1uL << phyif_id);
+        p_bd->if_list |= phyif_bitmask;
+        if (add_vlan_tag)  
+        {
+            /* VLAN TAG is desired == physical interface must NOT be on the untag list. */
+            p_bd->untag_if_list &= ~phyif_bitmask;
+        }
+        else
+        {
+            /* VLAN TAG is NOT desired == physical interface must be on the untag list. */
+            p_bd->untag_if_list |= phyif_bitmask;
+        }
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief          Remove given physical interface from a bridge domain.
+ * @details        [localdata_bd]
+ * @param[in,out]  p_bd  Local data to be modified.
+ *                       Initial data can be obtained via fci_l2_bd_get_by_vlan().
+ * @param[in]      phyif_id  Physical interface ID
+ *                           IDs of physical interfaces are hardcoded.
+ *                           See the FCI API Reference, chapter Interface Management.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_l2_bd_ld_remove_phyif(fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id)
+{
+    assert(NULL != p_bd);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    if (32uL > phyif_id)  /* a check to prevent undefined behavior */
+    {
+        p_bd->if_list &= (uint32_t)(~(1uL << phyif_id));
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @defgroup    localdata_stent  [localdata_stent]
+ * @brief:      Functions marked as [localdata_stent] guarantee that 
+ *              only local data are accessed.
+ * @details:    These functions do not make any FCI calls.
+ *              If some local data modifications are made, then after all local data changes
+ *              are done and finished, call fci_l2_stent_update() to
+ *              update configuration of the real static entry in the PFE.
+ */
+ 
+ 
+/*
+ * @brief          Set target physical interfaces (forwarding list) which 
+ *                 shall receive a copy of the accepted traffic.
+ * @details        [localdata_stent]
+ *                 New forwarding list fully replaces the old one.
+ * @param[in,out]  p_stent  Local data to be modified.
+ *                          Initial data can be obtained via fci_l2_stent_get_by_vlanmac().
+ * @param[in]      fwlist   Target physical interfaces (forwarding list). A bitset.
+ *                          Each physical interface is represented by one bit.
+ *                          Conversion between physical interface ID and a corresponding
+ *                          egress vector bit is (1u << "physical interface ID").
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_l2_stent_ld_set_fwlist(fpp_l2_static_ent_cmd_t* p_stent, uint32_t fwlist)
+{
+    assert(NULL != p_stent);
+    p_stent->forward_list = fwlist;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set flag 'local' in a static entry.
+ * @details        [localdata_stent]
+ * @param[in,out]  p_stent  Local data to be modified.
+ *                          Initial data can be obtained via fci_l2_stent_get_by_vlanmac().
+ * @param[in]      local    A request to set/unset the flag.
+ *                          See description of fpp_l2_static_ent_cmd_t type in 
+ *                          the FCI API reference.
+ *                          Related topic: L2L3 Bridge mode of a physical interface.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_l2_stent_ld_set_local(fpp_l2_static_ent_cmd_t* p_stent, bool local)
+{
+    assert(NULL != p_stent);
+    p_stent->local = local;  /* NOTE: Implicit cast from bool to uintX_t */
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set flag 'discard on source MAC match' in a static entry.
+ * @details        [localdata_stent]
+ * @param[in,out]  p_stent  Local data to be modified.
+ *                          Initial data can be obtained via fci_l2_stent_get_by_vlanmac().
+ * @param[in]      src_discard  A request to set/unset the flag.
+ *                              See description of fpp_l2_static_ent_cmd_t type in 
+ *                              the FCI API reference.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_l2_stent_ld_set_src_discard(fpp_l2_static_ent_cmd_t* p_stent, bool src_discard)
+{
+    assert(NULL != p_stent);
+    p_stent->src_discard = src_discard;  /* NOTE: Implicit cast from bool to uintX_t */
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set flag 'discard on destination MAC match' in a static entry.
+ * @details        [localdata_stent]
+ * @param[in,out]  p_stent  Local data to be modified.
+ *                          Initial data can be obtained via fci_l2_stent_get_by_vlanmac().
+ * @param[in]      dst_discard  A request to set/unset the flag.
+ *                              See description of fpp_l2_static_ent_cmd_t type in 
+ *                              the FCI API reference.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_l2_stent_ld_set_dst_discard(fpp_l2_static_ent_cmd_t* p_stent, bool dst_discard)
+{
+    assert(NULL != p_stent);
+    p_stent->dst_discard = dst_discard;  /* NOTE: Implicit cast from bool to uintX_t */
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+ 
+ 
+/*
+ * @brief      Query status of a "default" flag.
+ * @details    [localdata_bd]
+ * @param[in]  p_bd  Local data to be queried.
+ *                   Initial data can be obtained via fci_l2_bd_get_by_vlan().
+ * @return     At time when the data was obtained, the bridge domain:
+ *             true  : was set as a default domain.
+ *             false : was NOT set as a default domain.
+ */
+bool fci_l2_bd_ld_is_default(const fpp_l2_bd_cmd_t* p_bd)
+{
+    assert(NULL != p_bd);
+    return (bool)(FPP_L2_BD_DEFAULT & (p_bd->flags));
+}
+ 
+ 
+/*
+ * @brief      Query status of a "fallback" flag.
+ * @details    [localdata_bd]
+ * @param[in]  p_bd  Local data to be queried.
+ *                   Initial data can be obtained via fci_l2_bd_get_by_vlan().
+ * @return     At time when the data was obtained, the bridge domain:
+ *             true  : was set as a fallback domain.
+ *             false : was NOT set as a fallback domain.
+ */
+bool fci_l2_bd_ld_is_fallback(const fpp_l2_bd_cmd_t* p_bd)
+{
+    assert(NULL != p_bd);
+    return (bool)(FPP_L2_BD_FALLBACK & (p_bd->flags));
+}
+ 
+ 
+/*
+ * @brief      Query whether the given physical interface is a member of a bridge domain.
+ * @details    [localdata_bd]
+ * @param[in]  p_bd      Local data to be queried.
+ *                       Initial data can be obtained via fci_l2_bd_get_by_vlan().
+ * @param[in]  phyif_id  phyif_id  Physical interface ID
+ *                       IDs of physical interfaces are hardcoded.
+ *                       See the FCI API Reference, chapter Interface Management.
+ * @return     At time when the data was obtained, the given physical interface:
+ *             true  : was a member of the given bridge domain.
+ *             false : was NOT a member of the given bridge domain.
+ */
+bool fci_l2_bd_ld_is_phyif(const fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id)
+{
+    assert(NULL != p_bd);
+    bool rtn = false;
+    if (32uL > phyif_id)
+    {
+        rtn = (bool)((1uL << phyif_id) & (p_bd->if_list));
+    }
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Query whether the requested physical interface is 
+ *             tagged by the bridge domain (or not).
+ * @details    [localdata_bd]
+ * @param[in]  p_bd      Local data to be queried.
+ *                       Initial data can be obtained via fci_l2_bd_get_by_vlan().
+ * @param[in]  phyif_id  Physical interface ID
+ *                       IDs of physical interfaces are hardcoded.
+ *                       See the FCI API Reference, chapter Interface Management.
+ * @return     At time when the data was obtained, the requested physical interface:
+ *             true  : was being tagged by the given bridge domain.
+ *             false : was NOT being tagged by the given bridge domain.
+ */
+bool fci_l2_bd_ld_is_tagged(const fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id)
+{
+    assert(NULL != p_bd);
+    bool rtn = false;
+    if (32uL > phyif_id)
+    {
+        rtn = (bool)(!((1uL << phyif_id) & (p_bd->untag_if_list)));
+    }
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Query whether a physical interface is a member of 
+ *             the static entry's forwarding list or not.
+ * @details    [localdata_stent]
+ * @param[in]  p_stent  Local data to be queried.
+ *                      Initial data can be obtained via fci_l2_stent_get_by_vlanmac().
+ * @param[in]  fwlist_bitflag  Queried physical interface. A bitflag.
+ *                             Each physical interface is represented by one bit.
+ *                             Conversion between physical interface ID and a corresponding
+ *                             fwlist bit is (1u << "physical interface ID").
+ *                             Hint: It is recommended to always query only a single bitflag.
+ * @return     At time when the data was obtained, the logical interface:
+ *             true  : had at least one queried forward list bitflag set
+ *             false : had none of the queried forward list bitflags set
+ */
+bool fci_l2_stent_ld_is_fwlist_phyifs(const fpp_l2_static_ent_cmd_t* p_stent,
+                                      uint32_t fwlist_bitflag)
+{
+    assert(NULL != p_stent);
+    return (bool)(fwlist_bitflag & (p_stent->forward_list));
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all bridge domains in the PFE and
+ *             execute a callback print function for each reported bridge domain.
+ * @param[in]  p_cl        FCI client instance
+ * @param[in]  p_cb_print  Callback print function.
+ *                         --> If the callback returns zero, then all is OK and 
+ *                             the next bridge domain is picked for a print process.
+ *                         --> If the callback returns non-zero, then some problem is 
+ *                             assumed and this function terminates prematurely.
+ * @return     FPP_ERR_OK : Successfully iterated through all bridge domains.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_l2_bd_print_all(FCI_CLIENT* p_cl, fci_l2_bd_cb_print_t p_cb_print)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_l2_bd_cmd_t cmd_to_fci = {0};
+    fpp_l2_bd_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_L2_BD,
+                    sizeof(fpp_l2_bd_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    ntoh_bd(&reply_from_fci);  /* set correct byte order */
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        rtn = p_cb_print(&reply_from_fci);
+        
+        if (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+            rtn = fci_query(p_cl, FPP_CMD_L2_BD,
+                            sizeof(fpp_l2_bd_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            ntoh_bd(&reply_from_fci);  /* set correct byte order */
+        }
+    }
+    
+    /* query loop runs till there are no more bridge domains to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_L2_BD_NOT_FOUND == rtn)
+    {
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all available bridge domains in the PFE.
+ * @param[in]   p_cl         FCI client instance
+ * @param[out]  p_rtn_count  Space to store the count of bridge domains.
+ * @return      FPP_ERR_OK : Successfully counted bridge domains.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No value copied.
+ */
+int fci_l2_bd_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_count);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_l2_bd_cmd_t cmd_to_fci = {0};
+    fpp_l2_bd_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    uint16_t count = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_L2_BD,
+                    sizeof(fpp_l2_bd_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    /* no need to set correct byte order (we are just counting bridge domains) */
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        count++;
+        
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_L2_BD,
+                        sizeof(fpp_l2_bd_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        /* no need to set correct byte order (we are just counting bridge domains) */
+    }
+    
+    /* query loop runs till there are no more bridge domains to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_L2_BD_NOT_FOUND == rtn)
+    {
+        *p_rtn_count = count;
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all static entries in the PFE and
+ *             execute a callback print function for each reported static entry.
+ * @param[in]  p_cl        FCI client instance
+ * @param[in]  p_cb_print  Callback print function.
+ *                         --> If the callback returns zero, then all is OK and 
+ *                             the next static entry is picked for a print process.
+ *                         --> If the callback returns non-zero, then some problem is 
+ *                             assumed and this function terminates prematurely.
+ * @return     FPP_ERR_OK : Successfully iterated through all static entries.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_l2_stent_print_all(FCI_CLIENT* p_cl, fci_l2_stent_cb_print_t p_cb_print)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_l2_static_ent_cmd_t cmd_to_fci = {0};
+    fpp_l2_static_ent_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
+                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    ntoh_stent(&reply_from_fci);  /* set correct byte order */
+    
+    /*  query loop  */
+    while (FPP_ERR_OK == rtn)
+    {
+        rtn = p_cb_print(&reply_from_fci);
+        
+        if (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+            rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
+                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+            ntoh_stent(&reply_from_fci);  /* set correct byte order */
+        }
+    }
+    
+    /* query loop runs till there are no more sttic entries to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_L2_STATIC_EN_NOT_FOUND == rtn)
+    {
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all static entries in the PFE which
+ *             are children of a given bridge domain. Execute a print function
+ *             for each reported static entry.
+ * @param[in]  p_cl        FCI client instance
+ * @param[in]  p_cb_print  Callback print function.
+ *                         --> If the callback returns zero, then all is OK and 
+ *                             the next static entry is picked for a print process.
+ *                         --> If the callback returns non-zero, then some problem is 
+ *                             assumed and this function terminates prematurely.
+ * @param[in]  vlan        VLAN ID of the parent bridge domain.
+ * @return     FPP_ERR_OK : Successfully iterated through all suitable static entries.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_l2_stent_print_by_vlan(FCI_CLIENT* p_cl, fci_l2_stent_cb_print_t p_cb_print, 
+                               uint16_t vlan)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_l2_static_ent_cmd_t cmd_to_fci = {0};
+    fpp_l2_static_ent_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
+                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    ntoh_stent(&reply_from_fci);  /* set correct byte order */
+    
+    /*  query loop  */
+    while (FPP_ERR_OK == rtn)
+    {
+        if (vlan == (reply_from_fci.vlan))
+        {
+            rtn = p_cb_print(&reply_from_fci);
+        }
+        
+        if (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+            rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
+                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+            ntoh_stent(&reply_from_fci);  /* set correct byte order */
+        }
+    }
+    
+    /* query loop runs till there are no more sttic entries to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_L2_STATIC_EN_NOT_FOUND == rtn)
+    {
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all available static entries in the PFE.
+ * @param[in]   p_cl         FCI client instance
+ * @param[out]  p_rtn_count  Space to store the count of static entries.
+ * @return      FPP_ERR_OK : Successfully counted static entries.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No value copied.
+ */
+int fci_l2_stent_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_count);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_l2_static_ent_cmd_t cmd_to_fci = {0};
+    fpp_l2_static_ent_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    uint16_t count = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
+                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    /* no need to set correct byte order (we are just counting static entries) */
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        count++;
+        
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
+                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+        /* no need to set correct byte order (we are just counting static entries) */
+    }
+    
+    /* query loop runs till there are no more sttic entries to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_L2_STATIC_EN_NOT_FOUND == rtn)
+    {
+        *p_rtn_count = count;
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all available static entries in the PFE which
+ *              are children of a given parent bridge domain.
+ * @param[in]   p_cl         FCI client instance
+ * @param[out]  p_rtn_count  Space to store the count of static entries.
+ * @param[in]   vlan         VLAN ID of the parent bridge domain.
+ * @return      FPP_ERR_OK : Successfully counted static entries.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No value copied.
+ */
+int fci_l2_stent_get_count_by_vlan(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, uint16_t vlan)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_count);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_l2_static_ent_cmd_t cmd_to_fci = {0};
+    fpp_l2_static_ent_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    uint16_t count = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
+                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    /* no need to set correct byte order (we are just counting static entries) */
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        if (vlan == ntohs(reply_from_fci.vlan))  /* NOTE: vlan needs correct byte order */
+        {
+            count++;
+        }
+        
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
+                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+        /* no need to set correct byte order (we are just counting static entries) */
+    }
+    
+    /* query loop runs till there are no more sttic entries to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_L2_STATIC_EN_NOT_FOUND == rtn)
+    {
+        *p_rtn_count = count;
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_interface/fci_l2_bd.h b/sw/libfci_cli/src/libfci_interface/fci_l2_bd.h
new file mode 100644
index 0000000..4baf9b1
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_interface/fci_l2_bd.h
@@ -0,0 +1,92 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef FCI_L2_BD_H_
+#define FCI_L2_BD_H_
+
+#include "fpp_ext.h"
+#include "libfci.h"
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+typedef int (*fci_l2_bd_cb_print_t)(const fpp_l2_bd_cmd_t* p_bd);
+typedef int (*fci_l2_stent_cb_print_t)(const fpp_l2_static_ent_cmd_t* p_stent);
+
+#define FCI_L2_BD_ACTION_FORWARD  (0u)
+#define FCI_L2_BD_ACTION_FLOOD    (1u)
+#define FCI_L2_BD_ACTION_PUNT     (2u)
+#define FCI_L2_BD_ACTION_DISCARD  (3u)
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
+
+int fci_l2_bd_get_by_vlan(FCI_CLIENT* p_cl, fpp_l2_bd_cmd_t* p_rtn_bd, uint16_t vlan);
+
+int fci_l2_stent_get_by_vlanmac(FCI_CLIENT* p_cl, fpp_l2_static_ent_cmd_t* p_rtn_stent,
+                                uint16_t vlan, const uint8_t p_mac[6]);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
+
+int fci_l2_bd_update(FCI_CLIENT* p_cl, fpp_l2_bd_cmd_t* p_bd);
+
+int fci_l2_stent_update(FCI_CLIENT* p_cl, fpp_l2_static_ent_cmd_t* p_stent);
+
+int fci_l2_flush_static(FCI_CLIENT* p_cl);
+int fci_l2_flush_learned(FCI_CLIENT* p_cl);
+int fci_l2_flush_all(FCI_CLIENT* p_cl);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in the PFE ======= */
+
+int fci_l2_bd_add(FCI_CLIENT* p_cl, fpp_l2_bd_cmd_t* p_rtn_bd, uint16_t vlan);
+int fci_l2_bd_del(FCI_CLIENT* p_cl, uint16_t vlan);
+
+int fci_l2_stent_add(FCI_CLIENT* p_cl, fpp_l2_static_ent_cmd_t* p_rtn_stent, uint16_t vlan, const uint8_t p_mac[6]);
+int fci_l2_stent_del(FCI_CLIENT* p_cl, uint16_t vlan, const uint8_t p_mac[6]);
+
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+
+int fci_l2_bd_ld_set_ucast_hit(fpp_l2_bd_cmd_t* p_bd, uint8_t action);
+int fci_l2_bd_ld_set_ucast_miss(fpp_l2_bd_cmd_t* p_bd, uint8_t action);
+int fci_l2_bd_ld_set_mcast_hit(fpp_l2_bd_cmd_t* p_bd, uint8_t action);
+int fci_l2_bd_ld_set_mcast_miss(fpp_l2_bd_cmd_t* p_bd, uint8_t action);
+int fci_l2_bd_ld_insert_phyif(fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id, bool add_vlan_tag);
+int fci_l2_bd_ld_remove_phyif(fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id);
+
+int fci_l2_stent_ld_set_fwlist(fpp_l2_static_ent_cmd_t* p_stent, uint32_t fwlist);
+int fci_l2_stent_ld_set_local(fpp_l2_static_ent_cmd_t* p_stent, bool local);
+int fci_l2_stent_ld_set_src_discard(fpp_l2_static_ent_cmd_t* p_stent, bool src_discard);
+int fci_l2_stent_ld_set_dst_discard(fpp_l2_static_ent_cmd_t* p_stent, bool dst_discard);
+
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+
+bool fci_l2_bd_ld_is_default(const fpp_l2_bd_cmd_t* p_bd);
+bool fci_l2_bd_ld_is_fallback(const fpp_l2_bd_cmd_t* p_bd);
+bool fci_l2_bd_ld_is_phyif(const fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id);
+bool fci_l2_bd_ld_is_tagged(const fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id);
+
+bool fci_l2_stent_ld_is_fwlist_phyifs(const fpp_l2_static_ent_cmd_t* p_stent, uint32_t fwlist_bitflag);
+
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+
+int fci_l2_bd_print_all(FCI_CLIENT* p_cl, fci_l2_bd_cb_print_t p_cb_print);
+int fci_l2_bd_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count);
+
+int fci_l2_stent_print_all(FCI_CLIENT* p_cl, fci_l2_stent_cb_print_t p_cb_print);
+int fci_l2_stent_print_by_vlan(FCI_CLIENT* p_cl, fci_l2_stent_cb_print_t p_cb_print, uint16_t vlan);
+int fci_l2_stent_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count);
+int fci_l2_stent_get_count_by_vlan(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, uint16_t vlan);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_interface/fci_log_if.c b/sw/libfci_cli/src/libfci_interface/fci_log_if.c
new file mode 100644
index 0000000..e13cf7a
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_interface/fci_log_if.c
@@ -0,0 +1,1715 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <string.h>
+#include <arpa/inet.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+#include "fci_common.h"
+#include "fci_log_if.h"
+ 
+ 
+/* ==== PRIVATE FUNCTIONS ================================================== */
+ 
+ 
+/*
+ * @brief          Network-to-host (ntoh) function for a logical interface struct.
+ * @param[in,out]  p_rtn_logif  The logical interface struct to be converted.
+ */
+static void ntoh_logif(fpp_log_if_cmd_t* p_rtn_logif)
+{
+    assert(NULL != p_rtn_logif);
+    
+    
+    p_rtn_logif->id = ntohl(p_rtn_logif->id);
+    p_rtn_logif->parent_id = ntohl(p_rtn_logif->parent_id);
+    p_rtn_logif->egress = ntohl(p_rtn_logif->egress);
+    ntoh_enum(&(p_rtn_logif->flags), sizeof(fpp_if_flags_t));
+    ntoh_enum(&(p_rtn_logif->match), sizeof(fpp_if_m_rules_t));
+    
+    p_rtn_logif->arguments.vlan = ntohs(p_rtn_logif->arguments.vlan);
+    p_rtn_logif->arguments.ethtype = ntohs(p_rtn_logif->arguments.ethtype);
+    p_rtn_logif->arguments.sport = ntohs(p_rtn_logif->arguments.sport);
+    p_rtn_logif->arguments.dport = ntohs(p_rtn_logif->arguments.dport);
+    p_rtn_logif->arguments.ipv.v4.sip = ntohl(p_rtn_logif->arguments.ipv.v4.sip);
+    p_rtn_logif->arguments.ipv.v4.dip = ntohl(p_rtn_logif->arguments.ipv.v4.dip);
+    p_rtn_logif->arguments.ipv.v6.sip[0] = ntohl(p_rtn_logif->arguments.ipv.v6.sip[0]);
+    p_rtn_logif->arguments.ipv.v6.sip[1] = ntohl(p_rtn_logif->arguments.ipv.v6.sip[1]);
+    p_rtn_logif->arguments.ipv.v6.sip[2] = ntohl(p_rtn_logif->arguments.ipv.v6.sip[2]);
+    p_rtn_logif->arguments.ipv.v6.sip[3] = ntohl(p_rtn_logif->arguments.ipv.v6.sip[3]);
+    p_rtn_logif->arguments.ipv.v6.dip[0] = ntohl(p_rtn_logif->arguments.ipv.v6.dip[0]);
+    p_rtn_logif->arguments.ipv.v6.dip[1] = ntohl(p_rtn_logif->arguments.ipv.v6.dip[1]);
+    p_rtn_logif->arguments.ipv.v6.dip[2] = ntohl(p_rtn_logif->arguments.ipv.v6.dip[2]);
+    p_rtn_logif->arguments.ipv.v6.dip[3] = ntohl(p_rtn_logif->arguments.ipv.v6.dip[3]);
+    p_rtn_logif->arguments.hif_cookie = ntohl(p_rtn_logif->arguments.hif_cookie);
+    
+    p_rtn_logif->stats.processed = ntohl(p_rtn_logif->stats.processed);
+    p_rtn_logif->stats.accepted = ntohl(p_rtn_logif->stats.accepted);
+    p_rtn_logif->stats.rejected = ntohl(p_rtn_logif->stats.rejected);
+    p_rtn_logif->stats.discarded = ntohl(p_rtn_logif->stats.discarded);
+}
+ 
+ 
+/*
+ * @brief          Host-to-network (hton) function for a logical interface struct.
+ * @param[in,out]  p_rtn_logif  The logical interface struct to be converted.
+ */
+static void hton_logif(fpp_log_if_cmd_t* p_rtn_logif)
+{
+    assert(NULL != p_rtn_logif);
+    
+    
+    p_rtn_logif->id = htonl(p_rtn_logif->id);
+    p_rtn_logif->parent_id = htonl(p_rtn_logif->parent_id);
+    p_rtn_logif->egress = htonl(p_rtn_logif->egress);
+    hton_enum(&(p_rtn_logif->flags), sizeof(fpp_if_flags_t));
+    hton_enum(&(p_rtn_logif->match), sizeof(fpp_if_m_rules_t));
+    
+    p_rtn_logif->arguments.vlan = htons(p_rtn_logif->arguments.vlan);
+    p_rtn_logif->arguments.ethtype = htons(p_rtn_logif->arguments.ethtype);
+    p_rtn_logif->arguments.sport = htons(p_rtn_logif->arguments.sport);
+    p_rtn_logif->arguments.dport = htons(p_rtn_logif->arguments.dport);
+    p_rtn_logif->arguments.ipv.v4.sip = htonl(p_rtn_logif->arguments.ipv.v4.sip);
+    p_rtn_logif->arguments.ipv.v4.dip = htonl(p_rtn_logif->arguments.ipv.v4.dip);
+    p_rtn_logif->arguments.ipv.v6.sip[0] = htonl(p_rtn_logif->arguments.ipv.v6.sip[0]);
+    p_rtn_logif->arguments.ipv.v6.sip[1] = htonl(p_rtn_logif->arguments.ipv.v6.sip[1]);
+    p_rtn_logif->arguments.ipv.v6.sip[2] = htonl(p_rtn_logif->arguments.ipv.v6.sip[2]);
+    p_rtn_logif->arguments.ipv.v6.sip[3] = htonl(p_rtn_logif->arguments.ipv.v6.sip[3]);
+    p_rtn_logif->arguments.ipv.v6.dip[0] = htonl(p_rtn_logif->arguments.ipv.v6.dip[0]);
+    p_rtn_logif->arguments.ipv.v6.dip[1] = htonl(p_rtn_logif->arguments.ipv.v6.dip[1]);
+    p_rtn_logif->arguments.ipv.v6.dip[2] = htonl(p_rtn_logif->arguments.ipv.v6.dip[2]);
+    p_rtn_logif->arguments.ipv.v6.dip[3] = htonl(p_rtn_logif->arguments.ipv.v6.dip[3]);
+    p_rtn_logif->arguments.hif_cookie = htonl(p_rtn_logif->arguments.hif_cookie);
+    
+    p_rtn_logif->stats.processed = htonl(p_rtn_logif->stats.processed);
+    p_rtn_logif->stats.accepted = htonl(p_rtn_logif->stats.accepted);
+    p_rtn_logif->stats.rejected = htonl(p_rtn_logif->stats.rejected);
+    p_rtn_logif->stats.discarded = htonl(p_rtn_logif->stats.discarded);
+}
+ 
+ 
+/*
+ * @brief       Set/unset a bitflag in a logical interface struct.
+ * @param[out]  p_rtn_logif  The logical interface struct to be modified.
+ * @param[in]   enable  New state of the bitflag.
+ * @param[in]   flag    The bitflag.
+ */
+static void set_flag(fpp_log_if_cmd_t* p_rtn_logif, bool enable,
+                     fpp_if_flags_t flag)
+{
+    assert(NULL != p_rtn_logif);
+    
+    
+    if (enable)
+    {
+        p_rtn_logif->flags |= flag;
+    }
+    else
+    {
+        p_rtn_logif->flags &= (fpp_if_flags_t)(~flag);
+    }
+}
+ 
+ 
+/*
+ * @brief       Set/unset a match rule bitflag in a logical interface stuct.
+ * @param[out]  p_rtn_logif  The logical interface struct to be modified.
+ * @param[in]   enable       New state of the bitflag.
+ * @param[in]   match_rule   The match rule bitflag.
+ */
+static void set_mr_flag(fpp_log_if_cmd_t* p_rtn_logif, bool enable,
+                        fpp_if_m_rules_t match_rule)
+{
+    assert(NULL != p_rtn_logif);
+    
+    
+    if (enable)
+    {
+        p_rtn_logif->match |= match_rule;
+    }
+    else
+    {
+        p_rtn_logif->match &= (fpp_if_flags_t)(~match_rule);
+    }
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested logical interface
+ *              from the PFE. Identify the interface by its name.
+ * @details     To use this function properly, the PFE interface database must be
+ *              locked for exclusive access. See fci_log_if_get_by_name_sa() for 
+ *              an example how to lock the database.
+ * @param[in]   p_cl         FCI client instance
+ * @param[out]  p_rtn_logif  Space for data from the PFE.
+ * @param[in]   p_name       Name of the requested logical interface.
+ *                           Names of logical interfaces are user-defined.
+ *                           See fci_log_if_add().
+ * @return      FPP_ERR_OK : Requested logical interface was found.
+ *                           A copy of its configuration was stored into p_rtn_logif.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No data copied.
+ */
+int fci_log_if_get_by_name(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, 
+                           const char* p_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_logif);
+    assert(NULL != p_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_log_if_cmd_t cmd_to_fci = {0};
+    fpp_log_if_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
+                    sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    ntoh_logif(&reply_from_fci);  /* set correct byte order */
+    
+    /* query loop (with the search condition) */
+    while ((FPP_ERR_OK == rtn) && (strcmp(p_name, reply_from_fci.name)))
+    {
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
+                        sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        ntoh_logif(&reply_from_fci);  /* set correct byte order */
+    }
+    
+    /* if search successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_logif = reply_from_fci;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested logical interface
+ *              from the PFE. Identify the interface by its name.
+ * @details     This is a standalone (_sa) function.
+ *              It shows how to properly access a logical interface. Namely:
+ *              1. Lock the interface database for exclusive access by this FCI client.
+ *              2. Execute one or more FCI calls which access 
+ *                 physical or logical interfaces.
+ *              3. Unlock the interface database's exclusive access lock.
+ * @param[in]   p_cl         FCI client instance
+ * @param[out]  p_rtn_logif  Space for data from the PFE.
+ * @param[in]   p_name       Name of the requested logical interface.
+ *                           Names of logical interfaces are user-defined.
+ *                           See fci_log_if_add().
+ * @return      FPP_ERR_OK : Requested logical interface was found.
+ *                           A copy of its configuration was stored into p_rtn_logif.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No data copied.
+ */
+inline int fci_log_if_get_by_name_sa(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, 
+                                     const char* p_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_logif);
+    assert(NULL != p_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    /* lock the interface database for exclusive access by this FCI client */
+    rtn = fci_write(p_cl, FPP_CMD_IF_LOCK_SESSION, 0, NULL);
+    
+    /* execute "payload" - FCI calls which access physical or logical interfaces */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_log_if_get_by_name(p_cl, p_rtn_logif, p_name);
+    }
+    
+    /* unlock the interface database's exclusive access lock */
+    /* result of the unlock action is returned only if previous "payload" actions were OK */
+    const int rtn_unlock = fci_write(p_cl, FPP_CMD_IF_UNLOCK_SESSION, 0, NULL);
+    rtn = ((FPP_ERR_OK == rtn) ? (rtn_unlock) : (rtn));
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested logical interface
+ *              from the PFE. Identify the interface by its ID.
+ * @details     To use this function properly, the PFE interface database must be
+ *              locked for exclusive access. See fci_log_if_get_by_name_sa() for 
+ *              an example how to lock the database.
+ * @param[in]   p_cl         FCI client instance
+ * @param[out]  p_rtn_logif  Space for data from the PFE.
+ * @param[in]   id           ID of the requested logical interface.
+ *                           IDs of logical interfaces are assigned automatically.
+ *                           Hint: It is better to identify logical interfaces by 
+ *                                 their interface names.
+ * @return      FPP_ERR_OK : Requested logical interface was found.
+ *                           A copy of its configuration was stored into p_rtn_logif.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No data copied.
+ */
+int fci_log_if_get_by_id(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, uint32_t id)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_logif);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_log_if_cmd_t cmd_to_fci = {0};
+    fpp_log_if_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
+                    sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    ntoh_logif(&reply_from_fci);  /* set correct byte order */
+    
+    /* query loop */
+    while ((FPP_ERR_OK == rtn) && (id != (reply_from_fci.id)))
+    {
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
+                        sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        ntoh_logif(&reply_from_fci);  /* set correct byte order */
+    }
+    
+    /* if search successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_logif = reply_from_fci;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
+ 
+ 
+/*
+ * @brief          Use FCI calls to update configuration of a target logical interface 
+ *                 in the PFE.
+ * @details        To use this function properly, the PFE interface database must be
+ *                 locked for exclusive access. See fci_log_if_update_sa() for 
+ *                 an example how to lock the database.
+ * @param[in]      p_cl     FCI client instance
+ * @param[in,out]  p_logif  Data struct which represents a new configuration of
+ *                          the target logical interface.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @return         FPP_ERR_OK : Configuration of the target logical interface was
+ *                              successfully updated in the PFE.
+ *                              Local data struct was automatically updated with 
+ *                              readback data from the PFE.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data struct not updated.
+ */
+int fci_log_if_update(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_logif);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_log_if_cmd_t cmd_to_fci = (*p_logif);
+    
+    /* send data */
+    hton_logif(&cmd_to_fci);  /* set correct byte order */
+    cmd_to_fci.action = FPP_ACTION_UPDATE;
+    rtn = fci_write(p_cl, FPP_CMD_LOG_IF, sizeof(fpp_log_if_cmd_t), 
+                                         (unsigned short*)(&cmd_to_fci));
+    
+    /* read back and update caller data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_log_if_get_by_id(p_cl, p_logif, (p_logif->id));
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief          Use FCI calls to update configuration of a target logical interface 
+ *                 in the PFE.
+ * @details        This is a standalone (_sa) function.
+ *                 It shows how to properly access a logical interface. Namely:
+ *                 1. Lock the interface database for exclusive access by this FCI client.
+ *                 2. Execute one or more FCI calls which access 
+ *                    physical or logical interfaces.
+ *                 3. Unlock the interface database's exclusive access lock.
+ * @param[in]      p_cl     FCI client instance
+ * @param[in,out]  p_logif  Data struct which represents a new configuration of
+ *                          the target logical interface.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @return         FPP_ERR_OK : Configuration of the target logical interface was
+ *                              successfully updated in the PFE.
+ *                              Local data struct was automatically updated with 
+ *                              readback data from the PFE.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data struct not updated.
+ */
+inline int fci_log_if_update_sa(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_logif);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    /* lock the interface database for exclusive access by this FCI client */
+    rtn = fci_write(p_cl, FPP_CMD_IF_LOCK_SESSION, 0, NULL);
+    
+    /* execute "payload" - FCI calls which access physical or logical interfaces */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_log_if_update(p_cl, p_logif);
+    }
+    
+    /* unlock the interface database's exclusive access lock */
+    /* result of the unlock action is returned only if previous "payload" actions were OK */
+    const int rtn_unlock = fci_write(p_cl, FPP_CMD_IF_UNLOCK_SESSION, 0, NULL);
+    rtn = ((FPP_ERR_OK == rtn) ? (rtn_unlock) : (rtn));
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in the PFE ======= */
+ 
+ 
+/*
+ * @brief       Use FCI calls to create a new logical interface in the PFE.
+ * @details     To use this function properly, the PFE interface database must be
+ *              locked for exclusive access. See fci_log_if_update_sa() for 
+ *              an example how to lock the database.
+ * @param[in]   p_cl           FCI client instance
+ * @param[out]  p_rtn_logif    Space for data from the PFE.
+ *                             Will contain a copy of configuration data of 
+ *                             the newly created logical interface.
+ *                             Can be NULL. If NULL, then there is no local data to fill.
+ * @param[in]   p_name         Name of the new logical interface.
+ *                             The name is user-defined.
+ * @param[in]   p_parent_name  Name of a parent physical interface.
+ *                             Names of physical interfaces are hardcoded.
+ *                             See the FCI API Reference, chapter Interface Management.
+ * @return      FPP_ERR_OK : New logical interface was created.
+ *                           If applicable, then its configuration data were 
+ *                           copied into p_rtn_logif.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No data copied.
+ */
+int fci_log_if_add(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, const char* p_name, 
+                   const char* p_parent_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_name);
+    assert(NULL != p_parent_name);
+    /* 'p_rtn_logif' is allowed to be NULL */
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_log_if_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    rtn = set_text((cmd_to_fci.name), p_name, IFNAMSIZ);
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = set_text((cmd_to_fci.parent_name), p_parent_name, IFNAMSIZ);
+    }
+    
+    /* send data */
+    if (FPP_ERR_OK == rtn)
+    {
+        hton_logif(&cmd_to_fci);  /* set correct byte order */
+        cmd_to_fci.action = FPP_ACTION_REGISTER;
+        rtn = fci_write(p_cl, FPP_CMD_LOG_IF, sizeof(fpp_log_if_cmd_t), 
+                                             (unsigned short*)(&cmd_to_fci));
+    }
+    
+    /* read back and update caller data (if applicable) */
+    if ((FPP_ERR_OK == rtn) && (NULL != p_rtn_logif))
+    {
+        rtn = fci_log_if_get_by_name(p_cl, p_rtn_logif, p_name);
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Use FCI calls to destroy the target logical interface in the PFE.
+ * @details    To use this function properly, the PFE interface database must be
+ *             locked for exclusive access. See fci_log_if_update_sa() for 
+ *             an example how to lock the database.
+ * @param[in]  p_cl    FCI client instance
+ * @param[in]  p_name  Name of the logical interface to destroy.
+ * @return     FPP_ERR_OK : Logical interface was destroyed.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_log_if_del(FCI_CLIENT* p_cl, const char* p_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_log_if_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    rtn = set_text((cmd_to_fci.name), p_name, IFNAMSIZ);
+    
+    /* send data */
+    if (FPP_ERR_OK == rtn)
+    {
+        hton_logif(&cmd_to_fci);  /* set correct byte order */
+        cmd_to_fci.action = FPP_ACTION_DEREGISTER;
+        rtn = fci_write(p_cl, FPP_CMD_LOG_IF, sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci));
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+/*
+ * @defgroup    localdata_logif  [localdata_logif]
+ * @brief:      Functions marked as [localdata_logif] guarantee that 
+ *              only local data are accessed.
+ * @details:    These functions do not make any FCI calls.
+ *              If some local data modifications are made, then after all local data changes
+ *              are done and finished, call fci_log_if_update() or fci_log_if_update_sa() to
+ *              update configuration of the real logical interface in the PFE.
+ */
+ 
+ 
+/*
+ * @brief          Enable ("up") a logical interface.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or 
+ *                          fci_log_if_get_by_id().
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_enable(fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    p_logif->flags |= FPP_IF_ENABLED;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Disable ("down") a logical interface.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or 
+ *                          fci_log_if_get_by_id().
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_disable(fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    p_logif->flags &= (fpp_if_flags_t)(~FPP_IF_ENABLED);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset promiscuous mode of a logical interface.
+ * @details        [localdata_logif]
+ *                 Promiscuous mode of a logical interface means the interface
+ *                 will accept all incoming traffic, regardless of active match rules.
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or 
+ *                          fci_log_if_get_by_id().
+ * @param[in]      promisc  A request to set/unset the promiscuous mode.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_promisc(fpp_log_if_cmd_t* p_logif, bool promisc)
+{
+    assert(NULL != p_logif);
+    set_flag(p_logif, promisc, FPP_IF_PROMISC);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset loopback mode of a logical interface.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif   Local data to be modified.
+ *                           Initial data can be obtained via fci_log_if_get_by_name() or 
+ *                           fci_log_if_get_by_id().
+ * @param[in]      loopback  A request to set/unset the loopback mode.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_loopback(fpp_log_if_cmd_t* p_logif, bool loopback)
+{
+    assert(NULL != p_logif);
+    set_flag(p_logif, loopback, FPP_IF_LOOPBACK);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set match mode (chaining mode of match rules).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      match_mode_is_or  A request to set match mode.
+ *                                   For details about logical interface match modes, see
+ *                                   description of a fpp_if_flags_t type in
+ *                                   the FCI API Reference.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_match_mode_or(fpp_log_if_cmd_t* p_logif, bool match_mode_is_or)
+{
+    assert(NULL != p_logif);
+    set_flag(p_logif, match_mode_is_or, FPP_IF_MATCH_OR);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset inverted mode of traffic acceptance.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      discard_on_match  A request to set/unset inverted mode.
+ *                                   For details about logical interface inverted mode, see
+ *                                   description of a fpp_if_flags_t type in
+ *                                   the FCI API Reference.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_discard_on_m(fpp_log_if_cmd_t* p_logif, bool discard_on_match)
+{
+    assert(NULL != p_logif);
+    set_flag(p_logif, discard_on_match, FPP_IF_DISCARD);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set target physical interfaces (egress vector) which 
+ *                 shall receive a copy of the accepted traffic.
+ * @details        [localdata_logif]
+ *                 New egress vector fully replaces the old one.
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      egress   Target physical interfaces (egress vector). A bitset.
+ *                          Each physical interface is represented by one bit.
+ *                          Conversion between physical interface ID and a corresponding
+ *                          egress vector bit is (1u << "physical interface ID").
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_egress_phyifs(fpp_log_if_cmd_t* p_logif, uint32_t egress)
+{
+    assert(NULL != p_logif);
+    p_logif->egress = egress;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+ 
+ 
+/*
+ * @brief          Clear all match rules and zeroify all match rule arguments.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_clear_all_mr(fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    p_logif->match = 0u;
+    memset(&(p_logif->arguments), 0, sizeof(fpp_if_m_args_t));
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_type_eth(fpp_log_if_cmd_t* p_logif, bool do_set)
+{
+    assert(NULL != p_logif);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_ETH);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_type_vlan(fpp_log_if_cmd_t* p_logif, bool do_set)
+{
+    assert(NULL != p_logif);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_VLAN);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_type_pppoe(fpp_log_if_cmd_t* p_logif, bool do_set)
+{
+    assert(NULL != p_logif);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_PPPOE);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_type_arp(fpp_log_if_cmd_t* p_logif, bool do_set)
+{
+    assert(NULL != p_logif);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_ARP);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_type_mcast(fpp_log_if_cmd_t* p_logif, bool do_set)
+{
+    assert(NULL != p_logif);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_MCAST);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_type_ip4(fpp_log_if_cmd_t* p_logif, bool do_set)
+{
+    assert(NULL != p_logif);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_IPV4);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_type_ip6(fpp_log_if_cmd_t* p_logif, bool do_set)
+{
+    assert(NULL != p_logif);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_IPV6);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_type_ipx(fpp_log_if_cmd_t* p_logif, bool do_set)
+{
+    assert(NULL != p_logif);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_IPX);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_type_bcast(fpp_log_if_cmd_t* p_logif, bool do_set)
+{
+    assert(NULL != p_logif);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_BCAST);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_type_udp(fpp_log_if_cmd_t* p_logif, bool do_set)
+{
+    assert(NULL != p_logif);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_UDP);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_type_tcp(fpp_log_if_cmd_t* p_logif, bool do_set)
+{
+    assert(NULL != p_logif);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_TCP);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_type_icmp(fpp_log_if_cmd_t* p_logif, bool do_set)
+{
+    assert(NULL != p_logif);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_ICMP);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_type_igmp(fpp_log_if_cmd_t* p_logif, bool do_set)
+{
+    assert(NULL != p_logif);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_IGMP);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (and its argument).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @param[in]      vlan     New VLAN ID for this match rule.
+ *                          When this match rule is active, is compares value of its
+ *                          'vlan' argument with value of the traffic's 'VID' field.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_vlan(fpp_log_if_cmd_t* p_logif, bool do_set, uint16_t vlan)
+{
+    assert(NULL != p_logif);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_VLAN);
+    p_logif->arguments.vlan = vlan;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (and its argument).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @param[in]      proto    New IP Protocol Number for this match rule.
+ *                          When this match rule is active, is compares value of its
+ *                          'proto' argument with value of the traffic's 'Protocol' field.
+ *                          See "IANA Assigned Internet Protocol Number":
+ *                https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_proto(fpp_log_if_cmd_t* p_logif, bool do_set, uint8_t proto)
+{
+    assert(NULL != p_logif);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_PROTO);
+    p_logif->arguments.proto = proto;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (and its argument).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @param[in]      sport    New source port value for this match rule.
+ *                          When this match rule is active, it compares value of its
+ *                          'sport' argument with value of the traffic's 'source port' field.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_sport(fpp_log_if_cmd_t* p_logif, bool do_set, uint16_t sport)
+{
+    assert(NULL != p_logif);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_SPORT);
+    p_logif->arguments.sport = sport;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (and its argument).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @param[in]      dport    New destination port value for this match rule.
+ *                          When this match rule is active, it compares value of its
+ *                          'dport' argument with value of the traffic's 
+ *                          'destination port' field.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_dport(fpp_log_if_cmd_t* p_logif, bool do_set, uint16_t dport)
+{
+    assert(NULL != p_logif);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_DPORT);
+    p_logif->arguments.dport = dport;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (and its argument).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @param[in]      p_sip6   New source IPv6 address for this match rule.
+ *                          When this match rule is active, it compares value of its
+ *                          'sip' argument with value of the traffic's 
+ *                          'source address' (applicable on IPv6 traffic only).
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_sip6(fpp_log_if_cmd_t* p_logif, bool do_set, 
+                              const uint32_t p_sip6[4])
+{
+    assert(NULL != p_logif);
+    assert(NULL != p_sip6);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_SIP6);
+    memcpy((p_logif->arguments.ipv.v6.sip), p_sip6, (4 * sizeof(uint32_t)));
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (and its argument).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @param[in]      p_dip6   New destination IPv6 address for this match rule.
+ *                          When this match rule is active, it compares value of its
+ *                          'dip' argument with value of the traffic's 
+ *                          'destination address' (applicable on IPv6 traffic only).
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_dip6(fpp_log_if_cmd_t* p_logif, bool do_set, 
+                              const uint32_t p_dip6[4])
+{
+    assert(NULL != p_logif);
+    assert(NULL != p_dip6);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_DIP6);
+    memcpy((p_logif->arguments.ipv.v6.dip), p_dip6, (4 * sizeof(uint32_t)));
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (and its argument).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @param[in]      sip      New source IPv4 address for this match rule.
+ *                          When this match rule is active, it compares value of its
+ *                          'sip' argument with value of the traffic's 
+ *                          'source address' (applicable on IPv4 traffic only).
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_sip(fpp_log_if_cmd_t* p_logif, bool do_set, uint32_t sip)
+{
+    assert(NULL != p_logif);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_SIP);
+    p_logif->arguments.ipv.v4.sip = sip;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (and its argument).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @param[in]      dip      New destination IPv4 address for this match rule.
+ *                          When this match rule is active, it compares value of its
+ *                          'dip' argument with value of the traffic's 
+ *                          'destination address' (applicable on IPv4 traffic only).
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_dip(fpp_log_if_cmd_t* p_logif, bool do_set, uint32_t dip)
+{
+    assert(NULL != p_logif);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_DIP);
+    p_logif->arguments.ipv.v4.dip = dip;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (and its argument).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @param[in]      ethtype  New EtherType number for this match rule.
+ *                          When this match rule is active, it compares value of its
+ *                          'ethtype' argument with value of the traffic's 'EtherType' field.
+ *                          See "IANA EtherType number (IEEE 802)":
+ *                https://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.xhtml
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_ethtype(fpp_log_if_cmd_t* p_logif, bool do_set, uint16_t ethtype)
+{
+    assert(NULL != p_logif);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_ETHTYPE);
+    p_logif->arguments.ethtype = ethtype;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (and its argument).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @param[in]      fp_table0_name  Name of a new FlexibleParser table for this match rule.
+ *                                 When this match rule is active, it inspects the traffic
+ *                                 according to rules listed in the referenced
+ *                                 FlexibleParser table.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_fp0(fpp_log_if_cmd_t* p_logif, bool do_set, 
+                             const char* fp_table0_name)
+{
+    assert(NULL != p_logif);
+    /* 'fp_table0_name' is allowed to be NULL */
+    
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_FP0);
+    return set_text((p_logif->arguments.fp_table0), fp_table0_name, IFNAMSIZ);
+}
+
+/*
+ * @brief          Set/unset the given match rule (and its argument).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @param[in]      fp_table0_name  Name of a new FlexibleParser table for this match rule.
+ *                                 When this match rule is active, it inspects the traffic
+ *                                 according to rules listed in the referenced
+ *                                 FlexibleParser table.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_fp1(fpp_log_if_cmd_t* p_logif, bool do_set, 
+                             const char* fp_table1_name)
+{
+    assert(NULL != p_logif);
+    /* 'fp_table1_name' is allowed to be NULL */
+    
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_FP1);
+    return set_text((p_logif->arguments.fp_table1), fp_table1_name, IFNAMSIZ);
+}
+
+/*
+ * @brief          Set/unset the given match rule (and its argument).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @param[in]      p_smac   New source MAC address for this match rule.
+ *                          When this match rule is active, it compares value of its
+ *                          'smac' argument with value of the traffic's 'source MAC' field.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_smac(fpp_log_if_cmd_t* p_logif, bool do_set, const uint8_t p_smac[6])
+{
+    assert(NULL != p_logif);
+    assert(NULL != p_smac);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_SMAC);
+    memcpy((p_logif->arguments.smac), p_smac, (6 * sizeof(uint8_t)));
+    return (FPP_ERR_OK);
+}
+
+/*
+ * @brief          Set/unset the given match rule (and its argument).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @param[in]      p_dmac   New destination MAC address for this match rule.
+ *                          When this match rule is active, it compares value of its
+ *                          'dmac' argument with value of the traffic's 
+ *                          'destination MAC' field.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_dmac(fpp_log_if_cmd_t* p_logif, bool do_set, const uint8_t p_dmac[6])
+{
+    assert(NULL != p_logif);
+    assert(NULL != p_dmac);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_DMAC);
+    memcpy((p_logif->arguments.dmac), p_dmac, (6 * sizeof(uint8_t)));
+    return (FPP_ERR_OK);
+}
+
+/*
+ * @brief          Set/unset the given match rule (and its argument).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ *                          Initial data can be obtained via fci_log_if_get_by_name() or
+ *                          fci_log_if_get_by_id().
+ * @param[in]      do_set   Request to set or unset the given match rule.
+ * @param[in]      hif_cookie  New hif cookiee value for this match rule.
+ *                             When this match rule is active, it compares value of its
+ *                            'hif_cookiee' argument with value of the hif_cookie tag.
+ *                             Hif_cookie tag is a part of internal overhead data, attached
+ *                             to the traffic by the host's driver.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_log_if_ld_set_mr_hif_cookie(fpp_log_if_cmd_t* p_logif, bool do_set, 
+                                    uint32_t hif_cookie)
+{
+    assert(NULL != p_logif);
+    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_HIF_COOKIE);
+    p_logif->arguments.hif_cookie = hif_cookie;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+ 
+ 
+/*
+ * @brief      Query status of an "enable" flag.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ *                      Initial data can be obtained via fci_log_if_get_by_name() or 
+ *                      fci_log_if_get_by_id().
+ * @return     At time when the data was obtained, the logical interface:
+ *             true  : was enabled ("up")
+ *             false : was disabled ("down")
+ */
+bool fci_log_if_ld_is_enabled(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return (bool)(FPP_IF_ENABLED & (p_logif->flags));
+}
+ 
+ 
+/*
+ * @brief      Query status of an "enable" flag (inverted logic).
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ *                      Initial data can be obtained via fci_log_if_get_by_name() or 
+ *                      fci_log_if_get_by_id().
+ * @return     At time when the data was obtained, the logical interface:
+ *             true  : was disabled ("down")
+ *             false : was enabled ("up")
+ */
+bool fci_log_if_ld_is_disabled(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return !fci_log_if_ld_is_enabled(p_logif);
+}
+ 
+ 
+/*
+ * @brief      Query status of a "promiscuous mode" flag.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ *                      Initial data can be obtained via fci_log_if_get_by_name() or 
+ *                      fci_log_if_get_by_id().
+ * @return     At time when the data was obtained, the logical interface:
+ *             true  : was in a promiscuous mode
+ *             false : was NOT in a promiscuous mode
+ */
+bool fci_log_if_ld_is_promisc(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return (bool)(FPP_IF_PROMISC & (p_logif->flags));
+}
+ 
+ 
+/*
+ * @brief      Query status of a "loopback" flag.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ *                      Initial data can be obtained via fci_log_if_get_by_name() or 
+ *                      fci_log_if_get_by_id().
+ * @return     At time when the data was obtained, the logical interface:
+ *             true  : was in a loopback mode
+ *             false : was NOT in a loopback mode
+ */
+bool fci_log_if_ld_is_loopback(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return (bool)(FPP_IF_LOOPBACK & (p_logif->flags));
+}
+ 
+ 
+/*
+ * @brief      Query status of a "match mode" flag (chaining mode of match rules).
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ *                      Initial data can be obtained via fci_log_if_get_by_name() or 
+ *                      fci_log_if_get_by_id().
+ * @return     At time when the data was obtained, the logical interface:
+ *             true  : was using OR match mode
+ *             false : was using AND match mode
+ */
+bool fci_log_if_ld_is_match_mode_or(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return (bool)(FPP_IF_MATCH_OR & (p_logif->flags));
+}
+ 
+ 
+/*
+ * @brief      Query status of a "discard on match" flag.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ *                      Initial data can be obtained via fci_log_if_get_by_name() or 
+ *                      fci_log_if_get_by_id().
+ * @return     At time when the data was obtained, the logical interface:
+ *             true  : was discarding traffic that passed matching process
+ *             false : was NOT discarding traffic that passed matching process
+ */
+bool fci_log_if_ld_is_discard_on_m(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return (bool)(FPP_IF_DISCARD & (p_logif->flags));
+}
+ 
+ 
+/*
+ * @brief      Query whether a physical interface is a member of the egress vector or not.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ *                      Initial data can be obtained via fci_log_if_get_by_name() or 
+ *                      fci_log_if_get_by_id().
+ * @param[in]  egress_bitflag  Queried physical interface. A bitflag.
+ *                             Each physical interface is represented by one bit.
+ *                             Conversion between physical interface ID and a corresponding
+ *                             egress vector bit is (1u << "physical interface ID").
+ *                             Hint: It is recommended to always query only a single bitflag.
+ * @return     At time when the data was obtained, the logical interface:
+ *             true  : had at least one queried egress bitflag set
+ *             false : had none of the queried egress bitflags set
+ */
+bool fci_log_if_ld_is_egress_phyifs(const fpp_log_if_cmd_t* p_logif, uint32_t egress_bitflag)
+{
+    assert(NULL != p_logif);
+    return (bool)(egress_bitflag & (p_logif->match));
+}
+ 
+ 
+/*
+ * @brief      Query whether a match rule is active or not.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ *                      Initial data can be obtained via fci_log_if_get_by_name() or 
+ *                      fci_log_if_get_by_id().
+ * @param[in]  match_rule  Queried match rule.
+ *                         Hint: It is recommended to always query only a single match rule.
+ * @return     At time when the data was obtained, the logical interface:
+ *             true  : had at least one queried match rule set
+ *             false : had none of the queried match rules set
+ */
+bool fci_log_if_ld_is_match_rule(const fpp_log_if_cmd_t* p_logif, fpp_if_m_rules_t match_rule)
+{
+    assert(NULL != p_logif);
+    return (bool)(match_rule & (p_logif->match));
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all logical interfaces in the PFE and
+ *             execute a callback print function for each reported logical interface.
+ * @details    To use this function properly, the PFE interface database must be
+ *             locked for exclusive access. See fci_log_if_print_all_sa() for 
+ *             an example how to lock the database.
+ * @param[in]  p_cl        FCI client instance
+ * @param[in]  p_cb_print  Callback print function.
+ *                         --> If the callback returns zero, then all is OK and 
+ *                             the next logical interface is picked for a print process.
+ *                         --> If the callback returns non-zero, then some problem is 
+ *                             assumed and this function terminates prematurely.
+ * @return     FPP_ERR_OK : Successfully iterated through all logical interfaces.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_log_if_print_all(FCI_CLIENT* p_cl, fci_log_if_cb_print_t p_cb_print)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_log_if_cmd_t cmd_to_fci = {0};
+    fpp_log_if_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
+                    sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    ntoh_logif(&reply_from_fci);  /* set correct byte order */
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        rtn = p_cb_print(&reply_from_fci);
+        
+        if (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+            rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
+                            sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            ntoh_logif(&reply_from_fci);  /* set correct byte order */
+        }
+    }
+    
+    /* query loop runs till there are no more logical interfaces to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_IF_ENTRY_NOT_FOUND == rtn)
+    {
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all logical interfaces in the PFE and
+ *             execute a callback print function for each reported logical interface.
+ * @details    This is a standalone (_sa) function.
+ *             It shows how to properly access a logical interface. Namely:
+ *             1. Lock the interface database for exclusive access by this FCI client.
+ *             2. Execute one or more FCI calls which access 
+ *                physical or logical interfaces.
+ *             3. Unlock the interface database's exclusive access lock.
+ * @param[in]  p_cl        FCI client instance
+ * @param[in]  p_cb_print  Callback print function.
+ *                         --> If the callback returns zero, then all is OK and 
+ *                             the next logical interface is picked for a print process.
+ *                         --> If the callback returns non-zero, then some problem is 
+ *                             assumed and this function terminates prematurely.
+ * @return     FPP_ERR_OK : Successfully iterated through all logical interfaces.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_log_if_print_all_sa(FCI_CLIENT* p_cl, fci_log_if_cb_print_t p_cb_print)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    /* lock the interface database for exclusive access by this FCI client */
+    rtn = fci_write(p_cl, FPP_CMD_IF_LOCK_SESSION, 0, NULL);
+    
+    /* execute "payload" - FCI calls which access physical or logical interfaces */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_log_if_print_all(p_cl, p_cb_print);
+    }
+    
+    /* unlock the interface database's exclusive access lock */
+    /* result of the unlock action is returned only if previous "payload" actions were OK */
+    const int rtn_unlock = fci_write(p_cl, FPP_CMD_IF_UNLOCK_SESSION, 0, NULL);
+    rtn = ((FPP_ERR_OK == rtn) ? (rtn_unlock) : (rtn));
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all logical interfaces in the PFE which
+ *             are children of a given parent physical interface. Execute a print function
+ *             for each reported logical interface.
+ * @details    To use this function properly, the PFE interface database must be
+ *             locked for exclusive access. See fci_log_if_print_all_sa() for 
+ *             an example how to lock the database.
+ * @param[in]  p_cl        FCI client instance
+ * @param[in]  p_cb_print  Callback print function.
+ *                         --> If the callback returns zero, then all is OK and 
+ *                             the next logical interface is picked for a print process.
+ *                         --> If the callback returns non-zero, then some problem is 
+ *                             assumed and this function terminates prematurely.
+ * @param[in]   p_parent_name  Name of a parent physical interface.
+ *                             Names of physical interfaces are hardcoded.
+ *                             See the FCI API Reference, chapter Interface Management.
+ * @return     FPP_ERR_OK : Successfully iterated through all suitable logical interfaces.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_log_if_print_by_parent(FCI_CLIENT* p_cl, fci_log_if_cb_print_t p_cb_print, 
+                               const char* p_parent_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    assert(NULL != p_parent_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_log_if_cmd_t cmd_to_fci = {0};
+    fpp_log_if_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
+                    sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    ntoh_logif(&reply_from_fci);  /* set correct byte order */
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        if (0 == strcmp((reply_from_fci.parent_name), p_parent_name))
+        {
+            rtn = p_cb_print(&reply_from_fci);
+        }
+        
+        if (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+            rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
+                            sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            ntoh_logif(&reply_from_fci);  /* set correct byte order */
+        }
+    }
+    
+    /* query loop runs till there are no more logical interfaces to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_IF_ENTRY_NOT_FOUND == rtn)
+    {
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all logical interfaces in the PFE.
+ * @details     To use this function properly, the PFE interface database must be
+ *              locked for exclusive access. See fci_log_if_print_all_sa() for 
+ *              an example how to lock the database.
+ * @param[in]   p_cl         FCI client instance
+ * @param[out]  p_rtn_count  Space to store the count of logical interfaces.
+ * @return      FPP_ERR_OK : Successfully counted logical interfaces.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No count was stored.
+ */
+int fci_log_if_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_count);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_log_if_cmd_t cmd_to_fci = {0};
+    fpp_log_if_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    uint16_t count = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
+                    sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    /* no need to set correct byte order (we are just counting interfaces) */
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        count++;
+        
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
+                        sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        /* no need to set correct byte order (we are just counting interfaces) */
+    }
+    
+    /* query loop runs till there are no more logical interfaces to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_IF_ENTRY_NOT_FOUND == rtn)
+    {
+        *p_rtn_count = count;
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all logical interfaces in the PFE which
+ *              are children of a given parent physical interface.
+ * @details     To use this function properly, the PFE interface database must be
+ *              locked for exclusive access. See fci_log_if_print_all_sa() for 
+ *              an example how to lock the database.
+ * @param[in]   p_cl           FCI client instance
+ * @param[out]  p_rtn_count    Space to store the count of logical interfaces.
+ * @param[in]   p_parent_name  Name of a parent physical interface.
+ *                             Names of physical interfaces are hardcoded.
+ *                             See the FCI API Reference, chapter Interface Management.
+ * @return      FPP_ERR_OK : Successfully counted logical interfaces.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No count was stored.
+ */
+int fci_log_if_get_count_by_parent(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, 
+                                   const char* p_parent_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_count);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_log_if_cmd_t cmd_to_fci = {0};
+    fpp_log_if_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    uint16_t count = 0u;
+    
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
+                    sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    /* no need to set correct byte order (we are just counting interfaces) */
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        if (0 == strcmp((reply_from_fci.parent_name), p_parent_name))
+        {
+            count++;
+        }
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
+                        sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        /* no need to set correct byte order (we are just counting interfaces) */
+    }
+    
+    /* query loop runs till there are no more logical interfaces to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_IF_ENTRY_NOT_FOUND == rtn)
+    {
+        *p_rtn_count = count;
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_interface/fci_log_if.h b/sw/libfci_cli/src/libfci_interface/fci_log_if.h
new file mode 100644
index 0000000..939689d
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_interface/fci_log_if.h
@@ -0,0 +1,102 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef FCI_LOG_IF_H_
+#define FCI_LOG_IF_H_
+
+#include "fpp_ext.h"
+#include "libfci.h"
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+typedef int (*fci_log_if_cb_print_t)(const fpp_log_if_cmd_t* p_logif);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
+
+int fci_log_if_get_by_name(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, const char* p_name);
+int fci_log_if_get_by_name_sa(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, const char* p_name);
+int fci_log_if_get_by_id(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, uint32_t id);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
+
+int fci_log_if_update(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_logif);
+int fci_log_if_update_sa(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_logif);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in the PFE ======= */
+
+int fci_log_if_add(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, const char* p_name, const char* p_parent_name);
+int fci_log_if_del(FCI_CLIENT* p_cl, const char* p_name);
+
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+
+int fci_log_if_ld_enable(fpp_log_if_cmd_t* p_logif);
+int fci_log_if_ld_disable(fpp_log_if_cmd_t* p_logif);
+int fci_log_if_ld_set_promisc(fpp_log_if_cmd_t* p_logif, bool promisc);
+int fci_log_if_ld_set_loopback(fpp_log_if_cmd_t* p_logif, bool loopback);
+int fci_log_if_ld_set_match_mode_or(fpp_log_if_cmd_t* p_logif, bool match_mode_is_or);
+int fci_log_if_ld_set_discard_on_m(fpp_log_if_cmd_t* p_logif, bool discard_on_match);
+int fci_log_if_ld_set_egress_phyifs(fpp_log_if_cmd_t* p_logif, uint32_t egress);
+
+int fci_log_if_ld_clear_all_mr(fpp_log_if_cmd_t* p_logif);
+int fci_log_if_ld_set_mr_type_eth(fpp_log_if_cmd_t* p_logif, bool do_set);
+int fci_log_if_ld_set_mr_type_vlan(fpp_log_if_cmd_t* p_logif, bool do_set);
+int fci_log_if_ld_set_mr_type_pppoe(fpp_log_if_cmd_t* p_logif, bool do_set);
+int fci_log_if_ld_set_mr_type_arp(fpp_log_if_cmd_t* p_logif, bool do_set);
+int fci_log_if_ld_set_mr_type_mcast(fpp_log_if_cmd_t* p_logif, bool do_set);
+int fci_log_if_ld_set_mr_type_ip4(fpp_log_if_cmd_t* p_logif, bool do_set);
+int fci_log_if_ld_set_mr_type_ip6(fpp_log_if_cmd_t* p_logif, bool do_set);
+int fci_log_if_ld_set_mr_type_ipx(fpp_log_if_cmd_t* p_logif, bool do_set);
+int fci_log_if_ld_set_mr_type_bcast(fpp_log_if_cmd_t* p_logif, bool do_set);
+int fci_log_if_ld_set_mr_type_udp(fpp_log_if_cmd_t* p_logif, bool do_set);
+int fci_log_if_ld_set_mr_type_tcp(fpp_log_if_cmd_t* p_logif, bool do_set);
+int fci_log_if_ld_set_mr_type_icmp(fpp_log_if_cmd_t* p_logif, bool do_set);
+int fci_log_if_ld_set_mr_type_igmp(fpp_log_if_cmd_t* p_logif, bool do_set);
+int fci_log_if_ld_set_mr_vlan(fpp_log_if_cmd_t* p_logif, bool do_set, uint16_t vlan);
+int fci_log_if_ld_set_mr_proto(fpp_log_if_cmd_t* p_logif, bool do_set, uint8_t proto);
+int fci_log_if_ld_set_mr_sport(fpp_log_if_cmd_t* p_logif, bool do_set, uint16_t sport);
+int fci_log_if_ld_set_mr_dport(fpp_log_if_cmd_t* p_logif, bool do_set, uint16_t dport);
+int fci_log_if_ld_set_mr_sip6(fpp_log_if_cmd_t* p_logif, bool do_set, const uint32_t p_sip6[4]);
+int fci_log_if_ld_set_mr_dip6(fpp_log_if_cmd_t* p_logif, bool do_set, const uint32_t p_sip6[4]);
+int fci_log_if_ld_set_mr_sip(fpp_log_if_cmd_t* p_logif, bool do_set, uint32_t sip);
+int fci_log_if_ld_set_mr_dip(fpp_log_if_cmd_t* p_logif, bool do_set, uint32_t dip);
+int fci_log_if_ld_set_mr_ethtype(fpp_log_if_cmd_t* p_logif, bool do_set, uint16_t ethtype);
+int fci_log_if_ld_set_mr_fp0(fpp_log_if_cmd_t* p_logif, bool do_set, const char* fp_table0_name);
+int fci_log_if_ld_set_mr_fp1(fpp_log_if_cmd_t* p_logif, bool do_set, const char* fp_table1_name);
+int fci_log_if_ld_set_mr_smac(fpp_log_if_cmd_t* p_logif, bool do_set, const uint8_t p_smac[6]);
+int fci_log_if_ld_set_mr_dmac(fpp_log_if_cmd_t* p_logif, bool do_set, const uint8_t p_dmac[6]);
+int fci_log_if_ld_set_mr_hif_cookie(fpp_log_if_cmd_t* p_logif, bool do_set, uint32_t hif_cookie);
+
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+
+bool fci_log_if_ld_is_enabled(const fpp_log_if_cmd_t* p_logif);
+bool fci_log_if_ld_is_disabled(const fpp_log_if_cmd_t* p_logif);
+bool fci_log_if_ld_is_promisc(const fpp_log_if_cmd_t* p_logif);
+bool fci_log_if_ld_is_loopback(const fpp_log_if_cmd_t* p_logif);
+bool fci_log_if_ld_is_match_mode_or(const fpp_log_if_cmd_t* p_logif);
+bool fci_log_if_ld_is_discard_on_m(const fpp_log_if_cmd_t* p_logif);
+bool fci_log_if_ld_is_egress_phyifs(const fpp_log_if_cmd_t* p_logif, uint32_t phyif_bitflag);
+bool fci_log_if_ld_is_mr(const fpp_log_if_cmd_t* p_logif, fpp_if_m_rules_t match_rule);
+
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+
+int fci_log_if_print_all(FCI_CLIENT* p_cl, fci_log_if_cb_print_t p_cb_print);
+int fci_log_if_print_all_sa(FCI_CLIENT* p_cl, fci_log_if_cb_print_t p_cb_print);
+int fci_log_if_print_by_parent(FCI_CLIENT* p_cl, fci_log_if_cb_print_t p_cb_print, const char* p_parent_name);
+int fci_log_if_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count);
+int fci_log_if_get_count_by_parent(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, const char* p_parent_name);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_interface/fci_phy_if.c b/sw/libfci_cli/src/libfci_interface/fci_phy_if.c
new file mode 100644
index 0000000..2a660b9
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_interface/fci_phy_if.c
@@ -0,0 +1,979 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <string.h>
+#include <arpa/inet.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+#include "fci_common.h"
+#include "fci_phy_if.h"
+ 
+ 
+/* ==== PRIVATE FUNCTIONS ================================================== */
+ 
+ 
+/*
+ * @brief          Network-to-host (ntoh) function for a physical interface struct.
+ * @param[in,out]  p_rtn_phyif  The physical interface struct to be converted.
+ */
+static void ntoh_phyif(fpp_phy_if_cmd_t* p_rtn_phyif)
+{
+    assert(NULL != p_rtn_phyif);
+    
+    
+    p_rtn_phyif->id = ntohl(p_rtn_phyif->id);
+    ntoh_enum(&(p_rtn_phyif->flags), sizeof(fpp_if_flags_t));
+    ntoh_enum(&(p_rtn_phyif->mode), sizeof(fpp_phy_if_op_mode_t));
+    ntoh_enum(&(p_rtn_phyif->block_state), sizeof(fpp_phy_if_block_state_t));
+    p_rtn_phyif->stats.ingress = ntohl(p_rtn_phyif->stats.ingress);
+    p_rtn_phyif->stats.egress = ntohl(p_rtn_phyif->stats.egress);
+    p_rtn_phyif->stats.malformed = ntohl(p_rtn_phyif->stats.malformed);
+    p_rtn_phyif->stats.discarded = ntohl(p_rtn_phyif->stats.discarded);
+}
+ 
+ 
+/*
+ * @brief          Host-to-network (hton) function for a physical interface struct.
+ * @param[in,out]  p_rtn_phyif  The physical interface struct to be converted.
+ */
+static void hton_phyif(fpp_phy_if_cmd_t* p_rtn_phyif)
+{
+    assert(NULL != p_rtn_phyif);
+    
+    
+    p_rtn_phyif->id = htonl(p_rtn_phyif->id);
+    hton_enum(&(p_rtn_phyif->flags), sizeof(fpp_if_flags_t));
+    hton_enum(&(p_rtn_phyif->mode), sizeof(fpp_phy_if_op_mode_t));
+    hton_enum(&(p_rtn_phyif->block_state), sizeof(fpp_phy_if_block_state_t));
+    p_rtn_phyif->stats.ingress = htonl(p_rtn_phyif->stats.ingress);
+    p_rtn_phyif->stats.egress = htonl(p_rtn_phyif->stats.egress);
+    p_rtn_phyif->stats.malformed = htonl(p_rtn_phyif->stats.malformed);
+    p_rtn_phyif->stats.discarded = htonl(p_rtn_phyif->stats.discarded);
+}
+ 
+ 
+/*
+ * @brief       Set/unset a bitflag in a physical interface struct.
+ * @param[out]  p_rtn_phyif  The physical interface struct to be modified.
+ * @param[in]   enable       New state of the bitflag.
+ * @param[in]   flag         The bitflag.
+ */
+static void set_flag(fpp_phy_if_cmd_t* p_rtn_phyif, bool enable, fpp_if_flags_t flag)
+{
+    assert(NULL != p_rtn_phyif);
+    
+    
+    if (enable)
+    {
+        p_rtn_phyif->flags |= flag;
+    }
+    else
+    {
+        p_rtn_phyif->flags &= (fpp_if_flags_t)(~flag);
+    }
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested physical interface
+ *              from the PFE. Identify the interface by its name.
+ * @details     To use this function properly, the PFE interface database must be
+ *              locked for exclusive access. See fci_phy_if_get_by_name_sa() for 
+ *              an example how to lock the database.
+ * @param[in]   p_cl         FCI client instance
+ * @param[out]  p_rtn_phyif  Space for data from the PFE.
+ * @param[in]   p_name       Name of the requested physical interface.
+ *                           Names of physical interfaces are hardcoded.
+ *                           See the FCI API Reference, chapter Interface Management.
+ * @return      FPP_ERR_OK : Requested physical interface was found.
+ *                           A copy of its configuration was stored into p_rtn_phyif.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No data copied.
+ */
+int fci_phy_if_get_by_name(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_rtn_phyif,
+                           const char* p_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_phyif);
+    assert(NULL != p_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_phy_if_cmd_t cmd_to_fci = {0};
+    fpp_phy_if_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
+                        sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    ntoh_phyif(&reply_from_fci);  /* set correct byte order */
+    
+    /* query loop (with the search condition) */
+    while ((FPP_ERR_OK == rtn) && (strcmp(p_name, reply_from_fci.name)))
+    {
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
+                        sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        ntoh_phyif(&reply_from_fci);  /* set correct byte order */
+    }
+    
+    /* if search successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_phyif = reply_from_fci;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested physical interface
+ *              from the PFE. Identify the interface by its name.
+ * @details     This is a standalone (_sa) function.
+ *              It shows how to properly access a physical interface. Namely:
+ *              1. Lock the interface database for exclusive access by this FCI client.
+ *              2. Execute one or more FCI calls which access 
+ *                 physical or logical interfaces.
+ *              3. Unlock the interface database's exclusive access lock.
+ * @param[in]   p_cl         FCI client instance
+ * @param[out]  p_rtn_phyif  Space for data from the PFE.
+ * @param[in]   p_name       Name of the requested physical interface.
+ *                           Names of physical interfaces are hardcoded.
+ *                           See the FCI API Reference, chapter Interface Management.
+ * @return      FPP_ERR_OK : Requested physical interface was found.
+ *                           A copy of its configuration was stored into p_rtn_phyif.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No data copied.
+ */
+inline int fci_phy_if_get_by_name_sa(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_rtn_phyif,
+                                     const char* p_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_phyif);
+    assert(NULL != p_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    /* lock the interface database for exclusive access by this FCI client */
+    rtn = fci_write(p_cl, FPP_CMD_IF_LOCK_SESSION, 0, NULL);
+    
+    /* execute "payload" - FCI calls which access physical or logical interfaces */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_phy_if_get_by_name(p_cl, p_rtn_phyif, p_name);
+    }
+    
+    /* unlock the interface database's exclusive access lock */
+    /* result of the unlock action is returned only if previous "payload" actions were OK */
+    const int rtn_unlock = fci_write(p_cl, FPP_CMD_IF_UNLOCK_SESSION, 0, NULL);
+    rtn = ((FPP_ERR_OK == rtn) ? (rtn_unlock) : (rtn));  
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested physical interface
+ *              from the PFE. Identify the interface by its ID.
+ * @details     To use this function properly, the PFE interface database must be
+ *              locked for exclusive access. See fci_phy_if_get_by_name_sa() for 
+ *              an example how to lock the database.
+ * @param[in]   p_cl         FCI client instance
+ * @param[out]  p_rtn_phyif  Space for data from the PFE.
+ * @param[in]   p_id         ID of the requested physical interface.
+ *                           IDs of physical interfaces are hardcoded.
+ *                           See the FCI API Reference, chapter Interface Management.
+ * @return      FPP_ERR_OK : Requested physical interface was found. 
+ *                           A copy of its configuration was stored into p_rtn_phyif.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No data copied.
+ */
+int fci_phy_if_get_by_id(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_rtn_phyif, uint32_t id)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_phyif);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_phy_if_cmd_t cmd_to_fci = {0};
+    fpp_phy_if_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
+                        sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    ntoh_phyif(&reply_from_fci);  /* set correct byte order */
+    
+    /* query loop (with the search condition) */
+    while ((FPP_ERR_OK == rtn) && (id != (reply_from_fci.id)))
+    {
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
+                        sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        ntoh_phyif(&reply_from_fci);  /* set correct byte order */
+    }
+    
+    /* if search successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_phyif = reply_from_fci;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
+ 
+ 
+/*
+ * @brief          Use FCI calls to update configuration of a target physical interface 
+ *                 in the PFE.
+ * @details        To use this function properly, the PFE interface database must be
+ *                 locked for exclusive access. See fci_phy_if_update_sa() for 
+ *                 an example how to lock the database.
+ * @param[in]      p_cl     FCI client instance
+ * @param[in,out]  p_phyif  Data struct which represents a new configuration of
+ *                          the target physical interface.
+ *                          Initial data can be obtained via fci_phy_if_get_by_name() or
+ *                          fci_phy_if_get_by_id().
+ * @return         FPP_ERR_OK : Configuration of the target physical interface was
+ *                              successfully updated in the PFE.
+ *                              Local data struct was automatically updated with 
+ *                              readback data from the PFE.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data struct not updated.
+ */
+int fci_phy_if_update(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_phyif);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_phy_if_cmd_t cmd_to_fci = (*p_phyif);
+    
+    /* send data */
+    hton_phyif(&cmd_to_fci);  /* set correct byte order */
+    cmd_to_fci.action = FPP_ACTION_UPDATE;
+    rtn = fci_write(p_cl, FPP_CMD_PHY_IF, sizeof(fpp_phy_if_cmd_t), 
+                                         (unsigned short*)(&cmd_to_fci));
+    
+    /* read back and update caller data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_phy_if_get_by_id(p_cl, p_phyif, (p_phyif->id));
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief          Use FCI calls to update configuration of a target physical interface 
+ *                 in the PFE.
+ * @details        This is a standalone (_sa) function.
+ *                 It shows how to properly access a physical interface. Namely:
+ *                 1. Lock the interface database for exclusive access by this FCI client.
+ *                 2. Execute one or more FCI calls which access 
+ *                    physical or logical interfaces.
+ *                 3. Unlock the interface database's exclusive access lock.
+ * @param[in]      p_cl     FCI client instance
+ * @param[in,out]  p_phyif  Data struct which represents a new configuration of
+ *                          the target physical interface.
+ *                          Initial data can be obtained via fci_phy_if_get_by_name() or 
+ *                          fci_phy_if_get_by_id().
+ * @return         FPP_ERR_OK : Configuration of the target physical interface was
+ *                              successfully updated in the PFE.
+ *                              Local data struct was automatically updated with 
+ *                              readback data from the PFE.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data struct not updated.
+ */
+inline int fci_phy_if_update_sa(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_phyif);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    /* lock the interface database for exclusive access by this FCI client */
+    rtn = fci_write(p_cl, FPP_CMD_IF_LOCK_SESSION, 0, NULL);
+    
+    /* execute "payload" - FCI calls which access physical or logical interfaces */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_phy_if_update(p_cl, p_phyif);
+    }
+    
+    /* unlock the interface database's exclusive access lock */
+    /* result of the unlock action is returned only if previous "payload" actions were OK */
+    const int rtn_unlock = fci_write(p_cl, FPP_CMD_IF_UNLOCK_SESSION, 0, NULL);
+    rtn = ((FPP_ERR_OK == rtn) ? (rtn_unlock) : (rtn));
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+/*
+ * @defgroup    localdata_phyif  [localdata_phyif]
+ * @brief:      Functions marked as [localdata_phyif] guarantee that 
+ *              only local data are accessed.
+ * @details:    These functions do not make any FCI calls.
+ *              If some local data modifications are made, then after all local data changes
+ *              are done and finished, call fci_phy_if_update() or fci_phy_if_update_sa() to
+ *              update configuration of the real physical interface in the PFE.
+ */
+ 
+ 
+/*
+ * @brief          Enable ("up") a physical interface.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif  Local data to be modified.
+ *                          Initial data can be obtained via fci_phy_if_get_by_name() or
+ *                          fci_phy_if_get_by_id().
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_phy_if_ld_enable(fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    p_phyif->flags |= FPP_IF_ENABLED;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Disable ("down") a physical interface.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif  Local data to be modified.
+ *                          Initial data can be obtained via fci_phy_if_get_by_name() or
+ *                          fci_phy_if_get_by_id().
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_phy_if_ld_disable(fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    p_phyif->flags &= (fpp_if_flags_t)(~FPP_IF_ENABLED);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset promiscuous mode of a physical interface.
+ * @details        [localdata_phyif]
+ *                 Promiscuous mode of a physical interface means the interface
+ *                 will accept and process all incoming traffic, regardless of
+ *                 the traffic's destination MAC.
+ * @param[in,out]  p_phyif  Local data to be modified.
+ *                          Initial data can be obtained via fci_phy_if_get_by_name() or 
+ *                          fci_phy_if_get_by_id().
+ * @param[in]      promisc  A request to set/unset the promiscuous mode.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_phy_if_ld_set_promisc(fpp_phy_if_cmd_t* p_phyif, bool promisc)
+{
+    assert(NULL != p_phyif);
+    set_flag(p_phyif, promisc, FPP_IF_PROMISC);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset this physical interface as a part of a loadbalancing bucket.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif      Local data to be modified.
+ *                              Initial data can be obtained via fci_phy_if_get_by_name() or 
+ *                              fci_phy_if_get_by_id().
+ * @param[in]      loadbalance  A request to add/remove this interface to/from
+ *                              a loadbalancing bucket.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_phy_if_ld_set_loadbalance(fpp_phy_if_cmd_t* p_phyif, bool loadbalance)
+{
+    assert(NULL != p_phyif);
+    set_flag(p_phyif, loadbalance, FPP_IF_LOADBALANCE);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset VLAN conformance check in a physical interface.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif    Local data to be modified.
+ *                            Initial data can be obtained via fci_phy_if_get_by_name() or 
+ *                            fci_phy_if_get_by_id().
+ * @param[in]      vlan_conf  A request to set/unset the VLAN conformance check.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_phy_if_ld_set_vlan_conf(fpp_phy_if_cmd_t* p_phyif, bool vlan_conf)
+{
+    assert(NULL != p_phyif);
+    set_flag(p_phyif, vlan_conf, FPP_IF_VLAN_CONF_CHECK);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset PTP conformance check in a physical interface.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif   Local data to be modified.
+ *                           Initial data can be obtained via fci_phy_if_get_by_name() or 
+ *                           fci_phy_if_get_by_id().
+ * @param[in]      ptp_conf  A request to set/unset the PTP conformance check.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_phy_if_ld_set_ptp_conf(fpp_phy_if_cmd_t* p_phyif, bool ptp_conf)
+{
+    assert(NULL != p_phyif);
+    set_flag(p_phyif, ptp_conf, FPP_IF_PTP_CONF_CHECK);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset PTP promiscuous mode in a physical interface.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif      Local data to be modified.
+ *                              Initial data can be obtained via fci_phy_if_get_by_name() or 
+ *                              fci_phy_if_get_by_id().
+ * @param[in]      ptp_promisc  A request to set/unset the PTP promiscuous mode.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_phy_if_ld_set_ptp_promisc(fpp_phy_if_cmd_t* p_phyif, bool ptp_promisc)
+{
+    assert(NULL != p_phyif);
+    set_flag(p_phyif, ptp_promisc, FPP_IF_PTP_PROMISC);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset Q-in-Q mode in a physical interface.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif      Local data to be modified.
+ *                              Initial data can be obtained via fci_phy_if_get_by_name() or 
+ *                              fci_phy_if_get_by_id().
+ * @param[in]      qinq         A request to set/unset the Q-in-Q mode.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_phy_if_ld_set_qinq(fpp_phy_if_cmd_t* p_phyif, bool qinq)
+{
+    assert(NULL != p_phyif);
+    set_flag(p_phyif, qinq, FPP_IF_ALLOW_Q_IN_Q);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset discarding of packets which have TTL<2.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif      Local data to be modified.
+ *                              Initial data can be obtained via fci_phy_if_get_by_name() or 
+ *                              fci_phy_if_get_by_id().
+ * @param[in]      discard_ttl  A request to set/unset the Q-in-Q mode.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_phy_if_ld_set_discard_ttl(fpp_phy_if_cmd_t* p_phyif, bool discard_ttl)
+{
+    assert(NULL != p_phyif);
+    set_flag(p_phyif, discard_ttl, FPP_IF_DISCARD_TTL);
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set operation mode of a physical interface.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif  Local data to be modified.
+ *                          Initial data can be obtained via fci_phy_if_get_by_name() or 
+ *                          fci_phy_if_get_by_id().
+ * @param[in]      mode     New operation mode
+ *                          For details about physical interface operation modes, see
+ *                          the description of a fpp_phy_if_op_mode_t type in
+ *                          the FCI API Reference.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_phy_if_ld_set_mode(fpp_phy_if_cmd_t* p_phyif, fpp_phy_if_op_mode_t mode)
+{
+    assert(NULL != p_phyif);
+    p_phyif->mode = mode;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set blocking state of a physical interface.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif      Local data to be modified.
+ *                              Initial data can be obtained via fci_phy_if_get_by_name() or 
+ *                              fci_phy_if_get_by_id().
+ * @param[in]      block_state  New blocking state
+ *                              For details about physical interface blocking states, see
+ *                              description of a fpp_phy_if_block_state_t type in
+ *                              the FCI API Reference.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_phy_if_ld_set_block_state(fpp_phy_if_cmd_t* p_phyif,
+                                  fpp_phy_if_block_state_t block_state)
+{
+    assert(NULL != p_phyif);
+    p_phyif->block_state = block_state;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set traffic mirroring from this physical interface to 
+ *                 another physical interface.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif        Local data to be modified.
+ *                                Initial data can be obtained via fci_phy_if_get_by_name() or
+ *                                fci_phy_if_get_by_id().
+ * @param[in]      p_mirror_name  Name of a physical interface which shall be receiving
+ *                                a copy of traffic.
+ *                                Names of physical interfaces are hardcoded.
+ *                                See the FCI API Reference, chapter Interface Management.
+ *                                Can be NULL. If NULL or "" (empty string), then
+ *                                traffic mirorring is disabled.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_phy_if_ld_set_mirror(fpp_phy_if_cmd_t* p_phyif, const char* p_mirror_name)
+{
+    assert(NULL != p_phyif);
+    /* 'p_mirror_name' is allowed to be NULL */
+    
+    
+    int rtn = FPP_ERR_FCI;
+    rtn = set_text(p_phyif->mirror, p_mirror_name, IFNAMSIZ);
+    if (FPP_ERR_OK == rtn)
+    {
+        const bool enable_mirroring = ((NULL != p_mirror_name) && ('\0' != p_mirror_name[0]));
+        set_flag(p_phyif, enable_mirroring, FPP_IF_MIRROR);
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief          Set FlexibleParser table to act as a FlexibleFilter for 
+ *                 this physical interface.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif        Local data to be modified.
+ *                                Initial data can be obtained via fci_phy_if_get_by_name() or
+ *                                fci_phy_if_get_by_id().
+ * @param[in]      p_table_name   Name of a FlexibleParser table.
+ *                                Can be NULL. If NULL or "" (empty string), then
+ *                                FlexibleFilter of this physical interface is disabled.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_phy_if_ld_set_flexifilter(fpp_phy_if_cmd_t* p_phyif, const char* p_table_name)
+{
+    assert(NULL != p_phyif);
+    /* 'p_table_name' is allowed to be NULL */
+    
+    int rtn = FPP_ERR_FCI;
+    rtn = set_text(p_phyif->ftable, p_table_name, IFNAMSIZ);
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+ 
+ 
+/*
+ * @brief      Query status of an "enable" flag.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ *                      Initial data can be obtained via fci_phy_if_get_by_name() or 
+ *                      fci_phy_if_get_by_id().
+ * @return     At time when the data was obtained, the physical interface:
+ *             true  : was enabled ("up")
+ *             false : was disabled ("down")
+ */
+bool fci_phy_if_ld_is_enabled(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    return (bool)(FPP_IF_ENABLED & (p_phyif->flags));
+}
+ 
+ 
+/*
+ * @brief      Query status of an "enable" flag (inverted logic).
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ *                      Initial data can be obtained via fci_phy_if_get_by_name() or
+ *                      fci_phy_if_get_by_id().
+ * @return     At time when the data was obtained, the physical interface:
+ *             true  : was disabled ("down")
+ *             false : was enabled ("up")
+ */
+bool fci_phy_if_ld_is_disabled(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    return !fci_phy_if_ld_is_enabled(p_phyif);
+}
+ 
+ 
+/*
+ * @brief      Query status of a "promiscuous mode" flag.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ *                      Initial data can be obtained via fci_phy_if_get_by_name() or
+ *                      fci_phy_if_get_by_id().
+ * @return     At time when the data was obtained, the physical interface:
+ *             true  : was in a promiscuous mode
+ *             false : was NOT in a promiscuous mode
+ */
+bool fci_phy_if_ld_is_promisc(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    return (bool)(FPP_IF_PROMISC & (p_phyif->flags));
+}
+ 
+ 
+/*
+ * @brief      Query status of a "loadbalance" flag.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ *                      Initial data can be obtained via fci_phy_if_get_by_name() or
+ *                      fci_phy_if_get_by_id().
+ * @return     At time when the data was obtained, the physical interface:
+ *             true  : was a part of a loadbalance bucket
+ *             false : was NOT a part of a loadbalance bucket
+ */
+bool fci_phy_if_ld_is_loadbalance(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    return (bool)(FPP_IF_LOADBALANCE & (p_phyif->flags));
+}
+ 
+ 
+/*
+ * @brief      Query status of a "VLAN conformance check" flag.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ *                      Initial data can be obtained via fci_phy_if_get_by_name() or
+ *                      fci_phy_if_get_by_id().
+ * @return     At time when the data was obtained, the physical interface:
+ *             true  : was checking VLAN conformance
+ *             false : was NOT checking VLAN conformance
+ */
+bool fci_phy_if_ld_is_vlan_conf(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    return (bool)(FPP_IF_VLAN_CONF_CHECK & (p_phyif->flags));
+}
+ 
+ 
+/*
+ * @brief      Query status of a "PTP conformance check" flag.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ *                      Initial data can be obtained via fci_phy_if_get_by_name() or
+ *                      fci_phy_if_get_by_id().
+ * @return     At time when the data was obtained, the physical interface:
+ *             true  : was checking PTP conformance
+ *             false : was NOT checking PTP conformance
+ */
+bool fci_phy_if_ld_is_ptp_conf(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    return (bool)(FPP_IF_PTP_CONF_CHECK & (p_phyif->flags));
+}
+ 
+ 
+/*
+ * @brief      Query status of a "PTP promisc" flag.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ *                      Initial data can be obtained via fci_phy_if_get_by_name() or
+ *                      fci_phy_if_get_by_id().
+ * @return     At time when the data was obtained, the physical interface:
+ *             true  : was using PTP promiscuous mode
+ *             false : was NOT using PTP promiscuous mode
+ */
+bool fci_phy_if_ld_is_ptp_promisc(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    return (bool)(FPP_IF_PTP_PROMISC & (p_phyif->flags));
+}
+ 
+ 
+/*
+ * @brief      Query status of a "Q-in-Q" flag.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ *                      Initial data can be obtained via fci_phy_if_get_by_name() or
+ *                      fci_phy_if_get_by_id().
+ * @return     At time when the data was obtained, the physical interface:
+ *             true  : was using Q-in-Q feature
+ *             false : was NOT using Q-in-Q feature
+ */
+bool fci_phy_if_ld_is_qinq(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    return (bool)(FPP_IF_ALLOW_Q_IN_Q & (p_phyif->flags));
+}
+ 
+ 
+/*
+ * @brief      Query status of a "Q-in-Q" flag.
+ * @details    [localdata_phyif]
+ *             This feature applies only if the physical interface is in a mode
+ *             which decrements TTL of packets (e.g. L3 Router).
+ * @param[in]  p_phyif  Local data to be queried.
+ *                      Initial data can be obtained via fci_phy_if_get_by_name() or
+ *                      fci_phy_if_get_by_id().
+ * @return     At time when the data was obtained, the physical interface:
+ *             true  : was discarding packets which have TTL<2 (only for some modes)
+ *             false : was sending packets which have TTL<2 to a host (only for some modes)
+ */
+bool fci_phy_if_ld_is_discard_ttl(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    return (bool)(FPP_IF_DISCARD_TTL & (p_phyif->flags));
+}
+ 
+ 
+/*
+ * @brief      Query status of a "mirror" flag.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ *                      Initial data can be obtained via fci_phy_if_get_by_name() or
+ *                      fci_phy_if_get_by_id().
+ * @return     At time when the data was obtained, the physical interface:
+ *             true  : had the mirroring feature enabled
+ *             false : had the mirroring feature disabled
+ */
+bool fci_phy_if_ld_is_mirror(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    return (bool)(FPP_IF_MIRROR & (p_phyif->flags));
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all physical interfaces in the PFE and
+ *             execute a callback print function for each reported physical interface.
+ * @details    To use this function properly, the PFE interface database must be
+ *             locked for exclusive access. See fci_phy_if_print_all_sa() for 
+ *             an example how to lock the database.
+ * @param[in]  p_cl        FCI client instance
+ * @param[in]  p_cb_print  Callback print function.
+ *                         --> If the callback returns zero, then all is OK and 
+ *                             the next physical interface is picked for a print process.
+ *                         --> If the callback returns non-zero, then some problem is 
+ *                             assumed and this function terminates prematurely.
+ * @return     FPP_ERR_OK : Successfully iterated through all physical interfaces.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_phy_if_print_all(FCI_CLIENT* p_cl, fci_phy_if_cb_print_t p_cb_print)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_phy_if_cmd_t cmd_to_fci = {0};
+    fpp_phy_if_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
+                    sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    ntoh_phyif(&reply_from_fci);  /* set correct byte order */
+        
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        rtn = p_cb_print(&reply_from_fci);
+        
+        if (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+            rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
+                            sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            ntoh_phyif(&reply_from_fci);  /* set correct byte order */
+        }
+    }
+    
+    /* query loop runs till there are no more physical interfaces to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_IF_ENTRY_NOT_FOUND == rtn)
+    {
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all physical interfaces in the PFE and
+ *             execute a callback print function for each reported physical interface.
+ * @details    This is a standalone (_sa) function.
+ *             It shows how to properly access a physical interface. Namely:
+ *             1. Lock the interface database for exclusive access by this FCI client.
+ *             2. Execute one or more FCI calls which access 
+ *                physical or logical interfaces.
+ *             3. Unlock the interface database's exclusive access lock.
+ * @param[in]  p_cl        FCI client instance
+ * @param[in]  p_cb_print  Callback print function.
+ *                         --> If the callback returns zero, then all is OK and 
+ *                             the next physical interface is picked for a print process.
+ *                         --> If the callback returns non-zero, then some problem is 
+ *                             assumed and this function terminates prematurely.
+ * @return     FPP_ERR_OK : Successfully iterated through all physical interfaces.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+inline int fci_phy_if_print_all_sa(FCI_CLIENT* p_cl, fci_phy_if_cb_print_t p_cb_print)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    /* lock the interface database for exclusive access by this FCI client */
+    rtn = fci_write(p_cl, FPP_CMD_IF_LOCK_SESSION, 0, NULL);
+    
+    /* execute "payload" - FCI calls which access physical or logical interfaces */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_phy_if_print_all(p_cl, p_cb_print);
+    }
+    
+    /* unlock the interface database's exclusive access lock */
+    /* result of the unlock action is returned only if previous "payload" actions were OK */
+    const int rtn_unlock = fci_write(p_cl, FPP_CMD_IF_UNLOCK_SESSION, 0, NULL);
+    rtn = ((FPP_ERR_OK == rtn) ? (rtn_unlock) : (rtn));
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all physical interfaces in the PFE.
+ * @details     To use this function properly, the PFE interface database must be
+ *              locked for exclusive access. See fci_phy_if_print_all_sa() for 
+ *              an example how to lock the database.
+ * @param[in]   p_cl         FCI client instance
+ * @param[out]  p_rtn_count  Space to store the count of physical interfaces.
+ * @return      FPP_ERR_OK : Successfully counted physical interfaces.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No count was stored.
+ */
+int fci_phy_if_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_count);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_phy_if_cmd_t cmd_to_fci = {0};
+    fpp_phy_if_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    uint16_t count = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
+                    sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    /* no need to set correct byte order (we are just counting interfaces) */
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        count++;
+        
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
+                        sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        /* no need to set correct byte order (we are just counting interfaces) */
+    }
+    
+    /* query loop runs till there are no more physical interfaces to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_IF_ENTRY_NOT_FOUND == rtn)
+    {
+        *p_rtn_count = count;
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_interface/fci_phy_if.h b/sw/libfci_cli/src/libfci_interface/fci_phy_if.h
new file mode 100644
index 0000000..f82be00
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_interface/fci_phy_if.h
@@ -0,0 +1,93 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef FCI_PHY_IF_H_
+#define FCI_PHY_IF_H_
+
+#include "fpp_ext.h"
+#include "libfci.h"
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+/* hardcoded PHY_IF names, IDs and bitflags (IDs 3 & 4 are reserved) */
+#define FCI_PHY_IF_EMAC0_ID  (0u)
+#define FCI_PHY_IF_EMAC1_ID  (1u)
+#define FCI_PHY_IF_EMAC2_ID  (2u)
+#define FCI_PHY_IF_UTIL_ID   (5u)
+#define FCI_PHY_IF_HIF0_ID   (6u)
+#define FCI_PHY_IF_HIF1_ID   (7u)
+#define FCI_PHY_IF_HIF2_ID   (8u)
+#define FCI_PHY_IF_HIF3_ID   (9u)
+
+#define FCI_PHY_IF_EMAC0_BITFLAG  (1uL << FCI_PHY_IF_EMAC0_ID)
+#define FCI_PHY_IF_EMAC1_BITFLAG  (1uL << FCI_PHY_IF_EMAC1_ID)
+#define FCI_PHY_IF_EMAC2_BITFLAG  (1uL << FCI_PHY_IF_EMAC2_ID)
+#define FCI_PHY_IF_UTIL_BITFLAG   (1uL << FCI_PHY_IF_UTIL_ID)
+#define FCI_PHY_IF_HIF0_BITFLAG   (1uL << FCI_PHY_IF_HIF0_ID)
+#define FCI_PHY_IF_HIF1_BITFLAG   (1uL << FCI_PHY_IF_HIF1_ID)
+#define FCI_PHY_IF_HIF2_BITFLAG   (1uL << FCI_PHY_IF_HIF2_ID)
+#define FCI_PHY_IF_HIF3_BITFLAG   (1uL << FCI_PHY_IF_HIF3_ID)
+
+typedef int (*fci_phy_if_cb_print_t)(const fpp_phy_if_cmd_t* p_phyif);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
+
+int fci_phy_if_get_by_name(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_rtn_phyif, const char* p_name);
+int fci_phy_if_get_by_name_sa(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_rtn_phyif, const char* p_name);
+int fci_phy_if_get_by_id(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_rtn_phyif, uint32_t id);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
+
+int fci_phy_if_update(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_phyif);
+int fci_phy_if_update_sa(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_phyif);
+
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+
+int fci_phy_if_ld_enable(fpp_phy_if_cmd_t* p_phyif);
+int fci_phy_if_ld_disable(fpp_phy_if_cmd_t* p_phyif);
+int fci_phy_if_ld_set_promisc(fpp_phy_if_cmd_t* p_phyif, bool promisc);
+int fci_phy_if_ld_set_loadbalance(fpp_phy_if_cmd_t* p_phyif, bool loadbalance);
+int fci_phy_if_ld_set_vlan_conf(fpp_phy_if_cmd_t* p_phyif, bool vlan_conf);
+int fci_phy_if_ld_set_ptp_conf(fpp_phy_if_cmd_t* p_phyif, bool ptp_conf);
+int fci_phy_if_ld_set_ptp_promisc(fpp_phy_if_cmd_t* p_phyif, bool ptp_promisc);
+int fci_phy_if_ld_set_qinq(fpp_phy_if_cmd_t* p_phyif, bool qinq);
+int fci_phy_if_ld_set_discard_ttl(fpp_phy_if_cmd_t* p_phyif, bool discard_ttl);
+int fci_phy_if_ld_set_mode(fpp_phy_if_cmd_t* p_phyif, fpp_phy_if_op_mode_t mode);
+int fci_phy_if_ld_set_block_state(fpp_phy_if_cmd_t* p_phyif, fpp_phy_if_block_state_t block_state);
+int fci_phy_if_ld_set_mirror(fpp_phy_if_cmd_t* p_phyif, const char* p_mirror_name);
+int fci_phy_if_ld_set_flexifilter(fpp_phy_if_cmd_t* p_phyif, const char* p_table_name);
+
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+
+bool fci_phy_if_ld_is_enabled(const fpp_phy_if_cmd_t* p_phyif);
+bool fci_phy_if_ld_is_disabled(const fpp_phy_if_cmd_t* p_phyif);
+bool fci_phy_if_ld_is_promisc(const fpp_phy_if_cmd_t* p_phyif);
+bool fci_phy_if_ld_is_loadbalance(const fpp_phy_if_cmd_t* p_phyif);
+bool fci_phy_if_ld_is_vlan_conf(const fpp_phy_if_cmd_t* p_phyif);
+bool fci_phy_if_ld_is_ptp_conf(const fpp_phy_if_cmd_t* p_phyif);
+bool fci_phy_if_ld_is_ptp_promisc(const fpp_phy_if_cmd_t* p_phyif);
+bool fci_phy_if_ld_is_qinq(const fpp_phy_if_cmd_t* p_phyif);
+bool fci_phy_if_ld_is_discard_ttl(const fpp_phy_if_cmd_t* p_phyif);
+bool fci_phy_if_ld_is_mirror(const fpp_phy_if_cmd_t* p_phyif);
+
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+
+int fci_phy_if_print_all(FCI_CLIENT* p_cl, fci_phy_if_cb_print_t p_cb_print);
+int fci_phy_if_print_all_sa(FCI_CLIENT* p_cl, fci_phy_if_cb_print_t p_cb_print);
+int fci_phy_if_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_interface/fci_qos.c b/sw/libfci_cli/src/libfci_interface/fci_qos.c
new file mode 100644
index 0000000..d3e02a5
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_interface/fci_qos.c
@@ -0,0 +1,1119 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <string.h>
+#include <arpa/inet.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+#include "fci_common.h"
+#include "fci_qos.h"
+ 
+ 
+/* ==== PRIVATE FUNCTIONS ================================================== */
+ 
+ 
+/*
+ * @brief          Network-to-host (ntoh) function for a queue struct.
+ * @param[in,out]  p_rtn_que  The queue struct to be converted.
+ */
+static void ntoh_que(fpp_qos_queue_cmd_t* p_rtn_que)
+{
+    assert(NULL != p_rtn_que);
+    
+    
+    p_rtn_que->min = ntohl(p_rtn_que->min);
+    p_rtn_que->max = ntohl(p_rtn_que->max);
+}
+ 
+ 
+/*
+ * @brief          Host-to-network (hton) function for a queue struct.
+ * @param[in,out]  p_rtn_que  The queue struct to be converted.
+ */
+static void hton_que(fpp_qos_queue_cmd_t* p_rtn_que)
+{
+    assert(NULL != p_rtn_que);
+    
+    
+    p_rtn_que->min = htonl(p_rtn_que->min);
+    p_rtn_que->max = htonl(p_rtn_que->max);
+}
+ 
+ 
+/*
+ * @brief          Network-to-host (ntoh) function for a scheduler struct.
+ * @param[in,out]  p_rtn_sch  The scheduler struct to be converted.
+ */
+static void ntoh_sch(fpp_qos_scheduler_cmd_t* p_rtn_sch)
+{
+    assert(NULL != p_rtn_sch);
+    
+    
+    p_rtn_sch->input_en = ntohl(p_rtn_sch->input_en);
+    for (uint8_t i = 0u; (32u > i); (++i))
+    {
+        p_rtn_sch->input_w[i] = ntohl(p_rtn_sch->input_w[i]);
+    }
+}
+ 
+ 
+/*
+ * @brief          Host-to-network (hton) function for a scheduler struct.
+ * @param[in,out]  p_rtn_sch  The scheduler struct to be converted.
+ */
+static void hton_sch(fpp_qos_scheduler_cmd_t* p_rtn_sch)
+{
+    assert(NULL != p_rtn_sch);
+    
+    
+    p_rtn_sch->input_en = htonl(p_rtn_sch->input_en);
+    for (uint8_t i = 0u; (32u > i); (++i))
+    {
+        p_rtn_sch->input_w[i] = htonl(p_rtn_sch->input_w[i]);
+    }
+}
+ 
+ 
+/*
+ * @brief          Network-to-host (ntoh) function for a shaper struct.
+ * @param[in,out]  p_rtn_shp  The shaper struct to be converted.
+ */
+static void ntoh_shp(fpp_qos_shaper_cmd_t* p_rtn_shp)
+{
+    assert(NULL != p_rtn_shp);
+    
+    
+    p_rtn_shp->isl = ntohl(p_rtn_shp->isl);
+    p_rtn_shp->max_credit = (int32_t)(ntohl(p_rtn_shp->max_credit));
+    p_rtn_shp->min_credit = (int32_t)(ntohl(p_rtn_shp->min_credit));
+}
+ 
+ 
+/*
+ * @brief          Host-to-network (hton) function for a shaper struct.
+ * @param[in,out]  p_rtn_shp  The shaper struct to be converted.
+ */
+static void hton_shp(fpp_qos_shaper_cmd_t* p_rtn_shp)
+{
+    assert(NULL != p_rtn_shp);
+    
+    
+    p_rtn_shp->isl = htonl(p_rtn_shp->isl);
+    p_rtn_shp->max_credit = (int32_t)(htonl(p_rtn_shp->max_credit));
+    p_rtn_shp->min_credit = (int32_t)(htonl(p_rtn_shp->min_credit));
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested QoS queue
+ *              from the PFE. Identify the QoS queue by name of the parent 
+ *              physical interface and by the queue's ID.
+ * @param[in]   p_cl          FCI client instance
+ * @param[out]  p_rtn_que     Space for data from the PFE.
+ * @param[in]   p_phyif_name  Name of a parent physical interface.
+ *                            Names of physical interfaces are hardcoded.
+ *                            See the FCI API Reference, chapter Interface Management.
+ *              que_id        ID of the requested QoS queue.
+ * @return      FPP_ERR_OK : Requested QoS queue was found.
+ *                           A copy of its configuration was stored into p_rtn_que.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No data copied.
+ */
+int fci_qos_que_get_by_id(FCI_CLIENT* p_cl, fpp_qos_queue_cmd_t* p_rtn_que, 
+                          const char* p_phyif_name, uint8_t que_id)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_que);
+    assert(NULL != p_phyif_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_qos_queue_cmd_t cmd_to_fci = {0};
+    fpp_qos_queue_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    cmd_to_fci.id = que_id;
+    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
+    
+    /* do the query */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* start query process */
+        cmd_to_fci.action = FPP_ACTION_QUERY;
+        rtn = fci_query(p_cl, FPP_CMD_QOS_QUEUE,
+                        sizeof(fpp_qos_queue_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        ntoh_que(&reply_from_fci);  /* set correct byte order */
+    }
+    
+    /* if search successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_que = reply_from_fci;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested QoS scheduler
+ *              from the PFE. Identify the QoS scheduler by name of the parent 
+ *              physical interface and by the scheduler's ID.
+ * @param[in]   p_cl          FCI client instance
+ * @param[out]  p_rtn_que     Space for data from the PFE.
+ * @param[in]   p_phyif_name  Name of a parent physical interface.
+ *                            Names of physical interfaces are hardcoded.
+ *                            See the FCI API Reference, chapter Interface Management.
+ *              sch_id        ID of the requested QoS scheduler.
+ * @return      FPP_ERR_OK : Requested QoS scheduler was found.
+ *                           A copy of its configuration was stored into p_rtn_sch.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No data copied.
+ */
+int fci_qos_sch_get_by_id(FCI_CLIENT* p_cl, fpp_qos_scheduler_cmd_t* p_rtn_sch, 
+                          const char* p_phyif_name, uint8_t sch_id)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_sch);
+    assert(NULL != p_phyif_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_qos_scheduler_cmd_t cmd_to_fci = {0};
+    fpp_qos_scheduler_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    cmd_to_fci.id = sch_id;
+    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
+    
+    /* do the query */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* start query process */
+        cmd_to_fci.action = FPP_ACTION_QUERY;
+        rtn = fci_query(p_cl, FPP_CMD_QOS_SCHEDULER,
+                        sizeof(fpp_qos_scheduler_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        ntoh_sch(&reply_from_fci);  /* set correct byte order */
+    }
+    
+    /* if search successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_sch = reply_from_fci;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested QoS shaper
+ *              from the PFE. Identify the QoS shaper by name of the parent 
+ *              physical interface and by the shaper's ID.
+ * @param[in]   p_cl          FCI client instance
+ * @param[out]  p_rtn_que     Space for data from the PFE.
+ * @param[in]   p_phyif_name  Name of a parent physical interface.
+ *                            Names of physical interfaces are hardcoded.
+ *                            See the FCI API Reference, chapter Interface Management.
+ *              shp_id        ID of the requested QoS shaper.
+ * @return      FPP_ERR_OK : Requested QoS shaper was found.
+ *                           A copy of its configuration was stored into p_rtn_shp.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No data copied.
+ */
+int fci_qos_shp_get_by_id(FCI_CLIENT* p_cl, fpp_qos_shaper_cmd_t* p_rtn_shp, 
+                          const char* p_phyif_name, uint8_t shp_id)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_shp);
+    assert(NULL != p_phyif_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_qos_shaper_cmd_t cmd_to_fci = {0};
+    fpp_qos_shaper_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    cmd_to_fci.id = shp_id;
+    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
+    
+    /* do the query */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* start query process */
+        cmd_to_fci.action = FPP_ACTION_QUERY;
+        rtn = fci_query(p_cl, FPP_CMD_QOS_SHAPER,
+                        sizeof(fpp_qos_shaper_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        ntoh_shp(&reply_from_fci);  /* set correct byte order */
+    }
+    
+    /* if search successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_shp = reply_from_fci;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
+ 
+ 
+/*
+ * @brief          Use FCI calls to update configuration of a target QoS queue
+ *                 in the PFE.
+ * @param[in]      p_cl   FCI client instance
+ * @param[in,out]  p_que  Data struct which represents a new configuration of 
+ *                        the target QoS queue.
+ *                        Initial data can be obtained via fci_qos_que_get_by_id().
+ * @return         FPP_ERR_OK : Configuration of the QoS queue was
+ *                              successfully updated in the PFE.
+ *                              Local data struct was automatically updated with 
+ *                              readback data from the PFE.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data struct not updated.
+ */
+int fci_qos_que_update(FCI_CLIENT* p_cl, fpp_qos_queue_cmd_t* p_que)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_que);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_qos_queue_cmd_t cmd_to_fci = (*p_que);
+    
+    /* send data */
+    hton_que(&cmd_to_fci);  /* set correct byte order */
+    cmd_to_fci.action = FPP_ACTION_UPDATE;
+    rtn = fci_write(p_cl, FPP_CMD_QOS_QUEUE, sizeof(fpp_qos_queue_cmd_t), 
+                                        (unsigned short*)(&cmd_to_fci));
+    
+    /* read back and update caller data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_qos_que_get_by_id(p_cl, p_que, (p_que->if_name), (p_que->id));
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief          Use FCI calls to update configuration of a target QoS scheduler
+ *                 in the PFE.
+ * @param[in]      p_cl   FCI client instance
+ * @param[in,out]  p_que  Data struct which represents a new configuration of 
+ *                        the target QoS scheduler.
+ *                        Initial data can be obtained via fci_qos_sch_get_by_id().
+ * @return         FPP_ERR_OK : Configuration of the QoS scheduler was
+ *                              successfully updated in the PFE.
+ *                              Local data struct was automatically updated with 
+ *                              readback data from the PFE.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data struct not updated.
+ */
+int fci_qos_sch_update(FCI_CLIENT* p_cl, fpp_qos_scheduler_cmd_t* p_sch)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_sch);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_qos_scheduler_cmd_t cmd_to_fci = (*p_sch);
+    
+    /* send data */
+    hton_sch(&cmd_to_fci);  /* set correct byte order */
+    cmd_to_fci.action = FPP_ACTION_UPDATE;
+    rtn = fci_write(p_cl, FPP_CMD_QOS_SCHEDULER, sizeof(fpp_qos_scheduler_cmd_t), 
+                                                (unsigned short*)(&cmd_to_fci));
+    
+    /* read back and update caller data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_qos_sch_get_by_id(p_cl, p_sch, (p_sch->if_name), (p_sch->id));
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief          Use FCI calls to update configuration of a target QoS shaper
+ *                 in the PFE.
+ * @param[in]      p_cl   FCI client instance
+ * @param[in,out]  p_que  Data struct which represents a new configuration of 
+ *                        the target QoS shaper.
+ *                        Initial data can be obtained via fci_qos_shp_get_by_id().
+ * @return         FPP_ERR_OK : Configuration of the QoS shaper was
+ *                              successfully updated in the PFE.
+ *                              Local data struct was automatically updated with 
+ *                              readback data from the PFE.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data struct not updated.
+ */
+int fci_qos_shp_update(FCI_CLIENT* p_cl, fpp_qos_shaper_cmd_t* p_shp)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_shp);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_qos_shaper_cmd_t cmd_to_fci = (*p_shp);
+    
+    /* send data */
+    hton_shp(&cmd_to_fci);  /* set correct byte order */
+    cmd_to_fci.action = FPP_ACTION_UPDATE;
+    rtn = fci_write(p_cl, FPP_CMD_QOS_SHAPER, sizeof(fpp_qos_shaper_cmd_t), 
+                                             (unsigned short*)(&cmd_to_fci));
+    
+    /* read back and update caller data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = fci_qos_shp_get_by_id(p_cl, p_shp, (p_shp->if_name), (p_shp->id));
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+/*
+ * @defgroup    localdata_que  [localdata_que]
+ * @brief:      Functions marked as [localdata_que] guarantee that 
+ *              only local data are accessed.
+ * @details:    These functions do not make any FCI calls.
+ *              If some local data modifications are made, then after all local data changes
+ *              are done and finished, call fci_qos_que_update() to 
+ *              update the given QoS queue in the PFE.
+ */
+ 
+ 
+/*
+ * @brief          Set mode (queue discipline) of a QoS queue.
+ * @details        [localdata_que]
+ * @param[in,out]  p_que     Local data to be modified.
+ *                           Initial data can be obtained via fci_qos_que_get_by_id().
+ * @param[in]      que_mode  queue mode (queue discipline)
+ *                           For valid modes, see the FCI API Reference, 
+ *                           chapter 'queue mode'.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_qos_que_ld_set_mode(fpp_qos_queue_cmd_t* p_que, uint8_t que_mode)
+{
+    assert(NULL != p_que);
+    p_que->mode = que_mode;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set minimal threshold of a QoS queue.
+ * @details        [localdata_que]
+ *                 Meaning of minimal threshold depends on que mode.
+ * @param[in,out]  p_que  Local data to be modified.
+ *                        Initial data can be obtained via fci_qos_que_get_by_id().
+ * @param[in]      min    minimal threshold
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_qos_que_ld_set_min(fpp_qos_queue_cmd_t* p_que, uint32_t min)
+{
+    assert(NULL != p_que);
+    p_que->min = min;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set queue mode (queue discipline) of a QoS queue.
+ * @details        [localdata_que]
+ *                 Meaning of maximal threshold depends on que mode.
+ * @param[in,out]  p_que  Local data to be modified.
+ *                        Initial data can be obtained via fci_qos_que_get_by_id().
+ * @param[in]      max    maximal threshold
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_qos_que_ld_set_max(fpp_qos_queue_cmd_t* p_que, uint32_t max)
+{
+    assert(NULL != p_que);
+    p_que->max = max;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set packet drop probability of a particular QoS queue's zone.
+ * @details        [localdata_que]
+ *                 Meaningful only for que mode WRED.
+ * @param[in,out]  p_que  Local data to be modified.
+ *                        Initial data can be obtained via fci_qos_que_get_by_id().
+ * @param[in]      zprob_id    id of a probability zone
+ *                             There may be less than 32 zones actually implemented in PFE.
+ *                             (32 is just the max array limit)
+ *                             See the FCI API Reference, chapter Egress QoS.
+ * @param[in]      percentage  drop probability in [%]
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_qos_que_ld_set_zprob(fpp_qos_queue_cmd_t* p_que, uint8_t zprob_id, 
+                             uint8_t percentage)
+{
+    assert(NULL != p_que);
+    int rtn = FPP_ERR_FCI;
+    if (32u > zprob_id)
+    {
+        p_que->zprob[zprob_id] = percentage;
+        rtn = FPP_ERR_OK;
+    }
+    return (rtn);
+}
+ 
+ 
+/*
+ * @defgroup    localdata_sch  [localdata_sch]
+ * @brief:      Functions marked as [localdata_sch] guarantee that 
+ *              only local data are accessed.
+ * @details:    These functions do not make any FCI calls.
+ *              If some local data modifications are made, then after all local data changes
+ *              are done and finished, call fci_qos_sch_update() to 
+ *              update the given QoS scheduler in the PFE.
+ */
+ 
+ 
+/*
+ * @brief          Set mode of a QoS scheduler.
+ * @details        [localdata_sch]
+ * @param[in,out]  p_sch     Local data to be modified.
+ *                           Initial data can be obtained via fci_qos_sch_get_by_id().
+ * @param[in]      sch_mode  scheduler mode
+ *                           For valid modes, see the FCI API Reference, 
+ *                           chapter 'schedulermode'.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_qos_sch_ld_set_mode(fpp_qos_scheduler_cmd_t* p_sch, uint8_t sch_mode)
+{
+    assert(NULL != p_sch);
+    p_sch->mode = sch_mode;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set selection algorithm of a QoS scheduler.
+ * @details        [localdata_sch]
+ * @param[in,out]  p_sch     Local data to be modified.
+ *                           Initial data can be obtained via fci_qos_sch_get_by_id().
+ * @param[in]      algo      selection algorithm
+ *                           For valid modes, see the FCI API Reference, 
+ *                           chapter 'scheduler algorithm'.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_qos_sch_ld_set_algo(fpp_qos_scheduler_cmd_t* p_sch, uint8_t algo)
+{
+    assert(NULL != p_sch);
+    p_sch->algo = algo;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set input of a QoS scheduler.
+ * @details        [localdata_sch]
+ * @param[in,out]  p_sch     Local data to be modified.
+ *                           Initial data can be obtained via fci_qos_sch_get_by_id().
+ * @param[in]      input_id  ID of the scheduler's input.
+ *                           There may be less than 32 inputs per scheduler 
+ *                           actually implemented in PFE. (32 is just the max array limit)
+ *                           See the FCI API Reference, chapter Egress QoS.
+ *                 enable    A request to enable/disable the given scheduler input.
+ *                 src       Data source which is connected to the given sscheduler input.
+ *                           See the FCI API Reference, chapter Egress QoS.
+ *                 weight    Weight ("importance") of the given scheduler input.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_qos_sch_ld_set_input(fpp_qos_scheduler_cmd_t* p_sch, uint8_t input_id, 
+                             bool enable, uint8_t src, uint32_t weight)
+{
+    assert(NULL != p_sch);
+    
+    int rtn = FPP_ERR_FCI;
+    if (32u > input_id)
+    {
+        if (enable)
+        {
+            p_sch->input_en |= (1uL << input_id);
+        }
+        else
+        {
+            p_sch->input_en &= ~(1uL << input_id);
+        }
+        
+        p_sch->input_src[input_id] = src;
+        p_sch->input_w[input_id] = weight;
+        
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @defgroup    localdata_shp  [localdata_shp]
+ * @brief:      Functions marked as [localdata_shp] guarantee that 
+ *              only local data are accessed.
+ * @details:    These functions do not make any FCI calls.
+ *              If some local data modifications are made, then after all local data changes
+ *              are done and finished, call fci_qos_shp_update() to 
+ *              update the given QoS shaper in the PFE.
+ */
+ 
+ 
+/*
+ * @brief          Set mode of a QoS shaper.
+ * @details        [localdata_shp]
+ * @param[in,out]  p_shp     Local data to be modified.
+ *                           Initial data can be obtained via fci_qos_shp_get_by_id().
+ * @param[in]      shp_mode  shaper mode
+ *                           For valid modes, see the FCI API Reference, 
+ *                           chapter 'shapermode'.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_qos_shp_ld_set_mode(fpp_qos_shaper_cmd_t* p_shp, uint8_t shp_mode)
+{
+    assert(NULL != p_shp);
+    p_shp->mode = shp_mode;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set position of a QoS shaper in a QoS configuration.
+ * @details        [localdata_shp]
+ * @param[in,out]  p_shp     Local data to be modified.
+ *                           Initial data can be obtained via fci_qos_shp_get_by_id().
+ * @param[in]      position  position of the QoS shaper
+ *                           For valid positions, see the FCI API Reference, 
+ *                           chapter Egress QoS.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_qos_shp_ld_set_position(fpp_qos_shaper_cmd_t* p_shp, uint8_t position)
+{
+    assert(NULL != p_shp);
+    p_shp->position = position;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set idle slope rate of a QoS shaper.
+ * @details        [localdata_shp]
+ * @param[in,out]  p_shp     Local data to be modified.
+ *                           Initial data can be obtained via fci_qos_shp_get_by_id().
+ * @param[in]      isl       idle slope rate (units per second)
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_qos_shp_ld_set_isl(fpp_qos_shaper_cmd_t* p_shp, uint32_t isl)
+{
+    assert(NULL != p_shp);
+    p_shp->isl = isl;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set minimal credit of a QoS shaper.
+ * @details        [localdata_shp]
+ * @param[in,out]  p_shp       Local data to be modified.
+ *                             Initial data can be obtained via fci_qos_shp_get_by_id().
+ * @param[in]      min_credit  minimal credit
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_qos_shp_ld_set_min_credit(fpp_qos_shaper_cmd_t* p_shp, int32_t min_credit)
+{
+    assert(NULL != p_shp);
+    p_shp->min_credit = min_credit;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set maximal credit of a QoS shaper.
+ * @details        [localdata_shp]
+ * @param[in,out]  p_shp       Local data to be modified.
+ *                             Initial data can be obtained via fci_qos_shp_get_by_id().
+ * @param[in]      min_credit  maximal credit
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_qos_shp_ld_set_max_credit(fpp_qos_shaper_cmd_t* p_shp, int32_t max_credit)
+{
+    assert(NULL != p_shp);
+    p_shp->max_credit = max_credit;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+ 
+ 
+/*
+ * @brief      Query whether an input of a QoS scheduler is enabled or not.
+ * @details    [localdata_sch]
+ * @param[in]  p_sch  Local data to be queried.
+ *                    Initial data can be obtained via fci_qos_sch_get_by_id().
+ * @param[in]  input_id  Queried scheduler input.
+ * @return     At time when the data was obtained, the given scheduler input:
+ *             true  : was enabled
+ *             false : was disabled
+ */
+bool fci_qos_sch_ld_is_input_enabled(const fpp_qos_scheduler_cmd_t* p_sch, uint8_t input_id)
+{
+    assert(NULL != p_sch);
+    return (bool)((32u > input_id) ? ((1uL << input_id) & (p_sch->input_en)) : (false));
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through QoS queues of the given physical
+ *             interface and execute a callback print function for each QoS queue.
+ * @param[in]  p_cl           FCI client instance
+ * @param[in]  p_cb_print     Callback print function.
+ *                            --> If the callback returns zero, then all is OK and 
+ *                                the next QoS queue is picked for a print process.
+ *                            --> If the callback returns non-zero, then some problem is 
+ *                                assumed and this function terminates prematurely.
+ * @param[in]  p_phyif_name   Name of a parent physical interface.
+ *                            Names of physical interfaces are hardcoded.
+ *                            See the FCI API Reference, chapter Interface Management.
+ * @return     FPP_ERR_OK : Successfully iterated through QoS queues of 
+ *                          the given physical interface.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_qos_que_print_by_phyif(FCI_CLIENT* p_cl, fci_qos_que_cb_print_t p_cb_print, 
+                               const char* p_phyif_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    assert(NULL != p_phyif_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_qos_queue_cmd_t cmd_to_fci = {0};
+    fpp_qos_queue_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
+    
+    /* do the query */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* query loop */
+        uint8_t que_id = 0u;
+        while (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.id = que_id;
+            cmd_to_fci.action = FPP_ACTION_QUERY;
+            rtn = fci_query(p_cl, FPP_CMD_QOS_QUEUE,
+                            sizeof(fpp_qos_queue_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            ntoh_que(&reply_from_fci);  /* set correct byte order */
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = p_cb_print(&reply_from_fci);
+            }
+            
+            que_id++;
+        }
+        
+        /* query loop runs till there are no more QoS queues to report */
+        /* the following error is therefore OK and expected (it ends the query loop) */
+        if (FPP_ERR_QOS_QUEUE_NOT_FOUND == rtn)
+        {
+            rtn = FPP_ERR_OK;
+        }
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all QoS queues in the PFE which
+ *              are a part of a given parent physical interface.
+ * @param[in]   p_cl          FCI client instance
+ * @param[out]  p_rtn_count   Space to store the count of QoS queues.
+ * @param[in]   p_phyif_name  Name of a parent physical interface.
+ *                            Names of physical interfaces are hardcoded.
+ *                            See the FCI API Reference, chapter Interface Management.
+ * @return      FPP_ERR_OK : Successfully counted QoS queues.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No count was stored.
+ */
+int fci_qos_que_get_count_by_phyif(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, 
+                                   const char* p_phyif_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_phyif_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_qos_queue_cmd_t cmd_to_fci = {0};
+    fpp_qos_queue_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
+    
+    /* do the query */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* query loop */
+        uint8_t que_id = 0u;
+        while (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.id = que_id;
+            cmd_to_fci.action = FPP_ACTION_QUERY;
+            rtn = fci_query(p_cl, FPP_CMD_QOS_QUEUE,
+                            sizeof(fpp_qos_queue_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            /* no need to set correct byte order (we are just counting QoS queues) */
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                que_id++;
+            }
+        }
+        
+        /* query loop runs till there are no more QoS queues to report */
+        /* the following error is therefore OK and expected (it ends the query loop) */
+        if (FPP_ERR_QOS_QUEUE_NOT_FOUND == rtn)
+        {
+            *p_rtn_count = que_id;
+            rtn = FPP_ERR_OK;
+        }
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through QoS schedulers of the given physical
+ *             interface and execute a callback print function for each QoS scheduler.
+ * @param[in]  p_cl           FCI client instance
+ * @param[in]  p_cb_print     Callback print function.
+ *                            --> If the callback returns zero, then all is OK and 
+ *                                the next QoS scheduler is picked for a print process.
+ *                            --> If the callback returns non-zero, then some problem is 
+ *                                assumed and this function terminates prematurely.
+ * @param[in]  p_phyif_name   Name of a parent physical interface.
+ *                            Names of physical interfaces are hardcoded.
+ *                            See the FCI API Reference, chapter Interface Management.
+ * @return     FPP_ERR_OK : Successfully iterated through QoS schedulers of 
+ *                          the given physical interface.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_qos_sch_print_by_phyif(FCI_CLIENT* p_cl, fci_qos_sch_cb_print_t p_cb_print, 
+                               const char* p_phyif_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    assert(NULL != p_phyif_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_qos_scheduler_cmd_t cmd_to_fci = {0};
+    fpp_qos_scheduler_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
+    
+    /* do the query */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* query loop */
+        uint8_t sch_id = 0u;
+        while (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.id = sch_id;
+            cmd_to_fci.action = FPP_ACTION_QUERY;
+            rtn = fci_query(p_cl, FPP_CMD_QOS_SCHEDULER,
+                            sizeof(fpp_qos_scheduler_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            ntoh_sch(&reply_from_fci);  /* set correct byte order */
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = p_cb_print(&reply_from_fci);
+            }
+            
+            sch_id++;
+        }
+        
+        /* query loop runs till there are no more QoS schedulers to report */
+        /* the following error is therefore OK and expected (it ends the query loop) */
+        if (FPP_ERR_QOS_SCHEDULER_NOT_FOUND == rtn)
+        {
+            rtn = FPP_ERR_OK;
+        }
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all QoS schedulers in the PFE which
+ *              are a part of a given parent physical interface.
+ * @param[in]   p_cl          FCI client instance
+ * @param[out]  p_rtn_count   Space to store the count of QoS schedulers.
+ * @param[in]   p_phyif_name  Name of a parent physical interface.
+ *                            Names of physical interfaces are hardcoded.
+ *                            See the FCI API Reference, chapter Interface Management.
+ * @return      FPP_ERR_OK : Successfully counted QoS schedulers.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No count was stored.
+ */
+int fci_qos_sch_get_count_by_phyif(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, 
+                                   const char* p_phyif_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_phyif_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_qos_scheduler_cmd_t cmd_to_fci = {0};
+    fpp_qos_scheduler_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
+    
+    /* do the query */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* query loop */
+        uint8_t sch_id = 0u;
+        while (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.id = sch_id;
+            cmd_to_fci.action = FPP_ACTION_QUERY;
+            rtn = fci_query(p_cl, FPP_CMD_QOS_SCHEDULER,
+                            sizeof(fpp_qos_scheduler_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            /* no need to set correct byte order (we are just counting QoS schedulers) */
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                sch_id++;
+            }
+        }
+        
+        /* query loop runs till there are no more QoS schedulers to report */
+        /* the following error is therefore OK and expected (it ends the query loop) */
+        if (FPP_ERR_QOS_SCHEDULER_NOT_FOUND == rtn)
+        {
+            *p_rtn_count = sch_id;
+            rtn = FPP_ERR_OK;
+        }
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through QoS shapers of the given physical
+ *             interface and execute a callback print function for each QoS shaper.
+ * @param[in]  p_cl           FCI client instance
+ * @param[in]  p_cb_print     Callback print function.
+ *                            --> If the callback returns zero, then all is OK and 
+ *                                the next QoS shaper is picked for a print process.
+ *                            --> If the callback returns non-zero, then some problem is 
+ *                                assumed and this function terminates prematurely.
+ * @param[in]  p_phyif_name   Name of a parent physical interface.
+ *                            Names of physical interfaces are hardcoded.
+ *                            See the FCI API Reference, chapter Interface Management.
+ * @return     FPP_ERR_OK : Successfully iterated through QoS shapers of 
+ *                          the given physical interface.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_qos_shp_print_by_phyif(FCI_CLIENT* p_cl, fci_qos_shp_cb_print_t p_cb_print, 
+                               const char* p_phyif_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    assert(NULL != p_phyif_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_qos_shaper_cmd_t cmd_to_fci = {0};
+    fpp_qos_shaper_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
+    
+    /* do the query */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* query loop */
+        uint8_t shp_id = 0u;
+        while (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.id = shp_id;
+            cmd_to_fci.action = FPP_ACTION_QUERY;
+            rtn = fci_query(p_cl, FPP_CMD_QOS_SHAPER,
+                            sizeof(fpp_qos_shaper_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            ntoh_shp(&reply_from_fci);  /* set correct byte order */
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = p_cb_print(&reply_from_fci);
+            }
+            
+            shp_id++;
+        }
+        
+        /* query loop runs till there are no more QoS shapers to report */
+        /* the following error is therefore OK and expected (it ends the query loop) */
+        if (FPP_ERR_QOS_SHAPER_NOT_FOUND == rtn)
+        {
+            rtn = FPP_ERR_OK;
+        }
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all QoS shapers in the PFE which
+ *              are a part of a given parent physical interface.
+ * @param[in]   p_cl          FCI client instance
+ * @param[out]  p_rtn_count   Space to store the count of QoS shapers.
+ * @param[in]   p_phyif_name  Name of a parent physical interface.
+ *                            Names of physical interfaces are hardcoded.
+ *                            See the FCI API Reference, chapter Interface Management.
+ * @return      FPP_ERR_OK : Successfully counted QoS shapers.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No count was stored.
+ */
+int fci_qos_shp_get_count_by_phyif(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, 
+                                   const char* p_phyif_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_phyif_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_qos_shaper_cmd_t cmd_to_fci = {0};
+    fpp_qos_shaper_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
+    
+    /* do the query */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* query loop */
+        uint8_t shp_id = 0u;
+        while (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.id = shp_id;
+            cmd_to_fci.action = FPP_ACTION_QUERY;
+            rtn = fci_query(p_cl, FPP_CMD_QOS_SHAPER,
+                            sizeof(fpp_qos_shaper_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            /* no need to set correct byte order (we are just counting QoS queues) */
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                shp_id++;
+            }
+        }
+        
+        /* query loop runs till there are no more QoS shapers to report */
+        /* the following error is therefore OK and expected (it ends the query loop) */
+        if (FPP_ERR_QOS_SHAPER_NOT_FOUND == rtn)
+        {
+            *p_rtn_count = shp_id;
+            rtn = FPP_ERR_OK;
+        }
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_interface/fci_qos.h b/sw/libfci_cli/src/libfci_interface/fci_qos.h
new file mode 100644
index 0000000..53a87ac
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_interface/fci_qos.h
@@ -0,0 +1,74 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef FCI_SPD_H_
+#define FCI_SPD_H_
+
+#include "fpp_ext.h"
+#include "libfci.h"
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+typedef int (*fci_qos_que_cb_print_t)(const fpp_qos_queue_cmd_t* p_que);
+typedef int (*fci_qos_sch_cb_print_t)(const fpp_qos_scheduler_cmd_t* p_sch);
+typedef int (*fci_qos_shp_cb_print_t)(const fpp_qos_shaper_cmd_t* p_shp);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
+
+int fci_qos_que_get_by_id(FCI_CLIENT* p_cl, fpp_qos_queue_cmd_t* p_rtn_que, const char* p_phyif_name, uint8_t que_id);
+int fci_qos_sch_get_by_id(FCI_CLIENT* p_cl, fpp_qos_scheduler_cmd_t* p_rtn_sch, const char* p_phyif_name, uint8_t sch_id);
+int fci_qos_shp_get_by_id(FCI_CLIENT* p_cl, fpp_qos_shaper_cmd_t* p_rtn_shp, const char* p_phyif_name, uint8_t shp_id);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
+
+int fci_qos_que_update(FCI_CLIENT* p_cl, fpp_qos_queue_cmd_t* p_que);
+int fci_qos_sch_update(FCI_CLIENT* p_cl, fpp_qos_scheduler_cmd_t* p_sch);
+int fci_qos_shp_update(FCI_CLIENT* p_cl, fpp_qos_shaper_cmd_t* p_shp);
+
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+
+int fci_qos_que_ld_set_mode(fpp_qos_queue_cmd_t* p_que, uint8_t que_mode);
+int fci_qos_que_ld_set_min(fpp_qos_queue_cmd_t* p_que, uint32_t min);
+int fci_qos_que_ld_set_max(fpp_qos_queue_cmd_t* p_que, uint32_t max);
+int fci_qos_que_ld_set_zprob(fpp_qos_queue_cmd_t* p_que, uint8_t zprob_id, uint8_t percentage);
+
+int fci_qos_sch_ld_set_mode(fpp_qos_scheduler_cmd_t* p_sch, uint8_t sch_mode);
+int fci_qos_sch_ld_set_algo(fpp_qos_scheduler_cmd_t* p_sch, uint8_t algo);
+int fci_qos_sch_ld_set_input(fpp_qos_scheduler_cmd_t* p_sch, uint8_t input_id, bool enable, uint8_t src, uint32_t weight);
+
+int fci_qos_shp_ld_set_mode(fpp_qos_shaper_cmd_t* p_shp, uint8_t shp_mode);
+int fci_qos_shp_ld_set_position(fpp_qos_shaper_cmd_t* p_shp, uint8_t position);
+int fci_qos_shp_ld_set_isl(fpp_qos_shaper_cmd_t* p_shp, uint32_t isl);
+int fci_qos_shp_ld_set_min_credit(fpp_qos_shaper_cmd_t* p_shp, int32_t min_credit);
+int fci_qos_shp_ld_set_max_credit(fpp_qos_shaper_cmd_t* p_shp, int32_t max_credit);
+
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+
+bool fci_qos_sch_ld_is_input_enabled(const fpp_qos_scheduler_cmd_t* p_sch, uint8_t input_id);
+
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+
+int fci_qos_que_print_by_phyif(FCI_CLIENT* p_cl, fci_qos_que_cb_print_t p_cb_print, const char* p_phyif_name);
+int fci_qos_que_get_count_by_phyif(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, const char* p_parent_name);
+
+int fci_qos_sch_print_by_phyif(FCI_CLIENT* p_cl, fci_qos_sch_cb_print_t p_cb_print, const char* p_phyif_name);
+int fci_qos_sch_get_count_by_phyif(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, const char* p_parent_name);
+
+int fci_qos_shp_print_by_phyif(FCI_CLIENT* p_cl, fci_qos_shp_cb_print_t p_cb_print, const char* p_phyif_name);
+int fci_qos_shp_get_count_by_phyif(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, const char* p_parent_name);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_interface/fci_rt_ct.c b/sw/libfci_cli/src/libfci_interface/fci_rt_ct.c
new file mode 100644
index 0000000..a3b4e6b
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_interface/fci_rt_ct.c
@@ -0,0 +1,1785 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <string.h>
+#include <arpa/inet.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+#include "fci_common.h"
+#include "fci_rt_ct.h"
+ 
+ 
+/* ==== PRIVATE FUNCTIONS ================================================== */
+ 
+ 
+/*
+ * @brief          Network-to-host (ntoh) function for a route struct.
+ * @param[in,out]  p_rtn_rt  The route struct to be converted.
+ */
+static void ntoh_rt(fpp_rt_cmd_t* p_rtn_rt)
+{
+    assert(NULL != p_rtn_rt);
+    
+    
+    p_rtn_rt->id = ntohl(p_rtn_rt->id);
+    p_rtn_rt->flags = ntohl(p_rtn_rt->flags);
+}
+ 
+ 
+/*
+ * @brief          Host-to-network (hton) function for a route struct.
+ * @param[in,out]  p_rtn_rt  The route struct to be converted.
+ */
+static void hton_rt(fpp_rt_cmd_t* p_rtn_rt)
+{
+    assert(NULL != p_rtn_rt);
+    
+    
+    p_rtn_rt->id = htonl(p_rtn_rt->id);
+    p_rtn_rt->flags = htonl(p_rtn_rt->flags);
+}
+ 
+ 
+/*
+ * @brief          Network-to-host (ntoh) function for an IPv4 conntrack struct.
+ * @param[in,out]  p_rtn_ct  The IPv4 conntrack struct to be converted.
+ */
+static void ntoh_ct(fpp_ct_cmd_t* p_rtn_ct)
+{
+    assert(NULL != p_rtn_ct);
+    
+    
+    p_rtn_ct->saddr = ntohl(p_rtn_ct->saddr);
+    p_rtn_ct->daddr = ntohl(p_rtn_ct->daddr);
+    p_rtn_ct->sport = ntohs(p_rtn_ct->sport);
+    p_rtn_ct->dport = ntohs(p_rtn_ct->dport);
+    p_rtn_ct->saddr_reply = ntohl(p_rtn_ct->saddr_reply);
+    p_rtn_ct->daddr_reply = ntohl(p_rtn_ct->daddr_reply);
+    p_rtn_ct->sport_reply = ntohs(p_rtn_ct->sport_reply);
+    p_rtn_ct->dport_reply = ntohs(p_rtn_ct->dport_reply);
+    p_rtn_ct->protocol = ntohs(p_rtn_ct->protocol);
+    p_rtn_ct->flags = ntohs(p_rtn_ct->flags);
+    p_rtn_ct->route_id = ntohl(p_rtn_ct->route_id);
+    p_rtn_ct->route_id_reply = ntohl(p_rtn_ct->route_id_reply);
+}
+ 
+ 
+/*
+ * @brief          Host-to-network (hton) function for the IPv4 conntrack struct.
+ * @param[in,out]  p_rtn_ct  The IPv4 conntrack struct to be converted.
+ */
+static void hton_ct(fpp_ct_cmd_t* p_rtn_ct)
+{
+    assert(NULL != p_rtn_ct);
+    
+    
+    p_rtn_ct->saddr = htonl(p_rtn_ct->saddr);
+    p_rtn_ct->daddr = htonl(p_rtn_ct->daddr);
+    p_rtn_ct->sport = htons(p_rtn_ct->sport);
+    p_rtn_ct->dport = htons(p_rtn_ct->dport);
+    p_rtn_ct->saddr_reply = htonl(p_rtn_ct->saddr_reply);
+    p_rtn_ct->daddr_reply = htonl(p_rtn_ct->daddr_reply);
+    p_rtn_ct->sport_reply = htons(p_rtn_ct->sport_reply);
+    p_rtn_ct->dport_reply = htons(p_rtn_ct->dport_reply);
+    p_rtn_ct->protocol = htons(p_rtn_ct->protocol);
+    p_rtn_ct->flags = htons(p_rtn_ct->flags);
+    p_rtn_ct->route_id = htonl(p_rtn_ct->route_id);
+    p_rtn_ct->route_id_reply = htonl(p_rtn_ct->route_id_reply);
+}
+ 
+ 
+/*
+ * @brief          Network-to-host (ntoh) function for the IPv6 conntrack struct.
+ * @param[in,out]  p_rtn_ct  The IPv6 conntrack struct to be converted.
+ */
+static void ntoh_ct6(fpp_ct6_cmd_t* p_rtn_ct6)
+{
+    assert(NULL != p_rtn_ct6);
+    
+    
+    p_rtn_ct6->saddr[0] = ntohl(p_rtn_ct6->saddr[0]);
+    p_rtn_ct6->saddr[1] = ntohl(p_rtn_ct6->saddr[1]);
+    p_rtn_ct6->saddr[2] = ntohl(p_rtn_ct6->saddr[2]);
+    p_rtn_ct6->saddr[3] = ntohl(p_rtn_ct6->saddr[3]);
+    p_rtn_ct6->daddr[0] = ntohl(p_rtn_ct6->daddr[0]);
+    p_rtn_ct6->daddr[1] = ntohl(p_rtn_ct6->daddr[1]);
+    p_rtn_ct6->daddr[2] = ntohl(p_rtn_ct6->daddr[2]);
+    p_rtn_ct6->daddr[3] = ntohl(p_rtn_ct6->daddr[3]);
+    p_rtn_ct6->sport = ntohs(p_rtn_ct6->sport);
+    p_rtn_ct6->dport = ntohs(p_rtn_ct6->dport);
+    p_rtn_ct6->saddr_reply[0] = ntohl(p_rtn_ct6->saddr_reply[0]);
+    p_rtn_ct6->saddr_reply[1] = ntohl(p_rtn_ct6->saddr_reply[1]);
+    p_rtn_ct6->saddr_reply[2] = ntohl(p_rtn_ct6->saddr_reply[2]);
+    p_rtn_ct6->saddr_reply[3] = ntohl(p_rtn_ct6->saddr_reply[3]);
+    p_rtn_ct6->daddr_reply[0] = ntohl(p_rtn_ct6->daddr_reply[0]);
+    p_rtn_ct6->daddr_reply[1] = ntohl(p_rtn_ct6->daddr_reply[1]);
+    p_rtn_ct6->daddr_reply[2] = ntohl(p_rtn_ct6->daddr_reply[2]);
+    p_rtn_ct6->daddr_reply[3] = ntohl(p_rtn_ct6->daddr_reply[3]);
+    p_rtn_ct6->sport_reply = ntohs(p_rtn_ct6->sport_reply);
+    p_rtn_ct6->dport_reply = ntohs(p_rtn_ct6->dport_reply);
+    p_rtn_ct6->protocol = ntohs(p_rtn_ct6->protocol);
+    p_rtn_ct6->flags = ntohs(p_rtn_ct6->flags);
+    p_rtn_ct6->route_id = ntohl(p_rtn_ct6->route_id);
+    p_rtn_ct6->route_id_reply = ntohl(p_rtn_ct6->route_id_reply);
+}
+ 
+ 
+/*
+ * @brief          Host-to-network (hton) function for the IPv6 conntrack struct.
+ * @param[in,out]  p_rtn_ct  The IPv6 conntrack struct to be converted.
+ */
+static void hton_ct6(fpp_ct6_cmd_t* p_rtn_ct6)
+{
+    assert(NULL != p_rtn_ct6);
+    
+    
+    p_rtn_ct6->saddr[0] = htonl(p_rtn_ct6->saddr[0]);
+    p_rtn_ct6->saddr[1] = htonl(p_rtn_ct6->saddr[1]);
+    p_rtn_ct6->saddr[2] = htonl(p_rtn_ct6->saddr[2]);
+    p_rtn_ct6->saddr[3] = htonl(p_rtn_ct6->saddr[3]);
+    p_rtn_ct6->daddr[0] = htonl(p_rtn_ct6->daddr[0]);
+    p_rtn_ct6->daddr[1] = htonl(p_rtn_ct6->daddr[1]);
+    p_rtn_ct6->daddr[2] = htonl(p_rtn_ct6->daddr[2]);
+    p_rtn_ct6->daddr[3] = htonl(p_rtn_ct6->daddr[3]);
+    p_rtn_ct6->sport = htons(p_rtn_ct6->sport);
+    p_rtn_ct6->dport = htons(p_rtn_ct6->dport);
+    p_rtn_ct6->saddr_reply[0] = htonl(p_rtn_ct6->saddr_reply[0]);
+    p_rtn_ct6->saddr_reply[1] = htonl(p_rtn_ct6->saddr_reply[1]);
+    p_rtn_ct6->saddr_reply[2] = htonl(p_rtn_ct6->saddr_reply[2]);
+    p_rtn_ct6->saddr_reply[3] = htonl(p_rtn_ct6->saddr_reply[3]);
+    p_rtn_ct6->daddr_reply[0] = htonl(p_rtn_ct6->daddr_reply[0]);
+    p_rtn_ct6->daddr_reply[1] = htonl(p_rtn_ct6->daddr_reply[1]);
+    p_rtn_ct6->daddr_reply[2] = htonl(p_rtn_ct6->daddr_reply[2]);
+    p_rtn_ct6->daddr_reply[3] = htonl(p_rtn_ct6->daddr_reply[3]);
+    p_rtn_ct6->sport_reply = htons(p_rtn_ct6->sport_reply);
+    p_rtn_ct6->dport_reply = htons(p_rtn_ct6->dport_reply);
+    p_rtn_ct6->protocol = htons(p_rtn_ct6->protocol);
+    p_rtn_ct6->flags = htons(p_rtn_ct6->flags);
+    p_rtn_ct6->route_id = htonl(p_rtn_ct6->route_id);
+    p_rtn_ct6->route_id_reply = htonl(p_rtn_ct6->route_id_reply);
+}
+ 
+ 
+/*
+ * @brief          Host-to-network (hton) function for the timeout struct.
+ * @param[in,out]  p_rtn_ct  The timeout struct to be converted.
+ */
+static void hton_timeout(fpp_timeout_cmd_t* p_rtn_timeout)
+{
+    assert(NULL != p_rtn_timeout);
+    
+    
+    p_rtn_timeout->protocol = htons(p_rtn_timeout->protocol);
+    p_rtn_timeout->sam_4o6_timeout = htons(p_rtn_timeout->sam_4o6_timeout);
+    p_rtn_timeout->timeout_value1 = htonl(p_rtn_timeout->timeout_value1);
+    p_rtn_timeout->timeout_value2 = htonl(p_rtn_timeout->timeout_value2);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested route from the PFE.
+ *              Identify the route by its ID.
+ * @param[in]   p_cl      FCI client instance
+ * @param[out]  p_rtn_rt  Space for data from the PFE.
+ * @param[in]   id        ID of the requested route.
+ *                        Route IDs are user-defined. See fci_rt_add().
+ * @return      FPP_ERR_OK : Requested route was found.
+ *                           A copy of its configuration was stored into p_rtn_rt.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No data copied.
+ */
+int fci_rt_get_by_id(FCI_CLIENT* p_cl, fpp_rt_cmd_t* p_rtn_rt, uint32_t id)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_rt);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_rt_cmd_t cmd_to_fci = {0};
+    fpp_rt_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_IP_ROUTE,
+                    sizeof(fpp_rt_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    ntoh_rt(&reply_from_fci);  /* set correct byte order */
+    
+    /* query loop (with the search condition) */
+    while ((FPP_ERR_OK == rtn) && (id != (reply_from_fci.id)))
+    {
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_IP_ROUTE,
+                        sizeof(fpp_rt_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        ntoh_rt(&reply_from_fci);  /* set correct byte order */
+    }
+    
+    /* if search successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_rt = reply_from_fci;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested IPv4 conntrack 
+ *              from the PFE. Identify the conntrack by a specific tuple of parameters.
+ * @param[in]   p_cl       FCI client instance
+ * @param[out]  p_rtn_ct   Space for data from the PFE.
+ * @param[in]   p_ct_data  Configuration data for IPv4 conntrack identification.
+ *                         To identify a conntrack, all following data must be correctly set:
+ *                           --> protocol
+ *                           --> saddr
+ *                           --> daddr
+ *                           --> sport
+ *                           --> dport
+ * @return      FPP_ERR_OK : Requested route was found.
+ *                           A copy of its configuration was stored into p_rtn_ct.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No data copied.
+ */
+int fci_ct_get_by_tuple(FCI_CLIENT* p_cl, fpp_ct_cmd_t* p_rtn_ct, 
+                                    const fpp_ct_cmd_t* p_ct_data)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_ct);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_ct_cmd_t cmd_to_fci = {0};
+    fpp_ct_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_IPV4_CONNTRACK,
+                    sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    ntoh_ct(&reply_from_fci);  /* set correct byte order */
+    
+    /* query loop (with the search condition) */
+    while ((FPP_ERR_OK == rtn) &&
+           (
+            ((p_ct_data->protocol) == (reply_from_fci.protocol)) && 
+            ((p_ct_data->sport) == (reply_from_fci.sport)) && 
+            ((p_ct_data->dport) == (reply_from_fci.dport)) &&
+            ((p_ct_data->saddr) == (reply_from_fci.saddr)) && 
+            ((p_ct_data->daddr) == (reply_from_fci.daddr)) 
+           )
+          )
+    {
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_IPV4_CONNTRACK,
+                        sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        ntoh_ct(&reply_from_fci);  /* set correct byte order */
+    }
+    
+    /* if search successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_ct = reply_from_fci;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested IPv6 conntrack 
+ *              from the PFE. Identify the conntrack by a specific tuple of parameters.
+ * @param[in]   p_cl        FCI client instance
+ * @param[out]  p_rtn_ct6   Space for data from the PFE.
+ * @param[in]   p_ct6_data  Configuration data for IPv6 conntrack identification.
+ *                          To identify a conntrack, all following data must be correctly set:
+ *                            --> protocol
+ *                            --> saddr
+ *                            --> daddr
+ *                            --> sport
+ *                            --> dport
+ * @return      FPP_ERR_OK : Requested route was found.
+ *                           A copy of its configuration was stored into p_rtn_ct6.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No data copied.
+ */
+int fci_ct6_get_by_tuple(FCI_CLIENT* p_cl, fpp_ct6_cmd_t* p_rtn_ct6, 
+                                     const fpp_ct6_cmd_t* p_ct6_data)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_ct6);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_ct6_cmd_t cmd_to_fci = {0};
+    fpp_ct6_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_IPV6_CONNTRACK,
+                    sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    ntoh_ct6(&reply_from_fci);  /* set correct byte order */
+    
+    /* query loop (with the search condition) */
+    while ((FPP_ERR_OK == rtn) &&
+           (
+            ((p_ct6_data->protocol) == (reply_from_fci.protocol)) && 
+            ((p_ct6_data->sport) == (reply_from_fci.sport)) && 
+            ((p_ct6_data->dport) == (reply_from_fci.dport)) &&
+            (0 == memcmp(p_ct6_data->saddr, reply_from_fci.saddr, (4 * sizeof(uint32_t)))) &&
+            (0 == memcmp(p_ct6_data->daddr, reply_from_fci.daddr, (4 * sizeof(uint32_t))))
+           )
+          )
+    {
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_IPV6_CONNTRACK,
+                        sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        ntoh_ct6(&reply_from_fci);  /* set correct byte order */
+    }
+    
+    /* if search successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_ct6 = reply_from_fci;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
+ 
+ 
+/*
+ * @brief       Use FCI calls to update configuration of a target IPv4 conntrack in the PFE.
+ * @details     NOTE: For conntracks, only a few selected parameters can be modified.
+ *                    See FCI API Reference, chapter FPP_CMD_IPV4_CONNTRACK, 
+ *              subsection "Action FPP_ACTION_UPDATE"
+ * @param[in]   p_cl       FCI client instance
+ * @param[in]   p_ct_data  Data struct which represents a new configuration of 
+ *                         the target IPv4 conntrack.
+ *                         Initial data can be obtained via fci_ct_get_by_tuple().
+ * @return      FPP_ERR_OK : Configuration of the target IPv4 conntrack was
+ *                           successfully updated in the PFE.
+ *              other      : Some error occured (represented by the respective error code).
+ */
+int fci_ct_update(FCI_CLIENT* p_cl, const fpp_ct_cmd_t* p_ct_data)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_ct_data);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_ct_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci = *p_ct_data;
+    
+    /* send data */
+    hton_ct(&cmd_to_fci);  /* set correct byte order */
+    cmd_to_fci.action = FPP_ACTION_UPDATE;
+    rtn = fci_write(p_cl, FPP_CMD_IPV4_CONNTRACK, sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci));
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to update configuration of a target IPv6 conntrack in the PFE.
+ * @details     NOTE: For conntracks, only a few selected parameters can be modified.
+ *                    See FCI API Reference, chapter FPP_CMD_IPV6_CONNTRACK, 
+ *              subsection "Action FPP_ACTION_UPDATE"
+ * @param[in]   p_cl        FCI client instance
+ * @param[in]   p_ct6_data  Data struct which represents a new configuration of 
+ *                          the target IPv6 conntrack.
+ *                          Initial data can be obtained via fci_ct6_get_by_tuple().
+ * @return      FPP_ERR_OK : Configuration of the target IPv6 conntrack was
+ *                           successfully updated in the PFE.
+ *              other      : Some error occured (represented by the respective error code).
+ */
+int fci_ct6_update(FCI_CLIENT* p_cl, const fpp_ct6_cmd_t* p_ct6_data)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_ct6_data);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_ct6_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci = *p_ct6_data;
+    
+    /* send data */
+    hton_ct6(&cmd_to_fci);  /* set correct byte order */
+    cmd_to_fci.action = FPP_ACTION_UPDATE;
+    rtn = fci_write(p_cl, FPP_CMD_IPV6_CONNTRACK, sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci));
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to set timeout for IPv4 TCP conntracks in the PFE.
+ * @param[in]   p_cl     FCI client instance
+ * @param[in]   timeout  Timeout [seconds]
+ * @param[in]   is_4o6   Set true if the timeout is intended for 
+ *                       IPv4 over IPv6 tunnel connections.
+ * @return      FPP_ERR_OK : New timeout was set.
+ *              other      : Some error occured (represented by the respective error code).
+ */
+int fci_ct_timeout_tcp(FCI_CLIENT* p_cl, uint32_t timeout, bool is_4o6)
+{
+    assert(NULL != p_cl);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_timeout_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci.protocol = 6u;  /* 6 == tcp */
+    cmd_to_fci.timeout_value1 = timeout;
+    cmd_to_fci.sam_4o6_timeout = ((is_4o6) ? (1u) : (0u));
+    
+    /* send data */
+    hton_timeout(&cmd_to_fci);  /* set correct byte order */
+    rtn = fci_write(p_cl, FPP_CMD_IPV4_SET_TIMEOUT, sizeof(fpp_timeout_cmd_t), 
+                                                   (unsigned short*)(&cmd_to_fci));
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to set timeout for IPv4 UDP conntracks in the PFE.
+ * @param[in]   p_cl      FCI client instance
+ * @param[in]   timeout   Timeout [seconds]
+ * @param[in]   timeout2  Separate timeout for unidirectional IPv4 UDP conntracks.
+ *                        If zero, then it is ignored and 'timeout' value is used for both
+ *                        bidirectional and unidirectional conntracks.
+ * @param[in]   is_4o6    Set true if the timeout is intended for 
+ *                        IPv4 over IPv6 tunnel connections.
+ * @return      FPP_ERR_OK : New timeout was set.
+ *              other      : Some error occured (represented by the respective error code).
+ */
+int fci_ct_timeout_udp(FCI_CLIENT* p_cl, uint32_t timeout, uint32_t timeout2, bool is_4o6)
+{
+    assert(NULL != p_cl);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_timeout_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci.protocol = 17u;  /* 17 == udp */
+    cmd_to_fci.timeout_value1 = timeout;
+    cmd_to_fci.timeout_value2 = timeout2;
+    cmd_to_fci.sam_4o6_timeout = ((is_4o6) ? (1u) : (0u));
+    
+    /* send data */
+    hton_timeout(&cmd_to_fci);  /* set correct byte order */
+    rtn = fci_write(p_cl, FPP_CMD_IPV4_SET_TIMEOUT, sizeof(fpp_timeout_cmd_t), 
+                                                   (unsigned short*)(&cmd_to_fci));
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to set timeout for all other IPv4 conntracks than TCP/UDP ones.
+ * @param[in]   p_cl     FCI client instance
+ * @param[in]   timeout  Timeout [seconds]
+ * @param[in]   is_4o6    Set true if the timeout is intended for 
+ *                        IPv4 over IPv6 tunnel connections.
+ * @return      FPP_ERR_OK : New timeout was set.
+ *              other      : Some error occured (represented by the respective error code).
+ */
+int fci_ct_timeout_others(FCI_CLIENT* p_cl, uint32_t timeout, bool is_4o6)
+{
+    assert(NULL != p_cl);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_timeout_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci.protocol = 0u;  /* 0 == others */
+    cmd_to_fci.timeout_value1 = timeout;
+    cmd_to_fci.sam_4o6_timeout = ((is_4o6) ? (1u) : (0u));
+    
+    /*  send data  */
+    hton_timeout(&cmd_to_fci);  /* set correct byte order */
+    rtn = fci_write(p_cl, FPP_CMD_IPV4_SET_TIMEOUT, sizeof(fpp_timeout_cmd_t), 
+                                                   (unsigned short*)(&cmd_to_fci));
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in the PFE ======= */
+ 
+ 
+/*
+ * @brief       Use FCI calls to create a new IP route in the PFE.
+ * @param[in]   p_cl       FCI client instance
+ * @param[in]   id         ID of the new route.
+ * @param[in]   p_rt_data  Configuration data for the new IP route.
+ *                         To create a new IP route, a local data struct must be created,
+ *                         configured and then passed to this function.
+ *                         See [localdata_rt] functions to learn more.
+ * @return      FPP_ERR_OK : New IP route was created.
+ *              other      : Some error occured (represented by the respective error code).
+ */
+int fci_rt_add(FCI_CLIENT* p_cl, uint32_t id, const fpp_rt_cmd_t* p_rt_data)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rt_data);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_rt_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci = *p_rt_data;
+    cmd_to_fci.id = id;
+    
+    /* send data */
+    hton_rt(&cmd_to_fci);  /* set correct byte order */
+    cmd_to_fci.action = FPP_ACTION_REGISTER;
+    rtn = fci_write(p_cl, FPP_CMD_IP_ROUTE, sizeof(fpp_rt_cmd_t), 
+                                           (unsigned short*)(&cmd_to_fci));
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to destroy the target IP route in the PFE.
+ * @param[in]   p_cl  FCI client instance
+ * @param[in]   id    ID of the route to destroy.
+ * @return      FPP_ERR_OK : IP route was destroyed.
+ *              other      : Some error occured (represented by the respective error code).
+ */
+int fci_rt_del(FCI_CLIENT* p_cl, uint32_t id)
+{
+    assert(NULL != p_cl);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_rt_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci.id = id;
+    
+    /* send data */
+    hton_rt(&cmd_to_fci);  /*  set correct byte order  */
+    cmd_to_fci.action = FPP_ACTION_DEREGISTER;
+    rtn = fci_write(p_cl, FPP_CMD_IP_ROUTE, sizeof(fpp_rt_cmd_t), 
+                                           (unsigned short*)(&cmd_to_fci));
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to create a new IPv4 conntrack in the PFE.
+ * @param[in]   p_cl       FCI client instance
+ * @param[in]   p_ct_data  Configuration data for the new IPv4 conntrack.
+ *                         To create a new IPv4 conntrack, a local data struct must 
+ *                         be created, configured and then passed to this function.
+ *                         See [localdata_ct] functions to learn more.
+ * @return      FPP_ERR_OK : New IPv4 conntrack was created.
+ *              other      : Some error occured (represented by the respective error code).
+ */
+int fci_ct_add(FCI_CLIENT* p_cl, const fpp_ct_cmd_t* p_ct_data)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_ct_data);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_ct_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci = *p_ct_data;
+    
+    /* send data */
+    hton_ct(&cmd_to_fci);  /* set correct byte order */
+    cmd_to_fci.action = FPP_ACTION_REGISTER;
+    rtn = fci_write(p_cl, FPP_CMD_IPV4_CONNTRACK, sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci));
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to destroy the target IPv4 conntrack in the PFE.
+ * @param[in]   p_cl  FCI client instance
+ * @param[in]   p_ct_data  Configuration data for IPv4 conntrack identification.
+ *                         To identify a conntrack, all following data must be correctly set:
+ *                           --> protocol
+ *                           --> saddr
+ *                           --> daddr
+ *                           --> sport
+ *                           --> dport
+ * @return      FPP_ERR_OK : IPv4 conntrack was destroyed.
+ *              other      : Some error occured (represented by the respective error code).
+ */
+int fci_ct_del(FCI_CLIENT* p_cl, const fpp_ct_cmd_t* p_ct_data)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_ct_data);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_ct_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci = *p_ct_data;
+    
+    /* send data */
+    hton_ct(&cmd_to_fci);  /* set correct byte order */
+    cmd_to_fci.action = FPP_ACTION_DEREGISTER;
+    rtn = fci_write(p_cl, FPP_CMD_IPV4_CONNTRACK, sizeof(fpp_ct_cmd_t), 
+                                                 (unsigned short*)(&cmd_to_fci));
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to create a new IPv6 conntrack in the PFE.
+ * @param[in]   p_cl       FCI client instance
+ * @param[in]   p_ct_data  Configuration data for the new IPv6 conntrack.
+ *                         To create a new IPv6 conntrack, a local data struct must 
+ *                         be created, configured and then passed to this function.
+ *                         See [localdata_ct6] functions to learn more.
+ * @return      FPP_ERR_OK : New IPv6 conntrack was created.
+ *              other      : Some error occured (represented by the respective error code).
+ */
+int fci_ct6_add(FCI_CLIENT* p_cl, const fpp_ct6_cmd_t* p_ct6_data)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_ct6_data);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_ct6_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci = *p_ct6_data;
+    
+    /* send data */
+    hton_ct6(&cmd_to_fci);  /* set correct byte order */
+    cmd_to_fci.action = FPP_ACTION_REGISTER;
+    rtn = fci_write(p_cl, FPP_CMD_IPV6_CONNTRACK, sizeof(fpp_ct6_cmd_t), 
+                                                 (unsigned short*)(&cmd_to_fci));
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to destroy the target IPv6 conntrack in the PFE.
+ * @param[in]   p_cl  FCI client instance
+ * @param[in]   p_ct_data  Configuration data for IPv6 conntrack identification.
+ *                         To identify a conntrack, all following data must be correctly set:
+ *                           --> protocol
+ *                           --> saddr
+ *                           --> daddr
+ *                           --> sport
+ *                           --> dport
+ * @return      FPP_ERR_OK : IPv6 conntrack was destroyed.
+ *              other      : Some error occured (represented by the respective error code).
+ */
+int fci_ct6_del(FCI_CLIENT* p_cl, const fpp_ct6_cmd_t* p_ct6_data)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_ct6_data);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_ct6_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci = *p_ct6_data;
+    
+    /* send data */
+    hton_ct6(&cmd_to_fci);  /* set correct byte order */
+    cmd_to_fci.action = FPP_ACTION_DEREGISTER;
+    rtn = fci_write(p_cl, FPP_CMD_IPV6_CONNTRACK, sizeof(fpp_ct6_cmd_t), 
+                                                 (unsigned short*)(&cmd_to_fci));
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to reset (clear) all IPv4 routes & conntracks in the PFE.
+ * @param[in]   p_cl  FCI client instance
+ * @return      FPP_ERR_OK : All IPv4 routes & conntracks were cleared.
+ *              other      : Some error occured (represented by the respective error code).
+ */
+int fci_rtct_reset_ip4(FCI_CLIENT* p_cl)
+{
+    assert(NULL != p_cl);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    /* prepare data */
+    /* empty */
+    
+    /* send data */
+    rtn = fci_write(p_cl, FPP_CMD_IPV4_RESET, 0, NULL);
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to reset (clear) all IPv6 routes & conntracks in the PFE.
+ * @param[in]   p_cl  FCI client instance
+ * @return      FPP_ERR_OK : All IPv6 routes & conntracks were cleared.
+ *              other      : Some error occured (represented by the respective error code).
+ */
+int fci_rtct_reset_ip6(FCI_CLIENT* p_cl)
+{
+    assert(NULL != p_cl);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    /* prepare data */
+    /* empty */
+    
+    /* send data */
+    rtn = fci_write(p_cl, FPP_CMD_IPV6_RESET, 0, NULL);
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+/*
+ * @defgroup    localdata_rt  [localdata_rt]
+ * @brief:      Functions marked as [localdata_rt] guarantee that 
+ *              only local data are accessed.
+ * @details:    These functions do not make any FCI calls.
+ *              If some local data modifications are made, then after all local data changes
+ *              are done and finished, call fci_rt_add() to 
+ *              create a new IP route with given configuration in the PFE.
+ */
+ 
+ 
+/*
+ * @brief          Set a route as IPv4 route. If the route was previously set as IPv6, then 
+ *                 the IPv6 flag is removed.
+ * @details        [localdata_rt]
+ * @param[in,out]  p_rt  Local data to be modified.
+ *                       For IP routes, there are no "initial data" to be obtained from PFE.
+ *                       Simply declare a local data struct and configure it.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_rt_ld_set_as_ip4(fpp_rt_cmd_t* p_rt)
+{
+    assert(NULL != p_rt);
+    p_rt->flags &= ~(FPP_IP_ROUTE_4o6);
+    p_rt->flags |= FPP_IP_ROUTE_6o4;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set a route as IPv6 route. If the route was previously set as IPv4, then 
+ *                 the IPv4 flag is removed.
+ * @details        [localdata_rt]
+ * @param[in,out]  p_rt  Local data to be modified.
+ *                       For IP routes, there are no "initial data" to be obtained from PFE.
+ *                       Simply declare a local data struct and configure it.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_rt_ld_set_as_ip6(fpp_rt_cmd_t* p_rt)
+{
+    assert(NULL != p_rt);
+    p_rt->flags &= ~(FPP_IP_ROUTE_6o4);
+    p_rt->flags |= FPP_IP_ROUTE_4o6;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set destination MAC address of a route.
+ * @details        [localdata_rt]
+ * @param[in,out]  p_rt  Local data to be modified.
+ *                       For IP routes, there are no "initial data" to be obtained from PFE.
+ *                       Simply declare a local data struct and configure it.
+ *                 p_src_mac  Source MAC address.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_rt_ld_set_src_mac(fpp_rt_cmd_t* p_rt, const uint8_t p_src_mac[6])
+{
+    assert(NULL != p_rt);
+    assert(NULL != p_src_mac);
+    memcpy((p_rt->src_mac), p_src_mac, (6 * sizeof(uint8_t)));
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set destination MAC address of a route.
+ * @details        [localdata_rt]
+ * @param[in,out]  p_rt  Local data to be modified.
+ *                       For IP routes, there are no "initial data" to be obtained from PFE.
+ *                       Simply declare a local data struct and configure it.
+ *                 p_dst_mac  Destination MAC address.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_rt_ld_set_dst_mac(fpp_rt_cmd_t* p_rt, const uint8_t p_dst_mac[6])
+{
+    assert(NULL != p_rt);
+    assert(NULL != p_dst_mac);
+    memcpy((p_rt->dst_mac), p_dst_mac, (6 * sizeof(uint8_t)));
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set egress physical interface of a route.
+ * @details        [localdata_rt]
+ * @param[in,out]  p_rt  Local data to be modified.
+ *                       For IP routes, there are no "initial data" to be obtained from PFE.
+ *                       Simply declare a local data struct and configure it.
+ * @param[in]      p_phyif_name  Name of a physical interface which shall be used as egress.
+ *                               Names of physical interfaces are hardcoded.
+ *                               See the FCI API Reference, chapter Interface Management.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_rt_ld_set_egress_phyif(fpp_rt_cmd_t* p_rt, const char* p_phyif_name)
+{
+    assert(NULL != p_rt);
+    assert(NULL != p_phyif_name);
+    
+    return set_text((p_rt->output_device), p_phyif_name, IFNAMSIZ);
+}
+ 
+ 
+/*
+ * @defgroup    localdata_ct  [localdata_ct]
+ * @brief:      Functions marked as [localdata_ct] guarantee that 
+ *              only local data are accessed.
+ * @details:    These functions do not make any FCI calls.
+ *              If some local data modifications are made, then after all local data changes
+ *              are done and finished, call fci_ct_add() to 
+ *              create a new IPv4 conntrack with given configuration in the PFE.
+ */
+ 
+ 
+/*
+ * @brief          Set protocol type of an IPv4 conntrack.
+ * @details        [localdata_ct]
+ * @param[in,out]  p_ct  Local data to be modified.
+ *                       For conntracks, there are no "initial data" to be obtained from PFE.
+ *                       Simply declare a local data struct and configure it.
+ * @param[in]      protocol  IP protocol ID
+ *                           See "IANA Assigned Internet Protocol Number":
+ *                https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_ct_ld_set_protocol(fpp_ct_cmd_t* p_ct, uint16_t protocol)
+{
+    assert(NULL != p_ct);
+    p_ct->protocol = protocol;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set ttl decrementing of an IPv4 conntrack.
+ * @details        [localdata_ct]
+ * @param[in,out]  p_ct  Local data to be modified.
+ *                       For conntracks, there are no "initial data" to be obtained from PFE.
+ *                       Simply declare a local data struct and configure it.
+ * @param[in]      enable  A request to enable/disable ttl decrementing.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_ct_ld_set_ttl_decr(fpp_ct_cmd_t* p_ct, bool enable)
+{
+    assert(NULL != p_ct);
+    if (enable)
+    {
+        p_ct->flags |= CTCMD_FLAGS_TTL_DECREMENT;
+    }
+    else
+    {
+        p_ct->flags &= (uint16_t)(~CTCMD_FLAGS_TTL_DECREMENT);
+    }
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set "orig direction" of an IPv4 conntrack.
+ * @details        [localdata_ct]
+ * @param[in,out]  p_ct  Local data to be modified.
+ *                       For conntracks, there are no "initial data" to be obtained from PFE.
+ *                       Simply declare a local data struct and configure it.
+ * @param[in]      saddr     IPv4 source address
+ * @param[in]      daddr     IPv4 destination address
+ * @param[in]      sport     Source port
+ * @param[in]      dport     Destination port
+ * @param[in]      route_id  ID of a route for the orig direction.
+ *                           The route must already exist in the PFE.
+ * @param[in]      vlan      VLAN tag
+ *                           0     : no VLAN tagging 
+ *                           non 0 : --> if packet not tagged, then VLAN tag is added.
+ *                                   --> if packet already tagged, then VLAN tag is replaced.
+ * @param[in]      unidir_orig_only  Request to make the conntrack unidirectional
+ *                                   (orig direction only).
+ *                                   If conntrack was previously configured to be
+ *                                   "reply direction only", it gets reconfigured to be
+ *                                   orig direction only.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_ct_ld_set_orig_dir(fpp_ct_cmd_t* p_ct, uint32_t saddr, uint32_t daddr,
+                           uint16_t sport, uint16_t dport,
+                           uint32_t route_id, uint16_t vlan, 
+                           bool unidir_orig_only)
+{
+    assert(NULL != p_ct);
+    
+    
+    p_ct->saddr = saddr;
+    p_ct->daddr = daddr;
+    p_ct->sport = sport;
+    p_ct->dport = dport;
+    p_ct->route_id = route_id;
+    p_ct->vlan = vlan;
+    if (unidir_orig_only)
+    {
+        p_ct->route_id_reply = 0uL;
+        p_ct->flags |= CTCMD_FLAGS_REP_DISABLED;
+        p_ct->flags &= ~(CTCMD_FLAGS_ORIG_DISABLED);
+    }
+    
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set "reply direction" of an IPv4 conntrack.
+ * @details        [localdata_ct]
+ * @param[in,out]  p_ct  Local data to be modified.
+ *                       For conntracks, there are no "initial data" to be obtained from PFE.
+ *                       Simply declare a local data struct and configure it.
+ * @param[in]      saddr_reply     IPv4 source address (reply direction)
+ * @param[in]      daddr_reply     IPv4 destination address (reply direction)
+ * @param[in]      sport_reply     Source port (reply direction)
+ * @param[in]      dport_reply     Destination port (reply direction)
+ * @param[in]      route_id_reply  ID of a route for the orig direction.
+ * @param[in]      vlan_reply      VLAN tag (reply direction)
+ *                                 0     : no VLAN tagging 
+ *                                 non 0 : --> if packet not tagged, then VLAN tag is added.
+ *                                         --> if packet already tagged, then 
+ *                                             VLAN tag is replaced.
+ * @param[in]      unidir_reply_only  Request to make the conntrack unidirectional 
+ *                                    (reply direction only).
+ *                                    If conntrack was previously configured to be
+ *                                    "orig direction only", it gets reconfigured to be
+ *                                    reply direction only.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_ct_ld_set_reply_dir(fpp_ct_cmd_t* p_ct, uint32_t saddr_reply, uint32_t daddr_reply,
+                            uint16_t sport_reply, uint16_t dport_reply,
+                            uint32_t route_id_reply, uint16_t vlan_reply,
+                            bool unidir_reply_only)
+{
+    assert(NULL != p_ct);
+    
+    
+    p_ct->saddr_reply = saddr_reply;
+    p_ct->daddr_reply = daddr_reply;
+    p_ct->sport_reply = sport_reply;
+    p_ct->dport_reply = dport_reply;
+    p_ct->route_id_reply = route_id_reply;
+    p_ct->vlan_reply = vlan_reply;
+    if (unidir_reply_only)
+    {
+        p_ct->route_id = 0uL;
+        p_ct->flags |= CTCMD_FLAGS_ORIG_DISABLED;
+        p_ct->flags &= ~(CTCMD_FLAGS_REP_DISABLED);
+    }
+    
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @defgroup    localdata_ct6  [localdata_ct6]
+ * @brief:      Functions marked as [localdata_ct] guarantee that 
+ *              only local data are accessed.
+ * @details:    These functions do not make any FCI calls.
+ *              If some local data modifications are made, then after all local data changes
+ *              are done and finished, call fci_ct6_add() to 
+ *              create a new IPv4 conntrack with given configuration in the PFE.
+ */
+ 
+ 
+/*
+ * @brief          Set protocol type of an IPv6 conntrack.
+ * @details        [localdata_ct6]
+ * @param[in,out]  p_ct  Local data to be modified.
+ *                       For conntracks, there are no "initial data" to be obtained from PFE.
+ *                       Simply declare a local data struct and configure it.
+ * @param[in]      protocol  IP protocol ID
+ *                           See "IANA Assigned Internet Protocol Number":
+ *                https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_ct6_ld_set_protocol(fpp_ct6_cmd_t* p_ct6, uint16_t protocol)
+{
+    assert(NULL != p_ct6);
+    p_ct6->protocol = protocol;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set ttl decrementing of an IPv6 conntrack.
+ * @details        [localdata_ct6]
+ * @param[in,out]  p_ct6  Local data to be modified.
+ *                        For conntracks, there are no "initial data" to be obtained from PFE.
+ *                        Simply declare a local data struct and configure it.
+ * @param[in]      enable  A request to enable/disable ttl decrementing.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_ct6_ld_set_ttl_decr(fpp_ct6_cmd_t* p_ct6, bool enable)
+{
+    assert(NULL != p_ct6);
+    if (enable)
+    {
+        p_ct6->flags |= CTCMD_FLAGS_TTL_DECREMENT;
+    }
+    else
+    {
+        p_ct6->flags &= (uint16_t)(~CTCMD_FLAGS_TTL_DECREMENT);
+    }
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set "orig direction" of an IPv6 conntrack.
+ * @details        [localdata_ct6]
+ * @param[in,out]  p_ct  Local data to be modified.
+ *                       For conntracks, there are no "initial data" to be obtained from PFE.
+ *                       Simply declare a local data struct and configure it.
+ * @param[in]      saddr     IPv6 source address
+ * @param[in]      daddr     IPv6 destination address
+ * @param[in]      sport     Source port
+ * @param[in]      dport     Destination port
+ * @param[in]      route_id  ID of a route for the orig direction.
+ *                           The route must already exist in the PFE.
+ * @param[in]      vlan      VLAN tag
+ *                           0     : no VLAN tagging 
+ *                           non 0 : --> if packet not tagged, then VLAN tag is added.
+ *                                   --> if packet already tagged, then VLAN tag is replaced.
+ * @param[in]      unidir_orig_only  Request to make the conntrack unidirectional
+ *                                   (orig direction only).
+ *                                   If conntrack was previously configured to be
+ *                                   "reply direction only", it gets reconfigured to be
+ *                                   orig direction only.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_ct6_ld_set_orig_dir(fpp_ct6_cmd_t* p_ct6, const uint32_t p_saddr[4], 
+                            const uint32_t p_daddr[4],
+                            uint16_t sport, uint16_t dport,
+                            uint32_t route_id, uint16_t vlan, 
+                            bool unidir_orig_only)
+{
+    assert(NULL != p_ct6);
+    assert(NULL != p_saddr);
+    assert(NULL != p_daddr);
+    
+    
+    memcpy((p_ct6->saddr), p_saddr, (4 * sizeof(uint32_t)));
+    memcpy((p_ct6->daddr), p_daddr, (4 * sizeof(uint32_t)));
+    p_ct6->sport = sport;
+    p_ct6->dport = dport;
+    p_ct6->route_id = route_id;
+    p_ct6->vlan = vlan;
+    if (unidir_orig_only)
+    {
+        p_ct6->route_id_reply = 0uL;
+        p_ct6->flags |= CTCMD_FLAGS_REP_DISABLED;
+        p_ct6->flags &= ~(CTCMD_FLAGS_ORIG_DISABLED);
+    }
+    
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set "reply direction" of an IPv6 conntrack.
+ * @details        [localdata_ct6]
+ * @param[in,out]  p_ct  Local data to be modified.
+ *                       For conntracks, there are no "initial data" to be obtained from PFE.
+ *                       Simply declare a local data struct and configure it.
+ * @param[in]      saddr_reply     IPv6 source address (reply direction)
+ * @param[in]      daddr_reply     IPv6 destination address (reply direction)
+ * @param[in]      sport_reply     Source port (reply direction)
+ * @param[in]      dport_reply     Destination port (reply direction)
+ * @param[in]      route_id_reply  ID of a route for the orig direction.
+ * @param[in]      vlan_reply      VLAN tag (reply direction)
+ *                                 0     : no VLAN tagging 
+ *                                 non 0 : --> if packet not tagged, then VLAN tag is added.
+ *                                         --> if packet already tagged, then 
+ *                                             VLAN tag is replaced.
+ * @param[in]      unidir_reply_only  Request to make the conntrack unidirectional 
+ *                                    (reply direction only).
+ *                                    If conntrack was previously configured to be
+ *                                    "orig direction only", it gets reconfigured to be
+ *                                    reply direction only.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_ct6_ld_set_reply_dir(fpp_ct6_cmd_t* p_ct6, const uint32_t p_saddr_reply[4], 
+                             const uint32_t p_daddr_reply[4],
+                             uint16_t sport_reply, uint16_t dport_reply,
+                             uint32_t route_id_reply, uint16_t vlan_reply,
+                             bool unidir_reply_only)
+{
+    assert(NULL != p_ct6);
+    assert(NULL != p_saddr_reply);
+    assert(NULL != p_daddr_reply);
+    
+    
+    memcpy((p_ct6->saddr_reply), p_saddr_reply, (4 * sizeof(uint32_t)));
+    memcpy((p_ct6->daddr_reply), p_daddr_reply, (4 * sizeof(uint32_t)));
+    p_ct6->sport_reply = sport_reply;
+    p_ct6->dport_reply = dport_reply;
+    p_ct6->route_id_reply = route_id_reply;
+    p_ct6->vlan_reply = vlan_reply;
+    if (unidir_reply_only)
+    {
+        p_ct6->route_id = 0uL;
+        p_ct6->flags |= CTCMD_FLAGS_ORIG_DISABLED;
+        p_ct6->flags &= ~(CTCMD_FLAGS_REP_DISABLED);
+    }
+    
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+ 
+ 
+/*
+ * @brief      Query whether the route is IPv4 route.
+ * @details    [localdata_rt]
+ * @param[in]  p_rt  Local data to be queried.
+ * @return     The route:
+ *             true  : is an IPv4 route.
+ *             false : is NOT an IPv4 route.
+ */
+bool fci_rt_ld_is_ip4(const fpp_rt_cmd_t* p_rt)
+{
+    assert(NULL != p_rt);
+    return (bool)(FPP_IP_ROUTE_6o4 & (p_rt->flags));
+}
+ 
+ 
+/*
+ * @brief      Query whether the route is IPv6 route.
+ * @details    [localdata_rt]
+ * @param[in]  p_rt  Local data to be queried.
+ * @return     The route:
+ *             true  : is an IPv6 route.
+ *             false : is NOT an IPv6 route.
+ */
+bool fci_rt_ld_is_ip6(const fpp_rt_cmd_t* p_rt)
+{
+    assert(NULL != p_rt);
+    return (bool)(FPP_IP_ROUTE_4o6 & (p_rt->flags));
+}
+ 
+ 
+/*
+ * @brief      Query whether the IPv4 conntrack serves as a NAT.
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     The IPv4 conntrack:
+ *             true  : does serve as a NAT.
+ *             false : does NOT serve as a NAT.
+ */
+bool fci_ct_ld_is_nat(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return (bool)(((p_ct->daddr_reply) != (p_ct->saddr)) || ((p_ct->saddr_reply) != (p_ct->daddr)));
+}
+ 
+ 
+/*
+ * @brief      Query whether the IPv4 conntrack serves as a PAT.
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     The IPv4 conntrack:
+ *             true  : does serve as a PAT.
+ *             false : does NOT serve as a PAT.
+ */
+bool fci_ct_ld_is_pat(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return (bool)(((p_ct->dport_reply) != (p_ct->sport)) || ((p_ct->sport_reply) != (p_ct->dport)));
+}
+ 
+ 
+/*
+ * @brief      Query whether the IPv4 conntrack modifies VLAN tags.
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     The IPv4 conntrack:
+ *             true  : does modify VLAN tags of served packets.
+ *             false : does NOT modify VLAN tags of served packets.
+ */
+bool fci_ct_ld_is_vlan_tagging(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return (bool)((0u != p_ct->vlan) || (0u != p_ct->vlan_reply));
+}
+ 
+ 
+/*
+ * @brief      Query whether the IPv4 conntrack decrements packet's TTL counter or not.
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     The IPV4 conntrack:
+ *             true  : does decrement TTL counter.
+ *             false : does NOT decrement TTL counter.
+ */
+bool fci_ct_ld_is_ttl_decr(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return (bool)(CTCMD_FLAGS_TTL_DECREMENT & (p_ct->flags));
+}
+ 
+ 
+/*
+ * @brief      Query whether the IPv4 conntrack is orig direction only.
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     The IPv4 conntrack:
+ *             true  : is orig direction only.
+ *             false : is NOT orig direction only.
+ */
+bool fci_ct_ld_is_orig_only(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return (bool)(CTCMD_FLAGS_REP_DISABLED & (p_ct->flags));
+}
+ 
+ 
+/*
+ * @brief      Query whether the IPv4 conntrack is reply direction only.
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     The IPv4 conntrack:
+ *             true  : is reply direction only.
+ *             false : is NOT reply direction only.
+ */
+bool fci_ct_ld_is_reply_only(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return (bool)(CTCMD_FLAGS_ORIG_DISABLED & (p_ct->flags));
+}
+ 
+ 
+/*
+ * @brief      Query whether the IPv6 conntrack serves as a NAT.
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     The IPv6 conntrack:
+ *             true  : does serve as a NAT.
+ *             false : does NOT serve as a NAT.
+ */
+bool fci_ct6_ld_is_nat(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return (bool)(memcmp((p_ct6->daddr_reply), (p_ct6->saddr), (4 * sizeof(uint32_t))) ||
+                  memcmp((p_ct6->saddr_reply), (p_ct6->daddr), (4 * sizeof(uint32_t))));
+}
+ 
+ 
+/*
+ * @brief      Query whether the IPv6 conntrack serves as a PAT.
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     The IPv6 conntrack:
+ *             true  : does serve as a PAT.
+ *             false : does NOT serve as a PAT.
+ */
+bool fci_ct6_ld_is_pat(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return (bool)(((p_ct6->dport_reply) != (p_ct6->sport)) || ((p_ct6->sport_reply) != (p_ct6->dport)));
+}
+ 
+ 
+/*
+ * @brief      Query whether the IPv6 conntrack modifies VLAN tags.
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     The IPv6 conntrack:
+ *             true  : does modify VLAN tags of served packets.
+ *             false : does NOT modify VLAN tags of served packets.
+ */
+bool fci_ct6_ld_is_vlan_tagging(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return (bool)((0u != p_ct6->vlan) || (0u != p_ct6->vlan_reply));
+}
+ 
+ 
+/*
+ * @brief      Query whether the IPv6 conntrack decrements packet's TTL counter or not.
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     The IPV6 conntrack:
+ *             true  : does decrement TTL counter.
+ *             false : does NOT decrement TTL counter.
+ */
+bool fci_ct6_ld_is_ttl_decr(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return (bool)(CTCMD_FLAGS_TTL_DECREMENT & (p_ct6->flags));
+}
+ 
+ 
+/*
+ * @brief      Query whether the IPv6 conntrack is orig direction only.
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     The IPv6 conntrack:
+ *             true  : is orig direction only.
+ *             false : is NOT orig direction only.
+ */
+bool fci_ct6_ld_is_orig_only(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return (bool)(CTCMD_FLAGS_REP_DISABLED & (p_ct6->flags));
+}
+ 
+ 
+/*
+ * @brief      Query whether the IPv6 conntrack is reply direction only.
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     The IPv6 conntrack:
+ *             true  : is reply direction only.
+ *             false : is NOT reply direction only.
+ */
+bool fci_ct6_ld_is_reply_only(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return (bool)(CTCMD_FLAGS_ORIG_DISABLED & (p_ct6->flags));
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all IP routes in the PFE and
+ *             execute a callback print function for each reported IP route.
+ * @param[in]  p_cl        FCI client instance
+ * @param[in]  p_cb_print  Callback print function.
+ *                         --> If the callback returns zero, then all is OK and 
+ *                             the next IP route is picked for a print process.
+ *                         --> If the callback returns non-zero, then some problem is 
+ *                             assumed and this function terminates prematurely.
+ * @param[in]  print_ip4   Set true to print IPv4 routes.
+ * @param[in]  print_ip6   Set true to print IPv6 routes.
+ * @return     FPP_ERR_OK : Successfully iterated through all IP routes.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_rt_print_all(FCI_CLIENT* p_cl, fci_rt_cb_print_t p_cb_print, bool print_ip4, bool print_ip6)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_rt_cmd_t cmd_to_fci = {0};
+    fpp_rt_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_IP_ROUTE,
+                    sizeof(fpp_rt_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    ntoh_rt(&reply_from_fci);  /* set correct byte order */
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        if ((print_ip4) && (FPP_IP_ROUTE_6o4 & (reply_from_fci.flags)))
+        {
+            rtn = p_cb_print(&reply_from_fci);  /* print IPv4 route info */
+        }
+        if ((print_ip6) && (FPP_IP_ROUTE_4o6 & (reply_from_fci.flags)))
+        {
+            rtn = p_cb_print(&reply_from_fci);  /* print IPv6 route info */
+        }
+        
+        if (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+            rtn = fci_query(p_cl, FPP_CMD_IP_ROUTE,
+                            sizeof(fpp_rt_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            ntoh_rt(&reply_from_fci);  /* set correct byte order */
+        }
+    }
+    
+    /* query loop runs till there are no more IP routes to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_RT_ENTRY_NOT_FOUND == rtn) 
+    {
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all IP routes in the PFE.
+ * @param[in]   p_cl         FCI client instance
+ * @param[out]  p_rtn_count  Space to store the count of IP routes.
+ * @return      FPP_ERR_OK : Successfully counted all IP routes.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No count was stored.
+ */
+int fci_rt_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_count);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_rt_cmd_t cmd_to_fci = {0};
+    fpp_rt_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    uint32_t count = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_IP_ROUTE,
+                    sizeof(fpp_rt_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    /* no need to set correct byte order (we are just counting routes) */
+    
+    /*  query loop  */
+    while (FPP_ERR_OK == rtn)
+    {
+        count++;
+        
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_IP_ROUTE,
+                        sizeof(fpp_rt_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        /* no need to set correct byte order (we are just counting routes) */
+    }
+    
+    /* query loop runs till there are no more IP routes to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_RT_ENTRY_NOT_FOUND == rtn)
+    {
+        *p_rtn_count = count;
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all IPv4 conntracks in the PFE and
+ *             execute a callback print function for each reported IPv4 conntrack.
+ * @param[in]  p_cl        FCI client instance
+ * @param[in]  p_cb_print  Callback print function.
+ *                         --> If the callback returns zero, then all is OK and 
+ *                             the next IPv4 conntrack is picked for a print process.
+ *                         --> If the callback returns non-zero, then some problem is 
+ *                             assumed and this function terminates prematurely.
+ * @return     FPP_ERR_OK : Successfully iterated through all IPv4 conntracks.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_ct_print_all(FCI_CLIENT* p_cl, fci_ct_cb_print_t p_cb_print)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_ct_cmd_t cmd_to_fci = {0};
+    fpp_ct_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_IPV4_CONNTRACK,
+                    sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    ntoh_ct(&reply_from_fci);  /* set correct byte order */
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        rtn = p_cb_print(&reply_from_fci);
+        
+        if (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+            rtn = fci_query(p_cl, FPP_CMD_IPV4_CONNTRACK,
+                            sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            ntoh_ct(&reply_from_fci);  /* set correct byte order */
+        }
+    }
+    
+    /* query loop runs till there are no more IPv4 conntracks to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_CT_ENTRY_NOT_FOUND == rtn)
+    {
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all IPv4 conntracks in the PFE.
+ * @param[in]   p_cl         FCI client instance
+ * @param[out]  p_rtn_count  Space to store the count of IPv4 conntracks.
+ * @return      FPP_ERR_OK : Successfully counted all IPv4 conntracks.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No count was stored.
+ */
+int fci_ct_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_count);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_ct_cmd_t cmd_to_fci = {0};
+    fpp_ct_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    uint32_t count = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_IPV4_CONNTRACK,
+                    sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    /* no need to set correct byte order (we are just counting conntracks) */
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        count++;
+        
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_IPV4_CONNTRACK,
+                        sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        /* no need to set correct byte order (we are just counting conntracks) */
+    }
+    
+    /* query loop runs till there are no more IPv4 conntracks to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_CT_ENTRY_NOT_FOUND == rtn)
+    {
+        *p_rtn_count = count;
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all IPv6 conntracks in the PFE and
+ *             execute a callback print function for each reported IPv6 conntrack.
+ * @param[in]  p_cl        FCI client instance
+ * @param[in]  p_cb_print  Callback print function.
+ *                         --> If the callback returns zero, then all is OK and 
+ *                             the next IPv6 conntrack is picked for a print process.
+ *                         --> If the callback returns non-zero, then some problem is 
+ *                             assumed and this function terminates prematurely.
+ * @return     FPP_ERR_OK : Successfully iterated through all IPv6 conntracks.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_ct6_print_all(FCI_CLIENT* p_cl, fci_ct6_cb_print_t p_cb_print)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_ct6_cmd_t cmd_to_fci = {0};
+    fpp_ct6_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_IPV6_CONNTRACK,
+                    sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    ntoh_ct6(&reply_from_fci);  /* set correct byte order */
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        rtn = p_cb_print(&reply_from_fci);
+        
+        if (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+            rtn = fci_query(p_cl, FPP_CMD_IPV6_CONNTRACK,
+                            sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            ntoh_ct6(&reply_from_fci);  /* set correct byte order */
+        }
+    }
+    
+    /* query loop runs till there are no more IPv6 conntracks to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_CT_ENTRY_NOT_FOUND == rtn)
+    {
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all IPv6 conntracks in the PFE.
+ * @param[in]   p_cl         FCI client instance
+ * @param[out]  p_rtn_count  Space to store the count of IPv6 conntracks.
+ * @return      FPP_ERR_OK : Successfully counted all IPv6 conntracks.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No count was stored.
+ */
+int fci_ct6_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_count);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_ct6_cmd_t cmd_to_fci = {0};
+    fpp_ct6_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    uint32_t count = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_IPV6_CONNTRACK,
+                    sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    /* no need to set correct byte order (we are just counting conntracks) */
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        count++;
+        
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_IPV6_CONNTRACK,
+                        sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        /* no need to set correct byte order (we are just counting conntracks) */
+    }
+    
+    /* query loop runs till there are no more IPv6 conntracks to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_CT_ENTRY_NOT_FOUND == rtn)
+    {
+        *p_rtn_count = count;
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_interface/fci_rt_ct.h b/sw/libfci_cli/src/libfci_interface/fci_rt_ct.h
new file mode 100644
index 0000000..f679ecf
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_interface/fci_rt_ct.h
@@ -0,0 +1,116 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef FCI_RT_CT_H_
+#define FCI_RT_CT_H_
+
+#include "fpp_ext.h"
+#include "libfci.h"
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+typedef int (*fci_rt_cb_print_t)(const fpp_rt_cmd_t* p_rt);
+typedef int (*fci_ct_cb_print_t)(const fpp_ct_cmd_t* p_ct);
+typedef int (*fci_ct6_cb_print_t)(const fpp_ct6_cmd_t* p_ct6);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
+
+int fci_rt_get_by_id(FCI_CLIENT* p_cl, fpp_rt_cmd_t* p_rtn_rt, uint32_t id);
+int fci_ct_get_by_tuple(FCI_CLIENT* p_cl, fpp_ct_cmd_t* p_rtn_ct, const fpp_ct_cmd_t* p_ct_data);
+int fci_ct6_get_by_tuple(FCI_CLIENT* p_cl, fpp_ct6_cmd_t* p_rtn_ct6, const fpp_ct6_cmd_t* p_ct6_data);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
+
+int fci_ct_update(FCI_CLIENT* p_cl, const fpp_ct_cmd_t* p_ct_data);
+int fci_ct6_update(FCI_CLIENT* p_cl, const fpp_ct6_cmd_t* p_ct6_data);
+
+int fci_ct_timeout_tcp(FCI_CLIENT* p_cl, uint32_t timeout, bool is_4o6);
+int fci_ct_timeout_udp(FCI_CLIENT* p_cl, uint32_t timeout, uint32_t timeout2, bool is_4o6);
+int fci_ct_timeout_others(FCI_CLIENT* p_cl, uint32_t timeout, bool is_4o6);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in the PFE ======= */
+
+int fci_rt_add(FCI_CLIENT* p_cl, uint32_t id, const fpp_rt_cmd_t* p_rt_data);
+int fci_rt_del(FCI_CLIENT* p_cl, uint32_t id);
+
+int fci_ct_add(FCI_CLIENT* p_cl, const fpp_ct_cmd_t* p_ct_data);
+int fci_ct_del(FCI_CLIENT* p_cl, const fpp_ct_cmd_t* p_ct_data);
+
+int fci_ct6_add(FCI_CLIENT* p_cl, const fpp_ct6_cmd_t* p_ct6_data);
+int fci_ct6_del(FCI_CLIENT* p_cl, const fpp_ct6_cmd_t* p_ct6_data);
+
+int fci_rtct_reset_ip4(FCI_CLIENT* p_cl);
+int fci_rtct_reset_ip6(FCI_CLIENT* p_cl);
+
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+
+int fci_rt_ld_set_as_ip4(fpp_rt_cmd_t* p_rt);
+int fci_rt_ld_set_as_ip6(fpp_rt_cmd_t* p_rt);
+int fci_rt_ld_set_src_mac(fpp_rt_cmd_t* p_rt, const uint8_t p_src_mac[6]);
+int fci_rt_ld_set_dst_mac(fpp_rt_cmd_t* p_rt, const uint8_t p_dst_mac[6]);
+int fci_rt_ld_set_egress_phyif(fpp_rt_cmd_t* p_rt, const char* p_phyif_name);
+
+int fci_ct_ld_set_protocol(fpp_ct_cmd_t* p_ct, uint16_t protocol);
+int fci_ct_ld_set_ttl_decr(fpp_ct_cmd_t* p_ct, bool enable);
+int fci_ct_ld_set_orig_dir(fpp_ct_cmd_t* p_ct, uint32_t saddr, uint32_t daddr,
+                           uint16_t sport, uint16_t dport,
+                           uint32_t route_id, uint16_t vlan, bool unidir_orig_only);
+int fci_ct_ld_set_reply_dir(fpp_ct_cmd_t* p_ct, uint32_t saddr_reply, uint32_t daddr_reply,
+                            uint16_t sport_reply, uint16_t dport_reply,
+                            uint32_t route_id_reply, uint16_t vlan_reply, bool unidir_reply_only);
+                            
+                            
+int fci_ct6_ld_set_protocol(fpp_ct6_cmd_t* p_ct6, uint16_t protocol);
+int fci_ct6_ld_set_ttl_decr(fpp_ct6_cmd_t* p_ct6, bool enable);
+int fci_ct6_ld_set_orig_dir(fpp_ct6_cmd_t* p_ct6, const uint32_t p_saddr[4], const uint32_t p_daddr[4],
+                            uint16_t sport, uint16_t dport,
+                            uint32_t route_id, uint16_t vlan, bool unidir_orig_only);
+int fci_ct6_ld_set_reply_dir(fpp_ct6_cmd_t* p_ct6, const uint32_t p_saddr_reply[4], const uint32_t p_daddr_reply[4],
+                             uint16_t sport_reply, uint16_t dport_reply,
+                             uint32_t route_id_reply, uint16_t vlan_reply, bool unidir_reply_only);
+
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+
+bool fci_rt_ld_is_ip4(const fpp_rt_cmd_t* p_rt);
+bool fci_rt_ld_is_ip6(const fpp_rt_cmd_t* p_rt);
+
+bool fci_ct_ld_is_nat(const fpp_ct_cmd_t* p_ct);
+bool fci_ct_ld_is_pat(const fpp_ct_cmd_t* p_ct);
+bool fci_ct_ld_is_vlan_tagging(const fpp_ct_cmd_t* p_ct);
+bool fci_ct_ld_is_ttl_decr(const fpp_ct_cmd_t* p_ct);
+bool fci_ct_ld_is_orig_only(const fpp_ct_cmd_t* p_ct);
+bool fci_ct_ld_is_reply_only(const fpp_ct_cmd_t* p_ct);
+
+bool fci_ct6_ld_is_nat(const fpp_ct6_cmd_t* p_ct6);
+bool fci_ct6_ld_is_pat(const fpp_ct6_cmd_t* p_ct6);
+bool fci_ct6_ld_is_vlan_tagging(const fpp_ct6_cmd_t* p_ct6);
+bool fci_ct6_ld_is_ttl_decr(const fpp_ct6_cmd_t* p_ct6);
+bool fci_ct6_ld_is_orig_only(const fpp_ct6_cmd_t* p_ct6);
+bool fci_ct6_ld_is_reply_only(const fpp_ct6_cmd_t* p_ct6);
+
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+
+int fci_rt_print_all(FCI_CLIENT* p_cl, fci_rt_cb_print_t p_cb_print, bool print_ip4, bool print_ip6);
+int fci_rt_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count);
+
+int fci_ct_print_all(FCI_CLIENT* p_cl, fci_ct_cb_print_t p_cb_print);
+int fci_ct_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count);
+
+int fci_ct6_print_all(FCI_CLIENT* p_cl, fci_ct6_cb_print_t p_cb_print);
+int fci_ct6_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_interface/fci_spd.c b/sw/libfci_cli/src/libfci_interface/fci_spd.c
new file mode 100644
index 0000000..72916bb
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_interface/fci_spd.c
@@ -0,0 +1,588 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <string.h>
+#include <arpa/inet.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+#include "fci_common.h"
+#include "fci_spd.h"
+ 
+ 
+/* ==== PRIVATE FUNCTIONS ================================================== */
+ 
+ 
+/*
+ * @brief          Network-to-host (ntoh) function for a SecurityPolicy struct.
+ * @param[in,out]  p_rtn_spd  The SecurityPolicy struct to be converted.
+ */
+static void ntoh_spd(fpp_spd_cmd_t* p_rtn_spd)
+{
+    assert(NULL != p_rtn_spd);
+    
+    
+    ntoh_enum(&(p_rtn_spd->flags), sizeof(fpp_spd_flags_t));
+    p_rtn_spd->position = ntohs(p_rtn_spd->position);
+    p_rtn_spd->saddr[0] = ntohl(p_rtn_spd->saddr[0]);
+    p_rtn_spd->saddr[1] = ntohl(p_rtn_spd->saddr[1]);
+    p_rtn_spd->saddr[2] = ntohl(p_rtn_spd->saddr[2]);
+    p_rtn_spd->saddr[3] = ntohl(p_rtn_spd->saddr[3]);
+    p_rtn_spd->daddr[0] = ntohl(p_rtn_spd->daddr[0]);
+    p_rtn_spd->daddr[1] = ntohl(p_rtn_spd->daddr[1]);
+    p_rtn_spd->daddr[2] = ntohl(p_rtn_spd->daddr[2]);
+    p_rtn_spd->daddr[3] = ntohl(p_rtn_spd->daddr[3]);
+    p_rtn_spd->sport = ntohs(p_rtn_spd->sport);
+    p_rtn_spd->dport = ntohs(p_rtn_spd->dport);
+    p_rtn_spd->sa_id = ntohl(p_rtn_spd->sa_id);
+    p_rtn_spd->spi = ntohl(p_rtn_spd->spi);
+    ntoh_enum(&(p_rtn_spd->spd_action), sizeof(fpp_spd_action_t));
+}
+ 
+ 
+/*
+ * @brief          Host-to-network (hton) function for a SecurityPolicy struct.
+ * @param[in,out]  p_rtn_spd  The SecurityPolicy struct to be converted.
+ */
+static void hton_spd(fpp_spd_cmd_t* p_rtn_spd)
+{
+    assert(NULL != p_rtn_spd);
+    
+    
+    hton_enum(&(p_rtn_spd->flags), sizeof(fpp_spd_flags_t));
+    p_rtn_spd->position = htons(p_rtn_spd->position);
+    p_rtn_spd->saddr[0] = htonl(p_rtn_spd->saddr[0]);
+    p_rtn_spd->saddr[1] = htonl(p_rtn_spd->saddr[1]);
+    p_rtn_spd->saddr[2] = htonl(p_rtn_spd->saddr[2]);
+    p_rtn_spd->saddr[3] = htonl(p_rtn_spd->saddr[3]);
+    p_rtn_spd->daddr[0] = htonl(p_rtn_spd->daddr[0]);
+    p_rtn_spd->daddr[1] = htonl(p_rtn_spd->daddr[1]);
+    p_rtn_spd->daddr[2] = htonl(p_rtn_spd->daddr[2]);
+    p_rtn_spd->daddr[3] = htonl(p_rtn_spd->daddr[3]);
+    p_rtn_spd->sport = htons(p_rtn_spd->sport);
+    p_rtn_spd->dport = htons(p_rtn_spd->dport);
+    p_rtn_spd->sa_id = htonl(p_rtn_spd->sa_id);
+    p_rtn_spd->spi = htonl(p_rtn_spd->spi);
+    hton_enum(&(p_rtn_spd->spd_action), sizeof(fpp_spd_action_t));
+}
+ 
+ 
+/*
+ * @brief       Set/unset a bitflag in a SecurityPolicy struct.
+ * @param[out]  p_rtn_spd  The SecurityPolicy struct to be modified.
+ * @param[in]   enable     New state of the bitflag.
+ * @param[in]   flag       The bitflag.
+ */
+static void set_flag(fpp_spd_cmd_t* p_rtn_spd, bool enable, fpp_spd_flags_t flag)
+{
+    assert(NULL != p_rtn_spd);
+    
+    
+    if (enable)
+    {
+        p_rtn_spd->flags |= flag;
+    }
+    else
+    {
+        p_rtn_spd->flags &= (fpp_spd_flags_t)(~flag);
+    }
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested SecurityPolicy
+ *              from the PFE. Identify the SecurityPolicy by name of the parent 
+ *              physical interface (each physical interface has its own SPD) and by
+ *              position of the policy in the SPD.
+ * @param[in]   p_cl          FCI client instance
+ * @param[out]  p_rtn_spd     Space for data from the PFE.
+ * @param[in]   p_phyif_name  Name of a parent physical interface.
+ *                            Names of physical interfaces are hardcoded.
+ *                            See the FCI API Reference, chapter Interface Management.
+ *              position      Position of the requested SecurityPolicy in the SPD.
+ * @return      FPP_ERR_OK : Requested SecurityPolicy was found.
+ *                           A copy of its configuration was stored into p_rtn_spd.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No data copied.
+ */
+int fci_spd_get_by_position(FCI_CLIENT* p_cl, fpp_spd_cmd_t* p_rtn_spd, 
+                            const char* p_phyif_name, uint16_t position)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_spd);
+    assert(NULL != p_phyif_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_spd_cmd_t cmd_to_fci = {0};
+    fpp_spd_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    rtn = set_text((cmd_to_fci.name), p_phyif_name, IFNAMSIZ);
+    
+    /* do the query */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* start query process */
+        cmd_to_fci.action = FPP_ACTION_QUERY;
+        rtn = fci_query(p_cl, FPP_CMD_SPD,
+                        sizeof(fpp_spd_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        ntoh_spd(&reply_from_fci);  /* set correct byte order */
+        
+        /* query loop (with the search condition) */
+        while ((FPP_ERR_OK == rtn) && (position != (reply_from_fci.position)))
+        {
+            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+            rtn = fci_query(p_cl, FPP_CMD_SPD,
+                            sizeof(fpp_spd_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            ntoh_spd(&reply_from_fci);  /* set correct byte order */
+        }
+    }
+    
+    /* if search successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_spd = reply_from_fci;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in the PFE ======= */
+ 
+ 
+/*
+ * @brief       Use FCI calls to create a new SecurityPolicy in the PFE.
+ *              The new policy is added into SPD of a provided parent physical interface.
+ * @param[in]   p_cl          FCI client instance
+ * @param[in]   p_phyif_name  Name of a parent physical interface.
+ *                            Names of physical interfaces are hardcoded.
+ *                            See the FCI API Reference, chapter Interface Management.
+ * @param[in]   position      Position of the new SecurityPolicy in the SPD.
+ * @param[in]   p_spd_data    Configuration data for the new SecurityPolicy.
+ *                            To create a new SecurityPolicy, a local data struct must be
+ *                            created, configured and then passed to this function.
+ *                            See [localdata_spd] functions to learn more.
+ * @return      FPP_ERR_OK : New SecurityPolicy was created.
+ *              other      : Some error occured (represented by the respective error code).
+ */
+int fci_spd_add(FCI_CLIENT* p_cl, const char* p_phyif_name, uint16_t position, 
+                const fpp_spd_cmd_t* p_spd_data)
+{
+    assert(NULL != p_cl);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_spd_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci = (*p_spd_data);
+    cmd_to_fci.position = position;
+    rtn = set_text((cmd_to_fci.name), p_phyif_name, IFNAMSIZ);
+    
+    /* send data */
+    if (FPP_ERR_OK == rtn)
+    {
+        hton_spd(&cmd_to_fci);  /* set correct byte order */
+        cmd_to_fci.action = FPP_ACTION_REGISTER;
+        rtn = fci_write(p_cl, FPP_CMD_SPD, sizeof(fpp_spd_cmd_t), 
+                                          (unsigned short*)(&cmd_to_fci));
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to destroy the target SecurityPolicy in the PFE.
+ * @param[in]   p_cl          FCI client instance
+ * @param[in]   p_phyif_name  Name of a parent physical interface.
+ * @param[in]   position      Position of the target SecurityPolicy in the SPD.
+ * @return      FPP_ERR_OK : SecurityPolicy was destroyed.
+ *              other      : Some error occured (represented by the respective error code).
+ */
+int fci_spd_del(FCI_CLIENT* p_cl, const char* p_phyif_name, uint16_t position)
+{
+    assert(NULL != p_cl);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    fpp_spd_cmd_t cmd_to_fci = {0};
+    
+    /*  prepare data  */
+    cmd_to_fci.position = position;
+    rtn = set_text((cmd_to_fci.name), p_phyif_name, IFNAMSIZ);
+    
+    /*  send data  */
+    if (FPP_ERR_OK == rtn)
+    {
+        hton_spd(&cmd_to_fci);  /*  set correct byte order  */
+        cmd_to_fci.action = FPP_ACTION_DEREGISTER;
+        rtn = fci_write(p_cl, FPP_CMD_SPD, sizeof(fpp_spd_cmd_t), 
+                                          (unsigned short*)(&cmd_to_fci));
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+/*
+ * @defgroup    localdata_spd  [localdata_spd]
+ * @brief:      Functions marked as [localdata_spd] guarantee that 
+ *              only local data are accessed.
+ * @details:    These functions do not make any FCI calls.
+ *              If some local data modifications are made, then after all local data changes
+ *              are done and finished, call fci_spd_add() to 
+ *              create a new SecurityPolicy with given configuration in the PFE.
+ */
+ 
+ 
+/*
+ * @brief          Set protocol type of a SecurityPolicy.
+ * @details        [localdata_spd]
+ * @param[in,out]  p_spd  Local data to be modified.
+ *                        For SecurityPolicy, there are no "initial data" to be obtained
+ *                        from the PFE. Simply declare a local data struct and configure it.
+ * @param[in]      protocol  IP protocol ID
+ *                           See "IANA Assigned Internet Protocol Number":
+ *                https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_spd_ld_set_protocol(fpp_spd_cmd_t* p_spd, uint8_t protocol)
+{
+    assert(NULL != p_spd);
+    p_spd->protocol = protocol;
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set source/destination IP address of a SecurityPolicy.
+ * @details        [localdata_spd]
+ *                 BEWARE: Address type of 'p_saddr' and 'p_daddr' must be the same!
+ * @param[in,out]  p_spd  Local data to be modified.
+ *                        For SecurityPolicy, there are no "initial data" to be obtained
+ *                        from the PFE. Simply declare a local data struct and configure it.
+ * @param[in]      p_saddr  Source IP address (IPv4 or IPv6).
+ * @param[in]      p_daddr  Destination IP address (IP4 or IP6).
+ * @param[in]      is_ip6   Set if provided addresses are IPv6 type addresses.
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_spd_ld_set_ip(fpp_spd_cmd_t* p_spd, const uint32_t p_saddr[4], 
+                      const uint32_t p_daddr[4], bool is_ip6)
+{
+    assert(NULL != p_spd);
+    assert(NULL != p_saddr);
+    assert(NULL != p_daddr);
+    
+    
+    const uint16_t cnt = ((is_ip6) ? (4u) : (1u));
+    memcpy((p_spd->saddr), p_saddr, (cnt * sizeof(uint32_t)));
+    memcpy((p_spd->daddr), p_daddr, (cnt * sizeof(uint32_t)));
+    set_flag(p_spd, is_ip6, FPP_SPD_FLAG_IPv6);
+    
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set source/destination port of the SecurityPolicy.
+ * @details        [localdata_spd]
+ * @param[in,out]  p_spd  Local data to be modified.
+ *                        For SecurityPolicy, there are no "initial data" to be obtained
+ *                        from the PFE. Simply declare a local data struct and configure it.
+ * @param[in]      use_sport  Prompt to use the source port value of this SecurityPolicy
+ *                            during SPD matching process (evaluation which policy to use).
+ *                            If false, then source port of the given SecurityPolicy is
+ *                            ignored (not tested) when the policy is evaluated.
+ * @param[in]      sport      Source port
+ * @param[in]      use_dport  Prompt to use the destination port value of this SecurityPolicy
+ *                            during SPD matching process (evaluation which policy to use).
+ *                            If false, then destination port of the given SecurityPolicy is
+ *                            ignored (not tested) when the policy is evaluated.
+ * @param[in]      dport      Destination port
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_spd_ld_set_port(fpp_spd_cmd_t* p_spd, bool use_sport, uint16_t sport, 
+                        bool use_dport, uint16_t dport)
+{
+    assert(NULL != p_spd);
+    
+    
+    p_spd->sport = ((use_sport) ? (sport) : (0u));
+    p_spd->dport = ((use_dport) ? (dport) : (0u));
+    set_flag(p_spd, (!use_sport), FPP_SPD_FLAG_SPORT_OPAQUE);  /* flag has inverted logic */
+    set_flag(p_spd, (!use_dport), FPP_SPD_FLAG_DPORT_OPAQUE);  /* flag has inverted logic */
+    
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/*
+ * @brief          Set action of the SecurityPolicy.
+ * @details        [localdata_spd]
+ * @param[in,out]  p_spd  Local data to be modified.
+ *                        For SecurityPolicy, there are no "initial data" to be obtained
+ *                        from the PFE. Simply declare a local data struct and configure it.
+ * @param[in]      spd_action  Action to do if traffic matches this SecurityPolicy.
+ *                             See description of fpp_spd_action_t type in 
+ *                             the FCI API Reference.
+ * @param[in]      sa_id  Meaningful ONLY if the action is FPP_SPD_ACTION_PROCESS_ENCODE.
+ *                        ID of an item in the SAD (Security Association Database).
+ *                        SAD is stored in the HSE FW (High Speed Encryption).
+ * @param[in]      spi    Meaningful ONLY if the action is FPP_SPD_ACTION_PROCESS_DECODE.
+ *                        Security Parameter Index (will be looked for in the traffic data)
+ * @return         FPP_ERR_OK : Local data were successfully modified.
+ *                 other      : Some error occured (represented by the respective error code).
+ *                              Local data not modified.
+ */
+int fci_spd_ld_set_action(fpp_spd_cmd_t* p_spd, fpp_spd_action_t spd_action, 
+                          uint32_t sa_id, uint32_t spi)
+{
+    assert(NULL != p_spd);
+    
+    
+    p_spd->spd_action = spd_action;
+    p_spd->sa_id = ((FPP_SPD_ACTION_PROCESS_ENCODE == spd_action) ? (sa_id) : (0uL));
+    p_spd->spi = ((FPP_SPD_ACTION_PROCESS_DECODE == spd_action) ? (spi) : (0uL));
+    
+    return (FPP_ERR_OK);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+ 
+ 
+/*
+ * @brief      Query address type of the given SecurityPolicy.
+ * @details    [localdata_spd]
+ * @param[in]  p_spd  Local data to be queried.
+ * @return     IP address of the policy:
+ *             true  : is IPv6 type.
+ *             false : is NOT IPv6 type.
+ */
+bool fci_spd_ld_is_ip6(const fpp_spd_cmd_t* p_spd)
+{
+    assert(NULL != p_spd);
+    return (bool)(FPP_SPD_FLAG_IPv6 & (p_spd->flags));
+}
+ 
+ 
+/*
+ * @brief      Query whether the source port value is used during SPD matching process.
+ * @details    [localdata_spd]
+ * @param[in]  p_spd  Local data to be queried.
+ * @return     Source port value:
+ *             true  : is used in a matching process.
+ *             false : is NOT used in a matching process.
+ */
+bool fci_spd_ld_is_used_sport(const fpp_spd_cmd_t* p_spd)
+{
+    assert(NULL != p_spd);
+    return !(FPP_SPD_FLAG_SPORT_OPAQUE & (p_spd->flags));  /* flag has inverted logic */
+}
+ 
+ 
+/*
+ * @brief      Query whether the destination port value is used during SPD matching process.
+ * @details    [localdata_spd]
+ * @param[in]  p_spd  Local data to be queried.
+ * @return     Destination port value:
+ *             true  : is used in a matching process.
+ *             false : is NOT used in a matching process.
+ */
+bool fci_spd_ld_is_used_dport(const fpp_spd_cmd_t* p_spd)
+{
+    assert(NULL != p_spd);
+    return !(FPP_SPD_FLAG_DPORT_OPAQUE & (p_spd->flags));  /* flag has inverted logic */
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through SecurityPolicies of the given physical
+ *             interface and execute a callback print function for each SecurityPolicy.
+ * @param[in]  p_cl           FCI client instance
+ * @param[in]  p_cb_print     Callback print function.
+ *                            --> If the callback returns zero, then all is OK and 
+ *                                the next physical interface is picked for a print process.
+ *                            --> If the callback returns non-zero, then some problem is 
+ *                                assumed and this function terminates prematurely.
+ * @param[in]  p_phyif_name   Name of a parent physical interface.
+ *                            Names of physical interfaces are hardcoded.
+ *                            See the FCI API Reference, chapter Interface Management.
+ * @param[in]  position_init  Start invoking callback print function from 
+ *                            this position in the SPD.
+ *                            If 0, start from the very first SecurityPolicy in the SPD.
+ * @param[in]  count          Print only this count of SecurityPolicies, then stop.
+ *                            If 0, keep printing SecurityPolicies till the end of the SPD.
+ * @return     FPP_ERR_OK : Successfully iterated through SecrityPolicies of 
+ *                          the given physical interface.
+ *             other      : Some error occured (represented by the respective error code).
+ */
+int fci_spd_print_by_phyif(FCI_CLIENT* p_cl, fci_spd_cb_print_t p_cb_print, 
+                           const char* p_phyif_name, uint16_t position_init, uint16_t count)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    assert(NULL != p_phyif_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_spd_cmd_t cmd_to_fci = {0};
+    fpp_spd_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    rtn = set_text((cmd_to_fci.name), p_phyif_name, IFNAMSIZ);
+    if (0u == count)  /* if 0, set max possible count of items */ 
+    {
+        count--;  /*  WARNING: intentional use of owf behavior */
+    }
+    
+    /* do the query */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* start query process */
+        cmd_to_fci.action = FPP_ACTION_QUERY;
+        rtn = fci_query(p_cl, FPP_CMD_SPD,
+                        sizeof(fpp_spd_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        ntoh_spd(&reply_from_fci);  /* set correct byte order */
+    
+        /* query loop */
+        uint16_t position = 0u;
+        while ((FPP_ERR_OK == rtn) && (0u != count))
+        {
+            if (position >= position_init)
+            {
+                rtn = p_cb_print(&reply_from_fci);
+                count--;
+            }
+            
+            position++;
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+                rtn = fci_query(p_cl, FPP_CMD_SPD,
+                                sizeof(fpp_spd_cmd_t), (unsigned short*)(&cmd_to_fci),
+                                &reply_length, (unsigned short*)(&reply_from_fci));
+                ntoh_spd(&reply_from_fci);  /* set correct byte order */
+            }
+        }
+        
+        /* query loop runs till there are no more SecurityPolicies to report */
+        /* the following error is therefore OK and expected (it ends the query loop) */
+        if (FPP_ERR_IF_ENTRY_NOT_FOUND == rtn)
+        {
+            rtn = FPP_ERR_OK;
+        }
+    }
+    
+    return (rtn);
+} 
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all SecurityPolicies in the PFE which are
+ *              associated with the given physical interface.
+ * @param[in]   p_cl          FCI client instance
+ * @param[out]  p_rtn_count   Space to store the count of SecurityPolicies.
+ * @param[in]   p_phyif_name  Name of a parent physical interface.
+ *                            Names of physical interfaces are hardcoded.
+ *                            See the FCI API Reference, chapter Interface Management.
+ * @return      FPP_ERR_OK : Successfully counted SecurityPolicies.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occured (represented by the respective error code).
+ *                           No count was stored.
+ */
+int fci_spd_get_count_by_phyif(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, 
+                               const char* p_phyif_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_count);
+    assert(NULL != p_phyif_name);
+    
+    
+    int rtn = FPP_ERR_FCI;
+    
+    fpp_spd_cmd_t cmd_to_fci = {0};
+    fpp_spd_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    uint16_t count = 0u;
+    
+    /* prepare data */
+    rtn = set_text((cmd_to_fci.name), p_phyif_name, IFNAMSIZ);
+    
+    /* do the query */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* start query process */
+        cmd_to_fci.action = FPP_ACTION_QUERY;
+        rtn = fci_query(p_cl, FPP_CMD_SPD,
+                        sizeof(fpp_spd_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+        /* no need to set correct byte order (we are just counting policies) */
+        
+        /*  query loop  */
+        while (FPP_ERR_OK == rtn)
+        {
+            count++;
+            
+            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+            rtn = fci_query(p_cl, FPP_CMD_SPD,
+                            sizeof(fpp_spd_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            /* no need to set correct byte order (we are just counting policies) */
+        }
+        
+        /* query loop runs till there are no more SecurityPolicies to report */
+        /* the following error is therefore OK and expected (it ends the query loop) */
+        if (FPP_ERR_IF_ENTRY_NOT_FOUND == rtn)
+        {
+            *p_rtn_count = count;
+            rtn = FPP_ERR_OK;
+        }
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_interface/fci_spd.h b/sw/libfci_cli/src/libfci_interface/fci_spd.h
new file mode 100644
index 0000000..b9acf7d
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_interface/fci_spd.h
@@ -0,0 +1,56 @@
+/* =========================================================================
+ *  (c) Copyright 2006-2016 Freescale Semiconductor, Inc.
+ *  Copyright 2017, 2019-2021 NXP
+ *
+ *  NXP Confidential. This software is owned or controlled by NXP and may only
+ *  be used strictly in accordance with the applicable license terms. By
+ *  expressly accepting such terms or by downloading, installing, activating
+ *  and/or otherwise using the software, you are agreeing that you have read,
+ *  and that you agree to comply with and are bound by, such license terms. If
+ *  you do not agree to be bound by the applicable license terms, then you may
+ *  not retain, install, activate or otherwise use the software.
+ *
+ *  This file contains sample code only. It is not part of the production code deliverables.
+ * ========================================================================= */
+
+#ifndef FCI_SPD_H_
+#define FCI_SPD_H_
+
+#include "fpp_ext.h"
+#include "libfci.h"
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+typedef int (*fci_spd_cb_print_t)(const fpp_spd_cmd_t* p_spd);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
+
+int fci_spd_get_by_position(FCI_CLIENT* p_cl, fpp_spd_cmd_t* p_rtn_spd, const char* p_phyif_name, uint16_t position);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in the PFE ======= */
+
+int fci_spd_add(FCI_CLIENT* p_cl, const char* p_phyif_name, uint16_t position, const fpp_spd_cmd_t* p_spd_data);
+int fci_spd_del(FCI_CLIENT* p_cl, const char* p_phyif_name, uint16_t position);
+
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+
+int fci_spd_ld_set_protocol(fpp_spd_cmd_t* p_spd, uint8_t protocol);
+int fci_spd_ld_set_ip(fpp_spd_cmd_t* p_spd, const uint32_t p_saddr[4], const uint32_t p_daddr[4], bool is_ip6);
+int fci_spd_ld_set_port(fpp_spd_cmd_t* p_spd, bool use_sport, uint16_t sport, bool use_dport, uint16_t dport);
+int fci_spd_ld_set_action(fpp_spd_cmd_t* p_spd, fpp_spd_action_t spd_action, uint32_t sa_id, uint32_t spi);
+
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+
+bool fci_spd_ld_is_ip6(const fpp_spd_cmd_t* p_spd);
+bool fci_spd_ld_is_used_sport(const fpp_spd_cmd_t* p_spd);
+bool fci_spd_ld_is_used_dport(const fpp_spd_cmd_t* p_spd);
+
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+
+int fci_spd_print_by_phyif(FCI_CLIENT* p_cl, fci_spd_cb_print_t p_cb_print, const char* p_phyif_name,
+                           uint16_t position_init, uint16_t count);
+int fci_spd_get_count_by_phyif(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, const char* p_phyif_name);
+
+/* ========================================================================= */
+
+#endif
-- 
2.17.1

