From 54698b4ecc90c4eeb5cf59d019a58d6139176363 Mon Sep 17 00:00:00 2001
From: "jan.petrous" <jan.petrous@nxp.com>
Date: Thu, 16 Feb 2023 20:08:40 +0100
Subject: [PATCH 1/2] version PFE_S32G_A53_LNX_1.3.0 RC1

Highlights:
    1) Support for PFE FW 1.6.0
    2) Jumbo frames up to 9k
    3) Use RT_LMEM on G3 by default
    4) Support external TS clock on EMACs
    5) Various fixes

pfe_linux.git: 4c50f8f99ce782d63dbf0027be042d81ca4e05b9

Upstream-Status: Pending 

Signed-off-by: Jan Petrous <jan.petrous@nxp.com>
Signed-off-by: Claudiu Manoil <claudiu.manoil@nxp.com>
Signed-off-by: Martin Hrdlicka <martin.hrdlicka@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 PFE_S32G_A53_LNX_1.3.0_SCR.txt                |  48 ++
 sw/common/public/blalloc.h                    |   6 +-
 sw/common/src/blalloc.c                       |  38 +-
 sw/fci/public/fci.h                           |   6 +-
 sw/fci/src/fci_core_linux.c                   |  54 +-
 sw/fci/src/fci_fp_db.c                        | 128 +----
 sw/fci/src/fci_fw_features.c                  |   6 +-
 sw/fci/src/fci_hm.c                           |   8 +-
 sw/fci/src/fci_mirror.c                       |   2 -
 sw/libfci_cli/Makefile                        |   2 +-
 sw/linux-pfeng/pfeng-bman.c                   | 142 +++--
 sw/linux-pfeng/pfeng-debugfs.c                |  24 +-
 sw/linux-pfeng/pfeng-drv.c                    |   6 +-
 sw/linux-pfeng/pfeng-dt.c                     |  27 +-
 sw/linux-pfeng/pfeng-hif.c                    |   4 +-
 sw/linux-pfeng/pfeng-netif.c                  |  99 ++--
 sw/linux-pfeng/pfeng-phylink.c                |   4 +-
 sw/linux-pfeng/pfeng-ptp.c                    |  22 +-
 sw/linux-pfeng/pfeng.h                        |   8 +-
 sw/oal/public/oal_types_linux.h               |  32 +-
 sw/pfe_hif_drv/public/pfe_hif_drv.h           |   6 +-
 sw/pfe_platform/hw/s32g/pfe_bmu_csr.c         |  51 +-
 sw/pfe_platform/hw/s32g/pfe_bmu_csr.h         |   6 +-
 sw/pfe_platform/hw/s32g/pfe_class_csr.c       | 239 ++++----
 sw/pfe_platform/hw/s32g/pfe_class_csr.h       |   8 +-
 sw/pfe_platform/hw/s32g/pfe_emac_csr.c        | 231 +++-----
 sw/pfe_platform/hw/s32g/pfe_emac_csr.h        |   6 +-
 sw/pfe_platform/hw/s32g/pfe_gpi_csr.c         |  77 ++-
 sw/pfe_platform/hw/s32g/pfe_gpi_csr.h         |   6 +-
 sw/pfe_platform/hw/s32g/pfe_hif_csr.c         |  33 +-
 sw/pfe_platform/hw/s32g/pfe_hif_csr.h         |   6 +-
 sw/pfe_platform/hw/s32g/pfe_platform_master.c | 178 +++++-
 sw/pfe_platform/hw/s32g/pfe_tmu_csr.c         |  66 +--
 sw/pfe_platform/hw/s32g/pfe_tmu_csr.h         |   6 +-
 sw/pfe_platform/hw/s32g/pfe_util_csr.c        |  26 +-
 sw/pfe_platform/hw/s32g/pfe_util_csr.h        |   6 +-
 sw/pfe_platform/public/pfe_bmu.h              |   6 +-
 sw/pfe_platform/public/pfe_class.h            |   9 +-
 sw/pfe_platform/public/pfe_ct_comp.h          |  13 +-
 sw/pfe_platform/public/pfe_emac.h             |  24 +-
 sw/pfe_platform/public/pfe_gpi.h              |   6 +-
 sw/pfe_platform/public/pfe_hif_chnl_linux.h   |   7 +-
 sw/pfe_platform/public/pfe_hif_ring_linux.h   |   5 +-
 sw/pfe_platform/public/pfe_hm.h               |  75 +--
 sw/pfe_platform/public/pfe_l2br.h             |  11 +-
 sw/pfe_platform/public/pfe_l2br_table.h       |   6 +-
 sw/pfe_platform/public/pfe_pe.h               |  17 +-
 sw/pfe_platform/public/pfe_platform.h         |   6 +-
 sw/pfe_platform/public/pfe_rtable.h           |   6 +-
 sw/pfe_platform/public/pfe_tmu.h              |   6 +-
 sw/pfe_platform/public/pfe_util.h             |   6 +-
 sw/pfe_platform/src/pfe_bmu.c                 |  18 +-
 sw/pfe_platform/src/pfe_class.c               | 340 ++++++-----
 sw/pfe_platform/src/pfe_emac.c                |  67 ++-
 sw/pfe_platform/src/pfe_gpi.c                 |  18 +-
 sw/pfe_platform/src/pfe_hif_chnl_linux.c      |  26 +-
 sw/pfe_platform/src/pfe_hif_ring_linux.c      |  25 +-
 sw/pfe_platform/src/pfe_hm.c                  |  32 +-
 sw/pfe_platform/src/pfe_hw_feature.c          |   4 +-
 sw/pfe_platform/src/pfe_l2br.c                | 498 +++++++++++++++-
 sw/pfe_platform/src/pfe_l2br_table.c          |  50 +-
 sw/pfe_platform/src/pfe_log_if.c              |   6 +-
 sw/pfe_platform/src/pfe_pe.c                  | 543 ++++++++----------
 sw/pfe_platform/src/pfe_phy_if.c              |  39 +-
 sw/pfe_platform/src/pfe_rtable.c              |  24 +-
 sw/pfe_platform/src/pfe_tmu.c                 |  19 +-
 sw/pfe_platform/src/pfe_util.c                | 117 ++--
 67 files changed, 2075 insertions(+), 1571 deletions(-)
 create mode 100644 PFE_S32G_A53_LNX_1.3.0_SCR.txt

diff --git a/PFE_S32G_A53_LNX_1.3.0_SCR.txt b/PFE_S32G_A53_LNX_1.3.0_SCR.txt
new file mode 100644
index 0000000..136d4fe
--- /dev/null
+++ b/PFE_S32G_A53_LNX_1.3.0_SCR.txt
@@ -0,0 +1,48 @@
+NXP Software Content Register
+
+Release Name:           PFE-DRV_S32G_A53_LNX_1.3.0
+
+Outgoing License:       GPL-2.0
+
+Package:                PFE-DRV_S32G_A53_LNX
+    Description:        The PFE Linux driver
+    Version:            1.3.0
+    License:            GPL-2.0
+    Format:             source code
+    Release Location:   GITHUB
+
+Component:              LINUX_PFENG
+    Location:           sw/linux-pfeng/
+    Description:        Linux NAPI ethernet driver
+    License:            GPL-2.0
+
+Component:              PFE_PLATFORM
+    Location:           sw/pfe_platform/
+                        sw/pfe_hif_drv/
+    Description:        PFE platform
+    License:            GPL-2.0
+
+Component:              SUPPORT_LIBS
+    Location:           sw/bpool/
+                        sw/common/
+                        sw/elf/
+                        sw/hal/
+                        sw/oal/
+                        sw/fifo/
+    Description:        PFE platform dependant library
+    License:            GPL-2.0
+
+Component:              FCI
+    Location:           sw/fci/
+                        sw/xfci/
+    Description:        Fast control interface library
+    License:            GPL-2.0
+
+Component:              ct_assert.h
+    Description:        Compile-time assert implementation
+    License:            GNU All-Permissive License
+
+Component:              LIBFCI_CLI
+    Location:           sw/libfci_cli/
+    Description:        Example FCI config tool
+    License:            BSD-3
diff --git a/sw/common/public/blalloc.h b/sw/common/public/blalloc.h
index 4c53e1e..93a6f71 100644
--- a/sw/common/public/blalloc.h
+++ b/sw/common/public/blalloc.h
@@ -1,5 +1,5 @@
 /* =========================================================================
- *  Copyright 2019-2022 NXP
+ *  Copyright 2019-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -70,9 +70,7 @@ errno_t blalloc_alloc_offs(blalloc_t *ctx, size_t size, size_t align, addr_t *ad
 void blalloc_free_offs_size(blalloc_t *ctx, addr_t offset, size_t size);
 void blalloc_free_offs(blalloc_t *ctx, addr_t offset);
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-uint32_t blalloc_get_text_statistics(const blalloc_t *ctx, char_t *buf, uint32_t buf_len, uint8_t verb_level);
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
+uint32_t blalloc_get_text_statistics(const blalloc_t *ctx, struct seq_file *seq, uint8_t verb_level);
 
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
diff --git a/sw/common/src/blalloc.c b/sw/common/src/blalloc.c
index aeb781c..70989de 100644
--- a/sw/common/src/blalloc.c
+++ b/sw/common/src/blalloc.c
@@ -1,5 +1,5 @@
 /* =========================================================================
- *  Copyright 2019-2022 NXP
+ *  Copyright 2019-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -498,24 +498,20 @@ void blalloc_free_offs(blalloc_t *ctx, addr_t offset)
 
 }
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-
 /**
 * @brief Reads the memory usage statistics in a text form
 * @param[in] ctx Context
-* @param[out] buf Output text buffer
-* @param[in] buf_len Size of the output text buffer
+* @param[in] seq Pointer to debugfs seq_file
 * @param[in] verb_level Verbosity lever
 * @return Number of characters written into the buffer.
 */
-uint32_t blalloc_get_text_statistics(const blalloc_t *ctx, char_t *buf, uint32_t buf_len, uint8_t verb_level)
+uint32_t blalloc_get_text_statistics(const blalloc_t *ctx, struct seq_file *seq, uint8_t verb_level)
 {
 	uint_t i, j;               /* Counters */
 	uint_t prev = 0U;          /* Did the used chunk precede this chunk? 1 = yes */
 	uint_t unused_chunks = 0U; /* Count of used chunks */
 	uint_t used_chunks = 0U;   /* Count of unused chunks */
 	uint_t fragments = 0U;     /* Count of holes between chunks */
-	uint32_t len = 0U;         /* Number of characters written into the buf */
 	uint_t byte_count = ((ctx->size >> ctx->chunk_size) + 3U) >> 2U;
 
 	/* Go through all bytes in chunkinfo */
@@ -528,10 +524,10 @@ uint32_t blalloc_get_text_statistics(const blalloc_t *ctx, char_t *buf, uint32_t
 			/* After each 32 bytes (and at start) print out a new line and address */
 			if(0U == (i % 32U))
 			{
-				len += oal_util_snprintf(buf + len, buf_len - len, "\n0x%05x: ", i * 4U * (1U << ctx->chunk_size));
+				seq_printf(seq, "\n0x%05x: ", i * 4U * (1U << ctx->chunk_size));
 			}
 			/* Print current chunkinfo byte */
-			len += oal_util_snprintf(buf + len, buf_len - len, "%02x", bits);
+			seq_printf(seq, "%02x", bits);
 		}
 
 		/* Go through all 2-bits in the current byte */
@@ -556,24 +552,22 @@ uint32_t blalloc_get_text_statistics(const blalloc_t *ctx, char_t *buf, uint32_t
 		}
 	}
 	/* Print out the information */
-	len += oal_util_snprintf(buf + len, buf_len - len, "\n"); /* End previous output */
-	len += oal_util_snprintf(buf + len, buf_len - len, "Free  memory %u bytes (%u chunks)\n", unused_chunks * ((uint_t)1U << ctx->chunk_size), unused_chunks);
-	len += oal_util_snprintf(buf + len, buf_len - len, "Used  memory %u bytes (%u chunks)\n", used_chunks * ((uint_t)1U << ctx->chunk_size), used_chunks);
-	len += oal_util_snprintf(buf + len, buf_len - len, "Total memory %u bytes (%u chunks)\n", (uint_t)ctx->size, byte_count * CHUNKS_IN_BYTE);
-	len += oal_util_snprintf(buf + len, buf_len - len, "Chunk size   %u bytes\n", (1U << ctx->chunk_size));
-	len += oal_util_snprintf(buf + len, buf_len - len, "Fragments    %u\n", fragments);
-	len += oal_util_snprintf(buf + len, buf_len - len, "Dummy chunks %u\n", (uint_t)((byte_count * CHUNKS_IN_BYTE) - (ctx->size >> ctx->chunk_size)));
+	seq_printf(seq, "\n"); /* End previous output */
+	seq_printf(seq, "Free  memory %u bytes (%u chunks)\n", unused_chunks * ((uint_t)1U << ctx->chunk_size), unused_chunks);
+	seq_printf(seq, "Used  memory %u bytes (%u chunks)\n", used_chunks * ((uint_t)1U << ctx->chunk_size), used_chunks);
+	seq_printf(seq, "Total memory %u bytes (%u chunks)\n", (uint_t)ctx->size, byte_count * CHUNKS_IN_BYTE);
+	seq_printf(seq, "Chunk size   %u bytes\n", (1U << ctx->chunk_size));
+	seq_printf(seq, "Fragments    %u\n", fragments);
+	seq_printf(seq, "Dummy chunks %u\n", (uint_t)((byte_count * CHUNKS_IN_BYTE) - (ctx->size >> ctx->chunk_size)));
 	if(verb_level > 0U)
 	{   /* Detailed information requested */
-		len += oal_util_snprintf(buf + len, buf_len - len, "1st free chunk  %u\n", (uint_t)ctx->start_srch);
-		len += oal_util_snprintf(buf + len, buf_len - len, "Bytes requested %u (cumulative)\n", (uint_t)ctx->requested);
-		len += oal_util_snprintf(buf + len, buf_len - len, "Bytes allocated %u (cumulative)\n", (uint_t)ctx->allocated);
+		seq_printf(seq, "1st free chunk  %u\n", (uint_t)ctx->start_srch);
+		seq_printf(seq, "Bytes requested %u (cumulative)\n", (uint_t)ctx->requested);
+		seq_printf(seq, "Bytes allocated %u (cumulative)\n", (uint_t)ctx->allocated);
 	}
-	return len;
+	return 0;
 }
 
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
-
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
 #include "Eth_43_PFE_MemMap.h"
diff --git a/sw/fci/public/fci.h b/sw/fci/public/fci.h
index 3eb5838..3aad0f7 100644
--- a/sw/fci/public/fci.h
+++ b/sw/fci/public/fci.h
@@ -1,5 +1,5 @@
 /* =========================================================================
- *  Copyright 2017-2022 NXP
+ *  Copyright 2017-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -64,9 +64,7 @@ errno_t fci_core_client_send_broadcast(fci_msg_t *msg, fci_msg_t *rep);
 errno_t fci_init(fci_init_info_t *info, const char_t *const identifier);
 void fci_fini(void);
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-uint32_t pfe_fp_get_text_statistics(pfe_fp_t *temp, char_t *buf, uint32_t buf_len, uint8_t verb_level);
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
+uint32_t pfe_fp_get_text_statistics(pfe_fp_t *temp, struct seq_file *seq, uint8_t verb_level);
 
 errno_t fci_process_ipc_message(fci_msg_t *msg, fci_msg_t *rep_msg);	/* This is here because FCI proxy RPC calls need it. */
 
diff --git a/sw/fci/src/fci_core_linux.c b/sw/fci/src/fci_core_linux.c
index 96525fc..db276cb 100644
--- a/sw/fci/src/fci_core_linux.c
+++ b/sw/fci/src/fci_core_linux.c
@@ -84,7 +84,7 @@ static fci_core_client_t *fci_core_get_client(fci_core_t *core, uint32_t port_id
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == core))
 	{
-		NXP_LOG_ERROR("NULL argument received\n");
+		NXP_LOG_RAW_ERROR("NULL argument received\n");
 		return NULL;
 	}
 #endif /* PFE_CFG_NULL_ARG_CHECK */
@@ -112,8 +112,8 @@ static uint8_t fci_core_get_count_of_clients(fci_core_t *core)
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == core))
 	{
-		NXP_LOG_ERROR("NULL argument received\n");
-		return NULL;
+		NXP_LOG_RAW_ERROR("NULL argument received\n");
+		return 0U;
 	}
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
@@ -213,7 +213,7 @@ void fci_core_fini(void)
 		}
 		if(mutex_lock_interruptible(&GET_FCI_CORE()->clients_lock))
 		{
-			NXP_LOG_WARNING("FCI clients lock failed\n");
+			NXP_LOG_RAW_WARNING("FCI clients lock failed\n");
 			return;
 		}
 		for(ii = 0; ii < FCI_CFG_MAX_CLIENTS; ii++)
@@ -223,7 +223,7 @@ void fci_core_fini(void)
 			{
 				if (EOK != fci_netlink_send(GET_FCI_CORE()->clients[ii].back_port_id, &msg))
 				{
-					NXP_LOG_ERROR("fci_netlink_send failed\n");
+					NXP_LOG_RAW_ERROR("fci_netlink_send failed\n");
 				}
 
 				GET_FCI_CORE()->clients[ii].connected = FALSE;
@@ -342,7 +342,7 @@ static errno_t fci_handle_msg(fci_msg_t *msg, fci_msg_t *rep_msg, uint32_t port_
 		{
 			if(mutex_lock_interruptible(&core->clients_lock))
 			{
-				NXP_LOG_ERROR("FCI clients lock failed\n");
+				NXP_LOG_RAW_ERROR("FCI clients lock failed\n");
 				return EAGAIN;
 			}
 
@@ -354,7 +354,7 @@ static errno_t fci_handle_msg(fci_msg_t *msg, fci_msg_t *rep_msg, uint32_t port_
 				{
 					if(msg->msg_client_register.port_id == core->clients[ii].back_port_id)
 					{
-						NXP_LOG_ERROR("Client already registered\n");
+						NXP_LOG_RAW_ERROR("Client already registered\n");
 						ret = EPERM;
 						break;
 					}
@@ -372,12 +372,12 @@ static errno_t fci_handle_msg(fci_msg_t *msg, fci_msg_t *rep_msg, uint32_t port_
 			{
 				if (FCI_CFG_MAX_CLIENTS == ii)
 				{
-					NXP_LOG_ERROR("Can't register new event listener, storage is full\n");
+					NXP_LOG_RAW_ERROR("Can't register new event listener, storage is full\n");
 					ret = ENOSPC;
 				}
 				else
 				{
-					NXP_LOG_INFO("Listener with port id cmd 0x%x, back 0x%x registered to pos %d\n", core->clients[ii].cmd_port_id,core->clients[ii].back_port_id,ii);
+					NXP_LOG_RAW_INFO("Listener with port id cmd 0x%x, back 0x%x registered to pos %d\n", core->clients[ii].cmd_port_id,core->clients[ii].back_port_id,ii);
 					ret = EOK;
 				}
 			}
@@ -406,7 +406,7 @@ static errno_t fci_handle_msg(fci_msg_t *msg, fci_msg_t *rep_msg, uint32_t port_
 		{
 			if(mutex_lock_interruptible(&core->clients_lock))
 			{
-				NXP_LOG_ERROR("FCI clients lock failed\n");
+				NXP_LOG_RAW_ERROR("FCI clients lock failed\n");
 				return EAGAIN;
 			}
 
@@ -427,12 +427,12 @@ static errno_t fci_handle_msg(fci_msg_t *msg, fci_msg_t *rep_msg, uint32_t port_
 
 			if (FCI_CFG_MAX_CLIENTS == ii)
 			{
-				NXP_LOG_ERROR("Requested connection ID not found\n");
+				NXP_LOG_RAW_ERROR("Requested connection ID not found\n");
 				ret = ENOENT;
 			}
 			else
 			{
-				NXP_LOG_INFO("Listener with port id cmd 0x%x unregistered from pos %d\n",port_id, ii);
+				NXP_LOG_RAW_INFO("Listener with port id cmd 0x%x unregistered from pos %d\n",port_id, ii);
 				ret = EOK;
 			}
 
@@ -455,7 +455,7 @@ static errno_t fci_handle_msg(fci_msg_t *msg, fci_msg_t *rep_msg, uint32_t port_
 			/*	We need to find the client based on cmd port id to be able to pass the client to the lower layers */
 			if(mutex_lock_interruptible(&core->clients_lock))
 			{
-				NXP_LOG_ERROR("FCI clients lock failed\n");
+				NXP_LOG_RAW_ERROR("FCI clients lock failed\n");
 				return EAGAIN;
 			}
 			client = fci_core_get_client(core, port_id);
@@ -503,18 +503,18 @@ static errno_t fci_netlink_send(uint32_t port_id, fci_msg_t *msg)
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == msg))
 	{
-		NXP_LOG_ERROR("NULL argument received\n");
+		NXP_LOG_RAW_ERROR("NULL argument received\n");
 		return EINVAL;
 	}
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
 	skb_out = nlmsg_new(msg_size, 0);
 	if (!skb_out) {
-		NXP_LOG_ERROR("Failed to allocate new skb\n");
+		NXP_LOG_RAW_ERROR("Failed to allocate new skb\n");
 		return ENOMEM;
 	}
 
-	NXP_LOG_DEBUG("FCI send netlink message to port_id 0x%x\n",port_id);
+	NXP_LOG_RAW_DEBUG("FCI send netlink message to port_id 0x%x\n",port_id);
 	nlh = nlmsg_put(skb_out, 0, 0, NLMSG_DONE, msg_size, GFP_ATOMIC);
 	nlh->nlmsg_flags = NLM_F_REQUEST;
 	NETLINK_CB(skb_out).dst_group = 0; /* not in mcast group */
@@ -523,7 +523,7 @@ static errno_t fci_netlink_send(uint32_t port_id, fci_msg_t *msg)
 	res = nlmsg_unicast(GET_FCI_CORE()->handle, skb_out, port_id);
 
 	if (res < 0) {
-		NXP_LOG_ERROR("Error while sending: %d\n", res);
+		NXP_LOG_RAW_ERROR("Error while sending: %d\n", res);
 	}
 	else
 	{
@@ -571,13 +571,13 @@ errno_t fci_core_client_send(fci_core_client_t *client, fci_msg_t *msg, fci_msg_
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(FALSE == __context.fci_initialized))
 	{
-		NXP_LOG_ERROR("Context not initialized\n");
+		NXP_LOG_RAW_ERROR("Context not initialized\n");
 		return EPERM;
 	}
 
 	if (unlikely(NULL == msg) || unlikely(NULL == rep))
 	{
-		NXP_LOG_ERROR("NULL argument received\n");
+		NXP_LOG_RAW_ERROR("NULL argument received\n");
 		return EINVAL;
 	}
 #endif /* PFE_CFG_NULL_ARG_CHECK */
@@ -585,13 +585,13 @@ errno_t fci_core_client_send(fci_core_client_t *client, fci_msg_t *msg, fci_msg_
 	/*	this function could be called from a callback even after the FCI module was destroyed */
 	if (NULL == GET_FCI_CORE())
 	{
-		NXP_LOG_WARNING("Cannot send FCI message (FCI core is NULL)\n");
+		NXP_LOG_RAW_WARNING("Cannot send FCI message (FCI core is NULL)\n");
 		return EINVAL;
 	}
 
 	if(mutex_lock_interruptible(&GET_FCI_CORE()->clients_lock))
 	{
-		NXP_LOG_WARNING("FCI clients lock failed\n");
+		NXP_LOG_RAW_WARNING("FCI clients lock failed\n");
 		return EAGAIN;
 	}
 	
@@ -599,7 +599,7 @@ errno_t fci_core_client_send(fci_core_client_t *client, fci_msg_t *msg, fci_msg_
 	{
 		if (EOK != (ret = fci_netlink_send(client->back_port_id, msg)))
 		{
-			NXP_LOG_ERROR("fci_netlink_send() failed: %d\n", ret);
+			NXP_LOG_RAW_ERROR("fci_netlink_send() failed: %d\n", ret);
 		}
 	}
 
@@ -619,13 +619,13 @@ errno_t fci_core_client_send_broadcast(fci_msg_t *msg, fci_msg_t *rep)
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(FALSE == __context.fci_initialized))
 	{
-		NXP_LOG_ERROR("Context not initialized\n");
+		NXP_LOG_RAW_ERROR("Context not initialized\n");
 		return EPERM;
 	}
 
 	if (unlikely(NULL == msg))
 	{
-		NXP_LOG_ERROR("NULL argument received\n");
+		NXP_LOG_RAW_ERROR("NULL argument received\n");
 		return EINVAL;
 	}
 #endif /* PFE_CFG_NULL_ARG_CHECK */
@@ -633,13 +633,13 @@ errno_t fci_core_client_send_broadcast(fci_msg_t *msg, fci_msg_t *rep)
 	/*	this function could be called from a callback even after the FCI module was destroyed */
 	if (NULL == GET_FCI_CORE())
 	{
-		NXP_LOG_WARNING("Cannot send FCI message (FCI core is NULL)\n");
+		NXP_LOG_RAW_WARNING("Cannot send FCI message (FCI core is NULL)\n");
 		return EINVAL;
 	}
 
 	if(mutex_lock_interruptible(&core->clients_lock))
 	{
-		NXP_LOG_WARNING("FCI clients lock failed\n");
+		NXP_LOG_RAW_WARNING("FCI clients lock failed\n");
 		return EAGAIN;
 	}
 
@@ -649,7 +649,7 @@ errno_t fci_core_client_send_broadcast(fci_msg_t *msg, fci_msg_t *rep)
 		{
 			if (EOK != (ret = fci_netlink_send(core->clients[ii].back_port_id, msg)))
 			{
-				NXP_LOG_ERROR("fci_netlink_send() failed: %d\n", ret);
+				NXP_LOG_RAW_ERROR("fci_netlink_send() failed: %d\n", ret);
 			}
 		}
 	}
diff --git a/sw/fci/src/fci_fp_db.c b/sw/fci/src/fci_fp_db.c
index 53b655f..6dd0748 100644
--- a/sw/fci/src/fci_fp_db.c
+++ b/sw/fci/src/fci_fp_db.c
@@ -1,5 +1,5 @@
 /* =========================================================================
- *  Copyright 2019-2022 NXP
+ *  Copyright 2019-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -125,17 +125,6 @@ static fci_fp_rule_t *fci_fp_rule_get_next(fci_fp_rule_db_t *db, dbase_t dbase);
 static bool_t fci_fp_match_table_by_criterion(fci_fp_table_criterion_t crit, const fci_fp_table_criterion_arg_t *arg, const fci_fp_table_t *fp_table);
 static fci_fp_table_t *fci_fp_table_get_first(fci_fp_table_db_t *db, fci_fp_table_criterion_t crit, void *arg);
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-
-static uint32_t fci_fp_print_table(const fci_fp_table_t *fp_table, char_t *buf, uint32_t buf_len, uint8_t verb_level);
-static errno_t fci_fp_get_rule_pos_in_table(const fci_fp_table_t *fp_table, fci_fp_rule_t *rule, uint8_t *pos);
-static uint32_t fci_fp_print_rule(fci_fp_rule_t *rule, char_t *buf, uint32_t buf_len, uint8_t verb_level);
-
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
-
-#if 0
-static fci_fp_table_t *fci_fp_table_get_next(fci_fp_table_db_t *db);
-#endif
 /**
  * @brief        Match rule using given criterion
  * @param[in]    crit Selects criterion
@@ -1444,117 +1433,18 @@ errno_t fci_fp_db_get_table_next_rule(char_t *table_name, fci_fp_rule_info_t *ru
     return ret;
 }
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-
-/**
-* @brief Prints a rule in a human readable form
-* @param[in] rule Rule to be printed
-* @param[in] buf Buffer where to put the output
-* @param[in] len Size of the buffer
-* @param[in] verb_level Verbosity level
-* @return Number of characters written into the buffer
-*/
-static uint32_t fci_fp_print_rule(fci_fp_rule_t *rule, char_t *buf, uint32_t buf_len, uint8_t verb_level)
-{
-    uint32_t len = 0U;
-	(void)verb_level;
-
-    len += oal_util_snprintf(buf + len, buf_len - len, "%s = {", rule->name);
-    /* Conditions */
-    if((uint8_t)FP_FL_INVERT == ((uint8_t)rule->flags & (uint8_t)FP_FL_INVERT))
-    {
-        len += oal_util_snprintf(buf + len, buf_len - len, "!");
-    }
-    len += oal_util_snprintf(buf + len, buf_len - len, "(0x%x & 0x%x == ", rule->data, rule->mask);
-    if((uint8_t)FP_FL_L4_OFFSET == ((uint8_t)rule->flags & (uint8_t)FP_FL_L4_OFFSET))
-    {
-        len += oal_util_snprintf(buf + len, buf_len - len, "frame[L4 header + %u] & 0x%x)", rule->offset, rule->mask);
-    }
-    if((uint8_t)FP_FL_L3_OFFSET == ((uint8_t)rule->flags & (uint8_t)FP_FL_L3_OFFSET))
-    {
-        len += oal_util_snprintf(buf + len, buf_len - len, "frame[L3 header + %u] & 0x%x)", rule->offset, rule->mask);
-    }
-    else
-    {
-        len += oal_util_snprintf(buf + len, buf_len - len, "frame[%u] & 0x%x)", rule->offset, rule->mask);
-    }
-    /* Consequences */
-    if((uint8_t)FP_FL_REJECT == ((uint8_t)rule->flags & (uint8_t)FP_FL_REJECT))
-    {
-        len += oal_util_snprintf(buf + len, buf_len - len, "? REJECT : use next rule");
-    }
-    else if((uint8_t)FP_FL_ACCEPT == ((uint8_t)rule->flags & (uint8_t)FP_FL_ACCEPT))
-    {
-        len += oal_util_snprintf(buf + len, buf_len - len, "? ACCEPT : use next rule");
-    }
-    else
-    {
-        len += oal_util_snprintf(buf + len, buf_len - len, "? use rule %s : use next rule", rule->next_rule);
-    }
-    len += oal_util_snprintf(buf + len, buf_len - len, "}\n");
-    return len;
-}
-
-/**
-* @brief Prints table rules in a human readable form
-* @param[in] table Table to be printed
-* @param[in] buf Buffer where to put the output
-* @param[in] len Size of the buffer
-* @param[in] verb_level Verbosity level
-* @return Number of characters written into the buffer
-*/
-static uint32_t fci_fp_print_table(const fci_fp_table_t *fp_table, char_t *buf, uint32_t buf_len, uint8_t verb_level)
-{
-    uint32_t len = 0U;
-    LLIST_t *item;
-    fci_fp_rule_t *rule;
-
-    len += oal_util_snprintf(buf + len, buf_len - len, "%s = {\n", fp_table->name);
-    LLIST_ForEach(item, &fp_table->rules_db.rules)
-    {
-        rule = LLIST_Data(item, fci_fp_rule_t, table_entry);
-        len += fci_fp_print_rule(rule, buf + len, buf_len - len, verb_level);
-    }
-
-    len += oal_util_snprintf(buf + len, buf_len - len, "\n}\n");
-    return len;
-}
-
-/**
-* @brief Prints all tables in a human readable form
-* @param[in] table Table to be printed
-* @param[in] buf Buffer where to put the output
-* @param[in] len Size of the buffer
-* @param[in] verb_level Verbosity level
-* @return Number of characters written into the buffer
-*/
-uint32_t fci_fp_print_tables(char_t *buf, uint32_t buf_len, uint8_t verb_level)
-{
-    const fci_fp_table_t *fp_table;
-    LLIST_t *item;
-    uint32_t len = 0U;
-
-    LLIST_ForEach(item, &fci_fp_table_db.tables)
-    {
-        fp_table = LLIST_Data(item,  fci_fp_table_t, db_entry);
-        len += fci_fp_print_table(fp_table, buf + len, buf_len - len, verb_level);
-    }
-    return len;
-}
-
-uint32_t pfe_fp_get_text_statistics(pfe_fp_t *temp, char_t *buf, uint32_t buf_len, uint8_t verb_level)
+uint32_t pfe_fp_get_text_statistics(pfe_fp_t *temp, struct seq_file *seq, uint8_t verb_level)
 {
     const fci_fp_table_t *fp_table;
     pfe_ct_class_flexi_parser_stats_t *c_stats;
     LLIST_t *item;
-    uint32_t len = 0U;
     uint32_t pe_idx = 0U;
-	(void)temp;
+    (void)temp;
 
     LLIST_ForEach(item, &fci_fp_table_db.tables)
     {
         fp_table = LLIST_Data(item,  fci_fp_table_t, db_entry);
-        len += oal_util_snprintf(buf + len, buf_len - len, "%s = {\n", fp_table->name);
+        seq_printf(seq, "%s = {\n", fp_table->name);
         if (fp_table->dmem_addr != 0U)
         {
             c_stats = oal_mm_malloc(sizeof(pfe_ct_class_flexi_parser_stats_t) * (pfe_class_get_num_of_pes(fp_table->class) + 1U));
@@ -1574,23 +1464,21 @@ uint32_t pfe_fp_get_text_statistics(pfe_fp_t *temp, char_t *buf, uint32_t buf_le
                 pfe_class_sum_flexi_parser_stats(&c_stats[0], &c_stats[pe_idx + 1U]);
             }
 
-            len += pfe_class_fp_stat_to_str(&c_stats[0U], buf + len, buf_len - len, verb_level);
+            pfe_class_fp_stat_to_str(&c_stats[0U], seq, verb_level);
 
             oal_mm_free(c_stats);
         }
         else
         {
-            len += oal_util_snprintf(buf + len, buf_len - len, "Table not enabled in Firmware\n");
+            seq_printf(seq, "Table not enabled in Firmware\n");
         }
 
-        len += oal_util_snprintf(buf + len, buf_len - len, "\n}\n");
+        seq_printf(seq, "\n}\n");
     }
 
-    return len;
+    return 0;
 }
 
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
-
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
 #include "Eth_43_PFE_MemMap.h"
diff --git a/sw/fci/src/fci_fw_features.c b/sw/fci/src/fci_fw_features.c
index 585cc88..a98033f 100644
--- a/sw/fci/src/fci_fw_features.c
+++ b/sw/fci/src/fci_fw_features.c
@@ -1,5 +1,5 @@
 /* =========================================================================
- *  Copyright 2020-2022 NXP
+ *  Copyright 2020-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -13,8 +13,6 @@
 #include "fci_msg.h"
 #include "fci.h"
 #include "fci_internal.h"
-#include "pfe_pe.h"
-#include "pfe_class.h"
 #include "oal.h"
 #include "pfe_feature_mgr.h"
 #include "fci_fw_features.h"
@@ -248,7 +246,7 @@ errno_t fci_fw_features_element_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_fw_fe
 			fp_cmd = (fpp_fw_features_element_cmd_t *)(msg->msg_cmd.payload);
 
 
-			if ((NULL == fp_cmd->fw_feature_name) || fp_cmd->fw_feature_name[0] == '\0')
+			if (fp_cmd->fw_feature_name[0] == '\0')
 			{
 				NXP_LOG_ERROR("Feature invalid name (fpp_fw_features_element_cmd_t)\n");
 				*fci_ret = FPP_ERR_FW_FEATURE_NOT_FOUND;
diff --git a/sw/fci/src/fci_hm.c b/sw/fci/src/fci_hm.c
index 36224b2..008e4d2 100644
--- a/sw/fci/src/fci_hm.c
+++ b/sw/fci/src/fci_hm.c
@@ -46,7 +46,7 @@ static void fci_hm_cb(pfe_hm_item_t *unused)
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(FALSE == fci_context->fci_initialized))
 	{
-		NXP_LOG_ERROR("Context not initialized\n");
+		NXP_LOG_RAW_ERROR("Context not initialized\n");
 		ret = EPERM;
 	}
 	else
@@ -62,7 +62,7 @@ static void fci_hm_cb(pfe_hm_item_t *unused)
 			if (FALSE == fci_context->is_some_client)  /* Consume only if there is someone to send data to. */
 			{
 				ret = EPERM;
-				NXP_LOG_DEBUG("No client to send data to.\n");
+				NXP_LOG_RAW_DEBUG("No client to send data to.\n");
 			}
 			else
 			{
@@ -71,11 +71,11 @@ static void fci_hm_cb(pfe_hm_item_t *unused)
 				{
 					if (ENOENT == ret)
 					{
-						NXP_LOG_DEBUG("No more items in HM database\n");
+						NXP_LOG_RAW_DEBUG("No more items in HM database\n");
 					}
 					else
 					{
-						NXP_LOG_ERROR("Failed to get item from HM database: %d\n", ret);
+						NXP_LOG_RAW_ERROR("Failed to get item from HM database: %d\n", ret);
 					}
 				}
 				else
diff --git a/sw/fci/src/fci_mirror.c b/sw/fci/src/fci_mirror.c
index 810265f..f84051b 100644
--- a/sw/fci/src/fci_mirror.c
+++ b/sw/fci/src/fci_mirror.c
@@ -13,8 +13,6 @@
 #include "fci_msg.h"
 #include "fci.h"
 #include "fci_internal.h"
-#include "pfe_pe.h"
-#include "pfe_class.h"
 #include "oal.h"
 #include "fci_mirror.h"
 
diff --git a/sw/libfci_cli/Makefile b/sw/libfci_cli/Makefile
index b1e6c07..5e145bd 100644
--- a/sw/libfci_cli/Makefile
+++ b/sw/libfci_cli/Makefile
@@ -61,7 +61,7 @@ ifeq ($(TARGET_OS),LINUX)
 	GLOBAL_CCFLAGS := $(shell echo $(GLOBAL_CCFLAGS))
 	
 	CLI_TARGET_OS = "LNX"
-	CLI_DRV_VERSION = "1.2.0 RC2"
+	CLI_DRV_VERSION = "1.3.0 RC1"
 	CLI_DRV_COMMIT_HASH = "M4_DRIVER_COMMIT_HASH"
 else
 #This branch by defaut means QNX.
diff --git a/sw/linux-pfeng/pfeng-bman.c b/sw/linux-pfeng/pfeng-bman.c
index be83ae8..4ae8bf0 100644
--- a/sw/linux-pfeng/pfeng-bman.c
+++ b/sw/linux-pfeng/pfeng-bman.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020-2022 NXP
+ * Copyright 2020-2023 NXP
  *
  * SPDX-License-Identifier: GPL-2.0
  *
@@ -28,8 +28,9 @@ struct pfeng_rx_map {
 };
 
 struct pfeng_rx_chnl_pool {
-	pfe_hif_chnl_t	*chnl;
-	struct device	*dev;
+	struct device			*dev;
+	pfe_hif_chnl_t			*ll_chnl;
+	struct sk_buff			*skb;
 	u32				id;
 	u32				depth;
 
@@ -71,7 +72,7 @@ int pfeng_bman_pool_create(struct pfeng_hif_chnl *chnl)
 	}
 
 	chnl->bman.rx_pool = rx_pool;
-	rx_pool->chnl = chnl->priv;
+	rx_pool->ll_chnl = chnl->priv;
 	rx_pool->dev = chnl->dev;
 	rx_pool->id = pfe_hif_chnl_get_id(chnl->priv);
 	rx_pool->depth = PFE_CFG_HIF_RING_LENGTH;
@@ -253,10 +254,6 @@ static void pfeng_bman_free_rx_buffers(struct pfeng_rx_chnl_pool *pool)
 		if (!rx_map->page)
 			continue;
 
-		dma_sync_single_range_for_cpu(pool->dev, rx_map->dma,
-					      rx_map->page_offset,
-					      PFE_RXB_DMA_SIZE, DMA_FROM_DEVICE);
-
 		dma_unmap_page(pool->dev, rx_map->dma, PAGE_SIZE, DMA_FROM_DEVICE);
 
 		__free_page(rx_map->page);
@@ -267,35 +264,33 @@ static void pfeng_bman_free_rx_buffers(struct pfeng_rx_chnl_pool *pool)
 	}
 }
 
-static int pfeng_hif_chnl_refill_rx_buffer(struct pfeng_hif_chnl *chnl, struct pfeng_rx_map *rx_map)
+static int pfeng_hif_chnl_refill_rx_buffer(struct pfeng_rx_chnl_pool *pool, struct pfeng_rx_map *rx_map)
 {
-	struct pfeng_rx_chnl_pool *pool = chnl->bman.rx_pool;
 	int err;
 
 	/*	Ask for new buffer */
 	if (unlikely(!rx_map->page))
 		if (unlikely(!pfeng_bman_buf_alloc_and_map(pool, rx_map))) {
-			HM_MSG_DEV_ERR(chnl->dev, "buffer allocation error\n");
+			HM_MSG_DEV_ERR(pool->dev, "buffer allocation error\n");
 			return -ENOMEM;
 		}
 
 	/* Add new buffer to ring */
-	err = pfe_hif_chnl_supply_rx_buf(chnl->priv, (void *)(rx_map->dma + rx_map->page_offset), PFE_RXB_DMA_SIZE);
+	err = pfe_hif_chnl_supply_rx_buf(pool->ll_chnl, (void *)(rx_map->dma + rx_map->page_offset), PFE_RXB_DMA_SIZE);
 	if (unlikely(err))
 		return err;
 
 	return 0;
 }
 
-static int pfeng_hif_chnl_refill_rx_pool(struct pfeng_hif_chnl *chnl, int count)
+static int pfeng_hif_chnl_refill_rx_pool(struct pfeng_rx_chnl_pool *pool, int count)
 {
-	struct pfeng_rx_chnl_pool *pool = chnl->bman.rx_pool;
 	struct pfeng_rx_map *rx_map;
 	int i, ret = 0;
 
 	for (i = 0; i < count; i++) {
 		rx_map = pfeng_bman_get_rx_map(pool, pool->wr_idx);
-		ret = pfeng_hif_chnl_refill_rx_buffer(chnl, rx_map);
+		ret = pfeng_hif_chnl_refill_rx_buffer(pool, rx_map);
 		if (unlikely(ret))
 			break;
 		/* push rx map */
@@ -327,18 +322,45 @@ static void pfeng_reuse_page(struct pfeng_rx_chnl_pool *pool,
 	pool->alloc_idx++;
 }
 
+static struct pfeng_rx_map *pfeng_get_rx_buff(struct pfeng_rx_chnl_pool *pool, u32 i, u32 size)
+{
+	struct pfeng_rx_map *rx_map = pfeng_bman_get_rx_map(pool, i);
+
+	dma_sync_single_range_for_cpu(pool->dev, rx_map->dma,
+				      rx_map->page_offset,
+				      size, DMA_FROM_DEVICE);
+
+	return rx_map;
+}
+
+static void pfeng_put_rx_buff(struct pfeng_rx_chnl_pool *pool, struct pfeng_rx_map *rx_map, u32 size)
+{
+	if (likely(pfeng_page_reusable(rx_map->page))) {
+		rx_map->page_offset ^= PFE_RXB_TRUESIZE;
+		page_ref_inc(rx_map->page);
+
+		pfeng_reuse_page(pool, rx_map);
+
+		/* dma sync for use by device */
+		dma_sync_single_range_for_device(pool->dev, rx_map->dma,
+						 rx_map->page_offset,
+						 size, DMA_FROM_DEVICE);
+	} else {
+		dma_unmap_page(pool->dev, rx_map->dma, PAGE_SIZE, DMA_FROM_DEVICE);
+	}
+
+	/* drop reference since page has been recycled (@alloc_idx), or unmaped */
+	rx_map->page = NULL;
+}
+
 static struct sk_buff *pfeng_rx_map_buff_to_skb(struct pfeng_rx_chnl_pool *pool, u32 rx_len)
 {
 	struct pfeng_rx_map *rx_map;
 	struct sk_buff *skb;
 	void *va;
 
-	rx_map = pfeng_bman_get_rx_map(pool, pool->rd_idx);
-
 	/* get rx buffer */
-	dma_sync_single_range_for_cpu(pool->dev, rx_map->dma,
-				      rx_map->page_offset,
-				      rx_len, DMA_FROM_DEVICE);
+	rx_map = pfeng_get_rx_buff(pool, pool->rd_idx, rx_len);
 
 	va = page_address(rx_map->page) + rx_map->page_offset;
 	skb = build_skb(va - PFE_RXB_PAD, PFE_RXB_TRUESIZE);
@@ -361,53 +383,66 @@ static struct sk_buff *pfeng_rx_map_buff_to_skb(struct pfeng_rx_chnl_pool *pool,
 	__skb_put(skb, rx_len);
 
 	/* put rx buffer */
-	if (likely(pfeng_page_reusable(rx_map->page))) {
-		rx_map->page_offset ^= PFE_RXB_TRUESIZE;
-		page_ref_inc(rx_map->page);
-
-		pfeng_reuse_page(pool, rx_map);
-
-		/* dma sync for use by device */
-		dma_sync_single_range_for_device(pool->dev, rx_map->dma,
-						 rx_map->page_offset,
-						 PFE_RXB_DMA_SIZE,
-						 DMA_FROM_DEVICE);
-	} else {
-		dma_unmap_page(pool->dev, rx_map->dma, PAGE_SIZE, DMA_FROM_DEVICE);
-	}
+	pfeng_put_rx_buff(pool, rx_map, rx_len);
 
-	/* drop reference as page was reused at alloc_idx, or was unmaped */
-	rx_map->page = NULL;
 	/* pull rx map */
 	pool->rd_idx++;
 
 	return skb;
 }
 
+static void pfeng_rx_add_buff_to_skb(struct pfeng_rx_chnl_pool *pool, u32 rx_len)
+{
+	struct pfeng_rx_map *rx_map;
+
+	/* get rx buffer */
+	rx_map = pfeng_get_rx_buff(pool, pool->rd_idx, rx_len);
+
+	skb_add_rx_frag(pool->skb, skb_shinfo(pool->skb)->nr_frags, rx_map->page,
+			rx_map->page_offset, rx_len, PFE_RXB_TRUESIZE);
+
+	/* put rx buffer */
+	pfeng_put_rx_buff(pool, rx_map, rx_len);
+
+	/* pull rx map */
+	pool->rd_idx++;
+}
+
 struct sk_buff *pfeng_hif_chnl_receive_pkt(struct pfeng_hif_chnl *chnl)
 {
+	struct pfeng_rx_chnl_pool *pool = chnl->bman.rx_pool;
+	bool_t lifm = false;
 	struct sk_buff *skb;
 	void *buf_pa;
 	u32 rx_len;
-	bool_t lifm;
 
-	if (unlikely(pfeng_bman_rx_chnl_pool_unused(chnl->bman.rx_pool) >= PFENG_BMAN_REFILL_THR))
-		pfeng_hif_chnl_refill_rx_pool(chnl, PFENG_BMAN_REFILL_THR);
+	if (unlikely(pfeng_bman_rx_chnl_pool_unused(pool) >= PFENG_BMAN_REFILL_THR))
+		pfeng_hif_chnl_refill_rx_pool(pool, PFENG_BMAN_REFILL_THR);
 
-	/* get received frame info from the RX BD and move to the next BD in the ring */
-	if (EOK != pfe_hif_chnl_rx(chnl->priv, &buf_pa, &rx_len, &lifm))
-	{
-		return NULL;
-	}
+	while (!lifm) {
+		/* get frame buffer info from the RX BD and move to the next BD in the ring */
+		if (EOK != pfe_hif_chnl_rx(pool->ll_chnl, &buf_pa, &rx_len, &lifm)) {
+			return NULL;
+		}
 
-	/* map the corresponding buffer (frame) to an skb and advance
-	 * the pool consumer index, to keep it in sync with the BD ring
-	 * consumer index */
-	skb = pfeng_rx_map_buff_to_skb(chnl->bman.rx_pool, rx_len);
-	if (unlikely(!skb)) {
-		HM_MSG_DEV_ERR(chnl->dev, "chnl%d: Rx skb mapping failed\n", chnl->idx);
-		return NULL;
+		if (!pool->skb) {
+			/* map the corresponding buffer (frame) to an skb and advance
+			 * the pool consumer index, to keep it in sync with the BD ring
+			 * consumer index */
+			skb = pfeng_rx_map_buff_to_skb(pool, rx_len);
+			if (unlikely(!skb)) {
+				HM_MSG_DEV_ERR(chnl->dev, "chnl%d: Rx skb mapping failed\n", chnl->idx);
+				return NULL;
+			}
+
+			pool->skb = skb;
+		} else {
+			pfeng_rx_add_buff_to_skb(pool, rx_len);
+		}
 	}
+
+	skb = pool->skb;
+	pool->skb = NULL;
 	prefetch(skb->data);
 
 	return skb;
@@ -415,12 +450,13 @@ struct sk_buff *pfeng_hif_chnl_receive_pkt(struct pfeng_hif_chnl *chnl)
 
 int pfeng_hif_chnl_fill_rx_buffers(struct pfeng_hif_chnl *chnl)
 {
+	struct pfeng_rx_chnl_pool *pool = chnl->bman.rx_pool;
 	int cnt = 0;
 	int ret;
 
-	while (pfe_hif_chnl_can_accept_rx_buf(chnl->priv)) {
+	while (pfe_hif_chnl_can_accept_rx_buf(pool->ll_chnl)) {
 
-		ret = pfeng_hif_chnl_refill_rx_pool(chnl, 1);
+		ret = pfeng_hif_chnl_refill_rx_pool(pool, 1);
 		if (ret)
 			break;
 		cnt++;
diff --git a/sw/linux-pfeng/pfeng-debugfs.c b/sw/linux-pfeng/pfeng-debugfs.c
index a930caa..46e9f4d 100644
--- a/sw/linux-pfeng/pfeng-debugfs.c
+++ b/sw/linux-pfeng/pfeng-debugfs.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018,2020-2022 NXP
+ * Copyright 2018,2020-2023 NXP
  *
  * SPDX-License-Identifier: GPL-2.0
  *
@@ -11,33 +11,19 @@
 #include "pfe_cfg.h"
 #include "pfeng.h"
 #include "fci.h"
+#include "pfe_platform.h"
 
 #if defined(CONFIG_DEBUG_FS)
 
 static u32 *msg_verbosity_ptr;
 
-#define DEBUGFS_BUF_SIZE 4096
-
 #define CREATE_DEBUGFS_ENTRY_TYPE(ename,var_type)				\
 static int fn_##ename##_debug_show(struct seq_file *seq, void *v)		\
 {										\
 	pfe_##var_type##_t *var_##ename = seq->private;				\
-	char *buf;								\
-	int ret;								\
-										\
-	buf = kzalloc(DEBUGFS_BUF_SIZE, GFP_KERNEL);				\
-	if (!buf) {								\
-		seq_puts(seq, "no memory\n");					\
-		return -ENOMEM;							\
-	}									\
-										\
-	ret = pfe_##ename##_get_text_statistics(var_##ename, buf,		\
-			DEBUGFS_BUF_SIZE, *msg_verbosity_ptr);			\
-										\
-	if (ret)								\
-		seq_puts(seq, buf);						\
 										\
-	kfree(buf);								\
+	pfe_##ename##_get_text_statistics(var_##ename, seq, 			\
+					  *msg_verbosity_ptr);			\
 										\
 	return 0;								\
 }										\
@@ -65,6 +51,7 @@ CREATE_DEBUGFS_ENTRY_TYPE(tmu,tmu);
 CREATE_DEBUGFS_ENTRY_TYPE(util,util);
 CREATE_DEBUGFS_ENTRY_TYPE(fp,fp);
 CREATE_DEBUGFS_ENTRY_TYPE(rtable,rtable);
+CREATE_DEBUGFS_ENTRY_TYPE(fw_features,platform);
 #endif
 CREATE_DEBUGFS_ENTRY_TYPE(hif_chnl,hif_chnl);
 
@@ -150,6 +137,7 @@ int pfeng_debugfs_create(struct pfeng_priv *priv)
 		ADD_DEBUGFS_ENTRY("emac1", emac, priv->dbgfs, priv->pfe_platform->emac[1], &dsav);
 	if (priv->emac[2].enabled)
 		ADD_DEBUGFS_ENTRY("emac2", emac, priv->dbgfs, priv->pfe_platform->emac[2], &dsav);
+	ADD_DEBUGFS_ENTRY("fw", fw_features, priv->dbgfs, priv->pfe_platform, &dsav);
 #endif
 
 	return 0;
diff --git a/sw/linux-pfeng/pfeng-drv.c b/sw/linux-pfeng/pfeng-drv.c
index 3c3200e..efa14e5 100644
--- a/sw/linux-pfeng/pfeng-drv.c
+++ b/sw/linux-pfeng/pfeng-drv.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2019-2022 NXP
+ * Copyright 2019-2023 NXP
  *
  * SPDX-License-Identifier: GPL-2.0
  *
@@ -124,9 +124,9 @@ static bool g2_ordered_class_writes = false;
 module_param(g2_ordered_class_writes, bool, 0644);
 MODULE_PARM_DESC(g2_ordered_class_writes, "\t Enable ordered class writes on S32G2 (default: false)");
 
-static bool g3_rtable_in_lmem = false;
+static bool g3_rtable_in_lmem = true;
 module_param(g3_rtable_in_lmem , bool, 0644);
-MODULE_PARM_DESC(g3_rtable_in_lmem , "\t Allocate PFE's Routing Table in local memory on S32G3 (default: false)");
+MODULE_PARM_DESC(g3_rtable_in_lmem , "\t Allocate PFE's Routing Table in local memory on S32G3 (default: true)");
 
 uint32_t get_pfeng_pfe_cfg_master_if(void)
 {
diff --git a/sw/linux-pfeng/pfeng-dt.c b/sw/linux-pfeng/pfeng-dt.c
index 01828d9..230ae3b 100644
--- a/sw/linux-pfeng/pfeng-dt.c
+++ b/sw/linux-pfeng/pfeng-dt.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2021-2022 NXP
+ * Copyright 2021-2023 NXP
  *
  * SPDX-License-Identifier: GPL-2.0
  *
@@ -117,6 +117,9 @@ int pfeng_dt_create_config(struct pfeng_priv *priv)
 	int irq, i, ret = 0;
 	u32 propval;
 	char propname[32];
+#ifdef PFE_CFG_PFE_MASTER
+	int emacs;
+#endif /* PFE_CFG_PFE_MASTER */
 
 	/* Get the base address of device */
 	res = platform_get_resource_byname(priv->pdev, IORESOURCE_MEM, PFE_RES_NAME_PFE_CBUS);
@@ -193,6 +196,21 @@ int pfeng_dt_create_config(struct pfeng_priv *priv)
 		if (!ret)
 			pfe_cfg->vlan_stats_size = propval;
 	}
+
+	/* optional: EMACs with external timestamping */
+	emacs = of_property_count_elems_of_size(np, "nxp,pfeng-emac-ts-ext-modes", sizeof(u32));
+	if ((emacs > 0) && (emacs < PFENG_PFE_EMACS)) {
+		for (i = 0; i < emacs; i++) {
+			ret = of_property_read_u32_index(np, "nxp,pfeng-emac-ts-ext-modes", i, &propval);
+			if (ret)
+				continue;
+			if (propval >= PFENG_PFE_EMACS) {
+				HM_MSG_DEV_ERR(dev, "EMAC number %u is invalid, aborting\n", propval);
+				return -EIO;
+			}
+			pfe_cfg->emac_ext_ts_mask |= (1 << propval);
+		}
+	}
 #endif /* PFE_CFG_PFE_MASTER */
 
 	/* IRQ per HIF */
@@ -276,10 +294,11 @@ int pfeng_dt_create_config(struct pfeng_priv *priv)
 		HM_MSG_DEV_INFO(dev, "netif name: %s", netif_cfg->name);
 
 		/* MAC eth address */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
-		netif_cfg->macaddr = (u8 *)of_get_mac_address(child);
-		if (netif_cfg->macaddr)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,13,0)
+		if (!IS_ERR_OR_NULL(of_get_mac_address(child))) {
+			memcpy(netif_cfg->macaddr, (u8 *)of_get_mac_address(child), ETH_ALEN);
 			HM_MSG_DEV_INFO(dev, "DT mac addr: %pM", netif_cfg->macaddr);
+		}
 #else
 		if (!of_get_mac_address(child, netif_cfg->macaddr))
 			HM_MSG_DEV_INFO(dev, "DT mac addr: %pM", netif_cfg->macaddr);
diff --git a/sw/linux-pfeng/pfeng-hif.c b/sw/linux-pfeng/pfeng-hif.c
index 1cadfa0..f239ef4 100644
--- a/sw/linux-pfeng/pfeng-hif.c
+++ b/sw/linux-pfeng/pfeng-hif.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020-2022 NXP
+ * Copyright 2020-2023 NXP
  *
  * SPDX-License-Identifier: GPL-2.0
  *
@@ -270,7 +270,7 @@ static int pfeng_hif_chnl_rx(struct pfeng_hif_chnl *chnl, int limit)
 		/* get target netdevice */
 		netif = pfeng_phy_if_id_to_netif(chnl, hif_hdr->i_phy_if);
 		if (unlikely(!netif)) {
-			HM_MSG_DEV_ERR(chnl->dev, "Missing netdev for packet from PHYIF#%d\n",
+			HM_MSG_DEV_DBG(chnl->dev, "Missing netdev for packet from PHYIF#%d\n",
 				hif_hdr->i_phy_if);
 			consume_skb(skb);
 			done++;
diff --git a/sw/linux-pfeng/pfeng-netif.c b/sw/linux-pfeng/pfeng-netif.c
index b0acacd..9539bc8 100644
--- a/sw/linux-pfeng/pfeng-netif.c
+++ b/sw/linux-pfeng/pfeng-netif.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020-2022 NXP
+ * Copyright 2020-2023 NXP
  *
  * SPDX-License-Identifier: GPL-2.0
  *
@@ -17,6 +17,7 @@
 #include "pfe_cfg.h"
 #include "oal.h"
 #include "pfe_platform.h"
+#include "pfe_feature_mgr.h"
 
 #include "pfeng.h"
 
@@ -416,56 +417,51 @@ static int pfeng_netif_logif_change_mtu(struct net_device *netdev, int mtu)
 	return 0;
 }
 
-static int pfeng_mii_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
-{
-	struct pfeng_netif *netif = netdev_priv(netdev);
-	struct mii_ioctl_data *mii = if_mii(rq);
-	u16 val;
-
-	if (netdev->phydev)
-		switch (cmd) {
-		case SIOCGMIIPHY:
-		case SIOCGMIIREG:
-		case SIOCSMIIREG:
-			return phy_mii_ioctl(netdev->phydev, rq, cmd);
-		}
-	else
-		switch (cmd) {
-		case SIOCGMIIREG:
-			val = pfeng_mdio_read(netif->priv->emac[netif->cfg->emac_id].mii_bus, mii->phy_id, mii->reg_num);
-			if (val > -1) {
-				mii->val_out = val;
-				return 0;
-			}
-			return val;
-		case SIOCSMIIREG:
-			return pfeng_mdio_write(netif->priv->emac[netif->cfg->emac_id].mii_bus, mii->phy_id, mii->reg_num, mii->val_in);
-		}
-
-	return -EOPNOTSUPP;
-}
-
 static int pfeng_netif_logif_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
 {
 	struct pfeng_netif *netif = netdev_priv(netdev);
+	struct mii_ioctl_data *mii = if_mii(rq);
+	int val, phyaddr, phyreg;
 
-	if (!phy_has_hwtstamp(netdev->phydev)) {
-		switch (cmd) {
-		case SIOCSHWTSTAMP:
-			return pfeng_hwts_ioctl_set(netif, rq);
-		case SIOCGHWTSTAMP:
-			return pfeng_hwts_ioctl_get(netif, rq);
-		}
+	if (mdio_phy_id_is_c45(mii->phy_id)) {
+		phyaddr = mdio_phy_id_prtad(mii->phy_id);
+		phyreg = MII_ADDR_C45 | (mdio_phy_id_devad(mii->phy_id) << 16) | mii->reg_num;
+	} else {
+		phyaddr = mii->phy_id;
+		phyreg = mii->reg_num;
 	}
 
-	if (netif->phylink)
-		return phylink_mii_ioctl(netif->phylink, rq, cmd);
-
 	switch (cmd) {
 	case SIOCGMIIPHY:
+		if (!netdev->phydev)
+			return -EOPNOTSUPP;
+		phyaddr = mii->phy_id = netdev->phydev->mdio.addr;
+		fallthrough;
 	case SIOCGMIIREG:
+		if (netdev->phydev)
+			return phy_mii_ioctl(netdev->phydev, rq, cmd);
+		/* If no phydev, use direct MDIO call */
+		val = pfeng_mdio_read(netif->priv->emac[netif->cfg->emac_id].mii_bus, phyaddr, phyreg);
+		if (val > -1) {
+			mii->val_out = val;
+			return 0;
+		}
+		return val;
 	case SIOCSMIIREG:
-		return pfeng_mii_ioctl(netdev, rq, cmd);
+		if (netdev->phydev)
+			return phy_mii_ioctl(netdev->phydev, rq, cmd);
+		/* If no phydev, use direct MDIO call */
+		return pfeng_mdio_write(netif->priv->emac[netif->cfg->emac_id].mii_bus, phyaddr, phyreg, mii->val_in);
+	case SIOCGHWTSTAMP:
+		if (phy_has_hwtstamp(netdev->phydev))
+			return phy_mii_ioctl(netdev->phydev, rq, cmd);
+		else
+			return pfeng_hwts_ioctl_get(netif, rq);
+	case SIOCSHWTSTAMP:
+		if (phy_has_hwtstamp(netdev->phydev))
+			return phy_mii_ioctl(netdev->phydev, rq, cmd);
+		else
+			return pfeng_hwts_ioctl_set(netif, rq);
 	}
 
 	return -EOPNOTSUPP;
@@ -677,7 +673,11 @@ static const struct net_device_ops pfeng_netdev_ops = {
 	.ndo_start_xmit		= pfeng_netif_logif_xmit,
 	.ndo_stop		= pfeng_netif_logif_stop,
 	.ndo_change_mtu		= pfeng_netif_logif_change_mtu,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,15,0)
+	.ndo_eth_ioctl		= pfeng_netif_logif_ioctl,
+#else
 	.ndo_do_ioctl		= pfeng_netif_logif_ioctl,
+#endif
 	.ndo_set_mac_address	= pfeng_netif_set_mac_address,
 	.ndo_set_rx_mode	= pfeng_netif_set_rx_mode,
 	.ndo_fix_features	= pfeng_netif_fix_features,
@@ -706,7 +706,7 @@ static void pfeng_netif_detach_hifs(struct pfeng_netif *netif)
 			return;
 		}
 		chnl->netifs[netif->cfg->emac_id] = NULL;
-		HM_MSG_NETDEV_ERR(netdev, "Unsubscribe from HIF%u\n", chnl->idx);
+		HM_MSG_NETDEV_INFO(netdev, "Unsubscribe from HIF%u\n", chnl->idx);
 	}
 }
 
@@ -977,8 +977,8 @@ static int pfeng_netif_logif_init_second_stage(struct pfeng_netif *netif)
 		goto err;
 
 	/* Set MAC address */
-	if (netif->cfg->macaddr && is_valid_ether_addr(netif->cfg->macaddr))
-		memcpy(&saddr.sa_data, netif->cfg->macaddr, sizeof(saddr.sa_data));
+	if (is_valid_ether_addr(netif->cfg->macaddr))
+		memcpy(&saddr.sa_data, netif->cfg->macaddr, ARRAY_SIZE(netif->cfg->macaddr));
 	else
 		memset(&saddr.sa_data, 0, sizeof(saddr.sa_data));
 
@@ -1133,7 +1133,16 @@ static struct pfeng_netif *pfeng_netif_logif_create(struct pfeng_priv *priv, str
 
 	/* MTU ranges */
 	netdev->min_mtu = ETH_MIN_MTU;
-	netdev->max_mtu = ETH_DATA_LEN + VLAN_HLEN; /* account for 8021q DSA tag length, AAVB-3196 */
+
+#ifdef PFE_CFG_PFE_MASTER
+	if (pfe_feature_mgr_is_available("jumbo_frames")) {
+		netdev->max_mtu = PFE_EMAC_JUMBO_MTU + PFE_MIN_DSA_OVERHEAD;
+	} else {
+		netdev->max_mtu = PFE_EMAC_STD_MTU + PFE_MIN_DSA_OVERHEAD; /* account for 8021q DSA tag length */
+	}
+#else
+	netdev->max_mtu = PFE_EMAC_STD_MTU + PFE_MIN_DSA_OVERHEAD; /* account for 8021q DSA tag length */
+#endif
 
 	/* Each packet requires extra buffer for Tx header (metadata) */
 	netdev->needed_headroom = PFENG_TX_PKT_HEADER_SIZE;
diff --git a/sw/linux-pfeng/pfeng-phylink.c b/sw/linux-pfeng/pfeng-phylink.c
index b1e9f18..024c52e 100644
--- a/sw/linux-pfeng/pfeng-phylink.c
+++ b/sw/linux-pfeng/pfeng-phylink.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020-2022 NXP
+ * Copyright 2020-2023 NXP
  *
  * SPDX-License-Identifier: GPL-2.0
  *
@@ -34,7 +34,7 @@ static void pfeng_cfg_to_plat(struct pfeng_netif *netif, const struct phylink_li
 
 	switch (state->speed) {
 	default:
-		HM_MSG_NETDEV_ERR(netif->netdev, "Speed not supported\n");
+		HM_MSG_NETDEV_WARN(netif->netdev, "Speed not supported\n");
 		speed_valid = false;
 		return;
 	case SPEED_2500:
diff --git a/sw/linux-pfeng/pfeng-ptp.c b/sw/linux-pfeng/pfeng-ptp.c
index ffd89cc..5990a91 100644
--- a/sw/linux-pfeng/pfeng-ptp.c
+++ b/sw/linux-pfeng/pfeng-ptp.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2021-2022 NXP
+ * Copyright 2021-2023 NXP
  *
  * SPDX-License-Identifier: GPL-2.0
  *
@@ -30,7 +30,10 @@ int pfeng_ptp_adjfreq(struct ptp_clock_info *ptp, s32 delta)
 
 	ret = pfe_emac_set_ts_freq_adjustment(emac, delta, sgn);
 
-	if (ret != 0){
+	if (ret == EPERM) {
+		HM_MSG_NETDEV_WARN(netif->netdev, "Frequency adjustment failed on EMAC%u\n", netif->cfg->emac_id);
+		ret = -EOPNOTSUPP;
+	} else if (ret != 0){
 		HM_MSG_NETDEV_ERR(netif->netdev, "Frequency adjustment failed (err %d)\n", ret);
 		ret = -EINVAL;
 	}
@@ -59,7 +62,10 @@ int pfeng_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)
 
 	ret = pfe_emac_adjust_ts_time(emac, sec, nsec, sgn);
 
-	if (ret != 0) {
+	if (ret == EPERM) {
+		HM_MSG_NETDEV_WARN(netif->netdev, "Time adjustment failed on EMAC%u\n", netif->cfg->emac_id);
+		ret = -EOPNOTSUPP;
+	} else if (ret != 0) {
 		HM_MSG_NETDEV_ERR(netif->netdev, "Time adjustment failed (err %d)\n", ret);
 		ret = -EINVAL;
 	}
@@ -103,7 +109,10 @@ int pfeng_ptp_settime64(struct ptp_clock_info *ptp, const struct timespec64 *ts)
 
 	ret = pfe_emac_set_ts_time(emac, sec, ts->tv_nsec, sec_hi);
 
-	if (ret != 0) {
+	if (ret == EPERM) {
+		HM_MSG_NETDEV_WARN(netif->netdev, "Set time failed on EMAC%u\n", netif->cfg->emac_id);
+		ret = -EOPNOTSUPP;
+	} else if (ret != 0) {
 		HM_MSG_NETDEV_ERR(netif->netdev, "Set time failed (err %d)\n", ret);
 		ret = -EINVAL;
 	}
@@ -154,6 +163,7 @@ void pfeng_ptp_register(struct pfeng_netif *netif)
 	struct pfeng_priv *priv = netif->priv;
         pfe_emac_t *emac = priv->pfe_platform->emac[netif->cfg->emac_id];
 	errno_t ret;
+	bool ext_ts;
 
 	/* Set PTP clock to null in case of error */
 	netif->ptp_clock = NULL;
@@ -165,9 +175,11 @@ void pfeng_ptp_register(struct pfeng_netif *netif)
 	/* Calculate max possible adjustment by controller */
 	pfeng_ptp_prepare_clock_adjustement(netif, priv->clk_ptp_reference);
 
+	/* Get EMAC's timestamping mode external / internal */
+	ext_ts = priv->pfe_platform->emac_ext_ts_mask & (1 << netif->cfg->emac_id);
 	/* Start PTP clock and enable time stamping in platform */
 	ret = pfe_emac_enable_ts(emac, priv->clk_ptp_reference,
-				 priv->clk_ptp_reference / 2LLU);
+				 ext_ts ? 0 : (priv->clk_ptp_reference / 2LLU));
 
 	if(ret) {
 		HM_MSG_DEV_ERR(netif->dev, "Failed to register PTP clock on EMAC%d\n", netif->cfg->emac_id);
diff --git a/sw/linux-pfeng/pfeng.h b/sw/linux-pfeng/pfeng.h
index 9ad82e5..d7b0761 100644
--- a/sw/linux-pfeng/pfeng.h
+++ b/sw/linux-pfeng/pfeng.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018-2022 NXP
+ * Copyright 2018-2023 NXP
  *
  * SPDX-License-Identifier: GPL-2.0
  *
@@ -44,7 +44,7 @@
 #else
 #error Incorrect configuration!
 #endif
-#define PFENG_DRIVER_VERSION		"1.2.0 RC2"
+#define PFENG_DRIVER_VERSION		"1.3.0 RC1"
 
 #define PFENG_FW_CLASS_NAME		"s32g_pfe_class.fw"
 #define PFENG_FW_UTIL_NAME		"s32g_pfe_util.fw"
@@ -129,11 +129,7 @@ struct pfeng_netif_cfg {
 	struct list_head		lnode;
 	const char			*name;
 	struct device_node		*dn;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
-	u8				*macaddr;
-#else
 	u8				macaddr[ETH_ALEN];
-#endif
 	u8				emac_id;
 	u8				hifs;
 	u32				hifmap;
diff --git a/sw/oal/public/oal_types_linux.h b/sw/oal/public/oal_types_linux.h
index ec9c157..0022de1 100644
--- a/sw/oal/public/oal_types_linux.h
+++ b/sw/oal/public/oal_types_linux.h
@@ -1,5 +1,5 @@
 /* =========================================================================
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -106,37 +106,37 @@ extern int msg_verbosity;
 
 #define HM_MSG_HM_DEV_ERR(dev, format, ...) { \
 	if (dev) { \
-		dev_err((struct device *)dev, format, ##__VA_ARGS__); \
+		dev_err(dev, "ERR: " format, ##__VA_ARGS__); \
 	} \
 }
 
 #define HM_MSG_HM_DEV_WARN(dev, format, ...) { \
 	if (dev) { \
-		dev_warn((struct device *)dev, "ERR: " format, ##__VA_ARGS__); \
+		dev_warn(dev, format, ##__VA_ARGS__); \
 	} \
 }
 
 #define HM_MSG_HM_DEV_INFO(dev, format, ...) { \
 	if (dev) { \
-		dev_info((struct device *)dev, format, ##__VA_ARGS__); \
+		dev_info(dev, format, ##__VA_ARGS__); \
 	} \
 }
 
 #define HM_MSG_HM_NETDEV_ERR(dev, format, ...) { \
 	if (dev) { \
-		netdev_err((struct net_device *)dev, format, ##__VA_ARGS__); \
+		netdev_err(dev, "ERR: " format, ##__VA_ARGS__); \
 	} \
 }
 
 #define HM_MSG_HM_NETDEV_WARN(dev, format, ...) { \
 	if (dev) { \
-		netdev_warn((struct net_device *)dev, "ERR: " format, ##__VA_ARGS__); \
+		netdev_warn(dev, format, ##__VA_ARGS__); \
 	} \
 }
 
 #define HM_MSG_HM_NETDEV_INFO(dev, format, ...) { \
 	if (dev) { \
-		netdev_info((struct net_device *)dev, format, ##__VA_ARGS__); \
+		netdev_info(dev, format, ##__VA_ARGS__); \
 	} \
 }
 
@@ -161,6 +161,20 @@ typedef char char_t;
 typedef int int_t; /* For use within printf like functions that require "int" regardless its size */
 typedef unsigned int uint_t; /* For use within printf like functions */
 
+typedef enum {
+	NXP_LOG_TYPE_PFE,
+	NXP_LOG_TYPE_DEV,
+	NXP_LOG_TYPE_NETDEV
+} pfe_hm_log_type_t;
+
+typedef struct {
+	pfe_hm_log_type_t log_type;
+	union {
+		struct device *log_dev;
+		struct net_device *log_netdev;
+	};
+} pfe_hm_log_t;
+
 #ifndef EOK
 #define EOK 0
 #endif
@@ -191,12 +205,12 @@ typedef unsigned int uint_t; /* For use within printf like functions */
 #define NXP_LOG_INFO(format, ...) NXP_LOG_RAW_INFO(format, ##__VA_ARGS__)
 #define NXP_LOG_DEBUG(format, ...) NXP_LOG_RAW_DEBUG(format, ##__VA_ARGS__)
 
-#define HM_MSG_DEV_ERR(dev, format, ...) pfe_hm_report_dev_error(HM_SRC_PFENG_DEV, HM_EVT_RUNTIME, (void *)dev, format, ##__VA_ARGS__)
+#define HM_MSG_DEV_ERR(dev, format, ...) pfe_hm_report_dev_error(HM_SRC_DRIVER, HM_EVT_RUNTIME, dev, format, ##__VA_ARGS__)
 #define HM_MSG_DEV_WARN(dev, format, ...) HM_MSG_RAW_DEV_WARN(dev, format, ##__VA_ARGS__)
 #define HM_MSG_DEV_INFO(dev, format, ...) HM_MSG_RAW_DEV_INFO(dev, format, ##__VA_ARGS__)
 #define HM_MSG_DEV_DBG(dev, format, ...) HM_MSG_RAW_DEV_DBG(dev, format, ##__VA_ARGS__)
 
-#define HM_MSG_NETDEV_ERR(netdev, format, ...) pfe_hm_report_dev_error(HM_SRC_PFENG_NETDEV, HM_EVT_RUNTIME, (void *)netdev, format, ##__VA_ARGS__)
+#define HM_MSG_NETDEV_ERR(netdev, format, ...) pfe_hm_report_netdev_error(HM_SRC_DRIVER, HM_EVT_RUNTIME, netdev, format, ##__VA_ARGS__)
 #define HM_MSG_NETDEV_WARN(netdev, format, ...) HM_MSG_RAW_NETDEV_WARN(netdev, format, ##__VA_ARGS__)
 #define HM_MSG_NETDEV_INFO(netdev, format, ...) HM_MSG_RAW_NETDEV_INFO(netdev, format, ##__VA_ARGS__)
 #define HM_MSG_NETDEV_DBG(netdev, format, ...) HM_MSG_RAW_NETDEV_DBG(netdev, format, ##__VA_ARGS__)
diff --git a/sw/pfe_hif_drv/public/pfe_hif_drv.h b/sw/pfe_hif_drv/public/pfe_hif_drv.h
index c1d1d9e..0d99af0 100644
--- a/sw/pfe_hif_drv/public/pfe_hif_drv.h
+++ b/sw/pfe_hif_drv/public/pfe_hif_drv.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -47,10 +47,6 @@
 #include "pfe_hif_chnl.h"
 #endif
 
-#ifdef PFE_CFG_IEEE1588_SUPPORT
-#include "pfe_hif_ptp.h"
-#endif /* PFE_CFG_IEEE1588_SUPPORT */
-
 #define HIF_STATS
 
 enum
diff --git a/sw/pfe_platform/hw/s32g/pfe_bmu_csr.c b/sw/pfe_platform/hw/s32g/pfe_bmu_csr.c
index 24a4012..ec0b09f 100644
--- a/sw/pfe_platform/hw/s32g/pfe_bmu_csr.c
+++ b/sw/pfe_platform/hw/s32g/pfe_bmu_csr.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -293,19 +293,16 @@ void pfe_bmu_cfg_free_buf(addr_t base_va, addr_t buffer)
 	hal_write32((uint32_t)(buffer & 0xffffffffU), base_va + BMU_FREE_CTRL);
 }
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-
 /**
  * @brief		Get BMU statistics in text form
  * @details		This is a HW-specific function providing detailed text statistics
  * 				about the BMU block.
  * @param[in]	base_va Base address of BMU register space (virtual)
- * @param[in]	buf 		Pointer to the buffer to write to
- * @param[in]	size 		Buffer length
+ * @param[in]	seq 		Pointer to debugfs seq_file
  * @param[in]	verb_level 	Verbosity level
  * @return		Number of bytes written to the buffer
  */
-uint32_t pfe_bmu_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, uint8_t verb_level)
+uint32_t pfe_bmu_cfg_get_text_stat(addr_t base_va, struct seq_file *seq, uint8_t verb_level)
 {
 	uint32_t len = 0U;
 	uint32_t reg, ii;
@@ -321,49 +318,47 @@ uint32_t pfe_bmu_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, u
 	{
 		if(verb_level >= 10U)
 		{
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "BMU_REM_BUF_CNT     : 0x%x\n", hal_read32(base_va + BMU_REM_BUF_CNT));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "BMU_FREE_ERROR_ADDR : 0x%x\n", hal_read32(base_va + BMU_FREE_ERROR_ADDR));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "BMU_CURR_BUF_CNT    : 0x%x\n", hal_read32(base_va + BMU_CURR_BUF_CNT));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "BMU_DEBUG_BUS       : 0x%x\n", hal_read32(base_va + BMU_DEBUG_BUS));
+			seq_printf(seq, "BMU_REM_BUF_CNT     : 0x%x\n", hal_read32(base_va + BMU_REM_BUF_CNT));
+			seq_printf(seq, "BMU_FREE_ERROR_ADDR : 0x%x\n", hal_read32(base_va + BMU_FREE_ERROR_ADDR));
+			seq_printf(seq, "BMU_CURR_BUF_CNT    : 0x%x\n", hal_read32(base_va + BMU_CURR_BUF_CNT));
+			seq_printf(seq, "BMU_DEBUG_BUS       : 0x%x\n", hal_read32(base_va + BMU_DEBUG_BUS));
 		}
 
 		if(verb_level >= 9U)
 		{
 			/*	Get version */
 			reg = hal_read32(base_va + BMU_VERSION);
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Revision             : 0x%x\n", (reg >> 24) & 0xffU);
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Version              : 0x%x\n", (reg >> 16) & 0xffU);
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "ID                   : 0x%x\n", reg & 0xffffU);
+			seq_printf(seq, "Revision             : 0x%x\n", (reg >> 24) & 0xffU);
+			seq_printf(seq, "Version              : 0x%x\n", (reg >> 16) & 0xffU);
+			seq_printf(seq, "ID                   : 0x%x\n", reg & 0xffffU);
 		}
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Buffer Base (uc)     : p0x%x\n", (uint32_t)hal_read32(base_va + BMU_UCAST_BASEADDR));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Buffer Size          : 0x%x\n", 1U << hal_read32(base_va + BMU_BUF_SIZE));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Buffers Remaining    : 0x%x\n", hal_read32(base_va + BMU_REM_BUF_CNT));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Buffers Allocated    : 0x%x\n", hal_read32(base_va + BMU_CURR_BUF_CNT));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Low Watermark        : 0x%x\n", hal_read32(base_va + BMU_LOW_WATERMARK));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "High Watermark       : 0x%x\n", hal_read32(base_va + BMU_HIGH_WATERMARK));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "IRQ Threshold (uc)   : 0x%x\n", hal_read32(base_va + BMU_THRES) & 0xffffU);
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Free Error Address   : 0x%x\n", hal_read32(base_va + BMU_FREE_ERROR_ADDR));
+		seq_printf(seq, "Buffer Base (uc)     : p0x%x\n", (uint32_t)hal_read32(base_va + BMU_UCAST_BASEADDR));
+		seq_printf(seq, "Buffer Size          : 0x%x\n", 1U << hal_read32(base_va + BMU_BUF_SIZE));
+		seq_printf(seq, "Buffers Remaining    : 0x%x\n", hal_read32(base_va + BMU_REM_BUF_CNT));
+		seq_printf(seq, "Buffers Allocated    : 0x%x\n", hal_read32(base_va + BMU_CURR_BUF_CNT));
+		seq_printf(seq, "Low Watermark        : 0x%x\n", hal_read32(base_va + BMU_LOW_WATERMARK));
+		seq_printf(seq, "High Watermark       : 0x%x\n", hal_read32(base_va + BMU_HIGH_WATERMARK));
+		seq_printf(seq, "IRQ Threshold (uc)   : 0x%x\n", hal_read32(base_va + BMU_THRES) & 0xffffU);
+		seq_printf(seq, "Free Error Address   : 0x%x\n", hal_read32(base_va + BMU_FREE_ERROR_ADDR));
 		reg = hal_read32(base_va + BMU_BUF_CNT);
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Free Error Count     : 0x%x\n", reg >> 16);
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Active Buffers       : 0x%x\n", reg & 0xffffU);
+		seq_printf(seq, "Free Error Count     : 0x%x\n", reg >> 16);
+		seq_printf(seq, "Active Buffers       : 0x%x\n", reg & 0xffffU);
 
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "IRQ Source           : 0x%x\n", hal_read32(base_va + BMU_INT_SRC));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "IRQ Enable           : 0x%x\n", hal_read32(base_va + BMU_INT_ENABLE));
+		seq_printf(seq, "IRQ Source           : 0x%x\n", hal_read32(base_va + BMU_INT_SRC));
+		seq_printf(seq, "IRQ Enable           : 0x%x\n", hal_read32(base_va + BMU_INT_ENABLE));
 
 		for (ii=0; ii<32U; ii++)
 		{
 			reg = hal_read32(base_va + BMU_MAS0_BUF_CNT + (4U*ii));
 			if (0U != reg)
 			{
-				len += (uint32_t)oal_util_snprintf(buf + len, size - len, "MASTER%02d Count       : 0x%x\n", ii, reg);
+				seq_printf(seq, "MASTER%02d Count       : 0x%x\n", ii, reg);
 			}
 		}
 	}
 	return len;
 }
 
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
-
 /**
  * @brief		BMU error detect in polling
  * @details		check and return the interrupt source in polling mode
diff --git a/sw/pfe_platform/hw/s32g/pfe_bmu_csr.h b/sw/pfe_platform/hw/s32g/pfe_bmu_csr.h
index 63a75c1..525bd49 100644
--- a/sw/pfe_platform/hw/s32g/pfe_bmu_csr.h
+++ b/sw/pfe_platform/hw/s32g/pfe_bmu_csr.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -100,9 +100,7 @@ void pfe_bmu_cfg_disable(addr_t base_va);
 void * pfe_bmu_cfg_alloc_buf(addr_t base_va);
 void pfe_bmu_cfg_free_buf(addr_t base_va, addr_t buffer);
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-uint32_t pfe_bmu_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, uint8_t verb_level);
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
+uint32_t pfe_bmu_cfg_get_text_stat(addr_t base_va, struct seq_file *seq, uint8_t verb_level);
 
 uint32_t pfe_bmu_cfg_get_err_poll(addr_t base_va);
 
diff --git a/sw/pfe_platform/hw/s32g/pfe_class_csr.c b/sw/pfe_platform/hw/s32g/pfe_class_csr.c
index e88c567..b9abcab 100644
--- a/sw/pfe_platform/hw/s32g/pfe_class_csr.c
+++ b/sw/pfe_platform/hw/s32g/pfe_class_csr.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -71,7 +71,7 @@ void pfe_class_cfg_set_config(addr_t base_va, const pfe_class_cfg_t *cfg)
 			| PHYNO_IN_HASH(FALSE)
 			| PARSE_ROUTE_EN(FALSE)
 			| VLAN_AWARE_BRIDGE(TRUE)
-			| PARSE_BRIDGE_EN(TRUE)
+			| PARSE_BRIDGE_EN(FALSE)
 			| IPALIGNED_PKT(FALSE)
 			| ARC_HIT_CHECK_EN(FALSE)
 			| VLAN_AWARE_BRIDGE_PHY1(FALSE)
@@ -237,21 +237,18 @@ void pfe_class_cfg_set_def_vlan(addr_t base_va, uint16_t vlan)
  * @details		This is a HW-specific function providing detailed text statistics
  * 				about the CLASS block.
  * @param[in]	base_va Base address of CLASS register space (virtual)
- * @param[in]	buf 		Pointer to the buffer to write to
- * @param[in]	size 		Buffer length
+ * @param[in]	seq 		Pointer to debugfs seq_file
  * @param[in]	verb_level 	Verbosity level
  * @return		Number of bytes written to the buffer
  */
-uint32_t pfe_class_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, uint8_t verb_level)
+uint32_t pfe_class_cfg_get_text_stat(addr_t base_va, struct seq_file *seq, uint8_t verb_level)
 {
-	uint32_t len = 0U;
 	uint32_t reg;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL_ADDR == base_va))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		len = 0U;
 	}
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
@@ -259,196 +256,196 @@ uint32_t pfe_class_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size,
 		/* Debug registers */
 		if(verb_level >= 10U)
 		{
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE0_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE0_DEBUG));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE1_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE1_DEBUG));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE2_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE2_DEBUG));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE3_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE3_DEBUG));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE4_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE4_DEBUG));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE5_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE5_DEBUG));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE6_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE6_DEBUG));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PE7_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE7_DEBUG));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_STATE\t0x%x\n", hal_read32(base_va + CLASS_STATE));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_QB_BUF_AVAIL\t0x%x\n", hal_read32(base_va + CLASS_QB_BUF_AVAIL));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_RO_BUF_AVAIL\t0x%x\n", hal_read32(base_va + CLASS_RO_BUF_AVAIL));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_DEBUG_BUS01\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS01));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_DEBUG_BUS23\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS23));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_DEBUG_BUS45\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS45));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_DEBUG_BUS67\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS67));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_DEBUG_BUS89\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS89));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_DEBUG_BUS1011\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS1011));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_DEBUG_BUS12\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS12));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_RX_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_L3_FAIL_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V4_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V6_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_CHKSUM_ERR_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_TTL_ERR_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_RX_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_L3_FAIL_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V4_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V6_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_CHKSUM_ERR_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_TTL_ERR_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_RX_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_L3_FAIL_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V4_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V6_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_CHKSUM_ERR_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_TTL_ERR_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_RX_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_L3_FAIL_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_V4_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_V6_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_CHKSUM_ERR_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_TTL_ERR_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_RX_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_L3_FAIL_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_V4_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_V6_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_CHKSUM_ERR_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_TTL_ERR_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_ICMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_ICMP_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_IGMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_IGMP_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_TCP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_TCP_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY1_UDP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_UDP_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_ICMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_ICMP_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_IGMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_IGMP_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_TCP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_TCP_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY2_UDP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_UDP_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_ICMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_ICMP_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_IGMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_IGMP_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_TCP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_TCP_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY3_UDP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_UDP_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_ICMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_ICMP_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_IGMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_IGMP_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_TCP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_TCP_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_UDP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_UDP_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_RX_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_L3_FAIL_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_V4_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_V6_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_CHKSUM_ERR_PKTS));
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "CLASS_PHY4_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_TTL_ERR_PKTS));
+			seq_printf(seq, "CLASS_PE0_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE0_DEBUG));
+			seq_printf(seq, "CLASS_PE1_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE1_DEBUG));
+			seq_printf(seq, "CLASS_PE2_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE2_DEBUG));
+			seq_printf(seq, "CLASS_PE3_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE3_DEBUG));
+			seq_printf(seq, "CLASS_PE4_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE4_DEBUG));
+			seq_printf(seq, "CLASS_PE5_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE5_DEBUG));
+			seq_printf(seq, "CLASS_PE6_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE6_DEBUG));
+			seq_printf(seq, "CLASS_PE7_DEBUG\t0x%x\n", hal_read32(base_va + CLASS_PE7_DEBUG));
+			seq_printf(seq, "CLASS_STATE\t0x%x\n", hal_read32(base_va + CLASS_STATE));
+			seq_printf(seq, "CLASS_QB_BUF_AVAIL\t0x%x\n", hal_read32(base_va + CLASS_QB_BUF_AVAIL));
+			seq_printf(seq, "CLASS_RO_BUF_AVAIL\t0x%x\n", hal_read32(base_va + CLASS_RO_BUF_AVAIL));
+			seq_printf(seq, "CLASS_DEBUG_BUS01\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS01));
+			seq_printf(seq, "CLASS_DEBUG_BUS23\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS23));
+			seq_printf(seq, "CLASS_DEBUG_BUS45\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS45));
+			seq_printf(seq, "CLASS_DEBUG_BUS67\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS67));
+			seq_printf(seq, "CLASS_DEBUG_BUS89\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS89));
+			seq_printf(seq, "CLASS_DEBUG_BUS1011\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS1011));
+			seq_printf(seq, "CLASS_DEBUG_BUS12\t0x%x\n", hal_read32(base_va + CLASS_DEBUG_BUS12));
+			seq_printf(seq, "CLASS_PHY1_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_RX_PKTS));
+			seq_printf(seq, "CLASS_PHY1_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_L3_FAIL_PKTS));
+			seq_printf(seq, "CLASS_PHY1_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V4_PKTS));
+			seq_printf(seq, "CLASS_PHY1_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V6_PKTS));
+			seq_printf(seq, "CLASS_PHY1_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_CHKSUM_ERR_PKTS));
+			seq_printf(seq, "CLASS_PHY1_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_TTL_ERR_PKTS));
+			seq_printf(seq, "CLASS_PHY1_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_RX_PKTS));
+			seq_printf(seq, "CLASS_PHY1_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_L3_FAIL_PKTS));
+			seq_printf(seq, "CLASS_PHY1_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V4_PKTS));
+			seq_printf(seq, "CLASS_PHY1_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V6_PKTS));
+			seq_printf(seq, "CLASS_PHY1_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_CHKSUM_ERR_PKTS));
+			seq_printf(seq, "CLASS_PHY1_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_TTL_ERR_PKTS));
+			seq_printf(seq, "CLASS_PHY1_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_RX_PKTS));
+			seq_printf(seq, "CLASS_PHY1_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_L3_FAIL_PKTS));
+			seq_printf(seq, "CLASS_PHY1_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V4_PKTS));
+			seq_printf(seq, "CLASS_PHY1_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_V6_PKTS));
+			seq_printf(seq, "CLASS_PHY1_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_CHKSUM_ERR_PKTS));
+			seq_printf(seq, "CLASS_PHY1_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_TTL_ERR_PKTS));
+			seq_printf(seq, "CLASS_PHY2_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_RX_PKTS));
+			seq_printf(seq, "CLASS_PHY2_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_L3_FAIL_PKTS));
+			seq_printf(seq, "CLASS_PHY2_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_V4_PKTS));
+			seq_printf(seq, "CLASS_PHY2_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_V6_PKTS));
+			seq_printf(seq, "CLASS_PHY2_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_CHKSUM_ERR_PKTS));
+			seq_printf(seq, "CLASS_PHY2_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_TTL_ERR_PKTS));
+			seq_printf(seq, "CLASS_PHY3_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_RX_PKTS));
+			seq_printf(seq, "CLASS_PHY3_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_L3_FAIL_PKTS));
+			seq_printf(seq, "CLASS_PHY3_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_V4_PKTS));
+			seq_printf(seq, "CLASS_PHY3_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_V6_PKTS));
+			seq_printf(seq, "CLASS_PHY3_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_CHKSUM_ERR_PKTS));
+			seq_printf(seq, "CLASS_PHY3_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_TTL_ERR_PKTS));
+			seq_printf(seq, "CLASS_PHY1_ICMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_ICMP_PKTS));
+			seq_printf(seq, "CLASS_PHY1_IGMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_IGMP_PKTS));
+			seq_printf(seq, "CLASS_PHY1_TCP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_TCP_PKTS));
+			seq_printf(seq, "CLASS_PHY1_UDP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY1_UDP_PKTS));
+			seq_printf(seq, "CLASS_PHY2_ICMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_ICMP_PKTS));
+			seq_printf(seq, "CLASS_PHY2_IGMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_IGMP_PKTS));
+			seq_printf(seq, "CLASS_PHY2_TCP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_TCP_PKTS));
+			seq_printf(seq, "CLASS_PHY2_UDP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY2_UDP_PKTS));
+			seq_printf(seq, "CLASS_PHY3_ICMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_ICMP_PKTS));
+			seq_printf(seq, "CLASS_PHY3_IGMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_IGMP_PKTS));
+			seq_printf(seq, "CLASS_PHY3_TCP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_TCP_PKTS));
+			seq_printf(seq, "CLASS_PHY3_UDP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY3_UDP_PKTS));
+			seq_printf(seq, "CLASS_PHY4_ICMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_ICMP_PKTS));
+			seq_printf(seq, "CLASS_PHY4_IGMP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_IGMP_PKTS));
+			seq_printf(seq, "CLASS_PHY4_TCP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_TCP_PKTS));
+			seq_printf(seq, "CLASS_PHY4_UDP_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_UDP_PKTS));
+			seq_printf(seq, "CLASS_PHY4_RX_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_RX_PKTS));
+			seq_printf(seq, "CLASS_PHY4_L3_FAIL_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_L3_FAIL_PKTS));
+			seq_printf(seq, "CLASS_PHY4_V4_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_V4_PKTS));
+			seq_printf(seq, "CLASS_PHY4_V6_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_V6_PKTS));
+			seq_printf(seq, "CLASS_PHY4_CHKSUM_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_CHKSUM_ERR_PKTS));
+			seq_printf(seq, "CLASS_PHY4_TTL_ERR_PKTS\t0x%x\n", hal_read32(base_va + CLASS_PHY4_TTL_ERR_PKTS));
 		}
 
 		if(verb_level >= 9U)
 		{
 			/*	Get version */
 			reg = hal_read32(base_va + CLASS_VERSION);
-			len += oal_util_snprintf(buf + len, size - len, "Revision\t0x%x\n", (reg >> 24U) & 0xffU);
-			len += oal_util_snprintf(buf + len, size - len, "Version \t0x%x\n", (reg >> 16U) & 0xffU);
-			len += oal_util_snprintf(buf + len, size - len, "ID      \t0x%x\n", reg & 0xffffU);
+			seq_printf(seq, "Revision\t0x%x\n", (reg >> 24U) & 0xffU);
+			seq_printf(seq, "Version \t0x%x\n", (reg >> 16U) & 0xffU);
+			seq_printf(seq, "ID      \t0x%x\n", reg & 0xffffU);
 		}
 			/*	CLASS_ROUTE_MULTI */
 			reg = hal_read32(base_va + CLASS_ROUTE_MULTI);
-			len += oal_util_snprintf(buf + len, size - len, "CLASS_ROUTE_MULTI \t0x%x\n", reg);
+			seq_printf(seq, "CLASS_ROUTE_MULTI \t0x%x\n", reg);
 
 			/*	CLASS_STATE */
 			reg = hal_read32(base_va + CLASS_STATE);
-			len += oal_util_snprintf(buf + len, size - len, "CLASS_STATE       \t0x%x\n", reg);
+			seq_printf(seq, "CLASS_STATE       \t0x%x\n", reg);
 
 			reg = hal_read32(base_va + CLASS_QB_BUF_AVAIL);
-			len += oal_util_snprintf(buf + len, size - len, "CLASS_QB_BUF_AVAIL\t0x%x\n", reg);
+			seq_printf(seq, "CLASS_QB_BUF_AVAIL\t0x%x\n", reg);
 
 			reg = hal_read32(base_va + CLASS_RO_BUF_AVAIL);
-			len += oal_util_snprintf(buf + len, size - len, "CLASS_RO_BUF_AVAIL\t0x%x\n", reg);
+			seq_printf(seq, "CLASS_RO_BUF_AVAIL\t0x%x\n", reg);
 
 			reg = hal_read32(base_va + CLASS_PE0_DEBUG);
-			len += oal_util_snprintf(buf + len, size - len, "PE0 PC\t0x%x\n", reg & 0xffffU);
+			seq_printf(seq, "PE0 PC\t0x%x\n", reg & 0xffffU);
 			reg = hal_read32(base_va + CLASS_PE1_DEBUG);
-			len += oal_util_snprintf(buf + len, size - len, "PE1 PC\t0x%x\n", reg & 0xffffU);
+			seq_printf(seq, "PE1 PC\t0x%x\n", reg & 0xffffU);
 			reg = hal_read32(base_va + CLASS_PE2_DEBUG);
-			len += oal_util_snprintf(buf + len, size - len, "PE2 PC\t0x%x\n", reg & 0xffffU);
+			seq_printf(seq, "PE2 PC\t0x%x\n", reg & 0xffffU);
 			reg = hal_read32(base_va + CLASS_PE3_DEBUG);
-			len += oal_util_snprintf(buf + len, size - len, "PE3 PC\t0x%x\n", reg & 0xffffU);
+			seq_printf(seq, "PE3 PC\t0x%x\n", reg & 0xffffU);
 			reg = hal_read32(base_va + CLASS_PE4_DEBUG);
-			len += oal_util_snprintf(buf + len, size - len, "PE4 PC\t0x%x\n", reg & 0xffffU);
+			seq_printf(seq, "PE4 PC\t0x%x\n", reg & 0xffffU);
 			reg = hal_read32(base_va + CLASS_PE5_DEBUG);
-			len += oal_util_snprintf(buf + len, size - len, "PE5 PC\t0x%x\n", reg & 0xffffU);
+			seq_printf(seq, "PE5 PC\t0x%x\n", reg & 0xffffU);
 			reg = hal_read32(base_va + CLASS_PE6_DEBUG);
-			len += oal_util_snprintf(buf + len, size - len, "PE6 PC\t0x%x\n", reg & 0xffffU);
+			seq_printf(seq, "PE6 PC\t0x%x\n", reg & 0xffffU);
 			reg = hal_read32(base_va + CLASS_PE7_DEBUG);
-			len += oal_util_snprintf(buf + len, size - len, "PE7 PC\t0x%x\n", reg & 0xffffU);
+			seq_printf(seq, "PE7 PC\t0x%x\n", reg & 0xffffU);
 
 			/*	Get info per PHY */
-			len += oal_util_snprintf(buf + len, size - len, "[PHY1]\n");
+			seq_printf(seq, "[PHY1]\n");
 
-			len += oal_util_snprintf(buf + len, size - len, "RX\t%10u TX\t%10u\nIPV4\t%10u IPV6\t%10u\n",
+			seq_printf(seq, "RX\t%10u TX\t%10u\nIPV4\t%10u IPV6\t%10u\n",
 					hal_read32(base_va + CLASS_PHY1_RX_PKTS),
 					hal_read32(base_va + CLASS_PHY1_TX_PKTS),
 					hal_read32(base_va + CLASS_PHY1_V4_PKTS),
 					hal_read32(base_va + CLASS_PHY1_V6_PKTS));
 
-			len += oal_util_snprintf(buf + len, size - len, "ICMP\t%10u IGMP\t%10u TCP\t%10u UDP\t%10u\n",
+			seq_printf(seq, "ICMP\t%10u IGMP\t%10u TCP\t%10u UDP\t%10u\n",
 					hal_read32(base_va + CLASS_PHY1_ICMP_PKTS),
 					hal_read32(base_va + CLASS_PHY1_IGMP_PKTS),
 					hal_read32(base_va + CLASS_PHY1_TCP_PKTS),
 					hal_read32(base_va + CLASS_PHY1_UDP_PKTS));
 
-			len += oal_util_snprintf(buf + len, size - len, "L3 Fail\t%10u CSUM Fail\t%10u TTL Fail\t%10u\n",
+			seq_printf(seq, "L3 Fail\t%10u CSUM Fail\t%10u TTL Fail\t%10u\n",
 					hal_read32(base_va + CLASS_PHY1_L3_FAIL_PKTS),
 					hal_read32(base_va + CLASS_PHY1_CHKSUM_ERR_PKTS),
 					hal_read32(base_va + CLASS_PHY1_TTL_ERR_PKTS));
 
-			len += oal_util_snprintf(buf + len, size - len, "[PHY2]\n");
+			seq_printf(seq, "[PHY2]\n");
 
-			len += oal_util_snprintf(buf + len, size - len, "RX\t%10u TX\t%10u\t IPV4\t%10u IPV6\t%10u\n",
+			seq_printf(seq, "RX\t%10u TX\t%10u\t IPV4\t%10u IPV6\t%10u\n",
 					hal_read32(base_va + CLASS_PHY2_RX_PKTS),
 					hal_read32(base_va + CLASS_PHY2_TX_PKTS),
 					hal_read32(base_va + CLASS_PHY2_V4_PKTS),
 					hal_read32(base_va + CLASS_PHY2_V6_PKTS));
 
-			len += oal_util_snprintf(buf + len, size - len, "ICMP\t%10u IGMP\t%10u TCP\t%10u UDP\t%10u\n",
+			seq_printf(seq, "ICMP\t%10u IGMP\t%10u TCP\t%10u UDP\t%10u\n",
 					hal_read32(base_va + CLASS_PHY2_ICMP_PKTS),
 					hal_read32(base_va + CLASS_PHY2_IGMP_PKTS),
 					hal_read32(base_va + CLASS_PHY2_TCP_PKTS),
 					hal_read32(base_va + CLASS_PHY2_UDP_PKTS));
 
-			len += oal_util_snprintf(buf + len, size - len, "L3 Fail\t%10u CSUM Fail\t%10u TTL Fail\t%10u\n",
+			seq_printf(seq, "L3 Fail\t%10u CSUM Fail\t%10u TTL Fail\t%10u\n",
 					hal_read32(base_va + CLASS_PHY2_L3_FAIL_PKTS),
 					hal_read32(base_va + CLASS_PHY2_CHKSUM_ERR_PKTS),
 					hal_read32(base_va + CLASS_PHY2_TTL_ERR_PKTS));
 
-			len += oal_util_snprintf(buf + len, size - len, "[PHY3]\n");
+			seq_printf(seq, "[PHY3]\n");
 
-			len += oal_util_snprintf(buf + len, size - len, "RX\t%10u TX\t%10u\nIPV4\t%10u IPV6\t%10u\n",
+			seq_printf(seq, "RX\t%10u TX\t%10u\nIPV4\t%10u IPV6\t%10u\n",
 					hal_read32(base_va + CLASS_PHY3_RX_PKTS),
 					hal_read32(base_va + CLASS_PHY3_TX_PKTS),
 					hal_read32(base_va + CLASS_PHY3_V4_PKTS),
 					hal_read32(base_va + CLASS_PHY3_V6_PKTS));
 
-			len += oal_util_snprintf(buf + len, size - len, "ICMP\t%10u IGMP\t%10u TCP\t%10u UDP\t%10u\n",
+			seq_printf(seq, "ICMP\t%10u IGMP\t%10u TCP\t%10u UDP\t%10u\n",
 					hal_read32(base_va + CLASS_PHY3_ICMP_PKTS),
 					hal_read32(base_va + CLASS_PHY3_IGMP_PKTS),
 					hal_read32(base_va + CLASS_PHY3_TCP_PKTS),
 					hal_read32(base_va + CLASS_PHY3_UDP_PKTS));
 
-			len += oal_util_snprintf(buf + len, size - len, "L3 Fail\t%10u CSUM Fail\t%10u TTL Fail\t%10u\n",
+			seq_printf(seq, "L3 Fail\t%10u CSUM Fail\t%10u TTL Fail\t%10u\n",
 					hal_read32(base_va + CLASS_PHY3_L3_FAIL_PKTS),
 					hal_read32(base_va + CLASS_PHY3_CHKSUM_ERR_PKTS),
 					hal_read32(base_va + CLASS_PHY3_TTL_ERR_PKTS));
 
-			len += oal_util_snprintf(buf + len, size - len, "[PHY4]\n");
+			seq_printf(seq, "[PHY4]\n");
 
-			len += oal_util_snprintf(buf + len, size - len, "RX\t%10u TX\t%10u\nIPV4\t%10u IPV6\t%10u\n",
+			seq_printf(seq, "RX\t%10u TX\t%10u\nIPV4\t%10u IPV6\t%10u\n",
 					hal_read32(base_va + CLASS_PHY4_RX_PKTS),
 					hal_read32(base_va + CLASS_PHY4_TX_PKTS),
 					hal_read32(base_va + CLASS_PHY4_V4_PKTS),
 					hal_read32(base_va + CLASS_PHY4_V6_PKTS));
 
-			len += oal_util_snprintf(buf + len, size - len, "ICMP\t%10u IGMP\t%10u TCP\t%10u UDP\t%10u\n",
+			seq_printf(seq, "ICMP\t%10u IGMP\t%10u TCP\t%10u UDP\t%10u\n",
 					hal_read32(base_va + CLASS_PHY4_ICMP_PKTS),
 					hal_read32(base_va + CLASS_PHY4_IGMP_PKTS),
 					hal_read32(base_va + CLASS_PHY4_TCP_PKTS),
 					hal_read32(base_va + CLASS_PHY4_UDP_PKTS));
 
-			len += oal_util_snprintf(buf + len, size - len, "L3 Fail\t%10u CSUM Fail\t%10u TTL Fail\t%10u\n",
+			seq_printf(seq, "L3 Fail\t%10u CSUM Fail\t%10u TTL Fail\t%10u\n",
 					hal_read32(base_va + CLASS_PHY4_L3_FAIL_PKTS),
 					hal_read32(base_va + CLASS_PHY4_CHKSUM_ERR_PKTS),
 					hal_read32(base_va + CLASS_PHY4_TTL_ERR_PKTS));
 	}
 
-	return len;
+	return 0;
 }
 
 #endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
@@ -477,6 +474,30 @@ void pfe_class_cfg_rtable_lookup_disable(const addr_t base_va)
 	NXP_LOG_INFO("Disabling RTable lookup PARSE_ROUTE_EN\n");
 }
 
+/**
+ * @brief		Enable HW bridge lookup
+ * @param[in]	base_va Base address of CLASS register space (virtual)
+ */
+void pfe_class_cfg_bridge_lookup_enable(const addr_t base_va)
+{
+	uint32_t reg = hal_read32(base_va + CLASS_ROUTE_MULTI);
+	hal_write32(reg | PARSE_BRIDGE_EN(TRUE), base_va + CLASS_ROUTE_MULTI);
+
+	NXP_LOG_INFO("Enabling HW bridge lookup PARSE_BRIDGE_EN\n");
+}
+
+/**
+ * @brief		Disable HW bridge lookup
+ * @param[in]	base_va Base address of CLASS register space (virtual)
+ */
+void pfe_class_cfg_bridge_lookup_disable(const addr_t base_va)
+{
+	uint32_t reg = hal_read32(base_va + CLASS_ROUTE_MULTI);
+	hal_write32(reg & (~PARSE_BRIDGE_EN(TRUE)), base_va + CLASS_ROUTE_MULTI);
+
+	NXP_LOG_INFO("Disabling HW bridge lookup PARSE_BRIDGE_EN\n");
+}
+
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
 #include "Eth_43_PFE_MemMap.h"
diff --git a/sw/pfe_platform/hw/s32g/pfe_class_csr.h b/sw/pfe_platform/hw/s32g/pfe_class_csr.h
index feabe51..859a701 100644
--- a/sw/pfe_platform/hw/s32g/pfe_class_csr.h
+++ b/sw/pfe_platform/hw/s32g/pfe_class_csr.h
@@ -2,7 +2,7 @@
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
  *  Copyright 2015-2016 Freescale Semiconductor, Inc.
- *  Copyright 2017-2022 NXP
+ *  Copyright 2017-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -347,14 +347,14 @@ void pfe_class_cfg_reset(addr_t base_va);
 void pfe_class_cfg_enable(addr_t base_va);
 void pfe_class_cfg_disable(addr_t base_va);
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-uint32_t pfe_class_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, uint8_t verb_level);
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
+uint32_t pfe_class_cfg_get_text_stat(addr_t base_va, struct seq_file *seq, uint8_t verb_level);
 
 errno_t pfe_class_cfg_set_rtable(addr_t base_va, addr_t rtable_pa, uint32_t rtable_len, uint32_t entry_size);
 void pfe_class_cfg_set_def_vlan(addr_t base_va, uint16_t vlan);
 void pfe_class_cfg_rtable_lookup_enable(const addr_t base_va);
 void pfe_class_cfg_rtable_lookup_disable(const addr_t base_va);
+void pfe_class_cfg_bridge_lookup_enable(const addr_t base_va);
+void pfe_class_cfg_bridge_lookup_disable(const addr_t base_va);
 
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
diff --git a/sw/pfe_platform/hw/s32g/pfe_emac_csr.c b/sw/pfe_platform/hw/s32g/pfe_emac_csr.c
index afa201c..8e6d2fb 100644
--- a/sw/pfe_platform/hw/s32g/pfe_emac_csr.c
+++ b/sw/pfe_platform/hw/s32g/pfe_emac_csr.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -15,22 +15,19 @@
 #include "pfe_emac_csr.h"
 #include "pfe_feature_mgr.h"
 
-#ifdef PFE_CFG_TARGET_OS_AUTOSAR
-/* TODO: Remove this macro after ARTD-27720 is finished (AAVB-5221) */
-#define ETH_43_PFE_PROT_MEM_U32            ((uint32)0x00000004UL) 
+#ifndef ETH_HLEN
+#define ETH_HLEN		14U
+#endif
+#ifndef ETH_FCS_LEN
+#define ETH_FCS_LEN		4U
+#endif
+#ifndef VLAN_HLEN
+#define VLAN_HLEN		4U
+#endif
 
-#if (STD_ON == ETH_43_PFE_USER_ACCESS_ALLOWED_AVAILABLE)
-    #define USER_MODE_REG_PROT_ENABLED      (STD_ON)
-    #include "RegLockMacros.h"
-#endif /* (STD_ON == ETH_43_PFE_SET_USER_ACCESS_ALLOWED_AVAILABLE) */
-#endif /*PFE_CFG_TARGET_OS_AUTOSAR*/
-
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-
-#ifdef PFE_CFG_TARGET_OS_AUTOSAR
-#define ETH_43_PFE_START_SEC_CONST_32
-#include "Eth_43_PFE_MemMap.h"
-#endif /* PFE_CFG_TARGET_OS_AUTOSAR */
+#define PFE_EMAC_PKT_OVERHEAD	(PFE_MIN_DSA_OVERHEAD + ETH_HLEN + ETH_FCS_LEN)
+#define PFE_EMAC_STD_MAXFRMSZ	(PFE_EMAC_STD_MTU + PFE_EMAC_PKT_OVERHEAD)
+#define PFE_EMAC_JUMBO_MAXFRMSZ	(PFE_EMAC_JUMBO_MTU + PFE_EMAC_PKT_OVERHEAD)
 
 /* Mode conversion table */
 /* usage scope: phy_mode_to_str */
@@ -47,28 +44,12 @@ static const char_t * const phy_mode[] =
         "INVALID",
 };
 
-#ifdef PFE_CFG_TARGET_OS_AUTOSAR
-#define ETH_43_PFE_STOP_SEC_CONST_32
-#include "Eth_43_PFE_MemMap.h"
-#endif /* PFE_CFG_TARGET_OS_AUTOSAR */
-
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
-
-#ifdef PFE_CFG_TARGET_OS_AUTOSAR
-#define ETH_43_PFE_START_SEC_CODE
-#include "Eth_43_PFE_MemMap.h"
-#endif /* PFE_CFG_TARGET_OS_AUTOSAR */
-
 static inline uint32_t reverse_bits_32(uint32_t u32Data);
 static inline uint32_t crc32_reversed(const uint8_t *const data, const uint32_t len);
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-
 static inline const char_t* phy_mode_to_str(uint32_t mode);
 static const char *emac_speed_to_str(pfe_emac_speed_t speed);
 
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
-
 static inline uint32_t reverse_bits_32(uint32_t u32Data)
 {
     uint8_t u8Index;
@@ -111,8 +92,6 @@ static inline uint32_t crc32_reversed(const uint8_t *const data, const uint32_t
 	return reverse_bits_32(~res);
 }
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-
 /**
  * @brief		Convert EMAC mode to string
  * @details		Helper function for statistics to convert phy mode to string.
@@ -163,30 +142,6 @@ static const char *emac_speed_to_str(pfe_emac_speed_t speed)
 	return ret;
 }
 
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
-
-#ifdef PFE_CFG_TARGET_OS_AUTOSAR
-#if (STD_ON == ETH_43_PFE_USER_ACCESS_ALLOWED_AVAILABLE)
-/**
- * @brief		Set UAA bit in the register protection module while using the usermode functionality
- * @param[in]	base_va The EMAC base address
- */
-void pfe_emac_csr_set_user_mode_allowed(const uint32_t * base_va)
-{
-    SET_USER_ACCESS_ALLOWED((uint32_t)base_va, ETH_43_PFE_PROT_MEM_U32);
-}
-
-/**
- * @brief		Clear UAA bit in the register protection module while using the usermode functionality
- * @param[in]	base_va The EMAC base address
- */
-void pfe_emac_csr_clr_user_mode_allowed(const uint32_t * base_va)
-{
-    CLR_USER_ACCESS_ALLOWED((uint32_t)base_va, ETH_43_PFE_PROT_MEM_U32);
-}
-#endif /*STD_ON == ETH_43_PFE_USER_ACCESS_ALLOWED_AVAILABLE*/
-#endif /*PFE_CFG_TARGET_OS_AUTOSAR*/
-
 /**
  * @brief		HW-specific initialization function
  * @param[in]	base_va Base address of MAC register space (virtual)
@@ -242,7 +197,8 @@ errno_t pfe_emac_cfg_init(addr_t base_va, pfe_emac_mii_mode_t mode,
 	hal_write32(reg
 			| LARGE_MODE_TIMEOUT(0x2U)
 			| NORMAL_MODE_TIMEOUT(0x2U)
-			| 0x10UL
+			/*	Select according to real CSR clock frequency. S32G: CSR_CLK = 300MHz => 300 ticks */
+			| 0x12CUL
 			, base_va + MAC_FSM_ACT_TIMER);
 	hal_write32(0U
 			| DATA_PARITY_PROTECTION(1U)
@@ -250,7 +206,7 @@ errno_t pfe_emac_cfg_init(addr_t base_va, pfe_emac_mii_mode_t mode,
 			, base_va + MTL_DPP_CONTROL);
 	hal_write32(0U
 			| FSM_PARITY_ENABLE(1U)
-			| FSM_TIMEOUT_ENABLE(0U)
+			| FSM_TIMEOUT_ENABLE(1U)
 			, base_va + MAC_FSM_CONTROL);
 
 	reg = 0U | ARP_OFFLOAD_ENABLE(0U)
@@ -296,11 +252,11 @@ errno_t pfe_emac_cfg_init(addr_t base_va, pfe_emac_mii_mode_t mode,
 	hal_write32(0U, base_va + MTL_TXQ0_OPERATION_MODE);
 	if (TRUE == pfe_feature_mgr_is_available("jumbo_frames"))
 	{
-		hal_write32(GIANT_PACKET_SIZE_LIMIT(9022U), base_va + MAC_EXT_CONFIGURATION);
+		hal_write32(GIANT_PACKET_SIZE_LIMIT(PFE_EMAC_JUMBO_MAXFRMSZ), base_va + MAC_EXT_CONFIGURATION);
 	}
 	else
 	{
-		hal_write32(GIANT_PACKET_SIZE_LIMIT(1522U), base_va + MAC_EXT_CONFIGURATION);
+		hal_write32(GIANT_PACKET_SIZE_LIMIT(PFE_EMAC_STD_MAXFRMSZ), base_va + MAC_EXT_CONFIGURATION);
 	}
 
 	hal_write32(0U, base_va + MAC_TIMESTAMP_CONTROL);
@@ -949,7 +905,7 @@ errno_t pfe_emac_cfg_set_max_frame_length(addr_t base_va, uint32_t len)
 
 	if (je && edvlp)
 	{
-		maxlen = 9026U;
+		maxlen = PFE_EMAC_JUMBO_MAXFRMSZ + VLAN_HLEN;
 	}
 
 	if (!je && s2kp)
@@ -966,24 +922,24 @@ errno_t pfe_emac_cfg_set_max_frame_length(addr_t base_va, uint32_t len)
 
 	if (!je && !s2kp && !gpslce && edvlp)
 	{
-		maxlen = 1526U;
+		maxlen = PFE_EMAC_STD_MAXFRMSZ + VLAN_HLEN;
 	}
 
 	if (je && !edvlp)
 	{
-		maxlen = 9022U;
+		maxlen = PFE_EMAC_JUMBO_MAXFRMSZ;
 	}
 
 	if (!je && !s2kp && gpslce && !edvlp)
 	{
 		reg = hal_read32(base_va + MAC_EXT_CONFIGURATION);
 		maxlen = reg & GIANT_PACKET_SIZE_LIMIT((uint32_t)-1);
-		maxlen += 4U;
+		maxlen += VLAN_HLEN;
 	}
 
 	if (!je && !s2kp && !gpslce && !edvlp)
 	{
-		maxlen = 1522U;
+		maxlen = PFE_EMAC_STD_MAXFRMSZ;
 	}
 
 	if (len > maxlen)
@@ -1238,7 +1194,7 @@ errno_t pfe_emac_cfg_mdio_read22(addr_t base_va, uint8_t pa, uint8_t ra, uint16_
 			| CLAUSE45_ENABLE(0U)
 			| GMII_OPERATION_CMD(GMII_READ)
 			| SKIP_ADDRESS_PACKET(0U)
-			/*	Select according to real CSR clock frequency. S32G: CSR_CLK = XBAR_CLK = 400MHz */
+			/*	Select according to real CSR clock frequency. S32G: CSR_CLK = XBAR_CLK = 300MHz */
 			| CSR_CLOCK_RANGE(CSR_CLK_300_500_MHZ_MDC_CSR_DIV_204)
 			| NUM_OF_TRAILING_CLOCKS(0U)
 			| REG_DEV_ADDR(ra)
@@ -1294,7 +1250,7 @@ errno_t pfe_emac_cfg_mdio_read45(addr_t base_va, uint8_t pa, uint8_t dev, uint16
 			| CLAUSE45_ENABLE(1U)
 			| GMII_OPERATION_CMD(GMII_READ)
 			| SKIP_ADDRESS_PACKET(0U)
-			/*	Select according to real CSR clock frequency. S32G: CSR_CLK = XBAR_CLK = 400MHz */
+			/*	Select according to real CSR clock frequency. S32G: CSR_CLK = XBAR_CLK = 300MHz */
 			| CSR_CLOCK_RANGE(CSR_CLK_300_500_MHZ_MDC_CSR_DIV_204)
 			| NUM_OF_TRAILING_CLOCKS(0U)
 			| REG_DEV_ADDR(dev)
@@ -1345,7 +1301,7 @@ errno_t pfe_emac_cfg_mdio_write22(addr_t base_va, uint8_t pa, uint8_t ra, uint16
 				| CLAUSE45_ENABLE(0U)
 				| GMII_OPERATION_CMD(GMII_WRITE)
 				| SKIP_ADDRESS_PACKET(0U)
-				/*	Select according to real CSR clock frequency. S32G: CSR_CLK = XBAR_CLK = 400MHz */
+				/*	Select according to real CSR clock frequency. S32G: CSR_CLK = XBAR_CLK = 300MHz */
 				| CSR_CLOCK_RANGE(CSR_CLK_300_500_MHZ_MDC_CSR_DIV_204)
 				| NUM_OF_TRAILING_CLOCKS(0U)
 				| REG_DEV_ADDR(ra)
@@ -1389,7 +1345,7 @@ errno_t pfe_emac_cfg_mdio_write45(addr_t base_va, uint8_t pa, uint8_t dev, uint1
 				| CLAUSE45_ENABLE(1U)
 				| GMII_OPERATION_CMD(GMII_WRITE)
 				| SKIP_ADDRESS_PACKET(0U)
-				/*	Select according to real CSR clock frequency. S32G: CSR_CLK = XBAR_CLK = 400MHz */
+				/*	Select according to real CSR clock frequency. S32G: CSR_CLK = XBAR_CLK = 300MHz */
 				| CSR_CLOCK_RANGE(CSR_CLK_300_500_MHZ_MDC_CSR_DIV_204)
 				| NUM_OF_TRAILING_CLOCKS(0U)
 				| REG_DEV_ADDR(dev)
@@ -1432,21 +1388,17 @@ uint32_t pfe_emac_cfg_get_rx_cnt(addr_t base_va)
 	return hal_read32(base_va + RX_PACKETS_COUNT_GOOD_BAD);
 }
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-
 /**
  * @brief		Get EMAC statistics in text form
  * @details		This is a HW-specific function providing detailed text statistics
  * 				about the EMAC block.
  * @param[in]	base_va 	Base address of EMAC register space (virtual)
- * @param[in]	buf 		Pointer to the buffer to write to
- * @param[in]	size 		Buffer length
+ * @param[in]	seq 		Pointer to debugfs seq_file
  * @param[in]	verb_level 	Verbosity level
  * @return		Number of bytes written to the buffer
  */
-uint32_t pfe_emac_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, uint8_t verb_level)
+uint32_t pfe_emac_cfg_get_text_stat(addr_t base_va, struct seq_file *seq, uint8_t verb_level)
 {
-	uint32_t len = 0U;
 	uint32_t reg;
 	pfe_emac_speed_t speed;
 	pfe_emac_duplex_t duplex;
@@ -1462,163 +1414,161 @@ uint32_t pfe_emac_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size,
 	{
 		/*	Get version */
 		reg = hal_read32(base_va + MAC_VERSION);
-		len += oal_util_snprintf(buf + len, size - len, "SNPVER                    : 0x%x\n", reg & 0xffU);
-		len += oal_util_snprintf(buf + len, size - len, "USERVER                   : 0x%x\n", (reg >> 8) & 0xffU);
+		seq_printf(seq,  "SNPVER                    : 0x%x\n", reg & 0xffU);
+		seq_printf(seq,  "USERVER                   : 0x%x\n", (reg >> 8) & 0xffU);
 
 		reg = hal_read32(base_va + RX_PACKETS_COUNT_GOOD_BAD);
-		len += oal_util_snprintf(buf + len, size - len, "RX_PACKETS_COUNT_GOOD_BAD : 0x%x\n", reg);
+		seq_printf(seq,  "RX_PACKETS_COUNT_GOOD_BAD : 0x%x\n", reg);
 		reg = hal_read32(base_va + TX_PACKET_COUNT_GOOD_BAD);
-		len += oal_util_snprintf(buf + len, size - len, "TX_PACKET_COUNT_GOOD_BAD  : 0x%x\n", reg);
+		seq_printf(seq,  "TX_PACKET_COUNT_GOOD_BAD  : 0x%x\n", reg);
 
 		(void)pfe_emac_cfg_get_link_config(base_va, &speed, &duplex);
 		reg = hal_read32(base_va + MAC_CONFIGURATION);
-		len += oal_util_snprintf(buf + len, size - len, "MAC_CONFIGURATION         : 0x%x [speed: %s]\n", reg, emac_speed_to_str(speed));
+		seq_printf(seq,  "MAC_CONFIGURATION         : 0x%x [speed: %s]\n", reg, emac_speed_to_str(speed));
 
 		reg = (hal_read32(base_va + MAC_HW_FEATURE0) >> 28U) & 0x07U;
-		len += oal_util_snprintf(buf + len, size - len, "ACTPHYSEL(MAC_HW_FEATURE0): %s\n", phy_mode_to_str(reg));
+		seq_printf(seq,  "ACTPHYSEL(MAC_HW_FEATURE0): %s\n", phy_mode_to_str(reg));
 
 		/* Error debugging */
 		if(verb_level >= 8U)
 		{
 			reg = hal_read32(base_va + TX_UNDERFLOW_ERROR_PACKETS);
-			len += oal_util_snprintf(buf + len, size - len, "TX_UNDERFLOW_ERROR_PACKETS        : 0x%x\n", reg);
+			seq_printf(seq,  "TX_UNDERFLOW_ERROR_PACKETS        : 0x%x\n", reg);
 			reg = hal_read32(base_va + TX_SINGLE_COLLISION_GOOD_PACKETS);
-			len += oal_util_snprintf(buf + len, size - len, "TX_SINGLE_COLLISION_GOOD_PACKETS  : 0x%x\n", reg);
+			seq_printf(seq,  "TX_SINGLE_COLLISION_GOOD_PACKETS  : 0x%x\n", reg);
 			reg = hal_read32(base_va + TX_MULTIPLE_COLLISION_GOOD_PACKETS);
-			len += oal_util_snprintf(buf + len, size - len, "TX_MULTIPLE_COLLISION_GOOD_PACKETS: 0x%x\n", reg);
+			seq_printf(seq,  "TX_MULTIPLE_COLLISION_GOOD_PACKETS: 0x%x\n", reg);
 			reg = hal_read32(base_va + TX_DEFERRED_PACKETS);
-			len += oal_util_snprintf(buf + len, size - len, "TX_DEFERRED_PACKETS               : 0x%x\n", reg);
+			seq_printf(seq,  "TX_DEFERRED_PACKETS               : 0x%x\n", reg);
 			reg = hal_read32(base_va + TX_LATE_COLLISION_PACKETS);
-			len += oal_util_snprintf(buf + len, size - len, "TX_LATE_COLLISION_PACKETS         : 0x%x\n", reg);
+			seq_printf(seq,  "TX_LATE_COLLISION_PACKETS         : 0x%x\n", reg);
 			reg = hal_read32(base_va + TX_EXCESSIVE_COLLISION_PACKETS);
-			len += oal_util_snprintf(buf + len, size - len, "TX_EXCESSIVE_COLLISION_PACKETS    : 0x%x\n", reg);
+			seq_printf(seq,  "TX_EXCESSIVE_COLLISION_PACKETS    : 0x%x\n", reg);
 			reg = hal_read32(base_va + TX_CARRIER_ERROR_PACKETS);
-			len += oal_util_snprintf(buf + len, size - len, "TX_CARRIER_ERROR_PACKETS          : 0x%x\n", reg);
+			seq_printf(seq,  "TX_CARRIER_ERROR_PACKETS          : 0x%x\n", reg);
 			reg = hal_read32(base_va + TX_EXCESSIVE_DEFERRAL_ERROR);
-			len += oal_util_snprintf(buf + len, size - len, "TX_EXCESSIVE_DEFERRAL_ERROR       : 0x%x\n", reg);
+			seq_printf(seq,  "TX_EXCESSIVE_DEFERRAL_ERROR       : 0x%x\n", reg);
 
 			reg = hal_read32(base_va + TX_OSIZE_PACKETS_GOOD);
-			len += oal_util_snprintf(buf + len, size - len, "TX_OSIZE_PACKETS_GOOD             : 0x%x\n", reg);
+			seq_printf(seq,  "TX_OSIZE_PACKETS_GOOD             : 0x%x\n", reg);
 
 			reg = hal_read32(base_va + RX_CRC_ERROR_PACKETS);
-			len += oal_util_snprintf(buf + len, size - len, "RX_CRC_ERROR_PACKETS              : 0x%x\n", reg);
+			seq_printf(seq,  "RX_CRC_ERROR_PACKETS              : 0x%x\n", reg);
 			reg = hal_read32(base_va + RX_ALIGNMENT_ERROR_PACKETS);
-			len += oal_util_snprintf(buf + len, size - len, "RX_ALIGNMENT_ERROR_PACKETS        : 0x%x\n", reg);
+			seq_printf(seq,  "RX_ALIGNMENT_ERROR_PACKETS        : 0x%x\n", reg);
 			reg = hal_read32(base_va + RX_RUNT_ERROR_PACKETS);
-			len += oal_util_snprintf(buf + len, size - len, "RX_RUNT_ERROR_PACKETS             : 0x%x\n", reg);
+			seq_printf(seq,  "RX_RUNT_ERROR_PACKETS             : 0x%x\n", reg);
 			reg = hal_read32(base_va + RX_JABBER_ERROR_PACKETS);
-			len += oal_util_snprintf(buf + len, size - len, "RX_JABBER_ERROR_PACKETS           : 0x%x\n", reg);
+			seq_printf(seq,  "RX_JABBER_ERROR_PACKETS           : 0x%x\n", reg);
 			reg = hal_read32(base_va + RX_LENGTH_ERROR_PACKETS);
-			len += oal_util_snprintf(buf + len, size - len, "RX_LENGTH_ERROR_PACKETS           : 0x%x\n", reg);
+			seq_printf(seq,  "RX_LENGTH_ERROR_PACKETS           : 0x%x\n", reg);
 			reg = hal_read32(base_va + RX_OUT_OF_RANGE_TYPE_PACKETS);
-			len += oal_util_snprintf(buf + len, size - len, "RX_OUT_OF_RANGE_TYPE_PACKETS      : 0x%x\n", reg);
+			seq_printf(seq,  "RX_OUT_OF_RANGE_TYPE_PACKETS      : 0x%x\n", reg);
 			reg = hal_read32(base_va + RX_FIFO_OVERFLOW_PACKETS);
-			len += oal_util_snprintf(buf + len, size - len, "RX_FIFO_OVERFLOW_PACKETS          : 0x%x\n", reg);
+			seq_printf(seq,  "RX_FIFO_OVERFLOW_PACKETS          : 0x%x\n", reg);
 			reg = hal_read32(base_va + RX_RECEIVE_ERROR_PACKETS);
-			len += oal_util_snprintf(buf + len, size - len, "RX_RECEIVE_ERROR_PACKETS          : 0x%x\n", reg);
+			seq_printf(seq,  "RX_RECEIVE_ERROR_PACKETS          : 0x%x\n", reg);
 			reg = hal_read32(base_va + RX_RECEIVE_ERROR_PACKETS);
-			len += oal_util_snprintf(buf + len, size - len, "RX_RECEIVE_ERROR_PACKETS          : 0x%x\n", reg);
+			seq_printf(seq,  "RX_RECEIVE_ERROR_PACKETS          : 0x%x\n", reg);
 
 			reg = hal_read32(base_va + MTL_ECC_ERR_CNTR_STATUS);
-			len += oal_util_snprintf(buf + len, size - len, "MTL_ECC_CORRECTABLE_ERRORS        : 0x%x\n", (reg & 0xffU));
-			len += oal_util_snprintf(buf + len, size - len, "MTL_ECC_UNCORRECTABLE_ERRORS      : 0x%x\n", ((reg >> 16U) & 0xfU));
+			seq_printf(seq,  "MTL_ECC_CORRECTABLE_ERRORS        : 0x%x\n", (reg & 0xffU));
+			seq_printf(seq,  "MTL_ECC_UNCORRECTABLE_ERRORS      : 0x%x\n", ((reg >> 16U) & 0xfU));
 		}
 
 		/* Cast/vlan/flow control */
 		if(verb_level >= 3U)
 		{
 			reg = hal_read32(base_va + TX_UNICAST_PACKETS_GOOD_BAD);
-			len += oal_util_snprintf(buf + len, size - len, "TX_UNICAST_PACKETS_GOOD_BAD       : 0x%x\n", reg);
+			seq_printf(seq,  "TX_UNICAST_PACKETS_GOOD_BAD       : 0x%x\n", reg);
 			reg = hal_read32(base_va + TX_BROADCAST_PACKETS_GOOD);
-			len += oal_util_snprintf(buf + len, size - len, "TX_BROADCAST_PACKETS_GOOD         : 0x%x\n", reg);
+			seq_printf(seq,  "TX_BROADCAST_PACKETS_GOOD         : 0x%x\n", reg);
 			reg = hal_read32(base_va + TX_BROADCAST_PACKETS_GOOD_BAD);
-			len += oal_util_snprintf(buf + len, size - len, "TX_BROADCAST_PACKETS_GOOD_BAD     : 0x%x\n", reg);
+			seq_printf(seq,  "TX_BROADCAST_PACKETS_GOOD_BAD     : 0x%x\n", reg);
 			reg = hal_read32(base_va + TX_MULTICAST_PACKETS_GOOD);
-			len += oal_util_snprintf(buf + len, size - len, "TX_MULTICAST_PACKETS_GOOD         : 0x%x\n", reg);
+			seq_printf(seq,  "TX_MULTICAST_PACKETS_GOOD         : 0x%x\n", reg);
 			reg = hal_read32(base_va + TX_MULTICAST_PACKETS_GOOD_BAD);
-			len += oal_util_snprintf(buf + len, size - len, "TX_MULTICAST_PACKETS_GOOD_BAD     : 0x%x\n", reg);
+			seq_printf(seq,  "TX_MULTICAST_PACKETS_GOOD_BAD     : 0x%x\n", reg);
 			reg = hal_read32(base_va + TX_VLAN_PACKETS_GOOD);
-			len += oal_util_snprintf(buf + len, size - len, "TX_VLAN_PACKETS_GOOD              : 0x%x\n", reg);
+			seq_printf(seq,  "TX_VLAN_PACKETS_GOOD              : 0x%x\n", reg);
 			reg = hal_read32(base_va + TX_PAUSE_PACKETS);
-			len += oal_util_snprintf(buf + len, size - len, "TX_PAUSE_PACKETS                  : 0x%x\n", reg);
+			seq_printf(seq,  "TX_PAUSE_PACKETS                  : 0x%x\n", reg);
 		}
 
 		if(verb_level >= 4U)
 		{
 			reg = hal_read32(base_va + RX_UNICAST_PACKETS_GOOD);
-			len += oal_util_snprintf(buf + len, size - len, "RX_UNICAST_PACKETS_GOOD           : 0x%x\n", reg);
+			seq_printf(seq,  "RX_UNICAST_PACKETS_GOOD           : 0x%x\n", reg);
 			reg = hal_read32(base_va + RX_BROADCAST_PACKETS_GOOD);
-			len += oal_util_snprintf(buf + len, size - len, "RX_BROADCAST_PACKETS_GOOD         : 0x%x\n", reg);
+			seq_printf(seq,  "RX_BROADCAST_PACKETS_GOOD         : 0x%x\n", reg);
 			reg = hal_read32(base_va + RX_MULTICAST_PACKETS_GOOD);
-			len += oal_util_snprintf(buf + len, size - len, "RX_MULTICAST_PACKETS_GOOD         : 0x%x\n", reg);
+			seq_printf(seq,  "RX_MULTICAST_PACKETS_GOOD         : 0x%x\n", reg);
 			reg = hal_read32(base_va + RX_VLAN_PACKETS_GOOD_BAD);
-			len += oal_util_snprintf(buf + len, size - len, "RX_VLAN_PACKETS_GOOD_BAD          : 0x%x\n", reg);
+			seq_printf(seq,  "RX_VLAN_PACKETS_GOOD_BAD          : 0x%x\n", reg);
 			reg = hal_read32(base_va + RX_PAUSE_PACKETS);
-			len += oal_util_snprintf(buf + len, size - len, "RX_PAUSE_PACKETS                  : 0x%x\n", reg);
+			seq_printf(seq,  "RX_PAUSE_PACKETS                  : 0x%x\n", reg);
 			reg = hal_read32(base_va + RX_CONTROL_PACKETS_GOOD);
-			len += oal_util_snprintf(buf + len, size - len, "RX_CONTROL_PACKETS_GOOD           : 0x%x\n", reg);
+			seq_printf(seq,  "RX_CONTROL_PACKETS_GOOD           : 0x%x\n", reg);
 		}
 
 		if(verb_level >= 1U)
 		{
 			reg = hal_read32(base_va + TX_OCTET_COUNT_GOOD);
-			len += oal_util_snprintf(buf + len, size - len, "TX_OCTET_COUNT_GOOD                : 0x%x\n", reg);
+			seq_printf(seq,  "TX_OCTET_COUNT_GOOD                : 0x%x\n", reg);
 			reg = hal_read32(base_va + TX_OCTET_COUNT_GOOD_BAD);
-			len += oal_util_snprintf(buf + len, size - len, "TX_OCTET_COUNT_GOOD_BAD            : 0x%x\n", reg);
+			seq_printf(seq,  "TX_OCTET_COUNT_GOOD_BAD            : 0x%x\n", reg);
 			reg = hal_read32(base_va + TX_64OCTETS_PACKETS_GOOD_BAD);
-			len += oal_util_snprintf(buf + len, size - len, "TX_64OCTETS_PACKETS_GOOD_BAD       : 0x%x\n", reg);
+			seq_printf(seq,  "TX_64OCTETS_PACKETS_GOOD_BAD       : 0x%x\n", reg);
 			reg = hal_read32(base_va + TX_65TO127OCTETS_PACKETS_GOOD_BAD);
-			len += oal_util_snprintf(buf + len, size - len, "TX_65TO127OCTETS_PACKETS_GOOD_BAD  : 0x%x\n", reg);
+			seq_printf(seq,  "TX_65TO127OCTETS_PACKETS_GOOD_BAD  : 0x%x\n", reg);
 			reg = hal_read32(base_va + TX_128TO255OCTETS_PACKETS_GOOD_BAD);
-			len += oal_util_snprintf(buf + len, size - len, "TX_128TO255OCTETS_PACKETS_GOOD_BAD : 0x%x\n", reg);
+			seq_printf(seq,  "TX_128TO255OCTETS_PACKETS_GOOD_BAD : 0x%x\n", reg);
 			reg = hal_read32(base_va + TX_256TO511OCTETS_PACKETS_GOOD_BAD);
-			len += oal_util_snprintf(buf + len, size - len, "TX_256TO511OCTETS_PACKETS_GOOD_BAD : 0x%x\n", reg);
+			seq_printf(seq,  "TX_256TO511OCTETS_PACKETS_GOOD_BAD : 0x%x\n", reg);
 			reg = hal_read32(base_va + TX_512TO1023OCTETS_PACKETS_GOOD_BAD);
-			len += oal_util_snprintf(buf + len, size - len, "TX_512TO1023OCTETS_PACKETS_GOOD_BAD: 0x%x\n", reg);
+			seq_printf(seq,  "TX_512TO1023OCTETS_PACKETS_GOOD_BAD: 0x%x\n", reg);
 			reg = hal_read32(base_va + TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD);
-			len += oal_util_snprintf(buf + len, size - len, "TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD: 0x%x\n", reg);
+			seq_printf(seq,  "TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD: 0x%x\n", reg);
 		}
 
 		if(verb_level >= 5U)
 		{
 			reg = hal_read32(base_va + TX_OSIZE_PACKETS_GOOD);
-			len += oal_util_snprintf(buf + len, size - len, "TX_OSIZE_PACKETS_GOOD              : 0x%x\n", reg);
+			seq_printf(seq,  "TX_OSIZE_PACKETS_GOOD              : 0x%x\n", reg);
 		}
 
 		if(verb_level >= 2U)
 		{
 			reg = hal_read32(base_va + RX_OCTET_COUNT_GOOD);
-			len += oal_util_snprintf(buf + len, size - len, "RX_OCTET_COUNT_GOOD                : 0x%x\n", reg);
+			seq_printf(seq,  "RX_OCTET_COUNT_GOOD                : 0x%x\n", reg);
 			reg = hal_read32(base_va + RX_OCTET_COUNT_GOOD_BAD);
-			len += oal_util_snprintf(buf + len, size - len, "RX_OCTET_COUNT_GOOD_BAD            : 0x%x\n", reg);
+			seq_printf(seq,  "RX_OCTET_COUNT_GOOD_BAD            : 0x%x\n", reg);
 			reg = hal_read32(base_va + RX_64OCTETS_PACKETS_GOOD_BAD);
-			len += oal_util_snprintf(buf + len, size - len, "RX_64OCTETS_PACKETS_GOOD_BAD       : 0x%x\n", reg);
+			seq_printf(seq,  "RX_64OCTETS_PACKETS_GOOD_BAD       : 0x%x\n", reg);
 			reg = hal_read32(base_va + RX_65TO127OCTETS_PACKETS_GOOD_BAD);
-			len += oal_util_snprintf(buf + len, size - len, "RX_65TO127OCTETS_PACKETS_GOOD_BAD  : 0x%x\n", reg);
+			seq_printf(seq,  "RX_65TO127OCTETS_PACKETS_GOOD_BAD  : 0x%x\n", reg);
 			reg = hal_read32(base_va + RX_128TO255OCTETS_PACKETS_GOOD_BAD);
-			len += oal_util_snprintf(buf + len, size - len, "RX_128TO255OCTETS_PACKETS_GOOD_BAD : 0x%x\n", reg);
+			seq_printf(seq,  "RX_128TO255OCTETS_PACKETS_GOOD_BAD : 0x%x\n", reg);
 			reg = hal_read32(base_va + RX_256TO511OCTETS_PACKETS_GOOD_BAD);
-			len += oal_util_snprintf(buf + len, size - len, "RX_256TO511OCTETS_PACKETS_GOOD_BAD : 0x%x\n", reg);
+			seq_printf(seq,  "RX_256TO511OCTETS_PACKETS_GOOD_BAD : 0x%x\n", reg);
 			reg = hal_read32(base_va + RX_512TO1023OCTETS_PACKETS_GOOD_BAD);
-			len += oal_util_snprintf(buf + len, size - len, "RX_512TO1023OCTETS_PACKETS_GOOD_BAD: 0x%x\n", reg);
+			seq_printf(seq,  "RX_512TO1023OCTETS_PACKETS_GOOD_BAD: 0x%x\n", reg);
 			reg = hal_read32(base_va + RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD);
-			len += oal_util_snprintf(buf + len, size - len, "RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD: 0x%x\n", reg);
+			seq_printf(seq,  "RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD: 0x%x\n", reg);
 		}
 
 		if(verb_level >= 5U)
 		{
 			reg = hal_read32(base_va + RX_OVERSIZE_PACKETS_GOOD);
-			len += oal_util_snprintf(buf + len, size - len, "RX_OSIZE_PACKETS_GOOD              : 0x%x\n", reg);
+			seq_printf(seq,  "RX_OSIZE_PACKETS_GOOD              : 0x%x\n", reg);
 			reg = hal_read32(base_va + RX_UNDERSIZE_PACKETS_GOOD);
-			len += oal_util_snprintf(buf + len, size - len, "RX_UNDERSIZE_PACKETS_GOOD          : 0x%x\n", reg);
+			seq_printf(seq,  "RX_UNDERSIZE_PACKETS_GOOD          : 0x%x\n", reg);
 		}
 	}
 
-	return len;
+	return 0;
 }
 
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
-
 /**
  * @brief		Get EMAC statistic in numeric form
  * @details		This is a HW-specific function providing single statistic
@@ -1763,8 +1713,3 @@ errno_t pfe_emac_cfg_isr(addr_t base_va, addr_t cbus_base)
 	return EOK;
 }
 
-#ifdef PFE_CFG_TARGET_OS_AUTOSAR
-#define ETH_43_PFE_STOP_SEC_CODE
-#include "Eth_43_PFE_MemMap.h"
-#endif /* PFE_CFG_TARGET_OS_AUTOSAR */
-
diff --git a/sw/pfe_platform/hw/s32g/pfe_emac_csr.h b/sw/pfe_platform/hw/s32g/pfe_emac_csr.h
index 497cee6..257bfdf 100644
--- a/sw/pfe_platform/hw/s32g/pfe_emac_csr.h
+++ b/sw/pfe_platform/hw/s32g/pfe_emac_csr.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -344,9 +344,7 @@ errno_t pfe_emac_cfg_mdio_read45(addr_t base_va, uint8_t pa, uint8_t dev, uint16
 errno_t pfe_emac_cfg_mdio_write22(addr_t base_va, uint8_t pa, uint8_t ra, uint16_t val);
 errno_t pfe_emac_cfg_mdio_write45(addr_t base_va, uint8_t pa, uint8_t dev, uint16_t ra, uint16_t val);
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-uint32_t pfe_emac_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, uint8_t verb_level);
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
+uint32_t pfe_emac_cfg_get_text_stat(addr_t base_va, struct seq_file *seq, uint8_t verb_level);
 
 uint32_t pfe_emac_cfg_get_tx_cnt(addr_t base_va);
 uint32_t pfe_emac_cfg_get_rx_cnt(addr_t base_va);
diff --git a/sw/pfe_platform/hw/s32g/pfe_gpi_csr.c b/sw/pfe_platform/hw/s32g/pfe_gpi_csr.c
index 4086166..cb1d14d 100644
--- a/sw/pfe_platform/hw/s32g/pfe_gpi_csr.c
+++ b/sw/pfe_platform/hw/s32g/pfe_gpi_csr.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -660,28 +660,23 @@ uint32_t pfe_gpi_cfg_shp_get_drop_cnt(addr_t base_va, uint8_t id)
 	return hal_read32(base_va + CSR_IGQOS_STAT_SHAPER_DROP_CNT(id));
 }
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-
 /**
  * @brief		Get GPI statistics in text form
  * @details		This is a HW-specific function providing detailed text statistics
  * 				about the GPI block.
  * @param[in]	base_va 	Base address of GPI register space (virtual)
- * @param[in]	buf 		Pointer to the buffer to write to
- * @param[in]	size 		Buffer length
+ * @param[in]	seq 		Pointer to debugfs seq_file
  * @param[in]	verb_level 	Verbosity level
  * @return		Number of bytes written to the buffer
  */
-uint32_t pfe_gpi_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, uint8_t verb_level)
+uint32_t pfe_gpi_cfg_get_text_stat(addr_t base_va, struct seq_file *seq, uint8_t verb_level)
 {
-	uint32_t len = 0U;
 	uint32_t reg;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL_ADDR == base_va))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		len = 0U;
 	}
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
@@ -689,75 +684,73 @@ uint32_t pfe_gpi_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, u
 		/* Debug registers */
 		if(verb_level >= 10U)
 		{
-			len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_FIFO_DEBUG   : 0x%x\n", hal_read32(base_va + GPI_FIFO_DEBUG));
-			len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_TX_DBUG_REG1 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG1));
-			len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_TX_DBUG_REG2 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG2));
-			len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_TX_DBUG_REG3 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG3));
-			len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_TX_DBUG_REG4 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG4));
-			len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_TX_DBUG_REG5 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG5));
-			len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_TX_DBUG_REG6 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG6));
-			len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_RX_DBUG_REG1 : 0x%x\n", hal_read32(base_va + GPI_RX_DBUG_REG1));
-			len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_RX_DBUG_REG2 : 0x%x\n", hal_read32(base_va + GPI_RX_DBUG_REG2));
-			len += (uint32_t)oal_util_snprintf(buf + len, (size_t)size - len, "GPI_FIFO_STATUS  : 0x%x\n", hal_read32(base_va + GPI_FIFO_STATUS));
+			seq_printf(seq, "GPI_FIFO_DEBUG   : 0x%x\n", hal_read32(base_va + GPI_FIFO_DEBUG));
+			seq_printf(seq, "GPI_TX_DBUG_REG1 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG1));
+			seq_printf(seq, "GPI_TX_DBUG_REG2 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG2));
+			seq_printf(seq, "GPI_TX_DBUG_REG3 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG3));
+			seq_printf(seq, "GPI_TX_DBUG_REG4 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG4));
+			seq_printf(seq, "GPI_TX_DBUG_REG5 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG5));
+			seq_printf(seq, "GPI_TX_DBUG_REG6 : 0x%x\n", hal_read32(base_va + GPI_TX_DBUG_REG6));
+			seq_printf(seq, "GPI_RX_DBUG_REG1 : 0x%x\n", hal_read32(base_va + GPI_RX_DBUG_REG1));
+			seq_printf(seq, "GPI_RX_DBUG_REG2 : 0x%x\n", hal_read32(base_va + GPI_RX_DBUG_REG2));
+			seq_printf(seq, "GPI_FIFO_STATUS  : 0x%x\n", hal_read32(base_va + GPI_FIFO_STATUS));
 		}
 
 		/*	Get version */
 		if(verb_level >= 9U)
 		{
 			reg = hal_read32(base_va + GPI_VERSION);
-			len += oal_util_snprintf(buf + len, (size_t)size - len, "Revision             : 0x%x\n", (reg >> 24) & 0xffU);
-			len += oal_util_snprintf(buf + len, (size_t)size - len, "Version              : 0x%x\n", (reg >> 16) & 0xffU);
-			len += oal_util_snprintf(buf + len, (size_t)size - len, "ID                   : 0x%x\n", reg & 0xffffU);
+			seq_printf(seq, "Revision             : 0x%x\n", (reg >> 24) & 0xffU);
+			seq_printf(seq, "Version              : 0x%x\n", (reg >> 16) & 0xffU);
+			seq_printf(seq, "ID                   : 0x%x\n", reg & 0xffffU);
 		}
 
 		/*	Ingress QoS counters */
 		reg = hal_read32(base_va + CSR_IGQOS_QUEUE_STATUS);
-		len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS queue status   : 0x%x\n", reg);
+		seq_printf(seq, "IGQOS queue status   : 0x%x\n", reg);
 		reg = hal_read32(base_va + CSR_IGQOS_STAT_CLASS_DROP_CNT);
-		len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS CLASS drop cnt : 0x%x\n", reg);
+		seq_printf(seq, "IGQOS CLASS drop cnt : 0x%x\n", reg);
 		reg = hal_read32(base_va + CSR_IGQOS_STAT_LMEM_QUEUE_DROP_CNT);
-		len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS LMEM drop cnt  : 0x%x\n", reg);
+		seq_printf(seq, "IGQOS LMEM drop cnt  : 0x%x\n", reg);
 		reg = hal_read32(base_va + CSR_IGQOS_STAT_DMEM_QUEUE_DROP_CNT);
-		len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS DMEM drop cnt  : 0x%x\n", reg);
+		seq_printf(seq, "IGQOS DMEM drop cnt  : 0x%x\n", reg);
 		reg = hal_read32(base_va + CSR_IGQOS_STAT_RXF_QUEUE_DROP_CNT);
-		len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS RXF drop cnt   : 0x%x\n", reg);
+		seq_printf(seq, "IGQOS RXF drop cnt   : 0x%x\n", reg);
 		reg = pfe_gpi_cfg_shp_get_drop_cnt(base_va, 0);
-		len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS SHP0 drop cnt  : 0x%x\n", reg);
+		seq_printf(seq, "IGQOS SHP0 drop cnt  : 0x%x\n", reg);
 		reg = pfe_gpi_cfg_shp_get_drop_cnt(base_va, 1);
-		len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS SHP1 drop cnt  : 0x%x\n", reg);
+		seq_printf(seq, "IGQOS SHP1 drop cnt  : 0x%x\n", reg);
 		reg = hal_read32(base_va + CSR_IGQOS_STAT_MANAGED_PACKET_CNT);
-		len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS managed pkts   : 0x%x\n", reg);
+		seq_printf(seq, "IGQOS managed pkts   : 0x%x\n", reg);
 		reg = hal_read32(base_va + CSR_IGQOS_STAT_UNMANAGED_PACKET_CNT);
-		len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS unmanaged pkts : 0x%x\n", reg);
+		seq_printf(seq, "IGQOS unmanaged pkts : 0x%x\n", reg);
 		reg = hal_read32(base_va + CSR_IGQOS_STAT_RESERVED_PACKET_CNT);
-		len += oal_util_snprintf(buf + len, (size_t)size - len, "IGQOS reserved pkts  : 0x%x\n", reg);
+		seq_printf(seq, "IGQOS reserved pkts  : 0x%x\n", reg);
 
 		reg = hal_read32(base_va + GPI_FIFO_STATUS);
-		len += oal_util_snprintf(buf + len, (size_t)size - len, "TX Underrun          : 0x%x\n", reg);
+		seq_printf(seq, "TX Underrun          : 0x%x\n", reg);
 		hal_write32(0, base_va + GPI_FIFO_STATUS);
 
 		reg = hal_read32(base_va + GPI_FIFO_DEBUG);
-		len += oal_util_snprintf(buf + len, (size_t)size - len, "TX FIFO Packets      : 0x%x\n", reg & 0x1fU);
-		len += oal_util_snprintf(buf + len, (size_t)size - len, "RX FIFO Packets      : 0x%x\n", (reg >> 6) & 0x1fU);
-		len += oal_util_snprintf(buf + len, (size_t)size - len, "TX FIFO Level        : 0x%x\n", (reg >> 12) & 0xffU);
-		len += oal_util_snprintf(buf + len, (size_t)size - len, "RX FIFO Level        : 0x%x\n", (reg >> 20) & 0xffU);
+		seq_printf(seq, "TX FIFO Packets      : 0x%x\n", reg & 0x1fU);
+		seq_printf(seq, "RX FIFO Packets      : 0x%x\n", (reg >> 6) & 0x1fU);
+		seq_printf(seq, "TX FIFO Level        : 0x%x\n", (reg >> 12) & 0xffU);
+		seq_printf(seq, "RX FIFO Level        : 0x%x\n", (reg >> 20) & 0xffU);
 
 		reg = hal_read32(base_va + GPI_DTX_ASEQ);
-		len += oal_util_snprintf(buf + len, (size_t)size - len, "ASEQ Length          : 0x%x\n", reg);
+		seq_printf(seq, "ASEQ Length          : 0x%x\n", reg);
 
 		reg = hal_read32(base_va + GPI_EMAC_1588_TIMESTAMP_EN);
-		len += oal_util_snprintf(buf + len, (size_t)size - len, "1588 Enable register : 0x%x\n", reg);
+		seq_printf(seq, "1588 Enable register : 0x%x\n", reg);
 
 		reg = hal_read32(base_va + GPI_OVERRUN_DROPCNT);
-		len += oal_util_snprintf(buf + len, (size_t)size - len, "Overrun Drop Counter : 0x%x\n", reg);
+		seq_printf(seq, "Overrun Drop Counter : 0x%x\n", reg);
 		hal_write32(0, base_va + GPI_OVERRUN_DROPCNT);
 	}
 
-	return len;
+	return 0;
 }
 
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
-
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
 #include "Eth_43_PFE_MemMap.h"
diff --git a/sw/pfe_platform/hw/s32g/pfe_gpi_csr.h b/sw/pfe_platform/hw/s32g/pfe_gpi_csr.h
index 66d58f9..b2e5663 100644
--- a/sw/pfe_platform/hw/s32g/pfe_gpi_csr.h
+++ b/sw/pfe_platform/hw/s32g/pfe_gpi_csr.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -319,9 +319,7 @@ void pfe_gpi_cfg_shp_set_limits(addr_t base_va, uint8_t id, uint32_t max_credit,
 void pfe_gpi_cfg_shp_get_limits(addr_t base_va, uint8_t id, uint32_t *max_credit, uint32_t *min_credit);
 uint32_t pfe_gpi_cfg_shp_get_drop_cnt(addr_t base_va, uint8_t id);
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-uint32_t pfe_gpi_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, uint8_t verb_level);
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
+uint32_t pfe_gpi_cfg_get_text_stat(addr_t base_va, struct seq_file *seq, uint8_t verb_level);
 
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
diff --git a/sw/pfe_platform/hw/s32g/pfe_hif_csr.c b/sw/pfe_platform/hw/s32g/pfe_hif_csr.c
index cd85fc1..dc809e1 100644
--- a/sw/pfe_platform/hw/s32g/pfe_hif_csr.c
+++ b/sw/pfe_platform/hw/s32g/pfe_hif_csr.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -1060,41 +1060,36 @@ uint32_t pfe_hif_chnl_cfg_ltc_get(addr_t base_va, uint32_t channel_id)
  * 				about a HIF channel.
  * @param[in]	base_va 	Base address of channel register space (virtual)
  * @param[in]	channel_id 	Channel identifier
- * @param[in]	buf 		Pointer to the buffer to write to
- * @param[in]	size 		Buffer length
+ * @param[in]	seq 		Pointer to debugfs seq_file
  * @param[in]	verb_level 	Verbosity level number of data written to the buffer (0:less 1:more)
  * @return		Number of bytes written to the buffer
  */
-uint32_t pfe_hif_chnl_cfg_get_text_stat(addr_t base_va, uint32_t channel_id, char_t *buf, uint32_t size, uint8_t verb_level)
+uint32_t pfe_hif_chnl_cfg_get_text_stat(addr_t base_va, uint32_t channel_id, struct seq_file *seq, uint8_t verb_level)
 {
-	/*	Fill the buffer with runtime data */
-	uint32_t len = 0U;
 	uint32_t reg;
 
-	(void)verb_level;
-
-	len += oal_util_snprintf(buf + len, size - len, "[CHANNEL %d]\n", channel_id);
+	seq_printf(seq, "[CHANNEL %d]\n", channel_id);
 	reg = hal_read32(base_va + HIF_RX_STATUS_0_CHn(channel_id));
-	len += oal_util_snprintf(buf + len, size - len, "HIF_RX_STATUS_0           : 0x%x\n", reg);
+	seq_printf(seq, "HIF_RX_STATUS_0           : 0x%x\n", reg);
 	reg = hal_read32(base_va + HIF_RX_DMA_STATUS_0_CHn(channel_id));
-	len += oal_util_snprintf(buf + len, size - len, "HIF_RX_DMA_STATUS_0       : 0x%x\n", reg);
+	seq_printf(seq, "HIF_RX_DMA_STATUS_0       : 0x%x\n", reg);
 	reg = hal_read32(base_va + HIF_RX_PKT_CNT0_CHn(channel_id));
-	len += oal_util_snprintf(buf + len, size - len, "HIF_RX_PKT_CNT0           : 0x%x\n", reg);
+	seq_printf(seq, "HIF_RX_PKT_CNT0           : 0x%x\n", reg);
 	reg = hal_read32(base_va + HIF_RX_PKT_CNT1_CHn(channel_id));
-	len += oal_util_snprintf(buf + len, size - len, "HIF_RX_PKT_CNT1           : 0x%x\n", reg);
+	seq_printf(seq, "HIF_RX_PKT_CNT1           : 0x%x\n", reg);
 
 	reg = hal_read32(base_va + HIF_TX_STATUS_0_CHn(channel_id));
-	len += oal_util_snprintf(buf + len, size - len, "HIF_TX_STATUS_0           : 0x%x\n", reg);
+	seq_printf(seq, "HIF_TX_STATUS_0           : 0x%x\n", reg);
 	reg = hal_read32(base_va + HIF_TX_STATUS_1_CHn(channel_id));
-	len += oal_util_snprintf(buf + len, size - len, "HIF_TX_STATUS_1           : 0x%x\n", reg);
+	seq_printf(seq, "HIF_TX_STATUS_1           : 0x%x\n", reg);
 	reg = hal_read32(base_va + HIF_TX_DMA_STATUS_0_CHn(channel_id));
-	len += oal_util_snprintf(buf + len, size - len, "HIF_TX_DMA_STATUS_0       : 0x%x\n", reg);
+	seq_printf(seq, "HIF_TX_DMA_STATUS_0       : 0x%x\n", reg);
 	reg = hal_read32(base_va + HIF_TX_PKT_CNT0_CHn(channel_id));
-	len += oal_util_snprintf(buf + len, size - len, "HIF_TX_PKT_CNT0           : 0x%x\n", reg);
+	seq_printf(seq, "HIF_TX_PKT_CNT0           : 0x%x\n", reg);
 	reg = hal_read32(base_va + HIF_TX_PKT_CNT1_CHn(channel_id));
-	len += oal_util_snprintf(buf + len, size - len, "HIF_TX_PKT_CNT1           : 0x%x\n", reg);
+	seq_printf(seq, "HIF_TX_PKT_CNT1           : 0x%x\n", reg);
 
-	return len;
+	return 0;
 }
 
 /**
diff --git a/sw/pfe_platform/hw/s32g/pfe_hif_csr.h b/sw/pfe_platform/hw/s32g/pfe_hif_csr.h
index 837a1a9..3092982 100644
--- a/sw/pfe_platform/hw/s32g/pfe_hif_csr.h
+++ b/sw/pfe_platform/hw/s32g/pfe_hif_csr.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -285,10 +285,8 @@ bool_t pfe_hif_chnl_cfg_is_tx_bdp_fifo_empty(addr_t base_va, uint32_t channel_id
 errno_t pfe_hif_chnl_cfg_set_rx_irq_coalesce(addr_t base_va, uint32_t channel_id, uint32_t frames, uint32_t cycles);
 errno_t pfe_hif_chnl_cfg_get_rx_irq_coalesce(addr_t base_va, uint32_t channel_id, uint32_t *frames, uint32_t *cycles);
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-uint32_t pfe_hif_chnl_cfg_get_text_stat(addr_t base_va, uint32_t channel_id, char_t *buf, uint32_t size, uint8_t verb_level);
+uint32_t pfe_hif_chnl_cfg_get_text_stat(addr_t base_va, uint32_t channel_id, struct seq_file *seq, uint8_t verb_level);
 uint32_t pfe_hif_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, uint8_t verb_level);
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
 
 uint32_t pfe_hif_chnl_cfg_get_tx_cnt(addr_t base_va, uint32_t channel_id);
 uint32_t pfe_hif_chnl_cfg_get_rx_cnt(addr_t base_va, uint32_t channel_id);
diff --git a/sw/pfe_platform/hw/s32g/pfe_platform_master.c b/sw/pfe_platform/hw/s32g/pfe_platform_master.c
index ce699e1..76c38b8 100644
--- a/sw/pfe_platform/hw/s32g/pfe_platform_master.c
+++ b/sw/pfe_platform/hw/s32g/pfe_platform_master.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -2409,7 +2409,7 @@ static errno_t pfe_platform_create_rtable(pfe_platform_t *platform, const pfe_pl
 
 		if (TRUE == in_lmem && FALSE == pfe_feature_mgr_is_available(PFE_HW_FEATURE_RUN_ON_G3))
 		{
-			NXP_LOG_WARNING("'g3_rtable_in_lmem' works only on S32G3, ignore option\n");
+			NXP_LOG_DEBUG("'g3_rtable_in_lmem' works only on S32G3, ignore option\n");
 			in_lmem = FALSE;
 		}
 
@@ -2609,6 +2609,32 @@ static void pfe_platform_destroy_util(pfe_platform_t *platform)
 	}
 }
 
+/**
+ * @brief		Validate IEEE1588 timestamp sharing between MACs
+ */
+static errno_t pfe_platform_validate_emac_ts_sharing(pfe_platform_t *platform, const pfe_platform_config_t *config)
+{
+	errno_t ret = EOK;
+
+	/* Validate configuration of timestamp sharing between MACs */
+	/* Check if EMAC0 timestamping is shared from GMAC */
+	if (0U != ((1 << PFE_PHY_IF_ID_EMAC0) & config->emac_ext_ts_mask)) {
+		/* In this case both EMAC1 and EMAC2 must have internal timebase */
+		if (0U != (((1 << PFE_PHY_IF_ID_EMAC1) | (1 << PFE_PHY_IF_ID_EMAC2)) & config->emac_ext_ts_mask)) {
+			NXP_LOG_ERROR("Invalid configuration (bitmap: %u) of timestamp sharing between MACs\n", config->emac_ext_ts_mask);
+			ret = EINVAL;
+		}
+	}
+
+	if (EOK == ret)
+	{
+		platform->emac_ext_ts_mask = config->emac_ext_ts_mask;
+		NXP_LOG_INFO("EMAC timestamp external mode bitmap: %u\n", platform->emac_ext_ts_mask);
+	}
+
+	return ret;
+}
+
 /**
  * @brief		Assign EMAC to the platform
  */
@@ -2625,30 +2651,34 @@ static errno_t pfe_platform_create_emac(pfe_platform_t *platform, const pfe_plat
 	}
 	else
 	{
+		ret = pfe_platform_validate_emac_ts_sharing(platform, config);
 
-		/*	EMAC1 */
-		platform->emac[0] = pfe_emac_create(platform->cbus_baseaddr, CBUS_EMAC1_BASE_ADDR,
-								config->emac_mode[0], EMAC_SPEED_1000_MBPS, EMAC_DUPLEX_FULL);
-		if (NULL == platform->emac[0])
-		{
-			NXP_LOG_ERROR("Couldn't create EMAC1 instance\n");
-			ret = ENODEV;
-		}
-		else
+		/*  EMAC1 */
+		if (EOK == ret)
 		{
-			(void)pfe_emac_set_max_frame_length(platform->emac[0], 1522);
-			pfe_emac_enable_rx_flow_control(platform->emac[0]);
-			pfe_emac_enable_broadcast(platform->emac[0]);
-
-#ifdef PFE_CFG_IEEE1588_SUPPORT
-			if (EOK != pfe_emac_enable_ts(platform->emac[0],
-					PFE_CFG_IEEE1588_I_CLK_HZ, PFE_CFG_IEEE1588_EMAC0_O_CLK_HZ))
+			platform->emac[0] = pfe_emac_create(platform->cbus_baseaddr, CBUS_EMAC1_BASE_ADDR,
+									config->emac_mode[0], EMAC_SPEED_1000_MBPS, EMAC_DUPLEX_FULL);
+			if (NULL == platform->emac[0])
 			{
-				NXP_LOG_WARNING("EMAC0: Could not configure the timestamping unit\n");
+				NXP_LOG_ERROR("Couldn't create EMAC1 instance\n");
+				ret = ENODEV;
 			}
+			else
+			{
+				(void)pfe_emac_set_max_frame_length(platform->emac[0], 1522);
+				pfe_emac_enable_rx_flow_control(platform->emac[0]);
+				pfe_emac_enable_broadcast(platform->emac[0]);
+
+#ifdef PFE_CFG_IEEE1588_SUPPORT
+				if (EOK != pfe_emac_enable_ts(platform->emac[0],
+						PFE_CFG_IEEE1588_I_CLK_HZ, PFE_CFG_IEEE1588_EMAC0_O_CLK_HZ))
+				{
+					NXP_LOG_WARNING("EMAC0: Could not configure the timestamping unit\n");
+				}
 #endif /* PFE_CFG_IEEE1588_SUPPORT */
 
-			/*	MAC address will be added with phy/log interface */
+				/*	MAC address will be added with phy/log interface */
+			}
 		}
 
 		/*	EMAC2 */
@@ -3557,6 +3587,22 @@ errno_t pfe_platform_soft_reset(const pfe_platform_t *platform)
 	return ret;
 }
 
+/**
+ * @brief   Print PFE FW features available on this target. For debug purposes only.
+ */
+static void pfe_platform_print_features(void)
+{
+	const char *feature_name;
+	errno_t ret;
+
+	ret = pfe_feature_mgr_get_first(&feature_name);
+	while (EOK == ret)
+	{
+		NXP_LOG_INFO("FW feature: %s\n", feature_name);
+		ret = pfe_feature_mgr_get_next(&feature_name);
+	}
+}
+
 /**
  * @brief	The platform init function
  * @details	Initializes the PFE HW platform and prepares it for usage according to configuration.
@@ -3705,6 +3751,9 @@ errno_t pfe_platform_init(const pfe_platform_config_t *config)
 		goto exit;
 	}
 
+	/* Log names of all available FW feaures */
+	pfe_platform_print_features();
+
 	/*	GPI */
 	ret = pfe_platform_create_gpi(&pfe, config);
 	if (EOK != ret)
@@ -4007,6 +4056,95 @@ errno_t pfe_platform_get_fw_versions(const pfe_platform_t *platform, pfe_ct_vers
 	return EOK;
 }
 
+/**
+ * @brief               Return FW versions and features in text form
+ * @details             Function writes formatted text into given buffer.
+ * @param[in]   pfe		Pointer to Platform instance
+ * @param[in]   seq		Pointer to debugfs seq_file
+ * @param[in]   verb_level      Verbosity level
+ * @return              Number of bytes written to the buffer
+ */
+uint32_t pfe_fw_features_get_text_statistics(const pfe_platform_t *pfe, struct seq_file *seq, uint8_t verb_level)
+{
+	errno_t ret;
+	const char *feature_name;
+	pfe_ct_version_t fw_ver;
+	uint8_t enabled;
+	(void)(verb_level);
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (unlikely(NULL == seq))
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+	}
+	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		if (NULL == pfe)
+		{
+			seq_printf(seq, "Can not get information - Platform not initialized\n");
+		}
+		else
+		{
+			seq_printf(seq, "[FIRMWARE VERSION]\n");
+			if (NULL == pfe->classifier)
+			{
+				seq_printf(seq, "Class\tFirmware not loaded\n");
+			}
+			else
+			{
+				ret = pfe_class_get_fw_version(pfe->classifier, &fw_ver);
+				if (EOK == ret)
+				{
+					seq_printf(seq, "Class\t%u.%u.%u (api:%.32s)\n",
+						fw_ver.major, fw_ver.minor, fw_ver.patch, fw_ver.cthdr);
+				}
+				else
+				{
+					seq_printf(seq, "Class\tUnable to get FW version\n");
+				}
+			}
+			if (NULL == pfe->util)
+			{
+				seq_printf(seq, "Util\tFirmware not loaded\n");
+			}
+			else
+			{
+				ret = pfe_util_get_fw_version(pfe->util, &fw_ver);
+				if (EOK == ret)
+				{
+					seq_printf(seq, "Util\t%u.%u.%u (api:%.32s)\n",
+						fw_ver.major, fw_ver.minor, fw_ver.patch, fw_ver.cthdr);
+				}
+				else
+				{
+					seq_printf(seq, "Util\tUnable to get FW version\n");
+				}
+			}
+
+			seq_printf(seq, "[FIRMWARE FEATURE]\n");
+			ret = pfe_feature_mgr_get_first(&feature_name);
+			if (EOK != ret)
+			{
+				seq_printf(seq, "Unable to query list of FW features\n");
+			}
+			while (EOK == ret)
+			{
+				ret = pfe_feature_mgr_get_val(feature_name, &enabled);
+				if (EOK == ret)
+				{
+					seq_printf(seq, "%s:\t%s\n", feature_name, enabled ? "ON" : "OFF");
+				}
+				else
+				{
+					seq_printf(seq, "%s:\tUnable to query feature state\n", feature_name);
+				}
+				ret = pfe_feature_mgr_get_next(&feature_name);
+			}
+		}
+	}
+	return 0U;
+}
+
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
 #include "Eth_43_PFE_MemMap.h"
diff --git a/sw/pfe_platform/hw/s32g/pfe_tmu_csr.c b/sw/pfe_platform/hw/s32g/pfe_tmu_csr.c
index 7ded40b..435aa7b 100644
--- a/sw/pfe_platform/hw/s32g/pfe_tmu_csr.c
+++ b/sw/pfe_platform/hw/s32g/pfe_tmu_csr.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -1822,22 +1822,18 @@ uint8_t pfe_tmu_sch_cfg_get_bound_sched_output(addr_t cbus_base_va, pfe_ct_phy_i
 	return sched_id;
 }
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-
 /**
  * @brief		Get TMU statistics in text form
  * @details		This is a HW-specific function providing detailed text statistics
  * 				about the TMU block.
  * @param[in]	base_va 	Base address of TMU register space (virtual)
- * @param[in]	buf 		Pointer to buffer to be written
- * @param[in]	size 		Buffer length
+ * @param[in]	seq 		Pointer to debugfs seq_file
  * @param[in]	verb_level 	Verbosity level
  *
  * @return		Number of bytes written to the buffer
  */
-uint32_t pfe_tmu_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, uint8_t verb_level)
+uint32_t pfe_tmu_cfg_get_text_stat(addr_t base_va, struct seq_file *seq, uint8_t verb_level)
 {
-	uint32_t len = 0U;
 	uint32_t reg, ii;
 	uint8_t prob, queue, zone;
 	uint32_t level, drops, tx;
@@ -1845,40 +1841,40 @@ uint32_t pfe_tmu_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, u
 	/* Debug registers */
 	if(verb_level >= 10U)
 	{
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "TMU_PHY_INQ_PKTPTR  : 0x%x\n", hal_read32(base_va + TMU_PHY_INQ_PKTPTR));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "TMU_PHY_INQ_PKTINFO : 0x%x\n", hal_read32(base_va + TMU_PHY_INQ_PKTINFO));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "TMU_PHY_INQ_STAT    : 0x%x\n", hal_read32(base_va + TMU_PHY_INQ_STAT));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "TMU_DBG_BUS_TOP     : 0x%x\n", hal_read32(base_va + TMU_DBG_BUS_TOP));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "TMU_DBG_BUS_PP0     : 0x%x\n", hal_read32(base_va + TMU_DBG_BUS_PP0));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "TMU_DBG_BUS_PP1     : 0x%x\n", hal_read32(base_va + TMU_DBG_BUS_PP1));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "TMU_DBG_BUS_PP2     : 0x%x\n", hal_read32(base_va + TMU_DBG_BUS_PP2));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "TMU_DBG_BUS_PP3     : 0x%x\n", hal_read32(base_va + TMU_DBG_BUS_PP3));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "TMU_DBG_BUS_PP4     : 0x%x\n", hal_read32(base_va + TMU_DBG_BUS_PP4));
-		len += (uint32_t)oal_util_snprintf(buf + len, size - len, "TMU_DBG_BUS_PP5     : 0x%x\n", hal_read32(base_va + TMU_DBG_BUS_PP5));
+		seq_printf(seq, "TMU_PHY_INQ_PKTPTR  : 0x%x\n", hal_read32(base_va + TMU_PHY_INQ_PKTPTR));
+		seq_printf(seq, "TMU_PHY_INQ_PKTINFO : 0x%x\n", hal_read32(base_va + TMU_PHY_INQ_PKTINFO));
+		seq_printf(seq, "TMU_PHY_INQ_STAT    : 0x%x\n", hal_read32(base_va + TMU_PHY_INQ_STAT));
+		seq_printf(seq, "TMU_DBG_BUS_TOP     : 0x%x\n", hal_read32(base_va + TMU_DBG_BUS_TOP));
+		seq_printf(seq, "TMU_DBG_BUS_PP0     : 0x%x\n", hal_read32(base_va + TMU_DBG_BUS_PP0));
+		seq_printf(seq, "TMU_DBG_BUS_PP1     : 0x%x\n", hal_read32(base_va + TMU_DBG_BUS_PP1));
+		seq_printf(seq, "TMU_DBG_BUS_PP2     : 0x%x\n", hal_read32(base_va + TMU_DBG_BUS_PP2));
+		seq_printf(seq, "TMU_DBG_BUS_PP3     : 0x%x\n", hal_read32(base_va + TMU_DBG_BUS_PP3));
+		seq_printf(seq, "TMU_DBG_BUS_PP4     : 0x%x\n", hal_read32(base_va + TMU_DBG_BUS_PP4));
+		seq_printf(seq, "TMU_DBG_BUS_PP5     : 0x%x\n", hal_read32(base_va + TMU_DBG_BUS_PP5));
 	}
 
 	if(verb_level >= 9U)
 	{
 		/*	Get version */
 		reg = hal_read32(base_va + TMU_VERSION);
-		len += oal_util_snprintf(buf + len, size - len, "Revision             : 0x%x\n", (reg >> 24) & 0xffU);
-		len += oal_util_snprintf(buf + len, size - len, "Version              : 0x%x\n", (reg >> 16) & 0xffU);
-		len += oal_util_snprintf(buf + len, size - len, "ID                   : 0x%x\n", reg & 0xffffU);
+		seq_printf(seq, "Revision             : 0x%x\n", (reg >> 24) & 0xffU);
+		seq_printf(seq, "Version              : 0x%x\n", (reg >> 16) & 0xffU);
+		seq_printf(seq, "ID                   : 0x%x\n", reg & 0xffffU);
 	}
 
 	reg = hal_read32(base_va + TMU_CTRL);
-	len += oal_util_snprintf(buf + len, size - len, "TMU_CTRL             : 0x%x\n", reg);
+	seq_printf(seq, "TMU_CTRL             : 0x%x\n", reg);
 	reg = hal_read32(base_va + TMU_PHY_INQ_STAT);
-	len += oal_util_snprintf(buf + len, size - len, "TMU_PHY_INQ_STAT     : 0x%x\n", reg);
+	seq_printf(seq, "TMU_PHY_INQ_STAT     : 0x%x\n", reg);
 	reg = hal_read32(base_va + TMU_PHY_INQ_PKTPTR);
-	len += oal_util_snprintf(buf + len, size - len, "TMU_PHY_INQ_PKTPTR   : 0x%x\n", reg);
+	seq_printf(seq, "TMU_PHY_INQ_PKTPTR   : 0x%x\n", reg);
 	reg = hal_read32(base_va + TMU_PHY_INQ_PKTINFO);
-	len += oal_util_snprintf(buf + len, size - len, "TMU_PHY_INQ_PKTINFO  : 0x%x\n", reg);
+	seq_printf(seq, "TMU_PHY_INQ_PKTINFO  : 0x%x\n", reg);
 
 	/*	Print per-queue statistics */
 	for (ii=0U; ii < TLITE_PHYS_CNT; ii++)
 	{
-		len += oal_util_snprintf(buf + len, size - len, "[PHY: %d]\n", (int_t)ii);
+		seq_printf(seq, "[PHY: %d]\n", (int_t)ii);
 		for (queue=0U; queue<TLITE_PHY_QUEUES_CNT; queue++)
 		{
 			/*	Fill level */
@@ -1896,7 +1892,7 @@ uint32_t pfe_tmu_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, u
 				continue;
 			}
 
-			len += oal_util_snprintf(buf + len, size - len, "  [QUEUE: %d]\n", queue);
+			seq_printf(seq, "  [QUEUE: %d]\n", queue);
 
 			/*	curQ_cfg is @ position 4 per queue */
 			if (EOK != pfe_tmu_cntx_mem_read(base_va, phy_if_id_temp[ii], (8U * queue) + 4U, &reg))
@@ -1910,28 +1906,28 @@ uint32_t pfe_tmu_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, u
 			{
 				case 0x0U:
 				{
-					len += oal_util_snprintf(buf + len, size - len, "    Mode       : Default\n");
+					seq_printf(seq, "    Mode       : Default\n");
 					break;
 				}
 
 				case 0x1U:
 				{
-					len += oal_util_snprintf(buf + len, size - len, "    Mode       : Tail drop (max: %d)\n", (reg >> 11) & 0x1ffU);
+					seq_printf(seq, "    Mode       : Tail drop (max: %d)\n", (reg >> 11) & 0x1ffU);
 					break;
 				}
 
 				case 0x2U:
 				{
-					len += oal_util_snprintf(buf + len, size - len, "    Mode       : WRED (max: %d, min: %d)\n", (reg >> 11) & 0x1ffU, (reg >> 2) & 0x1ffU);
+					seq_printf(seq, "    Mode       : WRED (max: %d, min: %d)\n", (reg >> 11) & 0x1ffU, (reg >> 2) & 0x1ffU);
 					for (zone=0U; zone<pfe_tmu_q_get_wred_zones(base_va, phy_if_id_temp[ii], queue); zone++)
 					{
 						if (EOK != pfe_tmu_q_get_wred_probability(base_va, phy_if_id_temp[ii], queue, zone, &prob))
 						{
-							len += oal_util_snprintf(buf + len, size - len, "      Zone %d   : ERROR\n", zone);
+							seq_printf(seq, "      Zone %d   : ERROR\n", zone);
 						}
 						else
 						{
-							len += oal_util_snprintf(buf + len, size - len, "      Zone %d   : %d\n", zone, prob);
+							seq_printf(seq, "      Zone %d   : %d\n", zone, prob);
 						}
 					}
 
@@ -1940,21 +1936,19 @@ uint32_t pfe_tmu_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, u
 
 				default:
 				{
-					len += oal_util_snprintf(buf + len, size - len, "    Mode       : ERROR\n");
+					seq_printf(seq, "    Mode       : ERROR\n");
 					break;
 				}
 			}
 
-			len += oal_util_snprintf(buf + len, size - len, "    Fill level : % 8d Drops: % 8d, TX: % 8d\n", level, drops, tx);
+			seq_printf(seq, "    Fill level : % 8d Drops: % 8d, TX: % 8d\n", level, drops, tx);
 		}
 	}
 
 
-	return len;
+	return 0;
 }
 
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
-
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
 #include "Eth_43_PFE_MemMap.h"
diff --git a/sw/pfe_platform/hw/s32g/pfe_tmu_csr.h b/sw/pfe_platform/hw/s32g/pfe_tmu_csr.h
index 5deb3bd..360456c 100644
--- a/sw/pfe_platform/hw/s32g/pfe_tmu_csr.h
+++ b/sw/pfe_platform/hw/s32g/pfe_tmu_csr.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -264,9 +264,7 @@ void pfe_tmu_cfg_reset(addr_t cbus_base_va);
 void pfe_tmu_cfg_enable(addr_t cbus_base_va);
 void pfe_tmu_cfg_disable(addr_t cbus_base_va);
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-uint32_t pfe_tmu_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, uint8_t verb_level);
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
+uint32_t pfe_tmu_cfg_get_text_stat(addr_t base_va, struct seq_file *seq, uint8_t verb_level);
 
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
diff --git a/sw/pfe_platform/hw/s32g/pfe_util_csr.c b/sw/pfe_platform/hw/s32g/pfe_util_csr.c
index d0bbe18..f364da4 100644
--- a/sw/pfe_platform/hw/s32g/pfe_util_csr.c
+++ b/sw/pfe_platform/hw/s32g/pfe_util_csr.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -18,27 +18,23 @@
 #include "Eth_43_PFE_MemMap.h"
 #endif /* PFE_CFG_TARGET_OS_AUTOSAR */
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-
 /**
  * @brief		Get UTIL statistics in text form
  * @details		This is a HW-specific function providing detailed text statistics
  * 				about the UTIL block.
  * @param[in]	base_va 	Base address of UTIL register space (virtual)
- * @param[in]	buf 		Pointer to the buffer to write to
- * @param[in]	size 		Buffer length
+ * @param[in]	seq 		Pointer to debugfs seq_file
  * @param[in]	verb_level 	Verbosity level
  * @return		Number of bytes written to the buffer
  */
-uint32_t pfe_util_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, uint8_t verb_level)
+uint32_t pfe_util_cfg_get_text_stat(addr_t base_va, struct seq_file *seq, uint8_t verb_level)
 {
-	uint32_t len = 0U, reg;
+	uint32_t reg;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL_ADDR == base_va))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		len = 0U;
 	}
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
@@ -47,19 +43,17 @@ uint32_t pfe_util_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size,
 		if(verb_level >= 9U)
 		{
 			reg = hal_read32(base_va + UTIL_VERSION);
-			len += oal_util_snprintf(buf + len, size - len, "Revision             : 0x%x\n", (reg >> 24U) & 0xffU);
-			len += oal_util_snprintf(buf + len, size - len, "Version              : 0x%x\n", (reg >> 16U) & 0xffU);
-			len += oal_util_snprintf(buf + len, size - len, "ID                   : 0x%x\n", reg & 0xffffU);
+			seq_printf(seq, "Revision             : 0x%x\n", (reg >> 24U) & 0xffU);
+			seq_printf(seq, "Version              : 0x%x\n", (reg >> 16U) & 0xffU);
+			seq_printf(seq, "ID                   : 0x%x\n", reg & 0xffffU);
 		}
 
-		len += oal_util_snprintf(buf + len, size - len, "Max buffer count\t0x%08x\n", hal_read32(base_va + UTIL_MAX_BUF_CNT));
-		len += oal_util_snprintf(buf + len, size - len, "TQS max count\t\t0x%08x\n", hal_read32(base_va + UTIL_TSQ_MAX_CNT));
+		seq_printf(seq, "Max buffer count\t0x%08x\n", hal_read32(base_va + UTIL_MAX_BUF_CNT));
+		seq_printf(seq, "TQS max count\t\t0x%08x\n", hal_read32(base_va + UTIL_TSQ_MAX_CNT));
 	}
-	return len;
+	return 0;
 }
 
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
-
 /**
  * @brief		Dispatch interrupt from util.
  * @details		ACK and process triggered interrupts.
diff --git a/sw/pfe_platform/hw/s32g/pfe_util_csr.h b/sw/pfe_platform/hw/s32g/pfe_util_csr.h
index f465402..7da7b07 100644
--- a/sw/pfe_platform/hw/s32g/pfe_util_csr.h
+++ b/sw/pfe_platform/hw/s32g/pfe_util_csr.h
@@ -2,7 +2,7 @@
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
  *  Copyright 2015-2016 Freescale Semiconductor, Inc.
- *  Copyright 2017-2022 NXP
+ *  Copyright 2017-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -61,9 +61,7 @@
 #include "Eth_43_PFE_MemMap.h"
 #endif /* PFE_CFG_TARGET_OS_AUTOSAR */
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-uint32_t pfe_util_cfg_get_text_stat(addr_t base_va, char_t *buf, uint32_t size, uint8_t verb_level);
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
+uint32_t pfe_util_cfg_get_text_stat(addr_t base_va, struct seq_file *seq, uint8_t verb_level);
 
 errno_t pfe_util_cfg_isr(addr_t base_va);
 
diff --git a/sw/pfe_platform/public/pfe_bmu.h b/sw/pfe_platform/public/pfe_bmu.h
index fedfb2f..c4ac3c0 100644
--- a/sw/pfe_platform/public/pfe_bmu.h
+++ b/sw/pfe_platform/public/pfe_bmu.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -42,9 +42,7 @@ void *pfe_bmu_get_pa(const pfe_bmu_t *bmu, addr_t va) __attribute__((hot, pure))
 uint32_t pfe_bmu_get_buf_size(const pfe_bmu_t *bmu) __attribute__((cold, pure));
 void pfe_bmu_free_buf(const pfe_bmu_t *bmu, addr_t buffer) __attribute__((hot));
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-uint32_t pfe_bmu_get_text_statistics(const pfe_bmu_t *bmu, char_t *buf, uint32_t buf_len, uint8_t verb_level) __attribute__((cold));
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
+uint32_t pfe_bmu_get_text_statistics(const pfe_bmu_t *bmu, struct seq_file *seq, uint8_t verb_level) __attribute__((cold));
 
 void pfe_bmu_destroy(pfe_bmu_t *bmu) __attribute__((cold));
 #ifdef PFE_CFG_PFE_MASTER
diff --git a/sw/pfe_platform/public/pfe_class.h b/sw/pfe_platform/public/pfe_class.h
index c19dff9..58a3371 100644
--- a/sw/pfe_platform/public/pfe_class.h
+++ b/sw/pfe_platform/public/pfe_class.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -55,10 +55,8 @@ errno_t pfe_class_set_rtable(pfe_class_t *class, addr_t rtable_pa, uint32_t rtab
 errno_t pfe_class_set_default_vlan(const pfe_class_t *class, uint16_t vlan);
 uint32_t pfe_class_get_num_of_pes(const pfe_class_t *class);
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-uint32_t pfe_class_get_text_statistics(pfe_class_t *class, char_t *buf, uint32_t buf_len, uint8_t verb_level);
-uint32_t pfe_class_fp_stat_to_str(const pfe_ct_class_flexi_parser_stats_t *stat, char *buf, uint32_t buf_len, uint8_t verb_level);
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
+uint32_t pfe_class_get_text_statistics(pfe_class_t *class, struct seq_file *seq, uint8_t verb_level);
+uint32_t pfe_class_fp_stat_to_str(const pfe_ct_class_flexi_parser_stats_t *stat, struct seq_file *seq, uint8_t verb_level);
 
 void pfe_class_destroy(pfe_class_t *class);
 addr_t pfe_class_dmem_heap_alloc(const pfe_class_t *class, uint32_t size);
@@ -75,6 +73,7 @@ void pfe_class_sum_flexi_parser_stats(pfe_ct_class_flexi_parser_stats_t *sum, co
 errno_t pfe_class_get_stats(pfe_class_t *class, pfe_ct_classify_stats_t *stat);
 void pfe_class_rtable_lookup_enable(const pfe_class_t *class);
 void pfe_class_rtable_lookup_disable(const pfe_class_t *class);
+void pfe_class_update_hw_bridge_lookup(pfe_class_t *class, uint32_t if_bitmap, bool_t br_mode);
 
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
diff --git a/sw/pfe_platform/public/pfe_ct_comp.h b/sw/pfe_platform/public/pfe_ct_comp.h
index dc05f8f..10286cd 100644
--- a/sw/pfe_platform/public/pfe_ct_comp.h
+++ b/sw/pfe_platform/public/pfe_ct_comp.h
@@ -1,6 +1,6 @@
 /* =========================================================================
  *  
- *  Copyright 2022 NXP
+ *  Copyright 2022-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -28,4 +28,15 @@ typedef struct __attribute__((packed,aligned(4)))
 
 ct_assert(sizeof(pfe_ct_feature_desc_ext_t) == 24);
 
+typedef struct __attribute__((packed, aligned(4)))
+{
+	uint16_t vlan;                   /* VLAN value if applicable */
+	pfe_ct_vlan_table_result_t entry; /* Entry value - port map and other */
+	uint8_t field_valids;            /* see pfe_mac2f_table_entry_valid_bits_t */
+	uint8_t flags;                   /* see pfe_mac2f_table_entry_flags_t */
+	uint16_t col_ptr;		 /* Collision entry pointer */
+} l2br_vlan_hash_entry_t;
+
+ct_assert(sizeof(l2br_vlan_hash_entry_t) == 16);
+
 #endif /* HW_S32G_PFE_CT_COMP_H_ */
diff --git a/sw/pfe_platform/public/pfe_emac.h b/sw/pfe_platform/public/pfe_emac.h
index 3778c25..f4bf16c 100644
--- a/sw/pfe_platform/public/pfe_emac.h
+++ b/sw/pfe_platform/public/pfe_emac.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -13,6 +13,10 @@
 #include "pfe_ct.h"
 #include "pfe_gpi.h"
 
+#define PFE_EMAC_STD_MTU	1500U
+#define PFE_EMAC_JUMBO_MTU	9000U
+#define PFE_MIN_DSA_OVERHEAD	4U
+
 typedef enum
 {
 	EMAC_MODE_INVALID,
@@ -97,13 +101,6 @@ typedef enum __attribute__ ((packed)) {
 	EMAC_CRIT_INVALID,
 } pfe_emac_crit_t;
 
-#ifdef PFE_CFG_TARGET_OS_AUTOSAR
-#define ETH_43_PFE_START_SEC_CODE
-#include "Eth_43_PFE_MemMap.h"
-#endif /* PFE_CFG_TARGET_OS_AUTOSAR */
-
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-
 static inline const char_t *
 pfe_emac_mii_mode_to_str(pfe_emac_mii_mode_t mode)
 {
@@ -120,8 +117,6 @@ pfe_emac_mii_mode_to_str(pfe_emac_mii_mode_t mode)
 	}
 }
 
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
-
 /**
  * @brief		Check if given MAC address is zero
  * @param[in]	addr The address to check
@@ -236,9 +231,7 @@ errno_t pfe_emac_get_addr(pfe_emac_t *emac, pfe_mac_addr_t addr);
 errno_t pfe_emac_del_addr(pfe_emac_t *emac, const pfe_mac_addr_t addr, pfe_drv_id_t owner);
 void pfe_emac_destroy(pfe_emac_t *emac);
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-uint32_t pfe_emac_get_text_statistics(const pfe_emac_t *emac, char_t *buf, uint32_t buf_len, uint8_t verb_level);
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
+uint32_t pfe_emac_get_text_statistics(const pfe_emac_t *emac, struct seq_file *seq, uint8_t verb_level);
 
 uint32_t pfe_emac_get_rx_cnt(const pfe_emac_t *emac);
 uint32_t pfe_emac_get_tx_cnt(const pfe_emac_t *emac);
@@ -247,9 +240,4 @@ errno_t pfe_emac_isr(pfe_emac_t *emac);
 void pfe_emac_irq_mask(pfe_emac_t *emac);
 void pfe_emac_irq_unmask(pfe_emac_t *emac);
 
-#ifdef PFE_CFG_TARGET_OS_AUTOSAR
-#define ETH_43_PFE_STOP_SEC_CODE
-#include "Eth_43_PFE_MemMap.h"
-#endif /* PFE_CFG_TARGET_OS_AUTOSAR */
-
 #endif /* PUBLIC_PFE_EMAC_H_ */
diff --git a/sw/pfe_platform/public/pfe_gpi.h b/sw/pfe_platform/public/pfe_gpi.h
index 7681403..620a801 100644
--- a/sw/pfe_platform/public/pfe_gpi.h
+++ b/sw/pfe_platform/public/pfe_gpi.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -185,9 +185,7 @@ void pfe_gpi_enable(const pfe_gpi_t *gpi);
 errno_t pfe_gpi_reset(const pfe_gpi_t *gpi);
 void pfe_gpi_disable(const pfe_gpi_t *gpi);
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-uint32_t pfe_gpi_get_text_statistics(const pfe_gpi_t *gpi, char_t *buf, uint32_t buf_len, uint8_t verb_level);
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
+uint32_t pfe_gpi_get_text_statistics(const pfe_gpi_t *gpi, struct seq_file *seq, uint8_t verb_level);
 
 void pfe_gpi_destroy(pfe_gpi_t *gpi);
 uint32_t pfe_gpi_cfg_get_sys_clk_mhz(addr_t cbus_base_va);
diff --git a/sw/pfe_platform/public/pfe_hif_chnl_linux.h b/sw/pfe_platform/public/pfe_hif_chnl_linux.h
index b9b3801..1d5d58e 100644
--- a/sw/pfe_platform/public/pfe_hif_chnl_linux.h
+++ b/sw/pfe_platform/public/pfe_hif_chnl_linux.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -219,9 +219,10 @@ errno_t pfe_hif_chnl_set_rx_irq_coalesce(pfe_hif_chnl_t *chnl, uint32_t frames,
 bool_t pfe_hif_chnl_is_rx_dma_active(const pfe_hif_chnl_t *chnl) __attribute__((hot));
 bool_t pfe_hif_chnl_is_tx_dma_active(const pfe_hif_chnl_t *chnl) __attribute__((hot));
 uint32_t pfe_hif_chnl_get_id(const pfe_hif_chnl_t *chnl) __attribute__((pure, cold));
-uint32_t pfe_hif_chnl_dump_ring(const pfe_hif_chnl_t *chnl, bool_t dump_rx, bool_t dump_tx, char_t *buf, uint32_t size, uint8_t verb_level) __attribute__((cold));
-uint32_t pfe_hif_chnl_get_text_statistics(const pfe_hif_chnl_t *chnl, char_t *buf, uint32_t buf_len, uint8_t verb_level) __attribute__((cold));
+uint32_t pfe_hif_chnl_dump_ring(const pfe_hif_chnl_t *chnl, bool_t dump_rx, bool_t dump_tx, struct seq_file *seq, uint8_t verb_level) __attribute__((cold));
 uint32_t pfe_hif_chnl_get_tx_cnt(const pfe_hif_chnl_t *chnl);
 uint32_t pfe_hif_chnl_get_rx_cnt(const pfe_hif_chnl_t *chnl);
 
+uint32_t pfe_hif_chnl_get_text_statistics(const pfe_hif_chnl_t *chnl, struct seq_file *seq, uint8_t verb_level) __attribute__((cold));
+
 #endif /* PUBLIC_PFE_HIF_CHNL_H_ */
diff --git a/sw/pfe_platform/public/pfe_hif_ring_linux.h b/sw/pfe_platform/public/pfe_hif_ring_linux.h
index 8a95146..439cf92 100644
--- a/sw/pfe_platform/public/pfe_hif_ring_linux.h
+++ b/sw/pfe_platform/public/pfe_hif_ring_linux.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -25,6 +25,7 @@ errno_t pfe_hif_ring_drain_buf(pfe_hif_ring_t *ring, void **buf_pa) __attribute_
 bool_t pfe_hif_ring_is_below_wm(const pfe_hif_ring_t *ring) __attribute__((pure, hot));
 void pfe_hif_ring_invalidate(const pfe_hif_ring_t *ring) __attribute__((cold));
 uint32_t pfe_hif_ring_get_fill_level(const pfe_hif_ring_t *ring) __attribute__((pure, hot));
-uint32_t pfe_hif_ring_dump(pfe_hif_ring_t *ring, char_t *name, char_t *buf, uint32_t size, uint8_t verb_level);
+
+uint32_t pfe_hif_ring_dump(pfe_hif_ring_t *ring, char_t *name, struct seq_file *seq, uint8_t verb_level);
 
 #endif /* PUBLIC_PFE_HIF_RING_H_ */
diff --git a/sw/pfe_platform/public/pfe_hm.h b/sw/pfe_platform/public/pfe_hm.h
index 27b15fe..9b3b56a 100644
--- a/sw/pfe_platform/public/pfe_hm.h
+++ b/sw/pfe_platform/public/pfe_hm.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2022 NXP
+ *  Copyright 2022-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -10,13 +10,13 @@
 #ifndef PFE_HM_H
 #define PFE_HM_H
 
-#define PFE_HM_DESCRIPTION_MAX_LEN 128
+#define PFE_HM_DESCRIPTION_MAX_LEN 256
 #define PFE_HM_QUEUE_LEN 8
 
 typedef enum {
-	HM_INFO,
-	HM_WARNING,
-	HM_ERROR
+	HM_INFO = 0,
+	HM_WARNING = 1,
+	HM_ERROR = 2
 } pfe_hm_type_t;
 
 typedef enum {
@@ -139,25 +139,23 @@ typedef enum {
 } pfe_hm_evt_t;
 
 typedef enum {
-	HM_SRC_UNKNOWN,
-	HM_SRC_DRIVER,
-	HM_SRC_PFENG_DEV,
-	HM_SRC_PFENG_NETDEV,
-	HM_SRC_WDT,
-	HM_SRC_EMAC0,
-	HM_SRC_EMAC1,
-	HM_SRC_EMAC2,
-	HM_SRC_BUS,
-	HM_SRC_PARITY,
-	HM_SRC_FAIL_STOP,
-	HM_SRC_FW_FAIL_STOP,
-	HM_SRC_HOST_FAIL_STOP,
-	HM_SRC_ECC,
-	HM_SRC_PE_CLASS,
-	HM_SRC_PE_UTIL,
-	HM_SRC_PE_TMU,
-	HM_SRC_HIF,
-	HM_SRC_BMU,
+	HM_SRC_UNKNOWN = 0,
+	HM_SRC_DRIVER = 1,
+	HM_SRC_WDT = 2,
+	HM_SRC_EMAC0 = 3,
+	HM_SRC_EMAC1 = 4,
+	HM_SRC_EMAC2 = 5,
+	HM_SRC_BUS = 6,
+	HM_SRC_PARITY = 7,
+	HM_SRC_FAIL_STOP = 8,
+	HM_SRC_FW_FAIL_STOP = 9,
+	HM_SRC_HOST_FAIL_STOP = 10,
+	HM_SRC_ECC = 11,
+	HM_SRC_PE_CLASS = 12,
+	HM_SRC_PE_UTIL = 13,
+	HM_SRC_PE_TMU = 14,
+	HM_SRC_HIF = 15,
+	HM_SRC_BMU = 16,
 } pfe_hm_src_t;
 
 typedef struct {
@@ -173,7 +171,7 @@ typedef void (* pfe_hm_cb_t)(pfe_hm_item_t *item);
 
 errno_t pfe_hm_init(void);
 errno_t pfe_hm_destroy(void);
-void pfe_hm_report(pfe_hm_src_t src, pfe_hm_type_t type, pfe_hm_evt_t id, void *dev,
+void pfe_hm_report(pfe_hm_src_t src, pfe_hm_type_t type, pfe_hm_evt_t id, pfe_hm_log_t hm_log,
 		const char *format, ...);
 errno_t pfe_hm_get(pfe_hm_item_t *item);
 const char *pfe_hm_get_event_str(pfe_hm_evt_t id);
@@ -182,12 +180,25 @@ bool_t pfe_hm_register_event_cb(pfe_hm_cb_t cb);
 
 #define __FILENAME__ (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)
 
-#define pfe_hm_report_info(src, id, format, ...) pfe_hm_report((src), HM_INFO, (id), NULL,"[%s:%d] " format, __FILENAME__, __LINE__, ##__VA_ARGS__)
-#define pfe_hm_report_warning(src, id, format, ...) pfe_hm_report((src), HM_WARNING, (id), NULL, "[%s:%d] " format, __FILENAME__, __LINE__, ##__VA_ARGS__)
-#define pfe_hm_report_error(src, id, format, ...) pfe_hm_report((src), HM_ERROR, (id), NULL, "[%s:%d] " format, __FILENAME__, __LINE__, ##__VA_ARGS__)
-
-#define pfe_hm_report_dev_info(src, id, dev, format, ...) pfe_hm_report((src), HM_INFO, (id), dev,"[%s:%d] " format, __FILENAME__, __LINE__, ##__VA_ARGS__)
-#define pfe_hm_report_dev_warning(src, id, dev, format, ...) pfe_hm_report((src), HM_WARNING, (id), dev, "[%s:%d] " format, __FILENAME__, __LINE__, ##__VA_ARGS__)
-#define pfe_hm_report_dev_error(src, id, dev, format, ...) pfe_hm_report((src), HM_ERROR, (id), dev, "[%s:%d] " format, __FILENAME__, __LINE__, ##__VA_ARGS__)
+#define pfe_hm_report_info(src, id, format, ...) \
+	pfe_hm_report((src), HM_INFO, (id), (pfe_hm_log_t){.log_type = NXP_LOG_TYPE_PFE}, "[%s:%d] " format, __FILENAME__, __LINE__, ##__VA_ARGS__)
+#define pfe_hm_report_warning(src, id, format, ...) \
+	pfe_hm_report((src), HM_WARNING, (id), (pfe_hm_log_t){.log_type = NXP_LOG_TYPE_PFE}, "[%s:%d] " format, __FILENAME__, __LINE__, ##__VA_ARGS__)
+#define pfe_hm_report_error(src, id, format, ...) \
+	pfe_hm_report((src), HM_ERROR, (id), (pfe_hm_log_t){.log_type = NXP_LOG_TYPE_PFE}, "[%s:%d] " format, __FILENAME__, __LINE__, ##__VA_ARGS__)
+
+#define pfe_hm_report_dev_info(src, id, dev, format, ...) \
+	pfe_hm_report((src), HM_INFO, (id), (pfe_hm_log_t){.log_type = NXP_LOG_TYPE_DEV, .log_dev = dev}, "[%s:%d] " format, __FILENAME__, __LINE__, ##__VA_ARGS__)
+#define pfe_hm_report_dev_warning(src, id, dev, format, ...) \
+	pfe_hm_report((src), HM_WARNING, (id), (pfe_hm_log_t){.log_type = NXP_LOG_TYPE_DEV, .log_dev = dev}, "[%s:%d] " format, __FILENAME__, __LINE__, ##__VA_ARGS__)
+#define pfe_hm_report_dev_error(src, id, dev, format, ...) \
+	pfe_hm_report((src), HM_ERROR, (id), (pfe_hm_log_t){.log_type = NXP_LOG_TYPE_DEV, .log_dev = dev}, "[%s:%d] " format, __FILENAME__, __LINE__, ##__VA_ARGS__)
+
+#define pfe_hm_report_netdev_info(src, id, dev, format, ...) \
+	pfe_hm_report((src), HM_INFO, (id), (pfe_hm_log_t){.log_type = NXP_LOG_TYPE_NETDEV, .log_netdev = dev}, "[%s:%d] " format, __FILENAME__, __LINE__, ##__VA_ARGS__)
+#define pfe_hm_report_netdev_warning(src, id, dev, format, ...) \
+	pfe_hm_report((src), HM_WARNING, (id), (pfe_hm_log_t){.log_type = NXP_LOG_TYPE_NETDEV, .log_netdev = dev}, "[%s:%d] " format, __FILENAME__, __LINE__, ##__VA_ARGS__)
+#define pfe_hm_report_netdev_error(src, id, dev, format, ...) \
+	pfe_hm_report((src), HM_ERROR, (id), (pfe_hm_log_t){.log_type = NXP_LOG_TYPE_NETDEV, .log_netdev = dev}, "[%s:%d] " format, __FILENAME__, __LINE__, ##__VA_ARGS__)
 
 #endif /* PFE_HM_H */
diff --git a/sw/pfe_platform/public/pfe_l2br.h b/sw/pfe_platform/public/pfe_l2br.h
index 82ecaac..4a51351 100644
--- a/sw/pfe_platform/public/pfe_l2br.h
+++ b/sw/pfe_platform/public/pfe_l2br.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -86,10 +86,8 @@ pfe_l2br_domain_t *pfe_l2br_get_fallback_domain(const pfe_l2br_t *bridge) __attr
 pfe_l2br_domain_t *pfe_l2br_get_first_domain(pfe_l2br_t *bridge, pfe_l2br_domain_get_crit_t crit, void *arg);
 pfe_l2br_domain_t *pfe_l2br_get_next_domain(pfe_l2br_t *bridge);
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-uint32_t pfe_l2br_get_text_statistics(const pfe_l2br_t *bridge, char_t *buf, uint32_t buf_len, uint8_t verb_level);
-uint32_t pfe_l2br_domain_get_text_statistics(pfe_l2br_t *bridge, char_t *buf, uint32_t buf_len, uint8_t verb_level);
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
+uint32_t pfe_l2br_get_text_statistics(const pfe_l2br_t *bridge, struct seq_file *seq, uint8_t verb_level);
+uint32_t pfe_l2br_domain_get_text_statistics(pfe_l2br_t *bridge, struct seq_file *seq, uint8_t verb_level);
 
 errno_t pfe_l2br_clear_domain_stats(const pfe_l2br_t *bridge, uint8_t vlan_index);
 errno_t pfe_l2br_get_domain_stats(const pfe_l2br_t *bridge, pfe_ct_vlan_stats_t *stat, uint8_t vlan_index);
@@ -99,6 +97,9 @@ errno_t pfe_l2br_flush_learned(pfe_l2br_t *bridge);
 errno_t pfe_l2br_flush_static(pfe_l2br_t *bridge);
 errno_t pfe_l2br_flush_all(pfe_l2br_t *bridge);
 pfe_l2br_table_entry_t *pfe_l2br_static_entry_get_entry(const pfe_l2br_static_entry_t *static_ent);
+errno_t pfe_l2br_update_vlan_hash_entry(pfe_l2br_domain_t *domain);
+errno_t pfe_l2br_add_vlan_hash_entry(pfe_l2br_domain_t *domain);
+errno_t pfe_l2br_delete_vlan_hash_entry(pfe_l2br_domain_t *domain);
 
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
diff --git a/sw/pfe_platform/public/pfe_l2br_table.h b/sw/pfe_platform/public/pfe_l2br_table.h
index 70a88eb..8816541 100644
--- a/sw/pfe_platform/public/pfe_l2br_table.h
+++ b/sw/pfe_platform/public/pfe_l2br_table.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -62,9 +62,7 @@ bool_t pfe_l2br_table_entry_is_fresh(const pfe_l2br_table_entry_t *entry) __attr
 errno_t pfe_l2br_table_entry_set_static(const pfe_l2br_table_t *l2br, pfe_l2br_table_entry_t *entry, bool_t is_static);
 bool_t pfe_l2br_table_entry_is_static(const pfe_l2br_table_entry_t *entry) __attribute__((pure));
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-uint32_t pfe_l2br_table_entry_to_str(const pfe_l2br_table_entry_t *entry, char_t *buf, uint32_t buf_len);
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
+uint32_t pfe_l2br_table_entry_to_str(const pfe_l2br_table_entry_t *entry, struct seq_file *seq);
 
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
diff --git a/sw/pfe_platform/public/pfe_pe.h b/sw/pfe_platform/public/pfe_pe.h
index f2e4b19..740c298 100644
--- a/sw/pfe_platform/public/pfe_pe.h
+++ b/sw/pfe_platform/public/pfe_pe.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -20,7 +20,7 @@ typedef struct pfe_pe_tag pfe_pe_t;
 #include "Eth_43_PFE_MemMap.h"
 #endif /* PFE_CFG_TARGET_OS_AUTOSAR */
 
-pfe_pe_t * pfe_pe_create(addr_t cbus_base_va, pfe_ct_pe_type_t type, uint8_t id);
+pfe_pe_t * pfe_pe_create(addr_t cbus_base_va, pfe_ct_pe_type_t type, uint8_t id, oal_mutex_t *lock_mutex, bool_t *miflock);
 void pfe_pe_set_dmem(pfe_pe_t *pe, addr_t elf_base, addr_t len);
 void pfe_pe_set_imem(pfe_pe_t *pe, addr_t elf_base, addr_t len);
 void pfe_pe_set_lmem(pfe_pe_t *pe, addr_t elf_base, addr_t len);
@@ -37,20 +37,17 @@ errno_t pfe_pe_get_classify_stats_nolock(pfe_pe_t *pe, uint32_t addr, pfe_ct_cla
 errno_t pfe_pe_get_class_algo_stats_nolock(pfe_pe_t *pe, uint32_t addr, pfe_ct_class_algo_stats_t *stats);
 pfe_ct_pe_sw_state_t pfe_pe_get_fw_state(pfe_pe_t *pe);
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-uint32_t pfe_pe_get_text_statistics(pfe_pe_t *pe, char_t *buf, uint32_t buf_len, uint8_t verb_level);
-uint32_t pfe_pe_stat_to_str(const pfe_ct_class_algo_stats_t *stat, char *buf, uint32_t buf_len, uint8_t verb_level);
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
+uint32_t pfe_pe_get_text_statistics(pfe_pe_t *pe, struct seq_file *seq, uint8_t verb_level);
 
 void pfe_pe_destroy(pfe_pe_t **pe, uint32_t pe_num);
 errno_t pfe_pe_check_mmap(const pfe_pe_t *pe);
 errno_t pfe_pe_get_fw_messages_nolock(pfe_pe_t *pe);
 errno_t pfe_pe_get_data_nolock(pfe_pe_t *pe, pfe_ct_buffer_t *buf);
 errno_t pfe_pe_put_data_nolock(pfe_pe_t *pe, pfe_ct_buffer_t *buf);
-errno_t pfe_pe_mem_lock(pfe_pe_t *pe);
-errno_t pfe_pe_mem_unlock(pfe_pe_t *pe);
-errno_t pfe_pe_lock(pfe_pe_t *pe);
-errno_t pfe_pe_unlock(pfe_pe_t *pe);
+errno_t pfe_pe_memlock_acquire_nolock(pfe_pe_t *pe);
+errno_t pfe_pe_memlock_release_nolock(pfe_pe_t *pe);
+errno_t pfe_pe_lock_family(pfe_pe_t *pe);
+errno_t pfe_pe_unlock_family(pfe_pe_t *pe);
 char *pfe_pe_get_fw_feature_str_base(const pfe_pe_t *pe);
 
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
diff --git a/sw/pfe_platform/public/pfe_platform.h b/sw/pfe_platform/public/pfe_platform.h
index 11cf199..455e3c2 100644
--- a/sw/pfe_platform/public/pfe_platform.h
+++ b/sw/pfe_platform/public/pfe_platform.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -11,7 +11,6 @@
 #define SRC_PFE_PLATFORM_H_
 
 #include "pfe_platform_cfg.h"
-#include "pfe_pe.h"
 #include "pfe_gpi.h"
 #include "pfe_bmu.h"
 #include "pfe_class.h"
@@ -96,6 +95,7 @@ typedef struct
 	pfe_emac_mii_mode_t emac_mode[3]; /* MII mode per PFE EMAC */
 	bool_t g2_ordered_class_writes;	/* S32G2 ordered class writes switch */
 	bool_t g3_rtable_in_lmem;	/* allocate the routing table in LMEM for S32G3 */
+	uint8_t emac_ext_ts_mask;	/* The bitmap representing setting of external timestamping mode on EMACs */
 } pfe_platform_config_t;
 
 typedef struct
@@ -160,6 +160,7 @@ typedef struct
 	bool_t fci_created;
 	bool_t g3_rtable_in_lmem;
 	uint32_t pfe_version;
+	uint8_t emac_ext_ts_mask;
 } pfe_platform_t;
 
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
@@ -182,6 +183,7 @@ pfe_phy_if_t *pfe_platform_get_phy_if_by_id(const pfe_platform_t *platform, pfe_
 void pfe_platform_idex_rpc_cbk(pfe_ct_phy_if_id_t sender, uint32_t id, void *buf, uint16_t buf_len, void *arg);
 #endif
 errno_t pfe_platform_get_fw_versions(const pfe_platform_t *platform, pfe_ct_version_t *class_fw, pfe_ct_version_t *util_fw);
+uint32_t pfe_fw_features_get_text_statistics(const pfe_platform_t *pfe, struct seq_file *seq, uint8_t verb_level);
 
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
diff --git a/sw/pfe_platform/public/pfe_rtable.h b/sw/pfe_platform/public/pfe_rtable.h
index a22950d..b904a20 100644
--- a/sw/pfe_platform/public/pfe_rtable.h
+++ b/sw/pfe_platform/public/pfe_rtable.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -156,9 +156,7 @@ errno_t pfe_rtable_entry_set_dstif_id(pfe_rtable_entry_t *entry, pfe_ct_phy_if_i
 
 void pfe_rtable_do_timeouts(pfe_rtable_t *rtable);
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-uint32_t pfe_rtable_get_text_statistics(const pfe_rtable_t *rtable, char_t *buf, uint32_t buf_len, uint8_t verb_level);
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
+uint32_t pfe_rtable_get_text_statistics(const pfe_rtable_t *rtable, struct seq_file *seq, uint8_t verb_level);
 
 errno_t pfe_rtable_get_stats(const pfe_rtable_t *rtable, pfe_ct_conntrack_stats_t *stat, uint8_t conntrack_index);
 
diff --git a/sw/pfe_platform/public/pfe_tmu.h b/sw/pfe_platform/public/pfe_tmu.h
index 4394351..4f7d553 100644
--- a/sw/pfe_platform/public/pfe_tmu.h
+++ b/sw/pfe_platform/public/pfe_tmu.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -115,9 +115,7 @@ void pfe_tmu_enable(const pfe_tmu_t *tmu);
 void pfe_tmu_reset(const pfe_tmu_t *tmu);
 void pfe_tmu_disable(const pfe_tmu_t *tmu);
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-uint32_t pfe_tmu_get_text_statistics(const pfe_tmu_t *tmu, char_t *buf, uint32_t buf_len, uint8_t verb_level);
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
+uint32_t pfe_tmu_get_text_statistics(const pfe_tmu_t *tmu, struct seq_file *seq, uint8_t verb_level);
 
 void pfe_tmu_destroy(const pfe_tmu_t *tmu);
 
diff --git a/sw/pfe_platform/public/pfe_util.h b/sw/pfe_platform/public/pfe_util.h
index 60b0662..e3c0106 100644
--- a/sw/pfe_platform/public/pfe_util.h
+++ b/sw/pfe_platform/public/pfe_util.h
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -29,9 +29,7 @@ void pfe_util_reset(pfe_util_t *util);
 void pfe_util_disable(pfe_util_t *util);
 errno_t pfe_util_load_firmware(pfe_util_t *util, const void *elf);
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-uint32_t pfe_util_get_text_statistics(const pfe_util_t *util, char_t *buf, uint32_t buf_len, uint8_t verb_level);
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
+uint32_t pfe_util_get_text_statistics(const pfe_util_t *util, struct seq_file *seq, uint8_t verb_level);
 
 void pfe_util_destroy(pfe_util_t *util);
 errno_t pfe_util_isr(const pfe_util_t *util);
diff --git a/sw/pfe_platform/src/pfe_bmu.c b/sw/pfe_platform/src/pfe_bmu.c
index bd6120d..54e9ddc 100644
--- a/sw/pfe_platform/src/pfe_bmu.c
+++ b/sw/pfe_platform/src/pfe_bmu.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -478,37 +478,29 @@ __attribute__((cold)) void pfe_bmu_destroy(pfe_bmu_t *bmu)
 	}
 }
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-
 /**
  * @brief		Return BMU runtime statistics in text form
  * @details		Function writes formatted text into given buffer.
  * @param[in]	bmu 		The BMU instance
- * @param[in]	buf 		Pointer to the buffer to write to
- * @param[in]	buf_len 	Buffer length
+ * @param[in]	seq 		Pointer to debugfs seq_file
  * @param[in]	verb_level 	Verbosity level
  * @return		Number of bytes written to the buffer
  */
-__attribute__((cold)) uint32_t pfe_bmu_get_text_statistics(const pfe_bmu_t *bmu, char_t *buf, uint32_t buf_len, uint8_t verb_level)
+__attribute__((cold)) uint32_t pfe_bmu_get_text_statistics(const pfe_bmu_t *bmu, struct seq_file *seq, uint8_t verb_level)
 {
-	uint32_t len = 0U;
-
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == bmu))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		len = 0U;
 	}
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		len += pfe_bmu_cfg_get_text_stat(bmu->bmu_base_va, buf, buf_len, verb_level);
+		pfe_bmu_cfg_get_text_stat(bmu->bmu_base_va, seq, verb_level);
 	}
-	return len;
+	return 0;
 }
 
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
-
 #ifdef PFE_CFG_PFE_MASTER
 /**
  * @brief		BMU error polling
diff --git a/sw/pfe_platform/src/pfe_class.c b/sw/pfe_platform/src/pfe_class.c
index 1137a19..ff32f96 100644
--- a/sw/pfe_platform/src/pfe_class.c
+++ b/sw/pfe_platform/src/pfe_class.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -38,9 +38,12 @@ struct pfe_classifier_tag
 	blalloc_t *        heap_context;   /* Heap manager context */
 	uint32_t           dmem_heap_base; /* DMEM base address of the heap */
 	oal_mutex_t        mutex;
+	oal_mutex_t        mutex_pe;       /* Shared mutex for CLASS PE cores */
+	bool_t             miflock_pe;     /* Shared 'miflock' diagnostic flag for CLASS PE cores */
 	uint32_t           current_feature;   /* Index of the feature to return by pfe_class_get_feature_next() */
 	pfe_fw_feature_t **fw_features;       /* List of all features*/
 	uint32_t           fw_features_count; /* Number of items in fw_features */
+	uint32_t           phy_if_bitmap_br_modes; /* Bitmap list of PHY interfaces with enabled bridge mode, used to control HW bridge lookup */
 };
 
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
@@ -52,20 +55,16 @@ static errno_t  pfe_class_dmem_heap_init(pfe_class_t *class);
 static errno_t  pfe_class_load_fw_features(pfe_class_t *class);
 static errno_t  pfe_class_load_fw_process(pfe_class_t *class);
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-
 static void     pfe_class_alg_stats_endian(pfe_ct_class_algo_stats_t *stat);
 static void     pfe_class_ihc_stats_endian(pfe_ct_class_ihc_stats_t *stat);
 static void     pfe_class_pe_stats_endian(pfe_ct_pe_stats_t *stat);
 static void     pfe_class_sum_pe_algo_stats(pfe_ct_class_algo_stats_t *sum, const pfe_ct_class_algo_stats_t *val);
 static void     pfe_class_sum_pe_ihc_stats(pfe_ct_class_ihc_stats_t *sum, const pfe_ct_class_ihc_stats_t *val);
-static uint32_t pfe_class_stat_to_str(const pfe_ct_class_algo_stats_t *stat, char *buf, uint32_t buf_len, uint8_t verb_level);
-static uint32_t pfe_class_ihc_stat_to_str(const pfe_ct_class_ihc_stats_t *stat, char *buf, uint32_t buf_len, uint8_t verb_level);
+static uint32_t pfe_class_stat_to_str(const pfe_ct_class_algo_stats_t *stat, struct seq_file *seq, uint8_t verb_level);
+static uint32_t pfe_class_ihc_stat_to_str(const pfe_ct_class_ihc_stats_t *stat, struct seq_file *seq, uint8_t verb_level);
 static void pfe_class_cal_total_stats(pfe_class_t *class, pfe_ct_classify_stats_t *total_stat, pfe_ct_classify_stats_t *stats);
 static errno_t pfe_class_create_pe(pfe_class_t *class, addr_t cbus_base_va, uint32_t pe_num);
 
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
-
 /**
  * @brief CLASS ISR
  * @details Checks all PEs whether they report a firmware error
@@ -89,47 +88,49 @@ errno_t pfe_class_isr(const pfe_class_t *class)
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		for (i = 0U; i < class->pe_num; i++)
+		/*	Allow safe use of _nolock() functions. We don't call the _memlock()
+		 	here as we don't need to have coherent accesses. */
+		if (EOK != pfe_pe_lock_family(*class->pe))
+		{
+			NXP_LOG_ERROR("pfe_pe_lock_family() failed\n");
+		}
+		else
 		{
-			/*	Allow safe use of _nolock() functions. We don't call the _mem_lock()
-				here as we don't need to have coherent accesses. */
-			if (EOK != pfe_pe_lock(class->pe[i]))
+			for (i = 0U; i < class->pe_num; i++)
 			{
-				NXP_LOG_ERROR("pfe_pe_lock() failed\n");
-			}
-
-			/*	Read and print the error record from each PE */
-			(void)pfe_pe_get_fw_messages_nolock(class->pe[i]);
-			/* Check the PE core for stalled state */
-			(void)pfe_pe_check_stalled_nolock(class->pe[i]);
+				/*	Read and print the error record from each PE */
+				(void)pfe_pe_get_fw_messages_nolock(class->pe[i]);
+				/* Check the PE core for stalled state */
+				(void)pfe_pe_check_stalled_nolock(class->pe[i]);
 
 #ifdef PFE_CFG_FCI_ENABLE
-			/*	Check if there is new message */
-			if (EOK == pfe_pe_get_data_nolock(class->pe[i], &buf))
-			{
-				/*	Provide data to user via FCI */
-				msg.msg_cmd.code   = FPP_CMD_DATA_BUF_AVAIL;
-				msg.msg_cmd.length = buf.len;
-
-				if (msg.msg_cmd.length > (uint32_t)sizeof(msg.msg_cmd.payload))
-				{
-					NXP_LOG_ERROR("FCI buffer is too small\n");
-				}
-				else
+				/*	Check if there is new message */
+				if (EOK == pfe_pe_get_data_nolock(class->pe[i], &buf))
 				{
-					(void)memcpy(&msg.msg_cmd.payload, buf.payload, buf.len);
-					ret = fci_core_client_send_broadcast(&msg, NULL);
-					if (EOK != ret)
+					/*	Provide data to user via FCI */
+					msg.msg_cmd.code   = FPP_CMD_DATA_BUF_AVAIL;
+					msg.msg_cmd.length = buf.len;
+
+					if (msg.msg_cmd.length > (uint32_t)sizeof(msg.msg_cmd.payload))
 					{
-						NXP_LOG_ERROR("Can't report data to FCI clients\n");
+						NXP_LOG_ERROR("FCI buffer is too small\n");
+					}
+					else
+					{
+						(void)memcpy(&msg.msg_cmd.payload, buf.payload, buf.len);
+						ret = fci_core_client_send_broadcast(&msg, NULL);
+						if (EOK != ret)
+						{
+							NXP_LOG_ERROR("Can't report data to FCI clients\n");
+						}
 					}
 				}
-			}
 #endif /* PFE_CFG_FCI_ENABLE */
+			}
 
-			if (EOK != pfe_pe_unlock(class->pe[i]))
+			if (EOK != pfe_pe_unlock_family(*class->pe))
 			{
-				NXP_LOG_ERROR("pfe_pe_unlock() failed\n");
+				NXP_LOG_ERROR("pfe_pe_unlock_family() failed\n");
 			}
 		}
 		ret = EOK;
@@ -173,7 +174,7 @@ static errno_t pfe_class_create_pe(pfe_class_t *class, addr_t cbus_base_va, uint
 	/*	Create PEs */
 	for (ii = 0U; ii < pe_num; ii++)
 	{
-		pe = pfe_pe_create(cbus_base_va, PE_TYPE_CLASS, (uint8_t)ii);
+		pe = pfe_pe_create(cbus_base_va, PE_TYPE_CLASS, (uint8_t)ii, &class->mutex_pe, &class->miflock_pe);
 
 		if (NULL == pe)
 		{
@@ -233,6 +234,13 @@ pfe_class_t *pfe_class_create(addr_t cbus_base_va, uint32_t pe_num, const pfe_cl
 				oal_mm_free(class);
 				class = NULL;
 			}
+			else if (EOK != oal_mutex_init(&class->mutex_pe))
+			{
+				NXP_LOG_ERROR("Unable to initialize shared mutex for CLASS PE cores\n");
+				(void)oal_mutex_destroy(&class->mutex);	/* 'mutex_pe' creation failed, but 'mutex' already exists */
+				oal_mm_free(class);
+				class = NULL;
+			}
 			else
 			{
 				if (pe_num > 0U)
@@ -243,6 +251,7 @@ pfe_class_t *pfe_class_create(addr_t cbus_base_va, uint32_t pe_num, const pfe_cl
 					{
 						NXP_LOG_ERROR("Unable to allocate memory\n");
 						(void)oal_mutex_destroy(&class->mutex);
+						(void)oal_mutex_destroy(&class->mutex_pe);
 						oal_mm_free(class);
 						class = NULL;
 					}
@@ -878,6 +887,11 @@ void pfe_class_destroy(pfe_class_t *class)
 			class->heap_context = NULL;
 		}
 
+		if (EOK != oal_mutex_destroy(&class->mutex_pe))
+		{
+			NXP_LOG_ERROR("Could not properly destroy shared mutex for CLASS PE cores\n");
+		}
+
 		if (EOK != oal_mutex_destroy(&class->mutex))
 		{
 			NXP_LOG_ERROR("Could not properly destroy mutex\n");
@@ -1234,12 +1248,11 @@ static void pfe_class_sum_pe_ihc_stats(pfe_ct_class_ihc_stats_t *sum, const pfe_
 /**
  * @brief                  Converts statistics of a logical interface or classification algorithm into a text form
  * @param[in]  stat        Statistics to convert - expected in HOST endian
- * @param[out] buf         Buffer where to write the text
- * @param[in]  buf_len     Buffer length
+ * @param[in]  seq         Pointer to debugfs seq_file
  * @param[in]  verb_level  Verbosity level
  * @return                 Number of bytes written into the output buffer
  */
-static uint32_t pfe_class_stat_to_str(const pfe_ct_class_algo_stats_t *stat, char *buf, uint32_t buf_len, uint8_t verb_level)
+static uint32_t pfe_class_stat_to_str(const pfe_ct_class_algo_stats_t *stat, struct seq_file *seq, uint8_t verb_level)
 {
 	uint32_t len = 0U;
 
@@ -1253,10 +1266,10 @@ static uint32_t pfe_class_stat_to_str(const pfe_ct_class_algo_stats_t *stat, cha
 	else
 #endif
 	{
-		len += oal_util_snprintf(buf + len, buf_len - len, "Frames processed: %u\n", stat->processed);
-		len += oal_util_snprintf(buf + len, buf_len - len, "Frames accepted:  %u\n", stat->accepted);
-		len += oal_util_snprintf(buf + len, buf_len - len, "Frames rejected:  %u\n", stat->rejected);
-		len += oal_util_snprintf(buf + len, buf_len - len, "Frames discarded: %u\n", stat->discarded);
+		seq_printf(seq, "Frames processed: %u\n", stat->processed);
+		seq_printf(seq, "Frames accepted:  %u\n", stat->accepted);
+		seq_printf(seq, "Frames rejected:  %u\n", stat->rejected);
+		seq_printf(seq, "Frames discarded: %u\n", stat->discarded);
 	}
 	return len;
 }
@@ -1264,12 +1277,11 @@ static uint32_t pfe_class_stat_to_str(const pfe_ct_class_algo_stats_t *stat, cha
 /**
  * @brief                 Converts statistics of a logical interface or classification algorithm into a text form
  * @param[in]  stat       Statistics to convert - expected in HOST endian
- * @param[out] buf        Buffer where to write the text
- * @param[in]  buf_len    Buffer length
+ * @param[in]  seq         Pointer to debugfs seq_file
  * @param[in]  verb_level Verbosity level
  * @return                Number of bytes written into the output buffer
  */
-static uint32_t pfe_class_ihc_stat_to_str(const pfe_ct_class_ihc_stats_t *stat, char *buf, uint32_t buf_len, uint8_t verb_level)
+static uint32_t pfe_class_ihc_stat_to_str(const pfe_ct_class_ihc_stats_t *stat, struct seq_file *seq, uint8_t verb_level)
 {
 	uint32_t len = 0U;
 
@@ -1283,9 +1295,9 @@ static uint32_t pfe_class_ihc_stat_to_str(const pfe_ct_class_ihc_stats_t *stat,
 	else
 #endif
 	{
-		len += oal_util_snprintf(buf + len, buf_len - len, "  Frames received:    %u\n", stat->rx);
-		len += oal_util_snprintf(buf + len, buf_len - len, "  Frames transmitted: %u\n", stat->tx);
-		len += oal_util_snprintf(buf + len, buf_len - len, "  Frames discarded:   %u\n", stat->discarded);
+		seq_printf(seq, "  Frames received:    %u\n", stat->rx);
+		seq_printf(seq, "  Frames transmitted: %u\n", stat->tx);
+		seq_printf(seq, "  Frames discarded:   %u\n", stat->discarded);
 	}
 	return len;
 }
@@ -1293,12 +1305,11 @@ static uint32_t pfe_class_ihc_stat_to_str(const pfe_ct_class_ihc_stats_t *stat,
 /**
  * @brief                  Converts statistics of a logical interface or classification algorithm into a text form
  * @param[in]   stat       Statistics to convert - expected in HOST endian
- * @param[out]  buf        Buffer where to write the text
- * @param[in]   buf_len    Buffer length
+ * @param[in]   seq        Pointer to debugfs seq_file
  * @param[in]   verb_level Verbosity level
  * @return                 Number of bytes written into the output buffer
  */
-uint32_t pfe_class_fp_stat_to_str(const pfe_ct_class_flexi_parser_stats_t *stat, char *buf, uint32_t buf_len, uint8_t verb_level)
+uint32_t pfe_class_fp_stat_to_str(const pfe_ct_class_flexi_parser_stats_t *stat, struct seq_file *seq, uint8_t verb_level)
 {
 	uint32_t len = 0U;
 
@@ -1312,8 +1323,8 @@ uint32_t pfe_class_fp_stat_to_str(const pfe_ct_class_flexi_parser_stats_t *stat,
 	else
 #endif
 	{
-		len += oal_util_snprintf(buf + len, buf_len - len, "Frames accepted:  %u\n", stat->accepted);
-		len += oal_util_snprintf(buf + len, buf_len - len, "Frames rejected:  %u\n", stat->rejected);
+		seq_printf(seq, "Frames accepted:  %u\n", stat->accepted);
+		seq_printf(seq, "Frames rejected:  %u\n", stat->rejected);
 	}
 	return len;
 }
@@ -1331,36 +1342,39 @@ errno_t pfe_class_put_data(const pfe_class_t *class, pfe_ct_buffer_t *buf)
 	uint32_t ii, tries;
 	errno_t  ret;
 
-	for (ii = 0U; ii < class->pe_num; ii++)
+	/*	Allow safe use of _nolock() functions. We don't call the _memlock()
+		here as we don't need to have coherent accesses. */
+	ret = pfe_pe_lock_family(*class->pe);
+	if (EOK != ret)
 	{
-		/*	Allow safe use of _nolock() functions. We don't call the _mem_lock()
-		 	here as we don't need to have coherent accesses. */
-		if (EOK != pfe_pe_lock(class->pe[ii]))
+		NXP_LOG_ERROR("pfe_pe_lock_family() failed\n");
+	}
+	else
+	{
+		for (ii = 0U; ii < class->pe_num; ii++)
 		{
-			NXP_LOG_ERROR("pfe_pe_lock() failed\n");
-		}
+			tries = 0U;
+			do
+			{
+				ret = pfe_pe_put_data_nolock(class->pe[ii], buf);
+				if (EAGAIN == ret)
+				{
+					tries++;
+					oal_time_usleep(200U);
+				}
+			} while ((ret == EAGAIN) && (tries < 10U));
 
-		tries = 0U;
-		do
-		{
-			ret = pfe_pe_put_data_nolock(class->pe[ii], buf);
-			if (EAGAIN == ret)
+			if (EOK != ret)
 			{
-				tries++;
-				oal_time_usleep(200U);
+				NXP_LOG_ERROR("Unable to update pe %u\n", (uint_t)ii);
+				ret = EBUSY;
+				break;
 			}
-		} while ((ret == EAGAIN) && (tries < 10U));
-
-		if (EOK != pfe_pe_unlock(class->pe[ii]))
-		{
-			NXP_LOG_ERROR("pfe_pe_lock() failed\n");
 		}
 
-		if (EOK != ret)
+		if (EOK != pfe_pe_unlock_family(*class->pe))
 		{
-			NXP_LOG_ERROR("Unable to update pe %u\n", (uint_t)ii);
-			ret = EBUSY;
-			break;
+			NXP_LOG_ERROR("pfe_pe_unlock_family() failed\n");
 		}
 	}
 
@@ -1472,15 +1486,12 @@ errno_t pfe_class_get_stats(pfe_class_t *class, pfe_ct_classify_stats_t *stat)
  * @brief		Return CLASS runtime statistics in text form
  * @details		Function writes formatted text into given buffer.
  * @param[in]	class 		The CLASS instance
- * @param[in]	buf 		Pointer to the buffer to write to
- * @param[in]	buf_len 	Buffer length
+ * @param[in]	seq			Pointer to debugfs seq_file
  * @param[in]	verb_level 	Verbosity level
  * @return		Number of bytes written to the buffer
  */
-uint32_t pfe_class_get_text_statistics(pfe_class_t *class, char_t *buf, uint32_t buf_len, uint8_t verb_level)
+uint32_t pfe_class_get_text_statistics(pfe_class_t *class, struct seq_file *seq, uint8_t verb_level)
 {
-	uint32_t len = 0U;
-
 	pfe_ct_pe_mmap_t        mmap;
 	errno_t                 ret = EOK;
 	uint32_t                ii, j;
@@ -1504,7 +1515,6 @@ uint32_t pfe_class_get_text_statistics(pfe_class_t *class, char_t *buf, uint32_t
 	if (unlikely(NULL == class))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		len = 0U;
 	}
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
@@ -1517,14 +1527,14 @@ uint32_t pfe_class_get_text_statistics(pfe_class_t *class, char_t *buf, uint32_t
 		/* FW version */
 		if (EOK == pfe_class_get_fw_version(class, &fw_ver))
 		{
-			len += oal_util_snprintf(buf + len, buf_len - len, "FIRMWARE VERSION\t%u.%u.%u (api:%.32s)\n", fw_ver.major, fw_ver.minor, fw_ver.patch, fw_ver.cthdr);
+			seq_printf(seq, "FIRMWARE VERSION\t%u.%u.%u (api:%.32s)\n", fw_ver.major, fw_ver.minor, fw_ver.patch, fw_ver.cthdr);
 		}
 		else
 		{
-			len += oal_util_snprintf(buf + len, buf_len - len, "FIRMWARE VERSION <unknown>\n");
+			seq_printf(seq, "FIRMWARE VERSION <unknown>\n");
 		}
 
-		len += pfe_class_cfg_get_text_stat(class->cbus_base_va, buf + len, buf_len - len, verb_level);
+		pfe_class_cfg_get_text_stat(class->cbus_base_va, seq, verb_level);
 
 		/* Allocate memory to copy the statistics from PEs + one position for sums
 		(having sums separate from data allows to print also per PE details) */
@@ -1555,36 +1565,50 @@ uint32_t pfe_class_get_text_statistics(pfe_class_t *class, char_t *buf, uint32_t
 			}
 			else
 			{
-
-				/* Lock all PEs - they will stop processing frames and wait. This will
-				ensure data coherence. */
-				for (ii = 0U; ii < class->pe_num; ii++)
+				ret = pfe_pe_lock_family(*class->pe);
+				if (EOK != ret)
 				{
-					ret = pfe_pe_mem_lock(class->pe[ii]);
-					if (EOK != ret)
+					NXP_LOG_ERROR("pfe_pe_lock_family() failed\n");
+					seq_printf(seq, "pfe_pe_lock_family() failed\n");
+				}
+				else
+				{
+					/*	Acquire memlock for all PE cores. They will stop processing frames and wait.
+						This will ensure data coherence. */
+					for (ii = 0U; ii < class->pe_num; ii++)
 					{
-						NXP_LOG_ERROR("PE %u could not be locked\n", (uint_t)ii);
-						len += oal_util_snprintf(buf + len, buf_len - len, "PE %u could not be locked - statistics are not coherent\n", ii);
+						ret = pfe_pe_memlock_acquire_nolock(class->pe[ii]);
+						if (EOK != ret)
+						{
+							NXP_LOG_ERROR("Cannot acquire PE %u memlock\n", (uint_t)ii);
+							seq_printf(seq, "Cannot acquire PE %u memlock - statistics are not coherent\n", ii);
+						}
 					}
-				}
 
-				/* Get PE info per PE
-				- leave 1st position in allocated memory empty for sums */
-				for (ii = 0U; ii < class->pe_num; ii++)
-				{
-					(void)pfe_pe_get_pe_stats_nolock(
-					    class->pe[ii],
-					    oal_ntohl(mmap.class_pe.pe_stats),
-					    &pe_stats[ii + 1U]);
-				}
+					/* Get PE info per PE
+					- leave 1st position in allocated memory empty for sums */
+					for (ii = 0U; ii < class->pe_num; ii++)
+					{
+						(void)pfe_pe_get_pe_stats_nolock(
+							class->pe[ii],
+							oal_ntohl(mmap.class_pe.pe_stats),
+							&pe_stats[ii + 1U]);
+					}
 
-				/* Unlock all PEs */
-				for (ii = 0U; ii < class->pe_num; ii++)
-				{
-					ret = pfe_pe_mem_unlock(class->pe[ii]);
+					/* Release memlock for all PE cores. */
+					for (ii = 0U; ii < class->pe_num; ii++)
+					{
+						ret = pfe_pe_memlock_release_nolock(class->pe[ii]);
+						if (EOK != ret)
+						{
+							NXP_LOG_ERROR("Cannot release PE %u memlock\n", (uint_t)ii);
+						}
+					}
+
+					ret = pfe_pe_unlock_family(*class->pe);
 					if (EOK != ret)
 					{
-						NXP_LOG_ERROR("PE %u could not be unlocked\n", (uint_t)ii);
+						NXP_LOG_ERROR("pfe_pe_unlock_family() failed\n");
 					}
 				}
 
@@ -1620,46 +1644,46 @@ uint32_t pfe_class_get_text_statistics(pfe_class_t *class, char_t *buf, uint32_t
 				}
 
 				/* Print results */
-				len += oal_util_snprintf(buf + len, buf_len - len, "-- Per PE statistics --\n");
+				seq_printf(seq, "-- Per PE statistics --\n");
 
 				for (ii = 0U; ii < class->pe_num; ii++)
 				{
-					len += oal_util_snprintf(buf + len, buf_len - len, "PE %u Frames processed: %u\n", ii, pe_stats[ii + 1U].processed);
-					len += oal_util_snprintf(buf + len, buf_len - len, "PE %u Frames discarded: %u\n", ii, pe_stats[ii + 1U].discarded);
+					seq_printf(seq, "PE %u Frames processed: %u\n", ii, pe_stats[ii + 1U].processed);
+					seq_printf(seq, "PE %u Frames discarded: %u\n", ii, pe_stats[ii + 1U].discarded);
 				}
 
-				len += oal_util_snprintf(buf + len, buf_len - len, "-- Summary statistics --\n");
-				len += oal_util_snprintf(buf + len, buf_len - len, "Frames processed: %u\n", pe_stats[0].processed);
-				len += oal_util_snprintf(buf + len, buf_len - len, "Frames discarded: %u\n", pe_stats[0].discarded);
+				seq_printf(seq, "-- Summary statistics --\n");
+				seq_printf(seq, "Frames processed: %u\n", pe_stats[0].processed);
+				seq_printf(seq, "Frames discarded: %u\n", pe_stats[0].discarded);
 
 				for (j = 0U; j < ((uint32_t)PFE_PHY_IF_ID_MAX + 1U); j++)
 				{
-					len += oal_util_snprintf(buf + len, buf_len - len, "Frames with %u replicas: %u\n", j + 1U, pe_stats[0].replicas[j]);
+					seq_printf(seq, "Frames with %u replicas: %u\n", j + 1U, pe_stats[0].replicas[j]);
 				}
 
-				len += oal_util_snprintf(buf + len, buf_len - len, "Frames with HIF_TX_INJECT: %u\n", pe_stats[0].injected);
+				seq_printf(seq, "Frames with HIF_TX_INJECT: %u\n", pe_stats[0].injected);
 
-				len += oal_util_snprintf(buf + len, buf_len - len, "- Flexible router -\n");
-				len += pfe_class_stat_to_str(&c_alg_stats.flexible_router, buf + len, buf_len - len, verb_level);
-				len += oal_util_snprintf(buf + len, buf_len - len, "- IP Router -\n");
-				len += pfe_class_stat_to_str(&c_alg_stats.ip_router, buf + len, buf_len - len, verb_level);
-				len += oal_util_snprintf(buf + len, buf_len - len, "- VLAN Bridge -\n");
-				len += pfe_class_stat_to_str(&c_alg_stats.vlan_bridge, buf + len, buf_len - len, verb_level);
-				len += oal_util_snprintf(buf + len, buf_len - len, "- Logical Interfaces -\n");
-				len += pfe_class_stat_to_str(&c_alg_stats.log_if, buf + len, buf_len - len, verb_level);
-				len += oal_util_snprintf(buf + len, buf_len - len, "- InterHIF -\n");
+				seq_printf(seq, "- Flexible router -\n");
+				pfe_class_stat_to_str(&c_alg_stats.flexible_router, seq, verb_level);
+				seq_printf(seq, "- IP Router -\n");
+				pfe_class_stat_to_str(&c_alg_stats.ip_router, seq, verb_level);
+				seq_printf(seq, "- VLAN Bridge -\n");
+				pfe_class_stat_to_str(&c_alg_stats.vlan_bridge, seq, verb_level);
+				seq_printf(seq, "- Logical Interfaces -\n");
+				pfe_class_stat_to_str(&c_alg_stats.log_if, seq, verb_level);
+				seq_printf(seq, "- InterHIF -\n");
 
 				for (j = 0U; j < ((uint32_t)PFE_PHY_IF_ID_MAX + 1U); j++)
 				{
 					if (0U != (((uint32_t)1U << j) & (uint32_t)HIF_CHANNELS_MASK))
 					{
-						len += oal_util_snprintf(buf + len, buf_len - len, "Interface: %s\n", phyif_name[j]);
-						len += pfe_class_ihc_stat_to_str(&c_alg_stats.hif_to_hif[j], buf + len, buf_len - len, verb_level);
+						seq_printf(seq, "Interface: %s\n", phyif_name[j]);
+						pfe_class_ihc_stat_to_str(&c_alg_stats.hif_to_hif[j], seq, verb_level);
 					}
 				}
 
-				len += oal_util_snprintf(buf + len, buf_len - len, "\nDMEM heap\n---------\n");
-				len += blalloc_get_text_statistics(class->heap_context, buf + len, buf_len - len, verb_level);
+				seq_printf(seq, "\nDMEM heap\n---------\n");
+				blalloc_get_text_statistics(class->heap_context, seq, verb_level);
 
 				/* Free allocated memory */
 				oal_mm_free(pe_stats);
@@ -1667,7 +1691,7 @@ uint32_t pfe_class_get_text_statistics(pfe_class_t *class, char_t *buf, uint32_t
 		}
 	}
 
-	return len;
+	return 0;
 }
 
 #endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
@@ -1714,6 +1738,58 @@ void pfe_class_rtable_lookup_disable(const pfe_class_t *class)
 	pfe_class_cfg_rtable_lookup_disable(class->cbus_base_va);
 }
 
+/**
+* @brief 		Control HW bridge lookup
+* @param[in] 	class The classifier instance
+* @param[in] 	if_bitmap The bitmap represnting PHY IF
+* @param[in] 	br_mode The bridge mode state of PHY IF
+* @note			HW bridge lookup is enabled with the 1st PHY IF set to bridge mode,
+*				disabled when the last PHY IF bridge mode is unset.
+*/
+void pfe_class_update_hw_bridge_lookup(pfe_class_t *class, uint32_t if_bitmap, bool_t br_mode)
+{
+	uint32_t if_bitmap_br_modes_before;
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (unlikely(NULL == class))
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+	}
+	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		if (EOK != oal_mutex_lock(&class->mutex))
+		{
+			NXP_LOG_ERROR("mutex lock failed\n");
+		}
+
+		if_bitmap_br_modes_before = class->phy_if_bitmap_br_modes;
+		if (TRUE == br_mode)
+		{
+			class->phy_if_bitmap_br_modes |= if_bitmap;
+			if (0U == if_bitmap_br_modes_before)
+			{
+				/* Enable HW bridge lookup */
+				pfe_class_cfg_bridge_lookup_enable(class->cbus_base_va);
+			}
+		}
+		else
+		{
+			class->phy_if_bitmap_br_modes &= ~if_bitmap;
+			if ((0U != if_bitmap_br_modes_before) && (0U == class->phy_if_bitmap_br_modes))
+			{
+				/* Disable HW bridge lookup */
+				pfe_class_cfg_bridge_lookup_disable(class->cbus_base_va);
+			}
+		}
+
+		if (EOK != oal_mutex_unlock(&class->mutex))
+		{
+			NXP_LOG_ERROR("mutex unlock failed\n");
+		}
+	}
+}
+
+
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
 #include "Eth_43_PFE_MemMap.h"
diff --git a/sw/pfe_platform/src/pfe_emac.c b/sw/pfe_platform/src/pfe_emac.c
index 2354f18..408d7e4 100644
--- a/sw/pfe_platform/src/pfe_emac.c
+++ b/sw/pfe_platform/src/pfe_emac.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -35,6 +35,7 @@ struct pfe_emac_tag
 	uint32_t o_clk_hz;			/*	IEEE1588 desired output clock */
 	uint32_t adj_ppb;			/*	IEEE1588 frequency adjustment value */
 	bool_t adj_sign;			/*	IEEE1588 frequency adjustment sign (TRUE - positive, FALSE - negative) */
+	bool_t ext_ts;				/*  IEEE1588 external timestamp mode */
 	pfe_gpi_t *gpi;				/* gpi handle, to export gpi services for this emac instance */
 };
 
@@ -49,24 +50,9 @@ typedef struct
 	pfe_drv_id_t owner;	/*	Identification of the driver that owns this entry */
 } pfe_mac_addr_db_entry_t;
 
-#ifdef PFE_CFG_TARGET_OS_AUTOSAR
-#define ETH_43_PFE_START_SEC_VAR_INIT_32
-#include "Eth_43_PFE_MemMap.h"
-#endif /* PFE_CFG_TARGET_OS_AUTOSAR */
-
 /* usage scope: pfe_emac_mdio_lock */
 static uint32_t key_seed = 123U;
 
-#ifdef PFE_CFG_TARGET_OS_AUTOSAR
-#define ETH_43_PFE_STOP_SEC_VAR_INIT_32
-#include "Eth_43_PFE_MemMap.h"
-#endif /* PFE_CFG_TARGET_OS_AUTOSAR */
-
-#ifdef PFE_CFG_TARGET_OS_AUTOSAR
-#define ETH_43_PFE_START_SEC_CODE
-#include "Eth_43_PFE_MemMap.h"
-#endif /* PFE_CFG_TARGET_OS_AUTOSAR */
-
 static bool_t pfe_emac_flush_criterion_eval(const pfe_mac_addr_db_entry_t *entry, pfe_emac_crit_t crit, pfe_mac_type_t type, pfe_drv_id_t owner);
 static void pfe_emac_addr_db_init(pfe_emac_t *emac);
 static errno_t pfe_emac_addr_db_add(pfe_emac_t *emac, const pfe_mac_addr_t addr, bool_t in_hash_grp, uint32_t data, pfe_drv_id_t owner);
@@ -645,6 +631,7 @@ errno_t pfe_emac_enable_ts(pfe_emac_t *emac, uint32_t i_clk_hz, uint32_t o_clk_h
 	{
 		emac->i_clk_hz = i_clk_hz;
 		emac->o_clk_hz = o_clk_hz;
+		emac->ext_ts = eclk;
 
 		if (EOK != oal_mutex_lock(&emac->ts_mutex))
 		{
@@ -676,10 +663,18 @@ errno_t pfe_emac_set_ts_freq_adjustment(pfe_emac_t *emac, uint32_t ppb, bool_t s
 		NXP_LOG_ERROR("Mutex lock failed\n");
 	}
 
+	if (TRUE == emac->ext_ts)
+	{
+		NXP_LOG_DEBUG("Cannot adjust timestamping clock frequency on EMAC%u working in external timestamp mode\n", pfe_emac_get_index(emac));
+		ret = EPERM;
+	}
+	else
+	{
 	emac->adj_ppb = ppb;
 	emac->adj_sign = sgn;
 
 	ret = pfe_emac_cfg_adjust_ts_freq(emac->emac_base_va, emac->i_clk_hz, emac->o_clk_hz, ppb, sgn);
+	}
 
 	if (EOK != oal_mutex_unlock(&emac->ts_mutex))
 	{
@@ -798,7 +793,15 @@ errno_t pfe_emac_adjust_ts_time(pfe_emac_t *emac, uint32_t sec, uint32_t nsec, b
 			NXP_LOG_ERROR("Mutex lock failed\n");
 		}
 
+		if (TRUE == emac->ext_ts)
+		{
+			NXP_LOG_DEBUG("Cannot adjust timestamping time on EMAC%u working in external timestamp mode\n", pfe_emac_get_index(emac));
+			ret = EPERM;
+		}
+		else
+		{
 		ret = pfe_emac_cfg_adjust_ts_time(emac->emac_base_va, sec, nsec, sgn);
+		}
 
 		if (EOK != oal_mutex_unlock(&emac->ts_mutex))
 		{
@@ -837,7 +840,15 @@ errno_t pfe_emac_set_ts_time(pfe_emac_t *emac, uint32_t sec, uint32_t nsec, uint
 			NXP_LOG_ERROR("Mutex lock failed\n");
 		}
 
+		if (TRUE == emac->ext_ts)
+		{
+			NXP_LOG_DEBUG("Cannot set timestamping time on EMAC%u working in external timestamp mode\n", pfe_emac_get_index(emac));
+			ret = EPERM;
+		}
+		else
+		{
 		ret = pfe_emac_cfg_set_ts_time(emac->emac_base_va, sec, nsec, sec_hi);
+		}
 
 		if (EOK != oal_mutex_unlock(&emac->ts_mutex))
 		{
@@ -1992,21 +2003,16 @@ uint32_t pfe_emac_get_tx_cnt(const pfe_emac_t *emac)
 	return tx_cnt;
 }
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-
 /**
  * @brief		Return EMAC runtime statistics in text form
  * @details		Function writes formatted text into given buffer.
  * @param[in]	gpi 		The EMAC instance
- * @param[in]	buf 		Pointer to the buffer to write to
- * @param[in]	size 		Buffer length
+ * @param[in]	seq			Pointer to debugfs seq_file
  * @param[in]	verb_level 	Verbosity level
  * @return		Number of bytes written to the buffer
  */
-uint32_t pfe_emac_get_text_statistics(const pfe_emac_t *emac, char_t *buf, uint32_t buf_len, uint8_t verb_level)
+uint32_t pfe_emac_get_text_statistics(const pfe_emac_t *emac, struct seq_file *seq, uint8_t verb_level)
 {
-	uint32_t len = 0U;
-
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == emac))
 	{
@@ -2015,13 +2021,11 @@ uint32_t pfe_emac_get_text_statistics(const pfe_emac_t *emac, char_t *buf, uint3
 	}
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
-	{
-		len += pfe_emac_cfg_get_text_stat(emac->emac_base_va, buf + len, buf_len - len, verb_level);
-	}
-	return len;
-}
 
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
+	pfe_emac_cfg_get_text_stat(emac->emac_base_va, seq, verb_level);
+
+	return 0;
+}
 
 /**
  * @brief		Get EMAC statistic in numeric form
@@ -2097,8 +2101,3 @@ void pfe_emac_irq_unmask(pfe_emac_t *emac)
 	(void)emac;
 }
 
-#ifdef PFE_CFG_TARGET_OS_AUTOSAR
-#define ETH_43_PFE_STOP_SEC_CODE
-#include "Eth_43_PFE_MemMap.h"
-#endif /* PFE_CFG_TARGET_OS_AUTOSAR */
-
diff --git a/sw/pfe_platform/src/pfe_gpi.c b/sw/pfe_platform/src/pfe_gpi.c
index a5a3c1f..0d2904e 100644
--- a/sw/pfe_platform/src/pfe_gpi.c
+++ b/sw/pfe_platform/src/pfe_gpi.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -1455,25 +1455,19 @@ errno_t pfe_gpi_shp_get_drop_cnt(const pfe_gpi_t *gpi, uint8_t id, uint32_t *cnt
  * @brief		Return GPI runtime statistics in text form
  * @details		Function writes formatted text into given buffer.
  * @param[in]	gpi 		The GPI instance
- * @param[in]	buf 		Pointer to the buffer to write to
- * @param[in]	buf_len 	Buffer length
+ * @param[in]	seq			Pointer to debugfs seq_file
  * @param[in]	verb_level 	Verbosity level
  * @return		Number of bytes written to the buffer
  */
-uint32_t pfe_gpi_get_text_statistics(const pfe_gpi_t *gpi, char_t *buf, uint32_t buf_len, uint8_t verb_level)
+uint32_t pfe_gpi_get_text_statistics(const pfe_gpi_t *gpi, struct seq_file *seq, uint8_t verb_level)
 {
-	uint32_t len = 0U;
 	errno_t  ret = pfe_gpi_null_arg_check_return(gpi, EINVAL);
-	if (ret != EOK)
-	{
-		len = 0U;
-	}
-	else
+	if (ret == EOK)
 	{
-		len += pfe_gpi_cfg_get_text_stat(gpi->gpi_base_va, buf, buf_len, verb_level);
+		pfe_gpi_cfg_get_text_stat(gpi->gpi_base_va, seq, verb_level);
 	}
 
-	return len;
+	return 0;
 }
 
 #endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
diff --git a/sw/pfe_platform/src/pfe_hif_chnl_linux.c b/sw/pfe_platform/src/pfe_hif_chnl_linux.c
index 0e5b0e8..cdc6847 100644
--- a/sw/pfe_platform/src/pfe_hif_chnl_linux.c
+++ b/sw/pfe_platform/src/pfe_hif_chnl_linux.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -1819,11 +1819,10 @@ __attribute__((cold)) void pfe_hif_chnl_destroy(pfe_hif_chnl_t *chnl)
  * @param[in]	chnl The client channel instance
  * @param[in]	dump_rx True if RX ring has to be dumped
  * @param[in]	dump_tx True if TX ring has to be dumped
- * @param[in]	buf 		Pointer to the buffer to write to
- * @param[in]	size 		Buffer length
+ * @param[in]	seq			Pointer to debugfs seq_file
  * @param[in]	verb_level 	Verbosity level, number of data written to the buffer
  */
-__attribute__((cold)) uint32_t pfe_hif_chnl_dump_ring(const pfe_hif_chnl_t *chnl, bool_t dump_rx, bool_t dump_tx, char_t *buf, uint32_t size, uint8_t verb_level)
+__attribute__((cold)) uint32_t pfe_hif_chnl_dump_ring(const pfe_hif_chnl_t *chnl, bool_t dump_rx, bool_t dump_tx, struct seq_file *seq, uint8_t verb_level)
 {
 	uint32_t len = 0;
 
@@ -1837,12 +1836,12 @@ __attribute__((cold)) uint32_t pfe_hif_chnl_dump_ring(const pfe_hif_chnl_t *chnl
 
 	if(dump_rx)
 	{
-		len += pfe_hif_ring_dump(chnl->rx_ring, "RX", buf + len, size - len, verb_level);
+		len += pfe_hif_ring_dump(chnl->rx_ring, "RX", seq, verb_level);
 	}
 
 	if(dump_tx)
 	{
-		len += pfe_hif_ring_dump(chnl->tx_ring, "TX", buf + len, size - len, verb_level);
+		len += pfe_hif_ring_dump(chnl->tx_ring, "TX", seq, verb_level);
 	}
 
 	return len;
@@ -1888,15 +1887,12 @@ uint32_t pfe_hif_chnl_get_rx_cnt(const pfe_hif_chnl_t *chnl)
  * @brief		Return HIF channel runtime statistics in text form
  * @details		Function writes formatted text into given buffer.
  * @param[in]	chnl 		The channel instance
- * @param[in]	buf 		Pointer to the buffer to write to
- * @param[in]	buf_len 	Buffer length
+ * @param[in]	seq			Pointer to debugfs seq_file
  * @param[in]	verb_level 	Verbosity level, number of data written to the buffer
  * @return		Number of bytes written to the buffe
  */
-__attribute__((cold)) uint32_t pfe_hif_chnl_get_text_statistics(const pfe_hif_chnl_t *chnl, char_t *buf, uint32_t buf_len, uint8_t verb_level)
+__attribute__((cold)) uint32_t pfe_hif_chnl_get_text_statistics(const pfe_hif_chnl_t *chnl, struct seq_file *seq, uint8_t verb_level)
 {
-	uint32_t len = 0U;
-
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == chnl))
 	{
@@ -1906,12 +1902,12 @@ __attribute__((cold)) uint32_t pfe_hif_chnl_get_text_statistics(const pfe_hif_ch
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
 	/*	HIF */
-	len += pfe_hif_chnl_cfg_get_text_stat(chnl->cbus_base_va, chnl->id, buf, buf_len, verb_level);
+	pfe_hif_chnl_cfg_get_text_stat(chnl->cbus_base_va, chnl->id, seq, verb_level);
 
 	if (verb_level >= 9)
-		len += pfe_hif_chnl_dump_ring(chnl, TRUE, TRUE, buf + len, buf_len - len, verb_level);
+		pfe_hif_chnl_dump_ring(chnl, TRUE, TRUE, seq, verb_level);
 
-	return len;
+	return 0;
 }
 
 /**
@@ -1932,4 +1928,4 @@ bool_t pfe_hif_chnl_tx_fifo_is_below_wm(const pfe_hif_chnl_t *chnl)
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
     return pfe_hif_ring_is_below_wm(chnl->tx_ring);
-}
\ No newline at end of file
+}
diff --git a/sw/pfe_platform/src/pfe_hif_ring_linux.c b/sw/pfe_platform/src/pfe_hif_ring_linux.c
index 3e0e88d..1ef33da 100644
--- a/sw/pfe_platform/src/pfe_hif_ring_linux.c
+++ b/sw/pfe_platform/src/pfe_hif_ring_linux.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -675,13 +675,12 @@ __attribute__((cold)) static void pfe_hif_ring_invalidate_std(const pfe_hif_ring
  * @details		Dumps particular ring
  * @param[in]	ring The ring instance
  * @param[in]	name The ring name
- * @param[in]	buf 		Pointer to the buffer to write to
- * @param[in]	size 		Buffer length
+ * @param[in]	seq			Pointer to debugfs seq_file
  * @param[in]	verb_level 	Verbosity level, number of data written to the buffer
  * @return		Number of bytes written to the buffer
  * @note		Must not be preempted by: pfe_hif_ring_enqueue_buf(), pfe_hif_ring_destroy()
  */
-__attribute__((cold)) uint32_t pfe_hif_ring_dump(pfe_hif_ring_t *ring, char_t *name, char_t *buf, uint32_t size, uint8_t verb_level)
+__attribute__((cold)) uint32_t pfe_hif_ring_dump(pfe_hif_ring_t *ring, char_t *name, struct seq_file *seq, uint8_t verb_level)
 {
 	uint32_t ii;
 	uint32_t len = 0U;
@@ -695,9 +694,9 @@ __attribute__((cold)) uint32_t pfe_hif_ring_dump(pfe_hif_ring_t *ring, char_t *n
 	}
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
-	len += (uint32_t)oal_util_snprintf(buf + len, size - len, "Ring %s: len %d\n", name, RING_LEN);
-	len += (uint32_t)oal_util_snprintf(buf + len, size - len, "  Type: %s\n", ring->is_rx ? "RX" : "TX");
-	len += (uint32_t)oal_util_snprintf(buf + len, size - len, "  Index w/r: %d/%d (%d/%d)\n", ring->write_idx & RING_LEN_MASK, ring->read_idx & RING_LEN_MASK, ring->write_idx, ring->read_idx);
+	seq_printf(seq, "Ring %s: len %d\n", name, RING_LEN);
+	seq_printf(seq, "  Type: %s\n", ring->is_rx ? "RX" : "TX");
+	seq_printf(seq, "  Index w/r: %d/%d (%d/%d)\n", ring->write_idx & RING_LEN_MASK, ring->read_idx & RING_LEN_MASK, ring->write_idx, ring->read_idx);
 
 	if(verb_level >= 8) {
 		/* BD ring */
@@ -707,8 +706,8 @@ __attribute__((cold)) uint32_t pfe_hif_ring_dump(pfe_hif_ring_t *ring, char_t *n
 			pfe_hif_bd_t *bd = &(((pfe_hif_bd_t *)ring->base_va)[ii]);
 			if (0 == ii)
 			{
-				len += (uint32_t)oal_util_snprintf(buf + len, size - len, "  BD va/pa v0x%px/p0x%px\n", ring->base_va, ring->base_pa);
-				len += (uint32_t)oal_util_snprintf(buf + len, size - len, "            pa           idx: bufl:ctrl: status :  data  :  next  :seqn\n");
+				seq_printf(seq, "  BD va/pa v0x%px/p0x%px\n", ring->base_va, ring->base_pa);
+				seq_printf(seq, "            pa           idx: bufl:ctrl: status :  data  :  next  :seqn\n");
 			}
 
 			if ((ring->write_idx & RING_LEN_MASK) == ii)
@@ -724,7 +723,7 @@ __attribute__((cold)) uint32_t pfe_hif_ring_dump(pfe_hif_ring_t *ring, char_t *n
 				idx_str = "";
 			}
 
-			len += (uint32_t)oal_util_snprintf(buf + len, size - len, "    p0x%px%5d: %04x:%04x:%08x:%08x:%04x%s\n",(void *)&((pfe_hif_bd_t *)ring->base_pa)[ii], ii, HIF_RING_BD_W1_BD_BUFFLEN_GET(bd->rsvd_buflen_w1), HIF_RING_BD_W0_BD_CTRL_GET(bd->ctrl_seqnum_w0), bd->data, bd->next, HIF_RING_BD_W0_BD_SEQNUM_GET(bd->ctrl_seqnum_w0), idx_str);
+			seq_printf(seq, "    p0x%px%5d: %04x:%04x:%08x:%08x:%04x%s\n",(void *)&((pfe_hif_bd_t *)ring->base_pa)[ii], ii, HIF_RING_BD_W1_BD_BUFFLEN_GET(bd->rsvd_buflen_w1), HIF_RING_BD_W0_BD_CTRL_GET(bd->ctrl_seqnum_w0), bd->data, bd->next, HIF_RING_BD_W0_BD_SEQNUM_GET(bd->ctrl_seqnum_w0), idx_str);
 		}
 
 		/* WB ring */
@@ -734,8 +733,8 @@ __attribute__((cold)) uint32_t pfe_hif_ring_dump(pfe_hif_ring_t *ring, char_t *n
 				pfe_hif_wb_bd_t *wb = &(((pfe_hif_wb_bd_t *)ring->wb_tbl_base_va)[ii]);
 				if (0 == ii)
 				{
-					len += (uint32_t)oal_util_snprintf(buf + len, size - len, "  WB va/pa v0x%px/p0x%px\n", ring->wb_tbl_base_va, ring->wb_tbl_base_pa);
-					len += (uint32_t)oal_util_snprintf(buf + len, size - len, "    pa:      idx:  ctl: rsvd :bufl:seqn\n");
+					seq_printf(seq, "  WB va/pa v0x%px/p0x%px\n", ring->wb_tbl_base_va, ring->wb_tbl_base_pa);
+					seq_printf(seq, "            pa           idx:  ctl: rsvd :bufl:seqn\n");
 				}
 
 				if ((ring->read_idx & RING_LEN_MASK) == ii)
@@ -747,7 +746,7 @@ __attribute__((cold)) uint32_t pfe_hif_ring_dump(pfe_hif_ring_t *ring, char_t *n
 					idx_str = "";
 				}
 
-				len += (uint32_t)oal_util_snprintf(buf + len, size - len, "    p0x%px%5d: %04x:%06x:%04x:%04x%s\n", (void *)&((pfe_hif_wb_bd_t *)ring->wb_tbl_base_pa)[ii], ii, HIF_RING_BD_W0_BD_CTRL(wb->rsvd_ctrl_w0), HIF_RING_WB_BD_W1_WB_BD_BUFFLEN(wb->seqnum_buflen_w1), HIF_RING_WB_BD_W1_WB_BD_SEQNUM(wb->seqnum_buflen_w1), idx_str);
+				seq_printf(seq, "    p0x%px%5d: %04x:%06x:%04x:%s\n", (void *)&((pfe_hif_wb_bd_t *)ring->wb_tbl_base_pa)[ii], ii, HIF_RING_BD_W0_BD_CTRL(wb->rsvd_ctrl_w0), HIF_RING_WB_BD_W1_WB_BD_BUFFLEN(wb->seqnum_buflen_w1), HIF_RING_WB_BD_W1_WB_BD_SEQNUM(wb->seqnum_buflen_w1), idx_str);
 			}
 		}
 	}
diff --git a/sw/pfe_platform/src/pfe_hm.c b/sw/pfe_platform/src/pfe_hm.c
index 2793cd5..d94e072 100644
--- a/sw/pfe_platform/src/pfe_hm.c
+++ b/sw/pfe_platform/src/pfe_hm.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2022 NXP
+ *  Copyright 2022-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -220,7 +220,7 @@ errno_t pfe_hm_destroy(void)
  * @param[in]	id		ID of the event
  * @param[in]	format	NULL or printf like formatted string
  */
-void pfe_hm_report(pfe_hm_src_t src, pfe_hm_type_t type, pfe_hm_evt_t id, void *dev,
+void pfe_hm_report(pfe_hm_src_t src, pfe_hm_type_t type, pfe_hm_evt_t id, pfe_hm_log_t hm_log,
 		const char *format, ...)
 {
 	pfe_hm_item_t item;
@@ -247,58 +247,58 @@ void pfe_hm_report(pfe_hm_src_t src, pfe_hm_type_t type, pfe_hm_evt_t id, void *
 	item.descr[0] = '\0';
 #endif	/** PFE_CFG_TARGET_OS_AUTOSAR */
 
-	if (HM_SRC_PFENG_DEV == src)
+	if (NXP_LOG_TYPE_DEV == hm_log.log_type)
 	{
 		switch (type)
 		{
 #ifdef PFE_CFG_HM_STRINGS_ENABLED
 			case HM_INFO:
-				HM_MSG_HM_DEV_INFO(dev, "(%s) event %d - %s%s%s", src_str, (int)id, event_str, separator, item.descr);
+				HM_MSG_HM_DEV_INFO(hm_log.log_dev, "(%s) event %d - %s%s%s", src_str, (int)id, event_str, separator, item.descr);
 				break;
 			case HM_WARNING:
-				HM_MSG_HM_DEV_WARN(dev, "(%s) event %d - %s%s%s", src_str, (int)id, event_str, separator, item.descr);
+				HM_MSG_HM_DEV_WARN(hm_log.log_dev, "(%s) event %d - %s%s%s", src_str, (int)id, event_str, separator, item.descr);
 				break;
 			case HM_ERROR:
-				HM_MSG_HM_DEV_ERR(dev, "(%s) event %d - %s%s%s", src_str, (int)id, event_str, separator, item.descr);
+				HM_MSG_HM_DEV_ERR(hm_log.log_dev, "(%s) event %d - %s%s%s", src_str, (int)id, event_str, separator, item.descr);
 				break;
 #else
 			case HM_INFO:
-				HM_MSG_HM_DEV_INFO(dev, "(%d) event %d%s%s", (int)src, (int)id, separator, item.descr);
+				HM_MSG_HM_DEV_INFO(hm_log.log_dev, "(%d) event %d%s%s", (int)src, (int)id, separator, item.descr);
 				break;
 			case HM_WARNING:
-				HM_MSG_HM_DEV_WARN(dev, "(%d) event %d%s%s", (int)src, (int)id, separator, item.descr);
+				HM_MSG_HM_DEV_WARN(hm_log.log_dev, "(%d) event %d%s%s", (int)src, (int)id, separator, item.descr);
 				break;
 			case HM_ERROR:
-				HM_MSG_HM_DEV_ERR(dev, "(%d) event %d%s%s", (int)src, (int)id, separator, item.descr);
+				HM_MSG_HM_DEV_ERR(hm_log.log_dev, "(%d) event %d%s%s", (int)src, (int)id, separator, item.descr);
 				break;
 #endif /* PFE_CFG_HM_STRINGS_ENABLED */
 			default:
 				break;
 		}
 	}
-	else if (HM_SRC_PFENG_NETDEV == src)
+	else if (NXP_LOG_TYPE_NETDEV == hm_log.log_type)
 	{
 		switch (type)
 		{
 #ifdef PFE_CFG_HM_STRINGS_ENABLED
 			case HM_INFO:
-				HM_MSG_HM_NETDEV_INFO(dev, "(%s) event %d - %s%s%s", src_str, (int)id, event_str, separator, item.descr);
+				HM_MSG_HM_NETDEV_INFO(hm_log.log_netdev, "(%s) event %d - %s%s%s", src_str, (int)id, event_str, separator, item.descr);
 				break;
 			case HM_WARNING:
-				HM_MSG_HM_NETDEV_WARN(dev, "(%s) event %d - %s%s%s", src_str, (int)id, event_str, separator, item.descr);
+				HM_MSG_HM_NETDEV_WARN(hm_log.log_netdev, "(%s) event %d - %s%s%s", src_str, (int)id, event_str, separator, item.descr);
 				break;
 			case HM_ERROR:
-				HM_MSG_HM_NETDEV_ERR(dev, "(%s) event %d - %s%s%s", src_str, (int)id, event_str, separator, item.descr);
+				HM_MSG_HM_NETDEV_ERR(hm_log.log_netdev, "(%s) event %d - %s%s%s", src_str, (int)id, event_str, separator, item.descr);
 				break;
 #else
 			case HM_INFO:
-				HM_MSG_HM_NETDEV_INFO(dev, "(%d) event %d%s%s", (int)src, (int)id, separator, item.descr);
+				HM_MSG_HM_NETDEV_INFO(hm_log.log_netdev, "(%d) event %d%s%s", (int)src, (int)id, separator, item.descr);
 				break;
 			case HM_WARNING:
-				HM_MSG_HM_NETDEV_WARN(dev, "(%d) event %d%s%s", (int)src, (int)id, separator, item.descr);
+				HM_MSG_HM_NETDEV_WARN(hm_log.log_netdev, "(%d) event %d%s%s", (int)src, (int)id, separator, item.descr);
 				break;
 			case HM_ERROR:
-				HM_MSG_HM_NETDEV_ERR(dev, "(%d) event %d%s%s", (int)src, (int)id, separator, item.descr);
+				HM_MSG_HM_NETDEV_ERR(hm_log.log_netdev, "(%d) event %d%s%s", (int)src, (int)id, separator, item.descr);
 				break;
 #endif /* PFE_CFG_HM_STRINGS_ENABLED */
 			default:
diff --git a/sw/pfe_platform/src/pfe_hw_feature.c b/sw/pfe_platform/src/pfe_hw_feature.c
index 00c6e9e..55822d9 100644
--- a/sw/pfe_platform/src/pfe_hw_feature.c
+++ b/sw/pfe_platform/src/pfe_hw_feature.c
@@ -1,5 +1,5 @@
 /* =========================================================================
- *  Copyright 2021-2022 NXP
+ *  Copyright 2021-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -110,7 +110,7 @@ errno_t pfe_hw_feature_init_all(const uint32_t *cbus_base, pfe_hw_feature_t **hw
 
 	if (EOK == ret)
 	{
-		feature = pfe_hw_feature_create("jumbo_frames", "Active if we handle jumbo frames", F_NONE, 0);
+		feature = pfe_hw_feature_create("jumbo_frames", "Active if we handle jumbo frames", F_PRESENT, 1);
 		if (NULL != feature)
 		{
 			hw_features[1] = feature;
diff --git a/sw/pfe_platform/src/pfe_l2br.c b/sw/pfe_platform/src/pfe_l2br.c
index 38aa030..2106a90 100644
--- a/sw/pfe_platform/src/pfe_l2br.c
+++ b/sw/pfe_platform/src/pfe_l2br.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -63,6 +63,7 @@ struct __pfe_l2br_tag
 	uint16_t def_vlan;							/*!< Default VLAN */
 	uint32_t dmem_fb_bd_base;					/*!< Address within classifier memory where the fall-back bridge domain structure is located */
 	uint32_t dmem_def_bd_base;					/*!< Address within classifier memory where the default bridge domain structure is located */
+	uint32_t dmem_vlan_hash_base;
 	oal_mutex_t *mutex;							/*!< Mutex protecting shared resources */
 	pfe_l2br_domain_get_crit_t cur_crit;		/*!< Current 'get' criterion (to get domains) */
 	pfe_l2br_static_ent_get_crit_t cur_crit_ent;/*!< Current 'get' criterion (to get static entry) */
@@ -142,6 +143,33 @@ typedef enum
 	PFE_L2BR_FLUSH_LEARNED_MAC
 } pfe_l2br_flush_types;
 
+/**
+ * @brief	Flags for 2-field MAC table entry (flags)
+ */
+typedef enum
+{
+	MAC_VALID_FLAG = (1U << 3),         /*!< MAC_ENTRY_VALID_FLAG */
+	MAC_COL_PTR_VALID_FLAG = (1U << 2), /*!< MAC_ENTRY_COL_PTR_VALID_FLAG */
+	MAC_RESERVED1_FLAG = (1U << 1),     /*!< MAC_ENTRY_RESERVED1_FLAG */
+	MAC_RESERVED2_FLAG = (1U << 0)      /*!< MAC_ENTRY_RESERVED2_FLAG */
+} pfe_l2br_table_entry_flags_t;
+
+/**
+ * @brief	Valid flags for 2-field MAC table entry (pfe_mac2f_table_entry_t.field_valids)
+ */
+typedef enum
+{
+	MAC_ENTRY_MAC_VALID = (1U << 0),   		/*!< (Field1 = MAC Valid)	*/
+	MAC_ENTRY_VLAN_VALID = (1U << 1),   		/*!< (Field2 = VLAN Valid)	*/
+	MAC_ENTRY_RESERVED1_VALID = (1U << 2),   	/*!< RESERVED				*/
+	MAC_ENTRY_RESERVED2_VALID = (1U << 3),   	/*!< RESERVED				*/
+	MAC_ENTRY_RESERVED3_VALID = (1U << 4),   	/*!< RESERVED				*/
+	MAC_ENTRY_RESERVED4_VALID = (1U << 5),	/*!< RESERVED				*/
+	MAC_ENTRY_RESERVED5_VALID = (1U << 6),	/*!< RESERVED				*/
+	MAC_ENTRY_RESERVED6_VALID = (1U << 7),	/*!< RESERVED				*/
+} pfe_l2br_table_entry_valid_bits_t;
+
+
 #define VLAN_STATS_VEC_SIZE 128
 
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
@@ -207,6 +235,11 @@ static errno_t pfe_bd_write_to_class(const pfe_l2br_t *bridge, uint32_t base, co
 	return ret;
 }
 
+/**
+ * @brief		Write bridge domain structure to classifier memory
+ * @param[in]	domain Pointer to the structure to be written
+ * @param[in]	base Memory location where to write
+ */
 static void pfe_l2br_update_hw_ll_entry(pfe_l2br_domain_t *domain, uint32_t base)
 {
 	pfe_ct_bd_entry_t sw_bd;
@@ -254,6 +287,372 @@ static void pfe_l2br_update_hw_ll_entry(pfe_l2br_domain_t *domain, uint32_t base
 	}
 }
 
+/**
+ * @brief		Get hash of a vlan id
+ * @param[in]	vlan_id from witch the hash is computed
+ * @retval		Hash of the vlan id
+ */
+static inline uint8_t fp_l2br_vlan_table_get_hash(uint16_t vlan_id)
+{
+	return (uint8_t)(vlan_id & 0x3FU);
+}
+
+/**
+ * @brief		Write vlan entry to classifier memory
+ * @param[in]	bridge The bridge instance
+ * @param[in]	pos Entry position in vlan table
+ * @param[in]	class_entry Pointer to the structure to be written
+ */
+static void pfe_vlan_write_to_class(const pfe_l2br_t *bridge, uint32_t pos, const l2br_vlan_hash_entry_t *class_entry)
+{
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (unlikely((NULL == class_entry) || (NULL == bridge) || (0U == pos)))
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		ret = EINVAL;
+	}
+	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		if (EOK != pfe_class_write_dmem(bridge->class, -1, (addr_t)(bridge->dmem_vlan_hash_base + pos*sizeof(l2br_vlan_hash_entry_t)), (const void *)class_entry, sizeof(l2br_vlan_hash_entry_t)))
+		{
+			NXP_LOG_ERROR("Class memory write failed\n");
+		}
+	}
+	return;
+}
+
+/**
+ * @brief		Read vlan entry to classifier memory
+ * @param[in]	bridge The bridge instance
+ * @param[in]	pos Entry position in vlan table
+ * @param[out]	class_entry Pointer to the structure to be read
+ */
+static void pfe_vlan_read_from_class(const pfe_l2br_t *bridge, uint32_t pos, l2br_vlan_hash_entry_t *class_entry)
+{
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (unlikely((NULL == class_entry) || (NULL == bridge) || (0U == pos)))
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		ret = EINVAL;
+	}
+	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		if (EOK != pfe_class_read_dmem(bridge->class, 0, class_entry, (addr_t)(bridge->dmem_vlan_hash_base + pos*sizeof(l2br_vlan_hash_entry_t)), sizeof(l2br_vlan_hash_entry_t)))
+		{
+			NXP_LOG_ERROR("Class memory read failed\n");
+		}
+	}
+	return;
+}
+
+/**
+ * @brief		Fill vlan entry based on domain information
+ * @param[in]	domain Pointer to vlan domain entry
+ * @param[out]	entry Pointer to the class structure
+ */
+static void pfe_l2br_vlan_action_to_entry(pfe_l2br_domain_t *domain, l2br_vlan_hash_entry_t *entry)
+{
+	uint64_t tmp64;
+	bool_t need_shift = FALSE;
+
+	entry->vlan = oal_htons(domain->vlan);
+	tmp64 = (1ULL << 63);
+	(void)memcpy(&entry->entry.val, &tmp64, sizeof(uint64_t));
+
+	if (0U == entry->entry.val)
+	{
+		need_shift = TRUE;
+	}
+
+	/*      Convert VLAN table result to fallback domain representation */
+	entry->entry.val = domain->u.action_data.val;
+
+	if (TRUE == need_shift)
+	{
+		tmp64 = (uint64_t)entry->entry.val << 9;
+		(void)memcpy(&entry->entry.val, &tmp64, sizeof(uint64_t));
+	}
+
+	/*      Convert to network endian */
+	tmp64 = cpu_to_be64p((uint64_t *)&entry->entry.val);
+	(void)memcpy(&entry->entry.val, &tmp64, sizeof(uint64_t));
+
+	entry->flags = MAC_VALID_FLAG;
+	entry->field_valids = MAC_ENTRY_VLAN_VALID;
+
+	return;
+}
+
+/**
+ * @brief		Find and update a given vlan domain to vlan class memory.
+ * @param[in]	domain Pointer to vlan domain structure to update.
+ * @retval		EOK Success
+ * @retval		EINVAL Invalid or missing argument
+ * @retval		ENOENT Vlan is not in class memory
+ */
+errno_t pfe_l2br_update_vlan_hash_entry(pfe_l2br_domain_t *domain)
+{
+	l2br_vlan_hash_entry_t vlan_new_entry, vlan_current_entry;
+	uint8_t pos;
+	errno_t ret = ENOENT;
+
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (unlikely(NULL == domain))
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		ret = EINVAL;
+	}
+	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+		(void)memset(&vlan_new_entry, 0, sizeof(l2br_vlan_hash_entry_t));
+		(void)memset(&vlan_current_entry, 0, sizeof(l2br_vlan_hash_entry_t));
+
+		pfe_l2br_vlan_action_to_entry(domain, &vlan_new_entry);
+
+		/*Read the entry at the vlan hash position*/
+		pos = fp_l2br_vlan_table_get_hash(domain->vlan);
+		pfe_vlan_read_from_class(domain->bridge, pos, &vlan_current_entry);
+
+		/*If the vlan exists in hash update the entry */
+		if (vlan_current_entry.vlan == vlan_new_entry.vlan)
+		{
+			vlan_current_entry.entry.val = vlan_new_entry.entry.val;
+			vlan_current_entry.flags |= MAC_VALID_FLAG;
+			vlan_current_entry.field_valids |= MAC_ENTRY_VLAN_VALID;
+
+			pfe_vlan_write_to_class(domain->bridge, pos, &vlan_current_entry);
+			ret = EOK;
+		}
+		else
+		{
+			/*entry is full with other entry find a place in collision*/
+			if (vlan_current_entry.flags & MAC_VALID_FLAG)
+			{
+				/*go through all callisions*/
+				while (vlan_current_entry.flags & MAC_COL_PTR_VALID_FLAG)
+				{
+					pos = oal_ntohs(vlan_current_entry.col_ptr);
+					pfe_vlan_read_from_class(domain->bridge, pos, &vlan_current_entry);
+					if (vlan_new_entry.vlan == vlan_current_entry.vlan)
+					{
+						pfe_vlan_write_to_class(domain->bridge, pos, &vlan_new_entry);
+						/*Found the entry in the collision domain*/
+						ret = EOK;
+						break;
+					}
+				}
+			}
+		}
+	}
+
+	return ret;
+}
+
+/**
+ * @brief		Find the position and add a given vlan domain to vlan class memory.
+ * @param[in]	domain Pointer to vlan domain structure to add.
+ * @retval		EOK Success
+ * @retval		EINVAL Invalid or missing argument
+ * @retval		EEXIST Vlan already exists in class memory
+ */
+errno_t pfe_l2br_add_vlan_hash_entry(pfe_l2br_domain_t *domain)
+{
+	l2br_vlan_hash_entry_t vlan_new_entry, vlan_current_entry, vlan_tmp_entry;	
+	uint8_t pos, prev_entry_pos, hash_size = 0, coll_space = 0;
+	errno_t  ret = EOK;
+
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (unlikely(NULL == domain))
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		ret = EINVAL;
+	}
+	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+
+		(void)memset(&vlan_new_entry, 0, sizeof(l2br_vlan_hash_entry_t));
+		(void)memset(&vlan_current_entry, 0, sizeof(l2br_vlan_hash_entry_t));
+		(void)memset(&vlan_tmp_entry, 0, sizeof(l2br_vlan_hash_entry_t));
+
+		ret = pfe_feature_mgr_table_get_payload("software_vlan_table", FW_FEATURE_TABLE_CONFIG, "size", &hash_size);
+		if (EOK != ret)
+		{
+			NXP_LOG_ERROR("Wrong vlan software table config size\n");
+			return ret;
+		}
+
+		ret = pfe_feature_mgr_table_get_payload("software_vlan_table", FW_FEATURE_TABLE_CONFIG, "coll_space", &coll_space);
+		if (EOK != ret)
+		{
+			NXP_LOG_ERROR("Wrong vlan software table config collision space\n");
+			return ret;
+		}
+
+		pfe_l2br_vlan_action_to_entry(domain, &vlan_new_entry);
+
+		/*Read the entry at the vlan hash position*/
+		pos = fp_l2br_vlan_table_get_hash(domain->vlan);
+		pfe_vlan_read_from_class(domain->bridge, pos, &vlan_current_entry);
+
+		/*If the vlan exists in hash update the entry */
+		if (vlan_current_entry.vlan == vlan_new_entry.vlan)
+		{
+			ret = EEXIST;
+		}
+		else
+		{
+			/*entry is full with other entry find a place in collision*/
+			if (vlan_current_entry.flags & MAC_VALID_FLAG)
+			{
+				prev_entry_pos = pos;
+				/*go through all callisions*/
+				while (vlan_current_entry.flags & MAC_COL_PTR_VALID_FLAG)
+				{
+					pos = oal_ntohs(vlan_current_entry.col_ptr);
+					prev_entry_pos = pos;
+					pfe_vlan_read_from_class(domain->bridge, pos, &vlan_current_entry);
+					if (vlan_new_entry.vlan == vlan_current_entry.vlan)
+					{
+						/*Found the entry in the collision domain*/
+						ret = EEXIST;
+						break;
+					}
+				}
+
+				if (vlan_new_entry.vlan != vlan_current_entry.vlan)
+				{
+					/*The new entry is not in collision. Find a place to add entry */
+					vlan_tmp_entry = vlan_current_entry;
+
+					if (pos < coll_space)
+					{
+						pos = coll_space;
+						pfe_vlan_read_from_class(domain->bridge, pos, &vlan_tmp_entry);
+					}
+					/*Find the first free postion in the collision*/
+					while (vlan_tmp_entry.flags & MAC_VALID_FLAG) 
+					{
+						pos ++;
+						if (pos >= hash_size)
+						{
+							ret =  ENOMEM;
+							break;
+						}	
+						pfe_vlan_read_from_class(domain->bridge, pos, &vlan_tmp_entry);
+					}
+					if (pos < hash_size)
+					{
+						/*   Write the new entry to pos */
+						pfe_vlan_write_to_class(domain->bridge, pos, &vlan_new_entry);
+
+						/*Update prev vlan id with collision pointer to the new vlan entry*/
+						vlan_current_entry.flags |= MAC_COL_PTR_VALID_FLAG;
+						vlan_current_entry.col_ptr = oal_htons(pos);
+						pfe_vlan_write_to_class(domain->bridge, prev_entry_pos, &vlan_current_entry);
+					}
+				}
+			}
+			else
+			{
+				/*   Write the new entry in hash */
+				pfe_vlan_write_to_class(domain->bridge, pos, &vlan_new_entry);
+			}
+		}
+	}
+
+	return ret;
+}
+
+/**
+ * @brief		Delete a given vlan domain from vlan class memory.
+ * @param[in]	domain Pointer to vlan domain structure to be removed.
+ * @retval		EOK Success
+ * @retval		EINVAL Invalid or missing argument
+ **/
+errno_t pfe_l2br_delete_vlan_hash_entry(pfe_l2br_domain_t *domain)
+{
+	l2br_vlan_hash_entry_t vlan_zero_entry, vlan_current_entry, vlan_prev_entry, vlan_tmp_entry;
+	uint8_t pos, prev_entry_pos, next_entry_pos;
+	bool erase_collision_entry = FALSE;
+	errno_t  ret = EOK;
+
+#if defined(PFE_CFG_NULL_ARG_CHECK)
+	if (unlikely(NULL == domain))
+	{
+		NXP_LOG_ERROR("NULL argument received\n");
+		ret = EINVAL;
+	}
+	else
+#endif /* PFE_CFG_NULL_ARG_CHECK */
+	{
+
+		(void)memset(&vlan_zero_entry, 0, sizeof(l2br_vlan_hash_entry_t));
+		(void)memset(&vlan_current_entry, 0, sizeof(l2br_vlan_hash_entry_t));
+		(void)memset(&vlan_prev_entry, 0, sizeof(l2br_vlan_hash_entry_t));
+		(void)memset(&vlan_tmp_entry, 0, sizeof(l2br_vlan_hash_entry_t));
+
+		pos = fp_l2br_vlan_table_get_hash(domain->vlan);
+		pfe_vlan_read_from_class(domain->bridge, pos, &vlan_current_entry);
+
+		/*If the entry is in hash*/
+		if (domain->vlan == oal_ntohs(vlan_current_entry.vlan))
+		{
+			/*If the entry has collision*/
+			if (vlan_current_entry.flags & MAC_COL_PTR_VALID_FLAG)
+			{
+				next_entry_pos = oal_ntohs(vlan_current_entry.col_ptr);
+				pfe_vlan_read_from_class(domain->bridge, next_entry_pos, &vlan_tmp_entry);
+				erase_collision_entry = TRUE;
+			}
+			/*Write to hash the next collision entry*/
+			pfe_vlan_write_to_class(domain->bridge, pos, &vlan_tmp_entry);
+
+			if (TRUE == erase_collision_entry)
+			{
+				pfe_vlan_write_to_class(domain->bridge, next_entry_pos, &vlan_zero_entry);
+			}
+		}
+		else
+		{
+			/*go through all collisions*/
+			while (vlan_current_entry.flags & MAC_COL_PTR_VALID_FLAG)
+			{
+				prev_entry_pos = pos;
+				vlan_prev_entry = vlan_current_entry;
+
+				pos = oal_ntohs(vlan_current_entry.col_ptr);
+				pfe_vlan_read_from_class(domain->bridge, pos, &vlan_current_entry);
+
+				/* entry found */
+				if (domain->vlan == oal_ntohs(vlan_current_entry.vlan))
+				{
+					/* there is an entry after in collision */
+					if (vlan_current_entry.flags & MAC_COL_PTR_VALID_FLAG)
+					{
+						vlan_prev_entry.col_ptr = vlan_current_entry.col_ptr;
+					}
+					else
+					{
+						vlan_prev_entry.flags = 0;
+						vlan_prev_entry.col_ptr = 0;
+					}
+					/* Update collision pointer on the prev position*/
+					pfe_vlan_write_to_class(domain->bridge, prev_entry_pos, &vlan_prev_entry);
+
+					pfe_vlan_write_to_class(domain->bridge, pos, &vlan_zero_entry);
+					break;
+				}
+			}
+		}
+	}
+
+	return ret;
+}
+
 /**
  * @brief		Update HW entry according to domain setup
  * @details		Function is intended to propagate domain configuration from host SW instance
@@ -279,6 +678,10 @@ static errno_t pfe_l2br_update_hw_entry(pfe_l2br_domain_t *domain)
 		{
 			/*	Update classifier memory (all PEs) */
 			pfe_l2br_update_hw_ll_entry(domain, domain->bridge->dmem_fb_bd_base);
+			if (TRUE == pfe_feature_mgr_is_available("software_vlan_table"))
+			{
+				pfe_l2br_update_vlan_hash_entry(domain);
+			}
 			ret = EOK;
 		}
 		else
@@ -288,6 +691,10 @@ static errno_t pfe_l2br_update_hw_entry(pfe_l2br_domain_t *domain)
 			{
 				/*	Update classifier memory (all PEs) */
 				pfe_l2br_update_hw_ll_entry(domain, domain->bridge->dmem_def_bd_base);
+				if (TRUE == pfe_feature_mgr_is_available("software_vlan_table"))
+				{
+					pfe_l2br_update_vlan_hash_entry(domain);
+				}
 			}
 			/*	Update standard or default domain entry */
 			ret = pfe_l2br_table_entry_set_action_data(domain->vlan_entry, domain->u.action_data_u64val);
@@ -298,8 +705,15 @@ static errno_t pfe_l2br_update_hw_entry(pfe_l2br_domain_t *domain)
 			}
 			else
 			{
-				/*	Propagate change to HW table */
-				ret = pfe_l2br_table_update_entry(domain->bridge->vlan_table, domain->vlan_entry);
+				if (TRUE == pfe_feature_mgr_is_available("software_vlan_table"))
+				{
+					ret = pfe_l2br_update_vlan_hash_entry(domain);
+				}
+				else
+				{
+					/*	Propagate change to HW table */
+					ret = pfe_l2br_table_update_entry(domain->bridge->vlan_table, domain->vlan_entry);
+				}
 				if (EOK != ret)
 				{
 					NXP_LOG_ERROR("Can't update VLAN table entry: %d\n", ret);
@@ -508,8 +922,16 @@ static errno_t pfe_l2br_config_domain(const pfe_l2br_t *bridge, pfe_l2br_domain_
 			}
 			else
 			{
-				/*	Add new VLAN table entry */
-				ret = pfe_l2br_table_add_entry(domain->bridge->vlan_table, domain->vlan_entry);
+				if (TRUE == pfe_feature_mgr_is_available("software_vlan_table"))
+				{
+					ret = pfe_l2br_add_vlan_hash_entry(domain);
+				}
+				else
+				{
+					/*	Add new VLAN table entry */
+					ret = pfe_l2br_table_add_entry(domain->bridge->vlan_table, domain->vlan_entry);
+				}
+
 				if (EOK != ret)
 				{
 					NXP_LOG_ERROR("Could not add VLAN table entry: %d\n", ret);
@@ -737,8 +1159,17 @@ errno_t pfe_l2br_domain_destroy(pfe_l2br_domain_t *domain)
 
 		if (NULL != domain->vlan_entry)
 		{
-			/*	Remove entry from the table */
-			ret = pfe_l2br_table_del_entry(domain->bridge->vlan_table, domain->vlan_entry);
+			if (TRUE == pfe_feature_mgr_is_available("software_vlan_table"))
+			{
+				ret = pfe_l2br_delete_vlan_hash_entry(domain);
+			}
+			else
+			{
+
+				/*	Remove entry from the table */
+				ret = pfe_l2br_table_del_entry(domain->bridge->vlan_table, domain->vlan_entry);
+			}
+
 			if (EOK != ret)
 			{
 				NXP_LOG_ERROR("Can't delete entry from VLAN table: %d\n", ret);
@@ -774,6 +1205,7 @@ static pfe_l2br_domain_t *pfe_l2br_create_default_domain(pfe_l2br_t *bridge, uin
 	errno_t             ret;
 	pfe_l2br_domain_t * domain;
 	pfe_ct_class_mmap_t class_mmap;
+	uint32_t vlan_hash_addr;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == bridge))
@@ -794,6 +1226,26 @@ static pfe_l2br_domain_t *pfe_l2br_create_default_domain(pfe_l2br_t *bridge, uin
 
 			bridge->dmem_def_bd_base = oal_ntohl(class_mmap.dmem_def_bd_base);
 
+			if (EOK == pfe_feature_mgr_enable("software_vlan_table"))
+			{
+				ret = pfe_feature_mgr_table_get_payload("software_vlan_table", FW_FEATURE_TABLE_CONFIG, "vlan_hash", (uint8_t*) &vlan_hash_addr);
+				if (EOK == ret)
+				{
+					bridge->dmem_vlan_hash_base = vlan_hash_addr;
+					NXP_LOG_INFO("Software vlan hash table @ p0x%x\n", vlan_hash_addr);
+				}
+				else
+				{
+					/*Fall back to hardware vlan table*/
+					pfe_feature_mgr_disable("software_vlan_table");
+					NXP_LOG_INFO("Hardware vlan hash table\n");
+				}
+			}
+			else
+			{
+				NXP_LOG_INFO("Hardware vlan hash table\n");
+			}
+
 			ret = pfe_l2br_domain_create(bridge, vlan);
 
 			if (EOK != ret)
@@ -3134,20 +3586,16 @@ static errno_t pfe_l2br_set_mac_aging_timeout(pfe_class_t *class, const uint16_t
 	return ret;
 }
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-
 /**
  * @brief		Return L2 Bridge runtime statistics in text form
  * @details		Function writes formatted text into given buffer.
  * @param[in]	bridge		The L2 Bridge instance
- * @param[in]	buf 		Pointer to the buffer to write to
- * @param[in]	buf_len 	Buffer length
+ * @param[in]	seq			Pointer to debugfs seq_file
  * @param[in]	verb_level 	Verbosity level
  * @return		Number of bytes written to the buffer
  */
-uint32_t pfe_l2br_get_text_statistics(const pfe_l2br_t *bridge, char_t *buf, uint32_t buf_len, uint8_t verb_level)
+uint32_t pfe_l2br_get_text_statistics(const pfe_l2br_t *bridge, struct seq_file *seq, uint8_t verb_level)
 {
-    uint32_t len = 0U;
     pfe_l2br_table_entry_t *entry;
     pfe_l2br_table_iterator_t* l2t_iter;
     errno_t ret;
@@ -3165,20 +3613,18 @@ uint32_t pfe_l2br_get_text_statistics(const pfe_l2br_t *bridge, char_t *buf, uin
     while (EOK == ret)
     {
         /* Print out the entry */
-        len += pfe_l2br_table_entry_to_str(entry, buf + len, buf_len - len);
+        pfe_l2br_table_entry_to_str(entry, seq);
         count++;
         /* Get the next entry */
         ret = pfe_l2br_table_get_next(bridge->mac_table, l2t_iter, entry);
     }
-    len += oal_util_snprintf(buf + len, buf_len - len, "\n MAC entries count: %u\n", count);
+    seq_printf(seq, "\n MAC entries count: %u\n", count);
     /* Free memory */
     (void)pfe_l2br_table_entry_destroy(entry);
     (void)pfe_l2br_iterator_destroy(l2t_iter);
-    return len;
+    return 0;
 }
 
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
-
 /**
  * @brief       Get Entry from L2 static entry
  * @param[in]   static_ent Static entry
@@ -3309,20 +3755,16 @@ errno_t pfe_l2br_clear_domain_stats(const pfe_l2br_t *bridge, uint8_t vlan_index
 	return ret;
 }
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-
 /**
  * @brief		Return L2 Bridge domain(vlan) statistics in text form
  * @details		Function writes formatted text into given buffer.
  * @param[in]	bridge		The L2 Bridge instance
- * @param[in]	buf 		Pointer to the buffer to write to
- * @param[in]	buf_len 	Buffer length
+ * @param[in]	seq			Pointer to debugfs seq_file
  * @param[in]	verb_level 	Verbosity level
  * @return		Number of bytes written to the buffer
  */
-uint32_t pfe_l2br_domain_get_text_statistics(pfe_l2br_t *bridge, char_t *buf, uint32_t buf_len, uint8_t verb_level)
+uint32_t pfe_l2br_domain_get_text_statistics(pfe_l2br_t *bridge, struct seq_file *seq, uint8_t verb_level)
 {
-	uint32_t len = 0U;
 	errno_t ret;
 	pfe_ct_vlan_stats_t stats = {0};
 	pfe_l2br_domain_t *domain = NULL;
@@ -3340,16 +3782,14 @@ uint32_t pfe_l2br_domain_get_text_statistics(pfe_l2br_t *bridge, char_t *buf, ui
 			NXP_LOG_ERROR("Get domain statistics failed\n");
 			break;
 		}
-		len += oal_util_snprintf(buf + len, buf_len - len, "Vlan [%4d] ingress: %12d       egress: %12d\n", domain->vlan, oal_ntohl(stats.ingress), oal_ntohl(stats.egress));
-		len += oal_util_snprintf(buf + len, buf_len - len, "      ingress_bytes: %12d egress_bytes: %12d\n", oal_ntohl(stats.ingress_bytes), oal_ntohl(stats.egress_bytes));
+		seq_printf(seq, "Vlan [%4d] ingress: %12d       egress: %12d\n", domain->vlan, oal_ntohl(stats.ingress), oal_ntohl(stats.egress));
+		seq_printf(seq, "      ingress_bytes: %12d egress_bytes: %12d\n", oal_ntohl(stats.ingress_bytes), oal_ntohl(stats.egress_bytes));
 		domain = pfe_l2br_get_next_domain(bridge);
 	}
 
-	return len;
+	return 0;
 }
 
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
-
 /**
  * @brief		Get L2 bridge domain(vlan) statistics
  * @param[in]	domain		The classifier instance
diff --git a/sw/pfe_platform/src/pfe_l2br_table.c b/sw/pfe_platform/src/pfe_l2br_table.c
index 71f9279..4cd4875 100644
--- a/sw/pfe_platform/src/pfe_l2br_table.c
+++ b/sw/pfe_platform/src/pfe_l2br_table.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -821,7 +821,6 @@ errno_t pfe_l2br_iterator_destroy(const pfe_l2br_table_iterator_t *inst)
  * @brief			Compute hash of the entry.
  * @details			It is assumed that this function uses same algorithms as PFE HW.
  * @param[in]		entry Entry to be hashed
- * @param[out]		hash [passback] Hash of the entry
  * @retval			hash of the entry
  */
 static uint8_t pfe_l2br_entry_get_hash(const pfe_l2br_table_entry_t *entry)
@@ -829,10 +828,10 @@ static uint8_t pfe_l2br_entry_get_hash(const pfe_l2br_table_entry_t *entry)
 	uint16_t hash = 0U;
 	
 	#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely(NULL == entry) || (NULL == hash))
+	if (unlikely(NULL == entry))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
+		return 0U;
 	}
 	#endif /* PFE_CFG_NULL_ARG_CHECK */
 
@@ -862,7 +861,7 @@ static void pfe_l2br_iterator_save_macvlan(pfe_l2br_table_iterator_t *l2t_iter,
 	if (unlikely(NULL == l2t_iter) || (NULL == entry))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return FALSE;
+		return;
 	}
 	#endif /* PFE_CFG_NULL_ARG_CHECK */
 	
@@ -1871,18 +1870,13 @@ __attribute__((pure)) bool_t pfe_l2br_table_entry_is_static(const pfe_l2br_table
 	}
 }
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-
 /**
  * @brief		Convert entry to string representation
  * @param[in]	entry The entry
- * @param[in]	buf Buffer to write the final string to
- * @param[in]	buf_len Buffer length
+ * @param[in]	seq			Pointer to debugfs seq_file
  */
-uint32_t pfe_l2br_table_entry_to_str(const pfe_l2br_table_entry_t *entry, char_t *buf, uint32_t buf_len)
+uint32_t pfe_l2br_table_entry_to_str(const pfe_l2br_table_entry_t *entry, struct seq_file *seq)
 {
-	uint32_t len = 0U;
-
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == entry) || (NULL == buf)))
 	{
@@ -1893,45 +1887,43 @@ uint32_t pfe_l2br_table_entry_to_str(const pfe_l2br_table_entry_t *entry, char_t
 
 	if (PFE_L2BR_TABLE_MAC2F == entry->type)
 	{
-		len += (uint32_t)snprintf(buf + len, buf_len - len, "[MAC+VLAN Table Entry]\n");
-		len += (uint32_t)snprintf(buf + len, buf_len - len, "MAC Address: %02x:%02x:%02x:%02x:%02x:%02x\n",
+		seq_printf(seq, "[MAC+VLAN Table Entry]\n");
+		seq_printf(seq, "MAC Address: %02x:%02x:%02x:%02x:%02x:%02x\n",
 				entry->u.mac2f_entry.mac[0],
 				entry->u.mac2f_entry.mac[1],
 				entry->u.mac2f_entry.mac[2],
 				entry->u.mac2f_entry.mac[3],
 				entry->u.mac2f_entry.mac[4],
 				entry->u.mac2f_entry.mac[5]);
-		len += (uint32_t)snprintf(buf + len, buf_len - len, "VLAN       : 0x%x\n", entry->u.mac2f_entry.vlan);
-		len += (uint32_t)snprintf(buf + len, buf_len - len, "Action Data: 0x%x\n", entry->u.mac2f_entry.action_data);
+		seq_printf(seq, "VLAN       : 0x%x\n", entry->u.mac2f_entry.vlan);
+		seq_printf(seq, "Action Data: 0x%x\n", entry->u.mac2f_entry.action_data);
 #if 0
 		/* Currently not used - action data stores the port information, FW does not have access to port field */
-		len += (uint32_t)snprintf(buf + len, buf_len - len, "Port       : 0x%x\n", entry->u.mac2f_entry.port);
+		seq_printf(seq, "Port       : 0x%x\n", entry->u.mac2f_entry.port);
 #endif
-		len += (uint32_t)snprintf(buf + len, buf_len - len, "Col Ptr    : 0x%x\n", entry->u.mac2f_entry.col_ptr);
-		len += (uint32_t)snprintf(buf + len, buf_len - len, "Flags      : 0x%x\n", entry->u.mac2f_entry.flags);
+		seq_printf(seq, "Col Ptr    : 0x%x\n", entry->u.mac2f_entry.col_ptr);
+		seq_printf(seq, "Flags      : 0x%x\n", entry->u.mac2f_entry.flags);
 	}
 	else if (PFE_L2BR_TABLE_VLAN == entry->type)
 	{
-		len += (uint32_t)snprintf(buf + len, buf_len - len, "[VLAN Table Entry]\n");
-		len += (uint32_t)snprintf(buf + len, buf_len - len, "VLAN       : 0x%x\n", entry->u.vlan_entry.vlan);
+		seq_printf(seq, "[VLAN Table Entry]\n");
+		seq_printf(seq, "VLAN       : 0x%x\n", entry->u.vlan_entry.vlan);
 		/*	Native type used to fix compiler warning */
-		len += (uint32_t)snprintf(buf + len, buf_len - len, "Action Data: 0x%"PRINT64"x\n", (uint64_t)entry->u.vlan_entry.action_data);
+		seq_printf(seq, "Action Data: 0x%"PRINT64"x\n", (uint64_t)entry->u.vlan_entry.action_data);
 #if 0
 		/* Currently not used - action data stores the port information, FW does not have access to port field */
-		len += (uint32_t)snprintf(buf + len, buf_len - len, "Port       : 0x%x\n", entry->u.vlan_entry.port);
+		seq_printf(seq, "Port       : 0x%x\n", entry->u.vlan_entry.port);
 #endif
-		len += (uint32_t)snprintf(buf + len, buf_len - len, "Col Ptr    : 0x%x\n", entry->u.vlan_entry.col_ptr);
-		len += (uint32_t)snprintf(buf + len, buf_len - len, "Flags      : 0x%x\n", entry->u.vlan_entry.flags);
+		seq_printf(seq, "Col Ptr    : 0x%x\n", entry->u.vlan_entry.col_ptr);
+		seq_printf(seq, "Flags      : 0x%x\n", entry->u.vlan_entry.flags);
 	}
 	else
 	{
-		len += (uint32_t)snprintf(buf + len, buf_len - len, "Invalid entry type\n");
+		seq_printf(seq, "Invalid entry type\n");
 	}
-	return len;
+	return 0;
 }
 
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
-
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
 #include "Eth_43_PFE_MemMap.h"
diff --git a/sw/pfe_platform/src/pfe_log_if.c b/sw/pfe_platform/src/pfe_log_if.c
index 5fcdd73..2fd7b47 100644
--- a/sw/pfe_platform/src/pfe_log_if.c
+++ b/sw/pfe_platform/src/pfe_log_if.c
@@ -17,7 +17,6 @@
 #include "pfe_cbus.h"
 #include "pfe_ct.h"
 #include "pfe_log_if.h"
-#include "pfe_pe.h"
 #include "pfe_class.h"
 #include "blalloc.h" /* Block allocator to assign interface IDs */
 #include "pfe_platform_cfg.h"
@@ -2418,7 +2417,10 @@ uint32_t pfe_log_if_get_text_statistics(const pfe_log_if_t *iface, char_t *buf,
 					printed_rules = TRUE; /* Avoid printing it multiple times*/
 				}
 				len += oal_util_snprintf(buf + len, buf_len - len, "- Statistics from PE %u -\n", i);
-				len += pfe_pe_stat_to_str(&log_if_class.class_stats, buf + len, buf_len - len, verb_level);
+				len += oal_util_snprintf(buf + len, buf_len - len, "Frames processed: %u\n", oal_ntohl(log_if_class.class_stats.processed));
+				len += oal_util_snprintf(buf + len, buf_len - len, "Frames accepted:  %u\n", oal_ntohl(log_if_class.class_stats.accepted));
+				len += oal_util_snprintf(buf + len, buf_len - len, "Frames rejected:  %u\n", oal_ntohl(log_if_class.class_stats.rejected));
+				len += oal_util_snprintf(buf + len, buf_len - len, "Frames discarded: %u\n", oal_ntohl(log_if_class.class_stats.discarded));
 			}
 			++i;
 		}
diff --git a/sw/pfe_platform/src/pfe_pe.c b/sw/pfe_platform/src/pfe_pe.c
index 4f4235d..501e071 100644
--- a/sw/pfe_platform/src/pfe_pe.c
+++ b/sw/pfe_platform/src/pfe_pe.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -22,44 +22,10 @@
 #define INVALID_FEATURES_BASE 		0xFFFFFFFFU
 #define ALIGNMENT_CHECKMASK			0x3U
 #define ALIGNMENT_PACKEDNUMBER		4U
-/**
- * @brief	Mutex protecting access to common mem_access_* registers
- */
-
-#ifdef PFE_CFG_TARGET_OS_AUTOSAR
-#define ETH_43_PFE_START_SEC_VAR_CLEARED_UNSPECIFIED
-#include "Eth_43_PFE_MemMap.h"
-#endif /* PFE_CFG_TARGET_OS_AUTOSAR */
-
-static oal_mutex_t mem_access_lock;
-
-#ifdef PFE_CFG_TARGET_OS_AUTOSAR
-#define ETH_43_PFE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
-#include "Eth_43_PFE_MemMap.h"
-
-#define ETH_43_PFE_START_SEC_VAR_INIT_BOOLEAN
-#include "Eth_43_PFE_MemMap.h"
-#endif /* PFE_CFG_TARGET_OS_AUTOSAR */
-
-/* usage scope: pfe_pe_create */
-static bool_t mem_access_lock_init = FALSE;
-
-#ifdef PFE_CFG_TARGET_OS_AUTOSAR
-#define ETH_43_PFE_STOP_SEC_VAR_INIT_BOOLEAN
-#include "Eth_43_PFE_MemMap.h"
-
-#define ETH_43_PFE_START_SEC_VAR_INIT_32
-#include "Eth_43_PFE_MemMap.h"
-#endif /* PFE_CFG_TARGET_OS_AUTOSAR */
 
 /* usage scope: pfe_pe_load_firmware*/
 static pfe_ct_pe_mmap_t *tmp_mmap = NULL;
 
-#ifdef PFE_CFG_TARGET_OS_AUTOSAR
-#define ETH_43_PFE_STOP_SEC_VAR_INIT_32
-#include "Eth_43_PFE_MemMap.h"
-#endif /* PFE_CFG_TARGET_OS_AUTOSAR */
-
 typedef enum
 {
 	PFE_PE_DMEM,
@@ -121,8 +87,9 @@ struct pfe_pe_tag
 	pfe_ct_pe_mmap_t *mmap_data;		/* Buffer containing the memory map data */
 
 	/* Mutex */
-	oal_mutex_t lock_mutex;				/* Locking PE API mutex */
-	bool_t miflock;						/* When TRUE then PFE memory interface is locked */
+	oal_mutex_t *lock_mutex;			/* Pointer to shared PE API mutex (provided from PE's parent) */
+	bool_t *miflock;					/* Pointer to diagnostic flag (provided from PE's parent) 
+											When TRUE then PFE memory interface is locked */
 
 	/* Stall detection */
 	uint32_t counter;					/* Latest PE counter value */
@@ -168,7 +135,7 @@ static errno_t pfe_pe_mem_process_lock(pfe_pe_t *pe, PFE_PTR(pfe_ct_pe_misc_cont
 #if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
 
 static inline const char_t *pfe_pe_get_fw_state_str(pfe_ct_pe_sw_state_t state);
-static uint32_t pfe_pe_get_measurements_nolock(pfe_pe_t *pe, uint32_t count, uint32_t ptr, char_t *buf, uint32_t buf_len, uint8_t verb_level);
+static uint32_t pfe_pe_get_measurements_nolock(pfe_pe_t *pe, uint32_t count, uint32_t ptr, struct seq_file *seq, uint8_t verb_level);
 
 #endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
 
@@ -301,9 +268,9 @@ static void pfe_pe_free_mem(pfe_pe_t **pe, uint32_t pe_num)
 
 	for (ii = 0; ii < pe_num; ++ii)
 	{
-		if (EOK != pfe_pe_unlock(pe[ii]))
+		if (EOK != pfe_pe_unlock_family(pe[ii]))
 		{
-			NXP_LOG_ERROR("pfe_pe_unlock() failed\n");
+			NXP_LOG_ERROR("pfe_pe_unlock_family() failed\n");
 		}
 		pe[ii]->mmap_data = NULL;
 
@@ -367,15 +334,17 @@ static bool_t pfe_pe_is_active_nolock(pfe_pe_t *pe)
 
 
 /**
-* @brief Lock PE access
-* @param[in] pe PE which access shall be locked
-* @return EOK if success, error code otherwise
-*/
-errno_t pfe_pe_lock(pfe_pe_t *pe)
+ * @brief		Lock PE access
+ * @warning		Multiple PE cores may share a single mutex+miflock pair, forming a 'family'.
+ *				By locking one PE core of such a 'family', all other family members have to wait.
+ * @param[in]	pe PE whose access shall be locked
+ * @return		EOK if success, error code otherwise
+ */
+errno_t pfe_pe_lock_family(pfe_pe_t *pe)
 {
-	errno_t ret = oal_mutex_lock(&pe->lock_mutex);
+	errno_t ret = oal_mutex_lock(pe->lock_mutex);
 
-	if (unlikely(pe->miflock))
+	if (unlikely(*pe->miflock))
 	{
 		NXP_LOG_ERROR("Lock already indicated.\n");
 	}
@@ -383,27 +352,29 @@ errno_t pfe_pe_lock(pfe_pe_t *pe)
 	if (likely(EOK == ret))
 	{
 		/*	Indicate the 'lock' status */
-		pe->miflock = TRUE;
+		*pe->miflock = TRUE;
 	}
 
 	return ret;
 }
 
 /**
-* @brief Unlock PE access
-* @param[in] pe PE which access shall be unlocked
-* @return EOK if success, error code otherwise
-*/
-errno_t pfe_pe_unlock(pfe_pe_t *pe)
+ * @brief		Unlock PE access
+ * @waring		Multiple PE cores may share a single mutex+miflock pair, forming a 'family'.
+ *				By unlocking one PE core of such a 'family', all other family members are unlocked as well.
+ * @param[in]	pe PE whose access shall be unlocked
+ * @return		EOK if success, error code otherwise
+ */
+errno_t pfe_pe_unlock_family(pfe_pe_t *pe)
 {
 	/*	Indicate the 'unlock' status */
-	pe->miflock = FALSE;
+	*pe->miflock = FALSE;
 
-	return oal_mutex_unlock(&pe->lock_mutex);
+	return oal_mutex_unlock(pe->lock_mutex);
 }
 
 /**
- * @brief		Process to lock PE memory 
+ * @brief		Process to acquire lock of some PE memory
  * @param[in]	pe The PE instance
  * @param[in]	misc_dmem The miscellaneous control command structure
  * @return		EOK if success, error code otherwise
@@ -414,98 +385,80 @@ static errno_t pfe_pe_mem_process_lock(pfe_pe_t *pe, PFE_PTR(pfe_ct_pe_misc_cont
 	pfe_ct_pe_misc_control_t misc_ctrl = {0};
 	uint32_t timeout = 10;
 
-	if (EOK != pfe_pe_lock(pe))
+	/*	Read the misc control structure from DMEM */
+	pfe_pe_memcpy_from_dmem_to_host_32_nolock(
+			pe, &misc_ctrl, misc_dmem, sizeof(pfe_ct_pe_misc_control_t));
+
+	if (0U != misc_ctrl.graceful_stop_request)
 	{
-		NXP_LOG_ERROR("pfe_pe_lock() failed\n");
+		if (0U != misc_ctrl.graceful_stop_confirmation)
+		{
+			NXP_LOG_ERROR("Locking locked memory\n");
+		}
+		else
+		{
+			NXP_LOG_ERROR("Duplicate stop request\n");
+		}
+
 		ret = EPERM;
 	}
 	else
 	{
-			/*	Read the misc control structure from DMEM */
-		pfe_pe_memcpy_from_dmem_to_host_32_nolock(
-				pe, &misc_ctrl, misc_dmem, sizeof(pfe_ct_pe_misc_control_t));
+		/*	Writing the non-zero value triggers the request */
+		misc_ctrl.graceful_stop_request = 0xffU;
+		/*	PE will respond with setting this to non-zero value */
+		misc_ctrl.graceful_stop_confirmation = 0x0U;
+		/*	Use 'nolock' variant here. Accessing this data can't lead to conflicts. */
+		pfe_pe_memcpy_from_host_to_dmem_32_nolock(
+				pe, misc_dmem, &misc_ctrl, sizeof(pfe_ct_pe_misc_control_t));
 
-		if (0U != misc_ctrl.graceful_stop_request)
+		if (FALSE == pfe_pe_is_active_nolock(pe))
 		{
-			if (0U != misc_ctrl.graceful_stop_confirmation)
-			{
-				NXP_LOG_ERROR("Locking locked memory\n");
-			}
-			else
-			{
-				NXP_LOG_ERROR("Duplicate stop request\n");
-			}
-
-			if (EOK != pfe_pe_unlock(pe))
-			{
-				NXP_LOG_ERROR("pfe_pe_unlock() failed\n");
-			}
-
-			ret = EPERM;
+			/*	Access to PE memory is considered to be safe. PE memory interface is locked. */
+			ret = EOK;
 		}
 		else
 		{
-			/*	Writing the non-zero value triggers the request */
-			misc_ctrl.graceful_stop_request = 0xffU;
-			/*	PE will respond with setting this to non-zero value */
-			misc_ctrl.graceful_stop_confirmation = 0x0U;
-			/*	Use 'nolock' variant here. Accessing this data can't lead to conflicts. */
-			pfe_pe_memcpy_from_host_to_dmem_32_nolock(
-					pe, misc_dmem, &misc_ctrl, sizeof(pfe_ct_pe_misc_control_t));
-
-			if (FALSE == pfe_pe_is_active_nolock(pe))
-			{
-				/*	Access to PE memories is considered to be safe. PE memory
-					interface is locked. */
-				ret = EOK;
-			}
-			else
+			ret = EOK;
+			/*	Wait for response */
+			do
 			{
-				ret = EOK;
-				/*	Wait for response */
-				do
+				if (0U == timeout)
 				{
-					if (0U == timeout)
-					{
-						NXP_LOG_ERROR("Timed-out\n");
-
-						/*	Cancel the request */
-						misc_ctrl.graceful_stop_request = 0U;
+					NXP_LOG_ERROR("Timed-out\n");
 
-						/*	Use 'nolock' variant here. Accessing this data can't lead to conflicts. */
-						pfe_pe_memcpy_from_host_to_dmem_32_nolock(
-								pe, misc_dmem, &misc_ctrl, sizeof(pfe_ct_pe_misc_control_t));
+					/*	Cancel the request */
+					misc_ctrl.graceful_stop_request = 0U;
 
-						if (EOK != pfe_pe_unlock(pe))
-						{
-							NXP_LOG_ERROR("pfe_pe_unlock() failed\n");
-						}
+					/*	Use 'nolock' variant here. Accessing this data can't lead to conflicts. */
+					pfe_pe_memcpy_from_host_to_dmem_32_nolock(
+							pe, misc_dmem, &misc_ctrl, sizeof(pfe_ct_pe_misc_control_t));
 
-						ret = ETIME;
-						break;
-					}
+					ret = ETIME;
+					break;
+				}
 
-					oal_time_usleep(10U);
-					timeout--;
-					pfe_pe_memcpy_from_dmem_to_host_32_nolock(
-							pe, &misc_ctrl, misc_dmem, sizeof(pfe_ct_pe_misc_control_t));
+				oal_time_usleep(10U);
+				timeout--;
+				pfe_pe_memcpy_from_dmem_to_host_32_nolock(
+						pe, &misc_ctrl, misc_dmem, sizeof(pfe_ct_pe_misc_control_t));
 
-				} while (0U == misc_ctrl.graceful_stop_confirmation);
-				/*	Access to PE memory interface is locked */
-			}
+			} while (0U == misc_ctrl.graceful_stop_confirmation);
+			/*	Access to PE memory interface is locked */
 		}
 	}
+
 	return ret;
 }
 
 /**
- * @brief		Lock PE memory
- * @details		While locked, the PE can't access internal memory. Invoke the PE graceful
- *				stop request and wait for confirmation. Also lock the PE memory interface.
+ * @brief		Acquire lock of PE memory
+ * @details		While driver has the lock, PE cannot access its own internal memory.
+ *				This is needed if driver wants to interact with given PE memory (read/write).
  * @param[in]	pe The PE instance
  * @return		EOK if success, error code otherwise
  */
-errno_t pfe_pe_mem_lock(pfe_pe_t *pe)
+errno_t pfe_pe_memlock_acquire_nolock(pfe_pe_t *pe)
 {
 	errno_t ret;
 	PFE_PTR(pfe_ct_pe_misc_control_t) misc_dmem;
@@ -532,13 +485,13 @@ errno_t pfe_pe_mem_lock(pfe_pe_t *pe)
 }
 
 /**
- * @brief		Unlock PE memory
- * @details		While locked, the PE can't access internal memory. Here the memory
- * 				and the memory interface will be unlocked.
+ * @brief		Release lock of PE memory
+ * @details		While driver has the lock, PE cannot access its own internal memory.
+ *				This function releases the lock, allowing PE to resume its operations.
  * @param[in]	pe The PE instance
  * @return		EOK if success, error code otherwise
  */
-errno_t pfe_pe_mem_unlock(pfe_pe_t *pe)
+errno_t pfe_pe_memlock_release_nolock(pfe_pe_t *pe)
 {
 	errno_t ret;
 	PFE_PTR(pfe_ct_pe_misc_control_t) misc_dmem;
@@ -564,12 +517,6 @@ errno_t pfe_pe_mem_unlock(pfe_pe_t *pe)
 			/*	Use 'nolock' variant here. Accessing this data can't lead to conflicts. */
 			pfe_pe_memcpy_from_host_to_dmem_32_nolock(
 					pe, misc_dmem, &misc_ctrl, sizeof(pfe_ct_pe_misc_control_t));
-
-			/*	Unlock access to PE memory interface */
-			if (EOK != pfe_pe_unlock(pe))
-			{
-				NXP_LOG_ERROR("pfe_pe_unlock() failed\n");
-			}
 		}
 	}
 
@@ -710,7 +657,7 @@ static void pfe_pe_fw_memcpy_bulk(pfe_pe_t *pe, pfe_pe_mem_t mem, addr_t dst_add
 	}
 
 	/*	Sanity check if we can safely access the memory interface */
-	if (unlikely(!pe->miflock))
+	if (unlikely(!(*pe->miflock)))
 	{
 		NXP_LOG_ERROR("Accessing unlocked PE memory interface (write).\n");
 	}
@@ -774,7 +721,7 @@ static void pfe_pe_fw_memset_bulk(pfe_pe_t *pe, pfe_pe_mem_t mem, uint32_t val,
 	}
 
 	/*	Sanity check if we can safely access the memory interface */
-	if (unlikely(!pe->miflock))
+	if (unlikely(!(*pe->miflock)))
 	{
 		NXP_LOG_ERROR("Accessing unlocked PE memory interface (write).\n");
 	}
@@ -839,7 +786,7 @@ static void pfe_pe_fw_memcpy_single(pfe_pe_t *pe, pfe_pe_mem_t mem, addr_t dst_a
 	}
 
 	/*	Sanity check if we can safely access the memory interface */
-	if (unlikely(!pe->miflock))
+	if (unlikely(!(*pe->miflock)))
 	{
 		NXP_LOG_ERROR("Accessing unlocked PE memory interface (write).\n");
 	}
@@ -882,7 +829,7 @@ static void pfe_pe_fw_memset_single(pfe_pe_t *pe, pfe_pe_mem_t mem, uint32_t val
 	}
 
 	/*	Sanity check if we can safely access the memory interface */
-	if (unlikely(!pe->miflock))
+	if (unlikely(!(*pe->miflock)))
 	{
 		NXP_LOG_ERROR("Accessing unlocked PE memory interface (write).\n");
 	}
@@ -966,7 +913,7 @@ static uint32_t pfe_pe_mem_read(pfe_pe_t *pe, pfe_pe_mem_t mem, addr_t addr, uin
 						| PE_IBUS_WREN(0U);
 
 			/*	Sanity check if we can safely access the memory interface */
-			if (unlikely(!pe->miflock))
+			if (unlikely(!(*pe->miflock)))
 			{
 				NXP_LOG_ERROR("Accessing unlocked PE memory interface (read).\n");
 			}
@@ -1040,7 +987,7 @@ static void pfe_pe_mem_write(pfe_pe_t *pe, pfe_pe_mem_t mem, uint32_t val, addr_
 				| PE_IBUS_WREN(bytesel);
 
 		/*	Sanity check if we can safely access the memory interface */
-		if (unlikely(!pe->miflock))
+		if (unlikely(!(*pe->miflock)))
 		{
 			NXP_LOG_ERROR("Accessing unlocked PE memory interface (write).\n");
 		}
@@ -1149,20 +1096,29 @@ static void pfe_pe_memcpy_from_host_to_dmem_32_nolock(
  */
 void pfe_pe_memcpy_from_host_to_dmem_32(pfe_pe_t *pe, addr_t dst_addr, const void *src_ptr, uint32_t len)
 {
-	errno_t ret;
-
-	ret = pfe_pe_mem_lock(pe);
-	if (EOK != ret)
+	if (EOK != pfe_pe_lock_family(pe))
 	{
-		NXP_LOG_ERROR("Memory lock failed\n");
+		NXP_LOG_ERROR("pfe_pe_lock_family() failed\n");
 	}
 	else
 	{
-		pfe_pe_memcpy_from_host_to_dmem_32_nolock(pe, dst_addr, src_ptr, len);
+		if (EOK != pfe_pe_memlock_acquire_nolock(pe))
+		{
+			NXP_LOG_ERROR("Memory lock failed\n");
+		}
+		else
+		{
+			pfe_pe_memcpy_from_host_to_dmem_32_nolock(pe, dst_addr, src_ptr, len);
+
+			if (EOK != pfe_pe_memlock_release_nolock(pe))
+			{
+				NXP_LOG_ERROR("Memory unlock failed\n");
+			}
+		}
 
-		if (EOK != pfe_pe_mem_unlock(pe))
+		if (EOK != pfe_pe_unlock_family(pe))
 		{
-			NXP_LOG_ERROR("Memory unlock failed\n");
+			NXP_LOG_ERROR("pfe_pe_unlock_family() failed\n");
 		}
 	}
 }
@@ -1233,20 +1189,29 @@ void pfe_pe_memcpy_from_dmem_to_host_32_nolock(pfe_pe_t *pe, void *dst_ptr, addr
  */
 void pfe_pe_memcpy_from_dmem_to_host_32(pfe_pe_t *pe, void *dst_ptr, addr_t src_addr, uint32_t len)
 {
-	errno_t ret;
-
-	ret = pfe_pe_mem_lock(pe);
-	if (EOK != ret)
+	if (EOK != pfe_pe_lock_family(pe))
 	{
-		NXP_LOG_ERROR("Memory lock failed\n");
+		NXP_LOG_ERROR("pfe_pe_lock_family() failed\n");
 	}
 	else
 	{
-		pfe_pe_memcpy_from_dmem_to_host_32_nolock(pe, dst_ptr, src_addr, len);
+		if (EOK != pfe_pe_memlock_acquire_nolock(pe))
+		{
+			NXP_LOG_ERROR("Memory lock failed\n");
+		}
+		else
+		{
+			pfe_pe_memcpy_from_dmem_to_host_32_nolock(pe, dst_ptr, src_addr, len);
 
-		if (EOK != pfe_pe_mem_unlock(pe))
+			if (EOK != pfe_pe_memlock_release_nolock(pe))
+			{
+				NXP_LOG_ERROR("Memory unlock failed\n");
+			}
+		}
+
+		if (EOK != pfe_pe_unlock_family(pe))
 		{
-			NXP_LOG_ERROR("Memory unlock failed\n");
+			NXP_LOG_ERROR("pfe_pe_unlock_family() failed\n");
 		}
 	}
 }
@@ -1266,60 +1231,81 @@ void pfe_pe_memcpy_from_dmem_to_host_32(pfe_pe_t *pe, void *dst_ptr, addr_t src_
 errno_t pfe_pe_gather_memcpy_from_dmem_to_host_32(pfe_pe_t **pe, int32_t pe_count, void *dst_ptr, addr_t src_addr, uint32_t buffer_len, uint32_t read_len)
 {
 	int32_t ii = 0U;
-	uint8_t mem_lock_error = 0U;
+	uint8_t memlock_error = 0U;
 	errno_t ret = EOK;
 	errno_t ret_store = EOK;
 
-	/* Lock all PEs - they will stop processing frames and wait. This will
-	   ensure data coherence. */
-	for (ii = 0; ii < pe_count; ii++)
+	/* Lock family */
+	ret = pfe_pe_lock_family(*pe);
+	if (EOK != ret)
 	{
-		ret = pfe_pe_mem_lock(pe[ii]);
-		if (EOK != ret)
-		{
-			mem_lock_error++;
-			NXP_LOG_ERROR("Memory lock failed for PE instance %d\n", (int_t)ii);
-		}
+		NXP_LOG_ERROR("pfe_pe_lock_family() failed\n");
 	}
-
-	/* Only read from PEs if all PEs are locked */
-	if (0U == mem_lock_error)
+	else
 	{
-		/* Perform the read from required PEs */
+		/*	Acquire memlock for all PE cores. They will stop processing frames and wait.
+			This will ensure data coherence. */
 		for (ii = 0; ii < pe_count; ii++)
 		{
-			/* Check if there is still memory  */
-			if (buffer_len >= ((read_len * (uint32_t)ii) + read_len))
+			ret = pfe_pe_memlock_acquire_nolock(pe[ii]);
+			if (EOK != ret)
 			{
-				pfe_pe_memcpy_from_dmem_to_host_32_nolock(pe[ii],
-						(void *)((uint8_t*)dst_ptr + (read_len * (uint32_t)ii)),
-							src_addr, read_len);
+				memlock_error++;
+				NXP_LOG_ERROR("Memory lock failed for PE instance %d\n", (int_t)ii);
+
+				/* Save the error */
+				ret_store = ret;
 			}
-			else
+		}
+
+		/* Only read from PEs if all PEs are locked */
+		if (0U == memlock_error)
+		{
+			/* Perform the read from required PEs */
+			for (ii = 0; ii < pe_count; ii++)
 			{
-				ret = ENOMEM;
-				break;
+				/* Check if there is still memory  */
+				if (buffer_len >= ((read_len * (uint32_t)ii) + read_len))
+				{
+					pfe_pe_memcpy_from_dmem_to_host_32_nolock(pe[ii],
+							(void *)((uint8_t*)dst_ptr + (read_len * (uint32_t)ii)),
+								src_addr, read_len);
+				}
+				else
+				{
+					/* Memory limit reached. Save the error. */
+					ret_store = ENOMEM;
+					break;
+				}
 			}
 		}
-	}
 
-	/* Unlock all PEs */
-	for (ii = 0; ii < pe_count; ii++)
-	{
-		/* Backup return from memcpy */
-		ret_store = ret;
-		ret = pfe_pe_mem_unlock(pe[ii]);
-		if(EOK != ret)
+		/* Release memlock for all PE cores. */
+		for (ii = 0; ii < pe_count; ii++)
 		{
-			NXP_LOG_ERROR("Memory unlock failed\n");
+			ret = pfe_pe_memlock_release_nolock(pe[ii]);
+			if(EOK != ret)
+			{
+				NXP_LOG_ERROR("Memory unlock failed\n");
 
-			/* Error occurred. Override the return from previous actions. */
+				/* Save the error */
+				ret_store = ret;
+			}
+		}
+		
+		/* Unlock family */
+		ret = pfe_pe_unlock_family(*pe);
+		if (EOK != ret)
+		{
+			NXP_LOG_ERROR("pfe_pe_unlock_family() failed\n");
+
+			/* Save the error */
 			ret_store = ret;
 		}
-	}
 
-	/* Restore return to before unlock */
-	ret = ret_store;
+		/* If there was any error during the whole process, then return it. */
+		ret = ret_store;
+	}
 
 	return ret;
 }
@@ -1738,14 +1724,16 @@ static addr_t pfe_pe_get_elf_sect_load_addr(const ELF_File_t *elf_file, const El
  * @param[in]	cbus_base_va CBUS base address (virtual)
  * @param[in]	type Type of PE to create @see pfe_pe_type_t
  * @param[in]	id PE ID
+ * @param[in]	lock_mutex pointer to mutex of this PE core
+ * @param[in]	miflock pointer to miflock diagnostic flag of this PE core
  * @return		The PE instance or NULL if failed
  */
-pfe_pe_t * pfe_pe_create(addr_t cbus_base_va, pfe_ct_pe_type_t type, uint8_t id)
+pfe_pe_t * pfe_pe_create(addr_t cbus_base_va, pfe_ct_pe_type_t type, uint8_t id, oal_mutex_t *lock_mutex, bool_t *miflock)
 {
 	pfe_pe_t *pe = NULL;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely(NULL_ADDR == cbus_base_va))
+	if (unlikely(NULL_ADDR == cbus_base_va) || unlikely(NULL == lock_mutex))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
 		pe = NULL;
@@ -1769,30 +1757,8 @@ pfe_pe_t * pfe_pe_create(addr_t cbus_base_va, pfe_ct_pe_type_t type, uint8_t id)
 				pe->id = id;
 				pe->fw_msg_section = NULL;
 				pe->mmap_data = NULL;
-				if(EOK != oal_mutex_init(&pe->lock_mutex))
-				{
-					NXP_LOG_ERROR("Mutex init failed\n");
-					oal_mm_free(pe);
-					pe = NULL;
-				}
-
-				if (FALSE == mem_access_lock_init)
-				{
-					if (EOK == oal_mutex_init(&mem_access_lock))
-					{
-						mem_access_lock_init = TRUE;
-					}
-					else
-					{
-						NXP_LOG_ERROR("Mutex (mem_access_lock) init failed\n");
-						if (NULL != pe)
-						{
-							(void)oal_mutex_destroy(&pe->lock_mutex);
-							oal_mm_free(pe);
-							pe = NULL;
-						}
-					}
-				}
+				pe->lock_mutex = lock_mutex;
+				pe->miflock = miflock;
 			}
 		}
 	}
@@ -1926,16 +1892,14 @@ errno_t pfe_pe_load_firmware(pfe_pe_t **pe, uint32_t pe_num, const void *elf)
 	}
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
-	for (pe_idx = 0; pe_idx < pe_num; ++pe_idx)
+	ret = pfe_pe_lock_family(*pe);
+	if (EOK != ret)
 	{
-		if (EOK != pfe_pe_lock(pe[pe_idx]))
-		{
-			NXP_LOG_ERROR("pfe_pe_lock() failed\n");
-		}
-		/* TODO unlock if it fails (maybe it doesn't matter  as we fail init anyway ?)*/
+		NXP_LOG_ERROR("pfe_pe_lock_family() failed\n");
+		return ret;
 	}
 
-	ret =  pfe_pe_fw_install_ops(pe, (uint8_t)pe_num);
+	ret = pfe_pe_fw_install_ops(pe, (uint8_t)pe_num);
 	if (EOK != ret)
 	{
 		NXP_LOG_ERROR("Couldn't find PE load operations: %d\n", ret);
@@ -2112,13 +2076,13 @@ errno_t pfe_pe_load_firmware(pfe_pe_t **pe, uint32_t pe_num, const void *elf)
 		return ret;
 	}
 
-	for (ii = 0; ii < pe_num; ++ii)
+	if (EOK != pfe_pe_unlock_family(*pe))
 	{
-		if (EOK != pfe_pe_unlock(pe[ii]))
-		{
-			NXP_LOG_ERROR("pfe_pe_unlock() failed\n");
-		}
+		NXP_LOG_ERROR("pfe_pe_unlock_family() failed\n");
+	}
 
+	for (ii = 0; ii < pe_num; ++ii)
+	{
 		/*	Indicate that mmap_data is available */
 		pe[ii]->mmap_data = tmp_mmap;
 
@@ -2213,7 +2177,8 @@ void pfe_pe_destroy(pfe_pe_t **pe, uint32_t pe_num)
 			pe[pe_idx]->fw_feature_section = NULL;
 			pe[pe_idx]->fw_feature_section_size = 0U;
 
-			(void)oal_mutex_destroy(&pe[pe_idx]->lock_mutex);
+			pe[pe_idx]->lock_mutex = NULL;
+			pe[pe_idx]->miflock = NULL;
 			oal_mm_free(pe[pe_idx]);
 
 			pe[pe_idx] = NULL;
@@ -2633,38 +2598,6 @@ errno_t pfe_pe_get_class_algo_stats_nolock(pfe_pe_t *pe, uint32_t addr, pfe_ct_c
 
 #if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
 
-/**
- * @brief		Converts statistics of a logical interface or classification algorithm into a text form
- * @param[in]	stat		Statistics to convert
- * @param[out]	buf			Buffer where to write the text
- * @param[in]	buf_len		Buffer length
- * @param[in]	verb_level	Verbosity level
- * @return		Number of bytes written into the output buffer
- */
-uint32_t pfe_pe_stat_to_str(const pfe_ct_class_algo_stats_t *stat, char *buf, uint32_t buf_len, uint8_t verb_level)
-{
-	uint32_t len = 0U;
-
-	(void)verb_level;
-
-#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely((NULL == stat) || (NULL == buf)))
-	{
-		NXP_LOG_ERROR("NULL argument received\n");
-		len = 0U;
-	}
-	else
-#endif
-	{
-		len += oal_util_snprintf(buf + len, buf_len - len, "Frames processed: %u\n", oal_ntohl(stat->processed));
-		len += oal_util_snprintf(buf + len, buf_len - len, "Frames accepted:  %u\n", oal_ntohl(stat->accepted));
-		len += oal_util_snprintf(buf + len, buf_len - len, "Frames rejected:  %u\n", oal_ntohl(stat->rejected));
-		len += oal_util_snprintf(buf + len, buf_len - len, "Frames discarded: %u\n", oal_ntohl(stat->discarded));
-	}
-
-	return len;
-}
-
 /**
  * @brief Translates state pfe_ct_pe_sw_state_t to a string
  * @param[in] state State to be translated
@@ -2714,16 +2647,14 @@ static inline const char_t *pfe_pe_get_fw_state_str(pfe_ct_pe_sw_state_t state)
 * @param[in] pe PE which shall be read
 * @param[in] count Number of measurements in the PE memory to be read
 * @param[in] ptr Location of the measurements record in the PE memory
-* @param[in] buf Output text data buffer
-* @param[in] buf_len Size of the output text data buffer
+* @param[in] seq Pointer to debugfs seq_file
 * @param[in] verb_level Verbosity level
 * @return Number of bytes written into the text buffer
 */
-static uint32_t pfe_pe_get_measurements_nolock(pfe_pe_t *pe, uint32_t count, uint32_t ptr, char_t *buf, uint32_t buf_len, uint8_t verb_level)
+static uint32_t pfe_pe_get_measurements_nolock(pfe_pe_t *pe, uint32_t count, uint32_t ptr, struct seq_file *seq, uint8_t verb_level)
 {
 	pfe_ct_measurement_t *m = NULL;
 	uint_t i;
-	uint32_t len = 0U;
 
 	(void)verb_level;
 
@@ -2754,7 +2685,7 @@ static uint32_t pfe_pe_get_measurements_nolock(pfe_pe_t *pe, uint32_t count, uin
                 uint32_t cnt = oal_ntohl(m[i].cnt);
 
                 /* Just print the data without interpreting them */
-                len += oal_util_snprintf(buf + len, buf_len - len,
+                seq_printf(seq,
                         "Measurement %u:\tmin %10u\tmax %10u\tavg %10u\tcnt %10u\n",
                             i, min, max, avg, cnt);
             }
@@ -2764,7 +2695,7 @@ static uint32_t pfe_pe_get_measurements_nolock(pfe_pe_t *pe, uint32_t count, uin
         }
     }
 
-	return len;
+	return 0;
 }
 
 #endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
@@ -2781,9 +2712,9 @@ pfe_ct_pe_sw_state_t pfe_pe_get_fw_state(pfe_pe_t *pe)
 
 	/*	We don't need coherent data here so only lock the
 	 memory interface without locking the PE memory. */
-	if (EOK != pfe_pe_lock(pe))
+	if (EOK != pfe_pe_lock_family(pe))
 	{
-		NXP_LOG_ERROR("pfe_pe_lock() failed\n");
+		NXP_LOG_ERROR("pfe_pe_lock_family() failed\n");
 	}
 
 	if (pfe_pe_get_state_monitor_nolock(pe, &state_monitor) != EOK)
@@ -2791,9 +2722,9 @@ pfe_ct_pe_sw_state_t pfe_pe_get_fw_state(pfe_pe_t *pe)
 		state_monitor.state = PFE_FW_STATE_UNINIT;
 	}
 
-	if (EOK != pfe_pe_unlock(pe))
+	if (EOK != pfe_pe_unlock_family(pe))
 	{
-		NXP_LOG_ERROR("pfe_pe_unlock() failed\n");
+		NXP_LOG_ERROR("pfe_pe_unlock_family() failed\n");
 	}
 
 	return state_monitor.state;
@@ -2910,58 +2841,70 @@ errno_t pfe_pe_put_data_nolock(pfe_pe_t *pe, pfe_ct_buffer_t *buf)
  * @brief		Return PE runtime statistics in text form
  * @details		Function writes formatted text into given buffer.
  * @param[in]	pe 			The PE instance
- * @param[in]	buf 		Pointer to the buffer to write to
- * @param[in]	buf_len 	Buffer length
+ * @param[in]	seq			Pointer to debugfs seq_file
  * @param[in]	verb_level 	Verbosity level
  * @return		Number of bytes written to the buffer
  *
  */
-uint32_t pfe_pe_get_text_statistics(pfe_pe_t *pe, char_t *buf, uint32_t buf_len, uint8_t verb_level)
+uint32_t pfe_pe_get_text_statistics(pfe_pe_t *pe, struct seq_file *seq, uint8_t verb_level)
 {
-	uint32_t len = 0U;
 	pfe_ct_pe_sw_state_monitor_t state_monitor = {0};
-	errno_t ret;
 
 	if (NULL == pe->mmap_data)
 	{
 		return 0U;
 	}
 
-	len += oal_util_snprintf(buf + len, buf_len - len, "\nPE %u\n----\n", pe->id);
-	len += oal_util_snprintf(buf + len, buf_len - len, "- PE state monitor -\n");
+	seq_printf(seq, "\nPE %u\n----\n", pe->id);
+	seq_printf(seq, "- PE state monitor -\n");
 
-	/*	Make the PFE data coherent */
-	ret = pfe_pe_mem_lock(pe);
-	if (EOK != ret)
+	if (EOK != pfe_pe_lock_family(pe))
 	{
-		NXP_LOG_ERROR("Memory lock failed\n");
-		return 0;
+		NXP_LOG_ERROR("pfe_pe_lock_family() failed\n");
+		seq_printf(seq, "pfe_pe_lock_family() failed\n");
 	}
+	else
+	{
+		/*	Make the PFE data coherent */
+		if (EOK != pfe_pe_memlock_acquire_nolock(pe))
+		{
+			NXP_LOG_ERROR("Memory lock failed\n");
+			seq_printf(seq, "Memory lock failed\n");
+		}
+		else
+		{
+			pfe_pe_memcpy_from_dmem_to_host_32_nolock(pe, &state_monitor,
+					oal_ntohl(pe->mmap_data->common.state_monitor), sizeof(pfe_ct_pe_sw_state_monitor_t));
 
-	pfe_pe_memcpy_from_dmem_to_host_32_nolock(pe, &state_monitor,
-			oal_ntohl(pe->mmap_data->common.state_monitor), sizeof(pfe_ct_pe_sw_state_monitor_t));
+			seq_printf(seq, "FW State: %u (%s), counter %u\n",
+					state_monitor.state, pfe_pe_get_fw_state_str(state_monitor.state),
+						oal_ntohl(state_monitor.counter));
 
-	len += oal_util_snprintf(buf + len, buf_len - len, "FW State: %u (%s), counter %u\n",
-			state_monitor.state, pfe_pe_get_fw_state_str(state_monitor.state),
-				oal_ntohl(state_monitor.counter));
+			/* This is a class PE therefore we may access the specific data */
+			if (0U != oal_ntohl(pe->mmap_data->common.measurement_count))
+			{
+				seq_printf(seq, "- Measurements -\n");
 
-	/* This is a class PE therefore we may access the specific data */
-	if (0U != oal_ntohl(pe->mmap_data->common.measurement_count))
-	{
-		len += oal_util_snprintf(buf + len, buf_len - len, "- Measurements -\n");
+				/* Read processing time measurements */
+				pfe_pe_get_measurements_nolock(pe, oal_ntohl(pe->mmap_data->common.measurement_count),
+						oal_ntohl(pe->mmap_data->common.measurements), seq, verb_level);
+			}
 
-		/* Read processing time measurements */
-		len += pfe_pe_get_measurements_nolock(pe, oal_ntohl(pe->mmap_data->common.measurement_count),
-				oal_ntohl(pe->mmap_data->common.measurements), buf + len, buf_len - len, verb_level);
-	}
+			if (EOK != pfe_pe_memlock_release_nolock(pe))
+			{
+				NXP_LOG_ERROR("Memory unlock failed\n");
+				seq_printf(seq, "Memory unlock failed\n");
+			}
+		}
 
-	if (EOK != pfe_pe_mem_unlock(pe))
-	{
-		NXP_LOG_ERROR("Memory unlock failed\n");
-		len = 0U;
+		if (EOK != pfe_pe_unlock_family(pe))
+		{
+			NXP_LOG_ERROR("pfe_pe_unlock_family() failed\n");
+			seq_printf(seq, "pfe_pe_unlock_family() failed\n");
+		}
 	}
 
-	return len;
+	return 0;
 }
 
 #endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
diff --git a/sw/pfe_platform/src/pfe_phy_if.c b/sw/pfe_platform/src/pfe_phy_if.c
index 878b083..b3f9d0f 100644
--- a/sw/pfe_platform/src/pfe_phy_if.c
+++ b/sw/pfe_platform/src/pfe_phy_if.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *	
  *	Copyright (c) 2019 Imagination Technologies Limited
- *	Copyright 2018-2022 NXP
+ *	Copyright 2018-2023 NXP
  *
  *	SPDX-License-Identifier: GPL-2.0
  *
@@ -81,6 +81,7 @@ static errno_t pfe_phy_if_set_flag_nolock(pfe_phy_if_t *iface, pfe_ct_if_flags_t
 static errno_t pfe_phy_if_clear_flag_nolock(pfe_phy_if_t *iface, pfe_ct_if_flags_t flag);
 static pfe_ct_if_flags_t pfe_phy_if_get_flag_nolock(const pfe_phy_if_t *iface, pfe_ct_if_flags_t flag);
 static errno_t pfe_phy_if_enable_hw_block(const pfe_phy_if_t *iface);
+static void pfe_phy_if_update_op_mode_nolock(pfe_phy_if_t *iface, pfe_ct_if_op_mode_t mode);
 
 #if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
 
@@ -334,6 +335,9 @@ void pfe_phy_if_destroy(pfe_phy_if_t *iface)
 				NXP_LOG_DEBUG("%s mac_db is NULL.\n", iface->name);
 			}
 
+			/* Disable HW bridge lookup if the last interface was destroyed */
+			pfe_phy_if_update_op_mode_nolock(iface, IF_OP_DEFAULT);
+
 			if (EOK != oal_mutex_unlock(&iface->lock))
 			{
 				NXP_LOG_ERROR("mutex unlock failed\n");
@@ -1011,6 +1015,9 @@ errno_t pfe_phy_if_set_op_mode(pfe_phy_if_t *iface, pfe_ct_if_op_mode_t mode)
 				NXP_LOG_ERROR("mutex lock failed\n");
 			}
 
+			/* Enable HW bridge lookup if required */
+			pfe_phy_if_update_op_mode_nolock(iface, mode);
+
 			iface->phy_if_class.mode = mode;
 			ret = pfe_phy_if_write_to_class_nostats(iface, &iface->phy_if_class);
 			if (EOK != ret)
@@ -1029,6 +1036,30 @@ errno_t pfe_phy_if_set_op_mode(pfe_phy_if_t *iface, pfe_ct_if_op_mode_t mode)
 	return ret;
 }
 
+/**
+ * @brief		Maintain bridge operational mode
+ * @param[in]	iface The interface instance
+ * @param[in]	mode Mode to be set. See pfe_ct_if_op_mode_t.
+ * @note		Control HW bridge lookup mode based on operational mode of all PHYs.
+ */
+static void pfe_phy_if_update_op_mode_nolock(pfe_phy_if_t *iface, pfe_ct_if_op_mode_t mode)
+{
+	uint32_t if_bitmap;
+	bool_t br_mode = FALSE;
+
+	if ((PFE_PHY_IF_ID_EMAC0 <= iface->id) && (PFE_PHY_IF_ID_MAX >= iface->id))
+	{
+		/* Set bitmap based on PHY ID */
+		if_bitmap = (1U << iface->id);
+		if ((IF_OP_VLAN_BRIDGE == mode) || (IF_OP_L2L3_VLAN_BRIDGE == mode))
+		{
+			br_mode = TRUE;
+		}
+
+		pfe_class_update_hw_bridge_lookup(iface->class, if_bitmap, br_mode);
+	}
+}
+
 /**
  * @brief		Bind interface with EMAC
  * @param[in]	iface The interface instance
@@ -1363,6 +1394,9 @@ errno_t pfe_phy_if_enable(pfe_phy_if_t *iface)
 
 		NXP_LOG_DEBUG("Enabling %s\n", iface->name);
 
+		/* Enable HW bridge lookup if required */
+		pfe_phy_if_update_op_mode_nolock(iface, iface->phy_if_class.mode);
+
 		/*	Enable interface instance. Backup flags and write the changes. */
 		tmp = iface->phy_if_class.flags;
 		iface->phy_if_class.flags |= oal_htonl(IF_FL_ENABLED);
@@ -1473,6 +1507,9 @@ static errno_t pfe_phy_if_disable_nolock(pfe_phy_if_t *iface)
 						ret = EINVAL;
 					}
 				}
+
+				/* Disable HW bridge lookup if the last interface is disabled */
+				pfe_phy_if_update_op_mode_nolock(iface, IF_OP_DEFAULT);
 			}
 		}
 	}
diff --git a/sw/pfe_platform/src/pfe_rtable.c b/sw/pfe_platform/src/pfe_rtable.c
index a16e196..9bb94e5 100644
--- a/sw/pfe_platform/src/pfe_rtable.c
+++ b/sw/pfe_platform/src/pfe_rtable.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *	
  *	Copyright (c) 2019 Imagination Technologies Limited
- *	Copyright 2018-2022 NXP
+ *	Copyright 2018-2023 NXP
  *
  *	SPDX-License-Identifier: GPL-2.0
  *
@@ -3475,20 +3475,16 @@ errno_t pfe_rtable_clear_stats(const pfe_rtable_t *rtable, uint8_t conntrack_ind
 	return ret;
 }
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-
 /**
  * @brief		Return conntrack statistics in text form
  * @details		Function writes formatted text into given buffer.
  * @param[in]	rtable		The routing table instance
- * @param[in]	buf			Pointer to the buffer to write to
- * @param[in]	buf_len		Buffer length
+ * @param[in]	seq			Pointer to debugfs seq_file
  * @param[in]	verb_level	Verbosity level
  * @return		Number of bytes written to the buffer
  */
-uint32_t pfe_rtable_get_text_statistics(const pfe_rtable_t *rtable, char_t *buf, uint32_t buf_len, uint8_t verb_level)
+uint32_t pfe_rtable_get_text_statistics(const pfe_rtable_t *rtable, struct seq_file *seq, uint8_t verb_level)
 {
-	uint32_t len = 0U;
 	errno_t ret;
 	pfe_ct_conntrack_stats_t stats = {0};
 	LLIST_t *item;
@@ -3499,13 +3495,9 @@ uint32_t pfe_rtable_get_text_statistics(const pfe_rtable_t *rtable, char_t *buf,
 
 	ret = pfe_rtable_get_stats(rtable, &stats, 0);
 
-	if (EOK != ret)
-	{
-		len = 0U;
-	}
-	else
+	if (EOK == ret)
 	{
-		len += oal_util_snprintf(buf + len, buf_len - len, "Default				  hit: %12lu hit_bytes: %12lu\n", stats.hit, stats.hit_bytes);
+		seq_printf(seq, "Default				  hit: %12u hit_bytes: %12u\n", stats.hit, stats.hit_bytes);
 
 		/*	Protect table accesses */
 		if (unlikely(EOK != oal_mutex_lock(rtable->lock)))
@@ -3531,7 +3523,7 @@ uint32_t pfe_rtable_get_text_statistics(const pfe_rtable_t *rtable, char_t *buf,
 					continue;
 				}
 
-				len += oal_util_snprintf(buf + len, buf_len - len, "Conntrack route_id %2d hit: %12lu hit_bytes: %12lu\n", oal_ntohl(entry->route_id) , stats.hit, stats.hit_bytes);
+				seq_printf(seq, "Conntrack route_id %2d hit: %12u hit_bytes: %12u\n", oal_ntohl(entry->route_id) , stats.hit, stats.hit_bytes);
 			}
 		}
 
@@ -3541,11 +3533,9 @@ uint32_t pfe_rtable_get_text_statistics(const pfe_rtable_t *rtable, char_t *buf,
 		}
 	}
 
-	return len;
+	return 0;
 }
 
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
-
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
 #include "Eth_43_PFE_MemMap.h"
diff --git a/sw/pfe_platform/src/pfe_tmu.c b/sw/pfe_platform/src/pfe_tmu.c
index de3df9f..8b252b3 100644
--- a/sw/pfe_platform/src/pfe_tmu.c
+++ b/sw/pfe_platform/src/pfe_tmu.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -13,7 +13,6 @@
 
 #include "pfe_platform_cfg.h"
 #include "pfe_cbus.h"
-#include "pfe_pe.h"
 #include "pfe_feature_mgr.h"
 #include "pfe_phy_if.h"
 #include "pfe_tmu.h"
@@ -1697,38 +1696,30 @@ uint8_t pfe_tmu_sch_get_bound_queue(const pfe_tmu_t *tmu, pfe_ct_phy_if_id_t phy
 	return ret;
 }
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-
 /**
  * @brief		Return TMU runtime statistics in text form
  * @details		Function writes formatted text into given buffer.
  * @param[in]	tmu The TMU instance
- * @param[in]	buf Pointer to buffer to be written
- * @param[in]	buf_len Buffer length
+ * @param[in]	seq			Pointer to debugfs seq_file
  * @param[in]	verb_level 	Verbosity level
  * @return		Number of bytes written to the buffer
  */
-uint32_t pfe_tmu_get_text_statistics(const pfe_tmu_t *tmu, char_t *buf, uint32_t buf_len, uint8_t verb_level)
+uint32_t pfe_tmu_get_text_statistics(const pfe_tmu_t *tmu, struct seq_file *seq, uint8_t verb_level)
 {
-	uint32_t len = 0U;
-
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely(NULL == tmu))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		len = 0U;
 	}
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		len += pfe_tmu_cfg_get_text_stat(tmu->cbus_base_va, buf, buf_len, verb_level);
+		pfe_tmu_cfg_get_text_stat(tmu->cbus_base_va, seq, verb_level);
 	}
 
-	return len;
+	return 0;
 }
 
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
-
 #ifdef PFE_CFG_TARGET_OS_AUTOSAR
 #define ETH_43_PFE_STOP_SEC_CODE
 #include "Eth_43_PFE_MemMap.h"
diff --git a/sw/pfe_platform/src/pfe_util.c b/sw/pfe_platform/src/pfe_util.c
index 3a8b4a1..88aaf39 100644
--- a/sw/pfe_platform/src/pfe_util.c
+++ b/sw/pfe_platform/src/pfe_util.c
@@ -1,7 +1,7 @@
 /* =========================================================================
  *  
  *  Copyright (c) 2019 Imagination Technologies Limited
- *  Copyright 2018-2022 NXP
+ *  Copyright 2018-2023 NXP
  *
  *  SPDX-License-Identifier: GPL-2.0
  *
@@ -31,6 +31,8 @@ struct pfe_util_tag
 	uint32_t pe_num;		/*	Number of PEs */
 	pfe_pe_t **pe;			/*	List of particular PEs */
 	oal_mutex_t mutex;
+	oal_mutex_t mutex_pe;	/*	Shared mutex for UTIL PE cores */
+	bool_t miflock_pe;		/*	Shared 'miflock' diagnostic flag for UTIL PE cores */
 	uint32_t current_feature;			/* Index of the feature to return by pfe_util_get_feature_next() */
 	pfe_fw_feature_t **fw_features;		/* List of all features*/
 	uint32_t fw_features_count;			/* Number of items in fw_features */
@@ -214,7 +216,7 @@ static errno_t pfe_util_create_pe(uint32_t pe_num, addr_t cbus_base_va, pfe_util
 	/*	Create PEs */
 	for (count = 0U; count < pe_num; count++)
 	{
-		pe = pfe_pe_create(cbus_base_va, PE_TYPE_UTIL, count);
+		pe = pfe_pe_create(cbus_base_va, PE_TYPE_UTIL, count, &util->mutex_pe, &util->miflock_pe);
 
 		if (NULL == pe)
 		{
@@ -276,6 +278,15 @@ pfe_util_t *pfe_util_create(addr_t cbus_base_va, uint32_t pe_num, const pfe_util
 		oal_mm_free(util);
 		return NULL;
 	}
+
+	if (EOK != oal_mutex_init(&util->mutex_pe))
+	{
+		NXP_LOG_ERROR("Failed to initialize shared mutex for UTIL PE cores\n");
+		(void)oal_mutex_destroy(&util->mutex);	/* 'mutex_pe' creation failed, but 'mutex' already exists */
+		oal_mm_free(util);
+		return NULL;
+	}
+
     /* No need to lock mutex. No other function can be called before
        we return util handle from this function. */
 
@@ -286,6 +297,8 @@ pfe_util_t *pfe_util_create(addr_t cbus_base_va, uint32_t pe_num, const pfe_util
 		if (NULL == util->pe)
 		{
 			NXP_LOG_ERROR("Unable to allocate memory\n");
+			(void)oal_mutex_destroy(&util->mutex);
+			(void)oal_mutex_destroy(&util->mutex_pe);
 			oal_mm_free(util);
 			return NULL;
 		}
@@ -472,6 +485,7 @@ void pfe_util_destroy(pfe_util_t *util)
 		}
 
 		util->pe_num = 0U;
+		(void)oal_mutex_destroy(&util->mutex_pe);
 		(void)oal_mutex_destroy(&util->mutex);
 		oal_mm_free(util);
 	}
@@ -721,25 +735,26 @@ errno_t pfe_util_isr(const pfe_util_t *util)
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 	{
-		/* Read the error record from each PE */
-		for (count = 0U; count < util->pe_num; count++)
+		/*	Allow safe use of _nolock() functions. We don't call the _memlock()
+			here as we don't need to have coherent accesses. */
+		if (EOK != pfe_pe_lock_family(*util->pe))
+		{
+			NXP_LOG_ERROR("pfe_pe_lock_family() failed\n");
+		}
+		else
 		{
-			/*	Allow safe use of _nolock() functions. We don't call the _mem_lock()
-				here as we don't need to have coherent accesses. */
-			if (EOK != pfe_pe_lock(util->pe[count]))
+			/* Read the error record from each PE */
+			for (count = 0U; count < util->pe_num; count++)
 			{
-				NXP_LOG_ERROR("pfe_pe_lock() failed\n");
+				(void)pfe_pe_get_fw_messages_nolock(util->pe[count]);
+				(void)pfe_pe_check_stalled_nolock(util->pe[count]);
 			}
 
-			(void)pfe_pe_get_fw_messages_nolock(util->pe[count]);
-			(void)pfe_pe_check_stalled_nolock(util->pe[count]);
-
-			if (EOK != pfe_pe_unlock(util->pe[count]))
+			if (EOK != pfe_pe_unlock_family(*util->pe))
 			{
-				NXP_LOG_ERROR("pfe_pe_unlock() failed\n");
+				NXP_LOG_ERROR("pfe_pe_unlock_family() failed\n");
 			}
 		}
-
 		/* Acknowledge interrupt */
 		(void) pfe_util_cfg_isr(util->cbus_base_va);
 
@@ -767,20 +782,16 @@ void pfe_util_irq_unmask(const pfe_util_t *util)
 	(void)util;
 }
 
-#if !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS)
-
 /**
  * @brief		Return UTIL runtime statistics in text form
  * @details		Function writes formatted text into given buffer.
  * @param[in]	util 		The UTIL instance
- * @param[in]	buf 		Pointer to the buffer to write to
- * @param[in]	size 		Buffer length
+ * @param[in]	seq			Pointer to debugfs seq_file
  * @param[in]	verb_level 	Verbosity level
  * @return		Number of bytes written to the buffer
  */
-uint32_t pfe_util_get_text_statistics(const pfe_util_t *util, char_t *buf, uint32_t buf_len, uint8_t verb_level)
+uint32_t pfe_util_get_text_statistics(const pfe_util_t *util, struct seq_file *seq, uint8_t verb_level)
 {
-	uint32_t len = 0U;
 	uint32_t ii;
 	pfe_ct_version_t fw_ver;
 	pfe_ct_pe_mmap_t mmap;
@@ -789,7 +800,6 @@ uint32_t pfe_util_get_text_statistics(const pfe_util_t *util, char_t *buf, uint3
 	if (unlikely(NULL == buf))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		len = 0U;
 	}
 	else
 #endif /* PFE_CFG_NULL_ARG_CHECK */
@@ -797,71 +807,60 @@ uint32_t pfe_util_get_text_statistics(const pfe_util_t *util, char_t *buf, uint3
 		if (NULL == util)
 		{
 			/* NULL ptr to UTIL is allowed. Driver does not have to load UTIL FW. */
-			len += oal_util_snprintf(buf + len, buf_len - len, "UTIL Firmware not loaded.\n");
+			seq_printf(seq, "UTIL Firmware not loaded.\n");
 		}
 		else
 		{
 			/* FW version */
 			if (EOK == pfe_util_get_fw_version(util, &fw_ver))
 			{
-				len += oal_util_snprintf(buf + len, buf_len - len, "FIRMWARE VERSION\t%u.%u.%u (api:%.32s)\n",
+				seq_printf(seq, "FIRMWARE VERSION\t%u.%u.%u (api:%.32s)\n",
 					fw_ver.major, fw_ver.minor, fw_ver.patch, fw_ver.cthdr);
 			}
 			else
 			{
-				len += oal_util_snprintf(buf + len, buf_len - len, "FIRMWARE VERSION <unknown>\n");
+				seq_printf(seq, "FIRMWARE VERSION <unknown>\n");
 			}
 
-			len += pfe_util_cfg_get_text_stat(util->cbus_base_va, buf + len, buf_len - len, verb_level);
+			pfe_util_cfg_get_text_stat(util->cbus_base_va, seq, verb_level);
 
 			/*	Get PE info per PE */
 			for (ii = 0U; ii < util->pe_num; ii++)
 			{
 				ipsec_state_t state = { 0 };
-				uint32_t text_stat_len = 0U;
 
 				if (EOK == pfe_pe_get_mmap(util->pe[ii], &mmap))
 				{
-					text_stat_len = pfe_pe_get_text_statistics(util->pe[ii], buf + len, buf_len - len, verb_level);
-					if (0U == text_stat_len)
-					{
-						len = 0U;
-						break;
-					}
-					else
-					{
-						len += text_stat_len;
-						/* IPsec statistics */
-						pfe_pe_memcpy_from_dmem_to_host_32(util->pe[ii], &state, oal_ntohl(mmap.util_pe.ipsec_state), sizeof(state));
-						len += oal_util_snprintf(buf + len, buf_len - len, "\nIPsec\n");
-						len += oal_util_snprintf(buf + len, buf_len - len, "HSE MU            0x%x\n", oal_ntohl(state.hse_mu));
-						len += oal_util_snprintf(buf + len, buf_len - len, "HSE MU Channel    0x%x\n", oal_ntohl(state.hse_mu_chn));
-						len += oal_util_snprintf(buf + len, buf_len - len, "HSE_SRV_RSP_OK                         0x%x\n", oal_ntohl(state.response_ok));
-						len += oal_util_snprintf(buf + len, buf_len - len, "HSE_SRV_RSP_VERIFY_FAILED              0x%x\n", oal_ntohl(state.verify_failed));
-						len += oal_util_snprintf(buf + len, buf_len - len, "HSE_SRV_RSP_IPSEC_INVALID_DATA         0x%x\n", oal_ntohl(state.ipsec_invalid_data));
-						len += oal_util_snprintf(buf + len, buf_len - len, "HSE_SRV_RSP_IPSEC_REPLAY_DETECTED      0x%x\n", oal_ntohl(state.ipsec_replay_detected));
-						len += oal_util_snprintf(buf + len, buf_len - len, "HSE_SRV_RSP_IPSEC_REPLAY_LATE          0x%x\n", oal_ntohl(state.ipsec_replay_late));
-						len += oal_util_snprintf(buf + len, buf_len - len, "HSE_SRV_RSP_IPSEC_SEQNUM_OVERFLOW      0x%x\n", oal_ntohl(state.ipsec_seqnum_overflow));
-						len += oal_util_snprintf(buf + len, buf_len - len, "HSE_SRV_RSP_IPSEC_CE_DROP              0x%x\n", oal_ntohl(state.ipsec_ce_drop));
-						len += oal_util_snprintf(buf + len, buf_len - len, "HSE_SRV_RSP_IPSEC_TTL_EXCEEDED         0x%x\n", oal_ntohl(state.ipsec_ttl_exceeded));
-						len += oal_util_snprintf(buf + len, buf_len - len, "HSE_SRV_RSP_IPSEC_VALID_DUMMY_PAYLOAD  0x%x\n", oal_ntohl(state.ipsec_valid_dummy_payload));
-						len += oal_util_snprintf(buf + len, buf_len - len, "HSE_SRV_RSP_IPSEC_HEADER_LEN_OVERFLOW  0x%x\n", oal_ntohl(state.ipsec_header_overflow));
-						len += oal_util_snprintf(buf + len, buf_len - len, "HSE_SRV_RSP_IPSEC_PADDING_CHECK_FAIL   0x%x\n", oal_ntohl(state.ipsec_padding_check_fail));
-						len += oal_util_snprintf(buf + len, buf_len - len, "Code of handled error    0x%x\n", oal_ntohl(state.handled_error_code));
-						len += oal_util_snprintf(buf + len, buf_len - len, "SAId of handled error    0x%x\n", oal_ntohl(state.handled_error_said));
-						len += oal_util_snprintf(buf + len, buf_len - len, "Code of unhandled error  0x%x\n", oal_ntohl(state.unhandled_error_code));
-						len += oal_util_snprintf(buf + len, buf_len - len, "SAId of unhandled error  0x%x\n", oal_ntohl(state.unhandled_error_said));
-					}
+					pfe_pe_get_text_statistics(util->pe[ii], seq, verb_level);
+
+					/* IPsec statistics */
+					pfe_pe_memcpy_from_dmem_to_host_32(util->pe[ii], &state, oal_ntohl(mmap.util_pe.ipsec_state), sizeof(state));
+					seq_printf(seq, "\nIPsec\n");
+					seq_printf(seq, "HSE MU            0x%x\n", oal_ntohl(state.hse_mu));
+					seq_printf(seq, "HSE MU Channel    0x%x\n", oal_ntohl(state.hse_mu_chn));
+					seq_printf(seq, "HSE_SRV_RSP_OK                         0x%x\n", oal_ntohl(state.response_ok));
+					seq_printf(seq, "HSE_SRV_RSP_VERIFY_FAILED              0x%x\n", oal_ntohl(state.verify_failed));
+					seq_printf(seq, "HSE_SRV_RSP_IPSEC_INVALID_DATA         0x%x\n", oal_ntohl(state.ipsec_invalid_data));
+					seq_printf(seq, "HSE_SRV_RSP_IPSEC_REPLAY_DETECTED      0x%x\n", oal_ntohl(state.ipsec_replay_detected));
+					seq_printf(seq, "HSE_SRV_RSP_IPSEC_REPLAY_LATE          0x%x\n", oal_ntohl(state.ipsec_replay_late));
+					seq_printf(seq, "HSE_SRV_RSP_IPSEC_SEQNUM_OVERFLOW      0x%x\n", oal_ntohl(state.ipsec_seqnum_overflow));
+					seq_printf(seq, "HSE_SRV_RSP_IPSEC_CE_DROP              0x%x\n", oal_ntohl(state.ipsec_ce_drop));
+					seq_printf(seq, "HSE_SRV_RSP_IPSEC_TTL_EXCEEDED         0x%x\n", oal_ntohl(state.ipsec_ttl_exceeded));
+					seq_printf(seq, "HSE_SRV_RSP_IPSEC_VALID_DUMMY_PAYLOAD  0x%x\n", oal_ntohl(state.ipsec_valid_dummy_payload));
+					seq_printf(seq, "HSE_SRV_RSP_IPSEC_HEADER_LEN_OVERFLOW  0x%x\n", oal_ntohl(state.ipsec_header_overflow));
+					seq_printf(seq, "HSE_SRV_RSP_IPSEC_PADDING_CHECK_FAIL   0x%x\n", oal_ntohl(state.ipsec_padding_check_fail));
+					seq_printf(seq, "Code of handled error    0x%x\n", oal_ntohl(state.handled_error_code));
+					seq_printf(seq, "SAId of handled error    0x%x\n", oal_ntohl(state.handled_error_said));
+					seq_printf(seq, "Code of unhandled error  0x%x\n", oal_ntohl(state.unhandled_error_code));
+					seq_printf(seq, "SAId of unhandled error  0x%x\n", oal_ntohl(state.unhandled_error_said));
 				}
 			}
 		}
 	}
 
-	return len;
+	return 0;
 }
 
-#endif /* !defined(PFE_CFG_TARGET_OS_AUTOSAR) || defined(PFE_CFG_TEXT_STATS) */
-
 /**
  * @brief		Returns firmware versions
  * @param[in]	util The UTIL instance
-- 
2.25.1

