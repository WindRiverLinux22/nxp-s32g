From 9b3774f08bbb11e37a6ce6fc02757178f91979a2 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@oss.nxp.com>
Date: Wed, 1 Sep 2021 09:18:54 +0300
Subject: [PATCH 14/17] gpio: siul2-s32gen1: Correct IRQ mapping

commit 9b3774f08bbb11e37a6ce6fc02757178f91979a2 from
https://source.codeaurora.org/external/autobsps32/linux

GPIO lib maps the IRQ using the GPIO ID and the drivers
that are referencing SIUL2 driver as interrupt controller are
mapping the IRQ using EIRQ ID. This commit checks the
validity of the IRQ using these assumptions.

Upstream-Status: Pending

Issue: ALB-7618
Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@oss.nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/gpio/gpio-siul2-s32gen1.c | 53 ++++++++++++++++++++-----------
 1 file changed, 34 insertions(+), 19 deletions(-)

diff --git a/drivers/gpio/gpio-siul2-s32gen1.c b/drivers/gpio/gpio-siul2-s32gen1.c
index 2606719e2926..8a10b3a5d085 100644
--- a/drivers/gpio/gpio-siul2-s32gen1.c
+++ b/drivers/gpio/gpio-siul2-s32gen1.c
@@ -98,7 +98,6 @@ struct siul2_device_data {
 
 /**
  * struct siul2_gpio_dev - describes a group of GPIO pins
- * @pdev: the platform device
  * @data: platform data
  * @ipads: input pads address
  * @opads: output pads address
@@ -112,7 +111,6 @@ struct siul2_device_data {
  * @see gpio_dir
  */
 struct siul2_gpio_dev {
-	struct platform_device *pdev;
 	const struct siul2_device_data *platdata;
 
 	void __iomem *irq_base;
@@ -153,8 +151,8 @@ static inline int siul2_eirq_to_pin(struct siul2_gpio_dev *gpio_dev, int eirq)
 	return gpio_dev->eirq_pins[eirq].pin;
 }
 
-static inline bool siul2_is_valid_eirq(struct siul2_gpio_dev *gpio_dev,
-								int eirq)
+static inline bool siul2_is_valid_eirq_id(struct siul2_gpio_dev *gpio_dev,
+					  int eirq)
 {
 	if (eirq < 0 || eirq >= gpio_dev->eirq_npins)
 		return false;
@@ -168,7 +166,19 @@ static int siul2_pin_to_eirq(struct siul2_gpio_dev *gpio_dev, int pin)
 	for (i = 0; i < gpio_dev->eirq_npins; i++)
 		if (gpio_dev->eirq_pins[i].pin == pin)
 			return i;
-	return -1;
+	return -ENXIO;
+}
+
+static inline bool siul2_gpio_to_eirq_check(struct siul2_gpio_dev *gpio_dev,
+					int *eirq)
+{
+	int pin;
+
+	/* GPIO lib uses GPIO as EIRQ */
+	pin = siul2_gpio_to_pin(&gpio_dev->gc, *eirq);
+	*eirq = siul2_pin_to_eirq(gpio_dev, pin);
+
+	return siul2_is_valid_eirq_id(gpio_dev, *eirq);
 }
 
 static inline int siul2_get_gpio_pinspec(
@@ -279,7 +289,7 @@ static int siul2_to_irq(struct gpio_chip *chip, unsigned int gpio)
 	if (eirq < 0)
 		return -ENXIO;
 
-	return irq_create_mapping(domain, eirq);
+	return irq_create_mapping(domain, gpio);
 }
 
 static int siul2_gpio_dir_out(struct gpio_chip *chip, unsigned int gpio,
@@ -316,11 +326,7 @@ static void siul2_gpio_free(struct gpio_chip *chip, unsigned int gpio)
 
 static int siul2_get_eirq_from_data(struct irq_data *d)
 {
-	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
-	struct siul2_gpio_dev *gpio_dev = to_siul2_gpio_dev(gc);
-	int pin = siul2_eirq_to_pin(gpio_dev, irqd_to_hwirq(d));
-
-	return siul2_pin_to_eirq(gpio_dev, pin);
+	return irqd_to_hwirq(d);
 }
 
 static int siul2_gpio_irq_set_type(struct irq_data *d, unsigned int type)
@@ -330,14 +336,15 @@ static int siul2_gpio_irq_set_type(struct irq_data *d, unsigned int type)
 	int eirq = siul2_get_eirq_from_data(d);
 	unsigned long flags;
 	unsigned int irq_type = type & IRQ_TYPE_SENSE_MASK;
-	int ret;
+	int ret, pin;
 	u32 ireer0_val;
 	u32 ifeer0_val;
-	int pin = siul2_eirq_to_pin(gpio_dev, eirq);
 
-	if (!siul2_is_valid_eirq(gpio_dev, eirq))
+	if (!siul2_gpio_to_eirq_check(gpio_dev, &eirq))
 		return -EINVAL;
 
+	pin = siul2_eirq_to_pin(gpio_dev, eirq);
+
 	ret = pinctrl_gpio_direction_input(pin);
 	if (ret) {
 		dev_err(gc->parent, "Failed to configure %d pin as input pin\n",
@@ -380,7 +387,8 @@ static irqreturn_t siul2_gpio_irq_handler(int irq, void *data)
 {
 	struct siul2_gpio_dev *gpio_dev = data;
 	struct gpio_chip *gc = &gpio_dev->gc;
-	unsigned int eirq, child_irq;
+	struct device *dev = gc->parent;
+	unsigned int eirq, child_irq, pin, gpio;
 	uint32_t disr0_val;
 	unsigned long disr0_val_long;
 	irqreturn_t ret = IRQ_NONE;
@@ -390,11 +398,18 @@ static irqreturn_t siul2_gpio_irq_handler(int irq, void *data)
 	disr0_val_long = disr0_val;
 
 	for_each_set_bit(eirq, &disr0_val_long,
-					 BITS_PER_BYTE * sizeof(disr0_val)) {
+			 BITS_PER_BYTE * sizeof(disr0_val)) {
 		if (!gpio_dev->eirq_pins[eirq].used)
 			continue;
 
-		child_irq = irq_find_mapping(gc->irq.domain, eirq);
+		/* GPIO lib irq */
+		pin = siul2_eirq_to_pin(gpio_dev, eirq);
+		gpio = siul2_pin_to_gpio(gc, pin);
+		child_irq = irq_find_mapping(gc->irq.domain, gpio);
+
+		if (!child_irq)
+			dev_err(dev, "Unable to detect IRQ for GPIO %d & EIRQ %d\n",
+				gpio, eirq);
 
 		/*
 		 * Clear the interrupt before invoking the
@@ -419,7 +434,7 @@ static void siul2_gpio_irq_unmask(struct irq_data *data)
 	u32 direr0_val;
 	u32 disr0_val;
 
-	if (!siul2_is_valid_eirq(gpio_dev, eirq))
+	if (!siul2_gpio_to_eirq_check(gpio_dev, &eirq))
 		return;
 
 	spin_lock_irqsave(&gpio_dev->lock, flags);
@@ -452,7 +467,7 @@ static void siul2_gpio_irq_mask(struct irq_data *data)
 	u32 direr0_val;
 	u32 disr0_val;
 
-	if (!siul2_is_valid_eirq(gpio_dev, eirq))
+	if (!siul2_gpio_to_eirq_check(gpio_dev, &eirq))
 		return;
 
 	spin_lock_irqsave(&gpio_dev->lock, flags);
-- 
2.17.1

