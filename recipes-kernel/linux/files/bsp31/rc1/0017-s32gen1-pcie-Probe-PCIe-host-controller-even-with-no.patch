From f8f06e0d61d86350d2bb44a98f470d88f3e3c70a Mon Sep 17 00:00:00 2001
From: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
Date: Wed, 15 Sep 2021 14:55:06 +0300
Subject: [PATCH 17/17] s32gen1: pcie: Probe PCIe host controller even with no
 EP plugged

commit f8f06e0d61d86350d2bb44a98f470d88f3e3c70a from
https://source.codeaurora.org/external/autobsps32/linux

Upstream-Status: Pending

Issue: ALB-7703
Signed-off-by: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/pci/controller/dwc/pci-s32gen1.c      | 24 +++++++++++++++----
 .../phy/freescale/phy-fsl-s32gen1-serdes.c    | 24 +++++++++++++++++++
 2 files changed, 43 insertions(+), 5 deletions(-)

diff --git a/drivers/pci/controller/dwc/pci-s32gen1.c b/drivers/pci/controller/dwc/pci-s32gen1.c
index 9f31573e447c..23d14e0f2d33 100644
--- a/drivers/pci/controller/dwc/pci-s32gen1.c
+++ b/drivers/pci/controller/dwc/pci-s32gen1.c
@@ -593,8 +593,13 @@ static int s32gen1_pcie_start_link(struct dw_pcie *pcie)
 	s32gen1_pcie_enable_ltssm(s32_pp);
 	ret = dw_pcie_wait_for_link(pcie);
 
-	if (ret)
+	if (ret) {
+		/* We do not exit with error if link up was unsuccessful
+		 * Endpoint may be connected.
+		 */
+		ret = 0;
 		goto out;
+	}
 
 	/* Allow Gen2 or Gen3 mode after the link is up. */
 	BCLRSET16(pcie, dbi, PCI_EXP_CAP_ID + PCI_EXP_LNKCAP,
@@ -670,6 +675,7 @@ static irqreturn_t s32gen1_pcie_msi_handler(int irq, void *arg)
 static int s32gen1_pcie_host_init(struct pcie_port *pp)
 {
 	struct dw_pcie *pcie = to_dw_pcie_from_pp(pp);
+	struct s32gen1_pcie *s32_pci = to_s32gen1_from_dw_pcie(pcie);
 	int ret;
 
 	DEBUG_FUNC;
@@ -678,8 +684,12 @@ static int s32gen1_pcie_host_init(struct pcie_port *pp)
 
 	s32gen1_pcie_start_link(pcie);
 	ret = dw_pcie_wait_for_link(pcie);
-	if (ret)
-		return ret;
+	if (ret) {
+		if (!phy_validate(s32_pci->phy0, PHY_MODE_PCIE, 0, NULL)) {
+			dev_err(pcie->dev, "Failed to get link up with EP connected\n");
+			return ret;
+		}
+	}
 
 #ifdef CONFIG_PCI_MSI
 	if (!s32gen1_has_msi_parent(pp))
@@ -1284,8 +1294,12 @@ static int s32gen1_pcie_init_controller(struct s32gen1_pcie *s32_pp)
 	/* Only wait for link if RC */
 	if (!s32_pp->is_endpoint) {
 		ret = wait_phy_data_link(s32_pp);
-		if (ret)
-			return ret;
+		if (ret) {
+			if (!phy_validate(s32_pp->phy0, PHY_MODE_PCIE, 0, NULL)) {
+				dev_err(pcie->dev, "Failed to get link up with EP connected\n");
+				return ret;
+			}
+		}
 	}
 
 	dev_info(pcie->dev, "Configuring as %s\n",
diff --git a/drivers/phy/freescale/phy-fsl-s32gen1-serdes.c b/drivers/phy/freescale/phy-fsl-s32gen1-serdes.c
index 9e21340c1663..e9a0602004b5 100644
--- a/drivers/phy/freescale/phy-fsl-s32gen1-serdes.c
+++ b/drivers/phy/freescale/phy-fsl-s32gen1-serdes.c
@@ -48,6 +48,9 @@
 #define  PHY_REG_EN		BIT(31)
 #define PHY_REG_DATA		(0x4)
 
+#define PHY_SS_RO_REG_0		(0xE0)
+#define PHY_RX0_LOS			BIT(1)
+
 #define RAWLANE0_DIG_PCS_XF_RX_EQ_DELTA_IQ_OVRD_IN	(0x3019)
 #define RAWLANE1_DIG_PCS_XF_RX_EQ_DELTA_IQ_OVRD_IN	(0x3119)
 
@@ -516,12 +519,33 @@ static int serdes_phy_configure(struct phy *phy, union phy_configure_opts *opts)
 
 }
 
+static int serdes_phy_validate(struct phy *p, enum phy_mode mode, int submode,
+			       union phy_configure_opts *opts)
+{
+	struct serdes *serdes = phy_get_drvdata(p);
+	struct serdes_ctrl *sctrl = &serdes->ctrl;
+	u32 reg;
+
+	if (p->attrs.mode != PHY_MODE_PCIE)
+		return -EPERM;
+
+	/* Check if the receiver has lost the signal */
+	reg = readl(sctrl->ss_base + PHY_SS_RO_REG_0);
+	if (reg & PHY_RX0_LOS) {
+		/* Lost Phy signal */
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static const struct phy_ops serdes_ops = {
 	.reset		= serdes_phy_reset,
 	.init		= serdes_phy_init,
 	.set_mode	= serdes_phy_set_mode_ext,
 	.power_on	= serdes_phy_power_on,
 	.power_off	= serdes_phy_power_off,
+	.validate	= serdes_phy_validate,
 	.release	= serdes_phy_release,
 	.configure	= serdes_phy_configure,
 	.owner		= THIS_MODULE,
-- 
2.17.1

