From d11abf36559bf133cd7852261603b25ac30c7bf2 Mon Sep 17 00:00:00 2001
From: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
Date: Wed, 13 Oct 2021 15:37:46 +0300
Subject: [PATCH 19/20] pcie: e1000: Fix crash with surprise hot-unplug when
 eth1 up

When the network interface corresponding to e1000 NIC is up and
e1000 is surprise hot removed the 'e1000_close' and
'e1000_vlan_rx_kill_vid' routines are trying to read/write
registers from e1000 NIC which leads to a Kernel crash.

As part of this commit, we guard these sections using
'pci_channel_offline' call in order to determine if the
e1000 NIC is present or not in the PCIe slot.

Issue: ALB-7899
Upstream-Status: Pending 

Signed-off-by: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/net/ethernet/intel/e1000e/netdev.c | 28 +++++++++++++---------
 1 file changed, 17 insertions(+), 11 deletions(-)

diff --git a/drivers/net/ethernet/intel/e1000e/netdev.c b/drivers/net/ethernet/intel/e1000e/netdev.c
index 639fdb41176a..8283ecc932d3 100644
--- a/drivers/net/ethernet/intel/e1000e/netdev.c
+++ b/drivers/net/ethernet/intel/e1000e/netdev.c
@@ -2744,11 +2744,13 @@ static int e1000_vlan_rx_kill_vid(struct net_device *netdev,
 	}
 
 	/* remove VID from filter table */
-	if (adapter->flags & FLAG_HAS_HW_VLAN_FILTER) {
-		index = (vid >> 5) & 0x7F;
-		vfta = E1000_READ_REG_ARRAY(hw, E1000_VFTA, index);
-		vfta &= ~BIT((vid & 0x1F));
-		hw->mac.ops.write_vfta(hw, index, vfta);
+	if (!pci_channel_offline(adapter->pdev)) {
+		if (adapter->flags & FLAG_HAS_HW_VLAN_FILTER) {
+			index = (vid >> 5) & 0x7F;
+			vfta = E1000_READ_REG_ARRAY(hw, E1000_VFTA, index);
+			vfta &= ~BIT((vid & 0x1F));
+			hw->mac.ops.write_vfta(hw, index, vfta);
+		}
 	}
 
 	clear_bit(vid, adapter->active_vlans);
@@ -4736,7 +4738,8 @@ int e1000e_close(struct net_device *netdev)
 
 	pm_runtime_get_sync(&pdev->dev);
 
-	if (netif_device_present(netdev)) {
+	if (netif_device_present(netdev) &&
+	    !pci_channel_offline(adapter->pdev)) {
 		e1000e_down(adapter, true);
 		e1000_free_irq(adapter);
 
@@ -4759,9 +4762,11 @@ int e1000e_close(struct net_device *netdev)
 	/* If AMT is enabled, let the firmware know that the network
 	 * interface is now closed
 	 */
-	if ((adapter->flags & FLAG_HAS_AMT) &&
-	    !test_bit(__E1000_TESTING, &adapter->state))
-		e1000e_release_hw_control(adapter);
+	if (!pci_channel_offline(adapter->pdev)) {
+		if ((adapter->flags & FLAG_HAS_AMT) &&
+		    !test_bit(__E1000_TESTING, &adapter->state))
+			e1000e_release_hw_control(adapter);
+	}
 
 	cpu_latency_qos_remove_request(&adapter->pm_qos_req);
 
@@ -7710,10 +7715,11 @@ static void e1000_remove(struct pci_dev *pdev)
 	/* Release control of h/w to f/w.  If f/w is AMT enabled, this
 	 * would have already happened in close and is redundant.
 	 */
-	if (!pci_channel_offline(pdev))
+	if (!pci_channel_offline(pdev)) {
 		e1000e_release_hw_control(adapter);
+		e1000e_reset_interrupt_capability(adapter);
+	}
 
-	e1000e_reset_interrupt_capability(adapter);
 	kfree(adapter->tx_ring);
 	kfree(adapter->rx_ring);
 
-- 
2.17.1

