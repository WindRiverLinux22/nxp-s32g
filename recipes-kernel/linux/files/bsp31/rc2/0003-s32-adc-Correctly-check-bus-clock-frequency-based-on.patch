From 0b953d84bda5e05bc061c978a819a55d15b6d9ce Mon Sep 17 00:00:00 2001
From: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
Date: Fri, 17 Sep 2021 10:30:25 +0300
Subject: [PATCH 03/20] s32: adc: Correctly check bus clock frequency based on
 S32 platform flavours

On S32V234 platforms, using the 'ADCLKDIV' field from the MCR register,
there is the posibility of dividing the bus clock frequency by four.
On the other hand, on S32-GEN1 platform, this field is reserved,
and therefore the posibilities are to directly use the bus clock
frequency or divide it by two, by using the 'ADCLKSEL' field from
the same MCR register.

Issue: ALB-7726
Upstream-Status: Pending 

Signed-off-by: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/iio/adc/s32_adc.c | 42 +++++++++++++++++++--------------------
 1 file changed, 21 insertions(+), 21 deletions(-)

diff --git a/drivers/iio/adc/s32_adc.c b/drivers/iio/adc/s32_adc.c
index d9beeb79f4de..e4a03c7f99a4 100644
--- a/drivers/iio/adc/s32_adc.c
+++ b/drivers/iio/adc/s32_adc.c
@@ -291,18 +291,19 @@ static void s32_adc_calibration(struct s32_adc *info)
 	}
 
 	/* set AD_clk frequency to 40 MHz */
-	mcr_data &= ~ADC_ADCLKSEL & ~ADC_ADCLKDIV;
+	mcr_data &= ~ADC_ADCLKSEL;
 	clk_rate = clk_get_rate(info->clk);
-	switch (clk_rate) {
-	case ADC_CLK_FREQ_40MHz:
+	if (clk_rate == ADC_CLK_FREQ_40MHz) {
+		/* AD_CLK frequency is equal to bus clock frequency */
 		mcr_data |= ADC_ADCLKSEL;
-		break;
-	case ADC_CLK_FREQ_80MHz:
-		break;
-	case ADC_CLK_FREQ_160MHz:
-		mcr_data |= ADC_ADCLKDIV;
-		break;
-	default:
+	} else if (clk_rate == ADC_CLK_FREQ_160MHz) {
+		if (of_device_is_compatible(np, "fsl,s32v234-adc")) {
+			/* AD_clk is bus_clock divded by four */
+			mcr_data |= ADC_ADCLKDIV;
+		} else {
+			dev_err(info->dev, "Bad bus clock frequency\n");
+		}
+	} else if (clk_rate != ADC_CLK_FREQ_80MHz) {
 		dev_err(info->dev, "Bad bus clock frequency\n");
 	}
 
@@ -358,6 +359,8 @@ static void s32_adc_calibration(struct s32_adc *info)
 static void s32_adc_sample_set(struct s32_adc *info)
 {
 	struct s32_adc_feature *adc_feature = &info->adc_feature;
+	struct device_node *np = info->dev->of_node;
+	enum freq_sel freq_sel = adc_feature->freq_sel;
 	int mcr_data, ctr_data = 0, group;
 
 	/* configure AD_clk frequency */
@@ -365,18 +368,15 @@ static void s32_adc_sample_set(struct s32_adc *info)
 	mcr_data |= ADC_PWDN;
 	writel(mcr_data, info->regs + REG_ADC_MCR);
 
-	mcr_data &= ~ADC_ADCLKSEL & ~ADC_ADCLKDIV;
-
-	switch (adc_feature->freq_sel) {
-	case ADC_BUSCLK_EQUAL:
+	mcr_data &= ~ADC_ADCLKSEL;
+	if (freq_sel == ADC_BUSCLK_EQUAL) {
 		mcr_data |= ADC_ADCLKSEL;
-		break;
-	case ADC_BUSCLK_HALF:
-		break;
-	case ADC_BUSCLK_FOURTH:
-		mcr_data |= ADC_ADCLKDIV;
-		break;
-	default:
+	} else if (freq_sel == ADC_BUSCLK_FOURTH) {
+		if (of_device_is_compatible(np, "fsl,s32v234-adc"))
+			mcr_data |= ADC_ADCLKDIV;
+		else
+			dev_err(info->dev, "error frequency selection\n");
+	} else if (freq_sel != ADC_BUSCLK_HALF) {
 		dev_err(info->dev, "error frequency selection\n");
 	}
 
-- 
2.17.1

