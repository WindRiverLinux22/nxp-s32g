From 3314ec7f617271256dfa6dcafba601114361d992 Mon Sep 17 00:00:00 2001
From: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
Date: Tue, 28 Sep 2021 13:13:56 +0300
Subject: [PATCH 16/20] linux-s32: pcie: Add Hot-Plug support

We use 'misc' irq as a Hot-Plug interrupt source.

Issue: ALB-7701
Upstream-Status: Pending 

Signed-off-by: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/pci/controller/dwc/pci-s32gen1-regs.h |   6 +
 drivers/pci/controller/dwc/pci-s32gen1.c      | 180 ++++++++++++++++--
 drivers/pci/controller/dwc/pci-s32gen1.h      |   3 +
 3 files changed, 178 insertions(+), 11 deletions(-)

diff --git a/drivers/pci/controller/dwc/pci-s32gen1-regs.h b/drivers/pci/controller/dwc/pci-s32gen1-regs.h
index d7f8d68dfbbe..2f43a0e59372 100644
--- a/drivers/pci/controller/dwc/pci-s32gen1-regs.h
+++ b/drivers/pci/controller/dwc/pci-s32gen1-regs.h
@@ -50,6 +50,12 @@
 
 #define PCIE_CAP_DEVICE_CONTROL_DEVICE_STATUS (PCIE_CAP_BASEADDRESS + 0x8)
 
+/* Slot Control and Status Register */
+#define PCIE_SLOT_CONTROL_SLOT_STATUS		(PCIE_CAP_BASEADDRESS + 0x18)
+#define PCIE_CAP_PRESENCE_DETECT_CHANGE_EN	BIT(3)
+#define PCIE_CAP_HOT_PLUG_INT_EN			BIT(5)
+#define PCIE_CAP_DLL_STATE_CHANGED_EN		BIT(12)
+
 /* Link Control 2 and Status 2 Register. */
 
 #define PCIE_CAP_LINK_CONTROL2_LINK_STATUS2_REG (PCIE_CAP_BASEADDRESS + 0x30)
diff --git a/drivers/pci/controller/dwc/pci-s32gen1.c b/drivers/pci/controller/dwc/pci-s32gen1.c
index cd99354373ca..2c79a3cd31e7 100644
--- a/drivers/pci/controller/dwc/pci-s32gen1.c
+++ b/drivers/pci/controller/dwc/pci-s32gen1.c
@@ -526,6 +526,30 @@ static void s32gen1_pcie_disable_hot_unplug_irq(struct s32gen1_pcie *pci)
 	BCLR32(pci, ctrl, LINK_INT_CTRL_STS, LINK_REQ_RST_NOT_INT_EN);
 }
 
+static void s32gen1_pcie_disable_hot_plug_irq(struct dw_pcie *pcie)
+{
+	u32 reg;
+
+	dw_pcie_dbi_ro_wr_en(pcie);
+	reg = dw_pcie_readl_dbi(pcie, PCIE_SLOT_CONTROL_SLOT_STATUS);
+	reg &= ~(PCIE_CAP_PRESENCE_DETECT_CHANGE_EN | PCIE_CAP_HOT_PLUG_INT_EN |
+			PCIE_CAP_DLL_STATE_CHANGED_EN);
+	dw_pcie_writel_dbi(pcie, PCIE_SLOT_CONTROL_SLOT_STATUS, reg);
+	dw_pcie_dbi_ro_wr_dis(pcie);
+}
+
+static void s32gen1_pcie_enable_hot_plug_irq(struct dw_pcie *pcie)
+{
+	u32 reg;
+
+	dw_pcie_dbi_ro_wr_en(pcie);
+	reg = dw_pcie_readl_dbi(pcie, PCIE_SLOT_CONTROL_SLOT_STATUS);
+	reg |= (PCIE_CAP_PRESENCE_DETECT_CHANGE_EN | PCIE_CAP_HOT_PLUG_INT_EN |
+			PCIE_CAP_DLL_STATE_CHANGED_EN);
+	dw_pcie_writel_dbi(pcie, PCIE_SLOT_CONTROL_SLOT_STATUS, reg);
+	dw_pcie_dbi_ro_wr_dis(pcie);
+}
+
 static void s32gen1_pcie_disable_ltssm(struct s32gen1_pcie *pci)
 {
 	DEBUG_FID(pci->id);
@@ -595,6 +619,42 @@ static struct pci_bus *s32gen1_get_child_downstream_bus(struct pci_bus *bus)
 	return root_bus;
 }
 
+static int s32gen1_enable_hotplug_cap(struct dw_pcie *pcie)
+{
+	struct pcie_port *pp = &pcie->pp;
+	struct pci_bus *bus = pp->bridge->bus;
+	struct pci_bus *root_bus;
+	struct pci_dev *dev;
+	int pos;
+	u32 reg32;
+	u16 reg16;
+
+	root_bus = s32gen1_get_child_downstream_bus(bus);
+	if (IS_ERR(root_bus)) {
+		dev_err(pcie->dev, "Failed to find downstream devices\n");
+		return PTR_ERR(root_bus);
+	}
+	dev = root_bus->self;
+
+	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	if (!pos) {
+		dev_err(pcie->dev, "Unable to find PCI_CAP_ID_EXP capability\n");
+		return -ENXIO;
+	}
+
+	pci_read_config_word(dev, pos + PCI_EXP_FLAGS, &reg16);
+	reg16 |= PCI_EXP_FLAGS_SLOT;
+	pci_write_config_word(dev, pos + PCI_EXP_FLAGS, reg16);
+
+	pcie_capability_read_dword(dev, PCI_EXP_SLTCAP, &reg32);
+	reg32 |= (PCI_EXP_SLTCAP_HPC | PCI_EXP_SLTCAP_HPS);
+	pcie_capability_write_dword(dev, PCI_EXP_SLTCAP, reg32);
+
+	s32gen1_pcie_enable_hot_plug_irq(pcie);
+
+	return 0;
+}
+
 static int s32gen1_pcie_start_link(struct dw_pcie *pcie)
 {
 	struct s32gen1_pcie *s32_pp = to_s32gen1_from_dw_pcie(pcie);
@@ -780,6 +840,7 @@ static irqreturn_t s32gen1_pcie_hot_unplug_thread(int irq, void *arg)
 	struct pci_bus *bus = pp->bridge->bus;
 	struct pci_bus *root_bus;
 	struct pci_dev *pdev, *temp;
+	int ret;
 
 	pci_lock_rescan_remove();
 
@@ -800,6 +861,62 @@ static irqreturn_t s32gen1_pcie_hot_unplug_thread(int irq, void *arg)
 		pci_dev_put(pdev);
 	}
 
+	ret = s32gen1_enable_hotplug_cap(pcie);
+	if (ret)
+		dev_err(pcie->dev, "Failed to enable hotplug capability\n");
+
+out_unlock_rescan:
+	pci_unlock_rescan_remove();
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t s32gen1_pcie_hot_plug_irq(int irq, void *arg)
+{
+	struct s32gen1_pcie *s32_pci = arg;
+
+	BSET32(s32_pci, ctrl, PE0_INT_STS, HP_INT_STS);
+
+	/* if EP is not connected, we exit */
+	if (phy_validate(s32_pci->phy0, PHY_MODE_PCIE, 0, NULL))
+		return IRQ_HANDLED;
+
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t s32gen1_pcie_hot_plug_thread(int irq, void *arg)
+{
+	struct s32gen1_pcie *s32_pci = arg;
+	struct dw_pcie *pcie = &s32_pci->pcie;
+	struct pcie_port *pp = &pcie->pp;
+	struct pci_bus *bus = pp->bridge->bus;
+	struct pci_dev *dev;
+	struct pci_bus *root_bus;
+	int num, ret;
+
+	pci_lock_rescan_remove();
+
+	root_bus = s32gen1_get_child_downstream_bus(bus);
+	if (IS_ERR(root_bus)) {
+		dev_err(pcie->dev, "Failed to find downstream devices\n");
+		goto out_unlock_rescan;
+	}
+
+	num = pci_scan_slot(root_bus, PCI_DEVFN(0, 0));
+	if (!num) {
+		dev_err(pcie->dev, "No new device found\n");
+		goto out_unlock_rescan;
+	}
+
+	for_each_pci_bridge(dev, root_bus) {
+		ret = pci_hp_add_bridge(dev);
+		if (ret)
+			dev_warn(pcie->dev, "Failed to add hp bridge\n");
+	}
+
+	pci_assign_unassigned_bridge_resources(root_bus->self);
+	pcie_bus_configure_settings(root_bus);
+	pci_bus_add_devices(root_bus);
+
 out_unlock_rescan:
 	pci_unlock_rescan_remove();
 	return IRQ_HANDLED;
@@ -833,6 +950,42 @@ static int s32gen1_pcie_config_irq(int *irq_id, char *irq_name,
 	return 0;
 }
 
+static int s32gen1_pcie_config_hp_irq(struct s32gen1_pcie *s32_pp,
+				      struct platform_device *pdev)
+{
+	int irq_id, ret;
+
+	irq_id = platform_get_irq_byname(pdev, "link_req_stat");
+	if (irq_id <= 0) {
+		dev_err(&pdev->dev, "Failed to get link_req_stat irq\n");
+		return -ENODEV;
+	}
+
+	ret = request_threaded_irq(irq_id, s32gen1_pcie_hot_unplug_irq,
+				   s32gen1_pcie_hot_unplug_thread, IRQF_SHARED,
+				   "s32gen1-pcie-hot-unplug", s32_pp);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to request link_reg_stat irq\n");
+		return ret;
+	}
+
+	irq_id = platform_get_irq_byname(pdev, "misc");
+	if (irq_id <= 0) {
+		dev_err(&pdev->dev, "Failed to get misc irq\n");
+		return -ENODEV;
+	}
+
+	ret = request_threaded_irq(irq_id, s32gen1_pcie_hot_plug_irq,
+				   s32gen1_pcie_hot_plug_thread, IRQF_SHARED,
+				   "s32gen1-pcie-hotplug", s32_pp);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to request misc irq\n");
+		return ret;
+	}
+
+	return ret;
+}
+
 static int __init s32gen1_add_pcie_port(struct pcie_port *pp)
 {
 	struct dw_pcie *pcie = to_dw_pcie_from_pp(pp);
@@ -1385,7 +1538,7 @@ static int s32gen1_pcie_config_common(struct s32gen1_pcie *s32_pp,
 	struct device *dev = &pdev->dev;
 	struct dw_pcie *pcie = &(s32_pp->pcie);
 	struct pcie_port *pp = &(pcie->pp);
-	int irq_id, ret = 0;
+	int ret = 0;
 
 	DEBUG_FID(s32_pp->id);
 
@@ -1495,18 +1648,14 @@ static int s32gen1_pcie_config_common(struct s32gen1_pcie *s32_pp,
 	}
 
 	if (!s32_pp->is_endpoint) {
-		irq_id = platform_get_irq_byname(pdev, "link_req_stat");
-		if (irq_id <= 0) {
-			dev_err(&pdev->dev, "Failed to get link_req_stat irq\n");
-			return -ENODEV;
-		}
+		ret = s32gen1_pcie_config_hp_irq(s32_pp, pdev);
+		if (ret)
+			goto fail_host_init;
 
-		ret = request_threaded_irq(irq_id, s32gen1_pcie_hot_unplug_irq,
-					   s32gen1_pcie_hot_unplug_thread, IRQF_SHARED,
-					   "s32gen1-pcie-hot-unplug", s32_pp);
+		ret = s32gen1_enable_hotplug_cap(pcie);
 		if (ret) {
-			dev_err(&pdev->dev, "Failed to request link_reg_stat irq\n");
-			return ret;
+			dev_err(dev, "Failed to enable hotplug capability\n");
+			goto fail_host_init;
 		}
 
 		s32gen1_pcie_enable_hot_unplug_irq(s32_pp);
@@ -1594,6 +1743,8 @@ static int s32gen1_pcie_suspend(struct device *dev)
 
 	/* Disable Hot-Unplug irq */
 	s32gen1_pcie_disable_hot_unplug_irq(s32_pp);
+	/* Disable Hot-Plug irq */
+	s32gen1_pcie_disable_hot_plug_irq(pcie);
 
 	s32gen1_pcie_downstream_dev_to_D0(s32_pp);
 
@@ -1637,6 +1788,13 @@ static int s32gen1_pcie_resume(struct device *dev)
 	dw_pcie_writel_dbi(pcie, PORT_MSI_CTRL_INT_0_EN_OFF,
 			   s32_pp->msi_ctrl_int);
 
+	/* Enable Hot-Plug capability */
+	ret = s32gen1_enable_hotplug_cap(pcie);
+	if (ret) {
+		dev_err(dev, "Failed to enable hotplug capability\n");
+		goto fail_host_init;
+	}
+
 	/* Enable Hot-Unplug irq */
 	s32gen1_pcie_enable_hot_unplug_irq(s32_pp);
 
diff --git a/drivers/pci/controller/dwc/pci-s32gen1.h b/drivers/pci/controller/dwc/pci-s32gen1.h
index 9aee7c9716ff..4d6b6d46aee1 100644
--- a/drivers/pci/controller/dwc/pci-s32gen1.h
+++ b/drivers/pci/controller/dwc/pci-s32gen1.h
@@ -59,6 +59,9 @@
 #define LINK_REQ_RST_NOT_INT_EN	BIT(1)
 #define LINK_REQ_RST_NOT_CLR	BIT(2)
 
+#define PE0_INT_STS				0xE8
+#define HP_INT_STS				BIT(6)
+
 #define to_s32gen1_from_dw_pcie(x) \
 	container_of(x, struct s32gen1_pcie, pcie)
 
-- 
2.17.1

