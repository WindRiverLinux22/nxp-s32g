From cc717e318a00c43a6430f6572c79374e4e689ef0 Mon Sep 17 00:00:00 2001
From: Zhantao Tang <zhantao.tang@windriver.com>
Date: Tue, 12 Oct 2021 12:20:35 +0800
Subject: [PATCH 3/4] Revert "crypto: hse: wait for firmware init on resume"

This reverts commit 7e996b1bdf27b4d77e826646136a460ca7179017.

This patch is to make the pkcs11-hse userspace demo work normally.

Upstream-Status: Pending

Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/crypto/hse/hse-abi.h  |  9 ----
 drivers/crypto/hse/hse-core.c | 82 +++++++++++------------------------
 drivers/crypto/hse/hse-mu.c   | 13 ------
 drivers/crypto/hse/hse-mu.h   |  1 -
 4 files changed, 25 insertions(+), 80 deletions(-)

diff --git a/drivers/crypto/hse/hse-abi.h b/drivers/crypto/hse/hse-abi.h
index 11bc8bad4347..b423dafc5258 100644
--- a/drivers/crypto/hse/hse-abi.h
+++ b/drivers/crypto/hse/hse-abi.h
@@ -58,15 +58,6 @@ enum hse_event {
 	HSE_WA_SMR_PERIODIC_CHECK_FAILED = BIT(8),
 };
 
-/**
- * enum hse_host_event - HSE host event
- * @HSE_HOST_PERIPH_CONFIG_DONE: sent by the host to notify HSE when external
- *				 peripherals have been configured at init-time
- */
-enum hse_host_event {
-	HSE_HOST_PERIPH_CONFIG_DONE = BIT(0),
-};
-
 /**
  * enum hse_srv_id - HSE service ID
  * @HSE_SRV_ID_GET_ATTR: get attribute, such as firmware version
diff --git a/drivers/crypto/hse/hse-core.c b/drivers/crypto/hse/hse-core.c
index 6a4665bdfb0a..dcc2b3984ad6 100644
--- a/drivers/crypto/hse/hse-core.c
+++ b/drivers/crypto/hse/hse-core.c
@@ -22,8 +22,8 @@
 /**
  * enum hse_fw_status - HSE firmware status
  * @HSE_FW_SHUTDOWN: firmware not initialized or shut down due to fatal error
- * @HSE_FW_RUNNING: firmware running and able to service any type of request
- * @HSE_FW_STANDBY: firmware considered in stand-by state, no crypto requests
+ * @HSE_FW_RUNNING: firmware running
+ * @HSE_FW_STANDBY: firmware standby
  */
 enum hse_fw_status {
 	HSE_FW_SHUTDOWN = 0u,
@@ -85,15 +85,13 @@ struct hse_drvdata {
 };
 
 /**
- * hse_get_fw_version - retrieve firmware version
+ * hse_print_fw_version - print firmware version
  * @dev: HSE device
  *
- * Attribute buffer is encoded into the descriptor to get around HSE memory
- * access limitations and avoid DMA copy in upper range of 32-bit address space.
- *
- * Return: firmware version attribute
+ * Get firmware version attribute from HSE and print it. Attribute buffer is
+ * encoded into the descriptor to get around HSE memory access limitations.
  */
-static struct hse_attr_fw_version *hse_get_fw_version(struct device *dev)
+static void hse_print_fw_version(struct device *dev)
 {
 	struct hse_drvdata *drv = dev_get_drvdata(dev);
 	struct hse_srv_desc srv_desc;
@@ -115,10 +113,16 @@ static struct hse_attr_fw_version *hse_get_fw_version(struct device *dev)
 	err = hse_srv_req_sync(dev, HSE_CHANNEL_ADM, &srv_desc);
 	if (unlikely(err)) {
 		dev_dbg(dev, "%s: request failed: %d\n", __func__, err);
-		return ERR_PTR(err);
+		return;
 	}
 
-	return fw_ver;
+	dev_info(dev, "firmware type %d, version %d.%d.%d\n", fw_ver->fw_type,
+		 fw_ver->major, fw_ver->minor, fw_ver->patch);
+
+	drv->rng_srv_id = HSE_SRV_ID_GET_RANDOM_NUM;
+	if (fw_ver->major == 0u && fw_ver->minor == 9u &&
+	    (fw_ver->patch == 0u || fw_ver->patch == 1u))
+		drv->rng_srv_id |= 0x00A50000ul;
 }
 
 u32 _get_rng_srv_id(struct device *dev)
@@ -786,7 +790,6 @@ static int hse_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct hse_drvdata *drv;
-	struct hse_attr_fw_version *fw_ver;
 	void *desc_base_ptr;
 	u64 desc_base_dma;
 	u16 status;
@@ -813,6 +816,7 @@ static int hse_probe(struct platform_device *pdev)
 		dev_err(dev, "firmware not found\n");
 		return -ENODEV;
 	}
+	drv->firmware_status = HSE_FW_RUNNING;
 
 	/* manage channels and descriptor space */
 	hse_manage_channels(dev, desc_base_ptr, desc_base_dma);
@@ -827,23 +831,8 @@ static int hse_probe(struct platform_device *pdev)
 	hse_mu_irq_enable(drv->mu, HSE_INT_SYS_EVENT, HSE_EVT_MASK_WARN);
 	hse_mu_irq_enable(drv->mu, HSE_INT_SYS_EVENT, HSE_EVT_MASK_ERR);
 
-	/* enable service requests */
-	drv->firmware_status = HSE_FW_RUNNING;
-
 	/* check firmware version */
-	fw_ver = hse_get_fw_version(dev);
-	if (IS_ERR_OR_NULL(fw_ver)) {
-		err = PTR_ERR(fw_ver);
-		goto err_probe_failed;
-	}
-
-	dev_info(dev, "firmware type %d, version %d.%d.%d\n", fw_ver->fw_type,
-		 fw_ver->major, fw_ver->minor, fw_ver->patch);
-
-	drv->rng_srv_id = HSE_SRV_ID_GET_RANDOM_NUM;
-	if (fw_ver->major == 0u && fw_ver->minor == 9u &&
-	    (fw_ver->patch == 0u || fw_ver->patch == 1u))
-		drv->rng_srv_id |= 0x00A50000ul;
+	hse_print_fw_version(dev);
 
 	/* check HSE global status */
 	if (IS_ENABLED(CONFIG_CRYPTO_DEV_NXP_HSE_HWRNG) &&
@@ -937,58 +926,37 @@ static int hse_pm_suspend(struct device *dev)
 	srv_desc.srv_id = HSE_SRV_ID_PREPARE_FOR_STANDBY;
 	err = hse_srv_req_sync(dev, HSE_CHANNEL_ADM, &srv_desc);
 
-	/* cancel other requests */
+	/* cancel all requests */
 	hse_srv_req_cancel_all(dev);
 
 	if (unlikely(err && err != -EPERM)) {
+		drv->firmware_status = HSE_FW_RUNNING;
 		dev_err(dev, "%s: request failed: %d\n", __func__, err);
-		goto err_enable_irq;
+		return err;
 	}
 
 	dev_info(dev, "firmware prepared for stand-by\n");
 
 	return 0;
-err_enable_irq:
-	hse_mu_irq_enable(drv->mu, HSE_INT_RESPONSE, HSE_CH_MASK_ALL);
-	drv->firmware_status = HSE_FW_RUNNING;
-	return err;
 }
 
 static int hse_pm_resume(struct device *dev)
 {
 	struct hse_drvdata *drv = dev_get_drvdata(dev);
-	struct hse_attr_fw_version *fw_ver;
 	u16 status;
 
-	/* signal firmware that peripheral configuration is done */
-	hse_mu_trigger_event(drv->mu, HSE_HOST_PERIPH_CONFIG_DONE);
+	/* check firmware status */
+	status = hse_mu_check_status(drv->mu);
+	if (!likely(status & HSE_STATUS_INIT_OK)) {
+		dev_err(dev, "firmware not running\n");
+		return -ENODEV;
+	}
 
 	/* enable RX and event notifications */
 	hse_mu_irq_enable(drv->mu, HSE_INT_RESPONSE, HSE_CH_MASK_ALL);
 	hse_mu_irq_enable(drv->mu, HSE_INT_SYS_EVENT, HSE_EVT_MASK_WARN);
 	hse_mu_irq_enable(drv->mu, HSE_INT_SYS_EVENT, HSE_EVT_MASK_ERR);
 
-	/* check firmware status */
-	status = hse_mu_check_status(drv->mu);
-	if (!(status & HSE_STATUS_INIT_OK)) {
-		/* wait for firmware init */
-		fw_ver = hse_get_fw_version(dev);
-		if (IS_ERR_OR_NULL(fw_ver)) {
-			dev_err(dev, "%s: request failed: %ld\n", __func__,
-				PTR_ERR(fw_ver));
-			return PTR_ERR(fw_ver);
-		}
-		status = hse_mu_check_status(drv->mu);
-	}
-
-	if (IS_ENABLED(CONFIG_CRYPTO_DEV_NXP_HSE_HWRNG) &&
-	    !likely(status & HSE_STATUS_RNG_INIT_OK))
-		dev_err(dev, "RNG not initialized\n");
-	if (!likely(status & HSE_STATUS_INSTALL_OK))
-		dev_err(dev, "key catalogs not formatted\n");
-	if (unlikely(status & HSE_STATUS_PUBLISH_SYS_IMAGE))
-		dev_warn(dev, "volatile configuration, publish SYS_IMAGE\n");
-
 	drv->firmware_status = HSE_FW_RUNNING;
 	dev_info(dev, "device resumed, status 0x%04X\n", status);
 
diff --git a/drivers/crypto/hse/hse-mu.c b/drivers/crypto/hse/hse-mu.c
index 76753077c03e..bc21da4e1449 100644
--- a/drivers/crypto/hse/hse-mu.c
+++ b/drivers/crypto/hse/hse-mu.c
@@ -103,19 +103,6 @@ u32 hse_mu_check_event(void *mu)
 	return ioread32(&priv->regs->gsr);
 }
 
-/**
- * hse_mu_trigger_event - trigger HSE host event
- * @mu: MU instance handle
- *
- * Return: HSE host event mask
- */
-void hse_mu_trigger_event(void *mu, u32 evt)
-{
-	struct hse_mu_data *priv = mu;
-
-	return iowrite32(evt, &priv->regs->gcr);
-}
-
 /**
  * hse_mu_irq_enable - enable a specific type of interrupt using a mask
  * @mu: MU instance handle
diff --git a/drivers/crypto/hse/hse-mu.h b/drivers/crypto/hse/hse-mu.h
index a2bdec7cc723..f77628ebe48f 100644
--- a/drivers/crypto/hse/hse-mu.h
+++ b/drivers/crypto/hse/hse-mu.h
@@ -46,7 +46,6 @@ void *hse_mu_init(struct device *dev, void **desc_base_ptr, u64 *desc_base_dma,
 
 u16 hse_mu_check_status(void *mu);
 u32 hse_mu_check_event(void *mu);
-void hse_mu_trigger_event(void *mu, u32 evt);
 
 void hse_mu_irq_enable(void *mu, enum hse_irq_type irq_type, u32 irq_mask);
 void hse_mu_irq_disable(void *mu, enum hse_irq_type irq_type, u32 irq_mask);
-- 
2.25.1

