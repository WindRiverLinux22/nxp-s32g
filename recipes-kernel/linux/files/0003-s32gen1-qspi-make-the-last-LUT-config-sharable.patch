From d020e27e1f73a989ec9c1728194be0e2f7d86832 Mon Sep 17 00:00:00 2001
From: Quanyang Wang <quanyang.wang@windriver.com>
Date: Tue, 17 May 2022 17:47:11 +0800
Subject: [PATCH 3/3] s32gen1: qspi: make the last LUT config sharable

There are 80 LUTs in qspi controller, and every 5 LUTs form a sequence
to generate a valid flash transaction. A sequence corresponds to a LUT
config. And the maximum of LUT configs are 16.

Now the implimentation of s32g qspi driver is that one type of cmd
opcode occupies one LUT config. This means that this driver only
operates 16 types of cmd.

We can make the last LUT config which is the 15th to be sharable, the
previous 15 cmd can occupy 15 LUT configs, all the left cmds share the
15th LUT config.

Upstream-Status: Pending

Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/spi/s32gen1-qspi.c | 20 ++++++++++----------
 1 file changed, 10 insertions(+), 10 deletions(-)

diff --git a/drivers/spi/s32gen1-qspi.c b/drivers/spi/s32gen1-qspi.c
index d7707e3dc10c..593e44008265 100644
--- a/drivers/spi/s32gen1-qspi.c
+++ b/drivers/spi/s32gen1-qspi.c
@@ -114,6 +114,8 @@
 
 #define QUADSPI_S32GEN1_HIGH_FREQUENCY_VALUE	200000000
 
+#define S32GEN1_LAST_CONF_INDEX (S32GEN1_MAX_LUTS_CONFIGS - 1)
+
 struct qspi_op {
 	const struct spi_mem_op *op;
 	u8 *cfg;
@@ -519,10 +521,10 @@ static bool add_op_to_lutdb(struct fsl_qspi *q,
 
 	if (!lut_conf->index) {
 		lut_conf->index = q->luts_next_config;
-		q->luts_next_config++;
+		if (q->luts_next_config != S32GEN1_LAST_CONF_INDEX)
+			q->luts_next_config++;
 	}
 	*index = lut_conf->index;
-
 	return true;
 }
 
@@ -559,15 +561,13 @@ static bool enable_op(struct fsl_qspi *q, const struct spi_mem_op *op)
 	u8 lut_index;
 	u8 opcode  = get_cmd_opcode(op);
 
-	if (q->luts_next_config >= S32GEN1_MAX_LUTS_CONFIGS)
-		return false;
-
 	if (!q->lut_configs[opcode].enabled) {
 		if (!add_op_to_lutdb(q, op, &lut_index))
 			return false;
 
 		set_lut(q, lut_index, opcode);
-		q->lut_configs[opcode].enabled = true;
+		if (lut_index < S32GEN1_LAST_CONF_INDEX)
+			q->lut_configs[opcode].enabled = true;
 	}
 
 	return true;
@@ -1098,14 +1098,14 @@ int s32gen1_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)
 	if (!s32gen1_supports_op(mem, op))
 		return -1;
 
-	enabled = q->lut_configs[opcode].enabled;
-	if (!enabled)
-		return -1;
-
 	lut_cfg = q->lut_configs[opcode].index;
 	if (lut_cfg == LUT_INVALID_INDEX)
 		return -1;
 
+	enabled = q->lut_configs[opcode].enabled;
+	if (!enabled && lut_cfg != S32GEN1_LAST_CONF_INDEX)
+		return -1;
+
 	/* Register and memory write */
 	if (op->data.dir == SPI_MEM_DATA_OUT) {
 		q->flags &= ~QUADSPI_FLAG_PREV_READ_MEM;
-- 
2.25.1

