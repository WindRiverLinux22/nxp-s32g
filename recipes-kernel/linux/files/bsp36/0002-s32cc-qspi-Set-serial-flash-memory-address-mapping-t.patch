From 41031dddb320e7ab8eead924e2e710b4ea59a1df Mon Sep 17 00:00:00 2001
From: Ciprian Costea <ciprianmarian.costea@nxp.com>
Date: Thu, 12 Jan 2023 10:39:59 +0200
Subject: [PATCH 02/25] s32cc: qspi: Set serial flash memory address mapping to
 maximum available

On S32CC platforms the QSPI controller can address up to 512 MB of
serial flash memory. SFA1/2 registers are used in this regard,
but they were previously set to 512MB only on read mode (DTR-OPI).

Issue: ALB-9444
Upstream-Status: Pending 

Signed-off-by: Ciprian Costea <ciprianmarian.costea@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>

squash! s32cc: qspi: Set serial flash memory address mapping to maximum available
---
 drivers/spi/spi-fsl-qspi.c | 29 ++++++++++++++++++++---------
 drivers/spi/spi-fsl-qspi.h |  2 ++
 2 files changed, 22 insertions(+), 9 deletions(-)

diff --git a/drivers/spi/spi-fsl-qspi.c b/drivers/spi/spi-fsl-qspi.c
index 422bd982ffc9..a397e54ccbaf 100644
--- a/drivers/spi/spi-fsl-qspi.c
+++ b/drivers/spi/spi-fsl-qspi.c
@@ -7,7 +7,7 @@
  * Copyright (C) 2018 Bootlin
  * Copyright (C) 2018 exceet electronics GmbH
  * Copyright (C) 2018 Kontron Electronics GmbH
- * Copyright 2021-2022 NXP
+ * Copyright 2021-2023 NXP
  *
  * Transition to SPI MEM interface:
  * Authors:
@@ -102,6 +102,8 @@ static const struct fsl_qspi_devtype_data s32gen1_data = {
 	.ahb_buf_size = SZ_1K,
 	.quirks = 0,
 	.little_endian = true,
+	.flash1_size = 0x20000000,
+	.flash2_size = 0x20000000,
 };
 
 static const struct fsl_qspi_devtype_data s32g3_data = {
@@ -110,6 +112,8 @@ static const struct fsl_qspi_devtype_data s32g3_data = {
 	.ahb_buf_size = SZ_1K,
 	.quirks = 0,
 	.little_endian = true,
+	.flash1_size = 0x20000000,
+	.flash2_size = 0x20000000,
 };
 
 static inline int needs_swap_endian(struct fsl_qspi *q)
@@ -652,14 +656,21 @@ static int fsl_qspi_default_setup(struct fsl_qspi *q)
 	 * We use ahb_buf_size for each chip and set SFA1AD, SFA2AD, SFB1AD,
 	 * SFB2AD accordingly.
 	 */
-	qspi_writel(q, q->devtype_data->ahb_buf_size + addr_offset,
-		    base + QUADSPI_SFA1AD);
-	qspi_writel(q, q->devtype_data->ahb_buf_size * 2 + addr_offset,
-		    base + QUADSPI_SFA2AD);
-	qspi_writel(q, q->devtype_data->ahb_buf_size * 3 + addr_offset,
-		    base + QUADSPI_SFB1AD);
-	qspi_writel(q, q->devtype_data->ahb_buf_size * 4 + addr_offset,
-		    base + QUADSPI_SFB2AD);
+	if (!is_s32gen1_qspi(q)) {
+		qspi_writel(q, q->devtype_data->ahb_buf_size + addr_offset,
+			    base + QUADSPI_SFA1AD);
+		qspi_writel(q, q->devtype_data->ahb_buf_size * 2 + addr_offset,
+			    base + QUADSPI_SFA2AD);
+		qspi_writel(q, q->devtype_data->ahb_buf_size * 3 + addr_offset,
+			    base + QUADSPI_SFB1AD);
+		qspi_writel(q, q->devtype_data->ahb_buf_size * 4 + addr_offset,
+			    base + QUADSPI_SFB2AD);
+	} else {
+		qspi_writel(q, q->devtype_data->flash1_size, base + QUADSPI_SFA1AD);
+		qspi_writel(q, q->devtype_data->flash2_size, base + QUADSPI_SFA2AD);
+		qspi_writel(q, q->devtype_data->flash1_size, base + QUADSPI_SFB1AD);
+		qspi_writel(q, q->devtype_data->flash2_size, base + QUADSPI_SFB2AD);
+	}
 
 	q->selected = -1;
 
diff --git a/drivers/spi/spi-fsl-qspi.h b/drivers/spi/spi-fsl-qspi.h
index be7af1dfb5b6..16c687bbeace 100644
--- a/drivers/spi/spi-fsl-qspi.h
+++ b/drivers/spi/spi-fsl-qspi.h
@@ -222,6 +222,8 @@ struct fsl_qspi_devtype_data {
 	unsigned int ahb_buf_size;
 	unsigned int quirks;
 	bool little_endian;
+	u32 flash1_size;
+	u32 flash2_size;
 };
 
 struct fsl_qspi {
-- 
2.25.1

