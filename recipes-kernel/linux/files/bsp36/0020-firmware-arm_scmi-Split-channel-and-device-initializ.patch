From e41bf15012cd2e424e9cc211b84024dd77d47f14 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Mon, 21 Nov 2022 11:58:45 +0200
Subject: [PATCH 20/25] firmware: arm_scmi: Split channel and device
 initialization

Split channel initialization into two parts:
    - Device initialization
    - Channel initialization

This will be useful for the cases when RX and TX channels have
to be initialized.

Issue: ALB-9523
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/firmware/arm_scmi/smc.c | 105 +++++++++++++++++++++++---------
 1 file changed, 75 insertions(+), 30 deletions(-)

diff --git a/drivers/firmware/arm_scmi/smc.c b/drivers/firmware/arm_scmi/smc.c
index 6c7871a40611..4ce712e556b1 100644
--- a/drivers/firmware/arm_scmi/smc.c
+++ b/drivers/firmware/arm_scmi/smc.c
@@ -3,7 +3,7 @@
  * System Control and Management Interface (SCMI) Message SMC/HVC
  * Transport driver
  *
- * Copyright 2020 NXP
+ * Copyright 2020,2022 NXP
  */
 
 #include <linux/arm-smccc.h>
@@ -30,6 +30,7 @@
  * @inflight: Atomic flag to protect access to Tx/Rx shared memory area.
  *	      Used when operating in atomic mode.
  * @func_id: smc/hvc call function id
+ * @node: Linked list pointers
  */
 
 struct scmi_smc {
@@ -37,11 +38,15 @@ struct scmi_smc {
 	struct scmi_shared_mem __iomem *shmem;
 	/* Protect access to shmem area */
 	struct mutex shmem_lock;
+	struct list_head node;
 #define INFLIGHT_NONE	MSG_TOKEN_MAX
 	atomic_t inflight;
 	u32 func_id;
 };
 
+static LIST_HEAD(scmi_smc_devices);
+static DEFINE_MUTEX(smc_devices_lock);
+
 static irqreturn_t smc_msg_done_isr(int irq, void *data)
 {
 	struct scmi_smc *scmi_info = data;
@@ -97,45 +102,21 @@ static inline void smc_channel_lock_release(struct scmi_smc *scmi_info)
 		mutex_unlock(&scmi_info->shmem_lock);
 }
 
-static int smc_chan_setup(struct scmi_chan_info *cinfo, struct device *dev,
-			  bool tx)
+static struct scmi_smc *create_scmi_smc_dev(struct scmi_chan_info *cinfo,
+					    struct device *dev)
 {
 	struct device *cdev = cinfo->dev;
 	struct scmi_smc *scmi_info;
-	resource_size_t size;
-	struct resource res;
-	struct device_node *np;
 	u32 func_id;
 	int ret, irq;
 
-	if (!tx)
-		return -ENODEV;
-
 	scmi_info = devm_kzalloc(dev, sizeof(*scmi_info), GFP_KERNEL);
 	if (!scmi_info)
-		return -ENOMEM;
-
-	np = of_parse_phandle(cdev->of_node, "shmem", 0);
-	if (!of_device_is_compatible(np, "arm,scmi-shmem"))
-		return -ENXIO;
-
-	ret = of_address_to_resource(np, 0, &res);
-	of_node_put(np);
-	if (ret) {
-		dev_err(cdev, "failed to get SCMI Tx shared memory\n");
-		return ret;
-	}
-
-	size = resource_size(&res);
-	scmi_info->shmem = devm_ioremap(dev, res.start, size);
-	if (!scmi_info->shmem) {
-		dev_err(dev, "failed to ioremap SCMI Tx shared memory\n");
-		return -EADDRNOTAVAIL;
-	}
+		return ERR_PTR(-ENOMEM);
 
 	ret = of_property_read_u32(dev->of_node, "arm,smc-id", &func_id);
 	if (ret < 0)
-		return ret;
+		return ERR_PTR(ret);
 
 	/*
 	 * If there is an interrupt named "a2p", then the service and
@@ -149,7 +130,7 @@ static int smc_chan_setup(struct scmi_chan_info *cinfo, struct device *dev,
 				       dev_name(dev), scmi_info);
 		if (ret) {
 			dev_err(dev, "failed to setup SCMI smc irq\n");
-			return ret;
+			return ERR_PTR(ret);
 		}
 	} else {
 		cinfo->no_completion_irq = true;
@@ -160,6 +141,70 @@ static int smc_chan_setup(struct scmi_chan_info *cinfo, struct device *dev,
 	smc_channel_lock_init(scmi_info);
 	cinfo->transport_info = scmi_info;
 
+	return scmi_info;
+}
+
+static struct scmi_smc *get_scmi_smc_dev(struct scmi_chan_info *cinfo,
+					 struct device *dev)
+{
+	struct scmi_smc *smc_dev = NULL;
+	bool found = false;
+
+	mutex_lock(&smc_devices_lock);
+	list_for_each_entry(smc_dev, &scmi_smc_devices, node) {
+		if (smc_dev->cinfo == cinfo) {
+			found = true;
+			break;
+		}
+	}
+
+	if (found)
+		goto release_lock;
+
+	smc_dev = create_scmi_smc_dev(cinfo, dev);
+	if (!IS_ERR(smc_dev))
+		list_add(&smc_dev->node, &scmi_smc_devices);
+
+release_lock:
+	mutex_unlock(&smc_devices_lock);
+	return smc_dev;
+}
+
+static int smc_chan_setup(struct scmi_chan_info *cinfo, struct device *dev,
+			  bool tx)
+{
+	struct device *cdev = cinfo->dev;
+	struct scmi_smc *scmi_info;
+	resource_size_t size;
+	struct resource res;
+	struct device_node *np;
+	int ret;
+
+	if (!tx)
+		return -ENODEV;
+
+	scmi_info = get_scmi_smc_dev(cinfo, dev);
+	if (IS_ERR(scmi_info))
+		return PTR_ERR(scmi_info);
+
+	np = of_parse_phandle(cdev->of_node, "shmem", 0);
+	if (!of_device_is_compatible(np, "arm,scmi-shmem"))
+		return -ENXIO;
+
+	ret = of_address_to_resource(np, 0, &res);
+	of_node_put(np);
+	if (ret) {
+		dev_err(cdev, "failed to get SCMI Tx shared memory\n");
+		return ret;
+	}
+
+	size = resource_size(&res);
+	scmi_info->shmem = devm_ioremap(dev, res.start, size);
+	if (!scmi_info->shmem) {
+		dev_err(dev, "failed to ioremap SCMI Tx shared memory\n");
+		return -EADDRNOTAVAIL;
+	}
+
 	return 0;
 }
 
-- 
2.25.1

