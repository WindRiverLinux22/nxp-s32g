From 647b6ffa34258fd2fd825d1f458ce2fa698a094b Mon Sep 17 00:00:00 2001
From: Ciprian Costea <ciprianmarian.costea@nxp.com>
Date: Fri, 27 Jan 2023 11:04:18 +0200
Subject: [PATCH 42/63] s32cc: ocotp: Add ocotp driver

It adds support for reading fuses from the shadow registers.

Issue: ALB-9677
Upstream-Status: Pending 

Signed-off-by: Ciprian Costea <ciprianmarian.costea@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 arch/arm64/boot/dts/freescale/s32cc.dtsi  |  16 +-
 arch/arm64/boot/dts/freescale/s32g.dtsi   |   4 +
 arch/arm64/boot/dts/freescale/s32r45.dtsi |   4 +
 drivers/nvmem/Kconfig                     |  11 ++
 drivers/nvmem/Makefile                    |   2 +
 drivers/nvmem/s32cc-ocotp-nvmem.c         | 209 ++++++++++++++++++++++
 include/soc/s32cc/fuse.h                  |  33 ++++
 include/soc/s32cc/fuse_defs.h             |  20 +++
 include/soc/s32cc/nvmem_common.h          |  32 ++++
 9 files changed, 329 insertions(+), 2 deletions(-)
 create mode 100644 drivers/nvmem/s32cc-ocotp-nvmem.c
 create mode 100644 include/soc/s32cc/fuse.h
 create mode 100644 include/soc/s32cc/fuse_defs.h
 create mode 100644 include/soc/s32cc/nvmem_common.h

diff --git a/arch/arm64/boot/dts/freescale/s32cc.dtsi b/arch/arm64/boot/dts/freescale/s32cc.dtsi
index d3302ebd2a4d..eb11abd8003c 100644
--- a/arch/arm64/boot/dts/freescale/s32cc.dtsi
+++ b/arch/arm64/boot/dts/freescale/s32cc.dtsi
@@ -10,6 +10,7 @@
 #include <dt-bindings/clock/s32cc-scmi-clock.h>
 #include <dt-bindings/misc/s32cc-fccu.h>
 #include <dt-bindings/nvmem/s32cc-siul2-nvmem.h>
+#include <dt-bindings/nvmem/s32cc-ocotp-nvmem.h>
 #include <dt-bindings/perf/s32cc-scmi-perf.h>
 #include <dt-bindings/phy/phy.h>
 #include <dt-bindings/phy/phy-s32cc-serdes.h>
@@ -288,13 +289,24 @@ pcie_variant: pcie_variant@4 {
 			};
 		};
 
+		ocotp: ocotp@400a4000 {
+			reg = <0x0 0x400a4000 0x0 0x400>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			status = "okay";
+			tmu_fuse_val: tmu_fuse_val@298 {
+				reg = <TMU_FUSE_OFFSET OCOTP_CELL_SIZE>;
+			};
+		};
+
 		tmu: tmu@400a8000 {
 			compatible = "nxp,s32cc-tmu";
-			reg = <0x0 0x400a8000 0x0 0x3000>,
-				<0x0 0x400a4200 0x0 0x1fc>;
+			reg = <0x0 0x400a8000 0x0 0x3000>;
 			clocks = <&clks S32CC_SCMI_CLK_TMU_MODULE>,
 				<&clks S32CC_SCMI_CLK_TMU_REG>;
 			clock-names = "tmu_module", "tmu_reg";
+			nvmem-cell-names = "tmu_fuse_val";
+			nvmem-cells = <&tmu_fuse_val>;
 			status = "okay";
 		};
 
diff --git a/arch/arm64/boot/dts/freescale/s32g.dtsi b/arch/arm64/boot/dts/freescale/s32g.dtsi
index 820167a32157..08d2f2f5d6c3 100644
--- a/arch/arm64/boot/dts/freescale/s32g.dtsi
+++ b/arch/arm64/boot/dts/freescale/s32g.dtsi
@@ -973,6 +973,10 @@ &pcie1 {
 	msi-parent = <&gic>;
 };
 
+&ocotp {
+	compatible = "nxp,s32g-ocotp";
+};
+
 &qspi {
 	compatible = "nxp,s32g-qspi";
 	pinctrl-names = "default";
diff --git a/arch/arm64/boot/dts/freescale/s32r45.dtsi b/arch/arm64/boot/dts/freescale/s32r45.dtsi
index c420fab5f9a5..0a5793e3b92e 100644
--- a/arch/arm64/boot/dts/freescale/s32r45.dtsi
+++ b/arch/arm64/boot/dts/freescale/s32r45.dtsi
@@ -288,6 +288,10 @@ &pcie1 {
 	msi-parent = <&gic>;
 };
 
+&ocotp {
+	compatible = "nxp,s32r45-ocotp";
+};
+
 &tmu {
 	compatible = "nxp,s32r45-tmu";
 };
diff --git a/drivers/nvmem/Kconfig b/drivers/nvmem/Kconfig
index 9c0405f3a5f8..edd9a2685aef 100644
--- a/drivers/nvmem/Kconfig
+++ b/drivers/nvmem/Kconfig
@@ -203,6 +203,17 @@ config UNIPHIER_EFUSE
 	  This driver can also be built as a module. If so, the module
 	  will be called nvmem-uniphier-efuse.
 
+config NVMEM_S32CC_OCOTP
+	bool "S32CC SoC OCOTP support"
+	depends on SOC_S32CC
+	default y
+	help
+	  This is a driver for the 'OCOTP' peripheral available on S32CC
+	  platforms.
+
+	  If you say Y here, you will get support for the One Time
+	  Programmable memory pages.
+
 config NVMEM_VF610_OCOTP
 	tristate "VF610 SoC OCOTP support"
 	depends on SOC_VF610 || COMPILE_TEST
diff --git a/drivers/nvmem/Makefile b/drivers/nvmem/Makefile
index 8ec08c95321f..bccf8ef9b752 100644
--- a/drivers/nvmem/Makefile
+++ b/drivers/nvmem/Makefile
@@ -53,6 +53,8 @@ obj-$(CONFIG_RAVE_SP_EEPROM)	+= nvmem-rave-sp-eeprom.o
 nvmem-rave-sp-eeprom-y		:= rave-sp-eeprom.o
 obj-$(CONFIG_SC27XX_EFUSE)	+= nvmem-sc27xx-efuse.o
 nvmem-sc27xx-efuse-y		:= sc27xx-efuse.o
+obj-$(CONFIG_NVMEM_S32CC_OCOTP) += nvmem-s32cc-ocotp-nvmem.o
+nvmem-s32cc-ocotp-nvmem-y      := s32cc-ocotp-nvmem.o
 obj-$(CONFIG_NVMEM_S32_SIUL2)	+= nvmem_s32_siul2_nvmem.o
 nvmem_s32_siul2_nvmem-y		:= s32_siul2_nvmem.o
 obj-$(CONFIG_NVMEM_ZYNQMP)	+= nvmem_zynqmp_nvmem.o
diff --git a/drivers/nvmem/s32cc-ocotp-nvmem.c b/drivers/nvmem/s32cc-ocotp-nvmem.c
new file mode 100644
index 000000000000..ebeb3d7434df
--- /dev/null
+++ b/drivers/nvmem/s32cc-ocotp-nvmem.c
@@ -0,0 +1,209 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2023 NXP
+ */
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/nvmem-provider.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <dt-bindings/nvmem/s32cc-ocotp-nvmem.h>
+
+#define	OCOTP_WORD(X)		BIT(X)
+#define	OCOTP_WORD_RANGE(L, H)	GENMASK(H, L)
+
+#define S32CC_OCOTP_BANK_OFFSET     0x200U
+#define S32CC_OCOTP_BANK_SIZE       0x20U
+#define S32CC_OCOTP_WORD_SIZE       0x4U
+
+struct s32cc_fuse {
+	u8 bank;
+	u8 words_mask;
+};
+
+struct s32cc_fuse_map {
+	const struct s32cc_fuse *map;
+	size_t n_entries;
+};
+
+static const struct s32cc_fuse s32cc_fuse_map[] = {
+	{ .bank = 0, .words_mask = OCOTP_WORD_RANGE(2, 6) },
+	{ .bank = 1, .words_mask = OCOTP_WORD_RANGE(5, 7) },
+	{ .bank = 2, .words_mask = OCOTP_WORD_RANGE(0, 1) },
+	{ .bank = 2, .words_mask = OCOTP_WORD_RANGE(2, 4) },
+	{ .bank = 4, .words_mask = OCOTP_WORD(6) },
+	{ .bank = 5, .words_mask = OCOTP_WORD(1) },
+	{ .bank = 5, .words_mask = OCOTP_WORD(2) },
+	{ .bank = 6, .words_mask = OCOTP_WORD(7) },
+	{ .bank = 7, .words_mask = OCOTP_WORD_RANGE(0, 1) },
+	{ .bank = 11, .words_mask = OCOTP_WORD_RANGE(0, 5) },
+	{ .bank = 11, .words_mask = OCOTP_WORD_RANGE(6, 7) },
+	{ .bank = 12, .words_mask = OCOTP_WORD_RANGE(0, 2) },
+	{ .bank = 12, .words_mask = OCOTP_WORD(7) },
+	{ .bank = 13, .words_mask = OCOTP_WORD_RANGE(2, 4) },
+	{ .bank = 14,
+		.words_mask = OCOTP_WORD(1) | OCOTP_WORD(4) | OCOTP_WORD(5) },
+	{ .bank = 15, .words_mask = OCOTP_WORD_RANGE(5, 7) },
+};
+
+static const struct s32cc_fuse_map s32cc_map = {
+	.map = s32cc_fuse_map,
+	.n_entries = ARRAY_SIZE(s32cc_fuse_map),
+};
+
+struct s32cc_ocotp_priv {
+	struct device *dev;
+	void __iomem *base;
+	struct nvmem_config *config;
+	const struct s32cc_fuse_map *fuses;
+};
+
+static const struct of_device_id ocotp_of_match[] = {
+	{ .compatible = "nxp,s32g-ocotp", .data = &s32cc_map},
+	{ .compatible = "nxp,s32r45-ocotp", .data = &s32cc_map},
+	{ /* sentinel */ }
+};
+
+static u32 get_bank_index(unsigned int offset)
+{
+	return (offset - S32CC_OCOTP_BANK_OFFSET) / S32CC_OCOTP_BANK_SIZE;
+}
+
+static u32 get_word_index(unsigned int offset)
+{
+	return offset % S32CC_OCOTP_BANK_SIZE / S32CC_OCOTP_WORD_SIZE;
+}
+
+static const struct s32cc_fuse *get_fuse(const struct s32cc_fuse_map *map,
+					 u32 bank, u32 word)
+{
+	size_t i;
+
+	for (i = 0; i < map->n_entries; i++) {
+		if (map->map[i].bank == bank &&
+		    map->map[i].words_mask & OCOTP_WORD(word))
+			return &map->map[i];
+	}
+
+	return NULL;
+}
+
+static bool is_valid_word(const struct s32cc_fuse_map *map,
+			  u32 bank, u32 word)
+{
+	if (bank >= map->n_entries)
+		return false;
+
+	if (get_fuse(map, bank, word))
+		return true;
+
+	return false;
+}
+
+static int init_word_bank(struct s32cc_ocotp_priv *s32cc_data,
+			  unsigned int offset, int size, u32 *bank, u32 *word)
+{
+	if (offset < S32CC_OCOTP_BANK_OFFSET)
+		return -EINVAL;
+
+	if (size != 4)
+		return -EPERM;
+
+	*bank = get_bank_index(offset);
+	*word = get_word_index(offset);
+
+	if (!is_valid_word(s32cc_data->fuses, *bank, *word)) {
+		dev_err(s32cc_data->dev, "[bank %u, word %u] is not a valid fuse\n",
+			*bank, *word);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int s32cc_ocotp_read(void *context, unsigned int offset,
+			    void *val, size_t bytes)
+{
+	struct s32cc_ocotp_priv *s32cc_data = context;
+	u32 bank, word;
+	int ret;
+
+	if (bytes != OCOTP_CELL_SIZE)
+		return -EOPNOTSUPP;
+
+	ret = init_word_bank(s32cc_data, offset, bytes, &bank, &word);
+	if (ret)
+		return ret;
+
+	/* Read from Fuse OCOTP Shadow registers */
+	*(u32 *)val = ioread32(s32cc_data->base + offset);
+
+	return 0;
+}
+
+static struct nvmem_config s32cc_ocotp_nvmem_config = {
+	.name = "s32cc-ocotp",
+	.read_only = true,
+	.word_size = 4,
+	.reg_read = s32cc_ocotp_read,
+};
+
+static int s32cc_ocotp_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	const struct of_device_id *of_matched_dt_id;
+	struct s32cc_ocotp_priv *s32cc_data;
+	struct nvmem_device *nvmem;
+
+	of_matched_dt_id = of_match_device(ocotp_of_match, dev);
+	if (!of_matched_dt_id) {
+		dev_err(dev, "Unable to find driver data.\n");
+		return -ENODEV;
+	}
+
+	s32cc_data = devm_kzalloc(dev, sizeof(struct s32cc_ocotp_priv),
+				  GFP_KERNEL);
+	if (!s32cc_data)
+		return -ENOMEM;
+
+	s32cc_data->fuses = of_device_get_match_data(dev);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "Cannot obtain OCOTP resource.\n");
+		return -ENODEV;
+	}
+
+	s32cc_data->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(s32cc_data->base)) {
+		dev_err(dev, "Cannot map OCOTP device");
+		return PTR_ERR(s32cc_data->base);
+	}
+
+	s32cc_data->dev = dev;
+	s32cc_ocotp_nvmem_config.dev = dev;
+	s32cc_ocotp_nvmem_config.priv = s32cc_data;
+	s32cc_ocotp_nvmem_config.size = resource_size(res);
+	s32cc_data->config = &s32cc_ocotp_nvmem_config;
+
+	nvmem = devm_nvmem_register(dev, &s32cc_ocotp_nvmem_config);
+
+	return PTR_ERR_OR_ZERO(nvmem);
+}
+
+static struct platform_driver s32cc_ocotp_driver = {
+	.probe = s32cc_ocotp_probe,
+	.driver = {
+		.name = "s32cc-ocotp",
+		.of_match_table = ocotp_of_match,
+	},
+};
+module_platform_driver(s32cc_ocotp_driver);
+MODULE_AUTHOR("NXP");
+MODULE_DESCRIPTION("S32CC OCOTP driver");
+MODULE_LICENSE("GPL v2");
diff --git a/include/soc/s32cc/fuse.h b/include/soc/s32cc/fuse.h
new file mode 100644
index 000000000000..1e4c8c7380a3
--- /dev/null
+++ b/include/soc/s32cc/fuse.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2023 NXP
+ *
+ */
+
+#ifndef __SOC_S32CC_FUSE_H__
+#define __SOC_S32CC_FUSE_H__
+
+#include <soc/s32cc/fuse_defs.h>
+#include <soc/s32cc/nvmem_common.h>
+
+static inline
+int s32cc_ocotp_nvmem_get_tmu_fuse(struct device *dev,
+				   const char *cname,
+				   union s32cc_tmu_fuse *tmu_fuse)
+{
+	char *buf = NULL;
+
+	if (!tmu_fuse)
+		return -EINVAL;
+
+	buf = read_nvmem_cell(dev, cname);
+	if (IS_ERR(buf))
+		return PTR_ERR(buf);
+
+	tmu_fuse->R = *(s32 *)buf;
+
+	kfree(buf);
+	return 0;
+}
+
+#endif /* __SOC_S32CC_FUSE_H__*/
diff --git a/include/soc/s32cc/fuse_defs.h b/include/soc/s32cc/fuse_defs.h
new file mode 100644
index 000000000000..e3583713ba5c
--- /dev/null
+++ b/include/soc/s32cc/fuse_defs.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2023 NXP
+ *
+ */
+
+#ifndef __SOC_S32CC_FUSE_DEFS_H__
+#define __SOC_S32CC_FUSE_DEFS_H__
+
+union s32cc_tmu_fuse {
+	struct {
+		s32 CFG_DAC_TRIM0:5;
+		u8 Reserved0:1;
+		s32 CFG_DAC_TRIM1:5;
+		u32 Reserved1:21;
+	} B;
+	s32 R;
+};
+
+#endif /* __SOC_S32CC_FUSE_DEFS_H__ */
diff --git a/include/soc/s32cc/nvmem_common.h b/include/soc/s32cc/nvmem_common.h
new file mode 100644
index 000000000000..2fcaed81316a
--- /dev/null
+++ b/include/soc/s32cc/nvmem_common.h
@@ -0,0 +1,32 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2023 NXP
+ *
+ */
+
+#include <linux/nvmem-consumer.h>
+
+static inline char *read_nvmem_cell(struct device *dev,
+				    const char *cname)
+{
+	struct nvmem_cell *cell;
+	size_t len = 0;
+	char *buf;
+
+	cell = nvmem_cell_get(dev, cname);
+	if (IS_ERR(cell))
+		return ERR_PTR(-EINVAL);
+
+	buf = nvmem_cell_read(cell, &len);
+	nvmem_cell_put(cell);
+
+	if (IS_ERR(buf))
+		return buf;
+
+	if (len != sizeof(u32)) {
+		kfree(buf);
+		return ERR_PTR(-EOPNOTSUPP);
+	}
+
+	return buf;
+}
-- 
2.25.1

