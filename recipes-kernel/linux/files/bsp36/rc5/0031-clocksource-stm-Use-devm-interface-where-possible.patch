From 2b2bf76f9292f0706e2cbed39acb6c869c2dd064 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Thu, 12 Jan 2023 12:53:15 +0200
Subject: [PATCH 31/63] clocksource: stm: Use devm interface where possible

The usage of devm interface and metadata per driver instance will also
allow having multiple instances of the driver without metadata overlaps.

Issue: ALB-9261
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/clocksource/fsl_global_time.c | 112 +++++++++++++-------------
 1 file changed, 57 insertions(+), 55 deletions(-)

diff --git a/drivers/clocksource/fsl_global_time.c b/drivers/clocksource/fsl_global_time.c
index 62c6f59ccef3..710cce0b8998 100644
--- a/drivers/clocksource/fsl_global_time.c
+++ b/drivers/clocksource/fsl_global_time.c
@@ -31,16 +31,18 @@
 #define INPUT_LEN			2
 #define OUTPUT_LEN			11
 
-static void __iomem *timer_base;
-struct clk *clock;
+struct stm_driver {
+    void __iomem *base;
+};
 
 static ssize_t get_init(struct device *dev, struct device_attribute *attr,
 			char *buf)
 {
+	struct stm_driver *drv = dev_get_drvdata(dev);
 	int initialized;
 	u32	reg_content;
 
-	reg_content = readl(timer_base + STM_CR);
+	reg_content = readl(drv->base + STM_CR);
 	initialized = !!(reg_content & STM_CR_TEN);
 
 	return snprintf(buf, INPUT_LEN, "%d\n", initialized);
@@ -49,6 +51,7 @@ static ssize_t get_init(struct device *dev, struct device_attribute *attr,
 static ssize_t set_init(struct device *dev, struct device_attribute *attr,
 			const char *buf, size_t count)
 {
+	struct stm_driver *drv = dev_get_drvdata(dev);
 	int rc;
 	int should_init;
 
@@ -58,11 +61,11 @@ static ssize_t set_init(struct device *dev, struct device_attribute *attr,
 		return count;
 	}
 	if (should_init) {
-		writel(0, timer_base + STM_CNT);
+		writel(0, drv->base + STM_CNT);
 		writel(STM_CR_CPS | STM_CR_FRZ | STM_CR_TEN,
-		       timer_base + STM_CR);
+		       drv->base + STM_CR);
 	} else {
-		writel(0, timer_base + STM_CR);
+		writel(0, drv->base + STM_CR);
 	}
 	return count;
 }
@@ -70,9 +73,10 @@ static ssize_t set_init(struct device *dev, struct device_attribute *attr,
 static ssize_t get_time(struct device *dev, struct device_attribute *attr,
 			char *buf)
 {
+	struct stm_driver *drv = dev_get_drvdata(dev);
 	u32 cur_time;
 
-	cur_time = readl(timer_base + STM_CNT);
+	cur_time = readl(drv->base + STM_CNT);
 
 	return snprintf(buf, OUTPUT_LEN, "0x%08x\n", cur_time);
 }
@@ -82,9 +86,10 @@ static const struct device_attribute dev_attrs[] = {
 	__ATTR(value,	0440, get_time,	NULL)
 };
 
-static int init_interface(struct device *dev)
+static int init_sysfs_interface(struct device *dev)
 {
-	int rc, i, j;
+	size_t i, j;
+	int rc;
 
 	for (i = 0; i < ARRAY_SIZE(dev_attrs); i++) {
 		rc = device_create_file(dev, &dev_attrs[i]);
@@ -98,53 +103,69 @@ static int init_interface(struct device *dev)
 	return rc;
 }
 
+static void deinit_sysfs_interface(struct device *dev)
+{
+	size_t i;
+
+	for (i = 0; i < ARRAY_SIZE(dev_attrs); i++)
+		device_remove_file(dev, &dev_attrs[i]);
+}
+
+static int devm_clk_prepare_enable(struct device *dev, struct clk *clk)
+{
+	int ret;
+
+	ret = clk_prepare_enable(clk);
+	if (ret)
+		return ret;
+
+	return devm_add_action_or_reset(dev,
+					(void(*)(void *))clk_disable_unprepare,
+					clk);
+}
+
 static int global_timer_probe(struct platform_device *pdev)
 {
-	struct resource *res;
+	struct device *dev = &pdev->dev;
+	struct stm_driver *drv;
+	struct clk *clock;
 	int rc;
 
-	clock = devm_clk_get(&pdev->dev, "stm");
+	drv = devm_kzalloc(dev, sizeof(*drv), GFP_KERNEL);
+	if (!drv)
+		return -ENOMEM;
+
+	clock = devm_clk_get(dev, "stm");
 	if (IS_ERR(clock)) {
-		dev_err(&pdev->dev, "Failed getting clock from dtb\n");
+		dev_err(dev, "Failed getting clock from dtb\n");
 		return PTR_ERR(clock);
 	}
-	rc = clk_prepare_enable(clock);
+
+	rc = devm_clk_prepare_enable(dev, clock);
 	if (rc) {
-		dev_err(&pdev->dev, "Failed initializing clock\n");
+		dev_err(dev, "Failed initializing clock\n");
 		return rc;
 	}
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&pdev->dev, "Failed getting timer address from dtb.\n");
-		clk_disable_unprepare(clock);
-		return -ENODEV;
-	}
-	timer_base = ioremap(res->start, res->end - res->start);
-	if (!timer_base) {
-		dev_err(&pdev->dev, "Couldn't remap timer base address\n");
-		clk_disable_unprepare(clock);
-		return -ENOMEM;
+	drv->base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(drv->base)) {
+		dev_err(dev, "Couldn't remap timer base address\n");
+		return PTR_ERR(drv->base);
 	}
 
-	rc = init_interface(&pdev->dev);
+	rc = init_sysfs_interface(dev);
 	if (rc) {
-		dev_err(&pdev->dev, "Failed initiating sysfs interface\n");
-		iounmap(timer_base);
-		clk_disable_unprepare(clock);
+		dev_err(dev, "Failed initiating sysfs interface\n");
 	}
 
+	platform_set_drvdata(pdev, drv);
+
 	return rc;
 }
 
 static int global_timer_remove(struct platform_device *pdev)
 {
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(dev_attrs); i++)
-		device_remove_file(&pdev->dev, &dev_attrs[i]);
-	iounmap(timer_base);
-	clk_disable_unprepare(clock);
+	deinit_sysfs_interface(&pdev->dev);
 
 	return 0;
 }
@@ -166,26 +187,7 @@ static struct platform_driver global_time_driver = {
 	},
 };
 
-static int __init global_time_init(void)
-{
-	int ret;
-
-	ret = platform_driver_register(&global_time_driver);
-	if (ret) {
-		pr_err("%s Problem registering global timing drive\n",
-		       DRIVER_NAME);
-	}
-
-	return ret;
-}
-
-static void __exit global_time_exit(void)
-{
-	platform_driver_unregister(&global_time_driver);
-}
-
-module_init(global_time_init);
-module_exit(global_time_exit);
+module_platform_driver(global_time_driver)
 
 MODULE_DESCRIPTION("NXP SoC Level Time Source for Gen1");
 MODULE_LICENSE("GPL v2");
-- 
2.25.1

