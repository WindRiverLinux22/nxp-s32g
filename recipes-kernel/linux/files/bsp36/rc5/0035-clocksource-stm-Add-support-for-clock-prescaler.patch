From ffd1348888e09b6c507922449a8f2185018b9e95 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Thu, 12 Jan 2023 15:29:12 +0200
Subject: [PATCH 35/63] clocksource/stm: Add support for clock prescaler

Issue: ALB-9261
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/clocksource/fsl_global_time.c | 34 ++++++++++++++++++++-------
 1 file changed, 25 insertions(+), 9 deletions(-)

diff --git a/drivers/clocksource/fsl_global_time.c b/drivers/clocksource/fsl_global_time.c
index d151e05d4632..e19665c97775 100644
--- a/drivers/clocksource/fsl_global_time.c
+++ b/drivers/clocksource/fsl_global_time.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
-/* Copyright 2020 NXP
+/* Copyright 2020-2023 NXP
  *
  * Driver which provides universal timestamp at SoC level for S32Gen1.
  *
@@ -20,16 +20,15 @@
 #include <linux/of_device.h>
 #include <linux/clk.h>
 
-#define STM_CR				0x00
-#define STM_CNT				0x04
-#define STM_CR_CPS_OFFSET	8
-#define STM_CR_CPS_MASK		0xFF
-#define STM_CR_CPS			(STM_CR_CPS_MASK << STM_CR_CPS_OFFSET)
+#define STM_CR             0x00u
+#define STM_CNT                0x04u
+#define STM_CR_CPS_OFFSET      8u
+#define STM_CR_CPS(X)          ((X) << STM_CR_CPS_OFFSET)
 #define STM_CR_FRZ			BIT(1)
 #define STM_CR_TEN			BIT(0)
 #define DRIVER_NAME			"NXP S32GEN1 Univesal Time Source"
-#define INPUT_LEN			2
-#define OUTPUT_LEN			11
+#define INPUT_LEN          	2u
+#define OUTPUT_LEN         	11u
 
 enum stm_count_init {
     COUNT_ON_INIT,
@@ -38,6 +37,7 @@ enum stm_count_init {
 
 struct stm_driver {
     enum stm_count_init init;
+    u32 prescaler;
     void __iomem *base;
 };
 
@@ -57,7 +57,7 @@ static ssize_t get_init(struct device *dev, struct device_attribute *attr,
 static void stm_init_counter(struct stm_driver *drv)
 {
 	writel(0, drv->base + STM_CNT);
-	writel(STM_CR_CPS | STM_CR_FRZ | STM_CR_TEN,
+	writel(STM_CR_CPS(drv->prescaler - 1) | STM_CR_FRZ | STM_CR_TEN,
 	       drv->base + STM_CR);
 }
 
@@ -151,10 +151,24 @@ static int global_timer_probe(struct platform_device *pdev)
 {
 	const struct of_device_id *match;
 	struct device *dev = &pdev->dev;
+	const struct device_node *node;
 	struct stm_driver *drv;
 	struct clk *clock;
+	u32 prescaler;
 	int rc;
 
+	node = dev->of_node;
+	if (!node)
+		return -EINVAL;
+
+	if (of_property_read_u32(node, "nxp,prescaler", &prescaler))
+		prescaler = 1;
+
+	if (!prescaler || prescaler > 256) {
+		dev_err(dev, "Invalid prescaler value %u\n", prescaler);
+		return -EINVAL;
+	}
+
 	match = of_match_node(global_timer_dt_ids, pdev->dev.of_node);
 	if (!match)
 		return -EINVAL;
@@ -181,6 +195,8 @@ static int global_timer_probe(struct platform_device *pdev)
 		return PTR_ERR(drv->base);
 	}
 
+	drv->prescaler = prescaler;
+
 	drv->init = (enum stm_count_init)match->data;
 	if (drv->init == COUNT_ON_INIT)
 		stm_init_counter(drv);
-- 
2.25.1

