From 052176a28a14fc78359643aa38c0200265c7a113 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Thu, 13 Oct 2022 12:46:28 +0300
Subject: [PATCH 25/30] s32cc: Move PMIC WDG refresh before DDR init on resume
 path

This moves the PMIC WDG refresh as early as possible on platform
resume path. The change reduces the risks of spurious restarts when
the BL2 resume path + everything till PMIC WDG refresh (from BL31)
takes more than PMIC WDG timeout.

It also enables the caches for DTB parsing, PMIC initialization and
DDR state transition, thus significantly reducing the time needed
for these operations. It drops to 14ms from 299ms (release
configuration).

Issue: ALB-9357
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32/include/s32_bl2_el3.h |   2 +-
 plat/nxp/s32/s32_bl2_el3.c         |  46 +++++++++++--
 plat/nxp/s32/s32_bl31.c            |  16 ++++-
 plat/nxp/s32/s32g/s32g_bl2_el3.c   | 102 +++++++++++++++++++++++------
 plat/nxp/s32/s32g/s32g_resume.c    |  29 --------
 plat/nxp/s32/s32r/s32r_bl2_el3.c   |  10 ++-
 6 files changed, 139 insertions(+), 66 deletions(-)

diff --git a/plat/nxp/s32/include/s32_bl2_el3.h b/plat/nxp/s32/include/s32_bl2_el3.h
index d69714547..b9013759e 100644
--- a/plat/nxp/s32/include/s32_bl2_el3.h
+++ b/plat/nxp/s32/include/s32_bl2_el3.h
@@ -16,7 +16,7 @@ void add_bl32_extra1_img_to_mem_params_descs(bl_mem_params_node_t *params, size_
 void add_bl33_img_to_mem_params_descs(bl_mem_params_node_t *params, size_t *index);
 void add_invalid_img_to_mem_params_descs(bl_mem_params_node_t *params, size_t *index);
 
-int s32_el3_mmu_fixup(void);
+int s32_el3_mmu_fixup(const uintptr_t *filters, size_t n_filters);
 void clear_swt_faults(void);
 void clear_reset_cause(void);
 const char *get_reset_cause_str(enum reset_cause reset_cause);
diff --git a/plat/nxp/s32/s32_bl2_el3.c b/plat/nxp/s32/s32_bl2_el3.c
index fe677c441..7dc843a27 100644
--- a/plat/nxp/s32/s32_bl2_el3.c
+++ b/plat/nxp/s32/s32_bl2_el3.c
@@ -20,6 +20,7 @@
 #include <platform.h>
 #include <s32_bl_common.h>
 #include <tools_share/firmware_image_package.h>
+#include <s32_bl2_el3.h>
 
 #if (ERRATA_S32_050543 == 1)
 #include <dt-bindings/ddr-errata/s32-ddr-errata.h>
@@ -283,6 +284,25 @@ static int disable_qspi_mmu_entry(void)
 	return 0;
 }
 
+static void filter_mmu_entries(const uintptr_t *filters, size_t n_filters)
+{
+	size_t i, j;
+	bool used;
+
+	for (i = 0; i < ARRAY_SIZE(s32_mmap); i++) {
+		used = false;
+		for (j = 0; j < n_filters; j++) {
+			if (s32_mmap[i].base_pa == filters[j]) {
+				used = true;
+				break;
+			}
+		}
+
+		if (!used)
+			s32_mmap[i].size = 0;
+	}
+}
+
 #ifdef HSE_SECBOOT
 static size_t get_fip_size(void)
 {
@@ -308,12 +328,22 @@ static size_t get_fip_size(void)
 }
 #endif
 
-int s32_el3_mmu_fixup(void)
+int s32_el3_mmu_fixup(const uintptr_t *filters, size_t n_filters)
 {
 	const unsigned long code_start = BL_CODE_BASE;
-	const unsigned long code_size = BL_CODE_END - BL_CODE_BASE;
 	const unsigned long rw_start = BL2_RW_START;
-	const unsigned long rw_size = BL_END - BL2_RW_START;
+	unsigned long code_size;
+	unsigned long rw_size;
+
+	if (BL_END < BL2_RW_START)
+		return -EINVAL;
+
+	if (BL_CODE_END < BL_CODE_BASE)
+		return -EINVAL;
+
+	code_size = BL_CODE_END - BL_CODE_BASE;
+	rw_size = BL_END - BL2_RW_START;
+
 	mmap_region_t regions[] = {
 		{
 			.base_pa = code_start,
@@ -341,9 +371,13 @@ int s32_el3_mmu_fixup(void)
 	};
 	int i, ret;
 
-	ret = disable_qspi_mmu_entry();
-	if (ret)
-		return ret;
+	if (filters) {
+		filter_mmu_entries(filters, n_filters);
+	} else {
+		ret = disable_qspi_mmu_entry();
+		if (ret)
+			return ret;
+	}
 
 	/* Check the BL31/BL32/BL33 memory ranges for overlapping */
 	_Static_assert(S32_BL32_BASE + S32_BL32_SIZE <= BL31_BASE,
diff --git a/plat/nxp/s32/s32_bl31.c b/plat/nxp/s32/s32_bl31.c
index 081e60d2d..bca517a01 100644
--- a/plat/nxp/s32/s32_bl31.c
+++ b/plat/nxp/s32/s32_bl31.c
@@ -21,7 +21,7 @@
 #include "s32_sramc.h"
 
 #define MMU_ROUND_UP_TO_4K(x)	\
-			(((x) & ~0xfff) == (x) ? (x) : ((x) & ~0xfff) + 0x1000)
+	(((x) & ~0xfffU) == (x) ? (x) : ((x) & ~0xfffU) + 0x1000U)
 
 IMPORT_SYM(uintptr_t, __RW_START__, BL31_RW_START);
 
@@ -257,9 +257,19 @@ static uintptr_t get_dtb_base_page(void)
 static void s32_el3_mmu_fixup(void)
 {
 	const unsigned long code_start = BL_CODE_BASE;
-	const unsigned long code_size = BL_CODE_END - BL_CODE_BASE;
 	const unsigned long rw_start = BL31_RW_START;
-	const unsigned long rw_size = BL_END - BL31_RW_START;
+	unsigned long code_size;
+	unsigned long rw_size;
+
+	if (BL_END < BL31_RW_START)
+		panic();
+
+	if (BL_CODE_END < BL_CODE_BASE)
+		panic();
+
+	code_size = BL_CODE_END - BL_CODE_BASE;
+	rw_size = BL_END - BL31_RW_START;
+
 	mmap_region_t regions[] = {
 		{
 			.base_pa = code_start,
diff --git a/plat/nxp/s32/s32g/s32g_bl2_el3.c b/plat/nxp/s32/s32g/s32g_bl2_el3.c
index 2e20bf291..c5acbee98 100644
--- a/plat/nxp/s32/s32g/s32g_bl2_el3.c
+++ b/plat/nxp/s32/s32g/s32g_bl2_el3.c
@@ -24,6 +24,7 @@
 #else
 #include <ddr/ddr_init.h>
 #include <drivers/nxp/s32/ddr/ddr_lp.h>
+#include <dt-bindings/ddr-errata/s32-ddr-errata.h>
 #endif
 
 static bl_mem_params_node_t s32g_bl2_mem_params_descs[6];
@@ -56,25 +57,92 @@ static enum reset_cause get_reset_cause(void)
 	return CAUSE_ERROR;
 }
 
+static int init_and_setup_pmic(void)
+{
+	int ret = 0;
+
+	dt_init_ocotp();
+	dt_init_pmic();
+
+#if S32CC_EMU == 0
+	ret = pmic_setup();
+	if (ret)
+		ERROR("Failed to disable VR5510 watchdog\n");
+#endif
+
+	return ret;
+}
+
+static void reset_rtc(void)
+{
+	uint32_t rtc = S32G_RTC_BASE;
+	uint32_t rtcs;
+
+	mmio_write_32(rtc + RTC_APIVAL_OFFSET, 0x0);
+	mmio_write_32(rtc + RTC_RTCVAL_OFFSET, 0x0);
+
+	mmio_write_32(rtc + RTC_RTCC_OFFSET, 0x0);
+
+	rtcs = mmio_read_32(rtc + RTC_RTCS_OFFSET);
+	mmio_write_32(rtc + RTC_RTCS_OFFSET, rtcs);
+}
+
 static void resume_bl31(struct s32g_ssram_mailbox *ssram_mb)
 {
 #if S32CC_EMU == 0
 	s32g_warm_entrypoint_t resume_entrypoint;
 	uintptr_t csr_addr;
+	static const uintptr_t used_ips_base[] = {
+		/* Linflex */
+		S32_UART_BASE,
+		/* Pinmuxing */
+		SIUL2_0_BASE_ADDR,
+		SIUL2_1_BASE_ADDR,
+		/* PMIC */
+		I2C4_BASE_ADDR,
+		OCOTP_BASE_ADDR,
+		/* BL2 space */
+		FIP_BASE,
+		/* DDR */
+		DDRSS_BASE_ADDR,
+		DDR_ERRATA_REGION_BASE,
+		S32G_SSRAM_BASE,
+		GPR_BASE_PAGE_ADDR,
+		MC_CGM5_BASE_ADDR,
+		S32_MC_RGM_BASE_ADDR,
+	};
 
 	resume_entrypoint = ssram_mb->bl31_warm_entrypoint;
 	csr_addr = (uintptr_t)&ssram_mb->csr_settings[0];
 
-	s32_enable_a53_clock();
-	s32_enable_ddr_clock();
+	reset_rtc();
 
-	if (ddrss_to_normal_mode(csr_addr))
+	/*
+	 * Configure MMU & caches for a short period of time needed to boost
+	 * the DTB parsing and DDR reconfig.
+	 */
+	if (s32_el3_mmu_fixup(&used_ips_base[0], ARRAY_SIZE(used_ips_base))) {
+		ERROR("Failed to configure ");
+		panic();
+	}
+
+	if (init_and_setup_pmic()) {
+		ERROR("Failed to disable VR5510 watchdog\n");
 		panic();
+	}
+
+	if (ddrss_to_normal_mode(csr_addr)) {
+		ERROR("Failed to transition DDR to normal mode\n");
+		panic();
+	}
 
 #if (ERRATA_S32_050543 == 1)
 	ddr_errata_update_flag(polling_needed);
 #endif
 
+	isb();
+	dsb();
+	disable_mmu_el3();
 	resume_entrypoint();
 #endif
 }
@@ -90,6 +158,9 @@ void bl2_el3_early_platform_setup(u_register_t arg0, u_register_t arg1,
 	reset_cause = get_reset_cause();
 	clear_reset_cause();
 
+	s32_early_plat_init(false);
+	console_s32_register();
+
 	if ((reset_cause == CAUSE_WAKEUP_DURING_STANDBY) &&
 	    !ssram_mb->short_boot) {
 		/* Trampoline to bl31_warm_entrypoint */
@@ -97,11 +168,8 @@ void bl2_el3_early_platform_setup(u_register_t arg0, u_register_t arg1,
 		panic();
 	}
 
-	s32_early_plat_init(false);
-	console_s32_register();
-	s32_io_setup();
-
 	NOTICE("Reset status: %s\n", get_reset_cause_str(reset_cause));
+	s32_io_setup();
 
 	add_fip_img_to_mem_params_descs(params, &index);
 	add_bl31_img_to_mem_params_descs(params, &index);
@@ -123,20 +191,11 @@ static void copy_bl31ssram_image(void)
 
 void bl2_el3_plat_arch_setup(void)
 {
-	uint32_t ret;
-
-	ret = s32_el3_mmu_fixup();
-	if (ret)
+	if (s32_el3_mmu_fixup(NULL, 0))
 		panic();
 
-	dt_init_ocotp();
-	dt_init_pmic();
-
-#if S32CC_EMU == 0
-	ret = pmic_setup();
-	if (ret)
-		ERROR("Failed to disable VR5510 watchdog\n");
-#endif
+	if (init_and_setup_pmic())
+		panic();
 
 	s32_sram_clear(S32_BL33_IMAGE_BASE, get_bl2_dtb_base());
 	/* Clear only the necessary part for the FIP header. The rest will
@@ -152,9 +211,10 @@ void bl2_el3_plat_arch_setup(void)
 	clear_swt_faults();
 
 	/* This will also populate CSR section from bl31ssram */
-	ret = ddr_init();
-	if (ret)
+	if (ddr_init()) {
+		ERROR("Failed to configure the DDR subsystem\n");
 		panic();
+	}
 
 #if (ERRATA_S32_050543 == 1)
 	ddr_errata_update_flag(polling_needed);
diff --git a/plat/nxp/s32/s32g/s32g_resume.c b/plat/nxp/s32/s32g/s32g_resume.c
index 6110d36c1..af13e9ccc 100644
--- a/plat/nxp/s32/s32g/s32g_resume.c
+++ b/plat/nxp/s32/s32g/s32g_resume.c
@@ -7,43 +7,14 @@
 #include "s32_linflexuart.h"
 #include "s32g_lowlevel.h"
 #include "s32g_resume.h"
-#include "s32g_vr5510.h"
 #include "s32gen1-wkpu.h"
 #include <bl31/bl31.h>		/* for bl31_warm_entrypoint() */
 #include <lib/el3_runtime/context_mgmt.h>
 #include <lib/el3_runtime/cpu_data.h>
 #include <lib/mmio.h>
 
-void s32_ncore_isol_cluster0(void);
-
-static void reset_rtc(void)
-{
-	uint32_t rtc = S32G_RTC_BASE;
-	uint32_t rtcs;
-
-	mmio_write_32(rtc + RTC_APIVAL_OFFSET, 0x0);
-	mmio_write_32(rtc + RTC_RTCVAL_OFFSET, 0x0);
-
-	mmio_write_32(rtc + RTC_RTCC_OFFSET, 0x0);
-
-	rtcs = mmio_read_32(rtc + RTC_RTCS_OFFSET);
-	mmio_write_32(rtc + RTC_RTCS_OFFSET, rtcs);
-}
-
 void s32g_resume_entrypoint(void)
 {
-	int ret;
-
-	/* Prepare resume operation */
-	reset_registers_for_lockstep();
-	s32_ncore_isol_cluster0();
-	s32_early_plat_init(true);
-
-	ret = pmic_setup();
-	if (ret)
-		ERROR("Failed to disable VR5510 watchdog\n");
-
-	reset_rtc();
 	s32gen1_wkpu_reset();
 
 #if (S32_USE_LINFLEX_IN_BL31 == 1)
diff --git a/plat/nxp/s32/s32r/s32r_bl2_el3.c b/plat/nxp/s32/s32r/s32r_bl2_el3.c
index 731714a11..5e943f694 100644
--- a/plat/nxp/s32/s32r/s32r_bl2_el3.c
+++ b/plat/nxp/s32/s32r/s32r_bl2_el3.c
@@ -65,10 +65,7 @@ void bl2_el3_early_platform_setup(u_register_t arg0, u_register_t arg1,
 
 void bl2_el3_plat_arch_setup(void)
 {
-	uint32_t ret;
-
-	ret = s32_el3_mmu_fixup();
-	if (ret)
+	if (s32_el3_mmu_fixup(NULL, 0))
 		panic();
 
 	s32_sram_clear(S32_BL33_IMAGE_BASE, get_bl2_dtb_base());
@@ -80,9 +77,10 @@ void bl2_el3_plat_arch_setup(void)
 
 	clear_swt_faults();
 
-	ret = ddr_init();
-	if (ret)
+	if (ddr_init()) {
+		ERROR("Failed to configure the DDR subsystem\n");
 		panic();
+	}
 
 #if (ERRATA_S32_050543 == 1)
 	ddr_errata_update_flag(polling_needed);
-- 
2.17.1

