From 6aab264d076cbecd2da341ab8dd7191ecc8169a9 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Wed, 5 Oct 2022 12:51:33 +0300
Subject: [PATCH 26/30] s32cc: psci: Split A53 reset address set and kick

This prepares the ground for A53 kick using SCP.

Issue: ALB-9435
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32/include/s32_bl_common.h |  1 +
 plat/nxp/s32/include/s32_mc_me.h     |  7 +++++--
 plat/nxp/s32/s32_mc_me.c             | 26 ++++++++++++++------------
 plat/nxp/s32/s32_psci.c              |  6 ++++--
 4 files changed, 24 insertions(+), 16 deletions(-)

diff --git a/plat/nxp/s32/include/s32_bl_common.h b/plat/nxp/s32/include/s32_bl_common.h
index 21ee6122d..5fec2dce4 100644
--- a/plat/nxp/s32/include/s32_bl_common.h
+++ b/plat/nxp/s32/include/s32_bl_common.h
@@ -55,6 +55,7 @@ bool is_cluster0_off(void);
 bool is_cluster1_off(void);
 void scp_scmi_init(void);
 int send_scmi_to_scp(uintptr_t scmi_mem);
+void scp_set_core_reset_addr(uintptr_t addr);
 
 struct s32_i2c_driver *s32_add_i2c_module(void *fdt, int fdt_node);
 
diff --git a/plat/nxp/s32/include/s32_mc_me.h b/plat/nxp/s32/include/s32_mc_me.h
index a5e70ac65..bfa376bcd 100644
--- a/plat/nxp/s32/include/s32_mc_me.h
+++ b/plat/nxp/s32/include/s32_mc_me.h
@@ -1,7 +1,7 @@
 /*
  * MC Mode Entry definitions for S32GEN1 and compatible SoCs
  *
- * Copyright 2021 NXP
+ * Copyright 2021-2022 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -9,6 +9,8 @@
 #define __S32_MC_ME_H__
 
 #include "platform_def.h"
+#include <stdbool.h>
+#include <stddef.h>
 
 #define S32_MC_ME_BASE_ADDR	0x40088000ul
 #define S32_MC_ME_SIZE		0x1000ul
@@ -96,7 +98,8 @@ struct a53_haddr_mapping {
 void mc_me_apply_hw_changes(void);
 
 bool s32_core_in_reset(uint32_t core);
-void s32_kick_secondary_ca53_core(uint32_t core, uintptr_t entrypoint);
+void s32_set_core_entrypoint(uint32_t core, uint64_t entrypoint);
+void s32_kick_secondary_ca53_core(uint32_t core);
 void s32_turn_off_core(uint8_t part, uint8_t core);
 void s32_turn_off_mcores(void);
 void s32_reset_core(uint8_t part, uint8_t core);
diff --git a/plat/nxp/s32/s32_mc_me.c b/plat/nxp/s32/s32_mc_me.c
index dcf142597..2343a099b 100644
--- a/plat/nxp/s32/s32_mc_me.c
+++ b/plat/nxp/s32/s32_mc_me.c
@@ -20,7 +20,7 @@ void mc_me_apply_hw_changes(void)
  * PART<n>_CORE<m> register accessors
  */
 
-static void mc_me_part_core_addr_write(uintptr_t addr, uint32_t part,
+static void mc_me_part_core_addr_write(uint64_t addr, uint32_t part,
 				       uint32_t core)
 {
 	uint32_t addr_lo;
@@ -245,7 +245,7 @@ static void enable_a53_core_cluster(uint32_t core)
 	} while (stat != S32_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK);
 }
 
-static void set_core_high_addr(uintptr_t addr, uint32_t core)
+static void set_core_high_addr(uint64_t addr, uint32_t core)
 {
 	const struct a53_haddr_mapping *map;
 	uint32_t addr_hi = 0, reg_val, field_off, reg_off;
@@ -259,9 +259,7 @@ static void set_core_high_addr(uintptr_t addr, uint32_t core)
 	reg_off = map[core].reg;
 	field_off = map[core].field_off;
 
-#ifdef __aarch64__
 	addr_hi = (uint32_t)(addr >> 32);
-#endif
 
 	reg_val = mmio_read_32(GPR_BASE_ADDR + reg_off);
 
@@ -269,22 +267,26 @@ static void set_core_high_addr(uintptr_t addr, uint32_t core)
 	mmio_write_32(GPR_BASE_ADDR + reg_off, reg_val);
 }
 
-/** Reset and initialize secondary A53 core identified by its number
- *  in one of the MC_ME partitions
- */
-void s32_kick_secondary_ca53_core(uint32_t core, uintptr_t entrypoint)
+void s32_set_core_entrypoint(uint32_t core, uint64_t entrypoint)
 {
-	uint32_t rst;
-	uint32_t rst_mask = BIT(get_rgm_a53_bit(core));
 	const uint32_t part = S32_MC_ME_CA53_PART;
 
-	enable_a53_partition();
-
 	set_core_high_addr(entrypoint, core);
 	/* The MC_ME provides the 32 low-order bits for the core's
 	 * start address
 	 */
 	mc_me_part_core_addr_write(entrypoint, part, core);
+}
+
+/** Reset and initialize secondary A53 core identified by its number
+ *  in one of the MC_ME partitions
+ */
+void s32_kick_secondary_ca53_core(uint32_t core)
+{
+	uint32_t rst;
+	uint32_t rst_mask = BIT(get_rgm_a53_bit(core));
+
+	enable_a53_partition();
 
 	enable_a53_core_cluster(core);
 
diff --git a/plat/nxp/s32/s32_psci.c b/plat/nxp/s32/s32_psci.c
index 6c66f83f1..38e80c79f 100644
--- a/plat/nxp/s32/s32_psci.c
+++ b/plat/nxp/s32/s32_psci.c
@@ -51,8 +51,10 @@ static int s32_pwr_domain_on(u_register_t mpidr)
 	pos = plat_core_pos_by_mpidr(mpidr);
 	dsbsy();
 
-	if (s32_core_in_reset(pos))
-		s32_kick_secondary_ca53_core(pos, core_start_addr);
+	if (s32_core_in_reset(pos)) {
+		s32_set_core_entrypoint(pos, core_start_addr);
+		s32_kick_secondary_ca53_core(pos);
+	}
 
 	/* Do some chores on behalf of the secondary core. ICC setup must be
 	 * done by the secondaries, because the interface is not memory-mapped.
-- 
2.17.1

