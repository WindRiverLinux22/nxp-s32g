From eaae8825ef1235ad666f2845933d429a8ca2a30f Mon Sep 17 00:00:00 2001
From: Scott Branden <scott.branden@broadcom.com>
Date: Tue, 25 Aug 2020 13:49:32 -0700
Subject: [PATCH 01/30] fix: libc: use long for 64-bit types on aarch64

Use long instead of long long on aarch64 for 64_t stdint types.
Introduce inttypes.h to properly support printf format specifiers for
fixed width types for such change.

Change-Id: I0bca594687a996fde0a9702d7a383055b99f10a1
Upstream-Status: Pending 

Signed-off-by: Scott Branden <scott.branden@broadcom.com>

Cherry-pick from upstream commit:
4ce3e99a336b74611349595ea7fd5ed0277c3eeb

Issue: ALB-9298
Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 bl32/tsp/tsp_main.c                           |  6 ++-
 common/fdt_wrappers.c                         | 12 +++--
 drivers/brcm/emmc/emmc_csl_sdcard.c           |  6 ++-
 drivers/marvell/amb_adec.c                    | 13 +++--
 drivers/marvell/ccu.c                         |  9 ++--
 drivers/marvell/comphy/phy-comphy-cp110.c     |  4 +-
 drivers/marvell/gwin.c                        |  9 ++--
 drivers/marvell/io_win.c                      |  9 ++--
 drivers/marvell/iob.c                         |  9 ++--
 drivers/marvell/mc_trustzone/mc_trustzone.c   |  7 ++-
 drivers/mtd/spi-mem/spi_mem.c                 |  4 +-
 drivers/nxp/ddr/nxp-ddr/ddr.c                 |  9 ++--
 include/lib/libc/aarch32/inttypes_.h          | 21 +++++++++
 include/lib/libc/aarch32/stdint_.h            | 28 +++++++++++
 include/lib/libc/aarch64/inttypes_.h          | 21 +++++++++
 include/lib/libc/aarch64/stdint_.h            | 31 ++++++++++++
 include/lib/libc/inttypes.h                   | 47 +++++++++++++++++++
 include/lib/libc/stdint.h                     | 18 +------
 lib/bl_aux_params/bl_aux_params.c             |  4 +-
 .../board/fvp/fconf/fconf_hw_config_getter.c  |  5 +-
 plat/common/aarch64/plat_common.c             |  6 ++-
 plat/common/plat_spmd_manifest.c              |  8 ++--
 plat/hisilicon/hikey/hikey_bl1_setup.c        |  4 +-
 plat/hisilicon/poplar/bl31_plat_setup.c       |  4 +-
 plat/imx/imx8qm/imx8qm_bl31_setup.c           | 24 +++++-----
 plat/imx/imx8qx/imx8qx_bl31_setup.c           | 24 +++++-----
 plat/nvidia/tegra/common/tegra_bl31_setup.c   |  7 +--
 plat/nvidia/tegra/soc/t186/drivers/mce/mce.c  |  4 +-
 plat/nvidia/tegra/soc/t194/drivers/mce/mce.c  |  4 +-
 plat/nvidia/tegra/soc/t194/plat_ras.c         |  7 +--
 plat/nvidia/tegra/soc/t210/plat_sip_calls.c   |  5 +-
 plat/nxp/common/setup/ls_bl31_setup.c         |  6 ++-
 plat/renesas/rzg/bl2_plat_setup.c             |  4 +-
 plat/xilinx/common/plat_startup.c             | 10 ++--
 services/spd/trusty/trusty.c                  | 10 ++--
 services/std_svc/spmd/spmd_main.c             | 18 +++----
 services/std_svc/spmd/spmd_pm.c               |  7 ++-
 37 files changed, 312 insertions(+), 112 deletions(-)
 create mode 100644 include/lib/libc/aarch32/inttypes_.h
 create mode 100644 include/lib/libc/aarch32/stdint_.h
 create mode 100644 include/lib/libc/aarch64/inttypes_.h
 create mode 100644 include/lib/libc/aarch64/stdint_.h
 create mode 100644 include/lib/libc/inttypes.h

diff --git a/bl32/tsp/tsp_main.c b/bl32/tsp/tsp_main.c
index 01c9ec58f..55e153212 100644
--- a/bl32/tsp/tsp_main.c
+++ b/bl32/tsp/tsp_main.c
@@ -5,6 +5,8 @@
  */
 
 #include <assert.h>
+#include <inttypes.h>
+#include <stdint.h>
 
 #include <arch_features.h>
 #include <arch_helpers.h>
@@ -271,7 +273,7 @@ tsp_args_t *tsp_cpu_resume_main(uint64_t max_off_pwrlvl,
 
 #if LOG_LEVEL >= LOG_LEVEL_INFO
 	spin_lock(&console_lock);
-	INFO("TSP: cpu 0x%lx resumed. maximum off power level %lld\n",
+	INFO("TSP: cpu 0x%lx resumed. maximum off power level %" PRId64 "\n",
 	     read_mpidr(), max_off_pwrlvl);
 	INFO("TSP: cpu 0x%lx: %d smcs, %d erets %d cpu resume requests\n",
 		read_mpidr(),
@@ -375,7 +377,7 @@ tsp_args_t *tsp_smc_handler(uint64_t func,
 
 #if LOG_LEVEL >= LOG_LEVEL_INFO
 	spin_lock(&console_lock);
-	INFO("TSP: cpu 0x%lx received %s smc 0x%llx\n", read_mpidr(),
+	INFO("TSP: cpu 0x%lx received %s smc 0x%" PRIx64 "\n", read_mpidr(),
 		((func >> 31) & 1) == 1 ? "fast" : "yielding",
 		func);
 	INFO("TSP: cpu 0x%lx: %d smcs, %d erets\n", read_mpidr(),
diff --git a/common/fdt_wrappers.c b/common/fdt_wrappers.c
index dd7a0faef..8fcef60e1 100644
--- a/common/fdt_wrappers.c
+++ b/common/fdt_wrappers.c
@@ -8,6 +8,8 @@
 
 #include <assert.h>
 #include <errno.h>
+#include <inttypes.h>
+#include <stdint.h>
 #include <string.h>
 
 #include <libfdt.h>
@@ -402,7 +404,7 @@ static bool fdtw_xlat_hit(const uint32_t *value, int child_addr_size,
 	addr_range = fdt_read_prop_cells(value + child_addr_size +
 				parent_addr_size,
 				range_size);
-	VERBOSE("DT: Address %llx mapped to %llx with range %llx\n",
+	VERBOSE("DT: Address %" PRIx64 " mapped to %" PRIx64 " with range %" PRIx64 "\n",
 		local_address, parent_address, addr_range);
 
 	/* Perform range check */
@@ -413,8 +415,8 @@ static bool fdtw_xlat_hit(const uint32_t *value, int child_addr_size,
 
 	/* Found hit for the addr range that needs to be translated */
 	*translated_addr = parent_address + (base_address - local_address);
-	VERBOSE("DT: child address %llx mapped to %llx in parent bus\n",
-			local_address, parent_address);
+	VERBOSE("DT: child address %" PRIx64 "mapped to %" PRIx64 " in parent bus\n",
+		local_address, parent_address);
 	return true;
 }
 
@@ -470,8 +472,8 @@ static uint64_t fdtw_search_all_xlat_entries(const void *dtb,
 		next_entry = next_entry + ncells_xlat;
 	}
 
-	INFO("DT: No translation found for address %llx in node %s\n",
-		base_address, fdt_get_name(dtb, local_bus, NULL));
+	INFO("DT: No translation found for address %" PRIx64 " in node %s\n",
+	     base_address, fdt_get_name(dtb, local_bus, NULL));
 	return ILLEGAL_ADDR;
 }
 
diff --git a/drivers/brcm/emmc/emmc_csl_sdcard.c b/drivers/brcm/emmc/emmc_csl_sdcard.c
index d6ad4bc9c..9e2c618d9 100644
--- a/drivers/brcm/emmc/emmc_csl_sdcard.c
+++ b/drivers/brcm/emmc/emmc_csl_sdcard.c
@@ -4,9 +4,11 @@
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
+#include <inttypes.h>
+#include <stddef.h>
+#include <stdint.h>
 #include <stdlib.h>
 #include <string.h>
-#include <stddef.h>
 
 #include <arch_helpers.h>
 #include <lib/mmio.h>
@@ -521,7 +523,7 @@ static int xfer_data(struct sd_handle *handle,
 {
 	int rc = SD_OK;
 
-	VERBOSE("XFER: dest: 0x%llx, addr: 0x%x, size: 0x%x bytes\n",
+	VERBOSE("XFER: dest: 0x%" PRIx64 ", addr: 0x%x, size: 0x%x bytes\n",
 		(uint64_t)base, addr, length);
 
 	if ((length / handle->device->cfg.blockSize) > 1) {
diff --git a/drivers/marvell/amb_adec.c b/drivers/marvell/amb_adec.c
index 1f671058d..d78fa2517 100644
--- a/drivers/marvell/amb_adec.c
+++ b/drivers/marvell/amb_adec.c
@@ -7,6 +7,9 @@
 
 /* AXI to M-Bridge decoding unit driver for Marvell Armada 8K and 8K+ SoCs */
 
+#include <inttypes.h>
+#include <stdint.h>
+
 #include <common/debug.h>
 #include <lib/mmio.h>
 
@@ -44,10 +47,10 @@ static void amb_check_win(struct addr_map_win *win, uint32_t win_num)
 
 	/* make sure the base address is in 16-bit range */
 	if (win->base_addr > AMB_BASE_ADDR_MASK) {
-		WARN("Window %d: base address is too big 0x%llx\n",
+		WARN("Window %d: base address is too big 0x%" PRIx64 "\n",
 		       win_num, win->base_addr);
 		win->base_addr = AMB_BASE_ADDR_MASK;
-		WARN("Set the base address to 0x%llx\n", win->base_addr);
+		WARN("Set the base address to 0x%" PRIx64 "\n", win->base_addr);
 	}
 
 	base_addr  = win->base_addr << AMB_BASE_OFFSET;
@@ -57,15 +60,15 @@ static void amb_check_win(struct addr_map_win *win, uint32_t win_num)
 		win->base_addr = ALIGN_UP(base_addr, AMB_WIN_ALIGNMENT_1M);
 		WARN("Window %d: base address unaligned to 0x%x\n",
 		       win_num, AMB_WIN_ALIGNMENT_1M);
-		WARN("Align up the base address to 0x%llx\n", win->base_addr);
+		WARN("Align up the base address to 0x%" PRIx64 "\n", win->base_addr);
 	}
 
 	/* size parameter validity check */
 	if (!IS_POWER_OF_2(win->win_size)) {
-		WARN("Window %d: window size is not power of 2 (0x%llx)\n",
+		WARN("Window %d: window size is not power of 2 (0x%" PRIx64 ")\n",
 		       win_num, win->win_size);
 		win->win_size = ROUND_UP_TO_POW_OF_2(win->win_size);
-		WARN("Rounding size to 0x%llx\n", win->win_size);
+		WARN("Rounding size to 0x%" PRIx64 "\n", win->win_size);
 	}
 }
 
diff --git a/drivers/marvell/ccu.c b/drivers/marvell/ccu.c
index b4251f49b..c206f1168 100644
--- a/drivers/marvell/ccu.c
+++ b/drivers/marvell/ccu.c
@@ -7,6 +7,9 @@
 
 /* CCU unit device driver for Marvell AP807, AP807 and AP810 SoCs */
 
+#include <inttypes.h>
+#include <stdint.h>
+
 #include <common/debug.h>
 #include <drivers/marvell/ccu.h>
 #include <lib/mmio.h>
@@ -84,7 +87,7 @@ static void dump_ccu(int ap_index)
 							      win_id));
 			start = ((uint64_t)alr << ADDRESS_SHIFT);
 			end = (((uint64_t)ahr + 0x10) << ADDRESS_SHIFT);
-			printf("\tccu%d    %02x     0x%016llx 0x%016llx\n",
+			printf("\tccu%d    %02x     0x%016" PRIx64 " 0x%016" PRIx64 "\n",
 			       win_id, target_id, start, end);
 		}
 	}
@@ -99,14 +102,14 @@ void ccu_win_check(struct addr_map_win *win)
 	/* check if address is aligned to 1M */
 	if (IS_NOT_ALIGN(win->base_addr, CCU_WIN_ALIGNMENT)) {
 		win->base_addr = ALIGN_UP(win->base_addr, CCU_WIN_ALIGNMENT);
-		NOTICE("%s: Align up the base address to 0x%llx\n",
+		NOTICE("%s: Align up the base address to 0x%" PRIx64 "\n",
 		       __func__, win->base_addr);
 	}
 
 	/* size parameter validity check */
 	if (IS_NOT_ALIGN(win->win_size, CCU_WIN_ALIGNMENT)) {
 		win->win_size = ALIGN_UP(win->win_size, CCU_WIN_ALIGNMENT);
-		NOTICE("%s: Aligning size to 0x%llx\n",
+		NOTICE("%s: Aligning size to 0x%" PRIx64 "\n",
 		       __func__, win->win_size);
 	}
 }
diff --git a/drivers/marvell/comphy/phy-comphy-cp110.c b/drivers/marvell/comphy/phy-comphy-cp110.c
index c8ba9b8d3..57883c0f7 100644
--- a/drivers/marvell/comphy/phy-comphy-cp110.c
+++ b/drivers/marvell/comphy/phy-comphy-cp110.c
@@ -8,6 +8,8 @@
 /* Marvell CP110 SoC COMPHY unit driver */
 
 #include <errno.h>
+#include <inttypes.h>
+#include <stdint.h>
 
 #include <common/debug.h>
 #include <drivers/delay_timer.h>
@@ -102,7 +104,7 @@ static void mvebu_cp110_get_ap_and_cp_nr(uint8_t *ap_nr, uint8_t *cp_nr,
 	*cp_nr = (((comphy_base & ~0xffffff) - MVEBU_AP_IO_BASE(*ap_nr)) /
 		 MVEBU_CP_OFFSET);
 
-	debug("cp_base 0x%llx, ap_io_base 0x%lx, cp_offset 0x%lx\n",
+	debug("cp_base 0x%" PRIx64 ", ap_io_base 0x%lx, cp_offset 0x%lx\n",
 	       comphy_base, (unsigned long)MVEBU_AP_IO_BASE(*ap_nr),
 	       (unsigned long)MVEBU_CP_OFFSET);
 }
diff --git a/drivers/marvell/gwin.c b/drivers/marvell/gwin.c
index 9d9430836..fa59cb033 100644
--- a/drivers/marvell/gwin.c
+++ b/drivers/marvell/gwin.c
@@ -7,6 +7,9 @@
 
 /* GWIN unit device driver for Marvell AP810 SoC */
 
+#include <inttypes.h>
+#include <stdint.h>
+
 #include <common/debug.h>
 #include <drivers/marvell/gwin.h>
 #include <lib/mmio.h>
@@ -49,14 +52,14 @@ static void gwin_check(struct addr_map_win *win)
 	/* The base is always 64M aligned */
 	if (IS_NOT_ALIGN(win->base_addr, GWIN_ALIGNMENT_64M)) {
 		win->base_addr &= ~(GWIN_ALIGNMENT_64M - 1);
-		NOTICE("%s: Align the base address to 0x%llx\n",
+		NOTICE("%s: Align the base address to 0x%" PRIx64 "\n",
 		       __func__, win->base_addr);
 	}
 
 	/* size parameter validity check */
 	if (IS_NOT_ALIGN(win->win_size, GWIN_ALIGNMENT_64M)) {
 		win->win_size = ALIGN_UP(win->win_size, GWIN_ALIGNMENT_64M);
-		NOTICE("%s: Aligning window size to 0x%llx\n",
+		NOTICE("%s: Aligning window size to 0x%" PRIx64 "\n",
 		       __func__, win->win_size);
 	}
 }
@@ -167,7 +170,7 @@ static void dump_gwin(int ap_index)
 			alr = (alr >> ADDRESS_LSHIFT) << ADDRESS_RSHIFT;
 			ahr = mmio_read_32(GWIN_AHR_OFFSET(ap_index, win_num));
 			ahr = (ahr >> ADDRESS_LSHIFT) << ADDRESS_RSHIFT;
-			printf("\tgwin   %d     0x%016llx 0x%016llx\n",
+			printf("\tgwin   %d     0x%016" PRIx64 " 0x%016" PRIx64 "\n",
 			       (cr >> 8) & 0xF, alr, ahr);
 		}
 	}
diff --git a/drivers/marvell/io_win.c b/drivers/marvell/io_win.c
index c4257fa7c..124382ad9 100644
--- a/drivers/marvell/io_win.c
+++ b/drivers/marvell/io_win.c
@@ -7,6 +7,9 @@
 
 /* IO Window unit device driver for Marvell AP807, AP807 and AP810 SoCs */
 
+#include <inttypes.h>
+#include <stdint.h>
+
 #include <common/debug.h>
 #include <drivers/marvell/io_win.h>
 #include <lib/mmio.h>
@@ -44,14 +47,14 @@ static void io_win_check(struct addr_map_win *win)
 	/* check if address is aligned to 1M */
 	if (IS_NOT_ALIGN(win->base_addr, IO_WIN_ALIGNMENT_1M)) {
 		win->base_addr = ALIGN_UP(win->base_addr, IO_WIN_ALIGNMENT_1M);
-		NOTICE("%s: Align up the base address to 0x%llx\n",
+		NOTICE("%s: Align up the base address to 0x%" PRIx64 "\n",
 		       __func__, win->base_addr);
 	}
 
 	/* size parameter validity check */
 	if (IS_NOT_ALIGN(win->win_size, IO_WIN_ALIGNMENT_1M)) {
 		win->win_size = ALIGN_UP(win->win_size, IO_WIN_ALIGNMENT_1M);
-		NOTICE("%s: Aligning size to 0x%llx\n",
+		NOTICE("%s: Aligning size to 0x%" PRIx64 "\n",
 		       __func__, win->win_size);
 	}
 }
@@ -170,7 +173,7 @@ static void dump_io_win(int ap_index)
 								win_id));
 			start = ((uint64_t)alr << ADDRESS_SHIFT);
 			end = (((uint64_t)ahr + 0x10) << ADDRESS_SHIFT);
-			printf("\tio-win %d     0x%016llx 0x%016llx\n",
+			printf("\tio-win %d     0x%016" PRIx64 " 0x%016" PRIx64 "\n",
 			       trgt_id, start, end);
 		}
 	}
diff --git a/drivers/marvell/iob.c b/drivers/marvell/iob.c
index 29088aa92..1f3939560 100644
--- a/drivers/marvell/iob.c
+++ b/drivers/marvell/iob.c
@@ -7,6 +7,9 @@
 
 /* IOW unit device driver for Marvell CP110 and CP115 SoCs */
 
+#include <inttypes.h>
+#include <stdint.h>
+
 #include <arch_helpers.h>
 #include <common/debug.h>
 #include <drivers/marvell/iob.h>
@@ -57,7 +60,7 @@ static void iob_win_check(struct addr_map_win *win, uint32_t win_num)
 		win->base_addr = ALIGN_UP(win->base_addr, IOB_WIN_ALIGNMENT);
 		ERROR("Window %d: base address unaligned to 0x%x\n",
 		      win_num, IOB_WIN_ALIGNMENT);
-		printf("Align up the base address to 0x%llx\n",
+		printf("Align up the base address to 0x%" PRIx64 "\n",
 		       win->base_addr);
 	}
 
@@ -66,7 +69,7 @@ static void iob_win_check(struct addr_map_win *win, uint32_t win_num)
 		win->win_size = ALIGN_UP(win->win_size, IOB_WIN_ALIGNMENT);
 		ERROR("Window %d: window size unaligned to 0x%x\n", win_num,
 		      IOB_WIN_ALIGNMENT);
-		printf("Aligning size to 0x%llx\n", win->win_size);
+		printf("Aligning size to 0x%" PRIx64 "\n", win->win_size);
 	}
 }
 
@@ -130,7 +133,7 @@ static void dump_iob(void)
 				 */
 				end = start + (16 << 20);
 			}
-			printf("iob   %02d %s   0x%016llx 0x%016llx\n",
+			printf("iob   %02d %s   0x%016" PRIx64 " 0x%016" PRIx64 "\n",
 			       win_id, iob_target_name[target_id],
 			       start, end);
 		}
diff --git a/drivers/marvell/mc_trustzone/mc_trustzone.c b/drivers/marvell/mc_trustzone/mc_trustzone.c
index 52b300676..648bd0e98 100644
--- a/drivers/marvell/mc_trustzone/mc_trustzone.c
+++ b/drivers/marvell/mc_trustzone/mc_trustzone.c
@@ -5,6 +5,9 @@
  * https://spdx.org/licenses
  */
 
+#include <inttypes.h>
+#include <stdint.h>
+
 #include <common/debug.h>
 #include <drivers/marvell/addr_map.h>
 #include <lib/mmio.h>
@@ -39,7 +42,7 @@ void tz_enable_win(int ap_index, const struct addr_map_win *win, int win_id)
 	/* map the window size to trustzone register convention */
 	tz_size = fls(TZ_SIZE(win->win_size));
 
-	VERBOSE("%s: window size = 0x%llx maps to tz_size %d\n",
+	VERBOSE("%s: window size = 0x%" PRIx64 " maps to tz_size %d\n",
 		__func__, win->win_size, tz_size);
 	if (tz_size < 0 || tz_size > 31) {
 		ERROR("Using not allowed size for MC TrustZone window %d!\n",
@@ -49,7 +52,7 @@ void tz_enable_win(int ap_index, const struct addr_map_win *win, int win_id)
 
 	if (base & 0xfff) {
 		base = base & ~0xfff;
-		WARN("Attempt to open MC TZ win. at 0x%llx, truncate to 0x%x\n",
+		WARN("Attempt to open MC TZ win. at 0x%" PRIx64 ", truncate to 0x%x\n",
 		     win->base_addr, base);
 	}
 
diff --git a/drivers/mtd/spi-mem/spi_mem.c b/drivers/mtd/spi-mem/spi_mem.c
index 63ea7699b..010e8b62a 100644
--- a/drivers/mtd/spi-mem/spi_mem.c
+++ b/drivers/mtd/spi-mem/spi_mem.c
@@ -5,6 +5,8 @@
  */
 
 #include <assert.h>
+#include <inttypes.h>
+#include <stdint.h>
 
 #include <libfdt.h>
 
@@ -150,7 +152,7 @@ int spi_mem_exec_op(const struct spi_mem_op *op)
 	const struct spi_bus_ops *ops = spi_slave.ops;
 	int ret;
 
-	VERBOSE("%s: cmd:%x mode:%d.%d.%d.%d addqr:%llx len:%x\n",
+	VERBOSE("%s: cmd:%x mode:%d.%d.%d.%d addqr:%" PRIx64 " len:%x\n",
 		__func__, op->cmd.opcode, op->cmd.buswidth, op->addr.buswidth,
 		op->dummy.buswidth, op->data.buswidth,
 		op->addr.val, op->data.nbytes);
diff --git a/drivers/nxp/ddr/nxp-ddr/ddr.c b/drivers/nxp/ddr/nxp-ddr/ddr.c
index 216e05c7c..c051b3b25 100644
--- a/drivers/nxp/ddr/nxp-ddr/ddr.c
+++ b/drivers/nxp/ddr/nxp-ddr/ddr.c
@@ -5,6 +5,7 @@
  */
 
 #include <errno.h>
+#include <inttypes.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -850,7 +851,7 @@ long long dram_init(struct ddr_info *priv
 	priv->ip_rev = ip_rev;
 
 #ifndef CONFIG_STATIC_DDR
-	INFO("time base %llu ms\n", time_base);
+	INFO("time base %" PRIu64 " ms\n", time_base);
 	debug("Parse DIMM SPD(s)\n");
 	valid_spd_mask = parse_spd(priv);
 
@@ -870,7 +871,7 @@ long long dram_init(struct ddr_info *priv
 #endif
 
 	time = get_timer_val(time_base);
-	INFO("Time after parsing SPD %llu ms\n", time);
+	INFO("Time after parsing SPD %" PRIu64 " ms\n", time);
 	debug("Synthesize configurations\n");
 	ret = synthesize_ctlr(priv);
 	if (ret != 0) {
@@ -911,7 +912,7 @@ long long dram_init(struct ddr_info *priv
 	}
 
 	time = get_timer_val(time_base);
-	INFO("Time before programming controller %llu ms\n", time);
+	INFO("Time before programming controller %" PRIu64 " ms\n", time);
 	debug("Program controller registers\n");
 	ret = write_ddrc_regs(priv);
 	if (ret != 0) {
@@ -924,7 +925,7 @@ long long dram_init(struct ddr_info *priv
 	print_ddr_info(priv->ddr[0]);
 
 	time = get_timer_val(time_base);
-	INFO("Time used by DDR driver %llu ms\n", time);
+	INFO("Time used by DDR driver %" PRIu64 " ms\n", time);
 
 	return dram_size;
 }
diff --git a/include/lib/libc/aarch32/inttypes_.h b/include/lib/libc/aarch32/inttypes_.h
new file mode 100644
index 000000000..11d2d3525
--- /dev/null
+++ b/include/lib/libc/aarch32/inttypes_.h
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2020 Broadcom
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+/*
+ * Portions copyright (c) 2020, ARM Limited and Contributors.
+ * All rights reserved.
+ */
+
+#ifndef INTTYPES__H
+#define INTTYPES__H
+
+#define PRId64		"lld"	/* int64_t */
+#define PRIi64		"lli"	/* int64_t */
+#define PRIo64		"llo"	/* int64_t */
+#define PRIu64		"llu"	/* uint64_t */
+#define PRIx64		"llx"	/* uint64_t */
+#define PRIX64		"llX"	/* uint64_t */
+
+#endif /* INTTYPES__H */
diff --git a/include/lib/libc/aarch32/stdint_.h b/include/lib/libc/aarch32/stdint_.h
new file mode 100644
index 000000000..dafe142b5
--- /dev/null
+++ b/include/lib/libc/aarch32/stdint_.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2020 Broadcom
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+/*
+ * Portions copyright (c) 2020, ARM Limited and Contributors.
+ * All rights reserved.
+ */
+
+#ifndef STDINT__H
+#define STDINT__H
+
+#define INT64_MAX  LLONG_MAX
+#define INT64_MIN  LLONG_MIN
+#define UINT64_MAX ULLONG_MAX
+
+#define INT64_C(x) x ## LL
+#define UINT64_C(x) x ## ULL
+
+typedef long long int64_t;
+typedef unsigned long long uint64_t;
+typedef long long int64_least_t;
+typedef unsigned long long uint64_least_t;
+typedef long long int64_fast_t;
+typedef unsigned long long uint64_fast_t;
+
+#endif
diff --git a/include/lib/libc/aarch64/inttypes_.h b/include/lib/libc/aarch64/inttypes_.h
new file mode 100644
index 000000000..197d627bc
--- /dev/null
+++ b/include/lib/libc/aarch64/inttypes_.h
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2020 Broadcom
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+/*
+ * Portions copyright (c) 2020, ARM Limited and Contributors.
+ * All rights reserved.
+ */
+
+#ifndef INTTYPES__H
+#define INTTYPES__H
+
+#define PRId64		"ld"	/* int64_t */
+#define PRIi64		"li"	/* int64_t */
+#define PRIo64		"lo"	/* int64_t */
+#define PRIu64		"lu"	/* uint64_t */
+#define PRIx64		"lx"	/* uint64_t */
+#define PRIX64		"lX"	/* uint64_t */
+
+#endif /* INTTYPES__H */
diff --git a/include/lib/libc/aarch64/stdint_.h b/include/lib/libc/aarch64/stdint_.h
new file mode 100644
index 000000000..56e9f1b4c
--- /dev/null
+++ b/include/lib/libc/aarch64/stdint_.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2020 Broadcom
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+/*
+ * Portions copyright (c) 2020, ARM Limited and Contributors.
+ * All rights reserved.
+ */
+
+#ifndef STDINT__H
+#define STDINT__H
+
+#define INT64_MAX  LONG_MAX
+#define INT64_MIN  LONG_MIN
+#define UINT64_MAX ULONG_MAX
+
+#define INT64_C(x) x ## L
+#define UINT64_C(x) x ## UL
+
+typedef long int64_t;
+typedef unsigned long uint64_t;
+typedef long int64_least_t;
+typedef unsigned long uint64_least_t;
+typedef long int64_fast_t;
+typedef unsigned long uint64_fast_t;
+
+typedef __int128 int128_t;
+typedef unsigned __int128 uint128_t;
+
+#endif
diff --git a/include/lib/libc/inttypes.h b/include/lib/libc/inttypes.h
new file mode 100644
index 000000000..0f9e8c612
--- /dev/null
+++ b/include/lib/libc/inttypes.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2020 Broadcom
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+/*
+ * Portions copyright (c) 2020, ARM Limited and Contributors.
+ * All rights reserved.
+ */
+
+#ifndef INTTYPES_H
+#define INTTYPES_H
+
+#include <inttypes_.h>
+#include <stdint.h>
+
+#define PRId8		"d"	/* int8_t */
+#define PRId16		"d"	/* int16_t */
+#define PRId32		"d"	/* int32_t */
+#define PRIdPTR		"d"	/* intptr_t */
+
+#define PRIi8		"i"	/* int8_t */
+#define PRIi16		"i"	/* int16_t */
+#define PRIi32		"i"	/* int32_t */
+#define PRIiPTR		"i"	/* intptr_t */
+
+#define PRIo8		"o"	/* int8_t */
+#define PRIo16		"o"	/* int16_t */
+#define PRIo32		"o"	/* int32_t */
+#define PRIoPTR		"o"	/* intptr_t */
+
+#define PRIu8		"u"	/* uint8_t */
+#define PRIu16		"u"	/* uint16_t */
+#define PRIu32		"u"	/* uint32_t */
+#define PRIuPTR		"u"	/* uintptr_t */
+
+#define PRIx8		"x"	/* uint8_t */
+#define PRIx16		"x"	/* uint16_t */
+#define PRIx32		"x"	/* uint32_t */
+#define PRIxPTR		"x"	/* uintptr_t */
+
+#define PRIX8		"X"	/* uint8_t */
+#define PRIX16		"X"	/* uint16_t */
+#define PRIX32		"X"	/* uint32_t */
+#define PRIXPTR		"X"	/* uintptr_t */
+
+#endif
diff --git a/include/lib/libc/stdint.h b/include/lib/libc/stdint.h
index 818870e16..e96a25cd3 100644
--- a/include/lib/libc/stdint.h
+++ b/include/lib/libc/stdint.h
@@ -12,6 +12,7 @@
 #define STDINT_H
 
 #include <limits.h>
+#include <stdint_.h>
 
 #define INT8_MAX  CHAR_MAX
 #define INT8_MIN  CHAR_MIN
@@ -25,10 +26,6 @@
 #define INT32_MIN  INT_MIN
 #define UINT32_MAX UINT_MAX
 
-#define INT64_MAX  LLONG_MAX
-#define INT64_MIN  LLONG_MIN
-#define UINT64_MAX ULLONG_MAX
-
 #define INT_LEAST8_MIN  INT8_MIN
 #define INT_LEAST8_MAX  INT8_MAX
 #define UINT_LEAST8_MAX UINT8_MAX
@@ -77,12 +74,10 @@
 #define INT8_C(x)  x
 #define INT16_C(x) x
 #define INT32_C(x) x
-#define INT64_C(x) x ## LL
 
 #define UINT8_C(x)  x
 #define UINT16_C(x) x
 #define UINT32_C(x) x ## U
-#define UINT64_C(x) x ## ULL
 
 #define INTMAX_C(x)  x ## LL
 #define UINTMAX_C(x) x ## ULL
@@ -90,32 +85,26 @@
 typedef signed char int8_t;
 typedef short int16_t;
 typedef int int32_t;
-typedef long long int64_t;
 
 typedef unsigned char uint8_t;
 typedef unsigned short uint16_t;
 typedef unsigned int uint32_t;
-typedef unsigned long long uint64_t;
 
 typedef signed char int8_least_t;
 typedef short int16_least_t;
 typedef int int32_least_t;
-typedef long long int64_least_t;
 
 typedef unsigned char uint8_least_t;
 typedef unsigned short uint16_least_t;
 typedef unsigned int uint32_least_t;
-typedef unsigned long long uint64_least_t;
 
 typedef int int8_fast_t;
 typedef int int16_fast_t;
 typedef int int32_fast_t;
-typedef long long int64_fast_t;
 
 typedef unsigned int uint8_fast_t;
 typedef unsigned int uint16_fast_t;
 typedef unsigned int uint32_fast_t;
-typedef unsigned long long uint64_fast_t;
 
 typedef long intptr_t;
 typedef unsigned long uintptr_t;
@@ -130,9 +119,4 @@ typedef unsigned long long uintmax_t;
 typedef long register_t;
 typedef unsigned long u_register_t;
 
-#ifdef __aarch64__
-typedef __int128 int128_t;
-typedef unsigned __int128 uint128_t;
-#endif /* __aarch64__ */
-
 #endif /* STDINT_H */
diff --git a/lib/bl_aux_params/bl_aux_params.c b/lib/bl_aux_params/bl_aux_params.c
index 7a8115c61..7f357b7c2 100644
--- a/lib/bl_aux_params/bl_aux_params.c
+++ b/lib/bl_aux_params/bl_aux_params.c
@@ -3,6 +3,8 @@
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
+#include <inttypes.h>
+#include <stdint.h>
 
 #include <common/debug.h>
 #include <lib/coreboot.h>
@@ -25,7 +27,7 @@ void bl_aux_params_parse(u_register_t head,
 			break;
 #endif
 		default:
-			ERROR("Ignoring unknown BL aux parameter: 0x%llx",
+			ERROR("Ignoring unknown BL aux parameter: 0x%" PRIx64,
 			      p->type);
 			break;
 		}
diff --git a/plat/arm/board/fvp/fconf/fconf_hw_config_getter.c b/plat/arm/board/fvp/fconf/fconf_hw_config_getter.c
index 35a777b6f..45e3b7eb2 100644
--- a/plat/arm/board/fvp/fconf/fconf_hw_config_getter.c
+++ b/plat/arm/board/fvp/fconf/fconf_hw_config_getter.c
@@ -5,6 +5,9 @@
  */
 
 #include <assert.h>
+#include <inttypes.h>
+#include <stdint.h>
+
 #include <common/debug.h>
 #include <common/fdt_wrappers.h>
 #include <fconf_hw_config_getter.h>
@@ -229,7 +232,7 @@ int fconf_populate_uart_config(uintptr_t config)
 
 	uart_serial_config.uart_base = translated_addr;
 
-	VERBOSE("FCONF: UART serial device base address: %llx\n",
+	VERBOSE("FCONF: UART serial device base address: %" PRIx64 "\n",
 		uart_serial_config.uart_base);
 
 	/*
diff --git a/plat/common/aarch64/plat_common.c b/plat/common/aarch64/plat_common.c
index ba4c366a9..deb5b7eb3 100644
--- a/plat/common/aarch64/plat_common.c
+++ b/plat/common/aarch64/plat_common.c
@@ -5,6 +5,8 @@
  */
 
 #include <assert.h>
+#include <inttypes.h>
+#include <stdint.h>
 
 #include <arch_helpers.h>
 #include <drivers/console.h>
@@ -53,7 +55,7 @@ unsigned int platform_core_pos_helper(unsigned long mpidr)
  */
 void plat_sdei_handle_masked_trigger(uint64_t mpidr, unsigned int intr)
 {
-	WARN("Spurious SDEI interrupt %u on masked PE %llx\n", intr, mpidr);
+	WARN("Spurious SDEI interrupt %u on masked PE %" PRIx64 "\n", intr, mpidr);
 }
 
 /*
@@ -92,7 +94,7 @@ void plat_ea_handler(unsigned int ea_reason, uint64_t syndrome, void *cookie,
 
 	ERROR("Unhandled External Abort received on 0x%lx from %s\n",
 		read_mpidr_el1(), get_el_str(level));
-	ERROR("exception reason=%u syndrome=0x%llx\n", ea_reason, syndrome);
+	ERROR("exception reason=%u syndrome=0x%" PRIx64 "\n", ea_reason, syndrome);
 #if HANDLE_EA_EL3_FIRST
 	/* Skip backtrace for lower EL */
 	if (level != MODE_EL3) {
diff --git a/plat/common/plat_spmd_manifest.c b/plat/common/plat_spmd_manifest.c
index 8f4018c7c..b1fc13cee 100644
--- a/plat/common/plat_spmd_manifest.c
+++ b/plat/common/plat_spmd_manifest.c
@@ -6,8 +6,10 @@
 
 #include <assert.h>
 #include <errno.h>
-#include <string.h>
+#include <inttypes.h>
 #include <libfdt.h>
+#include <stdint.h>
+#include <string.h>
 
 #include <common/bl_common.h>
 #include <common/debug.h>
@@ -80,8 +82,8 @@ static int manifest_parse_attribute(spmc_manifest_attribute_t *attr,
 	VERBOSE("  version: %u.%u\n", attr->major_version, attr->minor_version);
 	VERBOSE("  spmc_id: 0x%x\n", attr->spmc_id);
 	VERBOSE("  binary_size: 0x%x\n", attr->binary_size);
-	VERBOSE("  load_address: 0x%llx\n", attr->load_address);
-	VERBOSE("  entrypoint: 0x%llx\n", attr->entrypoint);
+	VERBOSE("  load_address: 0x%" PRIx64 "\n", attr->load_address);
+	VERBOSE("  entrypoint: 0x%" PRIx64 "\n", attr->entrypoint);
 
 	return 0;
 }
diff --git a/plat/hisilicon/hikey/hikey_bl1_setup.c b/plat/hisilicon/hikey/hikey_bl1_setup.c
index 01c48ec58..31ff8206e 100644
--- a/plat/hisilicon/hikey/hikey_bl1_setup.c
+++ b/plat/hisilicon/hikey/hikey_bl1_setup.c
@@ -6,6 +6,8 @@
 
 #include <assert.h>
 #include <errno.h>
+#include <inttypes.h>
+#include <stdint.h>
 #include <string.h>
 
 #include <arch_helpers.h>
@@ -155,7 +157,7 @@ void bl1_plat_set_ep_info(unsigned int image_id,
 		__asm__ volatile ("msr	cpacr_el1, %0" : : "r"(data));
 		__asm__ volatile ("mrs	%0, cpacr_el1" : "=r"(data));
 	} while ((data & (3 << 20)) != (3 << 20));
-	INFO("cpacr_el1:0x%llx\n", data);
+	INFO("cpacr_el1:0x%" PRIx64 "\n", data);
 
 	ep_info->args.arg0 = 0xffff & read_mpidr();
 	ep_info->spsr = SPSR_64(MODE_EL1, MODE_SP_ELX,
diff --git a/plat/hisilicon/poplar/bl31_plat_setup.c b/plat/hisilicon/poplar/bl31_plat_setup.c
index a4e17cabc..fe60ddcb1 100644
--- a/plat/hisilicon/poplar/bl31_plat_setup.c
+++ b/plat/hisilicon/poplar/bl31_plat_setup.c
@@ -6,7 +6,9 @@
 
 #include <assert.h>
 #include <errno.h>
+#include <inttypes.h>
 #include <stddef.h>
+#include <stdint.h>
 #include <string.h>
 
 #include <platform_def.h>
@@ -130,6 +132,6 @@ void bl31_plat_arch_setup(void)
 			       BL_COHERENT_RAM_BASE,
 			       BL_COHERENT_RAM_END);
 
-	INFO("Boot BL33 from 0x%lx for %llu Bytes\n",
+	INFO("Boot BL33 from 0x%lx for %" PRIu64 " Bytes\n",
 	     bl33_image_ep_info.pc, bl33_image_ep_info.args.arg2);
 }
diff --git a/plat/imx/imx8qm/imx8qm_bl31_setup.c b/plat/imx/imx8qm/imx8qm_bl31_setup.c
index 4ca6a5db4..d9c91107c 100644
--- a/plat/imx/imx8qm/imx8qm_bl31_setup.c
+++ b/plat/imx/imx8qm/imx8qm_bl31_setup.c
@@ -5,6 +5,8 @@
  */
 
 #include <assert.h>
+#include <inttypes.h>
+#include <stdint.h>
 #include <stdbool.h>
 
 #include <platform_def.h>
@@ -261,14 +263,14 @@ void mx8_partition_resources(void)
 			err = sc_rm_get_memreg_info(ipc_handle, mr, &start, &end);
 			if (err)
 				ERROR("Memreg get info failed, %u\n", mr);
-			NOTICE("Memreg %u 0x%llx -- 0x%llx\n", mr, start, end);
+			NOTICE("Memreg %u 0x%" PRIx64 " -- 0x%" PRIx64 "\n", mr, start, end);
 			if (BL31_BASE >= start && (BL31_LIMIT - 1) <= end) {
 				mr_record = mr; /* Record the mr for ATF running */
 			} else {
 				err = sc_rm_assign_memreg(ipc_handle, os_part, mr);
 				if (err)
-					ERROR("Memreg assign failed, 0x%llx -- 0x%llx, \
-						err %d\n", start, end, err);
+					ERROR("Memreg assign failed, 0x%" PRIx64 " -- 0x%" PRIx64 ", \
+					      err %d\n", start, end, err);
 			}
 		}
 	}
@@ -280,23 +282,23 @@ void mx8_partition_resources(void)
 		if ((BL31_LIMIT - 1) < end) {
 			err = sc_rm_memreg_alloc(ipc_handle, &mr, BL31_LIMIT, end);
 			if (err)
-				ERROR("sc_rm_memreg_alloc failed, 0x%llx -- 0x%llx\n",
-					(sc_faddr_t)BL31_LIMIT, end);
+				ERROR("sc_rm_memreg_alloc failed, 0x%" PRIx64 " -- 0x%" PRIx64 "\n",
+				      (sc_faddr_t)BL31_LIMIT, end);
 			err = sc_rm_assign_memreg(ipc_handle, os_part, mr);
 			if (err)
-				ERROR("Memreg assign failed, 0x%llx -- 0x%llx\n",
-					(sc_faddr_t)BL31_LIMIT, end);
+				ERROR("Memreg assign failed, 0x%" PRIx64 " -- 0x%" PRIx64 "\n",
+				      (sc_faddr_t)BL31_LIMIT, end);
 		}
 
 		if (start < (BL31_BASE - 1)) {
 			err = sc_rm_memreg_alloc(ipc_handle, &mr, start, BL31_BASE - 1);
 			if (err)
-				ERROR("sc_rm_memreg_alloc failed, 0x%llx -- 0x%llx\n",
-					start, (sc_faddr_t)BL31_BASE - 1);
+				ERROR("sc_rm_memreg_alloc failed, 0x%" PRIx64 " -- 0x%" PRIx64 "\n",
+				      start, (sc_faddr_t)BL31_BASE - 1);
 			err = sc_rm_assign_memreg(ipc_handle, os_part, mr);
 				if (err)
-					ERROR("Memreg assign failed, 0x%llx -- 0x%llx\n",
-						start, (sc_faddr_t)BL31_BASE - 1);
+					ERROR("Memreg assign failed, 0x%" PRIx64 " -- 0x%" PRIx64 "\n",
+					      start, (sc_faddr_t)BL31_BASE - 1);
 		}
 	}
 
diff --git a/plat/imx/imx8qx/imx8qx_bl31_setup.c b/plat/imx/imx8qx/imx8qx_bl31_setup.c
index 3ff540017..3739cd681 100644
--- a/plat/imx/imx8qx/imx8qx_bl31_setup.c
+++ b/plat/imx/imx8qx/imx8qx_bl31_setup.c
@@ -5,7 +5,9 @@
  */
 
 #include <assert.h>
+#include <inttypes.h>
 #include <stdbool.h>
+#include <stdint.h>
 
 #include <platform_def.h>
 
@@ -238,14 +240,14 @@ void imx8_partition_resources(void)
 			if (err)
 				ERROR("Memreg get info failed, %u\n", mr);
 
-			NOTICE("Memreg %u 0x%llx -- 0x%llx\n", mr, start, end);
+			NOTICE("Memreg %u 0x%" PRIx64 " -- 0x%" PRIx64 "\n", mr, start, end);
 			if (BL31_BASE >= start && (BL31_LIMIT - 1) <= end) {
 				mr_record = mr; /* Record the mr for ATF running */
 			} else {
 				err = sc_rm_assign_memreg(ipc_handle, os_part, mr);
 				if (err)
-					ERROR("Memreg assign failed, 0x%llx -- 0x%llx, \
-						err %d\n", start, end, err);
+					ERROR("Memreg assign failed, 0x%" PRIx64 " -- 0x%" PRIx64 ", \
+					      err %d\n", start, end, err);
 			}
 		}
 	}
@@ -257,23 +259,23 @@ void imx8_partition_resources(void)
 		if ((BL31_LIMIT - 1) < end) {
 			err = sc_rm_memreg_alloc(ipc_handle, &mr, BL31_LIMIT, end);
 			if (err)
-				ERROR("sc_rm_memreg_alloc failed, 0x%llx -- 0x%llx\n",
-					(sc_faddr_t)BL31_LIMIT, end);
+				ERROR("sc_rm_memreg_alloc failed, 0x%" PRIx64 " -- 0x%" PRIx64 "\n",
+				      (sc_faddr_t)BL31_LIMIT, end);
 			err = sc_rm_assign_memreg(ipc_handle, os_part, mr);
 			if (err)
-				ERROR("Memreg assign failed, 0x%llx -- 0x%llx\n",
-					(sc_faddr_t)BL31_LIMIT, end);
+				ERROR("Memreg assign failed, 0x%" PRIx64 " -- 0x%" PRIx64 "\n",
+				      (sc_faddr_t)BL31_LIMIT, end);
 		}
 
 		if (start < (BL31_BASE - 1)) {
 			err = sc_rm_memreg_alloc(ipc_handle, &mr, start, BL31_BASE - 1);
 			if (err)
-				ERROR("sc_rm_memreg_alloc failed, 0x%llx -- 0x%llx\n",
-					start, (sc_faddr_t)BL31_BASE - 1);
+				ERROR("sc_rm_memreg_alloc failed, 0x%" PRIx64 " -- 0x%" PRIx64 "\n",
+				      start, (sc_faddr_t)BL31_BASE - 1);
 			err = sc_rm_assign_memreg(ipc_handle, os_part, mr);
 			if (err)
-				ERROR("Memreg assign failed, 0x%llx -- 0x%llx\n",
-					start, (sc_faddr_t)BL31_BASE - 1);
+				ERROR("Memreg assign failed, 0x%" PRIx64 " -- 0x%" PRIx64 "\n",
+				      start, (sc_faddr_t)BL31_BASE - 1);
 		}
 	}
 
diff --git a/plat/nvidia/tegra/common/tegra_bl31_setup.c b/plat/nvidia/tegra/common/tegra_bl31_setup.c
index cb4886f1a..6a3eae0dd 100644
--- a/plat/nvidia/tegra/common/tegra_bl31_setup.c
+++ b/plat/nvidia/tegra/common/tegra_bl31_setup.c
@@ -7,6 +7,7 @@
 
 #include <assert.h>
 #include <errno.h>
+#include <inttypes.h>
 #include <stddef.h>
 #include <string.h>
 
@@ -336,7 +337,7 @@ int32_t bl31_check_ns_address(uint64_t base, uint64_t size_in_bytes)
 	 * Sanity check the input values
 	 */
 	if ((base == 0U) || (size_in_bytes == 0U)) {
-		ERROR("NS address 0x%llx (%lld bytes) is invalid\n",
+		ERROR("NS address 0x%" PRIx64 " (%" PRId64 " bytes) is invalid\n",
 			base, size_in_bytes);
 		return -EINVAL;
 	}
@@ -347,7 +348,7 @@ int32_t bl31_check_ns_address(uint64_t base, uint64_t size_in_bytes)
 	if ((base < TEGRA_DRAM_BASE) || (base >= TEGRA_DRAM_END) ||
 	    (end > TEGRA_DRAM_END)) {
 
-		ERROR("NS address 0x%llx is out-of-bounds!\n", base);
+		ERROR("NS address 0x%" PRIx64 " is out-of-bounds!\n", base);
 		return -EFAULT;
 	}
 
@@ -356,7 +357,7 @@ int32_t bl31_check_ns_address(uint64_t base, uint64_t size_in_bytes)
 	 * to check if the NS DRAM range overlaps the TZDRAM aperture.
 	 */
 	if ((base < (uint64_t)TZDRAM_END) && (end > tegra_bl31_phys_base)) {
-		ERROR("NS address 0x%llx overlaps TZDRAM!\n", base);
+		ERROR("NS address 0x%" PRIx64 " overlaps TZDRAM!\n", base);
 		return -ENOTSUP;
 	}
 
diff --git a/plat/nvidia/tegra/soc/t186/drivers/mce/mce.c b/plat/nvidia/tegra/soc/t186/drivers/mce/mce.c
index 54d3b2ccd..aebacebf2 100644
--- a/plat/nvidia/tegra/soc/t186/drivers/mce/mce.c
+++ b/plat/nvidia/tegra/soc/t186/drivers/mce/mce.c
@@ -7,6 +7,8 @@
 
 #include <assert.h>
 #include <errno.h>
+#include <inttypes.h>
+#include <stdint.h>
 #include <string.h>
 
 #include <arch.h>
@@ -341,7 +343,7 @@ int32_t mce_command_handler(uint64_t cmd, uint64_t arg0, uint64_t arg1,
 		break;
 
 	default:
-		ERROR("unknown MCE command (%llu)\n", cmd);
+		ERROR("unknown MCE command (%" PRIu64 ")\n", cmd);
 		ret = EINVAL;
 		break;
 	}
diff --git a/plat/nvidia/tegra/soc/t194/drivers/mce/mce.c b/plat/nvidia/tegra/soc/t194/drivers/mce/mce.c
index e3d5bd513..af1c0aa26 100644
--- a/plat/nvidia/tegra/soc/t194/drivers/mce/mce.c
+++ b/plat/nvidia/tegra/soc/t194/drivers/mce/mce.c
@@ -16,8 +16,10 @@
 #include <mce_private.h>
 #include <platform_def.h>
 #include <stdbool.h>
+#include <stdint.h>
 #include <string.h>
 #include <errno.h>
+#include <inttypes.h>
 #include <t194_nvg.h>
 #include <tegra_def.h>
 #include <tegra_platform.h>
@@ -69,7 +71,7 @@ int32_t mce_command_handler(uint64_t cmd, uint64_t arg0, uint64_t arg1,
 		break;
 
 	default:
-		ERROR("unknown MCE command (%llu)\n", cmd);
+		ERROR("unknown MCE command (%" PRIu64 ")\n", cmd);
 		ret = -EINVAL;
 		break;
 	}
diff --git a/plat/nvidia/tegra/soc/t194/plat_ras.c b/plat/nvidia/tegra/soc/t194/plat_ras.c
index 0c4c6fad6..9eec867ee 100644
--- a/plat/nvidia/tegra/soc/t194/plat_ras.c
+++ b/plat/nvidia/tegra/soc/t194/plat_ras.c
@@ -4,6 +4,7 @@
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
+#include <inttypes.h>
 #include <stdbool.h>
 #include <stdint.h>
 
@@ -54,7 +55,7 @@ static void tegra194_ea_handler(unsigned int ea_reason, uint64_t syndrome,
 
 	ras_lock();
 
-	ERROR("MPIDR 0x%lx: exception reason=%u syndrome=0x%llx\n",
+	ERROR("MPIDR 0x%lx: exception reason=%u syndrome=0x%" PRIx64 "\n",
 		read_mpidr(), ea_reason, syndrome);
 
 	/* Call RAS EA handler */
@@ -146,7 +147,7 @@ void tegra194_ras_enable(void)
 			/* enable the supported errors */
 			err_ctrl |= err_fr;
 
-			VERBOSE("errselr_el1:0x%x, erxfr:0x%llx, err_ctrl:0x%llx\n",
+			VERBOSE("errselr_el1:0x%x, erxfr:0x%" PRIx64 ", err_ctrl:0x%" PRIx64 "\n",
 				idx_start + j, err_fr, err_ctrl);
 
 			/* enable specified errors, or set to 0 if no supported error */
@@ -288,7 +289,7 @@ static int32_t tegra194_ras_node_handler(uint32_t errselr, const char *name,
 	/* keep the log print same as linux arm64_ras driver. */
 	ERROR("**************************************\n");
 	ERROR("RAS Error in %s, ERRSELR_EL1=0x%x:\n", name, errselr);
-	ERROR("\tStatus = 0x%llx\n", status);
+	ERROR("\tStatus = 0x%" PRIx64 "\n", status);
 
 	/* Print uncorrectable errror information. */
 	if (ERR_STATUS_GET_FIELD(status, UE) != 0U) {
diff --git a/plat/nvidia/tegra/soc/t210/plat_sip_calls.c b/plat/nvidia/tegra/soc/t210/plat_sip_calls.c
index 904f8d62e..e3484bea9 100644
--- a/plat/nvidia/tegra/soc/t210/plat_sip_calls.c
+++ b/plat/nvidia/tegra/soc/t210/plat_sip_calls.c
@@ -5,6 +5,9 @@
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
+#include <inttypes.h>
+#include <stdint.h>
+
 #include <arch.h>
 #include <arch_helpers.h>
 #include <assert.h>
@@ -71,7 +74,7 @@ int plat_sip_handler(uint32_t smc_fid,
 		case PMC_CRYPTO_OP_0:
 		case PMC_TSC_MULT_0:
 		case PMC_STICKY_BIT:
-			ERROR("%s: error offset=0x%llx\n", __func__, x2);
+			ERROR("%s: error offset=0x%" PRIx64 "\n", __func__, x2);
 			return -EFAULT;
 		default:
 			/* Valid register */
diff --git a/plat/nxp/common/setup/ls_bl31_setup.c b/plat/nxp/common/setup/ls_bl31_setup.c
index 6cf6ae36a..bd0ab4fb7 100644
--- a/plat/nxp/common/setup/ls_bl31_setup.c
+++ b/plat/nxp/common/setup/ls_bl31_setup.c
@@ -6,6 +6,8 @@
  */
 
 #include <assert.h>
+#include <inttypes.h>
+#include <stdint.h>
 
 #ifdef LS_EL3_INTERRUPT_HANDLER
 #include <ls_interrupt_mgmt.h>
@@ -126,7 +128,7 @@ void bl31_early_platform_setup2(u_register_t arg0, u_register_t arg1,
 					loc_dram_regions_info->num_dram_regions;
 			dram_regions_info.total_dram_size =
 					loc_dram_regions_info->total_dram_size;
-			VERBOSE("Number of DRAM Regions = %llx\n",
+			VERBOSE("Number of DRAM Regions = %" PRIx64 "\n",
 					dram_regions_info.num_dram_regions);
 
 			for (i = 0; i < dram_regions_info.num_dram_regions;
@@ -135,7 +137,7 @@ void bl31_early_platform_setup2(u_register_t arg0, u_register_t arg1,
 					loc_dram_regions_info->region[i].addr;
 				dram_regions_info.region[i].size =
 					loc_dram_regions_info->region[i].size;
-				VERBOSE("DRAM%d Size = %llx\n", i,
+				VERBOSE("DRAM%d Size = %" PRIx64 "\n", i,
 					dram_regions_info.region[i].size);
 			}
 			rcw_porsr1 = bl31_image_ep_info.args.arg4;
diff --git a/plat/renesas/rzg/bl2_plat_setup.c b/plat/renesas/rzg/bl2_plat_setup.c
index ccc2562ee..e9dbd2058 100644
--- a/plat/renesas/rzg/bl2_plat_setup.c
+++ b/plat/renesas/rzg/bl2_plat_setup.c
@@ -4,6 +4,8 @@
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
+#include <inttypes.h>
+#include <stdint.h>
 #include <string.h>
 
 #include <arch_helpers.h>
@@ -531,7 +533,7 @@ static void bl2_advertise_dram_entries(uint64_t dram_config[8])
 			continue;
 		}
 
-		NOTICE("BL2: CH%d: %llx - %llx, %lld %siB\n",
+		NOTICE("BL2: CH%d: %" PRIx64 " - %" PRIx64 ", %" PRId64 " %siB\n",
 		       chan, start, start + size - 1U,
 		       (size >> 30) ? : size >> 20,
 		       (size >> 30) ? "G" : "M");
diff --git a/plat/xilinx/common/plat_startup.c b/plat/xilinx/common/plat_startup.c
index 8c9a049dd..f02f41e91 100644
--- a/plat/xilinx/common/plat_startup.c
+++ b/plat/xilinx/common/plat_startup.c
@@ -5,6 +5,8 @@
  */
 
 #include <assert.h>
+#include <inttypes.h>
+#include <stdint.h>
 
 #include <arch_helpers.h>
 #include <common/debug.h>
@@ -170,12 +172,12 @@ enum fsbl_handoff fsbl_atf_handover(entry_point_info_t *bl32,
 	    (ATFHandoffParams->magic[1] != 'L') ||
 	    (ATFHandoffParams->magic[2] != 'N') ||
 	    (ATFHandoffParams->magic[3] != 'X')) {
-		ERROR("BL31: invalid ATF handoff structure at %llx\n",
+		ERROR("BL31: invalid ATF handoff structure at %" PRIx64 "\n",
 		      atf_handoff_addr);
 		return FSBL_HANDOFF_INVAL_STRUCT;
 	}
 
-	VERBOSE("BL31: ATF handoff params at:0x%llx, entries:%u\n",
+	VERBOSE("BL31: ATF handoff params at:0x%" PRIx64 ", entries:%u\n",
 		atf_handoff_addr, ATFHandoffParams->num_entries);
 	if (ATFHandoffParams->num_entries > FSBL_MAX_PARTITIONS) {
 		ERROR("BL31: ATF handoff params: too many partitions (%u/%u)\n",
@@ -193,7 +195,7 @@ enum fsbl_handoff fsbl_atf_handover(entry_point_info_t *bl32,
 		int target_estate, target_secure;
 		int target_cpu, target_endianness, target_el;
 
-		VERBOSE("BL31: %zd: entry:0x%llx, flags:0x%llx\n", i,
+		VERBOSE("BL31: %zd: entry:0x%" PRIx64 ", flags:0x%" PRIx64 "\n", i,
 			ATFHandoffParams->partition[i].entry_point,
 			ATFHandoffParams->partition[i].flags);
 
@@ -254,7 +256,7 @@ enum fsbl_handoff fsbl_atf_handover(entry_point_info_t *bl32,
 			}
 		}
 
-		VERBOSE("Setting up %s entry point to:%llx, el:%x\n",
+		VERBOSE("Setting up %s entry point to:%" PRIx64 ", el:%x\n",
 			target_secure == FSBL_FLAGS_SECURE ? "BL32" : "BL33",
 			ATFHandoffParams->partition[i].entry_point,
 			target_el);
diff --git a/services/spd/trusty/trusty.c b/services/spd/trusty/trusty.c
index e102b8228..7daebcdd1 100644
--- a/services/spd/trusty/trusty.c
+++ b/services/spd/trusty/trusty.c
@@ -6,8 +6,10 @@
  */
 
 #include <assert.h>
+#include <inttypes.h>
 #include <lib/xlat_tables/xlat_tables_v2.h>
 #include <stdbool.h>
+#include <stdint.h>
 #include <string.h>
 
 #include <arch_helpers.h>
@@ -172,7 +174,7 @@ static uint64_t trusty_set_fiq_handler(void *handle, uint64_t cpu,
 	struct trusty_cpu_ctx *ctx;
 
 	if (cpu >= (uint64_t)PLATFORM_CORE_COUNT) {
-		ERROR("%s: cpu %lld >= %d\n", __func__, cpu, PLATFORM_CORE_COUNT);
+		ERROR("%s: cpu %" PRId64 " >= %d\n", __func__, cpu, PLATFORM_CORE_COUNT);
 		return (uint64_t)SM_ERR_INVALID_PARAMETERS;
 	}
 
@@ -204,7 +206,7 @@ static uint64_t trusty_fiq_exit(void *handle, uint64_t x1, uint64_t x2, uint64_t
 
 	ret = trusty_context_switch(NON_SECURE, SMC_FC_FIQ_EXIT, 0, 0, 0);
 	if (ret.r0 != 1U) {
-		INFO("%s(%p) SMC_FC_FIQ_EXIT returned unexpected value, %lld\n",
+		INFO("%s(%p) SMC_FC_FIQ_EXIT returned unexpected value, %" PRId64 "\n",
 		       __func__, handle, ret.r0);
 	}
 
@@ -356,7 +358,7 @@ static void trusty_cpu_suspend(uint32_t off)
 
 	ret = trusty_context_switch(NON_SECURE, SMC_FC_CPU_SUSPEND, off, 0, 0);
 	if (ret.r0 != 0U) {
-		INFO("%s: cpu %d, SMC_FC_CPU_SUSPEND returned unexpected value, %lld\n",
+		INFO("%s: cpu %d, SMC_FC_CPU_SUSPEND returned unexpected value, %" PRId64 "\n",
 		     __func__, plat_my_core_pos(), ret.r0);
 	}
 }
@@ -367,7 +369,7 @@ static void trusty_cpu_resume(uint32_t on)
 
 	ret = trusty_context_switch(NON_SECURE, SMC_FC_CPU_RESUME, on, 0, 0);
 	if (ret.r0 != 0U) {
-		INFO("%s: cpu %d, SMC_FC_CPU_RESUME returned unexpected value, %lld\n",
+		INFO("%s: cpu %d, SMC_FC_CPU_RESUME returned unexpected value, %" PRId64 "\n",
 		     __func__, plat_my_core_pos(), ret.r0);
 	}
 }
diff --git a/services/std_svc/spmd/spmd_main.c b/services/std_svc/spmd/spmd_main.c
index 06039f007..1dcd4956f 100644
--- a/services/std_svc/spmd/spmd_main.c
+++ b/services/std_svc/spmd/spmd_main.c
@@ -6,6 +6,8 @@
 
 #include <assert.h>
 #include <errno.h>
+#include <inttypes.h>
+#include <stdint.h>
 #include <string.h>
 
 #include <arch_helpers.h>
@@ -49,7 +51,7 @@ spmd_spm_core_context_t *spmd_get_context_by_mpidr(uint64_t mpidr)
 	int core_idx = plat_core_pos_by_mpidr(mpidr);
 
 	if (core_idx < 0) {
-		ERROR("Invalid mpidr: %llx, returned ID: %d\n", mpidr, core_idx);
+		ERROR("Invalid mpidr: %" PRIx64 ", returned ID: %d\n", mpidr, core_idx);
 		panic();
 	}
 
@@ -169,7 +171,7 @@ static int32_t spmd_init(void)
 
 	rc = spmd_spm_core_sync_entry(ctx);
 	if (rc != 0ULL) {
-		ERROR("SPMC initialisation failed 0x%llx\n", rc);
+		ERROR("SPMC initialisation failed 0x%" PRIx64 "\n", rc);
 		return 0;
 	}
 
@@ -430,12 +432,12 @@ uint64_t spmd_smc_handler(uint32_t smc_fid,
 	/* Determine which security state this SMC originated from */
 	secure_origin = is_caller_secure(flags);
 
-	VERBOSE("SPM(%u): 0x%x 0x%llx 0x%llx 0x%llx 0x%llx "
-		"0x%llx 0x%llx 0x%llx\n",
-		linear_id, smc_fid, x1, x2, x3, x4,
-		SMC_GET_GP(handle, CTX_GPREG_X5),
-		SMC_GET_GP(handle, CTX_GPREG_X6),
-		SMC_GET_GP(handle, CTX_GPREG_X7));
+	VERBOSE("SPM(%u): 0x%x 0x%" PRIx64 " 0x%" PRIx64 " 0x%" PRIx64 " 0x%" PRIx64
+		" 0x%" PRIx64 " 0x%" PRIx64 " 0x%" PRIx64 "\n",
+		    linear_id, smc_fid, x1, x2, x3, x4,
+		    SMC_GET_GP(handle, CTX_GPREG_X5),
+		    SMC_GET_GP(handle, CTX_GPREG_X6),
+		    SMC_GET_GP(handle, CTX_GPREG_X7));
 
 	switch (smc_fid) {
 	case FFA_ERROR:
diff --git a/services/std_svc/spmd/spmd_pm.c b/services/std_svc/spmd/spmd_pm.c
index 074609c89..2d58cdbe9 100644
--- a/services/std_svc/spmd/spmd_pm.c
+++ b/services/std_svc/spmd/spmd_pm.c
@@ -6,6 +6,9 @@
 
 #include <assert.h>
 #include <errno.h>
+#include <inttypes.h>
+#include <stdint.h>
+
 #include <lib/el3_runtime/context_mgmt.h>
 #include <lib/spinlock.h>
 #include "spmd_private.h"
@@ -104,7 +107,7 @@ static void spmd_cpu_on_finish_handler(u_register_t unused)
 
 	rc = spmd_spm_core_sync_entry(ctx);
 	if (rc != 0ULL) {
-		ERROR("%s failed (%llu) on CPU%u\n", __func__, rc,
+		ERROR("%s failed (%" PRIu64 ") on CPU%u\n", __func__, rc,
 			linear_id);
 		ctx->state = SPMC_STATE_OFF;
 		return;
@@ -132,7 +135,7 @@ static int32_t spmd_cpu_off_handler(u_register_t unused)
 
 	rc = spmd_spm_core_sync_entry(ctx);
 	if (rc != 0ULL) {
-		ERROR("%s failed (%llu) on CPU%u\n", __func__, rc, linear_id);
+		ERROR("%s failed (%" PRIu64 ") on CPU%u\n", __func__, rc, linear_id);
 	}
 
 	/* Expect a direct message response from the SPMC. */
-- 
2.17.1

