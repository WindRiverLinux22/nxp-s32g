From 565892894fb42125f56f8cd91b5bdc3dbdb2399c Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Fri, 7 Oct 2022 10:38:19 +0300
Subject: [PATCH 30/30] s32cc: Disable the core even if its clock seems off

This is useful for the secondary cores of a cluster where
the clock status bit is reserved. It's safe to stop
these cores even if they don't have full control of their
clock. The master core (lowest MIDR ID) of the cluster
should to cut the clock during its shutdown. The SW upper
layers must contain glue logic where the slave cores of the
cluster are shutdown prior to the master core.

Skip turn-off procedure for cores which are in reset.

Issue: ALB-9435
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32/include/s32_mc_me.h              |  2 +-
 plat/nxp/s32/s32_mc_me.c                      | 50 ++++++++++++++-----
 plat/nxp/s32/s32_psci.c                       |  2 +-
 .../s32g/s32g2/include/s32g2_platform_def.h   |  1 +
 .../s32g/s32g3/include/s32g3_platform_def.h   |  1 +
 plat/nxp/s32/s32r/include/s32r_platform_def.h |  1 +
 6 files changed, 42 insertions(+), 15 deletions(-)

diff --git a/plat/nxp/s32/include/s32_mc_me.h b/plat/nxp/s32/include/s32_mc_me.h
index bfa376bcd..92015cce7 100644
--- a/plat/nxp/s32/include/s32_mc_me.h
+++ b/plat/nxp/s32/include/s32_mc_me.h
@@ -97,7 +97,7 @@ struct a53_haddr_mapping {
 
 void mc_me_apply_hw_changes(void);
 
-bool s32_core_in_reset(uint32_t core);
+bool is_a53_core_in_reset(uint32_t core);
 void s32_set_core_entrypoint(uint32_t core, uint64_t entrypoint);
 void s32_kick_secondary_ca53_core(uint32_t core);
 void s32_turn_off_core(uint8_t part, uint8_t core);
diff --git a/plat/nxp/s32/s32_mc_me.c b/plat/nxp/s32/s32_mc_me.c
index 61b4a0c79..140c7fee5 100644
--- a/plat/nxp/s32/s32_mc_me.c
+++ b/plat/nxp/s32/s32_mc_me.c
@@ -173,15 +173,33 @@ void mc_me_enable_partition_block(uint32_t part, uint32_t block)
 	mc_me_part_pupd_update_and_wait(S32_MC_ME_PRTN_N_PUPD_PCUD_MASK, part);
 }
 
-bool s32_core_in_reset(uint32_t core)
+bool is_core_in_reset(uint32_t part, uint32_t core)
 {
 	uint32_t stat, rst;
+	uintptr_t pstat_addr;
 
-	rst = BIT(get_rgm_a53_bit(core));
-	stat = mmio_read_32(S32_MC_RGM_PSTAT(S32_MC_RGM_RST_DOMAIN_CA53));
+	if (part == S32_MC_ME_CA53_PART) {
+		if (core >= PLATFORM_CORE_COUNT)
+			panic();
+
+		rst = BIT_32(get_rgm_a53_bit(core));
+		pstat_addr = S32_MC_RGM_PSTAT(S32_MC_RGM_RST_DOMAIN_CA53);
+	} else {
+		if (core >= PLATFORM_M7_CORE_COUNT)
+			panic();
+
+		rst = BIT_32(get_rgm_m7_bit(core));
+		pstat_addr = S32_MC_RGM_PSTAT(S32_MC_RGM_RST_DOMAIN_CM7);
+	}
+	stat = mmio_read_32(pstat_addr);
 	return ((stat & rst) != 0);
 }
 
+bool is_a53_core_in_reset(uint32_t core)
+{
+	return is_core_in_reset(S32_MC_ME_CA53_PART, core);
+}
+
 static bool s32_core_clock_running(uint32_t part, uint32_t core)
 {
 	uint32_t stat;
@@ -284,8 +302,12 @@ void s32_set_core_entrypoint(uint32_t core, uint64_t entrypoint)
 void s32_kick_secondary_ca53_core(uint32_t core)
 {
 	uint32_t rst;
-	uint32_t rst_mask = BIT(get_rgm_a53_bit(core));
+	uint32_t rst_mask;
+
+	if (core >= PLATFORM_CORE_COUNT)
+		panic();
 
+	rst_mask = BIT_32(get_rgm_a53_bit(core));
 	enable_a53_partition();
 
 	enable_a53_core_cluster(core);
@@ -298,7 +320,7 @@ void s32_kick_secondary_ca53_core(uint32_t core)
 		rst |= rst_mask;
 		mmio_write_32(S32_MC_RGM_PRST(S32_MC_RGM_RST_DOMAIN_CA53),
 			      rst);
-		while (!s32_core_in_reset(core))
+		while (!is_a53_core_in_reset(core))
 			;
 	}
 
@@ -306,7 +328,7 @@ void s32_kick_secondary_ca53_core(uint32_t core)
 	rst &= ~rst_mask;
 	mmio_write_32(S32_MC_RGM_PRST(S32_MC_RGM_RST_DOMAIN_CA53), rst);
 	/* Wait for reset bit to deassert */
-	while (s32_core_in_reset(core))
+	while (is_a53_core_in_reset(core))
 		;
 }
 
@@ -318,12 +340,18 @@ void s32_reset_core(uint8_t part, uint8_t core)
 	uintptr_t pstat;
 
 	if (part == S32_MC_ME_CA53_PART) {
-		resetc = BIT(get_rgm_a53_bit(core));
+		if (core >= PLATFORM_CORE_COUNT)
+			panic();
+
+		resetc = BIT_32(get_rgm_a53_bit(core));
 		prst = S32_MC_RGM_PRST(S32_MC_RGM_RST_DOMAIN_CA53);
 		pstat = S32_MC_RGM_PSTAT(S32_MC_RGM_RST_DOMAIN_CA53);
 	} else {
+		if (core >= PLATFORM_M7_CORE_COUNT)
+			panic();
+
 		/* M7 cores */
-		resetc = BIT(get_rgm_m7_bit(core));
+		resetc = BIT_32(get_rgm_m7_bit(core));
 		prst = S32_MC_RGM_PRST(S32_MC_RGM_RST_DOMAIN_CM7);
 		pstat = S32_MC_RGM_PSTAT(S32_MC_RGM_RST_DOMAIN_CM7);
 	}
@@ -342,11 +370,7 @@ void s32_turn_off_core(uint8_t part, uint8_t core)
 {
 	uint32_t stat;
 
-	/* Assumption : The core is already in WFI */
-	stat = mmio_read_32(S32_MC_ME_PRTN_N_CORE_M_STAT(part, core));
-
-	/* The clock isn't enabled */
-	if (!(stat & S32_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK))
+	if (is_core_in_reset(part, core))
 		return;
 
 	/* Wait for WFI */
diff --git a/plat/nxp/s32/s32_psci.c b/plat/nxp/s32/s32_psci.c
index 677f8a82c..3a8f43e41 100644
--- a/plat/nxp/s32/s32_psci.c
+++ b/plat/nxp/s32/s32_psci.c
@@ -60,7 +60,7 @@ static int s32_pwr_domain_on(u_register_t mpidr)
 		if (ret)
 			return PSCI_E_INVALID_PARAMS;
 	} else {
-		if (s32_core_in_reset(pos)) {
+		if (is_a53_core_in_reset(pos)) {
 			s32_set_core_entrypoint(pos, core_start_addr);
 			s32_kick_secondary_ca53_core(pos);
 		}
diff --git a/plat/nxp/s32/s32g/s32g2/include/s32g2_platform_def.h b/plat/nxp/s32/s32g/s32g2/include/s32g2_platform_def.h
index 0306d724a..2ba962548 100644
--- a/plat/nxp/s32/s32g/s32g2/include/s32g2_platform_def.h
+++ b/plat/nxp/s32/s32g/s32g2/include/s32g2_platform_def.h
@@ -9,6 +9,7 @@
 #include <s32g_platform_def.h>
 
 #define PLATFORM_CORE_COUNT		4
+#define PLATFORM_M7_CORE_COUNT		3
 #define PLAT_GICR_BASE			(S32GEN1_GIC_BASE + 0x80000)
 #define S32GEN1_GIC_SIZE		(0x100000)
 
diff --git a/plat/nxp/s32/s32g/s32g3/include/s32g3_platform_def.h b/plat/nxp/s32/s32g/s32g3/include/s32g3_platform_def.h
index 08d86b66a..9ae13163f 100644
--- a/plat/nxp/s32/s32g/s32g3/include/s32g3_platform_def.h
+++ b/plat/nxp/s32/s32g/s32g3/include/s32g3_platform_def.h
@@ -9,6 +9,7 @@
 #include <s32g_platform_def.h>
 
 #define PLATFORM_CORE_COUNT		8
+#define PLATFORM_M7_CORE_COUNT		4
 #define PLAT_GICR_BASE			(S32GEN1_GIC_BASE + 0x100000)
 #define S32GEN1_GIC_SIZE		(0x200000)
 
diff --git a/plat/nxp/s32/s32r/include/s32r_platform_def.h b/plat/nxp/s32/s32r/include/s32r_platform_def.h
index 8a72ffb79..f7a24e1c2 100644
--- a/plat/nxp/s32/s32r/include/s32r_platform_def.h
+++ b/plat/nxp/s32/s32r/include/s32r_platform_def.h
@@ -9,6 +9,7 @@
 #include <s32_platform_def.h>
 
 #define PLATFORM_CORE_COUNT		4
+#define PLATFORM_M7_CORE_COUNT		3
 #define PLAT_GICR_BASE			(S32GEN1_GIC_BASE + 0x80000)
 #define S32GEN1_GIC_SIZE		(0x100000)
 
-- 
2.17.1

