From 98eaeabf18ab5efa04fee667425e98aab8580c4a Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Tue, 4 Oct 2022 11:26:31 +0300
Subject: [PATCH 20/30] s32: Initialize multiple SCMI channels

Issue: ALB-9298
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32/include/s32_bl_common.h    |   2 +-
 plat/nxp/s32/include/s32_platform_def.h |   1 +
 plat/nxp/s32/s32_bl31.c                 |   2 +-
 plat/nxp/s32/s32_scp_scmi.c             | 116 +++++++++++++++++-------
 plat/nxp/s32/s32_svc.c                  |   3 +-
 5 files changed, 87 insertions(+), 37 deletions(-)

diff --git a/plat/nxp/s32/include/s32_bl_common.h b/plat/nxp/s32/include/s32_bl_common.h
index e6187cdf2..21ee6122d 100644
--- a/plat/nxp/s32/include/s32_bl_common.h
+++ b/plat/nxp/s32/include/s32_bl_common.h
@@ -54,7 +54,7 @@ bool is_last_core(void);
 bool is_cluster0_off(void);
 bool is_cluster1_off(void);
 void scp_scmi_init(void);
-void send_scmi_to_scp(uintptr_t scmi_mem);
+int send_scmi_to_scp(uintptr_t scmi_mem);
 
 struct s32_i2c_driver *s32_add_i2c_module(void *fdt, int fdt_node);
 
diff --git a/plat/nxp/s32/include/s32_platform_def.h b/plat/nxp/s32/include/s32_platform_def.h
index c88c77c5e..478a019c3 100644
--- a/plat/nxp/s32/include/s32_platform_def.h
+++ b/plat/nxp/s32/include/s32_platform_def.h
@@ -185,6 +185,7 @@
 
 #define SCMI_PAYLOAD_BASE	(0x34000000U)
 #define SCMI_PAYLOAD_SIZE	(128)
+#define SCMI_PAYLOAD_MAX_SIZE	(SCMI_PAYLOAD_SIZE * PLATFORM_CORE_COUNT)
 
 #endif /* S32_PLATFORM_H */
 
diff --git a/plat/nxp/s32/s32_bl31.c b/plat/nxp/s32/s32_bl31.c
index 9e7fb8e53..eba375a3c 100644
--- a/plat/nxp/s32/s32_bl31.c
+++ b/plat/nxp/s32/s32_bl31.c
@@ -95,7 +95,7 @@ static const mmap_region_t s32_mmap[] = {
 	MAP_REGION_FLAT(MSCM_BASE_ADDR, MMU_ROUND_UP_TO_4K(MSCM_SIZE),
 			MT_DEVICE | MT_RW),
 	MAP_REGION_FLAT(SCMI_PAYLOAD_BASE,
-			MMU_ROUND_UP_TO_PAGE(SCMI_PAYLOAD_SIZE),
+			MMU_ROUND_UP_TO_PAGE(SCMI_PAYLOAD_MAX_SIZE),
 			MT_NON_CACHEABLE | MT_RW | MT_SECURE),
 #if defined(MC_CGM6_BASE_ADDR)
 	MAP_REGION_FLAT(MC_CGM6_BASE_ADDR, MMU_ROUND_UP_TO_PAGE(MC_CGM6_SIZE),
diff --git a/plat/nxp/s32/s32_scp_scmi.c b/plat/nxp/s32/s32_scp_scmi.c
index 718a9606c..c63e4c716 100644
--- a/plat/nxp/s32/s32_scp_scmi.c
+++ b/plat/nxp/s32/s32_scp_scmi.c
@@ -8,30 +8,12 @@
 #include <drivers/arm/css/scmi.h>
 #include <arm/css/scmi/scmi_private.h>
 #include <lib/mmio.h>
+#include <platform.h>
+#include <libc/errno.h>
 
-DEFINE_BAKERY_LOCK(s32_scmi_lock);
-
-void mscm_ring_doorbell(struct scmi_channel_plat_info *plat_info);
-
-static scmi_channel_plat_info_t s32_scmi_plat_info = {
-	.scmi_mbx_mem = SCMI_PAYLOAD_BASE,
-	.db_reg_addr = MSCM_BASE_ADDR,
-	.db_preserve_mask = 0xfffffffe,
-	.db_modify_mask = 0x1,
-	.ring_doorbell = &mscm_ring_doorbell,
-};
-
-/*
- * The global handle for invoking the SCMI driver APIs after the driver
- * has been initialized.
- */
-static void *s32_scmi_handle;
-
-/* The SCMI channel global object */
-static scmi_channel_t channel = {
-	.info = &s32_scmi_plat_info,
-	.lock = &s32_scmi_lock,
-};
+static scmi_channel_t scmi_channels[PLATFORM_CORE_COUNT];
+static scmi_channel_plat_info_t s32_scmi_plat_info[PLATFORM_CORE_COUNT];
+DEFINE_BAKERY_LOCK(s32_scmi_locks[PLATFORM_CORE_COUNT]);
 
 void mscm_ring_doorbell(struct scmi_channel_plat_info *plat_info)
 {
@@ -45,31 +27,97 @@ void mscm_ring_doorbell(struct scmi_channel_plat_info *plat_info)
 	mmio_write_32(reg, 1);
 }
 
+static uintptr_t get_mb_addr(uint32_t core)
+{
+	return SCMI_PAYLOAD_BASE + core * SCMI_PAYLOAD_SIZE;
+}
+
 void scp_scmi_init(void)
 {
-	s32_scmi_handle = scmi_init(&channel);
-	if (s32_scmi_handle == NULL) {
-		ERROR("SCMI Initialization failed\n");
-		panic();
+	size_t i;
+
+	assert(ARRAY_SIZE(scmi_channels) == ARRAY_SIZE(s32_scmi_locks));
+	assert(ARRAY_SIZE(scmi_channels) == ARRAY_SIZE(s32_scmi_plat_info));
+
+	for (i = 0u; i < ARRAY_SIZE(scmi_channels); i++) {
+		s32_scmi_plat_info[i] = (scmi_channel_plat_info_t) {
+			.scmi_mbx_mem = get_mb_addr(i),
+			.db_reg_addr = MSCM_BASE_ADDR,
+			.db_preserve_mask = 0xfffffffe,
+			.db_modify_mask = 0x1,
+			.ring_doorbell = &mscm_ring_doorbell,
+		};
+
+		scmi_channels[i] = (scmi_channel_t) {
+			.info = &s32_scmi_plat_info[i],
+			.lock = &s32_scmi_locks[i],
+		};
+	}
+}
+
+static scmi_channel_t *get_scmi_channel(int *ch_id)
+{
+	int core = plat_core_pos_by_mpidr(read_mpidr());
+
+	if (core >= ARRAY_SIZE(scmi_channels)) {
+		ERROR("Failed to get SCMI channel for core %d\n",
+		      core);
+		return NULL;
 	}
+
+	*ch_id = core;
+	return &scmi_channels[core];
+}
+
+static size_t get_packet_size(uintptr_t scmi_packet)
+{
+	mailbox_mem_t *mbx_mem = (mailbox_mem_t *)scmi_packet;
+
+	return offsetof(mailbox_mem_t, msg_header) + mbx_mem->len;
 }
 
 static void copy_scmi_msg(uintptr_t to, uintptr_t from)
 {
 	size_t copy_len;
-	mailbox_mem_t *mbx_mem = (mailbox_mem_t *)from;
 
-	copy_len =  offsetof(mailbox_mem_t, msg_header) + mbx_mem->len;
+	copy_len = get_packet_size(from);
 	memcpy((void *)to, (const void *)from, copy_len);
 }
 
-void send_scmi_to_scp(uintptr_t scmi_mem)
+int send_scmi_to_scp(uintptr_t scmi_mem)
 {
-	scmi_channel_t *ch = &channel;
-	scmi_channel_plat_info_t *ch_info = ch->info;
-	mailbox_mem_t *mbx_mem = (mailbox_mem_t *)(ch_info->scmi_mbx_mem);
+	scmi_channel_plat_info_t *ch_info;
+	mailbox_mem_t *mbx_mem;
+	void *s32_scmi_handle;
+	int ch_id;
+	scmi_channel_t *ch = get_scmi_channel(&ch_id);
+
+	if (!ch)
+		return -EINVAL;
+
+	if (get_packet_size(scmi_mem) > SCMI_PAYLOAD_SIZE)
+		return -EINVAL;
+
+	if (!ch->is_initialized) {
+		s32_scmi_handle = scmi_init(ch);
+		if (s32_scmi_handle == NULL) {
+			ERROR("Failed to initialize SCMI channel for core %d\n",
+			      ch_id);
+			return -EINVAL;
+		}
+	}
+
+	ch_info = ch->info;
+	mbx_mem = (mailbox_mem_t *)(ch_info->scmi_mbx_mem);
+
+	while (!SCMI_IS_CHANNEL_FREE(mbx_mem->status))
+		;
 
 	/* Transfer request into SRAM mailbox */
+	if (ch_info->scmi_mbx_mem + get_packet_size(scmi_mem) >
+	    SCMI_PAYLOAD_BASE + SCMI_PAYLOAD_MAX_SIZE)
+		return -EINVAL;
+
 	copy_scmi_msg((uintptr_t)mbx_mem, scmi_mem);
 
 	SCMI_MARK_CHANNEL_FREE(mbx_mem->status);
@@ -90,4 +138,6 @@ void send_scmi_to_scp(uintptr_t scmi_mem)
 
 	/* Copy the result to agent's space */
 	copy_scmi_msg(scmi_mem, (uintptr_t)mbx_mem);
+
+	return 0;
 }
diff --git a/plat/nxp/s32/s32_svc.c b/plat/nxp/s32/s32_svc.c
index 958c5fdb7..2b325c81c 100644
--- a/plat/nxp/s32/s32_svc.c
+++ b/plat/nxp/s32/s32_svc.c
@@ -108,8 +108,7 @@ static int scmi_handler(uint32_t smc_fid, u_register_t x1,
 static int scp_scmi_handler(uint32_t smc_fid, u_register_t x1,
 			    u_register_t x2, u_register_t x3)
 {
-	send_scmi_to_scp(S32_SCMI_SHARED_MEM);
-	return 0;
+	return send_scmi_to_scp(S32_SCMI_SHARED_MEM);
 }
 
 uintptr_t s32_svc_smc_handler(uint32_t smc_fid,
-- 
2.17.1

