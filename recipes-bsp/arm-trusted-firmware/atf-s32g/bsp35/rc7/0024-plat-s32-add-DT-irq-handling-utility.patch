From d660324836041156fcdf28b9e5971d56a2b48013 Mon Sep 17 00:00:00 2001
From: Bogdan Roman <bogdan-gabriel.roman@nxp.com>
Date: Tue, 8 Nov 2022 10:09:22 +0200
Subject: [PATCH 24/49] plat: s32: add DT irq handling utility

Function 'fdt_get_irq_props_by_index' will return the number of an
interrupt based on its position in the 'interrupts' property. One could
get the index of the interrupt based on the position of its
corresponding name and then call 'fdt_get_irq_props_by_index' to get
the interrupt number.
It has a similar functionality to 'fdt_get_reg_props_by_index'.

Issue: ALB-8989
Upstream-Status: Pending 

Signed-off-by: Bogdan Roman <bogdan-gabriel.roman@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32/include/s32_dt.h |  4 +-
 plat/nxp/s32/s32_dt.c         | 80 +++++++++++++++++++++++++++++++++++
 2 files changed, 83 insertions(+), 1 deletion(-)

diff --git a/plat/nxp/s32/include/s32_dt.h b/plat/nxp/s32/include/s32_dt.h
index 22670390a..4e233acb5 100644
--- a/plat/nxp/s32/include/s32_dt.h
+++ b/plat/nxp/s32/include/s32_dt.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2017-2019, ARM Limited and Contributors. All rights reserved.
- * Copyright 2020-2021 NXP
+ * Copyright 2020-2022 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -24,5 +24,7 @@ int fdt_get_address(void **fdt_addr);
 uint8_t fdt_get_status(int node);
 void dt_fill_device_info(struct dt_node_info *info, int node);
 int dt_enable_clocks(void *fdt, int node);
+int fdt_get_irq_props_by_index(const void *dtb, int node,
+			       unsigned int index, int *irq_num);
 
 #endif
diff --git a/plat/nxp/s32/s32_dt.c b/plat/nxp/s32/s32_dt.c
index 404c4c9e7..9b24f788e 100644
--- a/plat/nxp/s32/s32_dt.c
+++ b/plat/nxp/s32/s32_dt.c
@@ -9,6 +9,7 @@
 #include <inttypes.h>
 #include <common/debug.h>
 #include <common/fdt_wrappers.h>
+#include <drivers/arm/gic_common.h>
 #include <errno.h>
 #include <libfdt.h>
 #include <platform_def.h>
@@ -122,3 +123,82 @@ void dt_fill_device_info(struct dt_node_info *info, int node)
 
 	info->status = fdt_get_status(node);
 }
+
+static int fdt_read_irq_cells(const fdt32_t *prop, int nr_cells)
+{
+	int it_num;
+	uint32_t res;
+
+	if (!prop || nr_cells < 2)
+		return -1;
+
+	res = fdt32_to_cpu(prop[1]);
+	if (res > MAX_SPI_ID)
+		return -1;
+
+	it_num = (int)res;
+
+	switch (fdt32_to_cpu(prop[0])) {
+	case 1:
+		it_num += 16;
+		break;
+	case 0:
+		it_num += 32;
+		break;
+	default:
+		it_num = -1;
+	}
+
+	return it_num;
+}
+
+int fdt_get_irq_props_by_index(const void *dtb, int node,
+			       unsigned int index, int *irq_num)
+{
+	const fdt32_t *prop;
+	int parent, len = 0;
+	uint32_t ic, cell, res;
+
+	parent = fdt_parent_offset(dtb, node);
+	if (parent < 0)
+		return -FDT_ERR_BADOFFSET;
+
+	prop = fdt_getprop(dtb, parent, "#interrupt-cells", NULL);
+	if (!prop) {
+		INFO("Couldn't find \"#interrupts-cells\" property in dtb\n");
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	ic = fdt32_to_cpu(*prop);
+	if (ic == 0)
+		return -FDT_ERR_BADVALUE;
+
+	if (index > UINT32_MAX / ic)
+		return -FDT_ERR_BADVALUE;
+	cell = index * ic;
+
+	prop = fdt_getprop(dtb, node, "interrupts", &len);
+	if (!prop) {
+		INFO("Couldn't find \"interrupts\" property in dtb\n");
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	if (cell > UINT32_MAX - ic)
+		return -FDT_ERR_BADVALUE;
+	res = cell + ic;
+
+	if (res > UINT32_MAX / sizeof(uint32_t))
+		return -FDT_ERR_BADVALUE;
+	res = res * sizeof(uint32_t);
+
+	if (res > (unsigned int)len)
+		return -FDT_ERR_BADVALUE;
+
+	if (irq_num) {
+		*irq_num = fdt_read_irq_cells(&prop[cell], ic);
+		if (*irq_num < 0)
+			return -FDT_ERR_BADVALUE;
+	}
+
+	return 0;
+}
-- 
2.25.1

