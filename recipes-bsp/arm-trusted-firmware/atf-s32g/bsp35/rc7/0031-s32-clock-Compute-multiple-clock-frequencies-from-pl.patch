From ac8c71b7c2c8f1c5aafffa9a81cab91e1768a4ed Mon Sep 17 00:00:00 2001
From: Andra-Teodora Ilie <andra.ilie@nxp.com>
Date: Fri, 7 Oct 2022 14:23:55 +0300
Subject: [PATCH 31/49] s32: clock: Compute multiple clock frequencies from pll
 module

For a given clock, go up to the first non-shared
divisor and compute possible clock rates. Given the
minimum and maximum allowed frequency, compute the
corresponding divisors, then evenly sample divisor
values within the resulting range.

Issue: ALB-8876
Upstream-Status: Pending 

Signed-off-by: Andra-Teodora Ilie <andra.ilie@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/nxp/s32/clk/enable_clk.c              |   2 +-
 drivers/nxp/s32/clk/get_rate.c                | 162 +++++++++++++++++-
 .../drivers/nxp/s32/clk/s32gen1_clk_funcs.h   |   1 +
 3 files changed, 163 insertions(+), 2 deletions(-)

diff --git a/drivers/nxp/s32/clk/enable_clk.c b/drivers/nxp/s32/clk/enable_clk.c
index 6ba61bfd3..b458c215d 100644
--- a/drivers/nxp/s32/clk/enable_clk.c
+++ b/drivers/nxp/s32/clk/enable_clk.c
@@ -1241,7 +1241,7 @@ static const get_parent_clb_t parents_clbs[] = {
 	[s32gen1_pll_out_div_t] = get_pll_div_parent,
 };
 
-static struct s32gen1_clk_obj *get_module_parent(struct s32gen1_clk_obj *module)
+struct s32gen1_clk_obj *get_module_parent(struct s32gen1_clk_obj *module)
 {
 	uint32_t index;
 
diff --git a/drivers/nxp/s32/clk/get_rate.c b/drivers/nxp/s32/clk/get_rate.c
index dcc362833..164de62c7 100644
--- a/drivers/nxp/s32/clk/get_rate.c
+++ b/drivers/nxp/s32/clk/get_rate.c
@@ -10,6 +10,33 @@
 #include <stdint.h>
 #include <inttypes.h>
 
+static inline bool is_div(struct s32gen1_clk_obj *module)
+{
+	if (!module)
+		return NULL;
+
+	return module->type == s32gen1_cgm_div_t ||
+			module->type == s32gen1_pll_out_div_t ||
+			module->type == s32gen1_dfs_div_t;
+}
+
+static uint32_t get_div_value(unsigned long pfreq, unsigned long freq)
+{
+	uint64_t div;
+
+	if (freq > pfreq)
+		return 0;
+
+	div = fp2u(fp_div(u2fp(pfreq), u2fp(freq))) - 1;
+
+	return div > UINT8_MAX ? UINT8_MAX : div;
+}
+
+static inline size_t get_available_slots(struct s32gen1_clk_rates *clk_rates)
+{
+	return S32GEN1_MAX_NUM_FREQ - 2;
+}
+
 static inline unsigned long get_clock_max_rate(struct s32gen1_clk_rates *clk_rates)
 {
 	size_t nrates = *clk_rates->nrates;
@@ -30,6 +57,93 @@ static inline unsigned long get_clock_min_rate(struct s32gen1_clk_rates *clk_rat
 	return clk_rates->rates[0];
 }
 
+static inline unsigned long compute_div_freq(unsigned long pfreq, uint32_t div)
+{
+	return fp2u(fp_div(u2fp(pfreq), u2fp(div + 1)));
+}
+
+static inline bool is_div_rate_valid(unsigned long pfreq, unsigned long freq, uint32_t div)
+{
+	return compute_div_freq(pfreq, div) == freq;
+}
+
+static int update_min_rate(struct s32gen1_clk_rates *clk_rates, unsigned long rate)
+{
+	size_t nrates = *clk_rates->nrates;
+
+	if (nrates > 1 && rate > clk_rates->rates[1])
+		return -EINVAL;
+
+	clk_rates->rates[0] = rate;
+
+	if (!nrates)
+		(*clk_rates->nrates)++;
+
+	return 0;
+}
+
+static int update_max_rate(struct s32gen1_clk_rates *clk_rates, unsigned long rate)
+{
+	size_t nrates = *clk_rates->nrates;
+
+	if (nrates > 1 && rate < clk_rates->rates[nrates - 2])
+		return -EINVAL;
+
+	if (!nrates)
+		nrates = ++(*clk_rates->nrates);
+
+	clk_rates->rates[nrates - 1] = rate;
+
+	return 0;
+}
+
+static int populate_scaler_rates(unsigned long pfreq, struct s32gen1_clk_rates *clk_rates)
+{
+	uint32_t div, div_min, div_max, range;
+	size_t i, num_slots;
+	unsigned long tmp_freq, min_freq, max_freq;
+	int ret = 0;
+
+	if (!clk_rates)
+		return -EINVAL;
+
+	min_freq = get_clock_min_rate(clk_rates);
+	max_freq = get_clock_max_rate(clk_rates);
+
+	div_min = get_div_value(pfreq, max_freq);
+	div_max = get_div_value(pfreq, min_freq);
+
+	if (!is_div_rate_valid(pfreq, min_freq, div_max)) {
+		ret = update_min_rate(clk_rates, compute_div_freq(pfreq, div_max));
+		if (ret)
+			return ret;
+	}
+
+	if (!is_div_rate_valid(pfreq, max_freq, div_min)) {
+		ret = update_max_rate(clk_rates, compute_div_freq(pfreq, div_min));
+		if (ret)
+			return ret;
+	}
+
+	range = div_max - div_min;
+	if (!range)
+		return ret;
+
+	num_slots = get_available_slots(clk_rates);
+	if (range <= num_slots)
+		num_slots = range - 1;
+
+	for (i = 1; i <= num_slots; i++) {
+		div = div_min + (i * range) / (num_slots + 1);
+		tmp_freq = compute_div_freq(pfreq, div);
+
+		if (add_clk_rate(clk_rates, tmp_freq))
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
 static unsigned long get_osc_freq(struct s32gen1_clk_obj *module,
 			  struct s32gen1_clk_priv *priv)
 {
@@ -250,6 +364,21 @@ static unsigned long get_pll_div_freq(struct s32gen1_clk_obj *module,
 	return fp2u(fp_div(u2fp(pfreq), u2fp(dc + 1)));
 }
 
+static int get_pll_div_freqs(struct s32gen1_clk_obj *module,
+			      struct s32gen1_clk_priv *priv, struct s32gen1_clk_rates *clk_rates)
+{
+	struct s32gen1_clk_obj *parent = get_module_parent(module);
+	unsigned long pfreq;
+
+	pfreq = get_module_rate(parent, priv);
+	if (!pfreq) {
+		ERROR("Failed to get the frequency of PLL div parent\n");
+		return -EINVAL;
+	}
+
+	return populate_scaler_rates(pfreq, clk_rates);
+}
+
 static unsigned long get_part_block_freq(struct s32gen1_clk_obj *module,
 				 struct s32gen1_clk_priv *priv)
 {
@@ -363,6 +492,34 @@ static struct s32gen1_clk *get_leaf_clk(struct clk *c)
 	return clk;
 }
 
+static int get_available_frequencies(struct s32gen1_clk_obj *module, struct s32gen1_clk_priv *priv,
+			struct s32gen1_clk_rates *clk_rates)
+{
+	if (!module)
+		return -EINVAL;
+
+	switch (module->type) {
+	case s32gen1_pll_out_div_t:
+		return get_pll_div_freqs(module, priv, clk_rates);
+	default:
+		return 0;
+	}
+}
+
+static int get_clk_frequencies(struct s32gen1_clk_obj *module,
+	struct s32gen1_clk_priv *priv, struct s32gen1_clk_rates *clk_rates)
+{
+	struct s32gen1_clk_obj *parent = get_module_parent(module);
+
+	if (!module)
+		return 0;
+
+	if (is_div(module) && module->refcount == 1)
+		return get_available_frequencies(module, priv, clk_rates);
+
+	return get_clk_frequencies(parent, priv, clk_rates);
+}
+
 unsigned long s32gen1_get_rate(struct clk *c)
 {
 	struct s32gen1_clk *clk;
@@ -421,6 +578,9 @@ int s32gen1_get_rates(struct clk *c, struct s32gen1_clk_rates *clk_rates)
 	if (add_clk_rate(clk_rates, max_rate))
 		return -EINVAL;
 
-	return 0;
+	if (min_rate == max_rate)
+		return 0;
+
+	return get_clk_frequencies(&clk->desc, priv, clk_rates);
 }
 
diff --git a/include/drivers/nxp/s32/clk/s32gen1_clk_funcs.h b/include/drivers/nxp/s32/clk/s32gen1_clk_funcs.h
index 3a1ba194a..529797b9c 100644
--- a/include/drivers/nxp/s32/clk/s32gen1_clk_funcs.h
+++ b/include/drivers/nxp/s32/clk/s32gen1_clk_funcs.h
@@ -13,6 +13,7 @@
 struct s32gen1_clk *get_clock(uint32_t id);
 struct s32gen1_clk *get_plat_clock(uint32_t id);
 struct s32gen1_clk *get_plat_cc_clock(uint32_t id);
+struct s32gen1_clk_obj *get_module_parent(struct s32gen1_clk_obj *module);
 unsigned long s32gen1_set_rate(struct clk *c, unsigned long rate);
 int s32gen1_set_parent(struct clk *c, struct clk *p);
 int s32gen1_enable(struct clk *c, int enable);
-- 
2.25.1

