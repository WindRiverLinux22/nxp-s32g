From 5b3d9f445a93bfc5165a145ef4c0487d5b9281e8 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Mon, 17 Oct 2022 15:02:10 +0300
Subject: [PATCH 14/49] s32cc: Move WFI loop into C implementation

Needed to simplify the code and avoid mirrored ASM implementation
for gicv3_cpuif_enable (s32g_gic_fixups_for_secondary)

Issue: ALB-9414
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32/s32_bl31.c          |  18 +++-
 plat/nxp/s32/s32_lowlevel_bl31.S | 154 -------------------------------
 plat/nxp/s32/s32_psci.c          | 107 +++++++++++++++------
 3 files changed, 94 insertions(+), 185 deletions(-)

diff --git a/plat/nxp/s32/s32_bl31.c b/plat/nxp/s32/s32_bl31.c
index 6d9275f50..ffe817170 100644
--- a/plat/nxp/s32/s32_bl31.c
+++ b/plat/nxp/s32/s32_bl31.c
@@ -372,16 +372,28 @@ static void s32_el3_mmu_fixup(void)
 
 void s32_gic_setup(void)
 {
+	unsigned int pos = plat_my_core_pos();
 	gicv3_driver_init(&s32_gic_data);
 	gicv3_distif_init();
-	gicv3_rdistif_init(plat_my_core_pos());
-	gicv3_cpuif_enable(plat_my_core_pos());
+	gicv3_rdistif_init(pos);
+	gicv3_cpuif_enable(pos);
+	update_core_state(pos, CPUIF_EN, CPUIF_EN);
 }
 
 void plat_gic_save(void)
 {
-	for (int i = 0; i < PLATFORM_CORE_COUNT; i++)
+	unsigned int i;
+
+	for (i = 0; i < PLATFORM_CORE_COUNT; i++) {
+		if (get_core_state(i, CPUIF_EN)) {
+			gicv3_cpuif_disable(i);
+			update_core_state(i, CPUIF_EN, 0);
+		}
+	}
+
+	for (i = 0; i < PLATFORM_CORE_COUNT; i++) {
 		gicv3_rdistif_save(i, &rdisif_ctxs[i]);
+	}
 
 	gicv3_distif_save(&dist_ctx);
 }
diff --git a/plat/nxp/s32/s32_lowlevel_bl31.S b/plat/nxp/s32/s32_lowlevel_bl31.S
index 4b44d087a..f1bd76587 100644
--- a/plat/nxp/s32/s32_lowlevel_bl31.S
+++ b/plat/nxp/s32/s32_lowlevel_bl31.S
@@ -28,126 +28,6 @@ func s32_smp_fixup
 endfunc s32_smp_fixup
 
 
-/* Clear GICR_WAKER[ProcessorSleep] bit.
- * Returns in x8 the base address of the current Redistributor.
- *
- * Clobber list: x7,x8,x9,x10,x11
- */
-func gicr_waker_wake
-	mov	x11, x30
-	mov	x7, x0
-	bl	plat_my_core_pos
-
-	/* Find offset of our Redistributor */
-	mov	x8, #PLAT_GICR_BASE
-dec:
-	cbz	x0, clear_ps
-	mov	x9, #2
-	add	x8, x8, x9, lsl #16
-	mov	x9, #1
-	sub	x0, x0, x9
-	b	dec
-clear_ps:
-	/* Clear the PS bit */
-	ldr	w9, [x8, #GICR_WAKER]
-	movz	w10, #1
-	mvn	w10, w10, lsl #WAKER_PS_SHIFT
-	and	w9, w9, w10
-	str	w9, [x8, #GICR_WAKER]
-	dsb	st
-	isb
-	/* Wait for hw confirmation */
-children_asleep:
-	ldr	w9, [x8, #GICR_WAKER]
-	tbnz	w9, #WAKER_CA_SHIFT, children_asleep
-
-	mov	x0, x7
-	mov	x30, x11
-	ret
-endfunc gicr_waker_wake
-
-
-/* GICR and GICC initializations for the secondary core.
- *
- * This is a close equivalent of gicv3_cpuif_enable() that we need to make
- * ourselves here, because:
- *   a) GICR_WAKER must be cleared before accessing most of the ICC_* regs;
- *   b) the ICC_* registers are not memory-mapped, so the primary core cannot
- *   do these initializations on our behalf.
- *
- * Clobber list: x7,x8,x9,x10,x11,x13
- */
-func s32g_gic_fixups_for_secondary
-	mov	x13, x30
-	bl	gicr_waker_wake
-
-	/* Clear any pending interrupts before we go into wfi */
-	mov	x7, #0x1
-	lsl	x7, x7, #16	/* #GICR_SGIBASE_OFFSET */
-	add	x7, x7, #0x280	/* partial offset of #GICR_ICPENDR0 */
-	mov	x9, xzr
-	mvn	x9, x9
-	str	w9, [x8, x7] /* x8 was set by gicr_waker_wake */
-	dsb	sy
-
-	/* SRE */
-	mrs	x8, ICC_SRE_EL3
-	orr	x8, x8, #0xf
-	msr	ICC_SRE_EL3, x8
-	isb
-
-	/* Switch to NS state to write non secure ICC_SRE_EL2 */
-	mrs	x8, SCR_EL3
-	orr	x8, x8, #SCR_NS_BIT
-	msr	SCR_EL3, x8
-	isb
-
-	mrs	x8, ICC_SRE_EL2
-	orr	x8, x8, #0xf
-	msr	ICC_SRE_EL2, x8
-	isb
-
-	/* Revert to secure state and set up more of SCR_EL3 */
-	mrs	x8, SCR_EL3
-	/* ...clear NS and possibly HCE */
-	mov	x9, #SCR_NS_BIT
-#if (S32_HAS_HV == 0)
-	orr	x9, x9, #SCR_HCE_BIT
-#endif
-	mvn	x9, x9
-	and	x8, x8, x9
-	msr	SCR_EL3, x8
-	isb
-
-	/* Write the secure ICC_SRE_EL1 register */
-	movz	x8, #0x1
-	msr	ICC_SRE_EL1, x8
-	isb
-
-	/* Set interrupt priority filter */
-	movz	x8, #0xff
-	msr	ICC_PMR_EL1, x8
-	isb
-
-	msr	ICC_CTLR_EL3, xzr
-	msr	ICC_CTLR_EL1, xzr
-
-	/* Enable Group 0 (must come after ICC_PMR_EL1) */
-	movz	x8, #0x1
-	msr	ICC_IGRPEN0_EL1, x8
-
-	/* Enable Group 1 Secure interrupts */
-	mrs x8, ICC_IGRPEN1_EL3
-	orr x8, x8, #0xf
-	msr ICC_IGRPEN1_EL3, x8
-
-	isb
-
-	mov	x30, x13
-	ret
-endfunc s32g_gic_fixups_for_secondary
-
-
 /* Wait until CSADSER[DVMSNPEN1<n>] becomes set, meaning that we're safe
  * to run with caches enabled on this cluster.
  *
@@ -179,7 +59,6 @@ caiu_loop:
 	ret
 endfunc wait_ncore_caiu_online
 
-
 func plat_secondary_cold_boot_setup
 	bl	reset_registers_for_lockstep
 	/* Reset all callee-saved registers for secondary boot as they are not
@@ -191,38 +70,6 @@ func plat_secondary_cold_boot_setup
 	mov x22, #0
 	mov x23, #0
 
-	bl	s32g_gic_fixups_for_secondary
-	bl	plat_my_core_pos
-	lsl	x0, x0, #2	/* array elements are of size 32-bit*/
-	ldr	x7, =s32_core_release_var
-wfi_pen:
-	dsb	sy
-	/* Invalidate cache before reading s32_core_release_var[my_core_pos];
-	 * Save x0, x1 first.
-	 */
-	mov	x9, x0
-	mov	x10, x1
-	add	x0, x7, x0
-	mov	x1, #4
-	bl	inv_dcache_range
-	mov	x0, x9
-	mov	x1, x10
-	/* index s32_core_release_var with current core id */
-	ldr	w8, [x7, x0]
-	cbnz	w8, wfi_done
-
-	/* Make sure interrupts are taken to EL3 before going into wfi */
-	mrs	x8, SCR_EL3
-	orr	x9, x8, #SCR_FIQ_BIT
-	orr	x9, x9, #SCR_IRQ_BIT
-	msr	SCR_EL3, x9
-	/* Wait for the primary core to finish GIC setup on my behalf */
-	wfi
-	/* Restore SCR_EL3 */
-	msr	SCR_EL3, x8
-
-	b	wfi_pen
-wfi_done:
 	/* Wait for the master core to perform additional initializations
 	 * such as ncore_init for my cluster
 	 */
@@ -233,4 +80,3 @@ wfi_done:
 	ldr	x7, [x7]
 	br	x7
 endfunc plat_secondary_cold_boot_setup
-
diff --git a/plat/nxp/s32/s32_psci.c b/plat/nxp/s32/s32_psci.c
index c3c031a5e..f469b8ff5 100644
--- a/plat/nxp/s32/s32_psci.c
+++ b/plat/nxp/s32/s32_psci.c
@@ -63,6 +63,9 @@ static int s32_pwr_domain_on(u_register_t mpidr)
 		if (is_a53_core_in_reset(pos)) {
 			s32_set_core_entrypoint(pos, core_start_addr);
 			s32_kick_secondary_ca53_core(pos);
+		} else {
+			update_core_state(pos, CPU_USE_WFI_FOR_SLEEP,
+					  CPU_USE_WFI_FOR_SLEEP);
 		}
 	}
 
@@ -70,16 +73,10 @@ static int s32_pwr_domain_on(u_register_t mpidr)
 	 * done by the secondaries, because the interface is not memory-mapped.
 	 */
 	gicv3_rdistif_init(pos);
-	/* GICR_IGROUPR0, GICR_IGRPMOD0 */
-	gicv3_set_interrupt_type(S32_SECONDARY_WAKE_SGI, pos, INTR_GROUP0);
-	/* GICR_ISENABLER0 */
-	assert(plat_ic_is_sgi(S32_SECONDARY_WAKE_SGI));
-	gicv3_enable_interrupt(S32_SECONDARY_WAKE_SGI, pos);
 
 	/* Kick the secondary core out of wfi */
-	NOTICE("S32 TF-A: %s: booting up core %d\n", __func__, pos);
-	update_core_state(pos, CPU_ON, CPU_ON);
-	plat_ic_raise_el3_sgi(S32_SECONDARY_WAKE_SGI, mpidr);
+	NOTICE("S32 TF-A: %s: booting up core %d (%u)\n", __func__, pos,
+	       get_core_state(pos, CPU_USE_WFI_FOR_SLEEP));
 
 	if (is_core_in_secondary_cluster(pos) &&
 	    !ncore_is_caiu_online(A53_CLUSTER1_CAIU))
@@ -89,39 +86,87 @@ static int s32_pwr_domain_on(u_register_t mpidr)
 	    !ncore_is_caiu_online(A53_CLUSTER0_CAIU))
 		ncore_caiu_online(A53_CLUSTER0_CAIU);
 
+	update_core_state(pos, CPU_ON, CPU_ON);
+
+	/* Wait GIC initialization */
+	while (get_core_state(pos, CPUIF_EN | CPU_ON) != (CPUIF_EN | CPU_ON));
+
+	/* Send an interrupt if the core is waiting in a WFI loop */
+	if (get_core_state(pos, CPU_USE_WFI_FOR_SLEEP)) {
+		plat_ic_raise_el3_sgi(S32_SECONDARY_WAKE_SGI, mpidr);
+	}
+
 	return PSCI_E_SUCCESS;
 }
 
-/** Executed by the woken (secondary) core after it exits the wfi holding pen
- *  during cold boot.
- */
-static void s32_pwr_domain_on_finish(const psci_power_state_t *target_state)
+static void sleep_wfi_loop(void)
 {
-	int pos;
+	u_register_t scr;
+	unsigned int pos = plat_my_core_pos();
 	unsigned int intid;
 
-	NOTICE("S32 TF-A: %s: cpu %d running\n", __func__, plat_my_core_pos());
+	/* GICR_IGROUPR0, GICR_IGRPMOD0 */
+	gicv3_set_interrupt_type(S32_SECONDARY_WAKE_SGI, pos, INTR_GROUP0);
+	/* GICR_ISENABLER0 */
+	assert(plat_ic_is_sgi(S32_SECONDARY_WAKE_SGI));
+	gicv3_enable_interrupt(S32_SECONDARY_WAKE_SGI, pos);
+
+	if (!get_core_state(pos, CPUIF_EN)) {
+		gicv3_cpuif_enable(pos);
+		update_core_state(pos, CPUIF_EN, CPUIF_EN);
+	}
 
-	/* Clear pending interrupt */
-	pos = plat_my_core_pos();
-	while ((intid = gicv3_get_pending_interrupt_id()) <= MAX_SPI_ID) {
-		gicv3_clear_interrupt_pending(intid, pos);
+	scr = read_scr_el3();
+
+	/* Make sure interrupts are taken to EL3 before going into wfi */
+	do {
+		write_scr_el3(scr | SCR_IRQ_BIT | SCR_FIQ_BIT);
+		isb();
+		dsb();
+		wfi();
+		write_scr_el3(scr);
+
+		/* Restore SCR_EL3 */
+		intid = gicv3_get_pending_interrupt_id();
+		if (intid < MAX_SPI_ID) {
+			/* Mark it as consumed */
+			gicv3_clear_interrupt_pending(intid, pos);
+		}
 
-		if (intid == S32_SECONDARY_WAKE_SGI)
+		if (is_core_enabled(pos) && intid == S32_SECONDARY_WAKE_SGI) {
 			break;
+		}
+	} while (true);
 
-		WARN("%s(): Interrupt %d found pending instead of the expected %d\n",
-		     __func__, intid, S32_SECONDARY_WAKE_SGI);
-	}
+	gicv3_disable_interrupt(S32_SECONDARY_WAKE_SGI, pos);
+}
 
-	write_scr_el3(read_scr_el3() & ~SCR_IRQ_BIT);
+/** Executed by the woken (secondary) core after it exits the wfi holding pen
+ *  during cold boot.
+ */
+static void s32_pwr_domain_on_finish(const psci_power_state_t *target_state)
+{
+	unsigned int pos = plat_my_core_pos();
+	NOTICE("S32 TF-A: %s: cpu %d running\n", __func__, pos);
+
+	update_core_state(pos, CPU_USE_WFI_FOR_SLEEP, 0);
+	if (!get_core_state(pos, CPUIF_EN)) {
+		gicv3_cpuif_enable(pos);
+		update_core_state(pos, CPUIF_EN, CPUIF_EN);
+	}
 }
+
 #if defined(PLAT_s32g2) || defined(PLAT_s32g3)
 static void s32g_pwr_domain_suspend_finish(
 					const psci_power_state_t *target_state)
 {
+	unsigned int pos = plat_my_core_pos();
+
 	NOTICE("S32G TF-A: %s\n", __func__);
-	gicv3_cpuif_enable(plat_my_core_pos());
+	plat_gic_restore();
+
+	gicv3_cpuif_enable(pos);
+	update_core_state(pos, CPUIF_EN | CPU_ON, CPUIF_EN | CPU_ON);
 }
 
 static void s32g_pwr_domain_suspend(const psci_power_state_t *target_state)
@@ -152,18 +197,23 @@ static void __dead2 s32_pwr_domain_pwr_down_wfi(
 					const psci_power_state_t *target_state)
 {
 	unsigned int pos = plat_my_core_pos();
+	bool last_core = is_last_core();
 	int ret;
 
 	NOTICE("S32 TF-A: %s: cpu = %u\n", __func__, pos);
 
-	if (!is_last_core()) {
-		update_core_state(pos, CPU_ON, 0);
+	/* Mark the core as offline */
+	update_core_state(pos, CPUIF_EN | CPU_ON, 0);
+	gicv3_cpuif_disable(pos);
 
-		if (is_cluster0_off())
+	if (!last_core) {
+		if (is_cluster0_off()) {
 			ncore_caiu_offline(A53_CLUSTER0_CAIU);
+		}
 
-		if (is_cluster1_off())
+		if (is_cluster1_off()) {
 			ncore_caiu_offline(A53_CLUSTER1_CAIU);
+		}
 
 		if (is_scp_used()) {
 			ret = scp_cpu_off(pos);
@@ -172,6 +222,7 @@ static void __dead2 s32_pwr_domain_pwr_down_wfi(
 				plat_panic_handler();
 			}
 		}
+		sleep_wfi_loop();
 		plat_secondary_cold_boot_setup();
 	}
 
-- 
2.25.1

