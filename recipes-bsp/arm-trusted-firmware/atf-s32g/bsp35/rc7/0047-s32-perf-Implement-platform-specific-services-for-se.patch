From 81e00199c2d196dbdb831237f377b529fec19767 Mon Sep 17 00:00:00 2001
From: Andra-Teodora Ilie <andra.ilie@nxp.com>
Date: Wed, 17 Aug 2022 14:15:27 +0300
Subject: [PATCH 47/49] s32: perf: Implement platform specific services for
 setting and getting performance limits

Issue: ALB-7158
Upstream-Status: Pending 

Signed-off-by: Andra-Teodora Ilie <andra.ilie@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/nxp/s32/perf/s32gen1_scmi_perf.c      | 30 +++++++++++-
 .../drivers/nxp/s32/clk/s32gen1_scmi_perf.h   |  2 +
 plat/nxp/s32/s32_scmi_perf.c                  | 47 ++++++++++++++++++-
 3 files changed, 77 insertions(+), 2 deletions(-)

diff --git a/drivers/nxp/s32/perf/s32gen1_scmi_perf.c b/drivers/nxp/s32/perf/s32gen1_scmi_perf.c
index 8d7103a21..c5ca41629 100644
--- a/drivers/nxp/s32/perf/s32gen1_scmi_perf.c
+++ b/drivers/nxp/s32/perf/s32gen1_scmi_perf.c
@@ -2,11 +2,13 @@
 /*
  * Copyright 2022 NXP
  */
+
+#include <clk/clk.h>
+#include <clk/s32gen1_scmi_clk.h>
 #include <clk/s32gen1_scmi_perf.h>
 #include <drivers/scmi.h>
 #include <drivers/scmi-msg.h>
 #include <dt-bindings/perf/s32gen1-scmi-perf.h>
-#include <drivers/scmi-msg.h>
 #include <lib/utils_def.h>
 #include <lib/spinlock.h>
 
@@ -143,3 +145,29 @@ int s32gen1_scmi_set_level(unsigned int agent_id, unsigned int clock_id, unsigne
 	return plat_scmi_clock_set_rate(agent_id, clock_id, rate);
 }
 
+unsigned int s32gen1_scmi_get_max_level(unsigned int domain_id, uint32_t clock_id)
+{
+	struct clk_driver *drv = get_clk_driver_by_name(S32GEN1_CLK_DRV_NAME);
+	struct clk clk;
+	unsigned long rate;
+
+	clk.drv = drv;
+	clk.id = clock_id;
+	rate = s32gen1_get_maxrate(&clk);
+
+	return find_perf_level_by_rate(domain_id, rate);
+}
+
+unsigned int s32gen1_scmi_get_min_level(unsigned int domain_id, uint32_t clock_id)
+{
+	struct clk_driver *drv = get_clk_driver_by_name(S32GEN1_CLK_DRV_NAME);
+	struct clk clk;
+	unsigned long rate;
+
+	clk.drv = drv;
+	clk.id = clock_id;
+	rate = s32gen1_get_minrate(&clk);
+
+	return find_perf_level_by_rate(domain_id, rate);
+}
+
diff --git a/include/drivers/nxp/s32/clk/s32gen1_scmi_perf.h b/include/drivers/nxp/s32/clk/s32gen1_scmi_perf.h
index 937b26091..2cf3c12b2 100644
--- a/include/drivers/nxp/s32/clk/s32gen1_scmi_perf.h
+++ b/include/drivers/nxp/s32/clk/s32gen1_scmi_perf.h
@@ -29,5 +29,7 @@ unsigned int s32gen1_scmi_get_level(unsigned int agent_id, unsigned int clock_id
 				unsigned int domain_id);
 int s32gen1_scmi_set_level(unsigned int agent_id, unsigned int clock_id,
 	unsigned int domain_id, unsigned int perf_level);
+unsigned int s32gen1_scmi_get_max_level(unsigned int domain_id, uint32_t clock_id);
+unsigned int s32gen1_scmi_get_min_level(unsigned int domain_id, uint32_t clock_id);
 
 #endif
diff --git a/plat/nxp/s32/s32_scmi_perf.c b/plat/nxp/s32/s32_scmi_perf.c
index a72636cfe..4a4fcfa16 100644
--- a/plat/nxp/s32/s32_scmi_perf.c
+++ b/plat/nxp/s32/s32_scmi_perf.c
@@ -25,7 +25,7 @@ struct perf_domain {
 { .clock_id = (ID), .name = (NAME), .attributes = (ATTR), \
 	.min_level = (MIN_LEVEL), .max_level = (MAX_LEVEL), }
 
-static const struct perf_domain domains[] = {
+static struct perf_domain domains[] = {
 	[S32GEN1_SCMI_PERF_A53] = PERF_DOMAIN(S32GEN1_SCMI_CLK_A53, "a53",
 		SCMI_PERF_SET_LIMITS | SCMI_PERF_SET_LEVEL,
 		S32GEN1_A53_MIN_LEVEL, S32GEN1_A53_MAX_LEVEL),
@@ -143,4 +143,49 @@ int32_t plat_scmi_perf_set_level(unsigned int agent_id __unused,
 	return s32gen1_scmi_set_level(agent_id, clock_id, domain_id, perf_level);
 }
 
+int32_t plat_scmi_perf_get_limits(unsigned int agent_id, unsigned int domain_id,
+				    unsigned int *range_max, unsigned int *range_min)
+{
+	if (domain_id >= ARRAY_SIZE(domains))
+		return SCMI_NOT_FOUND;
+
+	if (!range_max || !range_min)
+		return SCMI_INVALID_PARAMETERS;
+
+	*range_max = domains[domain_id].max_level;
+	*range_min = domains[domain_id].min_level;
+
+	return SCMI_SUCCESS;
+}
+
+int32_t plat_scmi_perf_set_limits(unsigned int agent_id, unsigned int domain_id,
+				    unsigned int range_max, unsigned int range_min)
+{
+	unsigned int max_level, min_level;
+
+	if (domain_id >= ARRAY_SIZE(domains))
+		return SCMI_NOT_FOUND;
+
+	if (!(domains[domain_id].attributes & SCMI_PERF_SET_LIMITS))
+		return SCMI_DENIED;
+
+	if (range_min > range_max)
+		return SCMI_INVALID_PARAMETERS;
+
+	if (range_min == domains[domain_id].min_level &&
+		range_max == domains[domain_id].max_level)
+		return SCMI_SUCCESS;
+
+	max_level = s32gen1_scmi_get_max_level(domain_id, domains[domain_id].clock_id);
+	min_level = s32gen1_scmi_get_min_level(domain_id, domains[domain_id].clock_id);
+
+	if (range_max > max_level ||
+			range_min < min_level)
+		return SCMI_OUT_OF_RANGE;
+
+	domains[domain_id].max_level = range_max;
+	domains[domain_id].min_level = range_min;
+
+	return SCMI_SUCCESS;
+}
 
-- 
2.25.1

