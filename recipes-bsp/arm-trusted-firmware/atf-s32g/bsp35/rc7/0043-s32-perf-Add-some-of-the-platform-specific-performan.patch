From 4d2ce4ad2990f32a065c0609239773bd50543c68 Mon Sep 17 00:00:00 2001
From: Andra-Teodora Ilie <andra.ilie@nxp.com>
Date: Wed, 24 Aug 2022 16:55:48 +0300
Subject: [PATCH 43/49] s32: perf: Add some of the platform specific
 performance domain management operations

Implement operations for retrieving the performance domains count, name
and attributes.

Issue: ALB-7158
Upstream-Status: Pending 

Signed-off-by: Andra-Teodora Ilie <andra.ilie@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 .../drivers/nxp/s32/clk/s32gen1_scmi_perf.h   | 19 +++++
 plat/nxp/s32/s32_scmi_perf.c                  | 83 +++++++++++++++++++
 2 files changed, 102 insertions(+)
 create mode 100644 include/drivers/nxp/s32/clk/s32gen1_scmi_perf.h
 create mode 100644 plat/nxp/s32/s32_scmi_perf.c

diff --git a/include/drivers/nxp/s32/clk/s32gen1_scmi_perf.h b/include/drivers/nxp/s32/clk/s32gen1_scmi_perf.h
new file mode 100644
index 000000000..89ff32eb0
--- /dev/null
+++ b/include/drivers/nxp/s32/clk/s32gen1_scmi_perf.h
@@ -0,0 +1,19 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+/*
+ * Copyright 2022 NXP
+ */
+#ifndef S32GEN1_SCMI_PERF_H
+#define S32GEN1_SCMI_PERF_H
+
+#include <stddef.h>
+#include <stdint.h>
+
+#define KHZ                    	(1000U)
+
+#define SCMI_PERF_SET_LIMITS   	BIT(31)
+#define SCMI_PERF_SET_LEVEL    	BIT(30)
+
+#define rate2khz(rate)			((rate) / KHZ)
+#define rate2level(rate)		((rate) - (rate) % KHZ)
+
+#endif
diff --git a/plat/nxp/s32/s32_scmi_perf.c b/plat/nxp/s32/s32_scmi_perf.c
new file mode 100644
index 000000000..0c86e4f4d
--- /dev/null
+++ b/plat/nxp/s32/s32_scmi_perf.c
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2022 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#include <cdefs.h>
+#include <clk/s32gen1_scmi_perf.h>
+#include <common/debug.h>
+#include <drivers/scmi-msg.h>
+#include <drivers/scmi.h>
+#include <lib/utils_def.h>
+
+#include <dt-bindings/clock/s32gen1-scmi-clock.h>
+#include <dt-bindings/perf/s32gen1-scmi-perf.h>
+
+struct perf_domain {
+	uint32_t clock_id;
+	uint32_t attributes;
+	const char *name;
+};
+
+#define PERF_DOMAIN(ID, NAME, ATTR) \
+{ .clock_id = (ID), .name = (NAME), .attributes = (ATTR)}
+
+static const struct perf_domain domains[] = {
+	[S32GEN1_SCMI_PERF_A53] = PERF_DOMAIN(S32GEN1_SCMI_CLK_A53, "a53",
+		SCMI_PERF_SET_LIMITS | SCMI_PERF_SET_LEVEL),
+};
+
+size_t plat_scmi_perf_domain_count(unsigned int agent_id __unused)
+{
+	return ARRAY_SIZE(domains);
+}
+
+const char *plat_scmi_perf_get_name(unsigned int agent_id __unused,
+				  unsigned int domain_id)
+{
+	if (domain_id >= ARRAY_SIZE(domains))
+		return NULL;
+
+	return domains[domain_id].name;
+}
+
+int32_t plat_scmi_perf_get_attributes(unsigned int agent_id __unused,
+					unsigned int domain_id)
+{
+	if (domain_id >= ARRAY_SIZE(domains))
+		return SCMI_NOT_FOUND;
+
+	return domains[domain_id].attributes;
+}
+
+unsigned int plat_scmi_perf_get_sustained_freq(unsigned int agent_id,
+					unsigned int domain_id)
+{
+	unsigned long rate;
+
+	if (domain_id >= ARRAY_SIZE(domains))
+		return 0;
+
+	rate = plat_scmi_clock_get_rate(agent_id, domains[domain_id].clock_id);
+	rate = rate2khz(rate);
+	if (rate > UINT32_MAX)
+		return 0;
+
+	return rate;
+}
+
+unsigned int plat_scmi_perf_get_sustained_perf_lvl(unsigned int agent_id,
+					unsigned int domain_id)
+{
+	unsigned long rate;
+
+	if (domain_id >= ARRAY_SIZE(domains))
+		return 0;
+
+	rate = plat_scmi_clock_get_rate(agent_id, domains[domain_id].clock_id);
+	if (rate > UINT32_MAX)
+		return 0;
+
+	return rate2level(rate);
+}
+
-- 
2.25.1

