From c8e7f64d5419cc427ab5399da2444a4652d2812f Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Mon, 17 Oct 2022 14:39:14 +0300
Subject: [PATCH 13/49] s32cc: Encode CPU state using a 32 bit value

The state of a core is encoded using 3 switches:
    - CPU_ON
        This is used to mark a core as online or offline
    - CPUIF_EN
        GICV3 CPU interface state (on/off)
    - CPU_USE_WFI_FOR_SLEEP
        Core hotplug method. 1 for WFI loop and 0 for reset state.

These are needed to simplify the hotplug procedure considering
that a core can either enter WFI loop or can be externally controlled
by a SCP.

Issue: ALB-9414
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32/include/s32_bl_common.h | 16 +++++-
 plat/nxp/s32/s32_bl31.c              | 82 ++++++++++++++++++++++++----
 plat/nxp/s32/s32_psci.c              |  4 +-
 plat/nxp/s32/s32g/s32g_bl31.c        |  2 +-
 plat/nxp/s32/s32r/s32r_bl31.c        |  2 +-
 5 files changed, 89 insertions(+), 17 deletions(-)

diff --git a/plat/nxp/s32/include/s32_bl_common.h b/plat/nxp/s32/include/s32_bl_common.h
index c1d290e87..55df74360 100644
--- a/plat/nxp/s32/include/s32_bl_common.h
+++ b/plat/nxp/s32/include/s32_bl_common.h
@@ -29,6 +29,18 @@
 				 (x) : \
 				 ((x) & ~PAGE_MASK) + PAGE_SIZE_4KB)
 
+/* Flags used to encode a cpu state */
+/* 1 - CPU is online, 0 - CPU is offline */
+#define CPU_ON			BIT(0)
+/* 1 - GIC3 cpuiif on, 0 - GIC3 cpuiif off_ */
+#define CPUIF_EN		BIT(1)
+/*
+ * CPU hot unplug method:
+ * 1 - the core will use WFI loop
+ * 0 - the core will enter in reset
+ */
+#define CPU_USE_WFI_FOR_SLEEP	BIT(2)
+
 struct s32_i2c_driver {
 	struct s32_i2c_bus bus;
 	int fdt_node;
@@ -49,7 +61,9 @@ void s32_gic_setup(void);
 void plat_gic_save(void);
 void plat_gic_restore(void);
 
-void update_core_state(uint32_t core, uint32_t state);
+void update_core_state(uint32_t core, uint32_t mask, uint32_t flag);
+bool is_core_enabled(uint32_t core);
+uint32_t get_core_state(uint32_t core, uint32_t mask);
 bool is_last_core(void);
 bool is_cluster0_off(void);
 bool is_cluster1_off(void);
diff --git a/plat/nxp/s32/s32_bl31.c b/plat/nxp/s32/s32_bl31.c
index bca517a01..6d9275f50 100644
--- a/plat/nxp/s32/s32_bl31.c
+++ b/plat/nxp/s32/s32_bl31.c
@@ -157,23 +157,67 @@ const gicv3_driver_data_t s32_gic_data = {
 };
 
 volatile uint32_t s32_core_release_var[PLATFORM_CORE_COUNT];
+DEFINE_BAKERY_LOCK(s32_core_state_lock);
 
-void update_core_state(uint32_t core, uint32_t state)
+void update_core_state(uint32_t core, uint32_t mask, uint32_t flag)
 {
-	s32_core_release_var[core] = state;
+	bakery_lock_get(&s32_core_state_lock);
+	inv_dcache_range((uintptr_t)s32_core_release_var,
+			 sizeof(s32_core_release_var));
+	s32_core_release_var[core] &= ~mask;
+	s32_core_release_var[core] |= flag;
 	flush_dcache_range((uintptr_t)&s32_core_release_var[core],
 			   sizeof(s32_core_release_var[core]));
+	bakery_lock_release(&s32_core_state_lock);
+}
+
+uint32_t get_core_state(uint32_t core, uint32_t mask)
+{
+	uint32_t status;
+
+	bakery_lock_get(&s32_core_state_lock);
+	inv_dcache_range((uintptr_t)s32_core_release_var,
+			 sizeof(s32_core_release_var));
+	status = s32_core_release_var[core] & mask;
+	bakery_lock_release(&s32_core_state_lock);
+
+	return status;
+}
+
+/**
+ * The caller must take 's32_core_state_lock'
+ * and invalidate the caches on 's32_core_release_var'.
+ */
+static bool is_cpu_on(uint32_t core)
+{
+	return !!(s32_core_release_var[core] & CPU_ON);
+}
+
+bool is_core_enabled(uint32_t core)
+{
+	bool status;
+
+	bakery_lock_get(&s32_core_state_lock);
+	inv_dcache_range((uintptr_t)s32_core_release_var,
+			 sizeof(s32_core_release_var));
+	status = is_cpu_on(core);
+	bakery_lock_release(&s32_core_state_lock);
+
+	return status;
 }
 
 bool is_last_core(void)
 {
 	size_t i, on = 0U;
 
+	bakery_lock_get(&s32_core_state_lock);
 	inv_dcache_range((uintptr_t)s32_core_release_var,
 			 sizeof(s32_core_release_var));
-	for (i = 0U; i < ARRAY_SIZE(s32_core_release_var); i++)
-		if (s32_core_release_var[i])
+	for (i = 0U; i < ARRAY_SIZE(s32_core_release_var); i++) {
+		if (is_cpu_on(i))
 			on++;
+	}
+	bakery_lock_release(&s32_core_state_lock);
 
 	return (on == 1);
 }
@@ -181,27 +225,41 @@ bool is_last_core(void)
 bool is_cluster0_off(void)
 {
 	size_t i;
+	bool off_status = true;
 
+	bakery_lock_get(&s32_core_state_lock);
 	inv_dcache_range((uintptr_t)s32_core_release_var,
 			 sizeof(s32_core_release_var));
-	for (i = 0U; i < PLATFORM_CORE_COUNT / 2; i++)
-		if (s32_core_release_var[i])
-			return false;
+	for (i = 0U; i < PLATFORM_CORE_COUNT / 2; i++) {
+		if (is_cpu_on(i))
+			off_status = false;
 
-	return true;
+		if (!off_status)
+			break;
+	}
+	bakery_lock_release(&s32_core_state_lock);
+
+	return off_status;
 }
 
 bool is_cluster1_off(void)
 {
 	size_t i;
+	bool off_status = true;
 
+	bakery_lock_get(&s32_core_state_lock);
 	inv_dcache_range((uintptr_t)s32_core_release_var,
 			 sizeof(s32_core_release_var));
-	for (i = PLATFORM_CORE_COUNT / 2; i < PLATFORM_CORE_COUNT; i++)
-		if (s32_core_release_var[i])
-			return false;
+	for (i = PLATFORM_CORE_COUNT / 2; i < PLATFORM_CORE_COUNT; i++) {
+
+		if (is_cpu_on(i)) {
+			off_status = false;
+			break;
+		}
+	}
+	bakery_lock_release(&s32_core_state_lock);
 
-	return true;
+	return off_status;
 }
 
 static uint32_t s32_get_spsr_for_bl33_entry(void)
diff --git a/plat/nxp/s32/s32_psci.c b/plat/nxp/s32/s32_psci.c
index 3a8f43e41..c3c031a5e 100644
--- a/plat/nxp/s32/s32_psci.c
+++ b/plat/nxp/s32/s32_psci.c
@@ -78,7 +78,7 @@ static int s32_pwr_domain_on(u_register_t mpidr)
 
 	/* Kick the secondary core out of wfi */
 	NOTICE("S32 TF-A: %s: booting up core %d\n", __func__, pos);
-	update_core_state(pos, 1);
+	update_core_state(pos, CPU_ON, CPU_ON);
 	plat_ic_raise_el3_sgi(S32_SECONDARY_WAKE_SGI, mpidr);
 
 	if (is_core_in_secondary_cluster(pos) &&
@@ -157,7 +157,7 @@ static void __dead2 s32_pwr_domain_pwr_down_wfi(
 	NOTICE("S32 TF-A: %s: cpu = %u\n", __func__, pos);
 
 	if (!is_last_core()) {
-		update_core_state(pos, 0);
+		update_core_state(pos, CPU_ON, 0);
 
 		if (is_cluster0_off())
 			ncore_caiu_offline(A53_CLUSTER0_CAIU);
diff --git a/plat/nxp/s32/s32g/s32g_bl31.c b/plat/nxp/s32/s32g/s32g_bl31.c
index a8f594310..d71a3bec6 100644
--- a/plat/nxp/s32/s32g/s32g_bl31.c
+++ b/plat/nxp/s32/s32g/s32g_bl31.c
@@ -119,7 +119,7 @@ void bl31_platform_setup(void)
 	dt_init_wkpu();
 	dt_init_ocotp();
 
-	update_core_state(plat_my_core_pos(), 1);
+	update_core_state(plat_my_core_pos(), CPU_ON, CPU_ON);
 	s32_gic_setup();
 
 	s32_enable_a53_clock();
diff --git a/plat/nxp/s32/s32r/s32r_bl31.c b/plat/nxp/s32/s32r/s32r_bl31.c
index 81f27242a..d0caf5b27 100644
--- a/plat/nxp/s32/s32r/s32r_bl31.c
+++ b/plat/nxp/s32/s32r/s32r_bl31.c
@@ -15,7 +15,7 @@ void bl31_platform_setup(void)
 {
 	generic_delay_timer_init();
 
-	update_core_state(plat_my_core_pos(), 1);
+	update_core_state(plat_my_core_pos(), CPU_ON, CPU_ON);
 	s32_gic_setup();
 
 	s32_enable_a53_clock();
-- 
2.25.1

