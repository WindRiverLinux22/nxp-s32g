From 1013b5609178889d220e71a8bb666a07b6414f78 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Tue, 7 Mar 2023 13:56:23 +0200
Subject: [PATCH 2/5] s32cc: Move DDR clock on FIRC before DDR deassert

The move of the DDR clock on FIRC is needed due to this note
from RM:

The PRST0_0[PERIPH_3_RST] reset must deassert when DDR_CLK is
selected as FIRC. DDR_CLK can be switched to functional
frequency after the reset deasserts.

Issue: ALB-9880
Upstream-Status: Pending

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/nxp/s32/clk/early_clocks.c   | 43 ++++++++++----
 drivers/nxp/s32/clk/enable_clk.c     | 41 +++++++++++++-
 fdts/s32cc.dtsi                      |  9 +++
 plat/nxp/s32/include/s32_bl2_el3.h   |  9 ++-
 plat/nxp/s32/include/s32_bl_common.h |  2 +-
 plat/nxp/s32/include/s32_clocks.h    |  4 +-
 plat/nxp/s32/s32_bl2_el3.c           | 40 +++++++++----
 plat/nxp/s32/s32_bl2_scp.c           | 57 +++++++++++++------
 plat/nxp/s32/s32_bl_common.c         |  6 +-
 plat/nxp/s32/s32g/s32g_bl2_el3.c     | 84 +++++++++++++++++++++-------
 plat/nxp/s32/s32r/s32r_bl2_el3.c     |  4 +-
 11 files changed, 227 insertions(+), 72 deletions(-)

diff --git a/drivers/nxp/s32/clk/early_clocks.c b/drivers/nxp/s32/clk/early_clocks.c
index c2c7a1200..2620d3037 100644
--- a/drivers/nxp/s32/clk/early_clocks.c
+++ b/drivers/nxp/s32/clk/early_clocks.c
@@ -237,7 +237,7 @@ static int enable_qspi_clock(void)
 	return s32gen1_enable(&qspi, 1);
 }
 
-int s32_enable_ddr_clock(void)
+static int s32gen1_set_ddr_clock_state(int enable)
 {
 	int ret;
 	unsigned long rate;
@@ -258,23 +258,47 @@ int s32_enable_ddr_clock(void)
 	if (rate != S32GEN1_DDR_FREQ)
 		return -EINVAL;
 
-	return s32gen1_enable(&ddr, 1);
+	return s32gen1_enable(&ddr, enable);
+}
+
+int s32_enable_ddr_clock(void)
+{
+	return s32gen1_set_ddr_clock_state(1);
+}
+
+static int s32gen1_disable_ddr_clock(void)
+{
+	return s32gen1_set_ddr_clock_state(0);
 }
 
 int s32_reset_ddr_periph(void)
 {
 	int ret;
 
-	ret = s32gen1_assert_rgm((uintptr_t)s32_priv.rgm, true,
-				 S32GEN1_DDR_RST);
-	if (ret)
+	/* Move the clock to FIRC */
+	ret = s32gen1_disable_ddr_clock();
+	if (ret) {
+		ERROR("Failed to turn off the DDR clock (%d)\n", ret);
 		return ret;
+	}
 
-	return s32gen1_assert_rgm((uintptr_t)s32_priv.rgm, false,
+	ret = s32gen1_assert_rgm((uintptr_t)s32_priv.rgm, false,
 				  S32GEN1_DDR_RST);
+	if (ret) {
+		ERROR("Failed to deassert DDR reset (%d)\n", ret);
+		return ret;
+	}
+
+	ret = s32_enable_ddr_clock();
+	if (ret) {
+		ERROR("Failed to enable the DDR clock (%d)\n", ret);
+		return ret;
+	}
+
+	return ret;
 }
 
-int s32_plat_clock_init(bool skip_ddr_clk)
+int s32_plat_clock_init(void)
 {
 	int ret;
 
@@ -304,8 +328,5 @@ int s32_plat_clock_init(bool skip_ddr_clk)
 			return ret;
 	}
 
-	if (!skip_ddr_clk)
-		return s32_enable_ddr_clock();
-
-	return 0;
+	return s32_enable_ddr_clock();
 }
diff --git a/drivers/nxp/s32/clk/enable_clk.c b/drivers/nxp/s32/clk/enable_clk.c
index 66f0428e2..6458f0b92 100644
--- a/drivers/nxp/s32/clk/enable_clk.c
+++ b/drivers/nxp/s32/clk/enable_clk.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: BSD-3-Clause
 /*
- * Copyright 2020-2022 NXP
+ * Copyright 2020-2023 NXP
  */
 #include <clk/mc_cgm_regs.h>
 #include <clk/mc_me_regs.h>
@@ -364,10 +364,41 @@ static int cgm_mux_clk_config(void *cgm_addr, uint32_t mux, uint32_t source)
 	return -EINVAL;
 }
 
+static int get_mux_osc_id(struct s32gen1_mux *mux, uint32_t *osc)
+{
+	uint8_t i;
+
+	*osc = mux->clkids[0];
+
+	for (i = 0; i < mux->nclks; i++) {
+		if (mux->clkids[i] == S32GEN1_CLK_FIRC) {
+			*osc = S32GEN1_CLK_FIRC;
+			break;
+		}
+
+		/**
+		 * Save the option and continue to look for FIRC,
+		 * as it is a better option
+		 */
+		if (mux->clkids[i] == S32GEN1_CLK_FXOSC)
+			*osc = S32GEN1_CLK_FXOSC;
+	}
+
+	if (*osc != S32GEN1_CLK_FIRC && *osc != S32GEN1_CLK_FXOSC) {
+		ERROR("MC_CGM mux %d does not have a valid safety clock\n",
+		       mux->module);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static int enable_cgm_mux(struct s32gen1_mux *mux,
 			  struct s32gen1_clk_priv *priv, int enable)
 {
 	void *module_addr;
+	uint32_t osc_sel;
+	int ret;
 
 	module_addr = get_base_addr(mux->module, priv);
 
@@ -381,8 +412,12 @@ static int enable_cgm_mux(struct s32gen1_mux *mux,
 		return cgm_mux_clk_config(module_addr, mux->index,
 					  mux->source_id);
 
-	/* Switch on FIRC */
-	return cgm_mux_clk_config(module_addr, mux->index, S32GEN1_CLK_FIRC);
+	/* Switch to a safe clock source in case of clock turn-off */
+	ret = get_mux_osc_id(mux, &osc_sel);
+	if (ret)
+		return ret;
+
+	return cgm_mux_clk_config(module_addr, mux->index, osc_sel);
 }
 
 static int enable_mux(struct s32gen1_clk_obj *module,
diff --git a/fdts/s32cc.dtsi b/fdts/s32cc.dtsi
index bc7f019a6..bff16ec03 100644
--- a/fdts/s32cc.dtsi
+++ b/fdts/s32cc.dtsi
@@ -479,6 +479,15 @@
 		ddrpll: ddrpll@40044000 {
 			compatible = "nxp,s32cc-ddrpll";
 			reg = <0x0 0x40044000 0x0 0x3000>;
+
+			assigned-clocks =
+				<&plat_clks S32GEN1_CLK_DDR_PLL_MUX>,
+				<&plat_clks S32GEN1_CLK_DDR_PLL_VCO>;
+			assigned-clock-parents =
+				<&plat_clks S32GEN1_CLK_FXOSC>;
+			assigned-clock-rates =
+				<0>,
+				<S32GEN1_DDR_PLL_VCO_FREQ>;
 		};
 
 		fxosc: fxosc@40050000 {
diff --git a/plat/nxp/s32/include/s32_bl2_el3.h b/plat/nxp/s32/include/s32_bl2_el3.h
index d5a5abc4e..ba15dda92 100644
--- a/plat/nxp/s32/include/s32_bl2_el3.h
+++ b/plat/nxp/s32/include/s32_bl2_el3.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2021-2022 NXP
+ * Copyright 2021-2023 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -9,6 +9,11 @@
 #include <common/desc_image_load.h>
 #include "s32_mc_rgm.h"
 
+struct s32_mmu_filter {
+	const uintptr_t *base_addrs;
+	size_t n_base_addrs;
+};
+
 int add_bl31_img_to_mem_params_descs(bl_mem_params_node_t *params,
 				     size_t *index, size_t size);
 int add_bl32_img_to_mem_params_descs(bl_mem_params_node_t *params,
@@ -20,7 +25,7 @@ int add_bl33_img_to_mem_params_descs(bl_mem_params_node_t *params,
 int add_invalid_img_to_mem_params_descs(bl_mem_params_node_t *params,
 					size_t *index, size_t size);
 
-int s32_el3_mmu_fixup(const uintptr_t *filters, size_t n_filters);
+int s32_el3_mmu_fixup(const struct s32_mmu_filter *filters, size_t n_filters);
 void clear_swt_faults(void);
 void clear_reset_cause(void);
 const char *get_reset_cause_str(enum reset_cause reset_cause);
diff --git a/plat/nxp/s32/include/s32_bl_common.h b/plat/nxp/s32/include/s32_bl_common.h
index fe91bc0eb..020f679f1 100644
--- a/plat/nxp/s32/include/s32_bl_common.h
+++ b/plat/nxp/s32/include/s32_bl_common.h
@@ -55,7 +55,7 @@ extern const unsigned int dtb_size;
 
 bool is_lockstep_enabled(void);
 
-void s32_early_plat_init(bool skip_ddr_clk);
+void s32_early_plat_init(void);
 
 void s32_gic_setup(void);
 void plat_gic_save(void);
diff --git a/plat/nxp/s32/include/s32_clocks.h b/plat/nxp/s32/include/s32_clocks.h
index 5eeac5331..3ab10e412 100644
--- a/plat/nxp/s32/include/s32_clocks.h
+++ b/plat/nxp/s32/include/s32_clocks.h
@@ -158,8 +158,8 @@ enum s32g_mc_cgm {
 #define SDHC_CLK_FREQ		(200 * 1000 * 1000)
 #define I2C_CLK_FREQ		(133 * 1000 * 1000)
 
-int s32_plat_clock_init(bool skip_ddr_clk);
-int s32_scp_plat_clock_init(bool skip_ddr_clk);
+int s32_plat_clock_init(void);
+int s32_scp_plat_clock_init(void);
 int s32_enable_ddr_clock(void);
 int s32_enable_a53_clock(void);
 int scp_reset_ddr_periph(void);
diff --git a/plat/nxp/s32/s32_bl2_el3.c b/plat/nxp/s32/s32_bl2_el3.c
index b7fdd7b06..f80b199b0 100644
--- a/plat/nxp/s32/s32_bl2_el3.c
+++ b/plat/nxp/s32/s32_bl2_el3.c
@@ -242,6 +242,14 @@ static mmap_region_t s32_mmap[] = {
 			MT_DEVICE | MT_RW),
 	MAP_REGION_FLAT(S32_MC_RGM_BASE_ADDR, S32_MC_RGM_SIZE,
 			MT_DEVICE | MT_RW),
+	MAP_REGION_FLAT(S32_MC_ME_BASE_ADDR, S32_MC_ME_SIZE,
+			MT_DEVICE | MT_RW),
+	MAP_REGION_FLAT(DRAM_PLL_BASE_ADDR,
+			MMU_ROUND_UP_TO_PAGE(DRAM_PLL_SIZE),
+			MT_DEVICE | MT_RW),
+	MAP_REGION_FLAT(S32_FXOSC_BASE_ADDR,
+			MMU_ROUND_UP_TO_PAGE(S32_FXOSC_SIZE),
+			MT_DEVICE | MT_RW),
 	MAP_REGION_FLAT(USDHC_BASE_ADDR, MMU_ROUND_UP_TO_PAGE(USDHC_SIZE),
 			MT_DEVICE | MT_RW),
 	MAP_REGION2(S32_BL32_BASE, S32_BL32_BASE,
@@ -321,20 +329,32 @@ static int disable_qspi_mmu_entry(void)
 	return 0;
 }
 
-static void filter_mmu_entries(const uintptr_t *filters, size_t n_filters)
+static bool filters_contain(uintptr_t base_addr,
+			    const struct s32_mmu_filter *filters,
+			    size_t n_filters)
 {
+	const struct s32_mmu_filter *filter;
 	size_t i, j;
-	bool used;
 
-	for (i = 0; i < ARRAY_SIZE(s32_mmap); i++) {
-		used = false;
-		for (j = 0; j < n_filters; j++) {
-			if (s32_mmap[i].base_pa == filters[j]) {
-				used = true;
-				break;
-			}
+	for (i = 0; i < n_filters; i++) {
+		filter = &filters[i];
+		for (j = 0; j < filter->n_base_addrs; j++) {
+			if (base_addr == filter->base_addrs[j])
+				return true;
 		}
+	}
 
+	return false;
+}
+
+static void filter_mmu_entries(const struct s32_mmu_filter *filters,
+			       size_t n_filters)
+{
+	size_t i;
+	bool used;
+
+	for (i = 0; i < ARRAY_SIZE(s32_mmap); i++) {
+		used = filters_contain(s32_mmap[i].base_pa, filters, n_filters);
 		if (!used)
 			s32_mmap[i].size = 0;
 	}
@@ -372,7 +392,7 @@ static void get_fip_images_ranges(uintptr_t *images_base, size_t *images_size)
 	*images_size = MMU_ROUND_UP_TO_PAGE(fip_end - *images_base);
 }
 
-int s32_el3_mmu_fixup(const uintptr_t *filters, size_t n_filters)
+int s32_el3_mmu_fixup(const struct s32_mmu_filter *filters, size_t n_filters)
 {
 	const unsigned long code_start = BL_CODE_BASE;
 	const unsigned long rw_start = BL2_RW_START;
diff --git a/plat/nxp/s32/s32_bl2_scp.c b/plat/nxp/s32/s32_bl2_scp.c
index e8b4e732f..13f39670a 100644
--- a/plat/nxp/s32/s32_bl2_scp.c
+++ b/plat/nxp/s32/s32_bl2_scp.c
@@ -64,7 +64,7 @@ static int scp_scmi_reset_set_state(uint32_t domain_id, bool assert)
 	return 0;
 }
 
-static int scp_scmi_clk_set_config_enable(unsigned int clock_index)
+static int scp_scmi_clk_set_config(unsigned int clock_index, bool enable)
 {
 	int ret;
 	unsigned int token = 0;
@@ -85,7 +85,11 @@ static int scp_scmi_clk_set_config_enable(unsigned int clock_index)
 
 	payload_args = (struct scmi_clock_config_set_a2p *)mbx_mem->payload;
 	payload_args->clock_id = clock_index;
-	payload_args->attributes = SCMI_CLOCK_CONFIG_SET_ENABLE_MASK;
+
+	if (enable)
+		payload_args->attributes = SCMI_CLOCK_CONFIG_SET_ENABLE_MASK;
+	else
+		payload_args->attributes = 0u;
 
 	ret = send_scmi_to_scp((uintptr_t)mbx_mem, sizeof(buffer));
 	if (ret)
@@ -95,13 +99,19 @@ static int scp_scmi_clk_set_config_enable(unsigned int clock_index)
 	payload_resp = (struct scmi_clock_config_set_p2a *)mbx_mem->payload;
 	ret = payload_resp->status;
 	if (ret != SCMI_E_SUCCESS) {
-		ERROR("Failed to enable clock %u\n", clock_index);
+		ERROR("Failed to %s clock %u\n", enable ? "enable" : "disable",
+		      clock_index);
 		return ret;
 	}
 
 	return 0;
 }
 
+static int scp_scmi_clk_set_config_enable(unsigned int clock_index)
+{
+	return scp_scmi_clk_set_config(clock_index, true);
+}
+
 static int scp_scmi_clk_set_rate(unsigned int clock_index, unsigned long rate)
 {
 	int ret;
@@ -143,7 +153,7 @@ static int scp_scmi_clk_set_rate(unsigned int clock_index, unsigned long rate)
 	return 0;
 }
 
-int scp_enable_a53_clock(void)
+static int scp_enable_a53_clock(void)
 {
 	struct siul2_freq_mapping early_freqs;
 	int ret;
@@ -156,7 +166,7 @@ int scp_enable_a53_clock(void)
 				    early_freqs.a53_freq);
 }
 
-int scp_enable_lin_clock(void)
+static int scp_enable_lin_clock(void)
 {
 	int ret;
 
@@ -167,7 +177,7 @@ int scp_enable_lin_clock(void)
 	return scp_scmi_clk_set_config_enable(S32GEN1_SCMI_CLK_LINFLEX_LIN);
 }
 
-int scp_enable_sdhc_clock(void)
+static int scp_enable_sdhc_clock(void)
 {
 	int ret;
 
@@ -186,7 +196,7 @@ int scp_enable_sdhc_clock(void)
 	return scp_scmi_clk_set_config_enable(S32GEN1_SCMI_CLK_USDHC_MOD32K);
 }
 
-int scp_enable_qspi_clock(void)
+static int scp_enable_qspi_clock(void)
 {
 	int ret;
 
@@ -205,22 +215,32 @@ int scp_enable_qspi_clock(void)
 	return scp_scmi_clk_set_config_enable(S32GEN1_SCMI_CLK_QSPI_AHB);
 }
 
-int scp_enable_ddr_clock(void)
+static int scp_set_ddr_clock_state(bool enable)
 {
 	int ret;
 
-	ret = scp_scmi_clk_set_config_enable(S32GEN1_SCMI_CLK_DDR_PLL_REF);
+	ret = scp_scmi_clk_set_config(S32GEN1_SCMI_CLK_DDR_PLL_REF, enable);
 	if (ret)
 		return ret;
 
-	ret = scp_scmi_clk_set_config_enable(S32GEN1_SCMI_CLK_DDR_AXI);
+	ret = scp_scmi_clk_set_config(S32GEN1_SCMI_CLK_DDR_AXI, enable);
 	if (ret)
 		return ret;
 
-	return scp_scmi_clk_set_config_enable(S32GEN1_SCMI_CLK_DDR_REG);
+	return scp_scmi_clk_set_config(S32GEN1_SCMI_CLK_DDR_REG, enable);
+}
+
+static int scp_enable_ddr_clock(void)
+{
+	return scp_set_ddr_clock_state(true);
 }
 
-int s32_scp_plat_clock_init(bool skip_ddr_clk)
+static int scp_disable_ddr_clock(void)
+{
+	return scp_set_ddr_clock_state(false);
+}
+
+int s32_scp_plat_clock_init(void)
 {
 	int ret;
 
@@ -243,19 +263,20 @@ int s32_scp_plat_clock_init(bool skip_ddr_clk)
 			return ret;
 	}
 
-	if (!skip_ddr_clk)
-		return scp_enable_ddr_clock();
-
-	return 0;
+	return scp_enable_ddr_clock();
 }
 
 int scp_reset_ddr_periph(void)
 {
 	int ret;
 
-	ret = scp_scmi_reset_set_state(S32GEN1_SCMI_RST_DDR, true);
+	ret = scp_disable_ddr_clock();
+	if (ret)
+		return ret;
+
+	ret = scp_scmi_reset_set_state(S32GEN1_SCMI_RST_DDR, false);
 	if (ret)
 		return ret;
 
-	return scp_scmi_reset_set_state(S32GEN1_SCMI_RST_DDR, false);
+	return scp_enable_ddr_clock();
 }
diff --git a/plat/nxp/s32/s32_bl_common.c b/plat/nxp/s32/s32_bl_common.c
index 824249082..90ba20aff 100644
--- a/plat/nxp/s32/s32_bl_common.c
+++ b/plat/nxp/s32/s32_bl_common.c
@@ -50,16 +50,16 @@ int reset_ddr_periph(void)
 	return ret;
 }
 
-void s32_early_plat_init(bool skip_ddr_clk)
+void s32_early_plat_init(void)
 {
 	uint32_t caiutc;
 
 	s32_plat_config_pinctrl();
 	if (!is_scp_used()) {
-		s32_plat_clock_init(skip_ddr_clk);
+		s32_plat_clock_init();
 	} else {
 		scp_scmi_init(false);
-		s32_scp_plat_clock_init(skip_ddr_clk);
+		s32_scp_plat_clock_init();
 	}
 	/* Restore (clear) the CAIUTC[IsolEn] bit for the primay cluster, which
 	 * we have manually set during early BL2 boot.
diff --git a/plat/nxp/s32/s32g/s32g_bl2_el3.c b/plat/nxp/s32/s32g/s32g_bl2_el3.c
index ba615984c..f28602959 100644
--- a/plat/nxp/s32/s32g/s32g_bl2_el3.c
+++ b/plat/nxp/s32/s32g/s32g_bl2_el3.c
@@ -88,40 +88,84 @@ static __unused void reset_rtc(void)
 	mmio_write_32(rtc + RTC_RTCS_OFFSET, rtcs);
 }
 
+static const uintptr_t used_ips_base[] = {
+	/* Linflex */
+	S32_UART_BASE,
+	/* Pinmuxing */
+	SIUL2_0_BASE_ADDR,
+	SIUL2_1_BASE_ADDR,
+	/* PMIC */
+	I2C4_BASE_ADDR,
+	OCOTP_BASE_ADDR,
+	/* DDR */
+	DDRSS_BASE_ADDR,
+	DDR_ERRATA_REGION_BASE,
+	S32G_SSRAM_BASE,
+	GPR_BASE_PAGE_ADDR,
+};
+
+static const uintptr_t clock_ips[] = {
+	MC_CGM5_BASE_ADDR,
+	S32_MC_RGM_BASE_ADDR,
+	S32_MC_ME_BASE_ADDR,
+	DRAM_PLL_BASE_ADDR,
+	S32_FXOSC_BASE_ADDR,
+};
+
+static const uintptr_t scp_used_ips[] = {
+	S32_SCP_SCMI_MEM,
+	MSCM_BASE_ADDR,
+};
+
+static const struct s32_mmu_filter non_scp_filters[] = {
+	{
+		.base_addrs = used_ips_base,
+		.n_base_addrs = ARRAY_SIZE(used_ips_base),
+	},
+	{
+		.base_addrs = clock_ips,
+		.n_base_addrs = ARRAY_SIZE(clock_ips),
+	},
+};
+
+static const struct s32_mmu_filter scp_filters[] = {
+	{
+		.base_addrs = used_ips_base,
+		.n_base_addrs = ARRAY_SIZE(used_ips_base),
+	},
+	{
+		.base_addrs = scp_used_ips,
+		.n_base_addrs = ARRAY_SIZE(scp_used_ips),
+	},
+};
+
 static void resume_bl31(struct s32g_ssram_mailbox *ssram_mb)
 {
 #if S32CC_EMU == 0
 	s32g_warm_entrypoint_t resume_entrypoint;
+	const struct s32_mmu_filter *mmu_filters;
+	size_t n_mmu_filters;
 	uintptr_t csr_addr;
-	static const uintptr_t used_ips_base[] = {
-		/* Linflex */
-		S32_UART_BASE,
-		/* Pinmuxing */
-		SIUL2_0_BASE_ADDR,
-		SIUL2_1_BASE_ADDR,
-		/* PMIC */
-		I2C4_BASE_ADDR,
-		OCOTP_BASE_ADDR,
-		/* DDR */
-		DDRSS_BASE_ADDR,
-		DDR_ERRATA_REGION_BASE,
-		S32G_SSRAM_BASE,
-		GPR_BASE_PAGE_ADDR,
-		MC_CGM5_BASE_ADDR,
-		S32_MC_RGM_BASE_ADDR,
-	};
 
 	resume_entrypoint = ssram_mb->bl31_warm_entrypoint;
 	csr_addr = (uintptr_t)&ssram_mb->csr_settings[0];
 
 	reset_rtc();
 
+	if (is_scp_used()) {
+		mmu_filters = &scp_filters[0];
+		n_mmu_filters = ARRAY_SIZE(scp_filters);
+	} else {
+		mmu_filters = &non_scp_filters[0];
+		n_mmu_filters = ARRAY_SIZE(non_scp_filters);
+	}
+
 	/*
 	 * Configure MMU & caches for a short period of time needed to boost
 	 * the DTB parsing and DDR reconfig.
 	 */
-	if (s32_el3_mmu_fixup(&used_ips_base[0], ARRAY_SIZE(used_ips_base))) {
-		ERROR("Failed to configure ");
+	if (s32_el3_mmu_fixup(mmu_filters, n_mmu_filters)) {
+		ERROR("Failed to configure MMU");
 		panic();
 	}
 
@@ -159,7 +203,7 @@ void bl2_el3_early_platform_setup(u_register_t arg0, u_register_t arg1,
 	reset_cause = get_reset_cause();
 	clear_reset_cause();
 
-	s32_early_plat_init(false);
+	s32_early_plat_init();
 	console_s32_register();
 
 #ifdef HSE_SUPPORT
diff --git a/plat/nxp/s32/s32r/s32r_bl2_el3.c b/plat/nxp/s32/s32r/s32r_bl2_el3.c
index c7775b365..8f32bb973 100644
--- a/plat/nxp/s32/s32r/s32r_bl2_el3.c
+++ b/plat/nxp/s32/s32r/s32r_bl2_el3.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2021-2022 NXP
+ * Copyright 2021-2023 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -49,7 +49,7 @@ void bl2_el3_early_platform_setup(u_register_t arg0, u_register_t arg1,
 	reset_cause = get_reset_cause();
 	clear_reset_cause();
 
-	s32_early_plat_init(false);
+	s32_early_plat_init();
 	console_s32_register();
 	s32_io_setup();
 
-- 
2.25.1

