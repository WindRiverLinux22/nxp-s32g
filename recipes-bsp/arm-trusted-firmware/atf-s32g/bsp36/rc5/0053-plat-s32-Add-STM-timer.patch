From 65d469447561923dffb162bc71d17df581f55cae Mon Sep 17 00:00:00 2001
From: Andra-Teodora Ilie <andra.ilie@nxp.com>
Date: Thu, 16 Feb 2023 19:29:50 +0200
Subject: [PATCH 53/54] plat: s32: Add STM timer

STM timer is used for timestamping SCMI messages.

Issue: ALB-9436
Upstream-Status: Pending 

Signed-off-by: Andra-Teodora Ilie <andra.ilie@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/nxp/s32/stm/s32_stm.c                 | 88 +++++++++++++++++++
 fdts/s32cc.dtsi                               |  6 ++
 include/drivers/nxp/s32/stm/s32_stm.h         | 24 +++++
 plat/nxp/s32/include/s32_platform_def.h       |  5 ++
 plat/nxp/s32/s32_bl2_el3.c                    |  4 +
 plat/nxp/s32/s32_bl31.c                       |  4 +
 plat/nxp/s32/s32_common.mk                    |  1 +
 plat/nxp/s32/s32r/include/s32r_platform_def.h |  2 +-
 8 files changed, 133 insertions(+), 1 deletion(-)
 create mode 100644 drivers/nxp/s32/stm/s32_stm.c
 create mode 100644 include/drivers/nxp/s32/stm/s32_stm.h

diff --git a/drivers/nxp/s32/stm/s32_stm.c b/drivers/nxp/s32/stm/s32_stm.c
new file mode 100644
index 000000000..32ca9aebe
--- /dev/null
+++ b/drivers/nxp/s32/stm/s32_stm.c
@@ -0,0 +1,88 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright 2023 NXP
+ */
+
+#include <stdint.h>
+#include <common/debug.h>
+#include <common/fdt_wrappers.h>
+#include <drivers/nxp/s32/stm/s32_stm.h>
+#include <lib/libc/errno.h>
+#include <lib/mmio.h>
+#include <libfdt.h>
+#include <s32_dt.h>
+
+#define STM_CR				0x00
+#define STM_CNT				0x04
+
+#define STM_CR_TEN			BIT_32(0)
+#define STM_CR_FRZ			BIT_32(1)
+#define STM_CR_CPS_MASK     GENMASK(15, 8)
+#define STM_CR_CPS_OFFSET   (8u)
+#define STM_CR_CPS(X)       ((X) << STM_CR_CPS_OFFSET)
+#define STM_CNT_VAL         (0)
+
+static int s32_stm_get_setup_from_fdt(void *fdt, int node, struct s32_stm *stm)
+{
+	int ret;
+
+	ret = fdt_get_reg_props_by_index(fdt, node, 0, &stm->base, NULL);
+	if (ret) {
+		ERROR("Invalid STM base address\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int s32_stm_init(struct s32_stm *stm)
+{
+	void *fdt = NULL;
+	int stm_node;
+	int ret;
+
+	if (dt_open_and_check() < 0)
+		return -EINVAL;
+
+	if (fdt_get_address(&fdt) == 0)
+		return -EINVAL;
+
+	stm_node = fdt_node_offset_by_compatible(fdt, -1, "nxp,s32cc-stm-global");
+	if (stm_node == -1)
+		return -ENODEV;
+
+	ret = s32_stm_get_setup_from_fdt(fdt, stm_node, stm);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+bool s32_stm_is_enabled(struct s32_stm *stm)
+{
+	uint32_t cr = mmio_read_32(stm->base + STM_CR);
+
+	return !!(cr & STM_CR_TEN);
+}
+
+void s32_stm_enable(struct s32_stm *stm, bool enable)
+{
+	uint32_t cr = 0;
+
+	if (enable) {
+		mmio_write_32(stm->base + STM_CNT, STM_CNT_VAL);
+		cr |= STM_CR_FRZ;
+		cr |= STM_CR_TEN;
+		cr |= STM_CR_CPS(0) & STM_CR_CPS_MASK;
+		mmio_write_32(stm->base + STM_CR, cr);
+	} else {
+		cr = mmio_read_32(stm->base + STM_CR);
+		cr &= ~STM_CR_TEN;
+		mmio_write_32(stm->base + STM_CR, cr);
+	}
+}
+
+uint32_t s32_stm_get_count(struct s32_stm *stm)
+{
+	return mmio_read_32(stm->base + STM_CNT);
+}
diff --git a/fdts/s32cc.dtsi b/fdts/s32cc.dtsi
index cc69d8b43..bc7f019a6 100644
--- a/fdts/s32cc.dtsi
+++ b/fdts/s32cc.dtsi
@@ -705,6 +705,12 @@
 			status = "okay";
 		};
 
+		stm6: timer@40224000 {
+			compatible = "nxp,s32cc-stm-global";
+			reg = <0x0 0x40224000 0x0 0x3000>;
+			status = "okay";
+		};
+
 		pit1: pit@40288000 {
 			compatible = "nxp,s32cc-pit";
 			reg = <0x0 0x40288000 0x0 0x3000>;
diff --git a/include/drivers/nxp/s32/stm/s32_stm.h b/include/drivers/nxp/s32/stm/s32_stm.h
new file mode 100644
index 000000000..50a77efc3
--- /dev/null
+++ b/include/drivers/nxp/s32/stm/s32_stm.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2023 NXP
+ *
+ * S32 System Timer Module
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef S32_STM_H
+#define S32_STM_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+struct s32_stm {
+	uintptr_t base;
+};
+
+int s32_stm_init(struct s32_stm *driver);
+bool s32_stm_is_enabled(struct s32_stm *stm);
+void s32_stm_enable(struct s32_stm *stm, bool enable);
+uint32_t s32_stm_get_count(struct s32_stm *stm);
+
+#endif /* S32_STM_H */
diff --git a/plat/nxp/s32/include/s32_platform_def.h b/plat/nxp/s32/include/s32_platform_def.h
index 8044e51df..cb3b32457 100644
--- a/plat/nxp/s32/include/s32_platform_def.h
+++ b/plat/nxp/s32/include/s32_platform_def.h
@@ -185,6 +185,11 @@
 #define MSCM_BASE_ADDR		(0x40198000U)
 #define MSCM_SIZE		(0xfa0u)
 
+#if (SCMI_LOGGER == 1)
+#define STM6_BASE_ADDR          (0x40224000UL)
+#define STM6_SIZE               (0X3000)
+#endif
+
 /**
  * Memory map used for SCP SCMI communication:
  *
diff --git a/plat/nxp/s32/s32_bl2_el3.c b/plat/nxp/s32/s32_bl2_el3.c
index fc5cd17c4..b7fdd7b06 100644
--- a/plat/nxp/s32/s32_bl2_el3.c
+++ b/plat/nxp/s32/s32_bl2_el3.c
@@ -262,6 +262,10 @@ static mmap_region_t s32_mmap[] = {
 	MAP_REGION_FLAT(S32_SCP_SCMI_MEM,
 			MMU_ROUND_UP_TO_PAGE(S32_SCP_SCMI_MEM_SIZE),
 			MT_NON_CACHEABLE | MT_RW | MT_SECURE),
+#if defined(STM6_BASE_ADDR)
+	MAP_REGION_FLAT(STM6_BASE_ADDR, MMU_ROUND_UP_TO_PAGE(STM6_SIZE),
+			MT_DEVICE | MT_RW),
+#endif
 #if (ERRATA_S32_050543 == 1)
 	MAP_REGION_FLAT(DDR_ERRATA_REGION_BASE, DDR_ERRATA_REGION_SIZE,
 			MT_NON_CACHEABLE | MT_RW),
diff --git a/plat/nxp/s32/s32_bl31.c b/plat/nxp/s32/s32_bl31.c
index 860a7135e..4bcfb3467 100644
--- a/plat/nxp/s32/s32_bl31.c
+++ b/plat/nxp/s32/s32_bl31.c
@@ -108,6 +108,10 @@ static const mmap_region_t s32_mmap[] = {
 	MAP_REGION_FLAT(S32_SCP_SCMI_MEM,
 			MMU_ROUND_UP_TO_PAGE(S32_SCP_SCMI_MEM_SIZE),
 			MT_NON_CACHEABLE | MT_RW | MT_SECURE),
+#if defined(STM6_BASE_ADDR)
+	MAP_REGION_FLAT(STM6_BASE_ADDR, MMU_ROUND_UP_TO_PAGE(STM6_SIZE),
+			MT_DEVICE | MT_RW),
+#endif
 #if defined(MC_CGM6_BASE_ADDR)
 	MAP_REGION_FLAT(MC_CGM6_BASE_ADDR, MMU_ROUND_UP_TO_PAGE(MC_CGM6_SIZE),
 			MT_DEVICE | MT_RW),
diff --git a/plat/nxp/s32/s32_common.mk b/plat/nxp/s32/s32_common.mk
index 72b8295e2..da77ab97f 100644
--- a/plat/nxp/s32/s32_common.mk
+++ b/plat/nxp/s32/s32_common.mk
@@ -85,6 +85,7 @@ PLAT_BL_COMMON_SOURCES += \
 			${S32_DRIVERS}/clk/s32gen1_clk.c \
 			${S32_DRIVERS}/rst/s32gen1_rst.c \
 			${S32_DRIVERS}/clk/set_par_rate.c \
+			${S32_DRIVERS}/stm/s32_stm.c \
 			${S32_DRIVERS}/i2c/s32_i2c.c \
 			${BOOT_INFO_SRC} \
 
diff --git a/plat/nxp/s32/s32r/include/s32r_platform_def.h b/plat/nxp/s32/s32r/include/s32r_platform_def.h
index b845e7b66..efb1c3599 100644
--- a/plat/nxp/s32/s32r/include/s32r_platform_def.h
+++ b/plat/nxp/s32/s32r/include/s32r_platform_def.h
@@ -21,7 +21,7 @@
 #define S32_MPIDR_CPU_MASK		0x1
 #define S32_MPIDR_CPU_MASK_BITS	0x1
 
-#define MAX_MMAP_REGIONS		31
+#define MAX_MMAP_REGIONS		32
 #define MAX_XLAT_TABLES			25
 
 #if defined IMAGE_BL33
-- 
2.25.1

