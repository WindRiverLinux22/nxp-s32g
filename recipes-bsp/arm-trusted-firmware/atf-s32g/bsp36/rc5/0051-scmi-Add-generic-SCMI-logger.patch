From 902796f4cce0be52c5db2f0430ac917875b2378a Mon Sep 17 00:00:00 2001
From: Andra-Teodora Ilie <andra.ilie@nxp.com>
Date: Wed, 15 Feb 2023 11:05:17 +0200
Subject: [PATCH 51/54] scmi: Add generic SCMI logger

It saves general information about the SCMI messages sent
and the corresponding responses. It is the platform's
responsibility to allocate the necessary log entries.
The logger can be enabled using SCMI_LOGGER compile
time define.

Issue: ALB-9436
Upstream-Status: Pending 

Signed-off-by: Andra-Teodora Ilie <andra.ilie@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/arm/css/scmi/scmi_common.c         |   7 +
 drivers/arm/css/scmi/scmi_logger.c         | 258 +++++++++++++++++++++
 drivers/arm/css/scmi/scmi_logger.h         |  21 ++
 drivers/arm/css/scmi/scmi_logger_private.h |  55 +++++
 drivers/arm/css/scmi/scmi_private.h        |   1 +
 5 files changed, 342 insertions(+)
 create mode 100644 drivers/arm/css/scmi/scmi_logger.c
 create mode 100644 drivers/arm/css/scmi/scmi_logger.h
 create mode 100644 drivers/arm/css/scmi/scmi_logger_private.h

diff --git a/drivers/arm/css/scmi/scmi_common.c b/drivers/arm/css/scmi/scmi_common.c
index 57249fa35..eaa2cdf9e 100644
--- a/drivers/arm/css/scmi/scmi_common.c
+++ b/drivers/arm/css/scmi/scmi_common.c
@@ -11,6 +11,7 @@
 #include <drivers/arm/css/scmi.h>
 
 #include "scmi_private.h"
+#include "scmi_logger.h"
 
 #if HW_ASSISTED_COHERENCY
 #define scmi_lock_init(lock)
@@ -105,6 +106,9 @@ void scmi_send_sync_command(scmi_channel_t *ch)
 	if (DEBUG)
 		set_channel_poison(ch);
 
+	if (SCMI_LOGGER)
+		log_scmi_req(mbx_mem, ch->info->scmi_md_mem);
+
 	SCMI_MARK_CHANNEL_BUSY(mbx_mem->status);
 
 	/*
@@ -135,6 +139,9 @@ void scmi_send_sync_command(scmi_channel_t *ch)
 	assert(!is_message_too_big(ch));
 	if (DEBUG)
 		assert(check_poison(ch));
+
+	if (SCMI_LOGGER)
+		log_scmi_rsp(mbx_mem, ch->info->scmi_md_mem);
 }
 
 /*
diff --git a/drivers/arm/css/scmi/scmi_logger.c b/drivers/arm/css/scmi/scmi_logger.c
new file mode 100644
index 000000000..2ae8bc0a6
--- /dev/null
+++ b/drivers/arm/css/scmi/scmi_logger.c
@@ -0,0 +1,258 @@
+/*
+ * Copyright 2023 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#include <assert.h>
+#include <common/debug.h>
+#include <lib/utils_def.h>
+#include <plat/common/platform.h>
+#include <scmi-msg/common.h>
+#include "scmi_logger.h"
+#include "scmi_logger_private.h"
+
+enum scmi_msg_type {
+	SCMI_REQ,
+	SCMI_RSP
+};
+
+/* Platform specific logger init operation */
+#pragma weak log_scmi_plat_init
+int log_scmi_plat_init(struct scmi_logger *logger)
+{
+	return 0;
+}
+
+static struct scmi_logger logger;
+static struct scmi_log_entry *crt_msg[PLATFORM_CORE_COUNT];
+
+/**
+ * Each bit in the array represents the state of an SCMI
+ * logger entry, as follows:
+ *  - 0 = entry is free
+ *  - 1 = entry is busy
+ * Given a logger entry at index i, the position of the
+ * corresponding bit in the array is computed as:
+ *  index_of_slot_in_array = i / BITS_PER_SLOT
+ *  index_of_bit_in_slot = i % BITS_PER_SLOT
+ */
+static entry_state_t entry_state[SCMI_LOG_SLOTS_NUM];
+/**
+ * Used for masking the bits in the last slot that are
+ * not actually available (when SCMI_LOG_MAX_LEN is not
+ * divisbile by BITS_PER_SLOT).
+ */
+static entry_state_t slot_mask;
+
+/* Helper function for checking and setting an entry's state */
+static inline bool is_logger_empty(void)
+{
+	return logger.index == -1;
+}
+
+static uint32_t get_slot(uint32_t pos)
+{
+	assert(pos < SCMI_LOG_MAX_LEN);
+	return pos / BITS_PER_SLOT;
+}
+
+static uint32_t get_bit_in_slot(uint32_t pos)
+{
+	assert(pos < SCMI_LOG_MAX_LEN);
+	return pos % BITS_PER_SLOT;
+}
+
+static bool log_scmi_is_entry_free(uint32_t pos)
+{
+	if (pos >= SCMI_LOG_MAX_LEN)
+		return false;
+
+	return !(entry_state[get_slot(pos)] & BIT_64(get_bit_in_slot(pos)));
+}
+
+static void log_scmi_mark_entry_busy(uint32_t pos)
+{
+	assert(pos < SCMI_LOG_MAX_LEN);
+	assert(log_scmi_is_entry_free(pos));
+	entry_state[get_slot(pos)] |= BIT_64(get_bit_in_slot(pos));
+}
+
+static void log_scmi_mark_entry_free(uint32_t pos)
+{
+	assert(pos < SCMI_LOG_MAX_LEN);
+	assert(!log_scmi_is_entry_free(pos));
+	entry_state[get_slot(pos)] &= ~BIT_64(get_bit_in_slot(pos));
+}
+
+static int get_next_free_pos(int start_pos)
+{
+	unsigned int slot, bit, next_pos = 0;
+	unsigned int max_iterations = SCMI_LOG_SLOTS_NUM;
+	entry_state_t state;
+
+	if (is_logger_empty())
+		return 0;
+
+	if (start_pos < 0)
+		return -1;
+
+	slot = get_slot(start_pos);
+
+	while (max_iterations) {
+		bit = get_bit_in_slot(start_pos);
+
+		state = entry_state[slot];
+		/**
+		 * mask the bits behind current position
+		 * and the unavailable ones for the last slot
+		 */
+		state |= GENMASK_64(bit, 0);
+		if (slot == SCMI_LOG_SLOTS_NUM - 1)
+			state |= slot_mask;
+
+		next_pos = __builtin_ffsl(~state);
+		if (next_pos)
+			return slot * BITS_PER_SLOT + next_pos - 1;
+
+		/* if next_pos = 0 -> go to next slot */
+		slot = (slot + 1) % SCMI_LOG_SLOTS_NUM;
+		start_pos = slot * BITS_PER_SLOT;
+		/* check position 0 in slot */
+		if (log_scmi_is_entry_free(start_pos))
+			return start_pos;
+
+		max_iterations--;
+	}
+
+	return -1;
+}
+
+/* Helper functions to save relevant info to log buffer */
+static void log_scmi_req_message(struct scmi_msg *msg, uintptr_t md_addr)
+{
+	struct scmi_log_entry *entry = NULL;
+	size_t num_bytes = 0;
+	uint32_t msg_no = 0;
+	int pos = 0;
+	unsigned int core = plat_my_core_pos();
+
+	if (core >= (ssize_t)ARRAY_SIZE(crt_msg)) {
+		ERROR("Failed to get core number %d\n", core);
+		return;
+	}
+
+	if (!logger.get_entry)
+		return;
+
+	spin_lock(&logger.lock);
+	pos = get_next_free_pos(logger.index);
+	if (pos >= 0) {
+		/* valid position */
+		if (pos >= SCMI_LOG_MAX_LEN)
+			pos = 0;
+		entry = logger.get_entry(pos);
+		log_scmi_mark_entry_busy(pos);
+		msg_no = logger.msg_count;
+		logger.index = pos;
+		logger.msg_count++;
+	}
+
+	crt_msg[core] = entry;
+	spin_unlock(&logger.lock);
+
+	if (entry) {
+		entry->msg_no = msg_no;
+		entry->idx = pos;
+		entry->core = core;
+		entry->msg.agent_id = msg->agent_id;
+		entry->msg.protocol_id = msg->protocol_id;
+		entry->msg.message_id = msg->message_id;
+		entry->msg.in_size = msg->in_size;
+
+		num_bytes = msg->in_size;
+		if (msg->in_size > sizeof(entry->msg.request)) {
+			num_bytes = sizeof(entry->msg.request);
+			WARN("Incomplete SCMI request logged [msg_no = %d]\n", msg_no);
+		}
+		memcpy(&entry->msg.request, msg->in, num_bytes);
+
+		if (logger.log_req_data)
+			logger.log_req_data(entry, md_addr);
+	}
+}
+
+static void log_scmi_rsp_message(struct scmi_msg *msg, uintptr_t md_addr)
+{
+	struct scmi_log_entry *entry = NULL;
+	size_t num_bytes = 0;
+	unsigned int core = plat_my_core_pos();
+
+	if (core >= (ssize_t)ARRAY_SIZE(crt_msg)) {
+		ERROR("Failed to get core number %d\n", core);
+		return;
+	}
+
+	entry = crt_msg[core];
+
+	if (entry) {
+		entry->msg.out_size = msg->out_size;
+		num_bytes = MIN(msg->out_size, sizeof(entry->msg.response));
+		memcpy(&entry->msg.response, msg->out, num_bytes);
+
+		if (logger.log_rsp_data)
+			logger.log_rsp_data(entry, md_addr);
+
+		spin_lock(&logger.lock);
+		log_scmi_mark_entry_free(entry->idx);
+		spin_unlock(&logger.lock);
+	}
+}
+
+static void log_scmi_raw(mailbox_mem_t *mbx_mem, uintptr_t md_addr, enum scmi_msg_type type)
+{
+	uint32_t msg_header = mbx_mem->msg_header;
+
+	struct scmi_msg msg = {
+		.in = (char *)&mbx_mem->payload[0],
+		.in_size = mbx_mem->len - 4,
+		.agent_id = 0,
+		.protocol_id = SCMI_MSG_GET_PROTO(msg_header),
+		.message_id = SCMI_MSG_GET_MSG_ID(msg_header),
+		.out = (char *)&mbx_mem->payload[0],
+		.out_size = SCMI_MAILBOX_MEM_SIZE - sizeof(*mbx_mem),
+	};
+
+	switch (type) {
+	case SCMI_REQ:
+		log_scmi_req_message(&msg, md_addr);
+		break;
+	case SCMI_RSP:
+		log_scmi_rsp_message(&msg, md_addr);
+		break;
+	default:
+		break;
+	}
+}
+
+void log_scmi_init(void)
+{
+	unsigned int extra_bits = SCMI_LOG_MAX_LEN % BITS_PER_SLOT;
+
+	if (extra_bits)
+		slot_mask = ~GENMASK(extra_bits - 1, 0);
+
+	logger.index = -1;
+
+	if (log_scmi_plat_init(&logger))
+		ERROR("Could not init SCMI logger.\n");
+}
+
+void log_scmi_req(mailbox_mem_t *mbx_mem, uintptr_t md_addr)
+{
+	log_scmi_raw(mbx_mem, md_addr, SCMI_REQ);
+}
+
+void log_scmi_rsp(mailbox_mem_t *mbx_mem, uintptr_t md_addr)
+{
+	log_scmi_raw(mbx_mem, md_addr, SCMI_RSP);
+}
diff --git a/drivers/arm/css/scmi/scmi_logger.h b/drivers/arm/css/scmi/scmi_logger.h
new file mode 100644
index 000000000..28a37b7db
--- /dev/null
+++ b/drivers/arm/css/scmi/scmi_logger.h
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2023 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef SCMI_LOGGER_H
+#define SCMI_LOGGER_H
+
+#include "scmi_private.h"
+
+#ifndef SCMI_LOGGER
+#define SCMI_LOGGER     0
+#endif
+
+void log_scmi_init(void);
+void log_scmi_req(mailbox_mem_t *mbx_mem, uintptr_t md_addr);
+void log_scmi_rsp(mailbox_mem_t *mbx_mem, uintptr_t md_addr);
+
+#endif /* SCMI_LOGGER_H */
+
diff --git a/drivers/arm/css/scmi/scmi_logger_private.h b/drivers/arm/css/scmi/scmi_logger_private.h
new file mode 100644
index 000000000..36d2f9202
--- /dev/null
+++ b/drivers/arm/css/scmi/scmi_logger_private.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2023 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef SCMI_LOGGER_PRIVATE_H
+#define SCMI_LOGGER_PRIVATE_H
+
+#include <lib/spinlock.h>
+
+#ifndef SCMI_LOG_MAX_LEN
+#define SCMI_LOG_MAX_LEN		1024
+#endif
+
+#ifndef SCMI_LOG_BUF_LEN
+#define SCMI_LOG_BUF_LEN		32
+#endif
+
+typedef uint64_t entry_state_t;
+
+#define BITS_PER_SLOT			(sizeof(entry_state_t) * 8)
+#define SCMI_LOG_SLOTS_NUM		(SCMI_LOG_MAX_LEN / BITS_PER_SLOT +  \
+							(!!(SCMI_LOG_MAX_LEN % BITS_PER_SLOT)))
+
+/* General info about a SCMI message */
+struct message {
+	unsigned int agent_id;
+	unsigned int protocol_id;
+	unsigned int message_id;
+	size_t in_size;
+	size_t out_size;
+	uint8_t request[SCMI_LOG_BUF_LEN];
+	uint8_t response[SCMI_LOG_BUF_LEN];
+};
+
+struct scmi_log_entry {
+	uint32_t msg_no;
+	uint32_t idx;
+	int core;
+	struct message msg;
+};
+
+struct scmi_logger {
+	uint32_t msg_count;
+	int index;
+	spinlock_t lock;
+
+	/* logging interface */
+	struct scmi_log_entry* (*get_entry)(unsigned int index);
+	void (*log_req_data)(struct scmi_log_entry *entry, uintptr_t md_addr);
+	void (*log_rsp_data)(struct scmi_log_entry *entry, uintptr_t md_addr);
+};
+
+#endif /* SCMI_LOGGER_PRIVATE_H */
diff --git a/drivers/arm/css/scmi/scmi_private.h b/drivers/arm/css/scmi/scmi_private.h
index 2c7559106..2faa7c5e1 100644
--- a/drivers/arm/css/scmi/scmi_private.h
+++ b/drivers/arm/css/scmi/scmi_private.h
@@ -154,6 +154,7 @@ typedef struct mailbox_mem {
 	uint32_t payload[];
 } mailbox_mem_t;
 
+#define SCMI_MAILBOX_MEM_SIZE	(128U)
 
 /* Private APIs for use within SCMI driver */
 void scmi_get_channel(scmi_channel_t *ch);
-- 
2.25.1

