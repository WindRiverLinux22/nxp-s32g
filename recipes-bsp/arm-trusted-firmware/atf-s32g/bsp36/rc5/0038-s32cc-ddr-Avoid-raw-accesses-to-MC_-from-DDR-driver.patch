From 1345351593bf57b891f0b2e0cb9b0f7e8fe7ccbe Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Mon, 20 Feb 2023 16:29:14 +0200
Subject: [PATCH 38/54] s32cc: ddr: Avoid raw accesses to MC_* from DDR driver

When SCP is used, raw access to MC_RGM and MC_CGM5 is not permitted, as
XRDC may protect these. This patch adapts the DDR driver to access
reset-related registers through the SCMI reset domain when the SCP is
used.

Issue: ALB-9757
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/nxp/s32/clk/early_clocks.c            | 19 +++++-
 drivers/nxp/s32/ddr/ddr_utils.c               | 39 +++++++-----
 drivers/nxp/s32/rst/s32gen1_rst.c             |  4 +-
 .../drivers/nxp/s32/clk/s32gen1_scmi_rst.h    |  3 +-
 include/drivers/nxp/s32/ddr/ddr_utils.h       |  4 +-
 plat/nxp/s32/include/s32_clocks.h             |  4 +-
 plat/nxp/s32/s32_bl2_el3.c                    |  6 ++
 plat/nxp/s32/s32_bl31.c                       |  2 +-
 plat/nxp/s32/s32_bl_common.c                  | 14 ++++-
 plat/nxp/s32/s32_scp_early_clocks.c           | 59 ++++++++++++++++++-
 10 files changed, 131 insertions(+), 23 deletions(-)

diff --git a/drivers/nxp/s32/clk/early_clocks.c b/drivers/nxp/s32/clk/early_clocks.c
index ed92cac65..e4446970e 100644
--- a/drivers/nxp/s32/clk/early_clocks.c
+++ b/drivers/nxp/s32/clk/early_clocks.c
@@ -1,15 +1,19 @@
 // SPDX-License-Identifier: BSD-3-Clause
 /*
- * Copyright 2020-2022 NXP
+ * Copyright 2020-2023 NXP
  */
 #include <clk/clk.h>
 #include <clk/s32gen1_clk_funcs.h>
 #include <dt-bindings/clock/s32gen1-clock-freq.h>
 #include <dt-bindings/clock/s32gen1-clock.h>
+#include <drivers/nxp/s32/clk/s32gen1_scmi_rst.h>
+#include <drivers/nxp/s32/ddr/ddr_utils.h>
 #include <s32_bl_common.h>
 #include <s32_clocks.h>
 #include <s32_pinctrl.h>
 
+#define S32GEN1_DDR_RST (3u)
+
 #define CLK_INIT(ID)          \
 {                             \
 	.id = (ID),           \
@@ -269,6 +273,19 @@ int s32_enable_ddr_clock(void)
 	return s32gen1_enable(&ddr, 1);
 }
 
+int s32_reset_ddr_periph(void)
+{
+	int ret;
+
+	ret = s32gen1_assert_rgm((uintptr_t)s32_priv.rgm, true,
+				 S32GEN1_DDR_RST);
+	if (ret)
+		return ret;
+
+	return s32gen1_assert_rgm((uintptr_t)s32_priv.rgm, false,
+				  S32GEN1_DDR_RST);
+}
+
 int s32_plat_clock_init(bool skip_ddr_clk)
 {
 	int ret;
diff --git a/drivers/nxp/s32/ddr/ddr_utils.c b/drivers/nxp/s32/ddr/ddr_utils.c
index 1b9a8323b..557a44547 100644
--- a/drivers/nxp/s32/ddr/ddr_utils.c
+++ b/drivers/nxp/s32/ddr/ddr_utils.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020-2022 NXP
+ * Copyright 2020-2023 NXP
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -154,21 +154,32 @@ uint32_t set_axi_parity(void)
 		mmio_write_32(DDR_SS_REG, tmp32 | DDR_SS_DFI_1_ENABLED);
 	}
 
-	/*
-	 * Set ddr clock source on FIRC_CLK.
-	 * If it's already set on FIRC_CLK, already_set becomes true.
+	/**
+	 * This is a temporary workaround to avoid direct access to MC_* modules
+	 * when booting with SCP. It will be integrated into future versions of
+	 * the DDR tool.
+	 * @alb_atf_temp
 	 */
-	sel_clk_src(FIRC_CLK_SRC, &already_set);
-
-	/* De-assert Reset To Controller and AXI Ports */
-	tmp32 = mmio_read_32(MC_RGM_PRST_0);
-	mmio_write_32(MC_RGM_PRST_0,
-		      ~(FORCED_RESET_ON_PERIPH << PRST_0_PERIPH_3_RST_POS) &
-		      tmp32);
+	if (1) {
+		if (reset_ddr_periph())
+			return TRAINING_FAILED;
+	} else {
+		/*
+		 * Set ddr clock source on FIRC_CLK.
+		 * If it's already set on FIRC_CLK, already_set becomes true.
+		 */
+		sel_clk_src(FIRC_CLK_SRC, &already_set);
+
+		/* De-assert Reset To Controller and AXI Ports */
+		tmp32 = mmio_read_32(MC_RGM_PRST_0);
+		mmio_write_32(MC_RGM_PRST_0,
+			      ~(FORCED_RESET_ON_PERIPH << PRST_0_PERIPH_3_RST_POS) &
+			      tmp32);
 
-	/* Check if the initial clock source was not already set on FIRC */
-	if (!already_set)
-		sel_clk_src(DDR_PHI0_PLL, &already_set);
+		/* Check if the initial clock source was not already set on FIRC */
+		if (!already_set)
+			sel_clk_src(DDR_PHI0_PLL, &already_set);
+	}
 
 	/* Enable HIF, CAM Queueing */
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DBG1,
diff --git a/drivers/nxp/s32/rst/s32gen1_rst.c b/drivers/nxp/s32/rst/s32gen1_rst.c
index 2a8527477..835afdfc6 100644
--- a/drivers/nxp/s32/rst/s32gen1_rst.c
+++ b/drivers/nxp/s32/rst/s32gen1_rst.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: BSD-3-Clause
 /*
- * Copyright 2021 NXP
+ * Copyright 2021, 2023 NXP
  */
 #include <clk/clk.h>
 #include <clk/mc_rgm_regs.h>
@@ -64,7 +64,7 @@ static int get_reset_regs(unsigned long id, uintptr_t rgm,
 	return 0;
 }
 
-static int s32gen1_assert_rgm(uintptr_t rgm, bool asserted, uint32_t id)
+int s32gen1_assert_rgm(uintptr_t rgm, bool asserted, uint32_t id)
 {
 	uintptr_t prst, pstat;
 	uint32_t id_offset = id % 32;
diff --git a/include/drivers/nxp/s32/clk/s32gen1_scmi_rst.h b/include/drivers/nxp/s32/clk/s32gen1_scmi_rst.h
index e2d734317..c12c680cf 100644
--- a/include/drivers/nxp/s32/clk/s32gen1_scmi_rst.h
+++ b/include/drivers/nxp/s32/clk/s32gen1_scmi_rst.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: BSD-3-Clause */
 /*
- * Copyright 2021 NXP
+ * Copyright 2021, 2023 NXP
  */
 #ifndef S32GEN1_SCMI_RST_H
 #define S32GEN1_SCMI_RST_H
@@ -8,6 +8,7 @@
 #include <stdint.h>
 #include <stdbool.h>
 
+int s32gen1_assert_rgm(uintptr_t rgm, bool asserted, uint32_t id);
 int s32gen1_reset_periph(uint32_t periph_id, bool assert);
 int s32gen1_reset_partition(unsigned int part_id, bool assert_not_deassert);
 
diff --git a/include/drivers/nxp/s32/ddr/ddr_utils.h b/include/drivers/nxp/s32/ddr/ddr_utils.h
index c9d2538e4..b86770d80 100644
--- a/include/drivers/nxp/s32/ddr/ddr_utils.h
+++ b/include/drivers/nxp/s32/ddr/ddr_utils.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020-2022 NXP
+ * Copyright 2020-2023 NXP
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -473,4 +473,6 @@ uint32_t poll_derating_temp_errata(bool traffic_halted);
 
 #endif
 
+int reset_ddr_periph(void);
+
 #endif /* DDR_UTILS_H_ */
diff --git a/plat/nxp/s32/include/s32_clocks.h b/plat/nxp/s32/include/s32_clocks.h
index 00a91179c..069b8891e 100644
--- a/plat/nxp/s32/include/s32_clocks.h
+++ b/plat/nxp/s32/include/s32_clocks.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2021-2022 NXP
+ * Copyright 2021-2023 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -163,6 +163,8 @@ int s32_scp_plat_clock_init(bool skip_ddr_clk);
 int scp_scmi_clk_set_config_enable(unsigned int clock_index);
 int s32_enable_ddr_clock(void);
 int s32_enable_a53_clock(void);
+int scp_reset_ddr_periph(void);
+int s32_reset_ddr_periph(void);
 
 #endif /* _S32_CLOCKS_H_ */
 
diff --git a/plat/nxp/s32/s32_bl2_el3.c b/plat/nxp/s32/s32_bl2_el3.c
index 1a582485f..1e9da76f5 100644
--- a/plat/nxp/s32/s32_bl2_el3.c
+++ b/plat/nxp/s32/s32_bl2_el3.c
@@ -256,6 +256,12 @@ static mmap_region_t s32_mmap[] = {
 			MT_NON_CACHEABLE | MT_RW | MT_SECURE),
 	MAP_REGION_FLAT(S32_QSPI_BASE, S32_QSPI_SIZE, MT_DEVICE | MT_RW),
 	MAP_REGION_FLAT(S32_FLASH_BASE, FIP_MAXIMUM_SIZE, MT_RW | MT_SECURE),
+	/* SCP entries */
+	MAP_REGION_FLAT(MSCM_BASE_ADDR, MMU_ROUND_UP_TO_PAGE(MSCM_SIZE),
+			MT_DEVICE | MT_RW),
+	MAP_REGION_FLAT(S32_SCP_SCMI_MEM,
+			MMU_ROUND_UP_TO_PAGE(S32_SCP_SCMI_MEM_SIZE),
+			MT_NON_CACHEABLE | MT_RW | MT_SECURE),
 #if (ERRATA_S32_050543 == 1)
 	MAP_REGION_FLAT(DDR_ERRATA_REGION_BASE, DDR_ERRATA_REGION_SIZE,
 			MT_NON_CACHEABLE | MT_RW),
diff --git a/plat/nxp/s32/s32_bl31.c b/plat/nxp/s32/s32_bl31.c
index a375d17b7..860a7135e 100644
--- a/plat/nxp/s32/s32_bl31.c
+++ b/plat/nxp/s32/s32_bl31.c
@@ -103,7 +103,7 @@ static const mmap_region_t s32_mmap[] = {
 	MAP_REGION_FLAT(S32_OSPM_SCMI_MEM, S32_OSPM_SCMI_MEM_SIZE,
 			MT_NON_CACHEABLE | MT_RW | MT_SECURE),
 	/* SCP entries */
-	MAP_REGION_FLAT(MSCM_BASE_ADDR, MMU_ROUND_UP_TO_4K(MSCM_SIZE),
+	MAP_REGION_FLAT(MSCM_BASE_ADDR, MMU_ROUND_UP_TO_PAGE(MSCM_SIZE),
 			MT_DEVICE | MT_RW),
 	MAP_REGION_FLAT(S32_SCP_SCMI_MEM,
 			MMU_ROUND_UP_TO_PAGE(S32_SCP_SCMI_MEM_SIZE),
diff --git a/plat/nxp/s32/s32_bl_common.c b/plat/nxp/s32/s32_bl_common.c
index 74bf0cf8e..824249082 100644
--- a/plat/nxp/s32/s32_bl_common.c
+++ b/plat/nxp/s32/s32_bl_common.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2021-2022 NXP
+ * Copyright 2021-2023 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -38,6 +38,18 @@ void ddr_errata_update_flag(uint8_t flag)
 }
 #endif
 
+int reset_ddr_periph(void)
+{
+	int ret;
+
+	if (!is_scp_used())
+		ret = s32_reset_ddr_periph();
+	else
+		ret = scp_reset_ddr_periph();
+
+	return ret;
+}
+
 void s32_early_plat_init(bool skip_ddr_clk)
 {
 	uint32_t caiutc;
diff --git a/plat/nxp/s32/s32_scp_early_clocks.c b/plat/nxp/s32/s32_scp_early_clocks.c
index a0626350b..ea74b2240 100644
--- a/plat/nxp/s32/s32_scp_early_clocks.c
+++ b/plat/nxp/s32/s32_scp_early_clocks.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: BSD-3-Clause
 /*
- * Copyright 2022 NXP
+ * Copyright 2022-2023 NXP
  */
 
 #include <s32_bl_common.h>
@@ -10,13 +10,16 @@
 
 #include <libc/assert.h>
 #include <drivers/arm/css/scmi.h>
+#include <drivers/nxp/s32/ddr/ddr_utils.h>
 #include <arm/css/scmi/scmi_private.h>
 #include <clk/s32gen1_clk_funcs.h>
 #include <common/debug.h>
 #include <drivers/scmi.h>
 #include <scmi-msg/clock.h>
+#include <scmi-msg/reset_domain.h>
 
 #include <dt-bindings/clock/s32gen1-scmi-clock.h>
+#include <dt-bindings/reset/s32gen1-scmi-reset.h>
 
 #pragma weak scp_enable_board_early_clocks
 
@@ -25,6 +28,49 @@ int scp_enable_board_early_clocks(void)
 	return 0;
 }
 
+static int scp_scmi_reset_set_state(uint32_t domain_id, bool assert)
+{
+	int ret;
+	unsigned int token = 0;
+	struct scmi_reset_domain_request_a2p *payload_args;
+	struct scmi_reset_domain_request_p2a *payload_resp;
+	mailbox_mem_t *mbx_mem;
+	uint8_t buffer[S32_SCP_CH_MEM_SIZE];
+
+	mbx_mem = (mailbox_mem_t *)buffer;
+	mbx_mem->res_a = 0U;
+	mbx_mem->status = 0U;
+	mbx_mem->res_b = 0UL;
+	mbx_mem->flags = SCMI_FLAG_RESP_POLL;
+	mbx_mem->len = 4U + sizeof(*payload_args);
+	mbx_mem->msg_header = SCMI_MSG_CREATE(SCMI_PROTOCOL_ID_RESET_DOMAIN,
+					      SCMI_RESET_DOMAIN_REQUEST,
+					      token);
+
+	payload_args = (struct scmi_reset_domain_request_a2p *)mbx_mem->payload;
+	payload_args->domain_id = domain_id;
+	payload_args->reset_state = 0;
+
+	if (assert)
+		payload_args->flags = SCMI_RESET_DOMAIN_EXPLICIT;
+	else
+		payload_args->flags = 0U;
+
+	ret = send_scmi_to_scp((uintptr_t)mbx_mem, sizeof(buffer));
+	if (ret)
+		return ret;
+
+	/* The payload contains the response filled by send_scmi_to_scp() */
+	payload_resp = (struct scmi_reset_domain_request_p2a *)mbx_mem->payload;
+	ret = payload_resp->status;
+	if (ret != SCMI_E_SUCCESS) {
+		ERROR("Failed to reset doamin %u\n", domain_id);
+		return ret;
+	}
+
+	return 0;
+}
+
 int scp_scmi_clk_set_config_enable(unsigned int clock_index)
 {
 	int ret;
@@ -209,3 +255,14 @@ int s32_scp_plat_clock_init(bool skip_ddr_clk)
 
 	return scp_enable_board_early_clocks();
 }
+
+int scp_reset_ddr_periph(void)
+{
+	int ret;
+
+	ret = scp_scmi_reset_set_state(S32GEN1_SCMI_RST_DDR, true);
+	if (ret)
+		return ret;
+
+	return scp_scmi_reset_set_state(S32GEN1_SCMI_RST_DDR, false);
+}
-- 
2.25.1

