From b331c3f4dff19a30118ff7d6c5feddfb55792765 Mon Sep 17 00:00:00 2001
From: Andrei Cherechesu <andrei.cherechesu@nxp.com>
Date: Thu, 2 Mar 2023 11:15:16 +0200
Subject: [PATCH 42/54] s32: ddr: Update to driver/fw from S32CT 1.6 Update 6

This update comes with improvements regarding the DDR PHY impedance
calibration sequence. Also, the constraints on the Refresh Command
were removed, because the default configuration is working on both
Legacy and Modified mode devices, thus, no longer needing a separate
configuration for RDB3 Rev. F, which will be treated in a following commit.

Issue: ALB-9722
Upstream-Status: Pending 

Signed-off-by: Andrei Cherechesu <andrei.cherechesu@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/nxp/s32/ddr/ddr_init.c          | 16 ++++++----------
 drivers/nxp/s32/ddr/ddr_lp.c            |  5 ++---
 drivers/nxp/s32/ddr/ddr_utils.c         | 17 ++++++++---------
 include/drivers/nxp/s32/ddr/ddr_utils.h |  6 ++++--
 4 files changed, 20 insertions(+), 24 deletions(-)

diff --git a/drivers/nxp/s32/ddr/ddr_init.c b/drivers/nxp/s32/ddr/ddr_init.c
index b70b11e23..8b2f67630 100644
--- a/drivers/nxp/s32/ddr/ddr_init.c
+++ b/drivers/nxp/s32/ddr/ddr_init.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020-2022 NXP
+ * Copyright 2020-2023 NXP
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -82,6 +82,7 @@ static uint32_t ddrc_init_cfg(const struct ddrss_config *config)
 static uint32_t execute_training(const struct ddrss_config *config)
 {
 	uint32_t ret = NO_ERR;
+
 	/* Apply DQ swapping settings */
 	ret = load_dq_cfg(config->dq_swap_size, config->dq_swap);
 	if (ret != NO_ERR)
@@ -92,6 +93,9 @@ static uint32_t execute_training(const struct ddrss_config *config)
 	if (ret != NO_ERR)
 		return ret;
 
+	/* Configure PLL optimal settings */
+	set_optimal_pll();
+
 	/* Load 1D imem image */
 	mmio_write_32(MICROCONT_MUX_SEL, UNLOCK_CSR_ACCESS);
 	ret = load_phy_image(IMEM_START_ADDR, config->imem_1d_size,
@@ -100,16 +104,12 @@ static uint32_t execute_training(const struct ddrss_config *config)
 		return ret;
 	mmio_write_32(MICROCONT_MUX_SEL, LOCK_CSR_ACCESS);
 
-	/* Load 1D imem image */
+	/* Load 1D dmem image */
 	mmio_write_32(MICROCONT_MUX_SEL, UNLOCK_CSR_ACCESS);
 	ret = load_phy_image(DMEM_START_ADDR, config->dmem_1d_size,
 			     config->dmem_1d);
 	if (ret != NO_ERR)
 		return ret;
-	mmio_write_32(MICROCONT_MUX_SEL, LOCK_CSR_ACCESS);
-
-	/* Configure PLL optimal settings */
-	set_optimal_pll();
 
 	mmio_write_32(MICROCONT_MUX_SEL, LOCK_CSR_ACCESS);
 	mmio_write_32(APBONLY_MICRORESET, APBONLY_RESET_STALL_MASK);
@@ -149,10 +149,6 @@ static uint32_t execute_training(const struct ddrss_config *config)
 				     config->dmem_2d);
 		if (ret != NO_ERR)
 			return ret;
-		mmio_write_32(MICROCONT_MUX_SEL, LOCK_CSR_ACCESS);
-
-		/* Configure PLL optimal settings */
-		set_optimal_pll();
 
 		mmio_write_32(MICROCONT_MUX_SEL, LOCK_CSR_ACCESS);
 		mmio_write_32(APBONLY_MICRORESET, APBONLY_RESET_STALL_MASK);
diff --git a/drivers/nxp/s32/ddr/ddr_lp.c b/drivers/nxp/s32/ddr/ddr_lp.c
index 608d8d493..21f540997 100644
--- a/drivers/nxp/s32/ddr/ddr_lp.c
+++ b/drivers/nxp/s32/ddr/ddr_lp.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2021-2022 NXP
+ * Copyright 2021-2023 NXP
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -266,10 +266,9 @@ uint32_t ddrss_to_normal_mode(uintptr_t csr_array)
 	if (ret != NO_ERR)
 		return ret;
 
-	mmio_write_32(MICROCONT_MUX_SEL, LOCK_CSR_ACCESS);
-
 	/* Optimal PLL */
 	set_optimal_pll();
+	mmio_write_32(MICROCONT_MUX_SEL, LOCK_CSR_ACCESS);
 
 	/* Reload saved CSRs */
 	mmio_write_32(MICROCONT_MUX_SEL, UNLOCK_CSR_ACCESS);
diff --git a/drivers/nxp/s32/ddr/ddr_utils.c b/drivers/nxp/s32/ddr/ddr_utils.c
index 557a44547..a41316240 100644
--- a/drivers/nxp/s32/ddr/ddr_utils.c
+++ b/drivers/nxp/s32/ddr/ddr_utils.c
@@ -475,7 +475,6 @@ static uint32_t get_mail(uint32_t *mail)
 		return TIMEOUT_ERR;
 
 	*mail = mmio_read_32(DDR_PHYA_APBONLY_UCTWRITEONLYSHADOW);
-
 	/* ACK */
 	return ack_mail();
 }
@@ -576,8 +575,8 @@ static uint32_t init_memory_ecc_scrubber(void)
 	return NO_ERR;
 }
 
-/* Read lpddr4 mode register with given index */
-uint32_t read_lpddr4_mr(uint8_t mr_index)
+/* Read lpddr4 mode register with given rank and index */
+uint32_t read_lpddr4_mr(uint8_t mr_rank, uint8_t mr_index)
 {
 	uint32_t tmp32;
 	uint8_t succesive_reads = 0;
@@ -599,12 +598,12 @@ uint32_t read_lpddr4_mr(uint8_t mr_index)
 			succesive_reads = 0;
 	} while (succesive_reads != REQUIRED_MRSTAT_READS);
 
-	/* Set MR_TYPE = 0x1 (Read) and MR_RANK = 0x1 (Rank 0) */
+	/* Set MR_TYPE = 0x1 (Read) and MR_RANK = desired rank */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
 	tmp32 |= MRCTRL0_MR_TYPE_READ;
 	tmp32 = (tmp32 & ~(MRCTRL0_RANK_ACCESS_FIELD <<
 			   MRCTRL0_RANK_ACCESS_POS)) |
-		(MRCTRL0_RANK_0 << MRCTRL0_RANK_ACCESS_POS);
+		(mr_rank << MRCTRL0_RANK_ACCESS_POS);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0, tmp32);
 
 	/* Configure MR address: MRCTRL1[8:15] */
@@ -635,7 +634,7 @@ uint32_t read_lpddr4_mr(uint8_t mr_index)
 }
 
 /* Write data in lpddr4 mode register with given index */
-uint32_t write_lpddr4_mr(uint8_t mr_index, uint8_t mr_data)
+uint32_t write_lpddr4_mr(uint8_t mr_rank, uint8_t mr_index, uint8_t mr_data)
 {
 	uint32_t tmp32;
 	uint8_t succesive_reads = 0;
@@ -657,12 +656,12 @@ uint32_t write_lpddr4_mr(uint8_t mr_index, uint8_t mr_data)
 			succesive_reads = 0;
 	} while (succesive_reads != REQUIRED_MRSTAT_READS);
 
-	/* Set MR_TYPE = 0x0 (Write) and MR_RANK = 0x1 (Rank 0) */
+	/* Set MR_TYPE = 0x0 (Write) and MR_RANK = desired rank */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
 	tmp32 &= ~(MRCTRL0_MR_TYPE_READ);
 	tmp32 = (tmp32 & ~(MRCTRL0_RANK_ACCESS_FIELD <<
 			   MRCTRL0_RANK_ACCESS_POS)) |
-		(MRCTRL0_RANK_0 << MRCTRL0_RANK_ACCESS_POS);
+		(mr_rank << MRCTRL0_RANK_ACCESS_POS);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0, tmp32);
 
 	/* Configure MR address: MRCTRL1[8:15] and MR data: MRCTRL1[0:7]*/
@@ -1021,7 +1020,7 @@ uint8_t read_tuf(void)
 	uint32_t mr4_val;
 	uint8_t mr4_die_1, mr4_die_2;
 
-	mr4_val = read_lpddr4_mr(MR4_IDX);
+	mr4_val = read_lpddr4_mr(MRCTRL0_RANK_0, MR4_IDX);
 	mr4_die_1 = (uint8_t)(mr4_val & MR4_MASK);
 	mr4_die_2 = (uint8_t)((mr4_val >> MR4_SHIFT) & MR4_MASK);
 
diff --git a/include/drivers/nxp/s32/ddr/ddr_utils.h b/include/drivers/nxp/s32/ddr/ddr_utils.h
index b86770d80..7b450fa67 100644
--- a/include/drivers/nxp/s32/ddr/ddr_utils.h
+++ b/include/drivers/nxp/s32/ddr/ddr_utils.h
@@ -422,15 +422,17 @@ uint32_t post_train_setup(uint8_t options);
 uint32_t wait_firmware_execution(void);
 
 /* Read lpddr4 mode register.
+ * @param mr_rank - rank access
  * @param mr_index - index of mode register to be read
  */
-uint32_t read_lpddr4_mr(uint8_t mr_index);
+uint32_t read_lpddr4_mr(uint8_t mr_rank, uint8_t mr_index);
 
 /* Write lpddr4 mode register
+ * @param mr_rank - rank access
  * @param mr_index - index of mode register to be read
  * @param mr_data - data to be written
  */
-uint32_t write_lpddr4_mr(uint8_t mr_index, uint8_t mr_data);
+uint32_t write_lpddr4_mr(uint8_t mr_rank, uint8_t mr_index, uint8_t mr_data);
 
 /* Modify bitfield value with delta, given bitfield position and mask */
 bool update_bf(uint32_t *v, uint8_t pos, uint32_t mask, int32_t delta);
-- 
2.25.1

