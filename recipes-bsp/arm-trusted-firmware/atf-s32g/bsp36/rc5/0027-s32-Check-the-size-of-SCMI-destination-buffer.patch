From a26559ab0a5d165f90cff52b99ffbea631795a33 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Mon, 12 Dec 2022 16:23:48 +0200
Subject: [PATCH 27/54] s32: Check the size of SCMI destination buffer

Check the size of the SCMI buffer before copying the
response coming from SCP.

Issue: ALB-9425
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32/include/s32_scp_scmi.h |  2 +-
 plat/nxp/s32/s32_scp_early_clocks.c |  8 ++++++--
 plat/nxp/s32/s32_scp_scmi.c         | 23 +++++++++++++++++------
 plat/nxp/s32/s32_svc.c              |  3 +--
 4 files changed, 25 insertions(+), 11 deletions(-)

diff --git a/plat/nxp/s32/include/s32_scp_scmi.h b/plat/nxp/s32/include/s32_scp_scmi.h
index 9ce79750e..06887a35b 100644
--- a/plat/nxp/s32/include/s32_scp_scmi.h
+++ b/plat/nxp/s32/include/s32_scp_scmi.h
@@ -11,7 +11,7 @@
 typedef int (*scmi_msg_callback_t)(void *payload);
 
 void scp_scmi_init(bool request_irq);
-int send_scmi_to_scp(uintptr_t scmi_mem);
+int send_scmi_to_scp(uintptr_t scmi_mem, size_t scmi_mem_size);
 void scp_set_core_reset_addr(uintptr_t addr);
 int scp_get_cpu_state(uint32_t core);
 int scp_cpu_on(uint32_t core);
diff --git a/plat/nxp/s32/s32_scp_early_clocks.c b/plat/nxp/s32/s32_scp_early_clocks.c
index 5b6d733e5..a0626350b 100644
--- a/plat/nxp/s32/s32_scp_early_clocks.c
+++ b/plat/nxp/s32/s32_scp_early_clocks.c
@@ -48,7 +48,9 @@ int scp_scmi_clk_set_config_enable(unsigned int clock_index)
 	payload_args->clock_id = clock_index;
 	payload_args->attributes = SCMI_CLOCK_CONFIG_SET_ENABLE_MASK;
 
-	send_scmi_to_scp((uintptr_t)mbx_mem);
+	ret = send_scmi_to_scp((uintptr_t)mbx_mem, sizeof(buffer));
+	if (ret)
+		return ret;
 
 	/* The payload contains the response filled by send_scmi_to_scp() */
 	payload_resp = (struct scmi_clock_config_set_p2a *)mbx_mem->payload;
@@ -86,7 +88,9 @@ static int scp_scmi_clk_set_rate(unsigned int clock_index, unsigned long rate)
 	payload_args->rate[0] = (uint32_t)(rate & GENMASK(31, 0));
 	payload_args->rate[1] = (uint32_t)((uint64_t)rate >> 32);
 
-	send_scmi_to_scp((uintptr_t)mbx_mem);
+	ret = send_scmi_to_scp((uintptr_t)mbx_mem, sizeof(buffer));
+	if (ret)
+		return ret;
 
 	/* The payload contains the response filled by send_scmi_to_scp() */
 	payload_resp = (struct scmi_clock_rate_set_p2a *)mbx_mem->payload;
diff --git a/plat/nxp/s32/s32_scp_scmi.c b/plat/nxp/s32/s32_scp_scmi.c
index 584d537e2..f823c5dd0 100644
--- a/plat/nxp/s32/s32_scp_scmi.c
+++ b/plat/nxp/s32/s32_scp_scmi.c
@@ -224,12 +224,17 @@ static void *get_scmi_handle(void)
 	return scmi_handles[ch_id];
 }
 
-static void copy_scmi_msg(uintptr_t to, uintptr_t from)
+static int copy_scmi_msg(uintptr_t to, uintptr_t from, size_t to_size)
 {
 	size_t copy_len;
 
 	copy_len = get_packet_size(from);
+	if (copy_len > to_size)
+		return -E2BIG;
+
 	memcpy((void *)to, (const void *)from, copy_len);
+
+	return 0;
 }
 
 void scp_set_core_reset_addr(uintptr_t addr)
@@ -441,13 +446,14 @@ static int handle_internal_msg(uintptr_t scmi_mem)
 	return SCMI_SUCCESS;
 }
 
-static int forward_to_scp(uintptr_t scmi_mem)
+static int forward_to_scp(uintptr_t scmi_mem, size_t scmi_mem_size)
 {
 	unsigned int ch_id;
 	scmi_channel_plat_info_t *ch_info;
 	scmi_channel_t *ch = get_scmi_channel(&ch_id);
 	mailbox_mem_t *mbx_mem;
 	size_t packet_size;
+	int ret;
 
 	if (!ch)
 		return SCMI_GENERIC_ERROR;
@@ -466,7 +472,10 @@ static int forward_to_scp(uintptr_t scmi_mem)
 	    S32_SCP_SCMI_MEM + S32_SCP_SCMI_MEM_SIZE)
 		return SCMI_OUT_OF_RANGE;
 
-	copy_scmi_msg((uintptr_t)mbx_mem, scmi_mem);
+	ret = copy_scmi_msg((uintptr_t)mbx_mem, scmi_mem,
+			    S32_SCP_CH_MEM_SIZE);
+	if (ret)
+		return SCMI_OUT_OF_RANGE;
 
 	SCMI_MARK_CHANNEL_FREE(mbx_mem->status);
 
@@ -485,12 +494,14 @@ static int forward_to_scp(uintptr_t scmi_mem)
 	scmi_put_channel(ch);
 
 	/* Copy the result to agent's space */
-	copy_scmi_msg(scmi_mem, (uintptr_t)mbx_mem);
+	ret = copy_scmi_msg(scmi_mem, (uintptr_t)mbx_mem, scmi_mem_size);
+	if (ret)
+		return SCMI_OUT_OF_RANGE;
 
 	return SCMI_SUCCESS;
 }
 
-int send_scmi_to_scp(uintptr_t scmi_mem)
+int send_scmi_to_scp(uintptr_t scmi_mem, size_t scmi_mem_size)
 {
 	/* Filter OSPM specific call */
 	if (!is_proto_allowed((mailbox_mem_t *)scmi_mem))
@@ -502,5 +513,5 @@ int send_scmi_to_scp(uintptr_t scmi_mem)
 	if (is_internal_msg((mailbox_mem_t *)scmi_mem))
 		return handle_internal_msg(scmi_mem);
 
-	return forward_to_scp(scmi_mem);
+	return forward_to_scp(scmi_mem, scmi_mem_size);
 }
diff --git a/plat/nxp/s32/s32_svc.c b/plat/nxp/s32/s32_svc.c
index 345c4747f..7c35e508c 100644
--- a/plat/nxp/s32/s32_svc.c
+++ b/plat/nxp/s32/s32_svc.c
@@ -115,8 +115,7 @@ static int scp_scmi_handler(uint32_t smc_fid, u_register_t x1,
 	struct response *response = (struct response *)&mem->msg_payload[0];
 	int ret;
 
-	ret = send_scmi_to_scp(S32_OSPM_SCMI_MEM);
-
+	ret = send_scmi_to_scp(S32_OSPM_SCMI_MEM, S32_OSPM_SCMI_MEM_SIZE);
 	if (ret != SCMI_SUCCESS) {
 		response->status = ret;
 		mem->channel_status = 1;
-- 
2.25.1

