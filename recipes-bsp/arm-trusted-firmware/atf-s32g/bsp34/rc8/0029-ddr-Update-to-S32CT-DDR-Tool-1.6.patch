From 36bcf84f3ef3fd81fc9e1ab9144458b8825a600f Mon Sep 17 00:00:00 2001
From: Andrei Cherechesu <andrei.cherechesu@nxp.com>
Date: Fri, 19 Aug 2022 15:31:34 +0300
Subject: [PATCH 29/42] ddr: Update to S32CT DDR Tool 1.6

Updated the DDR code to the latest generated with
DDR Tool 1.6, including an improvement regarding the
DDR PHY impedance calibration sequence.

Issue: ALB-9197
Upstream-Status: Pending 

Signed-off-by: Andrei Cherechesu <andrei.cherechesu@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/nxp/s32/ddr/ddr_init.c         |   9 +++
 drivers/nxp/s32/ddr/ddr_lp_mmio.c      |  49 ++++++------
 drivers/nxp/s32/ddr/ddr_utils_mmio.c   | 103 +++++++++++++------------
 drivers/nxp/s32/ddr/s32g2/ddrc_cfg.c   |   4 +-
 include/drivers/nxp/s32/ddr/ddr_init.h |  23 ++++--
 5 files changed, 108 insertions(+), 80 deletions(-)

diff --git a/drivers/nxp/s32/ddr/ddr_init.c b/drivers/nxp/s32/ddr/ddr_init.c
index 94b97b001..bc47759bc 100644
--- a/drivers/nxp/s32/ddr/ddr_init.c
+++ b/drivers/nxp/s32/ddr/ddr_init.c
@@ -230,9 +230,18 @@ static uint32_t load_phy_image(uint32_t start_addr, size_t size,
 /* Ensure optimal phy pll settings. */
 void set_optimal_pll(void)
 {
+	uint32_t tmp32;
+
 	/* Configure phy pll for 3200MTS data rate */
 	mmio_write_32(MASTER_PLLCTRL1, PLLCTRL1_VALUE);
 	mmio_write_32(MASTER_PLLTESTMODE, PLLTESTMODE_VALUE);
 	mmio_write_32(MASTER_PLLCTRL4, PLLCTRL4_VALUE);
 	mmio_write_32(MASTER_PLLCTRL2, PLLCTRL2_VALUE);
+
+	tmp32 = mmio_read_32(MASTER_CALMISC2);
+	mmio_write_32(MASTER_CALMISC2, tmp32 | (CALMISC2 << CALMISC2_OFFSET));
+	tmp32 = mmio_read_32(MASTER_CALOFFSET);
+	tmp32 = tmp32 & CALDRV_MASK;
+	tmp32 |= (CALDRV << CALDRV_OFFSET) | (CALDRV << CALDRV2_OFFSET);
+	mmio_write_32(MASTER_CALOFFSET, tmp32);
 }
diff --git a/drivers/nxp/s32/ddr/ddr_lp_mmio.c b/drivers/nxp/s32/ddr/ddr_lp_mmio.c
index de0defac4..ab236c1ee 100644
--- a/drivers/nxp/s32/ddr/ddr_lp_mmio.c
+++ b/drivers/nxp/s32/ddr/ddr_lp_mmio.c
@@ -46,7 +46,8 @@ void store_csr(uintptr_t store_at)
 	mmio_write_32(DDR_PHYA_UCCLKHCLKENABLES, HCLKEN_MASK | UCCLKEN_MASK);
 
 	for (i = 0; i < csr_to_store_size; i++) {
-		csr = mmio_read_16(DDRSS_BASE_ADDR + csr_to_store[i]);
+		csr = mmio_read_16((uint32_t)(DDRSS_BASE_ADDR +
+					      csr_to_store[i]));
 		mmio_write_16(current_addr, csr);
 		current_addr += sizeof(uint16_t);
 	}
@@ -65,7 +66,8 @@ static void load_csr(uintptr_t load_from)
 	for (i = 0; i < csr_to_store_size; i++) {
 		csr = mmio_read_16(current_addr);
 		current_addr += sizeof(uint16_t);
-		mmio_write_16(DDRSS_BASE_ADDR + csr_to_store[i], csr);
+		mmio_write_16((uint32_t)(DDRSS_BASE_ADDR + csr_to_store[i]),
+			      csr);
 	}
 }
 
@@ -80,7 +82,8 @@ void store_ddrc_regs(uintptr_t store_at)
 	current_addr += sizeof(uint32_t) - (current_addr % sizeof(uint32_t));
 
 	for (i = 0; i < ddrc_to_store_size; i++) {
-		value = mmio_read_32((DDRC_BASE_ADDR + ddrc_to_store[i]));
+		value = mmio_read_32((uint32_t)(DDRC_BASE_ADDR +
+						ddrc_to_store[i]));
 		mmio_write_32(current_addr, value);
 		current_addr += sizeof(uint32_t);
 	}
@@ -98,7 +101,8 @@ static void load_ddrc_regs(uintptr_t load_from)
 
 	for (i = 0; i < ddrc_to_store_size; i++) {
 		value = mmio_read_32(current_addr);
-		mmio_write_32((DDRC_BASE_ADDR + ddrc_to_store[i]), value);
+		mmio_write_32((uint32_t)(DDRC_BASE_ADDR + ddrc_to_store[i]),
+			      value);
 		current_addr += sizeof(uint32_t);
 	}
 }
@@ -123,16 +127,16 @@ void ddrss_to_io_retention_mode(void)
 
 	/* Disable Scrubber */
 	sbrctl = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL, sbrctl &
-		      (~SCRUB_EN_MASK));
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL,
+		      sbrctl & (~SCRUB_EN_MASK));
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRSTAT);
 	} while ((tmp32 & SCRUB_BUSY_MASK) != SBRSTAT_SCRUBBER_NOT_BUSY);
 
 	/* Move to Self Refresh */
 	pwrctl = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL, pwrctl |
-		      SELFREF_SW_MASK);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
+		      pwrctl | SELFREF_SW_MASK);
 
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_STAT);
@@ -150,35 +154,35 @@ void ddrss_to_io_retention_mode(void)
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC,
 		      DFIMISC_TRANSITION_PHY_TO_LP3);
 	swctl = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL, swctl &
-		      (~SW_DONE_MASK));
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
+		      swctl & (~SW_DONE_MASK));
 
 	dfimisc = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC, dfimisc |
-		      DFI_FREQUENCY(DFIMISC_LP3_PHY_STATE));
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC,
+		      dfimisc | DFI_FREQUENCY(DFIMISC_LP3_PHY_STATE));
 
 	dfimisc = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC, dfimisc |
-		      DFI_INIT_START_MASK);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC,
+		      dfimisc | DFI_INIT_START_MASK);
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFISTAT);
 	} while ((tmp32 & DFI_INIT_COMPLETE_MASK) !=
 		 DFISTAT_DFI_INIT_INCOMPLETE);
 
 	dfimisc = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC, dfimisc |
-		      DFI_FREQUENCY(DFIMISC_LP3_PHY_STATE));
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC,
+		      dfimisc | DFI_FREQUENCY(DFIMISC_LP3_PHY_STATE));
 	dfimisc = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC, dfimisc &
-		      (~DFI_INIT_START_MASK));
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC,
+		      dfimisc & (~DFI_INIT_START_MASK));
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFISTAT);
 	} while ((tmp32 & DFI_INIT_COMPLETE_MASK) ==
 		 DFISTAT_DFI_INIT_INCOMPLETE);
 
 	swctl = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL, swctl |
-		      SW_DONE_MASK);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
+		      swctl | SW_DONE_MASK);
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
 	} while ((tmp32 & SW_DONE_ACK_MASK) == SWSTAT_SW_NOT_DONE);
@@ -186,7 +190,6 @@ void ddrss_to_io_retention_mode(void)
 	/* Set PwrOkIn to 0 */
 	tmp32 = mmio_read_32(DDR_RET_CONTROL_REG);
 	mmio_write_32(DDR_RET_CONTROL_REG, tmp32 & (~DDR_RET_CONTROL_MASK));
-
 	tmp32 = mmio_read_32(DDR_CONFIG_0_REG);
 	mmio_write_32(DDR_CONFIG_0_REG, tmp32 | DDR_CONFIG_0_MEM_RET);
 }
@@ -213,8 +216,8 @@ uint32_t ddrss_to_normal_mode(uintptr_t csr_array)
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_INIT0, init0);
 
 	pwrctl = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL, pwrctl |
-		      SELFREF_SW_MASK);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
+		      pwrctl | SELFREF_SW_MASK);
 
 	/* Setup AXI ports parity */
 	ret = set_axi_parity();
diff --git a/drivers/nxp/s32/ddr/ddr_utils_mmio.c b/drivers/nxp/s32/ddr/ddr_utils_mmio.c
index 6978abf25..b3a6ddfba 100644
--- a/drivers/nxp/s32/ddr/ddr_utils_mmio.c
+++ b/drivers/nxp/s32/ddr/ddr_utils_mmio.c
@@ -102,8 +102,8 @@ static void sel_clk_src(uint32_t clk_src, bool *already_set)
 		/* Set DDR_CLK source on src_clk */
 		tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC);
 		mmio_write_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC,
-			      (CSC_SELCTL_MASK & tmp32) |
-			      (clk_src << CSC_SELCTL_POS));
+			      (CSC_SELCTL_MASK & tmp32) | (clk_src <<
+							   CSC_SELCTL_POS));
 
 		/* Request clock switch */
 		tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC);
@@ -115,8 +115,8 @@ static void sel_clk_src(uint32_t clk_src, bool *already_set)
 		do {
 			tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR +
 					     OFFSET_MUX_0_CSS);
-		} while (((tmp32 >> CSS_SWIP_POS) &
-			  CSS_SW_IN_PROGRESS) != CSS_SW_COMPLETED);
+		} while (((tmp32 >> CSS_SWIP_POS) & CSS_SW_IN_PROGRESS) !=
+			 CSS_SW_COMPLETED);
 
 		/* To wait till Switch after request is succeeded */
 		do {
@@ -163,8 +163,9 @@ uint32_t set_axi_parity(void)
 
 	/* De-assert Reset To Controller and AXI Ports */
 	tmp32 = mmio_read_32(MC_RGM_PRST_0);
-	mmio_write_32(MC_RGM_PRST_0, ~(FORCED_RESET_ON_PERIPH <<
-				       PRST_0_PERIPH_3_RST_POS) & tmp32);
+	mmio_write_32(MC_RGM_PRST_0,
+		      ~(FORCED_RESET_ON_PERIPH << PRST_0_PERIPH_3_RST_POS) &
+		      tmp32);
 
 	/* Check if the initial clock source was not already set on FIRC */
 	if (!already_set)
@@ -207,8 +208,8 @@ uint32_t set_axi_parity(void)
 
 	/* DFI_INIT_COMPLETE_EN set to 0 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC, tmp32 &
-		      (~DFIMISC_DFI_INIT_COMPLETE_EN_MASK));
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC,
+		      (~DFIMISC_DFI_INIT_COMPLETE_EN_MASK) & tmp32);
 
 	/* Set SWCTL.sw_done to 1 */
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL, SWCTL_SWDONE_DONE);
@@ -223,13 +224,13 @@ uint32_t set_axi_parity(void)
 /* Enables AXI port n. Programming Mode: Dynamic */
 static uint32_t enable_axi_ports(void)
 {
-	/* Port 0 Control Register*/
+	/* Port 0 Control Register */
 	mmio_write_32(DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_0,
 		      ENABLE_AXI_PORT);
-	/* Port 1 Control Register*/
+	/* Port 1 Control Register */
 	mmio_write_32(DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_1,
 		      ENABLE_AXI_PORT);
-	/* Port 2 Control Register*/
+	/* Port 2 Control Register */
 	mmio_write_32(DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_2,
 		      ENABLE_AXI_PORT);
 
@@ -239,7 +240,7 @@ static uint32_t enable_axi_ports(void)
 /*
  * Post PHY training setup - complementary settings that need to be
  * performed after running the firmware.
- *  @param options - various flags controlling post training actions
+ * @param options - various flags controlling post training actions
  * (whether to init memory with ECC scrubber / whether to store CSR)
  */
 uint32_t post_train_setup(uint8_t options)
@@ -407,8 +408,7 @@ static uint32_t ack_mail(void)
 	uint32_t tmp32 = mmio_read_32(DDR_PHYA_APBONLY_UCTSHADOWREGS);
 
 	/* Wait firmware to respond to ACK (UctWriteProtShadow to be set) */
-	while ((--timeout != 0u) &&
-	       ((tmp32 & UCT_WRITE_PROT_SHADOW_MASK) ==
+	while ((--timeout != 0u) && ((tmp32 & UCT_WRITE_PROT_SHADOW_MASK) ==
 				     UCT_WRITE_PROT_SHADOW_ACK))
 		tmp32 = mmio_read_32(DDR_PHYA_APBONLY_UCTSHADOWREGS);
 
@@ -460,8 +460,8 @@ static uint32_t init_memory_ecc_scrubber(void)
 	/* Set SBRCTL.scrub_mode = 1. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL,
-		      (SBRCTL_SCRUB_MODE_WRITE <<
-		       SBRCTL_SCRUB_MODE_POS) | tmp32);
+		      (SBRCTL_SCRUB_MODE_WRITE << SBRCTL_SCRUB_MODE_POS) |
+		      tmp32);
 
 	/* Set SBRCTL.scrub_during_lowpower = 1. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
@@ -509,8 +509,8 @@ static uint32_t init_memory_ecc_scrubber(void)
 	/* Enter normal scrub operation (Reads): SBRCTL.scrub_mode = 0. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL,
-		      ~(SBRCTL_SCRUB_MODE_WRITE <<
-			SBRCTL_SCRUB_MODE_POS) & tmp32);
+		      ~(SBRCTL_SCRUB_MODE_WRITE << SBRCTL_SCRUB_MODE_POS) &
+		      tmp32);
 
 	/* Set SBRCTL.scrub_interval = 1. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
@@ -577,8 +577,8 @@ uint32_t read_lpddr4_mr(uint8_t mr_index)
 
 	/* Initiate MR transaction: MR_WR = 0x1 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0, tmp32 |
-		      (MRCTRL0_WR_ENGAGE << MRCTRL0_WR_ENGAGE_POS));
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0,
+		      tmp32 | (MRCTRL0_WR_ENGAGE << MRCTRL0_WR_ENGAGE_POS));
 
 	/* Wait until MR transaction completed */
 	succesive_reads = 0;
@@ -635,8 +635,8 @@ uint32_t write_lpddr4_mr(uint8_t mr_index, uint8_t mr_data)
 
 	/* Initiate MR transaction: MR_WR = 0x1 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0, tmp32 |
-		      (MRCTRL0_WR_ENGAGE << MRCTRL0_WR_ENGAGE_POS));
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0,
+		      tmp32 | (MRCTRL0_WR_ENGAGE << MRCTRL0_WR_ENGAGE_POS));
 
 	/* Wait until MR transaction completed */
 	succesive_reads = 0;
@@ -675,19 +675,23 @@ void read_cdds(void)
 		/* Compute max CDDs for both ranks depending on memory type */
 		if (is_lpddr4()) {
 			const uint32_t rr_addr[] = {
-					CDD_CHA_RR_1_0, CDD_CHA_RR_0_1,
-					CDD_CHB_RR_1_0, CDD_CHB_RR_0_1};
+				CDD_CHA_RR_1_0, CDD_CHA_RR_0_1,
+				CDD_CHB_RR_1_0, CDD_CHB_RR_0_1
+				};
 			const uint32_t ww_addr[] = {
-					CDD_CHA_WW_1_0, CDD_CHA_WW_0_1,
-					CDD_CHB_WW_1_0, CDD_CHB_WW_0_1};
+				CDD_CHA_WW_1_0, CDD_CHA_WW_0_1,
+				CDD_CHB_WW_1_0, CDD_CHB_WW_0_1
+				};
 			const uint32_t rw_addr[] = {
-					CDD_CHA_RW_1_1, CDD_CHA_RW_1_0,
-					CDD_CHA_RW_0_1, CDD_CHB_RW_1_1,
-					CDD_CHB_RW_1_0, CDD_CHB_RW_0_1};
+				CDD_CHA_RW_1_1, CDD_CHA_RW_1_0,
+				CDD_CHA_RW_0_1, CDD_CHB_RW_1_1,
+				CDD_CHB_RW_1_0, CDD_CHB_RW_0_1
+				};
 			const uint32_t wr_addr[] = {
-					CDD_CHA_WR_1_1, CDD_CHA_WR_1_0,
-					CDD_CHA_WR_0_1, CDD_CHB_WR_1_1,
-					CDD_CHB_WR_1_0, CDD_CHB_WR_0_1};
+				CDD_CHA_WR_1_1, CDD_CHA_WR_1_0,
+				CDD_CHA_WR_0_1, CDD_CHB_WR_1_1,
+				CDD_CHB_WR_1_0, CDD_CHB_WR_0_1
+				};
 
 			cdd_rr = get_max_cdd(rr_addr, ARRAY_SIZE(rr_addr));
 			cdd_rw = get_max_cdd(rw_addr, ARRAY_SIZE(rw_addr));
@@ -763,16 +767,18 @@ void read_vref_dq(void)
 void compute_tphy_wrdata_delay(void)
 {
 	const uint32_t single_rank_dly_addr[] = {
-			DBYTE0_TXDQSDLYTG0_U0, DBYTE0_TXDQSDLYTG0_U1,
-			DBYTE1_TXDQSDLYTG0_U0, DBYTE1_TXDQSDLYTG0_U1,
-			DBYTE2_TXDQSDLYTG0_U0, DBYTE2_TXDQSDLYTG0_U1,
-			DBYTE3_TXDQSDLYTG0_U0, DBYTE3_TXDQSDLYTG0_U1};
+		DBYTE0_TXDQSDLYTG0_U0, DBYTE0_TXDQSDLYTG0_U1,
+		DBYTE1_TXDQSDLYTG0_U0, DBYTE1_TXDQSDLYTG0_U1,
+		DBYTE2_TXDQSDLYTG0_U0, DBYTE2_TXDQSDLYTG0_U1,
+		DBYTE3_TXDQSDLYTG0_U0, DBYTE3_TXDQSDLYTG0_U1
+		};
 
 	const uint32_t dual_rank_dly_addr[] = {
-			DBYTE0_TXDQSDLYTG1_U0, DBYTE0_TXDQSDLYTG1_U1,
-			DBYTE1_TXDQSDLYTG1_U0, DBYTE1_TXDQSDLYTG1_U1,
-			DBYTE2_TXDQSDLYTG1_U0, DBYTE2_TXDQSDLYTG1_U1,
-			DBYTE3_TXDQSDLYTG1_U0, DBYTE3_TXDQSDLYTG1_U1};
+		DBYTE0_TXDQSDLYTG1_U0, DBYTE0_TXDQSDLYTG1_U1,
+		DBYTE1_TXDQSDLYTG1_U0, DBYTE1_TXDQSDLYTG1_U1,
+		DBYTE2_TXDQSDLYTG1_U0, DBYTE2_TXDQSDLYTG1_U1,
+		DBYTE3_TXDQSDLYTG1_U0, DBYTE3_TXDQSDLYTG1_U1
+		};
 
 	uint16_t tx_dqsdly, tx_dqsdly_tg1, tctrl_delay, burst_length,
 		 wrdata_use_dfi_phy_clk;
@@ -833,7 +839,7 @@ static uint32_t adjust_ddrc_config(void)
 		return BITFIELD_EXCEEDED;
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG2, tmp32);
 
-	/* For LPDDR4 overwrite INIT6 and INIT7 DDRC registers */
+	/* For LPDDR4 overwrite INIT6 and INIT7 DDRC registers. */
 	if (is_lpddr4()) {
 		/* INIT6.mr5 */
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_INIT6);
@@ -861,7 +867,6 @@ static uint32_t adjust_ddrc_config(void)
 
 		min = is_lpddr4() ? min_lp4 : min_ddr3;
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_RANKCTL);
-
 		/* RANKCTL.diff_rank_rd_gap */
 		rd_gap = (uint8_t)((tmp32 >> RANKCTL_RD_GAP_POS) &
 				   RANKCTL_RD_GAP_MASK);
@@ -1003,6 +1008,7 @@ uint32_t enable_derating_temp_errata(void)
 		polling_needed = 0;
 		return NO_ERR;
 	}
+
 	/* Disable timing parameter derating: DERATEEN.DERATE_EN = 0 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DERATEEN);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DERATEEN,
@@ -1035,7 +1041,6 @@ uint32_t enable_derating_temp_errata(void)
 	} while ((tmp32 & SWSTAT_SWDONE_ACK_MASK) != SWSTAT_SW_NOT_DONE);
 
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4);
-
 	/*
 	 * Set minimum time from activate to read/write command to same
 	 * bank: DRAMTMG4.T_RCD += 2
@@ -1059,8 +1064,8 @@ uint32_t enable_derating_temp_errata(void)
 	 * DRAMTMG0.T_RAS_MIN += 2
 	 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG0);
-	if (!update_bf(&tmp32, DRAMTMG0_TRAS_POS, DRAMTMG0_TRAS_MASK,
-		       DRAMTMG0_TRAS_DELTA_TIME))
+	if (!update_bf(&tmp32, DRAMTMG0_TRAS_POS,
+		       DRAMTMG0_TRAS_MASK, DRAMTMG0_TRAS_DELTA_TIME))
 		return BITFIELD_EXCEEDED;
 
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG0, tmp32);
@@ -1070,8 +1075,8 @@ uint32_t enable_derating_temp_errata(void)
 	 * same bank: DRAMTMG4.T_RP += 2
 	 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4);
-	if (!update_bf(&tmp32, DRAMTMG4_TRP_POS, DRAMTMG4_TRP_MASK,
-		       DRAMTMG4_TRP_DELTA_TIME))
+	if (!update_bf(&tmp32, DRAMTMG4_TRP_POS,
+		       DRAMTMG4_TRP_MASK, DRAMTMG4_TRP_DELTA_TIME))
 		return BITFIELD_EXCEEDED;
 
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4, tmp32);
@@ -1081,8 +1086,8 @@ uint32_t enable_derating_temp_errata(void)
 	 * DRAMTMG1.T_RC += 3
 	 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG1);
-	if (!update_bf(&tmp32, DRAMTMG1_TRC_POS, DRAMTMG1_TRC_MASK,
-		       DRAMTMG1_TRC_DELTA_TIME))
+	if (!update_bf(&tmp32, DRAMTMG1_TRC_POS,
+		       DRAMTMG1_TRC_MASK, DRAMTMG1_TRC_DELTA_TIME))
 		return BITFIELD_EXCEEDED;
 
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG1, tmp32);
diff --git a/drivers/nxp/s32/ddr/s32g2/ddrc_cfg.c b/drivers/nxp/s32/ddr/s32g2/ddrc_cfg.c
index 32429c0bd..87eedbc31 100644
--- a/drivers/nxp/s32/ddr/s32g2/ddrc_cfg.c
+++ b/drivers/nxp/s32/ddr/s32g2/ddrc_cfg.c
@@ -74,14 +74,14 @@ struct regconf ddrc_cfg[] = {
 	{0x403c00ec, 0x0004004fU},
 	{0x403c00f0, 0x00000000U},
 	{0x403c00f4, 0x00000779U},
-	{0x403c0100, 0x1a201b22U},
+	{0x403c0100, 0x1b203622U},
 	{0x403c0104, 0x00060633U},
 	{0x403c0108, 0x070e1517U},
 	{0x403c010c, 0x00c0c000U},
 	{0x403c0110, 0x0f04080fU},
 	{0x403c0114, 0x02040c0cU},
 	{0x403c0118, 0x01010007U},
-	{0x403c011c, 0x00000401U},
+	{0x403c011c, 0x00000402U},
 	{0x403c0120, 0x03034405U},
 	{0x403c0124, 0x0004040dU},
 	{0x403c0128, 0x001c180aU},
diff --git a/include/drivers/nxp/s32/ddr/ddr_init.h b/include/drivers/nxp/s32/ddr/ddr_init.h
index fe3712ae2..47966edea 100644
--- a/include/drivers/nxp/s32/ddr/ddr_init.h
+++ b/include/drivers/nxp/s32/ddr/ddr_init.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020-2021 NXP
+ * Copyright 2020-2022 NXP
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -34,11 +34,22 @@
 #include <stdlib.h>
 #include "ddr_utils.h"
 
-#define APBONLY_MICRORESET   0x40380420
-#define MASTER_PLLCTRL1      0x403816f0
-#define MASTER_PLLTESTMODE   0x40381708
-#define MASTER_PLLCTRL4      0x4038171c
-#define MASTER_PLLCTRL2      0x403816dc
+#define APBONLY_MICRORESET   0x40380420U
+#define MASTER_PLLCTRL1      0x403816f0U
+#define MASTER_PLLTESTMODE   0x40381708U
+#define MASTER_PLLCTRL4      0x4038171cU
+#define MASTER_PLLCTRL2      0x403816dcU
+
+#define MASTER_CALOFFSET     0x40381514U
+#define MASTER_CALMISC2      0x40381660U
+
+#define CALDRV               ((uint32_t)0x9U)
+#define CALDRV_OFFSET        0x6U
+#define CALDRV2_OFFSET       0xAU
+#define CALDRV_MASK          ~(0x3FC0U)
+
+#define CALMISC2             ((uint32_t)0x1U)
+#define CALMISC2_OFFSET      0xDU
 
 #define MICROCONT_MUX_SEL 0x40380400
 #define LOCK_CSR_ACCESS   0x00000001
-- 
2.17.1

