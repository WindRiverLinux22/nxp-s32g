From d2072708106e327d09181f261958493ab66e41ea Mon Sep 17 00:00:00 2001
From: Ionut Vicovan <Ionut.Vicovan@nxp.com>
Date: Thu, 10 Nov 2022 01:13:04 +0200
Subject: [PATCH 18/19] s32:serdes:hwconfig: Redesign 'hwconfig' env variable

The old format had lots of limitations, one being that it was not
possible to configure both XPCS interfaces for a SerDes.
New format is:
serdesX:mode=<pcie|pcie&xpcs0|pcie&xpcs1|xpcs0&xpcs1>;
clock=<ext|int>;fmhz=<100,125>;skip=<0|1>;pcieX:mode=<rc|ep>;
xpcsX_Y:speed=<10M|100M|1G|2G5>
This allows to better configure each lane and adds new attributes
to each controller.

Issue: ALB-8798

Upstream-Status: Pending 

Signed-off-by: Ionut Vicovan <Ionut.Vicovan@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 .../mach-s32/include/s32-cc/serdes_hwconfig.h | 163 +++---
 arch/arm/mach-s32/s32-cc/hwconfig_fixups.c    |  38 +-
 arch/arm/mach-s32/s32-cc/serdes_hwconfig.c    | 500 +++++++++++-------
 3 files changed, 412 insertions(+), 289 deletions(-)

diff --git a/arch/arm/mach-s32/include/s32-cc/serdes_hwconfig.h b/arch/arm/mach-s32/include/s32-cc/serdes_hwconfig.h
index c9bf5f0842..e45e75e96d 100644
--- a/arch/arm/mach-s32/include/s32-cc/serdes_hwconfig.h
+++ b/arch/arm/mach-s32/include/s32-cc/serdes_hwconfig.h
@@ -17,90 +17,107 @@
 #define MHZ_100			(100 * MHZ)
 #define MHZ_125			(125 * MHZ)
 
-enum serdes_dev_type {
-	SERDES_INVALID = 0,
-	PCIE_EP = 0x1, /* EP mode is 0x0, use 0x1 to allow us to use masks */
-	PCIE_RC = 0x4,
-	SGMII = 0x10, /* outside range of PE0_GEN_CTRL_1:DEVICE_TYPE */
-	/* TODO: If both PCIe/SGMII bifurcation modes are used, we may
-	 * need to use 2 SGMII modes - SGMII0 and SGMII1
-	 */
-	SERDES_SKIP = 0x20
-};
+#define SPEED_UNKNOWN		(-1)
 
-/* New enum */
-enum serdes_xpcs_mode_gen2 {
-	SGMII_XPCS_PCIE = 0,
-	SGMII_XPCS_DISABLED,
-	SGMII_XPCS_1G_OP,
-	SGMII_XPCS_2G5_OP,
-};
-
-/* Old enum TODO remove*/
-enum serdes_xpcs_mode {
-	SGMII_INAVALID = 0,
-	SGMII_XPCS0,		/* Combo mode PCIex1/SGMII(XPCS0) */
-	SGMII_XPCS1,		/* Combo mode PCIex1/SGMII(XPCS1) */
-	SGMII_XPCS0_XPCS1,	/* SGMII 2 x 1G mode */
-	SGMII_XPCS0_2G5,	/* SGMII 2.5G mode */
-	SGMII_XPCS_LAST = SGMII_XPCS0_2G5,
-};
+/* Same as in ethtool.h */
+/* The forced speed, 10Mb, 100Mb, gigabit, 2.5Gb, 10GbE. */
+#define SPEED_10		10
+#define SPEED_100		100
+#define SPEED_1000		1000
+#define SPEED_2500		2500
+#define SPEED_10000		10000
 
 /**
  * @brief	SerDes Subsystem Modes
  *
- * Based on doc from Synopsys:
+ * SS_RW_REG_0[SUBSYS_MODE] Based on S32G2RSERDESRM Rev5 / S32G3
  *
- * 000b - PCIe Gen3x2 mode
- * 001b - PCIe Gen3x1 and SGMII 1G bifurcation mode
- * 010b - PCIe Gen3x1 and SGMII 1G bifurcation mode
- * 011b - Two SGMII 1G/2.5G bifurcation mode
+ * 000b - PCIe Gen3 X2 mode
+ * 001b - PCIe Gen3 X1 and SGMII XPCS0 1G bifurcation mode
+ * 010b - PCIe Gen3 X1 and SGMII XPCS1 1G bifurcation mode
+ * 011b - Two SGMII 1G/2G5 bifurcation mode, PHY control XPCS0
+ * 100b - Two SGMII 1G/2G5 bifurcation mode, PHY control XPCS1
+ *
+ * Note: PCIe GenX means all speeds from Gen1 to GenX
+ * Note: Values for SUBSYS_MODE above are not 1:1 match with SerDes Modes below.
+ *
+ * Based on S32G2RM Rev5 / S32G3RM Rev2:
  *
  * SerDes_0 working modes
- * Mode Num-Name  PCIe        XPCS0     XPCS1     PHY        PHY        PHY Clk
- *                                                lane 0     lane 1     (MHz)
- * 0-PCIe only    X2 Gen3     N/A       N/A       PCIe Gen3  PCIe Gen3  100
- * 1-PCIe/SGMII   PCIe X1     SGMII     N/A       PCIe       SGMII      100
- * bifurcation    Gen2/3      1.25Gbps            Gen2/3     1.25Gbps
- *                                                           (GMAC0)
- * 2-PCIe/SGMII   PCIe X1     N/A       SGMII     PCIe       SGMII      100
- * bifurcation    Gen2/3                1.25Gbps  Gen2/3     1.25Gbps   100
- *                                                           (PFE_EMAC2)
- * 3-SGMII only   N/A         SGMII     SGMII     SGMII      SGMII      100/125
- *                            1.25Gbps  1.25Gbps  1.25Gbps   1.25Gbps
- *                            3.125Gbps 3.125Gbps 3.125Gbps  3.125Gbps
- *                                                (GMAC0)    (PFE_EMAC2)
+ *
+ * Mode Num - Name   PCIe     XPCS0     XPCS1     PHY        PHY        PHY Clk
+ *                                                lane 0     lane 1       (MHz)
+ * ----------------------------------------------------------------------------
+ * 0 - PCIe only     X2 Gen3  N/A       N/A       PCIe Gen3  PCIe Gen3      100
+ *
+ * 1 - PCIe/SGMII    X1 Gen3  SGMII 1G  N/A       PCIe Gen3  XPCS0 1G       100
+ *     bifurcation                                           (GMAC0)
+ *
+ * 2 - PCIe/SGMII    X1 Gen3    N/A     SGMII 1G  PCIe Gen3  XPCS1 1G       100
+ *     bifurcation   X1 Gen2(^) N/A     SGMII 2G5 PCIe Gen2  XPCS1 2G5      100
+ *                                                           (PFE_MAC2)
+ *
+ * 3 - SGMII only    N/A      SGMII 1G  SGMII 1G  XPCS0 1G   XPCS1 1G   100/125
+ *                                                (GMAC0)    (PFE_MAC2)
  *
  * SerDes_1 working modes
- * Mode Num-Name  PCIe        XPCS0     XPCS1     PHY        PHY        PHY Clk
- *                                                lane 0     lane 1     (MHz)
- * 0-PCIe only    X2 Gen3     N/A       N/A       PCIe Gen3  PCIe Gen3  100
- * 1-PCIe/SGMII   PCIe X1     SGMII     N/A       PCIe       SGMII      100
- * bifurcation    Gen2/3      1.25Gbps            Gen2/3     1.25Gbps
- *                                                          (PFE_MAC0/PFE_MAC1)
- * 2-PCIe/SGMII   PCIe X1     N/A       SGMII     PCIe       SGMII      100
- * bifurcation    Gen2/3                1.25Gbps  Gen2/3     1.25Gbps   100
- *                                                          (PFE_MAC0/PFE_MAC1)
- * 3-SGMII only   N/A         SGMII     SGMII     SGMII      SGMII      100/125
- *                            1.25Gbps  1.25Gbps  1.25Gbps   1.25Gbps
- *                            3.125Gbps 3.125Gbps 3.125Gbps  3.125Gbps
- *                                                (PFE_MAC0) (PFE_MAC0)
- * TODO: Investigate which of the two PCIe/SGMII bifurcation modes are
- * actually supported by S32G.
+ *
+ * Mode Num - Name   PCIe     XPCS0     XPCS1     PHY        PHY        PHY Clk
+ *                                                lane 0     lane 1       (MHz)
+ * ----------------------------------------------------------------------------
+ * 0 - PCIe only     X2 Gen3  N/A       N/A       PCIe Gen3  PCIe Gen3      100
+ *
+ * 1 - PCIe/SGMII    X1 Gen3  SGMII 1G  N/A       PCIe Gen3  XPCS0 1G       100
+ *     bifurcation                                           (PFE_MAC0)
+ *
+ * 2 - PCIe/SGMII    X1 Gen3    N/A     SGMII 1G  PCIe Gen3  XPCS1 1G       100
+ *     bifurcation   X1 Gen2(^) N/A     SGMII 2G5 PCIe Gen2  XPCS1 2G5      100
+ *                                                           (PFE_MAC1)
+ *
+ * 3 - SGMII only    N/A      SGMII 1G  SGMII 1G  XPCS0 1G   XPCS1 1G   100/125
+ *                                                (PFE_MAC0) (PFE_MAC1)
+ *
+ * 4 - SGMII only(^) N/A      SGMII 2G5 SGMII 1G  XPCS0 2G5  XPCS1 1G   100/125
+ *                   N/A      SGMII 1G  SGMII 2G5 XPCS0 1G   XPCS1 2G5  100/125
+ *                   N/A      SGMII 2G5 SGMII 2G5 XPCS0 2G5  XPCS1 2G5      125
+ *                                                (PFE_MAC0) (PFE_MAC1)
+ * Notes (^):
+ * Mode 2 - PCIe Gen2 on lane 0 and SGMII XPCS1 2G5 on lane 1 is supported only
+ *          for S32G3. To disambiguate, we'll call this second configuration of
+ *          Mode 2 as Mode 5.
+ * Mode 4 - Fully supported only on S32G3 (SerDes1). To disambiguate, we'll
+ *          call the three Mode 4 configuations as 4.1, 4.2, 4.3.
+ *          On S32G2, there is one limited flavor of configuration 4.3, running
+ *          at 125 MHz, with only XPCS0 2G5 on lane 0 and nothing on lane 1.
+ *
+ *
  */
 enum serdes_mode {
 	SERDES_MODE_INVAL = -1,
 	/*	Lane0=PCIe, Lane1=PCIe */
 	SERDES_MODE_PCIE_PCIE = 0,
 	/*	Lane0=PCIe, Lane1=SGMII(XPCS0) (1G) */
-	SERDES_MODE_PCIE_SGMII0 = 1,
+	SERDES_MODE_PCIE_XPCS0 = 1,
 	/*	Lane0=PCIe, Lane1=SGMII(XPCS1) (1G) */
-	SERDES_MODE_PCIE_SGMII1 = 2,
-	/*	Lane0=SGMII(1G/2.5G), Lane1=SGMII(1G/2.5G) */
-	SERDES_MODE_SGMII_SGMII = 3,
-	/*	Lane0=SGMII(1G/2.5G), Lane1=SGMII(1G/2.5G) */
-	SERDES_MODE_SGMII_SGMII_ALT = 4,
-	SERDES_MODE_MAX = SERDES_MODE_SGMII_SGMII_ALT
+	SERDES_MODE_PCIE_XPCS1 = 2,
+	/*	Lane0=SGMII(XPCS0) (1G/2G5), Lane1=SGMII(XPCS1) (1G/2G5) */
+	SERDES_MODE_XPCS0_XPCS1 = 3,
+	/*	Lane0=None, Lane1=SGMII(XPCS1) (1G/2G5); currently not used */
+	SERDES_MODE_XPCS1_ONLY = 4,
+	SERDES_MODE_MAX = SERDES_MODE_XPCS1_ONLY
+};
+
+enum serdes_xpcs_mode {
+	SGMII_INVALID = -1,
+	SGMII_XPCS_1G = 0,
+	SGMII_XPCS_2G5 = 1,
+	SGMII_XPCS_LAST = SGMII_XPCS_2G5
+};
+
+enum pcie_type {
+	PCIE_INVALID = 0,
+	PCIE_EP = 0x1, /* EP mode is 0x0, use 0x1 to allow us to use masks */
+	PCIE_RC = 0x4,
 };
 
 /* Supported link speeds for PCIe on S32CC
@@ -121,12 +138,16 @@ enum pcie_link_width {
 	X_MAX = X2
 };
 
-enum serdes_dev_type s32_serdes_get_mode_from_hwconfig(int id);
+enum serdes_mode s32_serdes_get_serdes_mode_from_hwconfig(int id);
 bool s32_serdes_is_external_clk_in_hwconfig(int i);
 unsigned long s32_serdes_get_clock_fmhz_from_hwconfig(int id);
-enum serdes_xpcs_mode s32_serdes_get_xpcs_cfg_from_hwconfig(int id);
-enum serdes_mode s32_serdes_get_op_mode_from_hwconfig(int id);
-enum pcie_phy_mode s32_serdes_get_phy_mode_from_hwconfig(int id);
+bool s32_serdes_get_skip_from_hwconfig(int id);
+enum pcie_type s32_serdes_get_pcie_type_from_hwconfig(int id);
+int s32_serdes_get_xpcs_speed_from_hwconfig(int serdes_id,
+					    int xpcs_id);
+enum serdes_xpcs_mode s32_serdes_get_xpcs_cfg_from_hwconfig(int serdes_id,
+							    int xpcs_id);
+enum pcie_phy_mode s32_serdes_get_pcie_phy_mode_from_hwconfig(int id);
 bool s32_serdes_is_cfg_valid(int id);
 bool s32_serdes_is_pcie_enabled_in_hwconfig(int id);
 bool s32_serdes_is_combo_mode_enabled_in_hwconfig(int id);
diff --git a/arch/arm/mach-s32/s32-cc/hwconfig_fixups.c b/arch/arm/mach-s32/s32-cc/hwconfig_fixups.c
index dca0b525b8..55db818658 100644
--- a/arch/arm/mach-s32/s32-cc/hwconfig_fixups.c
+++ b/arch/arm/mach-s32/s32-cc/hwconfig_fixups.c
@@ -371,9 +371,9 @@ static int set_pcie_mode(struct dts_node *node, int id)
 {
 	int ret;
 	char *compatible;
-	enum serdes_dev_type pcie_mode;
+	enum pcie_type pcie_mode;
 
-	pcie_mode = s32_serdes_get_mode_from_hwconfig(id);
+	pcie_mode = s32_serdes_get_pcie_type_from_hwconfig(id);
 	if (pcie_mode & PCIE_EP)
 		compatible = "nxp,s32cc-pcie-ep";
 	else
@@ -395,7 +395,7 @@ static int set_pcie_phy_mode(struct dts_node *node, int id)
 	const char *mode;
 	enum pcie_phy_mode phy_mode;
 
-	phy_mode = s32_serdes_get_phy_mode_from_hwconfig(id);
+	phy_mode = s32_serdes_get_pcie_phy_mode_from_hwconfig(id);
 	if (phy_mode == PCIE_PHY_MODE_INVALID) {
 		pr_err("Invalid PCIe%d PHY mode", id);
 		return -EINVAL;
@@ -423,8 +423,8 @@ static int set_pcie_phy_mode(struct dts_node *node, int id)
 	return ret;
 }
 
-static int add_serdes_lines(struct dts_node *root, int id, int lanes,
-			    u32 phandle)
+static int add_pcie_serdes_lines(struct dts_node *root, int id, int lanes,
+				 u32 phandle)
 {
 	char serdes_lane[SERDES_LINE_NAME_LEN];
 	struct dts_node node;
@@ -481,18 +481,18 @@ static int add_serdes_lines(struct dts_node *root, int id, int lanes,
 	return 0;
 }
 
-static int set_serdes_lines(struct dts_node *node, int id)
+static int set_pcie_serdes_lines(struct dts_node *node, int id)
 {
 	enum serdes_mode mode;
 	u32 phandle;
 	int ret, lanes = 0;
 	struct dts_node serdes, root = *node;
 
-	mode = s32_serdes_get_op_mode_from_hwconfig(id);
+	mode = s32_serdes_get_serdes_mode_from_hwconfig(id);
 	if (mode == SERDES_MODE_PCIE_PCIE)
 		lanes = 2;
 
-	if (mode == SERDES_MODE_PCIE_SGMII0 || mode == SERDES_MODE_PCIE_SGMII1)
+	if (mode == SERDES_MODE_PCIE_XPCS0 || mode == SERDES_MODE_PCIE_XPCS1)
 		lanes = 1;
 
 	if (!lanes) {
@@ -513,7 +513,7 @@ static int set_serdes_lines(struct dts_node *node, int id)
 		return ret;
 	}
 
-	ret = add_serdes_lines(&root, id, lanes, phandle);
+	ret = add_pcie_serdes_lines(&root, id, lanes, phandle);
 	if (ret)
 		return ret;
 
@@ -549,11 +549,11 @@ static int skip_dts_node(struct dts_node *root, const char *alias_fmt, u32 id)
 
 static int skip_dts_nodes_config(struct dts_node *root, int id, bool *skip)
 {
-	int ret;
-	enum serdes_dev_type mode;
+	int ret = -EINVAL;
 	struct dts_node serdes;
 
-	*skip = false;
+	if (!skip || !root)
+		return ret;
 
 	ret = node_by_alias(root, &serdes, SERDES_ALIAS_FMT, id);
 	if (ret) {
@@ -565,13 +565,12 @@ static int skip_dts_nodes_config(struct dts_node *root, int id, bool *skip)
 	if (root->fdt)
 		return 0;
 
-	mode = s32_serdes_get_mode_from_hwconfig(id);
+	*skip = s32_serdes_get_skip_from_hwconfig(id);
 
-	if (!(mode & SERDES_SKIP))
+	if (!*skip)
 		return 0;
 
-	printf("Skipping configuration for SerDes%d.\n", id);
-	*skip = true;
+	printf("Skipping configuration for SerDes%d\n", id);
 
 	ret = skip_dts_node(root, PCIE_ALIAS_FMT, id);
 	if (ret)
@@ -648,7 +647,7 @@ static int prepare_pcie_node(struct dts_node *root, int id)
 	if (ret)
 		return ret;
 
-	ret = set_serdes_lines(&node, id);
+	ret = set_pcie_serdes_lines(&node, id);
 	if (ret)
 		return ret;
 
@@ -795,7 +794,7 @@ static int set_serdes_mode(struct dts_node *root, int id)
 	u32 mode_num;
 	struct dts_node node;
 
-	mode = s32_serdes_get_op_mode_from_hwconfig(id);
+	mode = s32_serdes_get_serdes_mode_from_hwconfig(id);
 	if (mode == SERDES_MODE_INVAL) {
 		pr_err("Invalid SerDes%d mode\n", id);
 		return -EINVAL;
@@ -1149,6 +1148,9 @@ static int apply_hwconfig_fixups(bool fdt, void *blob)
 		}
 
 		ret = skip_dts_nodes_config(&root, id, &skip);
+		/* Either if we manage to disable the node or not, go to next node
+		 * if 'skip' is true
+		 */
 		if (skip || ret)
 			continue;
 
diff --git a/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c b/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c
index 5111e25052..2736ec5331 100644
--- a/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c
+++ b/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c
@@ -11,34 +11,29 @@
 #include <linux/ethtool.h>
 #include <s32-cc/serdes_hwconfig.h>
 
-/* use a mask to fix DEVICE_TYPE for EP */
-#define SERDES_MODE(mode) ((mode) & 0xe)
-#define IS_SERDES_PCIE(mode) ((mode) & (PCIE_EP | PCIE_RC))
-#define IS_SERDES_SGMII(mode) ((mode) & (SGMII))
-
-#define SERDES_RC_MODE_STR "RootComplex"
-#define SERDES_EP_MODE_STR "EndPoint"
-#define SERDES_SGMII_MODE_STR "SGMII"
-#define SERDES_SGMII_MODE_NONE_STR "None"
-#define MODE5_TOKEN "mode5"
+#define IS_SERDES_PCIE(mode) ({ typeof(mode) _mode = (mode); \
+			      (_mode >= SERDES_MODE_PCIE_PCIE) && \
+			      (_mode < SERDES_MODE_XPCS0_XPCS1); })
+#define IS_SERDES_XPCS(mode) ({ typeof(mode) _mode = (mode); \
+			      (_mode >= SERDES_MODE_PCIE_XPCS0) && \
+			      (_mode <= SERDES_MODE_MAX); })
 
 #define SERDES_NAME_SIZE 32
 
 bool s32_serdes_is_pcie_enabled_in_hwconfig(int id)
 {
-	enum serdes_dev_type ss_mode;
+	enum serdes_mode ss_mode;
 
-	ss_mode = s32_serdes_get_mode_from_hwconfig(id);
+	ss_mode = s32_serdes_get_serdes_mode_from_hwconfig(id);
 	return IS_SERDES_PCIE(ss_mode);
 }
 
 bool s32_serdes_is_combo_mode_enabled_in_hwconfig(int id)
 {
-	enum serdes_dev_type ss_mode;
+	enum serdes_mode ss_mode;
 
-	ss_mode = s32_serdes_get_mode_from_hwconfig(id);
-	return IS_SERDES_PCIE(ss_mode) &&
-			IS_SERDES_SGMII(ss_mode);
+	ss_mode = s32_serdes_get_serdes_mode_from_hwconfig(id);
+	return IS_SERDES_PCIE(ss_mode) && IS_SERDES_XPCS(ss_mode);
 }
 
 bool s32_serdes_is_hwconfig_instance_enabled(int id)
@@ -67,11 +62,35 @@ bool s32_serdes_is_hwconfig_instance_enabled(int id)
 }
 
 static inline
-char *s32_serdes_get_hwconfig_subarg(int id,
-				     const char *subarg,
-				     size_t *subarg_len)
+char *s32_serdes_get_pcie_hwconfig_subarg(int id,
+					  const char *subarg,
+					  size_t *subarg_len)
 {
-	char serdes_name[SERDES_NAME_SIZE];
+	char serdes_name[SERDES_NAME_SIZE + 1];
+	char *subarg_str = NULL;
+
+	snprintf(serdes_name, SERDES_NAME_SIZE, "pcie%d", id);
+	debug("%s: testing hwconfig for '%s' option '%s'\n", __func__,
+	      serdes_name, subarg);
+	subarg_str = (char *)hwconfig_subarg(serdes_name, subarg,
+		subarg_len);
+
+	if (!subarg_str || !*subarg_len) {
+		debug("'%s' option '%s' not found in hwconfig\n",
+		      serdes_name, subarg);
+		return NULL;
+	}
+
+	debug("found '%s' argument '%s=%s\n'", serdes_name, subarg, subarg_str);
+	return subarg_str;
+}
+
+static inline
+char *s32_serdes_get_serdes_hwconfig_subarg(int id,
+					    const char *subarg,
+					    size_t *subarg_len)
+{
+	char serdes_name[SERDES_NAME_SIZE + 1];
 	char *subarg_str = NULL;
 
 	if (!subarg || !subarg_len)
@@ -82,126 +101,218 @@ char *s32_serdes_get_hwconfig_subarg(int id,
 	 * `x` is the ID.
 	 */
 	snprintf(serdes_name, SERDES_NAME_SIZE, "serdes%d", id);
-	debug("%s: testing hwconfig for '%s'\n", __func__,
-	      serdes_name);
+	debug("%s: testing hwconfig for '%s' option '%s'\n", __func__,
+	      serdes_name, subarg);
 
 	subarg_str = (char *)hwconfig_subarg(serdes_name, subarg, subarg_len);
 
 	if (!subarg_str || !*subarg_len) {
+#ifdef CONFIG_S32CC_HWCONFIG_LEGACY
 		/* Backwards compatibility:
 		 * Initially the SerDes mode was set by using option `pciex`.
 		 */
-		snprintf(serdes_name, SERDES_NAME_SIZE, "pcie%d", id);
-		debug("%s: testing hwconfig for '%s'\n", __func__,
-		      serdes_name);
-		subarg_str = (char *)hwconfig_subarg(serdes_name, subarg,
-			subarg_len);
+		char pcie_name[SERDES_NAME_SIZE + 1];
 
+		snprintf(pcie_name, SERDES_NAME_SIZE, "pcie%d", id);
+		subarg_str = s32_serdes_get_pcie_hwconfig_subarg(id, subarg,
+								 subarg_len);
+#endif
 		if (!subarg_str || !*subarg_len) {
-			debug("'serdes%d' option '%s' not found in hwconfig\n",
-			      id, subarg);
+			debug("'%s' option '%s' not found in hwconfig\n",
+			      serdes_name, subarg);
 			return NULL;
 		}
 	}
 
-	debug("found 'serdes%d' argument '%s=%s\n'", id, subarg, subarg_str);
+	debug("found '%s' argument '%s=%s\n'", serdes_name, subarg, subarg_str);
 	return subarg_str;
 }
 
-enum serdes_dev_type s32_serdes_get_mode_from_hwconfig(int id)
+static inline
+char *s32_serdes_get_xpcs_hwconfig_subarg(int serdes_id, int xpcs_id,
+					  const char *subarg,
+					  size_t *subarg_len)
 {
-	enum serdes_dev_type devtype = SERDES_INVALID;
+	char xpcs_name[SERDES_NAME_SIZE + 1];
+	char *subarg_str = NULL;
+
+	snprintf(xpcs_name, SERDES_NAME_SIZE, "xpcs%d_%d", serdes_id, xpcs_id);
+	debug("%s: testing hwconfig for '%s' option '%s'\n", __func__,
+	      xpcs_name, subarg);
+	subarg_str = (char *)hwconfig_subarg(xpcs_name, subarg,
+					     subarg_len);
+
+	if (!subarg_str || !*subarg_len) {
+#ifdef CONFIG_S32CC_HWCONFIG_LEGACY
+		/* Backwards compatibility:
+		 * Initially the XPCS mode was set by using option `pciex`.
+		 */
+		subarg_str = s32_serdes_get_pcie_hwconfig_subarg(serdes_id,
+								 subarg,
+								 subarg_len);
+#endif
+		if (!subarg_str || !*subarg_len) {
+			debug("'%s' option '%s' not found in hwconfig\n",
+			      xpcs_name, subarg);
+			return NULL;
+		}
+	}
+
+	debug("found '%s' argument '%s=%s\n'", xpcs_name,
+	      subarg, subarg_str);
+	return subarg_str;
+}
+
+enum pcie_type s32_serdes_get_pcie_type_from_hwconfig(int id)
+{
+	enum pcie_type pcietype = PCIE_INVALID;
 	size_t subarg_len = 0;
-	char *option_str = s32_serdes_get_hwconfig_subarg(id, "mode",
+	char *option_str = s32_serdes_get_pcie_hwconfig_subarg(id, "mode",
 		&subarg_len);
 
 	if (!option_str || !subarg_len)
-		return SERDES_INVALID;
+		return PCIE_INVALID;
 
 	/* 'mode' option */
 	if (!strncmp(option_str, "rc", subarg_len))
-		devtype = PCIE_RC;
+		pcietype = PCIE_RC;
 	else if (!strncmp(option_str, "ep", subarg_len))
-		devtype = PCIE_EP;
-	else if (!strncmp(option_str, "sgmii", subarg_len))
-		devtype = SGMII;
+		pcietype = PCIE_EP;
+	else if (!strncmp(option_str, "rc&xpcs", strlen("rc&xpcs")))
+		pcietype = PCIE_RC;
+	else if (!strncmp(option_str, "ep&xpcs", strlen("ep&xpcs")))
+		pcietype = PCIE_EP;
+#ifdef CONFIG_S32CC_HWCONFIG_LEGACY
 	else if (!strncmp(option_str, "rc&sgmii", subarg_len))
-		devtype = (enum serdes_dev_type)((u32)PCIE_RC | (u32)SGMII);
+		pcietype = PCIE_RC;
 	else if (!strncmp(option_str, "ep&sgmii", subarg_len))
-		devtype = (enum serdes_dev_type)((u32)PCIE_EP | (u32)SGMII);
+		pcietype = PCIE_EP;
+#endif
 
-	/* 'skip' option */
-	option_str = s32_serdes_get_hwconfig_subarg(id, "skip", &subarg_len);
-	if (option_str && devtype != SERDES_INVALID &&
-	    (!strncmp(option_str, "true", subarg_len) ||
-	    !strncmp(option_str, "1", subarg_len)))
-		devtype |= SERDES_SKIP;
+	debug("found pcie%d mode %d\n", id, pcietype);
+	return pcietype;
+}
 
-	return devtype;
+bool s32_serdes_get_skip_from_hwconfig(int id)
+{
+	bool skip = false;
+	size_t subarg_len = 0;
+	char *option_str = s32_serdes_get_serdes_hwconfig_subarg(id, "skip",
+								 &subarg_len);
+	if (option_str &&
+	    !strncmp(option_str, "1", subarg_len))
+		skip = true;
+
+	debug("found serdes%d skip %d\n", id, skip);
+	return skip;
 }
 
-enum serdes_xpcs_mode s32_serdes_get_xpcs_cfg_from_hwconfig(int id)
+int s32_serdes_get_xpcs_speed_from_hwconfig(int serdes_id,
+					    int xpcs_id)
 {
 	/* Set default mode to invalid to force configuration */
-	enum serdes_xpcs_mode xpcs_mode = SGMII_INAVALID;
+	int speed = SPEED_UNKNOWN;
 	size_t subarg_len = 0;
-	char *option_str = s32_serdes_get_hwconfig_subarg(id, "xpcs_mode",
-		&subarg_len);
+	char *option_str = s32_serdes_get_xpcs_hwconfig_subarg(serdes_id,
+							       xpcs_id,
+							       "speed",
+							       &subarg_len);
+	if (!option_str || !subarg_len) {
+#ifdef CONFIG_S32CC_HWCONFIG_LEGACY
+		option_str = s32_serdes_get_pcie_hwconfig_subarg(serdes_id,
+								 "xpcs_mode",
+								 &subarg_len);
+		if (!option_str || !subarg_len)
+			return speed;
+
+		if (xpcs_id == 0 && !strncmp(option_str, "0", subarg_len))
+			speed = SPEED_1000;
+		else if (xpcs_id == 1 && !strncmp(option_str, "1", subarg_len))
+			speed = SPEED_1000;
+		else if (!strncmp(option_str, "both", subarg_len))
+			speed = SPEED_1000;
+		else if (xpcs_id == 0 && !strncmp(option_str, "2G5",
+						  subarg_len))
+			speed = SPEED_2500;
+#endif
+		debug("found xpcs%d_%d speed %d\n", serdes_id, xpcs_id, speed);
+		return speed;
+	}
 
-	if (!option_str || !subarg_len)
-		return xpcs_mode;
-
-	if (!strncmp(option_str, "0", subarg_len))
-		xpcs_mode = SGMII_XPCS0;
-	else if (!strncmp(option_str, "1", subarg_len))
-		xpcs_mode = SGMII_XPCS1;
-	else if (!strncmp(option_str, "both", subarg_len))
-		xpcs_mode = SGMII_XPCS0_XPCS1;
+	if (!strncmp(option_str, "10M", subarg_len))
+		speed = SPEED_10;
+	else if (!strncmp(option_str, "100M", subarg_len))
+		speed = SPEED_100;
+	else if (!strncmp(option_str, "1G", subarg_len))
+		speed = SPEED_1000;
 	else if (!strncmp(option_str, "2G5", subarg_len))
-		xpcs_mode = SGMII_XPCS0_2G5;
+		speed = SPEED_2500;
 
+	debug("found xpcs%d_%d speed %d\n", serdes_id, xpcs_id, speed);
+	return speed;
+}
+
+enum serdes_xpcs_mode s32_serdes_get_xpcs_cfg_from_hwconfig(int serdes_id,
+							    int xpcs_id)
+{
+	/* Set default mode to invalid to force configuration */
+	enum serdes_xpcs_mode xpcs_mode = SGMII_INVALID;
+	int speed = s32_serdes_get_xpcs_speed_from_hwconfig(serdes_id, xpcs_id);
+
+	switch (speed) {
+	case SPEED_10:
+	case SPEED_100:
+	case SPEED_1000:
+		xpcs_mode = SGMII_XPCS_1G;
+		break;
+	case SPEED_2500:
+		xpcs_mode = SGMII_XPCS_2G5;
+		break;
+	}
+
+	debug("found xpcs%d_%d mode %d\n", serdes_id, xpcs_id, xpcs_mode);
 	return xpcs_mode;
 }
 
 bool s32_serdes_is_external_clk_in_hwconfig(int id)
 {
 	size_t subarg_len = 0;
-	char *option_str = s32_serdes_get_hwconfig_subarg(id, "clock",
+	bool ext = false;
+	char *option_str = s32_serdes_get_serdes_hwconfig_subarg(id, "clock",
 		&subarg_len);
 
 	if (!option_str || !subarg_len)
 		return false;
 
 	if (!strncmp(option_str, "ext", subarg_len))
-		return true;
-	else if (!strncmp(option_str, "int", subarg_len))
-		return false;
+		ext = true;
 
-	return false;
+	debug("found serdes%d ext clock %d\n", id, ext);
+	return ext;
 }
 
 unsigned long s32_serdes_get_clock_fmhz_from_hwconfig(int id)
 {
 	size_t subarg_len = 0;
-	char *option_str = s32_serdes_get_hwconfig_subarg(id, "fmhz",
+	unsigned long fmhz = MHZ_100;
+	char *option_str = s32_serdes_get_serdes_hwconfig_subarg(id, "fmhz",
 		&subarg_len);
 
 	if (!option_str || !subarg_len)
-		return MHZ_100;
+		return fmhz;
 
-	if (!strncmp(option_str, "100", subarg_len))
-		return MHZ_100;
-	else if (!strncmp(option_str, "125", subarg_len))
-		return MHZ_125;
+	if (!strncmp(option_str, "125", subarg_len))
+		fmhz = MHZ_125;
 
-	return MHZ_100;
+	debug("found serdes%d fmhz %lu\n", id, fmhz);
+	return fmhz;
 }
 
-enum pcie_phy_mode s32_serdes_get_phy_mode_from_hwconfig(int id)
+enum pcie_phy_mode s32_serdes_get_pcie_phy_mode_from_hwconfig(int id)
 {
 	enum pcie_phy_mode phy_mode = CRNS;
 	size_t subarg_len = 0;
-	char *option_str = s32_serdes_get_hwconfig_subarg(id, "phy_mode",
+	char *option_str = s32_serdes_get_pcie_hwconfig_subarg(id, "phy_mode",
 		&subarg_len);
 
 	if (!option_str || !subarg_len)
@@ -212,152 +323,160 @@ enum pcie_phy_mode s32_serdes_get_phy_mode_from_hwconfig(int id)
 	else if (!strncmp(option_str, "sris", subarg_len))
 		phy_mode = SRIS;
 
+	debug("found pcie%d phy mode %d\n", id, phy_mode);
 	return phy_mode;
 }
 
-enum serdes_mode s32_serdes_get_op_mode_from_hwconfig(int id)
+enum serdes_mode s32_serdes_get_serdes_mode_from_hwconfig(int id)
 {
-	enum serdes_dev_type mode;
-	enum serdes_xpcs_mode xpcs_mode;
-	enum pcie_phy_mode ss_mode;
-
-	mode = s32_serdes_get_mode_from_hwconfig(id);
-	ss_mode = s32_serdes_get_phy_mode_from_hwconfig(id);
-	xpcs_mode = s32_serdes_get_xpcs_cfg_from_hwconfig(id);
+	size_t subarg_len = 0;
+	char *option_str = s32_serdes_get_serdes_hwconfig_subarg(id, "mode",
+		&subarg_len);
 
-	/* Do not configure SRIS or CRSS PHY MODE in conjunction
-	 * with any SGMII mode on the same SerDes subsystem
+	/* Get the 'mode' substring for 'serdesx'. Supported values are:
+	 * 'pcie', 'pcie&xpcsX' (X=0,1), 'xpcs0' or 'xpcs0&xpcs1' (no 'xpcs1').
+	 * If legacy support is enabled, it will get 'mode' from 'pciex'.
+	 * Either way, this should not fail.
 	 */
-	if (ss_mode == CRSS || ss_mode == SRIS) {
-		if (IS_SERDES_PCIE(mode) && !IS_SERDES_SGMII(mode))
-			return SERDES_MODE_PCIE_PCIE;
-
+	if (!option_str || !subarg_len)
 		return SERDES_MODE_INVAL;
-	}
 
-	if (IS_SERDES_PCIE(mode) && !IS_SERDES_SGMII(mode))
+	if (!strncmp(option_str, "pcie", subarg_len))
 		return SERDES_MODE_PCIE_PCIE;
 
-	if (IS_SERDES_PCIE(mode) && IS_SERDES_SGMII(mode)) {
-		/* Configure SS mode based on XPCS: modes 1 & 2 */
-		if (xpcs_mode == SGMII_XPCS0)
-			return SERDES_MODE_PCIE_SGMII0;
-
-		if (xpcs_mode == SGMII_XPCS1)
-			return SERDES_MODE_PCIE_SGMII1;
+	/* SS mode based on XPCS: modes 1, 2 or 5 */
+	if (!strncmp(option_str, "pcie&xpcs0", subarg_len))
+		return SERDES_MODE_PCIE_XPCS0;
+	if (!strncmp(option_str, "pcie&xpcs1", subarg_len))
+		return SERDES_MODE_PCIE_XPCS1;
 
-		return SERDES_MODE_INVAL;
-	}
+	/* Modes 3 or 4; we currently use only 3.
+	 * Mode 4 would go with "xpcs1" only, but it has not been validated.
+	 */
+	if (!strncmp(option_str, "xpcs0", subarg_len) ||
+	    !strncmp(option_str, "xpcs0&xpcs1", subarg_len))
+		return SERDES_MODE_XPCS0_XPCS1;
 
-	/* Mode 3 */
-	if (!IS_SERDES_PCIE(mode) && IS_SERDES_SGMII(mode))
-		return SERDES_MODE_SGMII_SGMII;
+#ifdef CONFIG_S32CC_HWCONFIG_LEGACY
+	/* Legacy options were 'rc', 'ep', 'sgmii' and combinations. */
+	if (!strncmp(option_str, "rc", subarg_len))
+		return SERDES_MODE_PCIE_PCIE;
+	else if (!strncmp(option_str, "ep", subarg_len))
+		return SERDES_MODE_PCIE_PCIE;
+	else if (!strncmp(option_str, "rc&sgmii", subarg_len))
+		return SERDES_MODE_PCIE_XPCS0;
+	else if (!strncmp(option_str, "ep&sgmii", subarg_len))
+		return SERDES_MODE_PCIE_XPCS0;
+	else if (!strncmp(option_str, "sgmii", subarg_len))
+		return SERDES_MODE_XPCS0_XPCS1;
+#endif
 
 	return SERDES_MODE_INVAL;
 }
 
 bool s32_serdes_is_mode5_enabled_in_hwconfig(int id)
 {
-	size_t demo_len = 0;
-	char *demo;
-
-	demo = s32_serdes_get_hwconfig_subarg(id, "demo", &demo_len);
-
-	if (!demo || !demo_len)
-		return false;
+	enum serdes_xpcs_mode xpcs1_mode;
+	enum serdes_mode mode;
 
-	if (strncmp(demo, MODE5_TOKEN, sizeof(MODE5_TOKEN) - 1))
-		return false;
+	xpcs1_mode = s32_serdes_get_xpcs_cfg_from_hwconfig(id, 1);
+	mode = s32_serdes_get_serdes_mode_from_hwconfig(id);
 
-	return true;
+	return (mode == SERDES_MODE_PCIE_XPCS1 && xpcs1_mode == SGMII_XPCS_2G5);
 }
 
 bool s32_serdes_is_cfg_valid(int id)
 {
-	enum serdes_dev_type devtype;
-	enum serdes_xpcs_mode xpcs_mode;
+	enum serdes_xpcs_mode xpcs0_mode, xpcs1_mode;
 	enum serdes_mode mode;
 	enum pcie_phy_mode phy_mode;
 	unsigned long freq;
-	bool mode5, ext_clk;
+	bool ext_clk;
+	char prefix[SERDES_NAME_SIZE + 1];
 
 	ext_clk = s32_serdes_is_external_clk_in_hwconfig(id);
 	freq = s32_serdes_get_clock_fmhz_from_hwconfig(id);
-	devtype = s32_serdes_get_mode_from_hwconfig(id);
-	xpcs_mode = s32_serdes_get_xpcs_cfg_from_hwconfig(id);
-	mode = s32_serdes_get_op_mode_from_hwconfig(id);
-	phy_mode = s32_serdes_get_phy_mode_from_hwconfig(id);
+	xpcs0_mode = s32_serdes_get_xpcs_cfg_from_hwconfig(id, 0);
+	xpcs1_mode = s32_serdes_get_xpcs_cfg_from_hwconfig(id, 1);
+	mode = s32_serdes_get_serdes_mode_from_hwconfig(id);
+	phy_mode = s32_serdes_get_pcie_phy_mode_from_hwconfig(id);
+	snprintf(prefix, SERDES_NAME_SIZE, "SerDes%d: 'hwconfig':", id);
 
 	if (mode == SERDES_MODE_INVAL) {
-		printf("Invalid opmode config on SerDes%d\n", id);
+		printf("%s Invalid mode configuration\n", prefix);
 		return false;
 	}
 
-	if (devtype == SERDES_INVALID) {
-		printf("Invalid SerDes%d configuration\n", id);
+	if (IS_SERDES_PCIE(mode) && freq == MHZ_125) {
+		printf("%s In PCIe/XPCS combo mode", prefix);
+		printf(" reference clock has to be 100Mhz\n");
 		return false;
 	}
 
-	if (IS_SERDES_PCIE(devtype) && freq == MHZ_125) {
-		printf("Invalid \"hwconfig\": In PCIe/SGMII combo");
-		printf(" reference clock has to be 100Mhz\n");
-		/* SGMII configuration fail */
+	if (phy_mode != CRNS && mode != SERDES_MODE_PCIE_PCIE) {
+		printf("%s Only CRNS PHY mode can be used for PCIe/XPCS combo mode",
+		       prefix);
 		return false;
 	}
 
-	if (IS_SERDES_SGMII(devtype) && xpcs_mode == SGMII_INAVALID) {
-		printf("Invalid \"hwconfig\": \"xpcs_mode\" is missing\n");
-		/* SGMII configuration fail */
+	if (!ext_clk && (phy_mode == CRSS || phy_mode == SRIS)) {
+		printf("%s CRSS or SRIS mode for PCIe PHY", prefix);
+		printf(" cannot be used with internal clock\n");
 		return false;
 	}
 
-	/* validate that required 'mode' does not interfere
-	 * with 'hwconfig'
-	 */
-	switch (mode & ~(uint32_t)(SERDES_SKIP)) {
-	case SERDES_MODE_PCIE_PCIE:
-		/* only PCIE, no SGMII for this mode */
-		if (!IS_SERDES_PCIE(devtype) || IS_SERDES_SGMII(devtype)) {
-			printf("SGMII isn't allowed when using PCIe mode\n");
-			return false;
-		}
-		break;
-	/* Will have to figure out how to handle SERDES_MODE_SGMII_PCIE
-	 * and SERDES_MODE_PCIE_SGMII, since lane assignment may differ.
-	 */
-	case SERDES_MODE_PCIE_SGMII0:
-	case SERDES_MODE_PCIE_SGMII1:
-		if (!IS_SERDES_PCIE(devtype) || !IS_SERDES_SGMII(devtype)) {
-			printf("The SerDes mode is incompletely described\n");
-			return false;
-		}
-		break;
-	case SERDES_MODE_SGMII_SGMII:
-		if (IS_SERDES_PCIE(devtype) || !IS_SERDES_SGMII(devtype)) {
-			printf("The SerDes mode is incompletely described\n");
-			return false;
-		}
-		break;
-	default:
+	/* Mode 0 - Only PCIE, no XPCS config for this mode */
+	if (mode == SERDES_MODE_PCIE_PCIE &&
+	    xpcs0_mode != SGMII_INVALID && xpcs1_mode != SGMII_INVALID) {
+		printf("%s No XPCS allowed when using PCIe mode\n", prefix);
 		return false;
 	}
 
-	mode5 = s32_serdes_is_mode5_enabled_in_hwconfig(id);
-	if (mode5) {
-		if (!(ext_clk && freq == MHZ_100 &&
-		      xpcs_mode == SGMII_XPCS1)) {
-			pr_err("SerDes%d: Invalid mode5 demo configuration\n",
-			       id);
-			return false;
-		}
+	/* Mode 1 */
+	if (mode == SERDES_MODE_PCIE_XPCS0 && xpcs0_mode != SGMII_XPCS_1G) {
+		printf("%s Invalid xpcs%d_0 configuration for", prefix, id);
+		printf("  PCIe/XPCS0 combo mode\n");
+		return false;
+	}
+	if (mode == SERDES_MODE_PCIE_XPCS0 && xpcs1_mode != SGMII_INVALID) {
+		printf("%s No xpcs%d_1 configuration allowed for", prefix, id);
+		printf("  PCIe/XPCS0 combo mode\n");
+		return false;
 	}
 
-	if (!ext_clk) {
-		if (phy_mode == CRSS || phy_mode == SRIS) {
-			printf("SerDes%d: CRSS or SRIS for PCIe%d PHY mode cannot be used with internal clock\n",
-			       id, id);
-			return false;
-		}
+	/* Mode 2 and 5 */
+	if (mode == SERDES_MODE_PCIE_XPCS1 &&
+	    !(xpcs1_mode == SGMII_XPCS_1G || xpcs1_mode == SGMII_XPCS_2G5)) {
+		printf("%s Invalid xpcs%d_1 configuration for", prefix, id);
+		printf("  PCIe/XPCS1 combo mode\n");
+		return false;
+	}
+	if (mode == SERDES_MODE_PCIE_XPCS1 && xpcs0_mode != SGMII_INVALID) {
+		printf("%s No xpcs%d_0 configuration allowed for", prefix, id);
+		printf("  PCIe/XPCS1 combo mode\n");
+		return false;
+	}
+
+	/* Modes 3 and 4 */
+	/* We allow SERDES_MODE_XPCS0_XPCS1 only with xpcsX_0 configured,
+	 * as this was the only Mode3 2G5 configuration supported before S32G3
+	 */
+	if (mode == SERDES_MODE_XPCS0_XPCS1 && xpcs0_mode == SGMII_INVALID) {
+		printf("%s Invalid xpcs configuration for", prefix);
+		printf("  XPCS1 only mode\n");
+		return false;
+	}
+	if (mode == SERDES_MODE_XPCS0_XPCS1 && xpcs0_mode == SGMII_XPCS_1G &&
+	    xpcs1_mode == SGMII_INVALID) {
+		printf("%s Invalid xpcs configuration for", prefix);
+		printf("  XPCS1 only mode\n");
+		return false;
+	}
+	if (mode == SERDES_MODE_XPCS1_ONLY && (xpcs0_mode != SGMII_INVALID ||
+	    xpcs1_mode == SGMII_INVALID)) {
+		printf("%s Invalid xpcs configuration for", prefix);
+		printf("  XPCS1 only mode\n");
+		return false;
 	}
 
 	return true;
@@ -383,15 +502,18 @@ int s32_serdes_get_alias_id(struct udevice *serdes_dev, int *devnump)
 	return ret;
 }
 
-int s32_serdes_get_lane_speed(struct udevice *serdes_dev, u32 lane)
+int s32_serdes_get_lane_speed(struct udevice *serdes_dev, u32 xpcs_id)
 {
-	enum serdes_xpcs_mode xpcs_mode;
+	int speed;
 	int serdes_id = 0;
 	int ret;
 
 	if (!serdes_dev)
 		return -EINVAL;
 
+	if (xpcs_id > 1)
+		return -EINVAL;
+
 	ret = s32_serdes_get_alias_id(serdes_dev, &serdes_id);
 	if (ret < 0) {
 		printf("Failed to get SerDes device id for device %s:\n",
@@ -399,31 +521,9 @@ int s32_serdes_get_lane_speed(struct udevice *serdes_dev, u32 lane)
 		return ret;
 	}
 
-	xpcs_mode = s32_serdes_get_xpcs_cfg_from_hwconfig(serdes_id);
-	switch (xpcs_mode) {
-	/* XPCS is on lane1 when using ss mode = 1 or 2 */
-	case SGMII_XPCS0:
-		if (lane)
-			return SPEED_1000;
-		break;
-	case SGMII_XPCS1:
-		if (lane) {
-			if (s32_serdes_is_mode5_enabled_in_hwconfig(serdes_id))
-				return SPEED_2500;
-			return SPEED_1000;
-		}
-		break;
-	case SGMII_XPCS0_XPCS1:
-		if (!lane || lane == 1)
-			return SPEED_1000;
-		break;
-	case SGMII_XPCS0_2G5:
-		if (!lane)
-			return SPEED_2500;
-		break;
-	case SGMII_INAVALID:
-		return -EINVAL;
-	}
+	speed = s32_serdes_get_xpcs_speed_from_hwconfig(serdes_id, xpcs_id);
+	debug("SerDes%d: hwconfig: xpcs%d_%d has speed %d\n",
+	      serdes_id, serdes_id, xpcs_id, speed);
 
-	return -EINVAL;
+	return speed;
 }
-- 
2.17.1

