From 2db0315aee251baacce8bf82cac9290fee2553f5 Mon Sep 17 00:00:00 2001
From: Ionut Vicovan <Ionut.Vicovan@nxp.com>
Date: Tue, 1 Nov 2022 14:11:48 +0200
Subject: [PATCH 06/19] s32cc: pcie: Group all device tree related checks in
 one place

Move the check for the SerDes presence to
's32_pcie_get_config_from_device_tree', where all the other
device tree related tasks are performed.

Issue: ALB-9211

Upstream-Status: Pending 

Signed-off-by: Ionut Vicovan <Ionut.Vicovan@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/pci/pcie_s32gen1.c | 79 +++++++++++++++++++-------------------
 1 file changed, 40 insertions(+), 39 deletions(-)

diff --git a/drivers/pci/pcie_s32gen1.c b/drivers/pci/pcie_s32gen1.c
index 8fae1f7e41..7a0e417969 100644
--- a/drivers/pci/pcie_s32gen1.c
+++ b/drivers/pci/pcie_s32gen1.c
@@ -784,6 +784,33 @@ static int s32_pcie_get_hw_mode_ep(struct s32_pcie *pcie)
 	return (header_type & 0x7f) == PCI_HEADER_TYPE_NORMAL;
 }
 
+static int s32gen1_check_serdes(struct udevice *dev)
+{
+	struct nvmem_cell c;
+	int ret;
+	u32 serdes_presence = 0;
+
+	ret = nvmem_cell_get(dev, "serdes_presence", &c);
+	if (ret) {
+		printf("Failed to get 'serdes_presence' cell\n");
+		return ret;
+	}
+
+	ret = nvmem_cell_read(&c, &serdes_presence, sizeof(serdes_presence));
+	if (ret) {
+		printf("%s: Failed to read cell 'serdes_presence' (err = %d)\n",
+		       __func__, ret);
+		return ret;
+	}
+
+	if (!serdes_presence) {
+		printf("SerDes Subsystem not present, skipping PCIe config\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
 static int s32_pcie_get_config_from_device_tree(struct s32_pcie *pcie)
 {
 	struct udevice *dev = pcie->bus;
@@ -794,6 +821,11 @@ static int s32_pcie_get_config_from_device_tree(struct s32_pcie *pcie)
 
 	debug("%s: dt node: %s\n", __func__, dev_read_name(dev));
 
+	/* check if serdes is enabled for the pcie node */
+	ret = s32gen1_check_serdes(dev);
+	if (ret)
+		return ret;
+
 	ret = generic_phy_get_by_name(dev, "serdes_lane0", &pcie->phy0);
 	if (ret) {
 		printf("Failed to get 'serdes_lane0' PHY\n");
@@ -1041,33 +1073,6 @@ static int s32_pcie_probe_ep(struct s32_pcie *pcie, struct uclass *uc)
 	return 0;
 }
 
-static int s32gen1_check_serdes(struct udevice *dev)
-{
-	struct nvmem_cell c;
-	int ret;
-	u32 serdes_presence = 0;
-
-	ret = nvmem_cell_get(dev, "serdes_presence", &c);
-	if (ret) {
-		printf("Failed to get 'serdes_presence' cell\n");
-		return ret;
-	}
-
-	ret = nvmem_cell_read(&c, &serdes_presence, sizeof(serdes_presence));
-	if (ret) {
-		printf("%s: Failed to read cell 'serdes_presence' (err = %d)\n",
-		       __func__, ret);
-		return ret;
-	}
-
-	if (!serdes_presence) {
-		printf("SerDes Subsystem not present, skipping PCIe config\n");
-		return -ENODEV;
-	}
-
-	return 0;
-}
-
 static int init_pcie_phy(struct s32_pcie *pcie)
 {
 	struct udevice *dev = pcie->bus;
@@ -1151,26 +1156,19 @@ static int s32_pcie_probe(struct udevice *dev)
 	bool ltssm_en = false;
 	u32 variant_bits, pcie_dev_id;
 
-	if (!pcie)
+	if (!pcie) {
+		printf("PCIe%d: invalid internal data\n", pcie->id);
 		return -EINVAL;
+	}
 
 	pcie->enabled = false;
 	pcie->ep_mode =
 		(enum pcie_device_mode)dev_get_driver_data(dev) == PCIE_EP_TYPE;
 
-	ret = s32gen1_check_serdes(dev);
-	if (ret)
-		return ret;
-
 	debug("%s: probing %s as %s\n", __func__, dev->name,
 	      PCIE_EP_RC_MODE(pcie->ep_mode));
-	if (!pcie) {
-		printf("PCIe%d: invalid internal data\n", pcie->id);
-		return -EINVAL;
-	}
 
 	pcie->bus = dev;
-
 	list_add(&pcie->list, &s32_pcie_list);
 
 	ret = s32_pcie_get_config_from_device_tree(pcie);
@@ -1181,6 +1179,11 @@ static int s32_pcie_probe(struct udevice *dev)
 	if (ret)
 		return ret;
 
+	if (pcie->ep_mode != s32_pcie_get_hw_mode_ep(pcie)) {
+		printf("PCIe%d: RC/EP configuration not set correctly\n",
+				pcie->id);
+	}
+
 	/*
 	 * it makes sense to link up only as RC, as the EP
 	 * may boot earlier
@@ -1215,8 +1218,6 @@ static int s32_pcie_probe(struct udevice *dev)
 		return ret;
 	}
 
-	pcie->ep_mode = s32_pcie_get_hw_mode_ep(pcie);
-
 	variant_bits = s32_pcie_get_dev_id_variant(dev);
 	s32_pcie_enable_dbi_rw(pcie->dbi);
 	if (variant_bits == PCI_DEVICE_ID_S32GEN1) {
-- 
2.17.1

