From 5302ade297eae4b1b236315546e04948f6f33c9c Mon Sep 17 00:00:00 2001
From: Ionut Vicovan <Ionut.Vicovan@nxp.com>
Date: Wed, 2 Nov 2022 00:06:30 +0200
Subject: [PATCH 09/19] s32cc: pcie: Update access to config space

Access to config space 0 and 1 should not rely on the fact that PCIe devices
get a seq number next to their parent's.
In some corner cases (e.g. PCIe0 with no EP or partially configured), PCIe0 bridge
may receive a seq number between PCIe1 bridge and PCIe1 devices. In this case,
PCIe1 devices are searched incorrectly in config space 1 and are not discovered.
For these unusual situations, make sure config space 0 is used for the lowest
seq number, then config space 1.

Issue: ALB-9211

Upstream-Status: Pending 

Signed-off-by: Ionut Vicovan <Ionut.Vicovan@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/pci/pcie_s32gen1.c | 39 +++++++++++++++++++++++++++++++++-----
 drivers/pci/pcie_s32gen1.h |  1 +
 2 files changed, 35 insertions(+), 5 deletions(-)

diff --git a/drivers/pci/pcie_s32gen1.c b/drivers/pci/pcie_s32gen1.c
index 5e5e8598cf..0aff8efea7 100644
--- a/drivers/pci/pcie_s32gen1.c
+++ b/drivers/pci/pcie_s32gen1.c
@@ -329,14 +329,42 @@ int s32_pcie_conf_address(const struct udevice *bus, pci_dev_t bdf,
 			  uint offset, void **paddress)
 {
 	struct s32_pcie *pcie = dev_get_priv(bus);
+	bool use_cfg0 = (PCI_BUS(bdf) > bus->seq);
+
+	if (!pcie)
+		return -EINVAL;
+
+	if (s32_pcie_addr_valid(pcie, bdf))
+		return -EINVAL;
+
+	if (PCI_BUS(bdf) < pcie->id) {
+		debug_wr("%s: (0x%x, %d): invalid bus\n", __func__,
+				PCI_BUS(bdf), bus->seq);
+		return -EINVAL;
+	}
+
 #ifdef PCIE_OVERCONFIG_BUS
 	u32 busdev = PCIE_ATU_BUS(PCI_BUS(bdf) - bus->seq) |
 				 PCIE_ATU_DEV(PCI_DEV(bdf)) |
 				 PCIE_ATU_FUNC(PCI_FUNC(bdf));
+	debug("%s: bdf=0x%x; bus=%d; seq=%d; device=0x%x; func=0x%x\n",
+	       dev_read_name(bus), bdf, PCI_BUS(bdf), bus->seq,
+	       PCI_DEV(bdf), PCI_FUNC(bdf));
+#endif
+#ifdef PCIE_USE_CFG1
+	/* The process of enumeration must start with cfg0 space, as sequences
+	 * are not always consecutive to the parent's (depending how the
+	 * device tree is being parsed).
+	 * After cfg0 is covered, we go to cfg1, to search e.g. for devices
+	 * connected to PCIe switches.
+	 */
+	if (use_cfg0) {
+		if (pcie->cfg0_seq < 0)
+			pcie->cfg0_seq = PCI_BUS(bdf);
+		else if (pcie->cfg0_seq != PCI_BUS(bdf))
+			use_cfg0 = false;
+	}
 #endif
-
-	if (s32_pcie_addr_valid(pcie, bdf))
-		return -EINVAL;
 
 	if (PCI_BUS(bdf) == bus->seq) {
 		*paddress = (void *)(UPTR(pcie->dbi) + offset);
@@ -344,7 +372,7 @@ int s32_pcie_conf_address(const struct udevice *bus, pci_dev_t bdf,
 		return 0;
 	}
 
-	if (PCI_BUS(bdf) == bus->seq + 1) {
+	if (use_cfg0) {
 #ifdef PCIE_OVERCONFIG_BUS
 		debug_wr("%s: cfg0_set_busdev 0x%x\n", __func__, busdev);
 		s32_pcie_cfg0_set_busdev(pcie, busdev);
@@ -354,7 +382,7 @@ int s32_pcie_conf_address(const struct udevice *bus, pci_dev_t bdf,
 	} else {
 #ifdef PCIE_USE_CFG1
 #ifdef PCIE_OVERCONFIG_BUS
-		debug_wr("%s: cfg1_set_busdev %d\n", __func__, busdev);
+		debug_wr("%s: cfg1_set_busdev 0x%x\n", __func__, busdev);
 		s32_pcie_cfg1_set_busdev(pcie, busdev);
 #endif
 		*paddress = (void *)(UPTR(pcie->cfg1) + offset);
@@ -888,6 +916,7 @@ static int s32_pcie_get_config_from_device_tree(struct s32_pcie *pcie)
 
 #ifdef PCIE_USE_CFG1
 	pcie->cfg1 = pcie->cfg0 + resource_size(&pcie->cfg_res) / 2;
+	pcie->cfg0_seq = -ENODEV;
 #endif
 
 	/* get supported speed (Gen1/Gen2/Gen3) from device tree */
diff --git a/drivers/pci/pcie_s32gen1.h b/drivers/pci/pcie_s32gen1.h
index 3c34662679..6445a1f9e6 100644
--- a/drivers/pci/pcie_s32gen1.h
+++ b/drivers/pci/pcie_s32gen1.h
@@ -251,6 +251,7 @@ struct s32_pcie {
 	void __iomem *dbi;
 	void __iomem *cfg0;
 #ifdef PCIE_USE_CFG1
+	int cfg0_seq;
 	void __iomem *cfg1;
 #endif
 	int id;
-- 
2.17.1

