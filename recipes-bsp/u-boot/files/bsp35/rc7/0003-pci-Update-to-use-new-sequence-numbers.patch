From cb5c4d3296a0c781a7a9c97c7449abdb3432ad97 Mon Sep 17 00:00:00 2001
From: Simon Glass <sjg@chromium.org>
Date: Wed, 16 Dec 2020 21:20:18 -0700
Subject: [PATCH 03/19] pci: Update to use new sequence numbers

Now that we know the sequence number at bind time, there is no need for
special-case code in dm_pci_hose_probe_bus().

Issue: ALB-9211

Upstream-Status: Pending 

Signed-off-by: Simon Glass <sjg@chromium.org>
Signed-off-by: Ionut Vicovan <Ionut.Vicovan@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/pci/pci-uclass.c | 37 ++++++++++++++++++++++---------------
 drivers/pci/pci_auto.c   | 10 +++++-----
 2 files changed, 27 insertions(+), 20 deletions(-)

diff --git a/drivers/pci/pci-uclass.c b/drivers/pci/pci-uclass.c
index e2882e3b63..c6081bc822 100644
--- a/drivers/pci/pci-uclass.c
+++ b/drivers/pci/pci-uclass.c
@@ -12,6 +12,7 @@
 #include <asm/io.h>
 #include <dm/device-internal.h>
 #include <dm/lists.h>
+#include <dm/uclass-internal.h>
 #if defined(CONFIG_X86) && defined(CONFIG_HAVE_FSP)
 #include <asm/fsp/fsp_support.h>
 #endif
@@ -538,7 +539,7 @@ int pci_auto_config_devices(struct udevice *bus)
 		debug("%s: device %s\n", __func__, dev->name);
 		ret = dm_pciauto_config_device(dev);
 		if (ret < 0)
-			return ret;
+			return log_msg_ret("auto", ret);
 		max_bus = ret;
 		sub_bus = max(sub_bus, max_bus);
 
@@ -548,7 +549,7 @@ int pci_auto_config_devices(struct udevice *bus)
 	}
 	debug("%s: done\n", __func__);
 
-	return sub_bus;
+	return log_msg_ret("sub", sub_bus);
 }
 
 int pci_generic_mmap_write_config(
@@ -626,14 +627,9 @@ int dm_pci_hose_probe_bus(struct udevice *bus)
 	if (ret) {
 		debug("%s: Cannot probe bus %s: %d\n", __func__, bus->name,
 		      ret);
-		return ret;
+		return log_msg_ret("probe", ret);
 	}
-	if (sub_bus != bus->seq) {
-		printf("%s: Internal error, bus '%s' got seq %d, expected %d\n",
-		       __func__, bus->name, bus->seq, sub_bus);
-		return -EPIPE;
-	}
-	sub_bus = pci_get_bus_max();
+
 	dm_pciauto_postscan_setup_bridge(bus, sub_bus);
 
 	return sub_bus;
@@ -695,7 +691,7 @@ static int pci_find_and_bind_driver(struct udevice *parent,
 
 	if (ofnode_valid(node) && !ofnode_is_available(node)) {
 		debug("%s: Ignoring disabled device\n", __func__);
-		return -EPERM;
+		return log_msg_ret("dis", -EPERM);
 	}
 
 	start = ll_entry_start(struct pci_driver_entry, pci_driver_entry);
@@ -721,7 +717,7 @@ static int pci_find_and_bind_driver(struct udevice *parent,
 			 */
 			if (!(gd->flags & GD_FLG_RELOC) &&
 			    !(drv->flags & DM_FLAG_PRE_RELOC))
-				return -EPERM;
+				return log_msg_ret("pre", -EPERM);
 
 			/*
 			 * We could pass the descriptor to the driver as
@@ -749,7 +745,7 @@ static int pci_find_and_bind_driver(struct udevice *parent,
 	 * limited (ie: using Cache As RAM).
 	 */
 	if (!(gd->flags & GD_FLG_RELOC) && !bridge)
-		return -EPERM;
+		return log_msg_ret("notbr", -EPERM);
 
 	/* Bind a generic driver so that the device can be used */
 	sprintf(name, "pci_%x:%x.%x", parent->seq, PCI_DEV(bdf),
@@ -978,6 +974,16 @@ static int pci_uclass_pre_probe(struct udevice *bus)
 	      bus->parent->name);
 	hose = bus->uclass_priv;
 
+	/*
+	 * Set the sequence number, if device_bind() doesn't. We want control
+	 * of this so that numbers are allocated as devices are probed. That
+	 * ensures that sub-bus numbered is correct (sub-buses must get numbers
+	 * higher than their parents)
+	 */
+	if (bus->seq == -1) {
+		bus->seq = uclass_find_next_free_req_seq(UCLASS_PCI);
+	}
+
 	/* For bridges, use the top-level PCI controller */
 	if (!device_is_on_pci_bus(bus)) {
 		hose->ctlr = bus;
@@ -988,6 +994,7 @@ static int pci_uclass_pre_probe(struct udevice *bus)
 		parent_hose = dev_get_uclass_priv(bus->parent);
 		hose->ctlr = parent_hose->bus;
 	}
+
 	hose->bus = bus;
 	hose->first_busno = bus->seq;
 	hose->last_busno = bus->seq;
@@ -1005,14 +1012,14 @@ static int pci_uclass_post_probe(struct udevice *bus)
 	debug("%s: probing bus %d\n", __func__, bus->seq);
 	ret = pci_bind_bus_devices(bus);
 	if (ret)
-		return ret;
+		return log_msg_ret("bind", ret);
 
 	if (CONFIG_IS_ENABLED(PCI_PNP) &&
 	    (!hose->skip_auto_config_until_reloc ||
 	     (gd->flags & GD_FLG_RELOC))) {
 		ret = pci_auto_config_devices(bus);
 		if (ret < 0)
-			return log_msg_ret("pci auto-config", ret);
+			return log_msg_ret("cfg", ret);
 	}
 
 #if defined(CONFIG_X86) && defined(CONFIG_HAVE_FSP)
@@ -1032,7 +1039,7 @@ static int pci_uclass_post_probe(struct udevice *bus)
 	if ((gd->flags & GD_FLG_RELOC) && (bus->seq == 0)) {
 		ret = fsp_init_phase_pci();
 		if (ret)
-			return ret;
+			return log_msg_ret("fsp", ret);
 	}
 #endif
 
diff --git a/drivers/pci/pci_auto.c b/drivers/pci/pci_auto.c
index 28667bde8d..26e7590bb9 100644
--- a/drivers/pci/pci_auto.c
+++ b/drivers/pci/pci_auto.c
@@ -320,7 +320,7 @@ int dm_pciauto_config_device(struct udevice *dev)
 	bool enum_only = false;
 	struct udevice *ctlr = pci_get_controller(dev);
 	struct pci_controller *ctlr_hose = dev_get_uclass_priv(ctlr);
-	int n;
+	int ret;
 
 #ifdef CONFIG_PCI_ENUM_ONLY
 	enum_only = true;
@@ -340,10 +340,10 @@ int dm_pciauto_config_device(struct udevice *dev)
 		dm_pciauto_setup_device(dev, 2, pci_mem, pci_prefetch, pci_io,
 					enum_only);
 
-		n = dm_pci_hose_probe_bus(dev);
-		if (n < 0)
-			return n;
-		sub_bus = (unsigned int)n;
+		ret = dm_pci_hose_probe_bus(dev);
+		if (ret < 0)
+			return log_msg_ret("probe", ret);
+		sub_bus = ret;
 		break;
 
 	case PCI_CLASS_BRIDGE_CARDBUS:
-- 
2.17.1

