From 99eaa315d41557453ca98a803b4509ecf3f26290 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Tue, 23 Aug 2022 10:00:16 +0300
Subject: [PATCH 079/102] net: dwc: s32cc: Use dev_err for errors instead of
 printf

Issue: ALB-8357
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/net/dwc_eth_qos_s32cc.c | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/drivers/net/dwc_eth_qos_s32cc.c b/drivers/net/dwc_eth_qos_s32cc.c
index d6aa76c8a9..91855d7fd1 100644
--- a/drivers/net/dwc_eth_qos_s32cc.c
+++ b/drivers/net/dwc_eth_qos_s32cc.c
@@ -380,43 +380,43 @@ static int init_sgmii_phy(struct udevice *dev)
 
 	xpcs_ops = s32cc_xpcs_get_ops();
 	if (!xpcs_ops) {
-		printf("Failed to get XPCS ops\n");
+		dev_err(dev, "Failed to get XPCS ops\n");
 		return -EIO;
 	}
 
 	ret = generic_phy_get_by_name(dev, "gmac_xpcs", &xpcs_phy);
 	if (ret) {
-		printf("Failed to get 'gmac_xpcs' PHY\n");
+		dev_err(dev, "Failed to get 'gmac_xpcs' PHY\n");
 		return ret;
 	}
 
 	phy_speed = s32_serdes_get_lane_speed(xpcs_phy.dev, xpcs_phy.id);
 	if (phy_speed < 0) {
-		printf("Failed to get speed of XPCS for 'gmac_xpcs'");
+		dev_err(dev, "Failed to get speed of XPCS for 'gmac_xpcs'");
 		return ret;
 	}
 
 	ret = generic_phy_init(&xpcs_phy);
 	if (ret) {
-		printf("Failed to init 'gmac_xpcs' PHY\n");
+		dev_err(dev, "Failed to init 'gmac_xpcs' PHY\n");
 		return ret;
 	}
 
 	ret = generic_phy_power_on(&xpcs_phy);
 	if (ret) {
-		printf("Failed to power on 'gmac_xpcs' PHY\n");
+		dev_err(dev, "Failed to power on 'gmac_xpcs' PHY\n");
 		return ret;
 	}
 
 	ret = generic_phy_configure(&xpcs_phy, NULL);
 	if (ret) {
-		printf("Failed to configure 'gmac_xpcs' PHY\n");
+		dev_err(dev, "Failed to configure 'gmac_xpcs' PHY\n");
 		return ret;
 	}
 
 	xpcs = s32cc_phy2xpcs(&xpcs_phy);
 	if (!xpcs) {
-		printf("Failed to get XPCS instance of 'gmac_xpcs'\n");
+		dev_err(dev, "Failed to get XPCS instance of 'gmac_xpcs'\n");
 		return -EINVAL;
 	}
 
@@ -427,7 +427,7 @@ static int init_sgmii_phy(struct udevice *dev)
 	state.an_complete = 0;
 	ret = xpcs_ops->xpcs_config(xpcs, &state);
 	if (ret) {
-		printf("Failed to configure 'gmac_xpcs' PHY\n");
+		dev_err(dev, "Failed to configure 'gmac_xpcs' PHY\n");
 		return ret;
 	}
 
-- 
2.17.1

