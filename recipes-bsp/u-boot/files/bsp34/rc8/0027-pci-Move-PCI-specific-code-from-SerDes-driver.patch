From fe6757b4586815fe8febf9aaf89e6a6f4d37cc82 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Wed, 13 Jul 2022 16:56:04 +0300
Subject: [PATCH 027/102] pci: Move PCI specific code from SerDes driver

Issue: ALB-8357
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/pci/pcie_s32gen1.c   | 74 ++++++++++++++++++++++++---
 drivers/pci/serdes_s32gen1.c | 98 ++----------------------------------
 drivers/pci/serdes_s32gen1.h | 13 +----
 3 files changed, 74 insertions(+), 111 deletions(-)

diff --git a/drivers/pci/pcie_s32gen1.c b/drivers/pci/pcie_s32gen1.c
index 8a687f2bb8..3e42abcedc 100644
--- a/drivers/pci/pcie_s32gen1.c
+++ b/drivers/pci/pcie_s32gen1.c
@@ -561,8 +561,8 @@ static int s32_pcie_setup_ep(struct s32_pcie *pcie)
 	return ret;
 }
 
-bool s32_pcie_set_link_width(void __iomem *dbi,
-		int id, enum serdes_link_width linkwidth)
+static bool s32_pcie_set_link_width(void __iomem *dbi, int id,
+				    enum serdes_link_width linkwidth)
 {
 	s32_pcie_enable_dbi_rw(dbi);
 
@@ -596,8 +596,8 @@ static int s32_pcie_check_phy_mode(int id, const char *mode)
 	return hwconfig_subarg_cmp(pcie_name, "phy_mode", mode);
 }
 
-bool s32_pcie_init(void __iomem *dbi, int id, bool rc_mode,
-		enum serdes_link_width linkwidth)
+static bool s32_pcie_init(void __iomem *dbi, int id, bool rc_mode,
+			  enum serdes_link_width linkwidth)
 {
 	debug("PCIe%d: Configure %s\n", id, PCIE_EP_RC_MODE(!rc_mode));
 
@@ -807,6 +807,16 @@ static void s32_get_link_status(struct s32_pcie *pcie,
 		debug("PCIe%d: current X%d Gen%d\n", pcie->id, *width, *speed);
 }
 
+static void s32_pcie_disable_ltssm(void __iomem *dbi)
+{
+	BCLR32(UPTR(dbi) + SS_PE0_GEN_CTRL_3, LTSSM_EN);
+}
+
+static void s32_pcie_enable_ltssm(void __iomem *dbi)
+{
+	BSET32(UPTR(dbi) + SS_PE0_GEN_CTRL_3, LTSSM_EN);
+}
+
 static bool is_s32gen1_pcie_ltssm_enabled(struct s32_pcie *pcie)
 {
 	return (s32_dbi_readl(UPTR(pcie->dbi) + SS_PE0_GEN_CTRL_3) & LTSSM_EN);
@@ -856,6 +866,15 @@ static int s32_pcie_get_dev_id_variant(struct udevice *dev)
 	return variant_bits;
 }
 
+static bool s32_pcie_wait_link_up(void __iomem *dbi)
+{
+	int count = PCIE_LINK_UP_COUNT;
+
+	return (wait_read32((void __iomem *)(UPTR(dbi) + SS_PE0_LINK_DBG_2),
+			    SERDES_LINKUP_EXPECT, SERDES_LINKUP_MASK,
+			    count) == 0);
+}
+
 static int s32_pcie_probe_rc(struct s32_pcie *pcie)
 {
 	u32 speed, width;
@@ -895,10 +914,11 @@ static int s32_pcie_probe_ep(struct s32_pcie *pcie, struct uclass *uc)
 	if (width > pcie->linkwidth) {
 		/* Supported value in dtb is smaller */
 		/* Set new link width */
-		s32_serdes_disable_ltssm(pcie->dbi);
-		s32_pcie_set_link_width(pcie->dbi, pcie->id, pcie->linkwidth);
+		s32_pcie_disable_ltssm(pcie->dbi);
+		if (!s32_pcie_set_link_width(pcie->dbi, pcie->id, pcie->linkwidth))
+			return -EIO;
 
-		s32_serdes_enable_ltssm(pcie->dbi);
+		s32_pcie_enable_ltssm(pcie->dbi);
 	}
 
 	/* apply other custom settings (bars, iATU etc.) */
@@ -937,6 +957,7 @@ static int s32_pcie_probe(struct udevice *dev)
 	bool ltssm_en = false;
 	u32 soc_serdes_presence;
 	u32 variant_bits, pcie_dev_id;
+	enum serdes_dev_type devtype;
 	struct udevice *siul21_nvmem = NULL;
 	struct nvmem_cell cell;
 
@@ -983,6 +1004,45 @@ static int s32_pcie_probe(struct udevice *dev)
 	if (ret)
 		return ret;
 
+	devtype = s32_serdes_get_mode_from_hwconfig(pcie->id);
+	if (IS_SERDES_PCIE(devtype)) {
+		if (IS_SERDES_SGMII(devtype))
+			pcie->linkwidth = X1;
+
+		if (!s32_pcie_init(pcie->dbi, pcie->id, devtype & PCIE_RC,
+				   pcie->linkwidth))
+			return ret;
+
+		s32_pcie_enable_ltssm(pcie->dbi);
+	}
+
+	/*
+	 * it makes sense to link up only as RC, as the EP
+	 * may boot earlier
+	 */
+	if (devtype & PCIE_RC) {
+		if (s32_pcie_wait_link_up(pcie->dbi)) {
+			debug("SerDes%d: link is up (X%d)\n", pcie->id,
+			      pcie->linkwidth);
+		} else {
+			if (pcie->linkwidth > X1) {
+				/* Attempt to link at X1 */
+				pcie->linkwidth = X1;
+				s32_pcie_disable_ltssm(pcie->dbi);
+
+				if (!s32_pcie_set_link_width(pcie->dbi,
+							     pcie->id,
+							     pcie->linkwidth))
+					return ret;
+
+				s32_pcie_enable_ltssm(pcie->dbi);
+				if (s32_pcie_wait_link_up(pcie->dbi))
+					debug("SerDes%d: link is up (X%d)\n",
+					      pcie->id, pcie->linkwidth);
+			}
+		}
+	}
+
 	ltssm_en = is_s32gen1_pcie_ltssm_enabled(pcie);
 	if (!ltssm_en) {
 		printf("PCIe%d: Not configuring PCIe, PHY not configured\n",
diff --git a/drivers/pci/serdes_s32gen1.c b/drivers/pci/serdes_s32gen1.c
index b19cd0142d..e873e5a3b8 100644
--- a/drivers/pci/serdes_s32gen1.c
+++ b/drivers/pci/serdes_s32gen1.c
@@ -34,8 +34,8 @@
 
 static LIST_HEAD(s32_serdes_list);
 
-static int wait_read32(void __iomem *address, u32 expected,
-		       u32 mask, int read_attempts)
+int wait_read32(void __iomem *address, u32 expected,
+		u32 mask, int read_attempts)
 {
 	__maybe_unused u32 tmp;
 
@@ -52,16 +52,7 @@ static int wait_read32(void __iomem *address, u32 expected,
 	return 0;
 }
 
-bool s32_pcie_wait_link_up(void __iomem *dbi)
-{
-	int count = PCIE_LINK_UP_COUNT;
-
-	return (wait_read32((void __iomem *)(UPTR(dbi) + SS_PE0_LINK_DBG_2),
-			    SERDES_LINKUP_EXPECT, SERDES_LINKUP_MASK,
-			    count) == 0);
-}
-
-int s32_serdes_set_mode(void __iomem *dbi, int id, enum serdes_mode mode)
+static int s32_serdes_set_mode(void __iomem *dbi, int id, enum serdes_mode mode)
 {
 	enum serdes_dev_type devtype = s32_serdes_get_mode_from_hwconfig(id);
 
@@ -97,16 +88,6 @@ int s32_serdes_set_mode(void __iomem *dbi, int id, enum serdes_mode mode)
 	return 0;
 }
 
-void s32_serdes_disable_ltssm(void __iomem *dbi)
-{
-	BCLR32(UPTR(dbi) + SS_PE0_GEN_CTRL_3, LTSSM_EN);
-}
-
-void s32_serdes_enable_ltssm(void __iomem *dbi)
-{
-	BSET32(UPTR(dbi) + SS_PE0_GEN_CTRL_3, LTSSM_EN);
-}
-
 static int s32_serdes_assert_reset(struct s32_serdes *serdes)
 {
 	__maybe_unused struct udevice *dev = serdes->bus;
@@ -341,20 +322,6 @@ static bool s32_serdes_init(struct s32_serdes *pcie)
 	return true;
 }
 
-__weak bool s32_pcie_init(void __iomem *dbi, int id, bool rc_mode,
-		enum serdes_link_width linkwidth)
-{
-	printf("PCIe%d disabled\n", id);
-	return false;
-}
-
-__weak bool s32_pcie_set_link_width(void __iomem *dbi,
-		int id, enum serdes_link_width linkwidth)
-{
-	printf("PCIe%d disabled\n", id);
-	return false;
-}
-
 __weak int s32_eth_xpcs_init(void __iomem *dbi, int id,
 			     enum serdes_mode ss_mode,
 			     enum serdes_xpcs_mode xpcs_mode,
@@ -403,7 +370,6 @@ static int s32_serdes_get_config_from_device_tree(struct s32_serdes *pcie)
 	struct resource res;
 	struct udevice *dev = pcie->bus;
 	int ret = 0;
-	u32 val;
 
 	ret = get_serdes_alias_id(dev, &pcie->id);
 	if (ret < 0) {
@@ -438,10 +404,6 @@ static int s32_serdes_get_config_from_device_tree(struct s32_serdes *pcie)
 	debug("%s: dbi: 0x%lx (0x%p)\n", __func__, (uintptr_t)res.start,
 	      pcie->dbi);
 
-	/* get supported width (X1/X2) from device tree */
-	val = dev_read_u32_default(dev, "num-lanes", X1);
-	pcie->linkwidth = (enum serdes_link_width)val;
-
 	return 0;
 }
 
@@ -538,12 +500,6 @@ static int s32_serdes_probe(struct udevice *dev)
 	s32_serdes_get_mode_str(pcie->devtype, pcie->xpcs_mode, mode);
 	printf("Configuring PCIe%d as %s\n", pcie->id, mode);
 
-
-	/* Keep ltssm_enable =0 to disable link  training for programming
-	 * the DBI.
-	 */
-	s32_serdes_disable_ltssm(pcie->dbi);
-
 	/* Apply the base SerDes/PHY settings */
 	if (!s32_serdes_init(pcie))
 		return ret;
@@ -567,52 +523,8 @@ static int s32_serdes_probe(struct udevice *dev)
 		}
 	}
 
-	if (IS_SERDES_PCIE(pcie->devtype)) {
-		char mode[SERDES_MODE_SIZE];
-
-		/* Update the max link depending on other factors */
-		/* Use by default the width from the serdes node
-		 * in the device tree
-		 */
-		s32_serdes_get_mode_str(pcie->devtype, pcie->xpcs_mode, mode);
-		debug("SerDes%d: Configure as %s\n", pcie->id, mode);
-		if (IS_SERDES_SGMII(pcie->devtype))
-			pcie->linkwidth = X1;
-
-		if (!s32_pcie_init(pcie->dbi, pcie->id,
-					pcie->devtype & PCIE_RC,
-					pcie->linkwidth))
-			return ret;
-
-		s32_serdes_enable_ltssm(pcie->dbi);
-	}
-
-	/*
-	 * it makes sense to link up only as RC, as the EP
-	 * may boot earlier
-	 */
-	if (pcie->devtype & PCIE_RC) {
-		if (s32_pcie_wait_link_up(pcie->dbi)) {
-			debug("SerDes%d: link is up (X%d)\n", pcie->id,
-					pcie->linkwidth);
-		} else {
-			if (pcie->linkwidth > X1) {
-				/* Attempt to link at X1 */
-				pcie->linkwidth = X1;
-				s32_serdes_disable_ltssm(pcie->dbi);
-
-				if (!s32_pcie_set_link_width(pcie->dbi,
-						pcie->id,
-						pcie->linkwidth))
-					return ret;
-
-				s32_serdes_enable_ltssm(pcie->dbi);
-				if (s32_pcie_wait_link_up(pcie->dbi))
-					debug("SerDes%d: link is up (X%d)\n",
-						pcie->id, pcie->linkwidth);
-			}
-		}
-	}
+	s32_serdes_get_mode_str(pcie->devtype, pcie->xpcs_mode, mode);
+	debug("SerDes%d: Configure as %s\n", pcie->id, mode);
 
 	return ret;
 }
diff --git a/drivers/pci/serdes_s32gen1.h b/drivers/pci/serdes_s32gen1.h
index bd3bce878d..ffa7ab9b5d 100644
--- a/drivers/pci/serdes_s32gen1.h
+++ b/drivers/pci/serdes_s32gen1.h
@@ -58,18 +58,9 @@ struct s32_serdes {
 	enum serdes_clock clktype;
 	enum serdes_clock_fmhz fmhz;
 	enum serdes_phy_mode phy_mode;
-	enum serdes_link_width linkwidth;
 };
 
-int s32_serdes_set_mode(void __iomem *dbi, int id, enum serdes_mode mode);
-enum serdes_mode s32_get_serdes_mode_from_target(void __iomem *dbi, int id);
-
-void s32_serdes_disable_ltssm(void __iomem *dbi);
-void s32_serdes_enable_ltssm(void __iomem *dbi);
-bool s32_pcie_wait_link_up(void __iomem *dbi);
-bool s32_pcie_set_link_width(void __iomem *dbi,
-		int id, enum serdes_link_width linkwidth);
-bool s32_pcie_init(void __iomem *dbi, int id, bool rc_mode,
-		enum serdes_link_width linkwidth);
+int wait_read32(void __iomem *address, u32 expected,
+		u32 mask, int read_attempts);
 
 #endif /* PCIE_S32GEN1_H */
-- 
2.17.1

