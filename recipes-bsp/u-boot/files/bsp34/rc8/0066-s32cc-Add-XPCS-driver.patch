From fd17afb291316e60d039f16719daa80d44daf3ae Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Wed, 3 Aug 2022 08:14:45 +0300
Subject: [PATCH 066/102] s32cc: Add XPCS driver

Expose XPCS as a phy for Ehternet drivers and isolate it as part
of the SerDes driver. This support was mostly taken from Linux
XPCS driver.

Issue: ALB-8357
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 .../mach-s32/include/s32-cc/serdes_hwconfig.h |    3 +
 arch/arm/mach-s32/include/s32-cc/xpcs.h       |   57 +
 arch/arm/mach-s32/s32-cc/serdes_hwconfig.c    |   64 +
 drivers/net/Makefile                          |    1 +
 drivers/net/pcs/Makefile                      |    4 +
 drivers/net/pcs/nxp-s32cc-xpcs.c              | 1122 +++++++++++++++++
 drivers/phy/nxp/s32cc-serdes.c                |  538 +++++---
 7 files changed, 1643 insertions(+), 146 deletions(-)
 create mode 100644 arch/arm/mach-s32/include/s32-cc/xpcs.h
 create mode 100644 drivers/net/pcs/Makefile
 create mode 100644 drivers/net/pcs/nxp-s32cc-xpcs.c

diff --git a/arch/arm/mach-s32/include/s32-cc/serdes_hwconfig.h b/arch/arm/mach-s32/include/s32-cc/serdes_hwconfig.h
index 1619c0638e..552e9e1048 100644
--- a/arch/arm/mach-s32/include/s32-cc/serdes_hwconfig.h
+++ b/arch/arm/mach-s32/include/s32-cc/serdes_hwconfig.h
@@ -5,6 +5,7 @@
 #define SERDES_HWCONFIG_H
 
 #include <fsl-s32gen1-pcie-phy-submode.h>
+#include <generic-phy.h>
 #include <linux/types.h>
 
 #define SERDES_CLK_SUBARG	"clock"
@@ -113,5 +114,7 @@ bool s32_serdes_has_mode5_enabled(int id);
 bool is_pcie_enabled_in_hwconfig(int id);
 int apply_dm_hwconfig_fixups(void);
 int apply_fdt_hwconfig_fixups(void *blob);
+int s32_serdes_get_alias_id(struct udevice *serdes_dev, int *devnump);
+int s32_serdes_get_lane_speed(struct udevice *serdes_dev, u32 lane);
 
 #endif
diff --git a/arch/arm/mach-s32/include/s32-cc/xpcs.h b/arch/arm/mach-s32/include/s32-cc/xpcs.h
new file mode 100644
index 0000000000..d06a887e0f
--- /dev/null
+++ b/arch/arm/mach-s32/include/s32-cc/xpcs.h
@@ -0,0 +1,57 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/**
+ * Copyright 2022 NXP
+ */
+#ifndef S32CC_XPCS_H
+#define S32CC_XPCS_H
+
+#include <generic-phy.h>
+#include <linux/types.h>
+
+struct s32cc_xpcs;
+
+struct phylink_link_state {
+	int speed;
+	int duplex;
+	int pause;
+	u32 advertising;
+	unsigned int link:1;
+	unsigned int an_enabled:1;
+	unsigned int an_complete:1;
+};
+
+struct s32cc_xpcs_ops {
+	int (*init)(struct s32cc_xpcs **xpcs, struct udevice *dev,
+		    unsigned char id, void __iomem *base, bool ext_clk,
+		    unsigned long rate, bool pcie_shared);
+	int (*power_on)(struct s32cc_xpcs *xpcs);
+	int (*config)(struct s32cc_xpcs *xpcs,
+		      const struct phylink_link_state *state);
+	int (*vreset)(struct s32cc_xpcs *xpcs);
+	int (*wait_vreset)(struct s32cc_xpcs *xpcs);
+	int (*init_plls)(struct s32cc_xpcs *xpcs);
+	int (*reset_rx)(struct s32cc_xpcs *xpcs);
+	bool (*has_valid_rx)(struct s32cc_xpcs *xpcs);
+
+	/* These function are planned to be used directly
+	 * by phylink in newer kernels (starting from 5.10).
+	 */
+	int (*xpcs_config)(struct s32cc_xpcs *xpcs,
+			   const struct phylink_link_state *state);
+	int (*xpcs_get_state)(struct s32cc_xpcs *xpcs,
+			      struct phylink_link_state *state);
+};
+
+const struct s32cc_xpcs_ops *s32cc_xpcs_get_ops(void);
+
+/**
+ * s32cc_phy2xpcs() - Get XPCS instance associated with a PHY
+ *
+ * @phy: A generic PHY obtained from s32cc SerDes driver.
+ *
+ * The return value will be the XPCS instance associate with the
+ * passed SerDes PHY.
+ */
+struct s32cc_xpcs *s32cc_phy2xpcs(struct phy *phy);
+
+#endif
diff --git a/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c b/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c
index f3dd441bba..dc080722b4 100644
--- a/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c
+++ b/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c
@@ -5,6 +5,11 @@
 #include <common.h>
 #include <hwconfig.h>
 #include <asm/arch/s32-cc/serdes_regs.h>
+#include <dm/device.h>
+#include <dm/of_access.h>
+#include <dm/ofnode.h>
+#include <dm/read.h>
+#include <linux/ethtool.h>
 #include <s32-cc/serdes_hwconfig.h>
 
 #define SERDES_RC_MODE_STR "RootComplex"
@@ -322,3 +327,62 @@ bool s32_serdes_is_cfg_valid(int id)
 
 	return true;
 }
+
+int s32_serdes_get_alias_id(struct udevice *serdes_dev, int *devnump)
+{
+	ofnode node = dev_ofnode(serdes_dev);
+	const char *uc_name = "serdes";
+	int ret;
+
+	if (ofnode_is_np(node)) {
+		ret = of_alias_get_id(ofnode_to_np(node), uc_name);
+		if (ret >= 0) {
+			*devnump = ret;
+			ret = 0;
+		}
+	} else {
+		ret = fdtdec_get_alias_seq(gd->fdt_blob, uc_name,
+					   ofnode_to_offset(node), devnump);
+	}
+
+	return ret;
+}
+
+int s32_serdes_get_lane_speed(struct udevice *serdes_dev, u32 lane)
+{
+	enum serdes_xpcs_mode xpcs_mode;
+	int serdes_id = 0;
+	int ret;
+
+	if (!serdes_dev)
+		return -EINVAL;
+
+	ret = s32_serdes_get_alias_id(serdes_dev, &serdes_id);
+	if (ret < 0) {
+		printf("Failed to get SerDes device id for device %s:\n",
+		       serdes_dev->name);
+		return ret;
+	}
+
+	xpcs_mode = s32_serdes_get_xpcs_cfg_from_hwconfig(serdes_id);
+	switch (xpcs_mode) {
+	/* XPCS is on lane1 when using ss mode = 1 or 2 */
+	case SGMII_XPCS0:
+	case SGMII_XPCS1:
+		if (lane)
+			return SPEED_1000;
+		break;
+	case SGMII_XPCS0_XPCS1:
+		if (!lane || lane == 1)
+			return SPEED_1000;
+		break;
+	case SGMII_XPCS0_2G5:
+		if (!lane)
+			return SPEED_2500;
+		break;
+	case SGMII_INAVALID:
+		return -EINVAL;
+	}
+
+	return -EINVAL;
+}
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 8e1fa851a6..d9cfd9fdc0 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -92,3 +92,4 @@ obj-$(CONFIG_HIGMACV300_ETH) += higmacv300.o
 obj-$(CONFIG_MDIO_SANDBOX) += mdio_sandbox.o
 obj-$(CONFIG_FSL_ENETC) += fsl_enetc.o fsl_enetc_mdio.o
 obj-$(CONFIG_NXP_S32CC) += s32/
+obj-y += pcs/
diff --git a/drivers/net/pcs/Makefile b/drivers/net/pcs/Makefile
new file mode 100644
index 0000000000..a053fd6705
--- /dev/null
+++ b/drivers/net/pcs/Makefile
@@ -0,0 +1,4 @@
+# SPDX-License-Identifier: GPL-2.0
+# Makefile for U-Boot PCS drivers
+
+obj-$(CONFIG_PHY_S32CC_SERDES) += nxp-s32cc-xpcs.o
diff --git a/drivers/net/pcs/nxp-s32cc-xpcs.c b/drivers/net/pcs/nxp-s32cc-xpcs.c
new file mode 100644
index 0000000000..ba1efb65aa
--- /dev/null
+++ b/drivers/net/pcs/nxp-s32cc-xpcs.c
@@ -0,0 +1,1122 @@
+// SPDX-License-Identifier: GPL-2.0
+/**
+ * Copyright 2022 NXP
+ */
+#include <regmap.h>
+#include <dm/device.h>
+#include <dm/devres.h>
+#include <linux/bitops.h>
+#include <linux/errno.h>
+#include <linux/ethtool.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/time.h>
+#include <s32-cc/xpcs.h>
+
+#define regmap_reg_range(low, high) { .start = (low), .size = (high) - (low), }
+
+#define SPEED_UNKNOWN				(-1)
+#define DUPLEX_UNKNOWN				(-1)
+
+#define XPCS_TIMEOUT_MS				(300 * USEC_PER_MSEC)
+
+#define SR_MII_CTRL				0x1F0000U
+#define   AN_ENABLE				BIT(12)
+#define   SR_RST				BIT(15)
+#define   SS13					BIT(13)
+#define   RESTART_AN				BIT(9)
+#define   DUPLEX_MODE				BIT(8)
+#define   SS6					BIT(6)
+
+#define SR_MII_STS				0x1F0001U
+#define   LINK_STS				BIT(2)
+#define   AN_ABL				BIT(3)
+#define   AN_CMPL				BIT(5)
+
+#define SR_MII_DEV_ID1				0x1F0002U
+#define SR_MII_DEV_ID2				0x1F0003U
+#define SR_MII_EXT_STS				0x1F000FU
+#define   CAP_1G_T_FD				BIT(13)
+#define   CAP_1G_T_HD				BIT(12)
+
+#define VR_MII_DIG_CTRL1			0x1F8000U
+#define   BYP_PWRUP				BIT(1)
+#define   EN_2_5G_MODE				BIT(2)
+#define   CL37_TMR_OVRRIDE		BIT(3)
+#define   INIT					BIT(8)
+#define   MAC_AUTO_SW				BIT(9)
+#define   CS_EN					BIT(10)
+#define   PWRSV					BIT(11)
+#define   EN_VSMMD1				BIT(13)
+#define   R2TLBE				BIT(14)
+#define   VR_RST				BIT(15)
+
+#define VR_MII_AN_CTRL				0x1F8001U
+#define   MII_AN_INTR_EN		BIT(0)
+#define   PCS_MODE_OFF			(1)
+#define   PCS_MODE_MASK			(0x3 << PCS_MODE_OFF)
+#define   PCS_MODE_SET(x)		(((x) << PCS_MODE_OFF) & PCS_MODE_MASK)
+#define    PCS_MODE_SGMII		(2)
+#define   MII_CTRL				BIT(8)
+
+#define VR_MII_AN_INTR_STS			0x1F8002U
+#define  CL37_ANCMPLT_INTR		BIT(0)
+#define  CL37_ANSGM_STS_DUPLEX		BIT(1)
+#define  CL37_ANSGM_STS_SPEED_OFF	(2)
+#define  CL37_ANSGM_STS_SPEED_MASK	(0x3 << CL37_ANSGM_STS_SPEED_OFF)
+#define  CL37_ANSGM_STS_LINK		BIT(4)
+
+#define VR_MII_DBG_CTRL				0x1F8005U
+#define   SUPPRESS_LOS_DET			BIT(4)
+#define   RX_DT_EN_CTL				BIT(6)
+
+#define VR_MII_LINK_TIMER_CTRL			0x1F800AU
+#define VR_MII_DIG_STS				0x1F8010U
+#define   PSEQ_STATE_OFF			(2)
+#define   PSEQ_STATE_MASK			(0x7 << PSEQ_STATE_OFF)
+#define   PSEQ_STATE(val)			(((val) & PSEQ_STATE_MASK) >> \
+						 PSEQ_STATE_OFF)
+#define     POWER_GOOD_STATE			0x4
+
+#define VR_MII_GEN5_12G_16G_TX_GENCTRL1 0x1F8031U
+#define  TX_CLK_RDY_0				BIT(12)
+
+#define VR_MII_GEN5_12G_16G_TX_GENCTRL2 0x1F8032U
+#define  TX_REQ_0				BIT(0)
+
+#define VR_MII_GEN5_12G_16G_TX_RATE_CTRL	0x1F8034U
+#define   TX0_RATE_OFF				0
+#define   TX0_RATE_MASK				0x7
+#define     TX0_BAUD_DIV_1			0
+#define     TX0_BAUD_DIV_4			2
+
+#define VR_MII_GEN5_12G_16G_TX_EQ_CTRL0		0x1F8036U
+#define   TX_EQ_MAIN_OFF			8
+#define   TX_EQ_MAIN_MASK			(0x3F << TX_EQ_MAIN_OFF)
+
+#define VR_MII_CONSUMER_10G_TX_TERM_CTRL	0x1F803CU
+#define   TX0_TERM_OFF				0
+#define   TX0_TERM_MASK				0x7
+
+#define VR_MII_GEN5_12G_16G_RX_GENCTRL1		0x1F8051U
+#define   RX_RST_0				BIT(4)
+
+#define VR_MII_GEN5_12G_16G_RX_GENCTRL2 0x1F8052U
+#define   RX_REQ_0				BIT(0)
+
+#define VR_MII_GEN5_12G_16G_RX_RATE_CTRL	0x1F8054U
+#define   RX0_RATE_OFF				0
+#define   RX0_RATE_MASK				0x3
+#define     RX0_BAUD_DIV_2			0x1
+#define     RX0_BAUD_DIV_8			0x3
+
+#define VR_MII_GEN5_12G_16G_CDR_CTRL		0x1F8056U
+#define   VCO_LOW_FREQ_0			BIT(8)
+
+#define VR_MII_GEN5_12G_16G_MPLL_CMN_CTRL	0x1F8070U
+#define   MPLLB_SEL_0				BIT(4)
+#define   MPLL_EN_0				BIT(0)
+
+#define VR_MII_GEN5_12G_16G_MPLLA_CTRL0		0x1F8071U
+#define   MPLLA_CAL_DISABLE			BIT(15)
+#define   MLLA_MULTIPLIER_OFF			0
+#define   MLLA_MULTIPLIER_MASK			(0xFF << MLLA_MULTIPLIER_OFF)
+
+#define VR_MII_GEN5_12G_MPLLA_CTRL1		0x1F8072U
+#define   MPLLA_FRACN_CTRL_OFF			5
+#define   MPLLA_FRACN_CTRL_MASK			(0x7FF << MPLLA_FRACN_CTRL_OFF)
+
+#define VR_MII_GEN5_12G_16G_MPLLA_CTRL2		0x1F8073U
+#define   MPLLA_TX_CLK_DIV_OFF			11
+#define   MPLLA_TX_CLK_DIV_MASK			(0x7 << MPLLA_TX_CLK_DIV_OFF)
+#define   MPLLA_DIV10_CLK_EN			BIT(9)
+
+#define VR_MII_GEN5_12G_16G_MPLLB_CTRL0		0x1F8074U
+#define   MPLLB_CAL_DISABLE			BIT(15)
+#define   MLLB_MULTIPLIER_OFF			0
+#define   MLLB_MULTIPLIER_MASK			0xFF
+
+#define VR_MII_GEN5_12G_MPLLB_CTRL1		0x1F8075U
+#define   MPLLB_FRACN_CTRL_OFF			5
+#define   MPLLB_FRACN_CTRL_MASK			(0x7FF << MPLLB_FRACN_CTRL_OFF)
+
+#define VR_MII_GEN5_12G_16G_MPLLB_CTRL2		0x1F8076U
+#define   MPLLB_TX_CLK_DIV_OFF			11
+#define   MPLLB_TX_CLK_DIV_MASK			(0x7 << MPLLA_TX_CLK_DIV_OFF)
+#define   MPLLB_DIV10_CLK_EN			BIT(9)
+
+#define VR_MII_RX_LSTS				0x1F8020U
+#define   RX_VALID_0				BIT(12)
+
+#define VR_MII_GEN5_12G_MPLLA_CTRL3		0x1F8077U
+#define   MPLLA_BANDWIDTH_OFF			0x0
+#define   MPLLA_BANDWIDTH_MASK			0xFFFF
+
+#define VR_MII_GEN5_12G_MPLLB_CTRL3		0x1F8078U
+#define   MPLLB_BANDWIDTH_OFF			0x0
+#define   MPLLB_BANDWIDTH_MASK			0xFFFF
+
+#define VR_MII_GEN5_12G_16G_REF_CLK_CTRL	0x1F8091U
+#define   REF_CLK_EN				BIT(0)
+#define   REF_USE_PAD				BIT(1)
+#define   REF_CLK_DIV2				BIT(2)
+#define   REF_RANGE_OFF				3
+#define   REF_RANGE_MASK			(0x7 << REF_RANGE_OFF)
+#define     RANGE_26_53_MHZ			0x1
+#define     RANGE_52_78_MHZ			0x2
+#define     RANGE_78_104_MHZ			0x3
+#define   REF_RANGE(x)				(((x) & 0x7U) << 3)
+#define   REF_MPLLA_DIV2			BIT(6)
+#define   REF_MPLLB_DIV2			BIT(7)
+#define   REF_RPT_CLK_EN			BIT(8)
+
+#define VR_MII_GEN5_12G_16G_VCO_CAL_LD0		0x1F8092U
+#define   VCO_LD_VAL_0_OFF			0
+#define   VCO_LD_VAL_0_MASK			0x1FFF
+
+#define VR_MII_GEN5_12G_VCO_CAL_REF0		0x1F8096U
+#define   VCO_REF_LD_0_OFF			0
+#define   VCO_REF_LD_0_MASK			0x3F
+
+#define UPTR(a)					((uintptr_t)(a))
+
+#define KHZ		(1000)
+#define MHZ(X)		(1000 * KHZ * (X))
+
+#define XPCS_WRITE_BITS(xpcs, REG, mask, value) \
+	xpcs_write_bits(xpcs, #REG, REG, mask, value)
+
+#define XPCS_WRITE(xpcs, REG, value) \
+	xpcs_write(xpcs, #REG, REG, value)
+
+#define XPCS_READ(xpcs, REG) \
+	xpcs_read(xpcs, #REG, REG)
+
+struct s32cc_xpcs_params {
+	u32 addr1;
+	u32 addr2;
+};
+
+enum s32cc_xpc_pll {
+	XPCS_PLLA,	/* Slow PLL */
+	XPCS_PLLB,	/* Fast PLL */
+};
+
+struct s32cc_xpcs {
+	struct s32cc_xpcs_params params;
+	enum s32cc_xpc_pll ref;
+	void __iomem *base;
+	struct udevice *dev;
+	unsigned char id;
+	bool ext_clk;
+	bool mhz125;
+	bool pcie_shared;
+};
+
+typedef bool (*xpcs_poll_func_t)(struct s32cc_xpcs *);
+
+struct xpcs_mask_poll {
+	struct s32cc_xpcs *xpcs;
+	unsigned int reg;
+	unsigned int mask;
+	unsigned int bits;
+};
+
+static const struct regmap_range xpcs_wr_ranges[] = {
+	regmap_reg_range(0x1F0000, 0x1F0000),
+	regmap_reg_range(0x1F0004, 0x1F0004),
+	regmap_reg_range(0x1F8000, 0x1F8003),
+	regmap_reg_range(0x1F8005, 0x1F8005),
+	regmap_reg_range(0x1F800A, 0x1F800A),
+	regmap_reg_range(0x1F8012, 0x1F8012),
+	regmap_reg_range(0x1F8015, 0x1F8015),
+	regmap_reg_range(0x1F8030, 0x1F8037),
+	regmap_reg_range(0x1F803C, 0x1F803C),
+	regmap_reg_range(0x1F8050, 0x1F8058),
+	regmap_reg_range(0x1F805C, 0x1F805E),
+	regmap_reg_range(0x1F8064, 0x1F8064),
+	regmap_reg_range(0x1F806B, 0x1F806B),
+	regmap_reg_range(0x1F8070, 0x1F8078),
+	regmap_reg_range(0x1F8090, 0x1F8092),
+	regmap_reg_range(0x1F8096, 0x1F8096),
+	regmap_reg_range(0x1F8099, 0x1F80A2),
+	regmap_reg_range(0x1F80E1, 0x1F80E1),
+};
+
+static const struct regmap_range xpcs_rd_ranges[] = {
+	regmap_reg_range(0x1F0001, 0x1F0003),
+	regmap_reg_range(0x1F0005, 0x1F0006),
+	regmap_reg_range(0x1F000F, 0x1F000F),
+	regmap_reg_range(0x1F0708, 0x1F0710),
+	regmap_reg_range(0x1F8010, 0x1F8011),
+	regmap_reg_range(0x1F8018, 0x1F8018),
+	regmap_reg_range(0x1F8020, 0x1F8020),
+	regmap_reg_range(0x1F8040, 0x1F8040),
+	regmap_reg_range(0x1F8060, 0x1F8060),
+	regmap_reg_range(0x1F8098, 0x1F8098),
+};
+
+static int get_xpcs_id(struct s32cc_xpcs *xpcs)
+{
+	return xpcs->id;
+}
+
+static struct udevice *get_xpcs_device(struct s32cc_xpcs *xpcs)
+{
+	return xpcs->dev;
+}
+
+static void init_params(u32 reg, struct s32cc_xpcs *xpcs,
+			struct s32cc_xpcs_params *params, u32 *data)
+{
+	u32 ofsleft = (reg >> 8) & 0xffffU;
+	u32 ofsright = (reg & 0xffU);
+
+	*data = ofsleft;
+
+	params->addr1 = xpcs->params.addr1;
+	params->addr2 = xpcs->params.addr2 + (ofsright * 4);
+
+	params->addr1 -= xpcs->params.addr2;
+	params->addr2 -= xpcs->params.addr2;
+}
+
+static bool regmap_reg_in_ranges(unsigned int reg,
+				 const struct regmap_range *ranges,
+				 size_t n_ranges)
+{
+	size_t i;
+	const struct regmap_range *range;
+
+	for (i = 0; i < n_ranges; i++) {
+		range = &ranges[i];
+		if (reg >= range->start && reg <= range->start + range->size)
+			return true;
+	}
+
+	return false;
+}
+
+static bool xpcs_writeable_reg(struct udevice *dev, unsigned int reg)
+{
+	return regmap_reg_in_ranges(reg, xpcs_wr_ranges,
+				    ARRAY_SIZE(xpcs_wr_ranges));
+}
+
+static bool xpcs_readable_reg(struct udevice *dev, unsigned int reg)
+{
+	if (!xpcs_writeable_reg(dev, reg))
+		return regmap_reg_in_ranges(reg, xpcs_rd_ranges,
+					    ARRAY_SIZE(xpcs_rd_ranges));
+
+	return true;
+}
+
+static int xpcs_regmap_reg_read(struct s32cc_xpcs *xpcs, unsigned int reg,
+				unsigned int *result)
+{
+	struct s32cc_xpcs_params params;
+	u32 data;
+
+	if (!xpcs_readable_reg(xpcs->dev, reg)) {
+		dev_err(xpcs->dev, "The register 0x%x isn't readable\n", reg);
+		return -EPERM;
+	}
+
+	init_params(reg, xpcs, &params, &data);
+
+	writew(data, UPTR(xpcs->base) + params.addr1);
+	*result = readw(UPTR(xpcs->base) + params.addr2);
+
+	return 0;
+}
+
+static int xpcs_regmap_reg_write(struct s32cc_xpcs *xpcs, unsigned int reg,
+				 unsigned int val)
+{
+	struct s32cc_xpcs_params params;
+	u32 data;
+
+	if (!xpcs_writeable_reg(xpcs->dev, reg)) {
+		dev_err(xpcs->dev, "The register 0x%x isn't writable\n", reg);
+		return -EPERM;
+	}
+
+	init_params(reg, xpcs, &params, &data);
+
+	writel(data, UPTR(xpcs->base) + params.addr1);
+	writel(val, UPTR(xpcs->base) + params.addr2);
+
+	return 0;
+}
+
+static void xpcs_write_bits(struct s32cc_xpcs *xpcs, const char *name,
+			    unsigned int reg, unsigned int mask,
+			    unsigned int value)
+{
+	__maybe_unused struct udevice *dev = get_xpcs_device(xpcs);
+	unsigned int val = 0;
+	int ret;
+
+	ret = xpcs_regmap_reg_read(xpcs, reg, &val);
+	if (ret) {
+		dev_err(dev, "write_bits: Failed to read XPCS reg: %s\n", name);
+		return;
+	}
+
+	val &= ~mask;
+	val |= value;
+
+	ret = xpcs_regmap_reg_write(xpcs, reg, val);
+
+	if (ret)
+		dev_err(dev, "write_bits: Failed to write XPCS reg: %s\n",
+			name);
+}
+
+static void xpcs_write(struct s32cc_xpcs *xpcs, const char *name,
+		       unsigned int reg, unsigned int value)
+{
+	__maybe_unused struct udevice *dev = get_xpcs_device(xpcs);
+	int ret = xpcs_regmap_reg_write(xpcs, reg, value);
+
+	if (ret)
+		dev_err(dev, "Failed to write XPCS reg: %s\n", name);
+}
+
+static unsigned int xpcs_read(struct s32cc_xpcs *xpcs, const char *name,
+			      unsigned int reg)
+{
+	__maybe_unused struct udevice *dev = get_xpcs_device(xpcs);
+	unsigned int val = 0;
+	int ret;
+
+	ret = xpcs_regmap_reg_read(xpcs, reg, &val);
+	if (ret)
+		dev_err(dev, "Failed to read XPCS reg: %s\n", name);
+
+	return val;
+}
+
+static int xpcs_init(struct s32cc_xpcs **xpcs, struct udevice *dev,
+		     unsigned char id, void __iomem *base, bool ext_clk,
+		     unsigned long rate, bool pcie_shared)
+{
+	struct s32cc_xpcs *xpcsp;
+
+	if (rate != MHZ(125) && rate != MHZ(100)) {
+		dev_err(dev, "XPCS cannot operate @%lu HZ\n", rate);
+		return -EINVAL;
+	}
+
+	*xpcs = devm_kmalloc(dev, sizeof(**xpcs), GFP_KERNEL);
+	if (!*xpcs) {
+		dev_err(dev, "Failed to allocate xpcs\n");
+		return -ENOMEM;
+	}
+
+	xpcsp = *xpcs;
+
+	xpcsp->base = base;
+	xpcsp->ext_clk = ext_clk;
+	xpcsp->id = id;
+	xpcsp->dev = dev;
+	xpcsp->pcie_shared = pcie_shared;
+
+	if (rate == MHZ(125))
+		xpcsp->mhz125 = true;
+	else
+		xpcsp->mhz125 = false;
+
+	if (!get_xpcs_id(xpcsp)) {
+		/**
+		 * XPCS parameters based on Serdes Reference Manual,
+		 * chapter 5.2
+		 */
+		xpcsp->params = (struct s32cc_xpcs_params) {
+			.addr1 = 0x823FCU,
+			.addr2 = 0x82000U,
+		};
+	} else {
+		xpcsp->params = (struct s32cc_xpcs_params) {
+			.addr1 = 0X82BFCU,
+			.addr2 = 0x82800U,
+		};
+	}
+
+	return 0;
+}
+
+static bool is_pgood_state(struct s32cc_xpcs *xpcs)
+{
+	unsigned int val;
+
+	/* Not in reset state */
+	val = XPCS_READ(xpcs, VR_MII_DIG_CTRL1);
+	if (val & VR_RST)
+		return false;
+
+	val = XPCS_READ(xpcs, VR_MII_DIG_STS);
+
+	return PSEQ_STATE(val) == POWER_GOOD_STATE;
+}
+
+static bool is_not_in_reset(struct s32cc_xpcs *xpcs)
+{
+	unsigned int val;
+
+	val = XPCS_READ(xpcs, SR_MII_CTRL);
+
+	return !(val & SR_RST);
+}
+
+static int xpcs_wait(struct s32cc_xpcs *xpcs, xpcs_poll_func_t func)
+{
+	bool val;
+
+	return readx_poll_timeout(func, xpcs, val, val, XPCS_TIMEOUT_MS);
+}
+
+static bool check_xpcs_bits(struct xpcs_mask_poll *data)
+{
+	return (XPCS_READ(data->xpcs, data->reg) & data->mask) == data->bits;
+}
+
+static int xpcs_wait_bits(struct s32cc_xpcs *xpcs, unsigned int reg,
+			  unsigned int mask, unsigned int bits)
+{
+	bool val;
+	struct xpcs_mask_poll data = {
+		.xpcs = xpcs,
+		.reg = reg,
+		.mask = mask,
+		.bits = bits,
+	};
+
+	return readx_poll_timeout(check_xpcs_bits, &data,
+				  val, val, XPCS_TIMEOUT_MS);
+}
+
+static int wait_power_good_state(struct s32cc_xpcs *xpcs)
+{
+	int ret;
+
+	ret = xpcs_wait(xpcs, is_pgood_state);
+	if (ret == -ETIMEDOUT)
+		dev_err(get_xpcs_device(xpcs), "XPCS%d power good timeout\n",
+			get_xpcs_id(xpcs));
+
+	return ret;
+}
+
+static int wait_reset(struct s32cc_xpcs *xpcs)
+{
+	int ret;
+
+	ret = xpcs_wait(xpcs, is_not_in_reset);
+	if (ret == -ETIMEDOUT)
+		dev_err(get_xpcs_device(xpcs), "XPCS%d is in reset\n",
+			get_xpcs_id(xpcs));
+
+	return ret;
+}
+
+static int xpcs_power_on(struct s32cc_xpcs *xpcs)
+{
+	/*Nothing for now*/
+	return 0;
+}
+
+static bool xpcs_has_valid_rx(struct s32cc_xpcs *xpcs)
+{
+	unsigned int val;
+
+	val = XPCS_READ(xpcs, VR_MII_RX_LSTS);
+	return !!(val & RX_VALID_0);
+}
+
+static int xpcs_vreset(struct s32cc_xpcs *xpcs)
+{
+	int ret = 0;
+
+	if (!xpcs)
+		return -EINVAL;
+
+	XPCS_WRITE_BITS(xpcs, VR_MII_DIG_CTRL1, VR_RST, VR_RST);
+
+	return ret;
+}
+
+static int xpcs_wait_vreset(struct s32cc_xpcs *xpcs)
+{
+	if (!xpcs)
+		return -EINVAL;
+
+	return wait_reset(xpcs);
+}
+
+static int xpcs_reset_rx(struct s32cc_xpcs *xpcs)
+{
+	__maybe_unused struct udevice *dev = get_xpcs_device(xpcs);
+	int ret;
+
+	ret = wait_power_good_state(xpcs);
+	if (ret) {
+		dev_err(dev, "Failed to enter in PGOOD state after vendor reset\n");
+		return ret;
+	}
+
+	/* Step 21 */
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_RX_GENCTRL1,
+			RX_RST_0, RX_RST_0);
+
+	/* Step 22 */
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_RX_GENCTRL1,
+			RX_RST_0, 0);
+
+	return 0;
+}
+
+static int xpcs_ref_clk_sel(struct s32cc_xpcs *xpcs,
+			    enum s32cc_xpc_pll ref_pll)
+{
+	switch (ref_pll) {
+	case XPCS_PLLA:
+		XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_MPLL_CMN_CTRL,
+				MPLLB_SEL_0, 0);
+		xpcs->ref = XPCS_PLLA;
+		break;
+	case XPCS_PLLB:
+		XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_MPLL_CMN_CTRL,
+				MPLLB_SEL_0, MPLLB_SEL_0);
+		xpcs->ref = XPCS_PLLB;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_MPLL_CMN_CTRL, MPLL_EN_0,
+			MPLL_EN_0);
+
+	return 0;
+}
+
+static void xpcs_electrical_configure(struct s32cc_xpcs *xpcs)
+{
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_TX_EQ_CTRL0,
+			TX_EQ_MAIN_MASK, 0xC << TX_EQ_MAIN_OFF);
+
+	XPCS_WRITE_BITS(xpcs, VR_MII_CONSUMER_10G_TX_TERM_CTRL,
+			TX0_TERM_MASK, 0x4 << TX0_TERM_OFF);
+}
+
+static int xpcs_vco_cfg(struct s32cc_xpcs *xpcs, enum s32cc_xpc_pll vco_pll)
+{
+	unsigned int vco_ld = 0;
+	unsigned int vco_ref = 0;
+	unsigned int rx_baud = 0;
+	unsigned int tx_baud = 0;
+
+	switch (vco_pll) {
+	case XPCS_PLLA:
+		if (xpcs->mhz125) {
+			vco_ld = 1360 << VCO_LD_VAL_0_OFF;
+			vco_ref = 17 << VCO_REF_LD_0_OFF;
+		} else {
+			vco_ld = 1350 << VCO_LD_VAL_0_OFF;
+			vco_ref = 27 << VCO_REF_LD_0_OFF;
+		}
+
+		rx_baud = RX0_BAUD_DIV_8 << RX0_RATE_OFF;
+		tx_baud = TX0_BAUD_DIV_4 << TX0_RATE_OFF;
+		break;
+	case XPCS_PLLB:
+		if (xpcs->mhz125) {
+			vco_ld = 1350 << VCO_LD_VAL_0_OFF;
+			vco_ref = 27 << VCO_REF_LD_0_OFF;
+		} else {
+			vco_ld = 1344 << VCO_LD_VAL_0_OFF;
+			vco_ref = 43 << VCO_REF_LD_0_OFF;
+		}
+
+		rx_baud = RX0_BAUD_DIV_2 << RX0_RATE_OFF;
+		tx_baud = TX0_BAUD_DIV_1 << TX0_RATE_OFF;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_VCO_CAL_LD0,
+			VCO_LD_VAL_0_MASK, vco_ld);
+
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_VCO_CAL_REF0,
+			VCO_REF_LD_0_MASK, vco_ref);
+
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_TX_RATE_CTRL,
+			TX0_RATE_MASK, tx_baud);
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_RX_RATE_CTRL,
+			RX0_RATE_MASK, rx_baud);
+
+	if (vco_pll == XPCS_PLLB) {
+		XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_CDR_CTRL,
+				VCO_LOW_FREQ_0, VCO_LOW_FREQ_0);
+	} else {
+		XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_CDR_CTRL,
+				VCO_LOW_FREQ_0, 0);
+	}
+
+	return 0;
+}
+
+static int xpcs_init_mplla(struct s32cc_xpcs *xpcs)
+{
+	__maybe_unused struct udevice *dev;
+	unsigned int val;
+
+	if (!xpcs)
+		return -EINVAL;
+
+	dev = get_xpcs_device(xpcs);
+
+	/* Step 7 */
+	val = 0;
+	if (xpcs->ext_clk)
+		val |= REF_USE_PAD;
+
+	if (xpcs->mhz125) {
+		val |= REF_MPLLA_DIV2;
+		val |= REF_CLK_DIV2;
+		val |= (RANGE_52_78_MHZ << REF_RANGE_OFF);
+	} else {
+		val |= (RANGE_26_53_MHZ << REF_RANGE_OFF);
+	}
+
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_REF_CLK_CTRL,
+			REF_MPLLA_DIV2 | REF_USE_PAD | REF_RANGE_MASK |
+			REF_CLK_DIV2, val);
+
+	/* Step 8 */
+	if (xpcs->mhz125)
+		val = (80 << MLLA_MULTIPLIER_OFF);
+	else
+		val = (25 << MLLA_MULTIPLIER_OFF);
+
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_MPLLA_CTRL0,
+			MPLLA_CAL_DISABLE | MLLA_MULTIPLIER_MASK,
+			val);
+
+	/* Step 9 */
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_MPLLA_CTRL1,
+			MPLLA_FRACN_CTRL_MASK, 0);
+
+	/* Step 10 */
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_MPLLA_CTRL2,
+			MPLLA_TX_CLK_DIV_MASK | MPLLA_DIV10_CLK_EN,
+			(1 << MPLLA_TX_CLK_DIV_OFF) | MPLLA_DIV10_CLK_EN);
+
+	/* Step 11 */
+	if (xpcs->mhz125)
+		val = 43 << MPLLA_BANDWIDTH_OFF;
+	else
+		val = 357 << MPLLA_BANDWIDTH_OFF;
+
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_MPLLA_CTRL3,
+			MPLLA_BANDWIDTH_MASK, val);
+
+	return 0;
+}
+
+static int xpcs_init_mpllb(struct s32cc_xpcs *xpcs)
+{
+	__maybe_unused struct udevice *dev;
+	unsigned int val;
+
+	if (!xpcs)
+		return -EINVAL;
+
+	dev = get_xpcs_device(xpcs);
+
+	/* Step 7 */
+	val = 0;
+	if (xpcs->ext_clk)
+		val |= REF_USE_PAD;
+
+	if (xpcs->mhz125) {
+		val |= REF_MPLLB_DIV2;
+		val |= REF_CLK_DIV2;
+		val |= (RANGE_52_78_MHZ << REF_RANGE_OFF);
+	} else {
+		val |= (RANGE_26_53_MHZ << REF_RANGE_OFF);
+	}
+
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_REF_CLK_CTRL,
+			REF_MPLLB_DIV2 | REF_USE_PAD | REF_RANGE_MASK |
+			REF_CLK_DIV2, val);
+
+	/* Step 8 */
+	if (xpcs->mhz125)
+		val = 125 << MLLB_MULTIPLIER_OFF;
+	else
+		val = 39 << MLLB_MULTIPLIER_OFF;
+
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_MPLLB_CTRL0,
+			MPLLB_CAL_DISABLE | MLLB_MULTIPLIER_MASK,
+			val);
+
+	/* Step 9 */
+	if (xpcs->mhz125)
+		val = (0 << MPLLB_FRACN_CTRL_OFF);
+	else
+		val = (1044 << MPLLB_FRACN_CTRL_OFF);
+
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_MPLLB_CTRL1,
+			MPLLB_FRACN_CTRL_MASK, val);
+
+	/* Step 10 */
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_MPLLB_CTRL2,
+			MPLLB_TX_CLK_DIV_MASK | MPLLB_DIV10_CLK_EN,
+			(5 << MPLLA_TX_CLK_DIV_OFF) | MPLLB_DIV10_CLK_EN);
+
+	/* Step 11 */
+	if (xpcs->mhz125)
+		val = (68 << MPLLB_BANDWIDTH_OFF);
+	else
+		val = (102 << MPLLB_BANDWIDTH_OFF);
+
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_MPLLB_CTRL3,
+			MPLLB_BANDWIDTH_MASK, val);
+
+	return 0;
+}
+
+static int xpcs_init_plls(struct s32cc_xpcs *xpcs)
+{
+	int ret;
+	__maybe_unused struct udevice *dev = get_xpcs_device(xpcs);
+
+	if (!xpcs->ext_clk)
+		XPCS_WRITE_BITS(xpcs, VR_MII_DIG_CTRL1, BYP_PWRUP, BYP_PWRUP);
+	else if (!xpcs->pcie_shared)
+		wait_power_good_state(xpcs);
+
+	xpcs_electrical_configure(xpcs);
+
+	xpcs_ref_clk_sel(xpcs, XPCS_PLLA);
+	ret = xpcs_init_mplla(xpcs);
+	if (ret) {
+		dev_err(dev, "Failed to initialize PLLA\n");
+		return ret;
+	}
+	ret = xpcs_init_mpllb(xpcs);
+	if (ret) {
+		dev_err(dev, "Failed to initialize PLLB\n");
+		return ret;
+	}
+	xpcs_vco_cfg(xpcs, XPCS_PLLA);
+
+	if (!xpcs->ext_clk)
+		XPCS_WRITE_BITS(xpcs, VR_MII_DIG_CTRL1, BYP_PWRUP, 0);
+
+	XPCS_WRITE_BITS(xpcs, SR_MII_CTRL, AN_ENABLE, 0);
+	XPCS_WRITE_BITS(xpcs, SR_MII_CTRL, DUPLEX_MODE, DUPLEX_MODE);
+
+	return 0;
+}
+
+static int serdes_bifurcation_pll_transit(struct s32cc_xpcs *xpcs,
+					  enum s32cc_xpc_pll target_pll)
+{
+	int ret = 0;
+	__maybe_unused struct udevice *dev = get_xpcs_device(xpcs);
+
+	/* Configure XPCS speed and VCO */
+	if (target_pll == XPCS_PLLA) {
+		XPCS_WRITE_BITS(xpcs, VR_MII_DIG_CTRL1, EN_2_5G_MODE, 0);
+		xpcs_vco_cfg(xpcs, XPCS_PLLA);
+	} else {
+		XPCS_WRITE_BITS(xpcs, VR_MII_DIG_CTRL1,
+				EN_2_5G_MODE, EN_2_5G_MODE);
+		xpcs_vco_cfg(xpcs, XPCS_PLLB);
+	}
+
+	/* Signal that clock are not available */
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_TX_GENCTRL1,
+			TX_CLK_RDY_0, 0);
+
+	/* Select PLL reference */
+	if (target_pll == XPCS_PLLA)
+		xpcs_ref_clk_sel(xpcs, XPCS_PLLA);
+	else
+		xpcs_ref_clk_sel(xpcs, XPCS_PLLB);
+
+	/* Initiate transmitter TX reconfiguration request */
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_TX_GENCTRL2,
+			TX_REQ_0, TX_REQ_0);
+
+	/* Wait for transmitter to reconfigure */
+	ret = xpcs_wait_bits(xpcs, VR_MII_GEN5_12G_16G_TX_GENCTRL2,
+			     TX_REQ_0, 0);
+	if (ret) {
+		dev_err(dev, "Switch to TX_REQ_0 failed\n");
+		return ret;
+	}
+
+	/* Initiate transmitter RX reconfiguration request */
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_RX_GENCTRL2,
+			RX_REQ_0, RX_REQ_0);
+
+	/* Wait for receiver to reconfigure */
+	ret = xpcs_wait_bits(xpcs, VR_MII_GEN5_12G_16G_RX_GENCTRL2,
+			     RX_REQ_0, 0);
+	if (ret) {
+		dev_err(dev, "Switch to RX_REQ_0 failed\n");
+		return ret;
+	}
+
+	/* Signal that clock are available */
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_TX_GENCTRL1,
+			TX_CLK_RDY_0, TX_CLK_RDY_0);
+
+	/* Flush internal logic */
+	XPCS_WRITE_BITS(xpcs, VR_MII_DIG_CTRL1, INIT, INIT);
+
+	/* Wait for init */
+	ret = xpcs_wait_bits(xpcs, VR_MII_DIG_CTRL1, INIT, 0);
+	if (ret) {
+		dev_err(dev, "XPCS INIT failed\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+static int xpcs_configure(struct s32cc_xpcs *xpcs,
+			  const struct phylink_link_state *state)
+{
+	XPCS_WRITE_BITS(xpcs, SR_MII_CTRL, AN_ENABLE, 0);
+	XPCS_WRITE_BITS(xpcs, SR_MII_CTRL, DUPLEX_MODE, DUPLEX_MODE);
+
+	return 0;
+}
+
+/* Note: This function should be compatible with phylink.
+ * That means it should only modify link, duplex, speed
+ * an_complete, pause.
+ */
+static int xpcs_get_state(struct s32cc_xpcs *xpcs,
+			  struct phylink_link_state *state)
+{
+	__maybe_unused struct udevice *dev = get_xpcs_device(xpcs);
+	unsigned int mii_ctrl, val, ss;
+	bool ss6, ss13, an_enabled, intr_en;
+
+	mii_ctrl = XPCS_READ(xpcs, SR_MII_CTRL);
+	an_enabled = !!(mii_ctrl & AN_ENABLE);
+	intr_en = !!(XPCS_READ(xpcs, VR_MII_AN_CTRL) & MII_AN_INTR_EN);
+
+	/* Check this important condition */
+	if (an_enabled && !intr_en) {
+		dev_err(dev, "Invalid SGMII AN config interrupt is disabled\n");
+		return -EINVAL;
+	}
+
+	if (an_enabled) {
+		/* MLO_AN_INBAND */
+		state->speed = SPEED_UNKNOWN;
+		state->link = 0;
+		state->duplex =  DUPLEX_UNKNOWN;
+		state->an_complete = 0;
+		val = XPCS_READ(xpcs, VR_MII_AN_INTR_STS);
+
+		/* Interrupt is raised with each SGMII AN that is in cases
+		 * Link down - Every SGMII link timer expire
+		 * Link up - Once before link goes up
+		 * So either linkup or raised interrupt mean AN was completed
+		 */
+		if ((val & CL37_ANCMPLT_INTR) || (val & CL37_ANSGM_STS_LINK)) {
+			state->an_complete = 1;
+			if (val & CL37_ANSGM_STS_LINK)
+				state->link = 1;
+			else
+				return 0;
+			if (val & CL37_ANSGM_STS_DUPLEX)
+				state->duplex = DUPLEX_FULL;
+			else
+				state->duplex = DUPLEX_HALF;
+			ss = ((val & CL37_ANSGM_STS_SPEED_MASK) >>
+			      CL37_ANSGM_STS_SPEED_OFF);
+		} else {
+			return 0;
+		}
+
+		/* Clear the interrupt */
+		if (val & CL37_ANCMPLT_INTR)
+			XPCS_WRITE_BITS(xpcs, VR_MII_AN_INTR_STS,
+					CL37_ANCMPLT_INTR, 0);
+	} else {
+		/* MLO_AN_FIXED, MLO_AN_PHY */
+		val = XPCS_READ(xpcs, SR_MII_STS);
+		state->link = !!(val & LINK_STS);
+		state->an_complete = 0;
+
+		if (mii_ctrl & DUPLEX_MODE)
+			state->duplex = DUPLEX_FULL;
+		else
+			state->duplex = DUPLEX_HALF;
+
+		ss6 = !!(mii_ctrl & SS6);
+		ss13 = !!(mii_ctrl & SS13);
+		ss = ss6 << 1 | ss13;
+	}
+
+	switch (ss) {
+	case 0:
+		state->speed = SPEED_10;
+		break;
+	case 1:
+		state->speed = SPEED_100;
+		break;
+	case 2:
+		state->speed = SPEED_1000;
+		break;
+	default:
+		dev_err(dev, "Failed to interpret the value of SR_MII_CTRL\n");
+		break;
+	}
+
+	val = XPCS_READ(xpcs, VR_MII_DIG_CTRL1);
+	if ((mii_ctrl & EN_2_5G_MODE) && state->speed == SPEED_1000)
+		state->speed = SPEED_2500;
+
+	/* Cover SGMII AN inability to distigunish between 1G and 2.5G */
+	if ((mii_ctrl & EN_2_5G_MODE) &&
+	    state->speed != SPEED_2500 && an_enabled) {
+		dev_err(dev, "Speed not supported in SGMII AN mode\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static bool phylink_test(u32 advertising, u32 capab)
+{
+	return !!(advertising & capab);
+}
+
+static int xpcs_config(struct s32cc_xpcs *xpcs,
+		       const struct phylink_link_state *state)
+{
+	__maybe_unused struct udevice *dev = get_xpcs_device(xpcs);
+	unsigned int val = 0, duplex = 0;
+	int ret = 0;
+	int speed = state->speed;
+	bool sgmi_osc = false;
+
+	/* Configure adaptive MII width */
+	XPCS_WRITE_BITS(xpcs, VR_MII_AN_CTRL, MII_CTRL, 0);
+
+	if (phylink_test(state->advertising, ADVERTISED_2500baseT_Full))
+		sgmi_osc = true;
+
+	if (phylink_test(state->advertising, ADVERTISED_10baseT_Half) ||
+	    phylink_test(state->advertising, ADVERTISED_10baseT_Full) ||
+	    phylink_test(state->advertising, ADVERTISED_100baseT_Half) ||
+	    phylink_test(state->advertising, ADVERTISED_100baseT_Full) ||
+	    phylink_test(state->advertising, ADVERTISED_100baseT1_Full) ||
+	    phylink_test(state->advertising, ADVERTISED_1000baseT_Half) ||
+	    phylink_test(state->advertising, ADVERTISED_1000baseT_Full) ||
+	    phylink_test(state->advertising, ADVERTISED_1000baseX_Full))
+		if (state->an_enabled && sgmi_osc)
+			dev_err(dev, "Invalid advertising configuration for SGMII AN\n");
+
+	if (state->an_enabled && !state->an_complete) {
+		if (sgmi_osc) {
+			XPCS_WRITE(xpcs, VR_MII_LINK_TIMER_CTRL, 0x30e);
+			speed = SPEED_2500;
+		} else {
+			XPCS_WRITE(xpcs, VR_MII_LINK_TIMER_CTRL, 0x7a1);
+			speed = SPEED_1000;
+		}
+		XPCS_WRITE_BITS(xpcs, VR_MII_DIG_CTRL1, CL37_TMR_OVRRIDE, 0);
+		XPCS_WRITE_BITS(xpcs, VR_MII_DIG_CTRL1,
+				CL37_TMR_OVRRIDE, CL37_TMR_OVRRIDE);
+	} else if (!state->an_enabled) {
+		XPCS_WRITE_BITS(xpcs, SR_MII_CTRL, AN_ENABLE, 0);
+		XPCS_WRITE_BITS(xpcs, VR_MII_AN_CTRL, MII_AN_INTR_EN, 0);
+	}
+
+	if (!state->an_enabled || !state->an_complete) {
+		switch (speed) {
+		case SPEED_10:
+			break;
+		case SPEED_100:
+			val = SS13;
+			break;
+		case SPEED_1000:
+			val = SS6;
+			break;
+		case SPEED_2500:
+			val = SS6;
+			break;
+		default:
+			dev_err(dev, "Speed not supported\n");
+			break;
+		}
+
+		if (state->duplex == DUPLEX_FULL)
+			duplex = DUPLEX_MODE;
+		else
+			duplex = 0;
+
+		XPCS_WRITE_BITS(xpcs, SR_MII_CTRL, DUPLEX_MODE, duplex);
+
+		if (speed == SPEED_2500) {
+			ret = serdes_bifurcation_pll_transit(xpcs, XPCS_PLLB);
+			if (ret)
+				dev_err(dev, "Switch to PLLB failed\n");
+		} else {
+			ret = serdes_bifurcation_pll_transit(xpcs, XPCS_PLLA);
+			if (ret)
+				dev_err(dev, "Switch to PLLA failed\n");
+		}
+
+		XPCS_WRITE_BITS(xpcs, SR_MII_CTRL, SS6 | SS13, val);
+	}
+
+	if (state->an_enabled && !state->an_complete) {
+		/* Select SGMII type AN, enable interrupt */
+		XPCS_WRITE_BITS(xpcs, VR_MII_AN_CTRL,
+				PCS_MODE_MASK | MII_AN_INTR_EN,
+				PCS_MODE_SET(PCS_MODE_SGMII) | MII_AN_INTR_EN);
+		/* Enable SGMII AN */
+		XPCS_WRITE_BITS(xpcs, SR_MII_CTRL, AN_ENABLE, AN_ENABLE);
+		/* Enable SGMII AUTO SW */
+		if (sgmi_osc)
+			XPCS_WRITE_BITS(xpcs, VR_MII_DIG_CTRL1, MAC_AUTO_SW, 0);
+		else
+			XPCS_WRITE_BITS(xpcs, VR_MII_DIG_CTRL1,
+					MAC_AUTO_SW, MAC_AUTO_SW);
+
+		XPCS_WRITE_BITS(xpcs, SR_MII_CTRL, RESTART_AN, RESTART_AN);
+	}
+
+	return 0;
+}
+
+static const struct s32cc_xpcs_ops s32cc_xpcs_ops = {
+	.init = xpcs_init,
+	.power_on = xpcs_power_on,
+	.config = xpcs_configure,
+	.vreset = xpcs_vreset,
+	.wait_vreset = xpcs_wait_vreset,
+	.init_plls = xpcs_init_plls,
+	.reset_rx = xpcs_reset_rx,
+	.has_valid_rx = xpcs_has_valid_rx,
+	.xpcs_config = xpcs_config,
+	.xpcs_get_state = xpcs_get_state,
+};
+
+const struct s32cc_xpcs_ops *s32cc_xpcs_get_ops(void)
+{
+	return &s32cc_xpcs_ops;
+}
diff --git a/drivers/phy/nxp/s32cc-serdes.c b/drivers/phy/nxp/s32cc-serdes.c
index 6a9b32f95a..752a8fe7ba 100644
--- a/drivers/phy/nxp/s32cc-serdes.c
+++ b/drivers/phy/nxp/s32cc-serdes.c
@@ -23,11 +23,32 @@
 #include <linux/ioport.h>
 #include <linux/sizes.h>
 #include <linux/time.h>
+#include <s32-cc/xpcs.h>
+#include <dt-bindings/phy/phy.h>
 
 #include "serdes_regs.h"
 #include "serdes_s32gen1_io.h"
 #include "sgmii.h"
 
+#define SERDES_MAX_LANES 2U
+#define SERDES_MAX_INSTANCES 2U
+
+#define XPCS_LANE0		0
+#define XPCS_LANE1		1
+
+#define XPCS_DISABLED		-1
+#define XPCS_ID_0		0
+#define XPCS_ID_1		1
+
+#define SERDES_LINE(TYPE, INSTANCE)\
+	{ \
+		.type = (TYPE), \
+		.instance = (INSTANCE), \
+	}
+
+#define PCIE_LANE(N) SERDES_LINE(PHY_TYPE_PCIE, N)
+#define XPCS_LANE(N) SERDES_LINE(PHY_TYPE_XPCS, N)
+
 #define SERDES_CLK_MODE(EXT_CLK) \
 			((EXT_CLK) ? "external" : "internal")
 #define SERDES_CLK_FMHZ(clk_type) \
@@ -92,6 +113,16 @@
 
 #define SERDES_PCIE_FREQ	100000000
 
+struct serdes_lane_conf {
+	/* Phy type from : include/dt-bindings/phy/phy.h */
+	u32 type;
+	u8 instance; /** Instance ID (e.g PCIE0, XPCS1) */
+};
+
+struct serdes_conf {
+	struct serdes_lane_conf lanes[SERDES_MAX_LANES];
+};
+
 struct pcie_ctrl {
 	struct reset_ctl *rst;
 	void __iomem *phy_base;
@@ -112,7 +143,11 @@ struct serdes_ctrl {
 };
 
 struct xpcs_ctrl {
+	struct s32cc_xpcs *phys[2];
+	const struct s32cc_xpcs_ops *ops;
 	void __iomem *base0, *base1;
+	bool powered_on[2];
+	bool initialized_clks;
 };
 
 struct serdes {
@@ -120,6 +155,8 @@ struct serdes {
 	struct serdes_ctrl ctrl;
 	struct xpcs_ctrl xpcs;
 	struct udevice *dev;
+	u32 phys_type[SERDES_MAX_LANES];
+	u8 lanes_status;
 
 	int id;
 };
@@ -128,6 +165,21 @@ static const char * const serdes_clk_names[] = {
 	"axi", "aux", "apb", "ref", "ext"
 };
 
+static void mark_configured_lane(struct serdes *serdes, u32 lane)
+{
+	serdes->lanes_status |= BIT(lane);
+}
+
+static bool is_lane_configured(struct serdes *serdes, u32 lane)
+{
+	return !!(serdes->lanes_status & BIT(lane));
+}
+
+static int serdes_phy_reset(struct phy *p)
+{
+	return 0;
+}
+
 static void pcie_phy_write(struct serdes *serdes, u32 reg, u32 val)
 {
 	writel(PHY_REG_EN, UPTR(serdes->pcie.phy_base) + PHY_REG_ADDR);
@@ -256,120 +308,158 @@ static int pcie_phy_power_on(struct serdes *serdes, int id)
 	return 0;
 }
 
-static void s32_serdes_xpcs1_pma_config(struct serdes *serdes)
+static int xpcs_phy_init(struct serdes *serdes, int id)
 {
-	/* Configure TX_VBOOST_LVL and TX_TERM_CTRL */
-	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MISC_CTRL_2,
-	      EXT_TX_VBOOST_LVL(0x3) | EXT_TX_TERM_CTRL(0x4),
-	      EXT_TX_VBOOST_LVL(0x7) | EXT_TX_TERM_CTRL(0x7));
-	/* Enable phy external control */
-	BSET32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_CTRL_SEL,
-	       EXT_PHY_CTRL_SEL);
-	/* Configure ref range, disable PLLB/ref div2 */
-	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_REF_CLK_CTRL,
-	      EXT_REF_RANGE(0x3),
-	      REF_CLK_DIV2_EN | REF_CLK_MPLLB_DIV2_EN | EXT_REF_RANGE(0x7));
-	/* Configure multiplier */
-	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MPLLB_CTRL_2,
-	      MPLLB_MULTIPLIER(0x27U) | EXT_MPLLB_FRACN_CTRL(0x414),
-	      MPLLB_MULTIPLIER(0xffU) | EXT_MPLLB_FRACN_CTRL(0x7ff) |
-	      1 << 24U | 1 << 28U);
-
-	BCLR32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_MPLLB_CTRL,
-	       MPLLB_SSC_EN_MASK);
-
-	/* Configure tx lane division, disable word clock div2*/
-	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MPLLB_CTRL_3,
-	      EXT_MPLLB_TX_CLK_DIV(0x5),
-	      EXT_MPLLB_WORD_DIV2_EN | EXT_MPLLB_TX_CLK_DIV(0x7));
-
-	/* Configure configure bandwidth for filtering and div10*/
-	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MPLLB_CTRL_1,
-	      EXT_MPLLB_BANDWIDTH(0x5f) | EXT_MPLLB_DIV10_CLK_EN,
-	      EXT_MPLLB_BANDWIDTH(0xffff) | EXT_MPLLB_DIV_CLK_EN |
-	      EXT_MPLLB_DIV8_CLK_EN | EXT_MPLLB_DIV_MULTIPLIER(0xff));
-
-	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MPLLA_CTRL_1,
-	      EXT_MPLLA_BANDWIDTH(0xc5), EXT_MPLLA_BANDWIDTH(0xffff));
-
-	/* Configure VCO */
-	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_XPCS1_RX_OVRD_CTRL,
-	      XPCS1_RX_VCO_LD_VAL(0x540U) | XPCS1_RX_REF_LD_VAL(0x2bU),
-	      XPCS1_RX_VCO_LD_VAL(0x1fffU) | XPCS1_RX_REF_LD_VAL(0x3fU));
-
-	/* Boundary scan control */
-	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_BS_CTRL,
-	      EXT_BS_RX_LEVEL(0xb) | EXT_BS_RX_BIGSWING,
-	      EXT_BS_RX_LEVEL(0x1f) | EXT_BS_TX_LOWSWING);
-
-	/* Rx loss threshold */
-	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MISC_CTRL_1,
-	      EXT_RX_LOS_THRESHOLD(0x3U) | EXT_RX_VREF_CTRL(0x11U),
-	      EXT_RX_LOS_THRESHOLD(0x3fU) | EXT_RX_VREF_CTRL(0x1fU));
+	struct serdes_ctrl *ctrl = &serdes->ctrl;
+	struct xpcs_ctrl *xpcs = &serdes->xpcs;
+	struct udevice *dev = serdes->dev;
+	bool shared = false;
+
+	void __iomem *base;
+	unsigned long rate;
+	int ret;
+
+	if (xpcs->phys[id])
+		return 0;
+
+	if (!id)
+		base = xpcs->base0;
+	else
+		base = xpcs->base1;
+
+	ret = get_clk_rate(serdes, &rate);
+	if (ret)
+		return ret;
+
+	if (ctrl->ss_mode == 1 || ctrl->ss_mode == 2)
+		shared = true;
+
+	return xpcs->ops->init(&xpcs->phys[id], dev, id, base,
+			       ctrl->ext_clk, rate, shared);
 }
 
-static void s32_serdes_start_mode5(struct serdes *serdes,
-				   enum serdes_xpcs_mode_gen2 xpcs[2])
+static int xpcs_phy_power_on(struct serdes *serdes, int id)
 {
-	if (!s32_serdes_has_mode5_enabled(serdes->id))
-		return;
-
-	printf("SerDes%d: Enabling serdes mode5\n", serdes->id);
-	/* Initialize PMA */
-	serdes_pma_mode5(serdes->xpcs.base1);
-	/* Initialize PHY */
-	s32_serdes_xpcs1_pma_config(serdes);
-	/* Initialize PCS */
-	serdes_pcs_mode5(serdes->xpcs.base1);
-	/* mode5 representation */
-	xpcs[0] = SGMII_XPCS_PCIE;
-	xpcs[1] = SGMII_XPCS_2G5_OP;
+	struct xpcs_ctrl *xpcs = &serdes->xpcs;
+	int ret;
+
+	if (xpcs->powered_on[id])
+		return 0;
+
+	ret = xpcs->ops->power_on(xpcs->phys[id]);
+	if (ret)
+		dev_err(serdes->dev, "Failed to power on XPCS%d\n", id);
+	else
+		xpcs->powered_on[id] = true;
+
+	return ret;
 }
 
-static int xpcs_init_clks(struct serdes *serdes)
+static bool is_xpcs_rx_stable(struct serdes *serdes, int id)
 {
-	/* Get XPCS configuration */
-	enum serdes_xpcs_mode xpcs_mode;
-	enum serdes_xpcs_mode_gen2 xpcs[2] = {SGMII_XPCS_PCIE};
-	unsigned long rate;
-	int ret;
+	struct xpcs_ctrl *xpcs = &serdes->xpcs;
 
-	xpcs_mode = s32_serdes_get_xpcs_cfg_from_hwconfig(serdes->id);
+	return xpcs->ops->has_valid_rx(xpcs->phys[id]);
+}
 
-	/* Nothing to do if PCIE only */
-	if (!serdes->ctrl.ss_mode)
-		return 0;
+static int xpcs_init_clks(struct serdes *serdes)
+{
+	struct serdes_ctrl *ctrl = &serdes->ctrl;
+	struct xpcs_ctrl *xpcs = &serdes->xpcs;
+	int ret, order[2], i, xpcs_id;
 
-	/* Nothing to do if XPCS options are invalid */
-	if (xpcs_mode == SGMII_INAVALID)
+	if (xpcs->initialized_clks)
 		return 0;
 
-	ret = get_clk_rate(serdes, &rate);
-	if (ret)
+	switch (ctrl->ss_mode) {
+	case 0:
+		return 0;
+	case 1:
+		order[0] = XPCS_ID_0;
+		order[1] = XPCS_DISABLED;
+		break;
+	case 2:
+		order[0] = XPCS_ID_1;
+		order[1] = XPCS_DISABLED;
+		break;
+	case 3:
+		order[0] = XPCS_ID_1;
+		order[1] = XPCS_ID_0;
+		break;
+	case 4:
+		order[0] = XPCS_ID_0;
+		order[1] = XPCS_ID_1;
+		break;
+	default:
 		return -EINVAL;
+	}
 
-	/* Check, if mode5 demo is requested */
-	s32_serdes_start_mode5(serdes, xpcs);
+	for (i = 0; i < ARRAY_SIZE(order); i++) {
+		xpcs_id = order[i];
 
-	ret = s32_eth_xpcs_init(serdes->xpcs.base0, serdes->xpcs.base1,
-				serdes->id,
-				serdes->ctrl.ss_mode,
-				xpcs_mode,
-				serdes->ctrl.ext_clk,
-				rate,
-				xpcs);
-	if (ret) {
-		printf("Error during configuration of SGMII on");
-		printf(" PCIe%d\n", serdes->id);
+		if (xpcs_id == XPCS_DISABLED)
+			continue;
+
+		ret = xpcs_phy_init(serdes, xpcs_id);
+		if (ret)
+			return ret;
+
+		ret = xpcs_phy_power_on(serdes, xpcs_id);
+		if (ret)
+			return ret;
+
+		ret = xpcs->ops->init_plls(xpcs->phys[xpcs_id]);
+		if (ret)
+			return ret;
 	}
 
-	return ret;
+	for (i = 0; i < ARRAY_SIZE(order); i++) {
+		xpcs_id = order[i];
+
+		if (xpcs_id == XPCS_DISABLED)
+			continue;
+
+		ret = xpcs->ops->vreset(xpcs->phys[xpcs_id]);
+		if (ret)
+			return ret;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(order); i++) {
+		xpcs_id = order[i];
+
+		if (xpcs_id == XPCS_DISABLED)
+			continue;
+
+		ret = xpcs->ops->wait_vreset(xpcs->phys[xpcs_id]);
+		if (ret)
+			return ret;
+
+		xpcs->ops->reset_rx(xpcs->phys[xpcs_id]);
+
+		if (!is_xpcs_rx_stable(serdes, xpcs_id))
+			dev_info(serdes->dev,
+				 "Unstable RX detected on XPCS%d\n", xpcs_id);
+	}
+
+	xpcs->initialized_clks = true;
+	return 0;
 }
 
 static int serdes_phy_init(struct phy *p)
 {
-	/* Nothing to do for PCIE phys */
-	return 0;
+	struct serdes *serdes = dev_get_priv(p->dev);
+	int id = p->id;
+
+	if (!serdes)
+		return -EINVAL;
+
+	if (serdes->phys_type[id] == PHY_TYPE_PCIE)
+		return 0;
+
+	if (serdes->phys_type[id] == PHY_TYPE_XPCS)
+		return xpcs_phy_init(serdes, p->id);
+
+	return -EINVAL;
 }
 
 static int serdes_phy_set_mode_ext(struct phy *p, int mode, int submode)
@@ -380,61 +470,247 @@ static int serdes_phy_set_mode_ext(struct phy *p, int mode, int submode)
 	if (!serdes)
 		return -EINVAL;
 
+	if (serdes->phys_type[id] != PHY_TYPE_PCIE)
+		return -EINVAL;
+
 	/* Check if same PCIE PHY mode is set on both lanes */
 	if (id == 1)
 		if (submode != serdes->ctrl.phy_mode)
 			return -EINVAL;
 
-	/* Do not configure SRIS or CRSS PHY MODE in conjunction
-	 * with any SGMII mode on the same SerDes subsystem
-	 */
-	if (submode == CRSS || submode == SRIS) {
-		if (serdes->ctrl.ss_mode != 0)
-			return -EINVAL;
-	}
+	if (mode == PHY_TYPE_PCIE) {
+		/* Do not configure SRIS or CRSS PHY MODE in conjunction
+		 * with any SGMII mode on the same SerDes subsystem
+		 */
+		if (submode == CRSS || submode == SRIS) {
+			if (serdes->ctrl.ss_mode != 0)
+				return -EINVAL;
+		}
 
-	/* CRSS or SRIS PCIE PHY mode cannot be used
-	 * with internal clock
-	 */
-	if (!serdes->ctrl.ext_clk)
-		if (submode == CRSS || submode == SRIS)
-			return -EINVAL;
+		/* CRSS or SRIS PCIE PHY mode cannot be used
+		 * with internal clock
+		 */
+		if (!serdes->ctrl.ext_clk)
+			if (submode == CRSS || submode == SRIS)
+				return -EINVAL;
 
-	serdes->ctrl.phy_mode = (enum pcie_phy_mode)submode;
+		serdes->ctrl.phy_mode = (enum pcie_phy_mode)submode;
 
-	return 0;
+		return 0;
+	}
+
+	return -EINVAL;
 }
 
 static int serdes_phy_power_on(struct phy *p)
 {
 	struct serdes *serdes = dev_get_priv(p->dev);
+	int id = p->id;
+
+	if (!serdes)
+		return -EINVAL;
+
+	if (serdes->phys_type[id] == PHY_TYPE_PCIE)
+		return pcie_phy_power_on(serdes, p->id);
+
+	if (serdes->phys_type[id] == PHY_TYPE_XPCS)
+		return xpcs_phy_power_on(serdes, p->id);
+
+	return 0;
+}
+
+static int serdes_phy_power_off(struct phy *p)
+{
+	return 0;
+}
+
+static int xpcs_phy_configure(struct phy *phy, struct phylink_link_state *state)
+{
+	struct serdes *serdes = dev_get_priv(phy->dev);
+	struct xpcs_ctrl *xpcs;
+	__maybe_unused struct udevice *dev;
 	int ret;
 
 	if (!serdes)
 		return -EINVAL;
 
-	ret = pcie_phy_power_on(serdes, p->id);
-	if (ret)
+	xpcs = &serdes->xpcs;
+	dev = serdes->dev;
+
+	ret = xpcs->ops->config(xpcs->phys[phy->id], NULL);
+	if (ret) {
+		dev_err(dev, "Failed to configure XPCS\n");
 		return ret;
+	}
+
+	return ret;
+}
+
+static int serdes_phy_configure(struct phy *phy, void *params)
+{
+	struct serdes *serdes = dev_get_priv(phy->dev);
+	int id = phy->id;
+	int ret = -EINVAL;
+
+	if (!serdes)
+		return -EINVAL;
+
+	if (serdes->phys_type[id] == PHY_TYPE_XPCS)
+		ret = xpcs_phy_configure(phy,
+					 (struct phylink_link_state *)params);
 
 	return ret;
 }
 
+static const struct serdes_conf serdes_mux_table[] = {
+	/* Mode 0 */
+	{ .lanes = { [0] = PCIE_LANE(0), [1] = PCIE_LANE(1) }, },
+	/* Mode 1 */
+	{ .lanes = { [0] = PCIE_LANE(0), [1] = XPCS_LANE(0), }, },
+	/* Mode 2 */
+	{ .lanes = { [0] = PCIE_LANE(0), [1] = XPCS_LANE(1), }, },
+	/* Mode 3 */
+	{ .lanes = { [0] = XPCS_LANE(0), [1] = XPCS_LANE(1), }, },
+	/* Mode 4 */
+	{ .lanes = { [0] = XPCS_LANE(0), [1] = XPCS_LANE(1), }, },
+};
+
+struct s32cc_xpcs *s32cc_phy2xpcs(struct phy *phy)
+{
+	struct serdes *serdes = dev_get_priv(phy->dev);
+	const struct serdes_lane_conf *lane_conf;
+	unsigned long lane = phy->id;
+	u32 ss_mode;
+	struct xpcs_ctrl *xpcs;
+
+	if (!serdes)
+		return NULL;
+
+	xpcs = &serdes->xpcs;
+	ss_mode = serdes->ctrl.ss_mode;
+	lane_conf = &serdes_mux_table[ss_mode].lanes[lane];
+
+	if (lane_conf->type != PHY_TYPE_XPCS)
+		return NULL;
+
+	return xpcs->phys[lane_conf->instance];
+}
+
+static int mode_to_pcs_lane(int mode, int pcs_instance)
+{
+	const struct serdes_lane_conf *l0 = &serdes_mux_table[mode].lanes[0];
+	const struct serdes_lane_conf *l1 = &serdes_mux_table[mode].lanes[1];
+
+	if (l0->type == PHY_TYPE_XPCS && l0->instance == pcs_instance)
+		return XPCS_LANE0;
+
+	if (l1->type == PHY_TYPE_XPCS && l1->instance == pcs_instance)
+		return XPCS_LANE1;
+
+	return XPCS_DISABLED;
+}
+
+static int check_lane_selection(struct serdes *serdes,
+				u32 phy_type, u32 instance,
+				u32 *lane_id)
+{
+	struct serdes_ctrl *ctrl = &serdes->ctrl;
+	const struct serdes_conf *conf = &serdes_mux_table[ctrl->ss_mode];
+	const struct serdes_lane_conf *lane_conf;
+	__maybe_unused struct udevice *dev = serdes->dev;
+	const char *phy_name;
+	int pcs_lane_id;
+
+	if (instance >= SERDES_MAX_INSTANCES) {
+		dev_err(dev, "Invalid instance : %u\n", instance);
+		return -EINVAL;
+	}
+
+	if (phy_type == PHY_TYPE_XPCS) {
+		pcs_lane_id = mode_to_pcs_lane(ctrl->ss_mode, instance);
+		if (pcs_lane_id >= 0) {
+			*lane_id = pcs_lane_id;
+		} else {
+			dev_err(dev, "Couldn't translate XPCS to lane\n");
+			return -EINVAL;
+		}
+	}
+
+	if (*lane_id >= SERDES_MAX_LANES) {
+		dev_err(dev, "Invalid lane : %u\n", *lane_id);
+		return -EINVAL;
+	}
+
+	switch (phy_type) {
+	case PHY_TYPE_PCIE:
+		phy_name = __stringify_1(PHY_TYPE_PCIE);
+		break;
+	case PHY_TYPE_XPCS:
+		phy_name = __stringify_1(PHY_TYPE_XPCS);
+		break;
+	default:
+		dev_err(dev, "Invalid PHY type : %u\n", phy_type);
+		return -EINVAL;
+	}
+
+	if (is_lane_configured(serdes, *lane_id) && phy_type != PHY_TYPE_XPCS) {
+		dev_err(dev, "Lane %u is already configured\n", *lane_id);
+		return -EINVAL;
+	}
+
+	lane_conf = &conf->lanes[*lane_id];
+
+	if (lane_conf->type != phy_type) {
+		dev_err(dev, "Invalid %u type applied on SerDes lane %d. Expected type %u\n",
+			phy_type, *lane_id, lane_conf->type);
+		return -EINVAL;
+	}
+
+	if (lane_conf->type != PHY_TYPE_PCIE &&
+	    lane_conf->instance != instance) {
+		dev_err(dev, "PHY %s instance %u cannot be applied on lane %u using SerDes mode %u)\n",
+			phy_name, instance, *lane_id, serdes->ctrl.ss_mode);
+		return -EINVAL;
+	}
+
+	mark_configured_lane(serdes, *lane_id);
+	return 0;
+}
+
 static int serdes_phy_xlate(struct phy *phy, struct ofnode_phandle_args *args)
 {
+	struct serdes *serdes = dev_get_priv(phy->dev);
+	u32 phy_type, instance, lane_id;
+	int ret;
+
+	if (!serdes)
+		return -EINVAL;
+
 	if (args->args_count < 3)
 		return -EINVAL;
 
-	phy->id = args->args[2];
+	phy_type = args->args[0];
+	instance = args->args[1];
+	lane_id = args->args[2];
+
+	ret = check_lane_selection(serdes, phy_type, instance, &lane_id);
+	if (ret)
+		return ret;
+
+	phy->id = lane_id;
+	serdes->phys_type[lane_id] = phy_type;
 
 	return 0;
 }
 
 static const struct phy_ops serdes_ops = {
 	.of_xlate	= serdes_phy_xlate,
+	.reset		= serdes_phy_reset,
 	.init		= serdes_phy_init,
 	.set_mode	= serdes_phy_set_mode_ext,
 	.power_on	= serdes_phy_power_on,
+	.power_off	= serdes_phy_power_off,
+	.configure	= serdes_phy_configure,
 };
 
 static int assert_reset(struct serdes *serdes)
@@ -516,38 +792,6 @@ static int init_serdes(struct serdes *serdes)
 	return ret;
 }
 
-__weak int s32_eth_xpcs_init(void __iomem *xpcs0, void __iomem *xpcs1,
-			     int id, u32 ss_mode,
-			     enum serdes_xpcs_mode xpcs_mode,
-			     bool ext_clk,
-			     unsigned long fmhz,
-			     enum serdes_xpcs_mode_gen2 xpcs[2])
-{
-	/* Configure SereDes XPCS for PFE/GMAC*/
-	printf("SerDes%d: XPCS is disabled\n", id);
-	return -ENODEV;
-}
-
-static int get_serdes_alias_id(struct udevice *dev, int *devnump)
-{
-	ofnode node = dev_ofnode(dev);
-	const char *uc_name = "serdes";
-	int ret;
-
-	if (ofnode_is_np(node)) {
-		ret = of_alias_get_id(ofnode_to_np(node), uc_name);
-		if (ret >= 0) {
-			*devnump = ret;
-			ret = 0;
-		}
-	} else {
-		ret = fdtdec_get_alias_seq(gd->fdt_blob, uc_name,
-					   ofnode_to_offset(node), devnump);
-	}
-
-	return ret;
-}
-
 static int ss_dt_init(struct udevice *dev, struct serdes *serdes)
 {
 	struct serdes_ctrl *ctrl = &serdes->ctrl;
@@ -555,9 +799,9 @@ static int ss_dt_init(struct udevice *dev, struct serdes *serdes)
 	int ret = 0;
 	size_t i;
 
-	ret = get_serdes_alias_id(dev, &serdes->id);
+	ret = s32_serdes_get_alias_id(dev, &serdes->id);
 	if (ret < 0) {
-		printf("Failed to get SerDes device id\n");
+		dev_err(dev, "Failed to get SerDes device id\n");
 		return ret;
 	}
 
@@ -665,6 +909,8 @@ static int xpcs_dt_init(struct udevice *dev, struct serdes *serdes)
 		return -ENOMEM;
 	}
 
+	xpcs->ops = s32cc_xpcs_get_ops();
+
 	return 0;
 }
 
@@ -692,7 +938,7 @@ static int serdes_probe(struct udevice *dev)
 
 	debug("%s: probing %s\n", __func__, dev->name);
 	if (!serdes) {
-		printf("s32-serdes: invalid internal data\n");
+		dev_err(dev, "Invalid internal data\n");
 		return -EINVAL;
 	}
 
-- 
2.17.1

