From 009913d00caa4264d76c586c873b3ae2092c7e37 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Thu, 14 Jul 2022 11:23:54 +0300
Subject: [PATCH 030/102] arm: s32cc: Make hwconfig validation part of the
 platform code

Issue: ALB-8357
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 arch/arm/mach-s32/s32-cc/hwconfig_fixups.c | 30 ++++++++++++++-
 arch/arm/mach-s32/s32-cc/serdes_hwconfig.c | 44 +++++++++++++++++++++-
 drivers/pci/serdes_s32gen1.c               | 43 ++-------------------
 3 files changed, 75 insertions(+), 42 deletions(-)

diff --git a/arch/arm/mach-s32/s32-cc/hwconfig_fixups.c b/arch/arm/mach-s32/s32-cc/hwconfig_fixups.c
index cf57ff47ef..f8408f2f97 100644
--- a/arch/arm/mach-s32/s32-cc/hwconfig_fixups.c
+++ b/arch/arm/mach-s32/s32-cc/hwconfig_fixups.c
@@ -4,6 +4,7 @@
  */
 #include <common.h>
 #include <malloc.h>
+#include <asm/arch-s32/s32-cc/serdes_regs.h>
 #include <dm/device.h>
 #include <dm/of_access.h>
 #include <dm/ofnode.h>
@@ -676,6 +677,27 @@ static int set_serdes_mode(struct dts_node *root, int id)
 	return ret;
 }
 
+static void disable_serdes_pcie_nodes(struct dts_node *root, u32 id)
+{
+	size_t i;
+	int ret;
+	struct dts_node node;
+	static const char * const fmts[] = {SERDES_ALIAS_FMT, PCIE_ALIAS_FMT};
+
+	for (i = 0; i < ARRAY_SIZE(fmts); i++) {
+		ret = node_by_alias(root, &node, fmts[i], id);
+		if (ret) {
+			pr_err("Failed to get '%s%u' alias\n", fmts[i], id);
+			continue;
+		}
+
+		ret = disable_node(&node);
+		if (ret) {
+			pr_err("Failed to disable %s%u\n", fmts[i], id);
+		}
+	}
+}
+
 static int apply_hwconfig_fixups(bool fdt, void *blob)
 {
 	int ret;
@@ -686,10 +708,16 @@ static int apply_hwconfig_fixups(bool fdt, void *blob)
 	};
 
 	for (id = 0; id <= 1; id++) {
+		if (!s32_serdes_is_cfg_valid(id)) {
+			disable_serdes_pcie_nodes(&root, id);
+			pr_err("SerDes%d configuration will be ignored as it's invalid\n",
+			       id);
+			continue;
+		}
+
 		ret = prepare_pcie_node(&root, id);
 		if (ret) {
 			pr_err("Failed to PCIe ofnode%d\n", id);
-			return ret;
 		}
 
 		ret = set_serdes_clk(&root, id);
diff --git a/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c b/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c
index 353d529fae..cc55715b6a 100644
--- a/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c
+++ b/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c
@@ -220,13 +220,22 @@ enum serdes_mode s32_serdes_get_op_mode_from_hwconfig(int id)
 	return SERDES_MODE_INVAL;
 }
 
-bool s32_serdes_is_xpcs_cfg_valid(int id, enum serdes_clock_fmhz freq)
+bool s32_serdes_is_cfg_valid(int id)
 {
 	enum serdes_dev_type devtype;
 	enum serdes_xpcs_mode xpcs_mode;
+	enum serdes_clock_fmhz freq;
+	enum serdes_mode mode;
 
+	freq = s32_serdes_get_clock_fmhz_from_hwconfig(id);
 	devtype = s32_serdes_get_mode_from_hwconfig(id);
 	xpcs_mode = s32_serdes_get_xpcs_cfg_from_hwconfig(id);
+	mode = s32_serdes_get_op_mode_from_hwconfig(id);
+
+	if (devtype == SERDES_INVALID) {
+		printf("Invalid SerDes%d configuration\n", id);
+		return false;
+	}
 
 	if (IS_SERDES_PCIE(devtype) && freq == CLK_125MHZ) {
 		printf("Invalid \"hwconfig\": In PCIe/SGMII combo");
@@ -235,11 +244,42 @@ bool s32_serdes_is_xpcs_cfg_valid(int id, enum serdes_clock_fmhz freq)
 		return false;
 	}
 
-	if (xpcs_mode == SGMII_INAVALID) {
+	if (IS_SERDES_SGMII(devtype) && xpcs_mode == SGMII_INAVALID) {
 		printf("Invalid \"hwconfig\": \"xpcs_mode\" is missing\n");
 		/* SGMII configuration fail */
 		return false;
 	}
 
+	/* validate that required 'mode' does not interfere
+	 * with 'hwconfig'
+	 */
+	switch (mode & ~(uint32_t)(SERDES_SKIP)) {
+	case SERDES_MODE_PCIE_PCIE:
+		/* only PCIE, no SGMII for this mode */
+		if (!IS_SERDES_PCIE(devtype) || IS_SERDES_SGMII(devtype)) {
+			printf("SGMII isn't allowed when using PCIe mode\n");
+			return false;
+		}
+		break;
+	/* Will have to figure out how to handle SERDES_MODE_SGMII_PCIE
+	 * and SERDES_MODE_PCIE_SGMII, since lane assignment may differ.
+	 */
+	case SERDES_MODE_PCIE_SGMII0:
+	case SERDES_MODE_PCIE_SGMII1:
+		if (!IS_SERDES_PCIE(devtype) || !IS_SERDES_SGMII(devtype)) {
+			printf("The SerDes mode is incompletely described\n");
+			return false;
+		}
+		break;
+	case SERDES_MODE_SGMII_SGMII:
+		if (IS_SERDES_PCIE(devtype) || !IS_SERDES_SGMII(devtype)) {
+			printf("The SerDes mode is incompletely described\n");
+			return false;
+		}
+		break;
+	default:
+		return false;
+	}
+
 	return true;
 }
diff --git a/drivers/pci/serdes_s32gen1.c b/drivers/pci/serdes_s32gen1.c
index 9640c3b090..814887292e 100644
--- a/drivers/pci/serdes_s32gen1.c
+++ b/drivers/pci/serdes_s32gen1.c
@@ -49,34 +49,8 @@ int wait_read32(void __iomem *address, u32 expected,
 	return 0;
 }
 
-static int s32_serdes_set_mode(void __iomem *dbi, int id, enum serdes_mode mode)
+static int s32_serdes_set_mode(void __iomem *dbi, enum serdes_mode mode)
 {
-	enum serdes_dev_type devtype = s32_serdes_get_mode_from_hwconfig(id);
-
-	/* validate that required 'mode' does not interfere
-	 * with 'hwconfig'
-	 */
-	switch (mode) {
-	case SERDES_MODE_PCIE_PCIE:
-		/* only PCIE, no SGMII for this mode */
-		if (!IS_SERDES_PCIE(devtype) || IS_SERDES_SGMII(devtype))
-			return -EINVAL;
-		break;
-	/* Will have to figure out how to handle SERDES_MODE_SGMII_PCIE
-	 * and SERDES_MODE_PCIE_SGMII, since lane assignment may differ.
-	 */
-	case SERDES_MODE_PCIE_SGMII0:
-	case SERDES_MODE_PCIE_SGMII1:
-		if (!IS_SERDES_PCIE(devtype) || !IS_SERDES_SGMII(devtype))
-			return -EINVAL;
-		break;
-	case SERDES_MODE_SGMII_SGMII:
-		if (IS_SERDES_PCIE(devtype) || !IS_SERDES_SGMII(devtype))
-			return -EINVAL;
-		break;
-	default: return -EINVAL;
-	}
-
 	BSET32(UPTR(dbi) + SS_SS_RW_REG_0, BUILD_MASK_VALUE(SUBSYS_MODE, mode));
 
 	/* small delay for stabilizing the signals */
@@ -269,7 +243,7 @@ static bool s32_serdes_init(struct s32_serdes *pcie)
 		W32(UPTR(pcie->dbi) + SS_PHY_GEN_CTRL, EXT_PCLK_REQ);
 	}
 
-	if (s32_serdes_set_mode(pcie->dbi, pcie->id, pcie->ss_mode))
+	if (s32_serdes_set_mode(pcie->dbi, pcie->ss_mode))
 		return false;
 
 	/* Set the clock for the Serdes module */
@@ -442,11 +416,6 @@ static int s32_serdes_probe(struct udevice *dev)
 		return ret;
 
 	pcie->devtype = s32_serdes_get_mode_from_hwconfig(pcie->id);
-	if (pcie->devtype == SERDES_INVALID) {
-		printf("Not configuring SerDes%d,", pcie->id);
-		printf(" no RC/EP/SGMII configuration selected\n");
-		return ret;
-	}
 
 	if (pcie->devtype & SERDES_SKIP) {
 		printf("Skipping configuration for SerDes%d,", pcie->id);
@@ -469,17 +438,13 @@ static int s32_serdes_probe(struct udevice *dev)
 
 	pcie->phy_mode = s32_serdes_get_phy_mode_from_hwconfig(pcie->id);
 
-	if (pcie->clktype == CLK_INT)
+	if (pcie->clktype == CLK_INT) {
 		if (pcie->phy_mode == CRSS || pcie->phy_mode == SRIS) {
 			printf("CRSS or SRIS for PCIe%d PHY mode cannot be used with internal clock\n",
 			       pcie->id);
 			return -EINVAL;
 		}
-
-	/* In case of sgmii mode check xpcs configuration */
-	if (IS_SERDES_SGMII(pcie->devtype) &&
-	    !s32_serdes_is_xpcs_cfg_valid(pcie->id, pcie->fmhz))
-		pcie->xpcs_mode = SGMII_INAVALID;
+	}
 
 	pcie_phy_mode = s32_serdes_get_pcie_phy_mode(pcie);
 	printf("Using %s clock for PCIe%d, %s\n",
-- 
2.17.1

