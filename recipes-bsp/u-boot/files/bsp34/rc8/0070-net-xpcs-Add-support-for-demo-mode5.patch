From d0f7499b60b1314ee19c13edee98fb511f9c2bb9 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Thu, 4 Aug 2022 10:22:58 +0300
Subject: [PATCH 070/102] net: xpcs: Add support for demo mode5

Issue: ALB-8357
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 arch/arm/mach-s32/include/s32-cc/xpcs.h |   9 +-
 drivers/net/pcs/nxp-s32cc-xpcs.c        |  80 +++++++++++++++--
 drivers/phy/nxp/s32cc-serdes.c          | 113 +++++++++++++++++++++---
 3 files changed, 181 insertions(+), 21 deletions(-)

diff --git a/arch/arm/mach-s32/include/s32-cc/xpcs.h b/arch/arm/mach-s32/include/s32-cc/xpcs.h
index d06a887e0f..a004bdd570 100644
--- a/arch/arm/mach-s32/include/s32-cc/xpcs.h
+++ b/arch/arm/mach-s32/include/s32-cc/xpcs.h
@@ -10,6 +10,12 @@
 
 struct s32cc_xpcs;
 
+enum pcie_xpcs_mode {
+	NOT_SHARED,
+	PCIE_XPCS_1G,
+	PCIE_XPCS_2G5,
+};
+
 struct phylink_link_state {
 	int speed;
 	int duplex;
@@ -23,7 +29,7 @@ struct phylink_link_state {
 struct s32cc_xpcs_ops {
 	int (*init)(struct s32cc_xpcs **xpcs, struct udevice *dev,
 		    unsigned char id, void __iomem *base, bool ext_clk,
-		    unsigned long rate, bool pcie_shared);
+		    unsigned long rate, enum pcie_xpcs_mode pcie_shared);
 	int (*power_on)(struct s32cc_xpcs *xpcs);
 	int (*config)(struct s32cc_xpcs *xpcs,
 		      const struct phylink_link_state *state);
@@ -32,6 +38,7 @@ struct s32cc_xpcs_ops {
 	int (*init_plls)(struct s32cc_xpcs *xpcs);
 	int (*reset_rx)(struct s32cc_xpcs *xpcs);
 	bool (*has_valid_rx)(struct s32cc_xpcs *xpcs);
+	int (*pre_pcie_2g5)(struct s32cc_xpcs *xpcs);
 
 	/* These function are planned to be used directly
 	 * by phylink in newer kernels (starting from 5.10).
diff --git a/drivers/net/pcs/nxp-s32cc-xpcs.c b/drivers/net/pcs/nxp-s32cc-xpcs.c
index ba1efb65aa..1bd8eeb0b0 100644
--- a/drivers/net/pcs/nxp-s32cc-xpcs.c
+++ b/drivers/net/pcs/nxp-s32cc-xpcs.c
@@ -79,7 +79,8 @@
 #define     POWER_GOOD_STATE			0x4
 
 #define VR_MII_GEN5_12G_16G_TX_GENCTRL1 0x1F8031U
-#define  TX_CLK_RDY_0				BIT(12)
+#define   VBOOST_EN_0				BIT(4)
+#define   TX_CLK_RDY_0				BIT(12)
 
 #define VR_MII_GEN5_12G_16G_TX_GENCTRL2 0x1F8032U
 #define  TX_REQ_0				BIT(0)
@@ -94,6 +95,9 @@
 #define   TX_EQ_MAIN_OFF			8
 #define   TX_EQ_MAIN_MASK			(0x3F << TX_EQ_MAIN_OFF)
 
+#define VR_MII_GEN5_12G_16G_TX_EQ_CTRL1		0x1F8037U
+#define   TX_EQ_OVR_RIDE			BIT(6)
+
 #define VR_MII_CONSUMER_10G_TX_TERM_CTRL	0x1F803CU
 #define   TX0_TERM_OFF				0
 #define   TX0_TERM_MASK				0x7
@@ -111,6 +115,7 @@
 #define     RX0_BAUD_DIV_8			0x3
 
 #define VR_MII_GEN5_12G_16G_CDR_CTRL		0x1F8056U
+#define   CDR_SSC_EN_0				BIT(4)
 #define   VCO_LOW_FREQ_0			BIT(8)
 
 #define VR_MII_GEN5_12G_16G_MPLL_CMN_CTRL	0x1F8070U
@@ -156,6 +161,9 @@
 #define   MPLLB_BANDWIDTH_OFF			0x0
 #define   MPLLB_BANDWIDTH_MASK			0xFFFF
 
+#define VR_MII_GEN5_12G_16G_MISC_CTRL0		0x1F8090U
+#define   PLL_CTRL				BIT(15)
+
 #define VR_MII_GEN5_12G_16G_REF_CLK_CTRL	0x1F8091U
 #define   REF_CLK_EN				BIT(0)
 #define   REF_USE_PAD				BIT(1)
@@ -210,7 +218,7 @@ struct s32cc_xpcs {
 	unsigned char id;
 	bool ext_clk;
 	bool mhz125;
-	bool pcie_shared;
+	enum pcie_xpcs_mode pcie_shared;
 };
 
 typedef bool (*xpcs_poll_func_t)(struct s32cc_xpcs *);
@@ -315,11 +323,12 @@ static bool xpcs_readable_reg(struct udevice *dev, unsigned int reg)
 static int xpcs_regmap_reg_read(struct s32cc_xpcs *xpcs, unsigned int reg,
 				unsigned int *result)
 {
+	struct udevice *dev = get_xpcs_device(xpcs);
 	struct s32cc_xpcs_params params;
 	u32 data;
 
-	if (!xpcs_readable_reg(xpcs->dev, reg)) {
-		dev_err(xpcs->dev, "The register 0x%x isn't readable\n", reg);
+	if (!xpcs_readable_reg(dev, reg)) {
+		dev_err(dev, "The register 0x%x isn't readable\n", reg);
 		return -EPERM;
 	}
 
@@ -334,11 +343,12 @@ static int xpcs_regmap_reg_read(struct s32cc_xpcs *xpcs, unsigned int reg,
 static int xpcs_regmap_reg_write(struct s32cc_xpcs *xpcs, unsigned int reg,
 				 unsigned int val)
 {
+	struct udevice *dev = get_xpcs_device(xpcs);
 	struct s32cc_xpcs_params params;
 	u32 data;
 
-	if (!xpcs_writeable_reg(xpcs->dev, reg)) {
-		dev_err(xpcs->dev, "The register 0x%x isn't writable\n", reg);
+	if (!xpcs_writeable_reg(dev, reg)) {
+		dev_err(dev, "The register 0x%x isn't writable\n", reg);
 		return -EPERM;
 	}
 
@@ -400,7 +410,7 @@ static unsigned int xpcs_read(struct s32cc_xpcs *xpcs, const char *name,
 
 static int xpcs_init(struct s32cc_xpcs **xpcs, struct udevice *dev,
 		     unsigned char id, void __iomem *base, bool ext_clk,
-		     unsigned long rate, bool pcie_shared)
+		     unsigned long rate, enum pcie_xpcs_mode pcie_shared)
 {
 	struct s32cc_xpcs *xpcsp;
 
@@ -789,15 +799,40 @@ static int xpcs_init_mpllb(struct s32cc_xpcs *xpcs)
 	return 0;
 }
 
+static void serdes_pma_high_freq_recovery(struct s32cc_xpcs *xpcs)
+{
+	/* PCS signal protection, PLL railout recovery */
+	XPCS_WRITE_BITS(xpcs, VR_MII_DBG_CTRL, SUPPRESS_LOS_DET | RX_DT_EN_CTL,
+			SUPPRESS_LOS_DET | RX_DT_EN_CTL);
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_MISC_CTRL0,
+			PLL_CTRL, PLL_CTRL);
+}
+
+static void serdes_pma_configure_tx_eq_post(struct s32cc_xpcs *xpcs)
+{
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_TX_EQ_CTRL1,
+			TX_EQ_OVR_RIDE, TX_EQ_OVR_RIDE);
+}
+
 static int xpcs_init_plls(struct s32cc_xpcs *xpcs)
 {
 	int ret;
 	__maybe_unused struct udevice *dev = get_xpcs_device(xpcs);
 
-	if (!xpcs->ext_clk)
+	if (!xpcs->ext_clk) {
 		XPCS_WRITE_BITS(xpcs, VR_MII_DIG_CTRL1, BYP_PWRUP, BYP_PWRUP);
-	else if (!xpcs->pcie_shared)
+	} else if (xpcs->pcie_shared == NOT_SHARED) {
+		wait_power_good_state(xpcs);
+	} else if (xpcs->pcie_shared == PCIE_XPCS_2G5) {
 		wait_power_good_state(xpcs);
+		/* Configure equlaization */
+		serdes_pma_configure_tx_eq_post(xpcs);
+		xpcs_electrical_configure(xpcs);
+
+		/* Enable receiver recover */
+		serdes_pma_high_freq_recovery(xpcs);
+		return 0;
+	}
 
 	xpcs_electrical_configure(xpcs);
 
@@ -998,6 +1033,32 @@ static int xpcs_get_state(struct s32cc_xpcs *xpcs,
 	return 0;
 }
 
+static int xpcs_pre_pcie_2g5(struct s32cc_xpcs *xpcs)
+{
+	__maybe_unused struct udevice *dev = get_xpcs_device(xpcs);
+	int ret;
+
+	/* Enable volatge boost */
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_TX_GENCTRL1, VBOOST_EN_0,
+			VBOOST_EN_0);
+
+	/* TX rate baud  */
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_TX_RATE_CTRL, 0x7, 0x0U);
+
+	/* Rx rate baud/2 */
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_RX_RATE_CTRL, 0x3U, 0x1U);
+
+	/* Set low-frequency operating band */
+	XPCS_WRITE_BITS(xpcs, VR_MII_GEN5_12G_16G_CDR_CTRL, CDR_SSC_EN_0,
+			VCO_LOW_FREQ_0);
+
+	ret = serdes_bifurcation_pll_transit(xpcs, XPCS_PLLB);
+	if (ret)
+		dev_err(dev, "Switch to PLLB failed\n");
+
+	return ret;
+}
+
 static bool phylink_test(u32 advertising, u32 capab)
 {
 	return !!(advertising & capab);
@@ -1112,6 +1173,7 @@ static const struct s32cc_xpcs_ops s32cc_xpcs_ops = {
 	.init_plls = xpcs_init_plls,
 	.reset_rx = xpcs_reset_rx,
 	.has_valid_rx = xpcs_has_valid_rx,
+	.pre_pcie_2g5 = xpcs_pre_pcie_2g5,
 	.xpcs_config = xpcs_config,
 	.xpcs_get_state = xpcs_get_state,
 };
diff --git a/drivers/phy/nxp/s32cc-serdes.c b/drivers/phy/nxp/s32cc-serdes.c
index 752a8fe7ba..8bcad5f1b6 100644
--- a/drivers/phy/nxp/s32cc-serdes.c
+++ b/drivers/phy/nxp/s32cc-serdes.c
@@ -102,6 +102,8 @@
 #define PHY_REG_ADDR		(0x0)
 #define  PHY_REG_EN		BIT(31)
 #define PHY_REG_DATA		(0x4)
+#define PHY_RST_CTRL		(0x8)
+#define  WARM_RST		BIT(1)
 
 #define RAWLANE0_DIG_PCS_XF_RX_EQ_DELTA_IQ_OVRD_IN	(0x3019)
 #define RAWLANE1_DIG_PCS_XF_RX_EQ_DELTA_IQ_OVRD_IN	(0x3119)
@@ -189,6 +191,16 @@ static void pcie_phy_write(struct serdes *serdes, u32 reg, u32 val)
 	udelay(100);
 }
 
+static void pcie_phy_cold_reset(struct serdes *serdes)
+{
+	u32 val;
+
+	val = readl(UPTR(serdes->pcie.phy_base) + PHY_RST_CTRL);
+	writel(val | WARM_RST, UPTR(serdes->pcie.phy_base) + PHY_RST_CTRL);
+	udelay(1000);
+	writel(val, UPTR(serdes->pcie.phy_base) + PHY_RST_CTRL);
+}
+
 static struct clk *get_serdes_clk(struct serdes *serdes, const char *name)
 {
 	size_t i;
@@ -313,7 +325,7 @@ static int xpcs_phy_init(struct serdes *serdes, int id)
 	struct serdes_ctrl *ctrl = &serdes->ctrl;
 	struct xpcs_ctrl *xpcs = &serdes->xpcs;
 	struct udevice *dev = serdes->dev;
-	bool shared = false;
+	enum pcie_xpcs_mode shared = NOT_SHARED;
 
 	void __iomem *base;
 	unsigned long rate;
@@ -331,8 +343,11 @@ static int xpcs_phy_init(struct serdes *serdes, int id)
 	if (ret)
 		return ret;
 
+	/* Mode 5 is virtual mode, a particularization of mode 2 */
 	if (ctrl->ss_mode == 1 || ctrl->ss_mode == 2)
-		shared = true;
+		shared = PCIE_XPCS_1G;
+	else if (ctrl->ss_mode == 5)
+		shared = PCIE_XPCS_2G5;
 
 	return xpcs->ops->init(&xpcs->phys[id], dev, id, base,
 			       ctrl->ext_clk, rate, shared);
@@ -362,6 +377,63 @@ static bool is_xpcs_rx_stable(struct serdes *serdes, int id)
 	return xpcs->ops->has_valid_rx(xpcs->phys[id]);
 }
 
+static void prepare_pma_mode5(struct serdes *serdes)
+{
+	/* Configure TX_VBOOST_LVL and TX_TERM_CTRL */
+	clrsetbits_32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MISC_CTRL_2,
+		      EXT_TX_VBOOST_LVL(0x7) | EXT_TX_TERM_CTRL(0x7),
+		      EXT_TX_VBOOST_LVL(0x3) | EXT_TX_TERM_CTRL(0x4));
+
+	/* Enable phy external control */
+	setbits_32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_CTRL_SEL,
+		   EXT_PHY_CTRL_SEL);
+
+	/* Configure ref range, disable PLLB/ref div2 */
+	clrsetbits_32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_REF_CLK_CTRL,
+		      REF_CLK_DIV2_EN | REF_CLK_MPLLB_DIV2_EN |
+		      EXT_REF_RANGE(0x7),
+		      EXT_REF_RANGE(0x3));
+
+	/* Configure multiplier */
+	clrsetbits_32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MPLLB_CTRL_2,
+		      MPLLB_MULTIPLIER(0xffU) | EXT_MPLLB_FRACN_CTRL(0x7ff) |
+		      1 << 24U | 1 << 28U,
+		      MPLLB_MULTIPLIER(0x27U) | EXT_MPLLB_FRACN_CTRL(0x414));
+
+	clrbits_32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_MPLLB_CTRL,
+		   MPLLB_SSC_EN_MASK);
+
+	/* Configure tx lane division, disable word clock div2*/
+	clrsetbits_32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MPLLB_CTRL_3,
+		      EXT_MPLLB_WORD_DIV2_EN | EXT_MPLLB_TX_CLK_DIV(0x7),
+		      EXT_MPLLB_TX_CLK_DIV(0x5));
+
+	/* Configure configure bandwidth for filtering and div10*/
+	clrsetbits_32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MPLLB_CTRL_1,
+		      EXT_MPLLB_BANDWIDTH(0xffff) | EXT_MPLLB_DIV_CLK_EN |
+		      EXT_MPLLB_DIV8_CLK_EN | EXT_MPLLB_DIV_MULTIPLIER(0xff),
+		      EXT_MPLLB_BANDWIDTH(0x5f) | EXT_MPLLB_DIV10_CLK_EN);
+
+	clrsetbits_32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MPLLA_CTRL_1,
+		      EXT_MPLLA_BANDWIDTH(0xffff),
+		      EXT_MPLLA_BANDWIDTH(0xc5));
+
+	/* Configure VCO */
+	clrsetbits_32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_XPCS1_RX_OVRD_CTRL,
+		      XPCS1_RX_VCO_LD_VAL(0x1fffU) | XPCS1_RX_REF_LD_VAL(0x3fU),
+		      XPCS1_RX_VCO_LD_VAL(0x540U) | XPCS1_RX_REF_LD_VAL(0x2bU));
+
+	/* Boundary scan control */
+	clrsetbits_32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_BS_CTRL,
+		      EXT_BS_RX_LEVEL(0x1f) | EXT_BS_TX_LOWSWING,
+		      EXT_BS_RX_LEVEL(0xb) | EXT_BS_RX_BIGSWING);
+
+	/* Rx loss threshold */
+	clrsetbits_32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MISC_CTRL_1,
+		      EXT_RX_LOS_THRESHOLD(0x3fU) | EXT_RX_VREF_CTRL(0x1fU),
+		      EXT_RX_LOS_THRESHOLD(0x3U) | EXT_RX_VREF_CTRL(0x11U));
+}
+
 static int xpcs_init_clks(struct serdes *serdes)
 {
 	struct serdes_ctrl *ctrl = &serdes->ctrl;
@@ -379,6 +451,7 @@ static int xpcs_init_clks(struct serdes *serdes)
 		order[1] = XPCS_DISABLED;
 		break;
 	case 2:
+	case 5:
 		order[0] = XPCS_ID_1;
 		order[1] = XPCS_DISABLED;
 		break;
@@ -413,15 +486,28 @@ static int xpcs_init_clks(struct serdes *serdes)
 			return ret;
 	}
 
-	for (i = 0; i < ARRAY_SIZE(order); i++) {
-		xpcs_id = order[i];
-
-		if (xpcs_id == XPCS_DISABLED)
-			continue;
+	if (ctrl->ss_mode == 5) {
+		prepare_pma_mode5(serdes);
 
-		ret = xpcs->ops->vreset(xpcs->phys[xpcs_id]);
-		if (ret)
+		ret = xpcs->ops->pre_pcie_2g5(xpcs->phys[1]);
+		if (ret) {
+			dev_err(serdes->dev,
+				"Failed to prepare SerDes for PCIE & XPCS @ 2G5 mode\n");
 			return ret;
+		}
+
+		pcie_phy_cold_reset(serdes);
+	} else {
+		for (i = 0; i < ARRAY_SIZE(order); i++) {
+			xpcs_id = order[i];
+
+			if (xpcs_id == XPCS_DISABLED)
+				continue;
+
+			ret = xpcs->ops->vreset(xpcs->phys[xpcs_id]);
+			if (ret)
+				return ret;
+		}
 	}
 
 	for (i = 0; i < ARRAY_SIZE(order); i++) {
@@ -573,6 +659,8 @@ static const struct serdes_conf serdes_mux_table[] = {
 	{ .lanes = { [0] = XPCS_LANE(0), [1] = XPCS_LANE(1), }, },
 	/* Mode 4 */
 	{ .lanes = { [0] = XPCS_LANE(0), [1] = XPCS_LANE(1), }, },
+	/* Demo mode 5 (Mode 2, where XPCS runs @2G5) */
+	{ .lanes = { [0] = PCIE_LANE(0), [1] = XPCS_LANE(1), }, },
 };
 
 struct s32cc_xpcs *s32cc_phy2xpcs(struct phy *phy)
@@ -765,7 +853,10 @@ static int init_serdes(struct serdes *serdes)
 
 	reg0 = readl(UPTR(ctrl->ss_base) + SS_RW_REG_0);
 	reg0 &= ~SUBMODE_MASK;
-	reg0 |= ctrl->ss_mode;
+	if (ctrl->ss_mode == 5)
+		reg0 |= 2;
+	else
+		reg0 |= ctrl->ss_mode;
 	writel(reg0, UPTR(ctrl->ss_base) + SS_RW_REG_0);
 
 	reg0 = readl(UPTR(ctrl->ss_base) + SS_RW_REG_0);
@@ -866,7 +957,7 @@ static int pcie_dt_init(struct udevice *dev, struct serdes *serdes)
 
 	pcie->phy_base = devm_ioremap(dev, res.start, resource_size(&res));
 	if (!pcie->phy_base) {
-		dev_err(dev, "Failed to map 'ss_pcie'\n");
+		dev_err(dev, "Failed to map 'pcie_phy'\n");
 		return -ENOMEM;
 	}
 
-- 
2.17.1

