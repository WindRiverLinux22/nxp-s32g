From ea74b0043296ac3a154ec11a87cabc6369d87bb9 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Fri, 5 Aug 2022 13:12:08 +0300
Subject: [PATCH 072/102] s32cc: Remove unused SerDes files

Remove previous SerDes driver implementation

Issue: ALB-8357
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 .../include/asm/arch-s32/s32-cc/serdes_regs.h | 161 ----
 .../asm/arch-s32/s32-cc/serdes_xpcs_regs.h    | 219 -----
 arch/arm/include/asm/arch-s32/s32-cc/sgmii.h  |  24 -
 arch/arm/mach-s32/s32-cc/Makefile             |   6 -
 arch/arm/mach-s32/s32-cc/hwconfig_fixups.c    |   1 -
 arch/arm/mach-s32/s32-cc/serdes_hwconfig.c    |   6 +-
 arch/arm/mach-s32/s32-cc/sgmii/serdes_xpcs.c  | 779 ------------------
 arch/arm/mach-s32/s32-cc/sgmii/sgmii.c        | 373 ---------
 board/nxp/s32-cc/Makefile                     |   1 -
 board/nxp/s32g274abluebox3/s32g274abluebox3.c |   4 +-
 drivers/net/Makefile                          |   1 -
 drivers/net/pfeng/Makefile                    |   1 -
 drivers/net/s32/Makefile                      |   1 -
 drivers/pci/Makefile                          |   1 -
 drivers/pci/pcie_s32gen1.c                    |   3 +-
 drivers/pci/pcie_s32gen1.h                    | 117 +++
 drivers/pci/serdes_s32gen1_io.h               |  92 ---
 .../s32-cc => drivers/pci}/ss_pcie_regs.h     |   0
 drivers/phy/Makefile                          |   1 -
 drivers/phy/nxp/s32cc-serdes.c                |   7 +-
 20 files changed, 127 insertions(+), 1671 deletions(-)
 delete mode 100644 arch/arm/include/asm/arch-s32/s32-cc/serdes_regs.h
 delete mode 100644 arch/arm/include/asm/arch-s32/s32-cc/serdes_xpcs_regs.h
 delete mode 100644 arch/arm/include/asm/arch-s32/s32-cc/sgmii.h
 delete mode 100644 arch/arm/mach-s32/s32-cc/sgmii/serdes_xpcs.c
 delete mode 100644 arch/arm/mach-s32/s32-cc/sgmii/sgmii.c
 delete mode 100644 drivers/pci/serdes_s32gen1_io.h
 rename {arch/arm/include/asm/arch-s32/s32-cc => drivers/pci}/ss_pcie_regs.h (100%)

diff --git a/arch/arm/include/asm/arch-s32/s32-cc/serdes_regs.h b/arch/arm/include/asm/arch-s32/s32-cc/serdes_regs.h
deleted file mode 100644
index ddb4366962..0000000000
--- a/arch/arm/include/asm/arch-s32/s32-cc/serdes_regs.h
+++ /dev/null
@@ -1,161 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright 2019-2022 NXP
- *
- * The SerDes module header file.
- */
-
-#ifndef SERDES_REGS_H
-#define SERDES_REGS_H
-
-#include <linux/errno.h>
-#include <linux/types.h>
-#include <s32-cc/serdes_hwconfig.h>
-
-/* use a mask to fix DEVICE_TYPE for EP */
-#define SERDES_MODE(mode) (mode & 0xe)
-#define IS_SERDES_PCIE(mode) (mode & (PCIE_EP | PCIE_RC))
-#define IS_SERDES_SGMII(mode) (mode & (SGMII))
-
-#define SERDES_SS_BASE				0x80000
-
-#define SS_PHY_EXT_MPLLA_CTRL_2			(SERDES_SS_BASE + 0x34U)
-#define SS_PHY_EXT_MPLLA_CTRL_3			(SERDES_SS_BASE + 0x38U)
-#define SS_PHY_EXT_RX_EQ_CTRL_1A		(SERDES_SS_BASE + 0x50U)
-#define SS_PHY_EXT_RX_EQ_CTRL_1B		(SERDES_SS_BASE + 0x54U)
-#define SS_PHY_EXT_RX_EQ_CTRL_1C		(SERDES_SS_BASE + 0x58U)
-#define SS_PHY_EXT_RX_EQ_CTRL_2A		(SERDES_SS_BASE + 0x60U)
-#define SS_PHY_EXT_RX_EQ_CTRL_2B		(SERDES_SS_BASE + 0x64U)
-#define SS_PHY_EXT_RX_EQ_CTRL_2C		(SERDES_SS_BASE + 0x68U)
-#define SS_PHY_EXT_RX_EQ_CTRL_3A		(SERDES_SS_BASE + 0x70U)
-#define SS_PHY_EXT_RX_EQ_CTRL_3B		(SERDES_SS_BASE + 0x74U)
-#define SS_PHY_EXT_RX_EQ_CTRL_3C		(SERDES_SS_BASE + 0x78U)
-#define SS_PHY_EXT_RX_EQ_CTRL_4B		(SERDES_SS_BASE + 0x84U)
-#define SS_PHY_EXT_RX_EQ_CTRL_4C		(SERDES_SS_BASE + 0x88U)
-#define SS_PHY_EXT_CALI_CTRL_1			(SERDES_SS_BASE + 0x90U)
-#define SS_PHY_EXT_CALI_CTRL_2			(SERDES_SS_BASE + 0x94U)
-#define SS_PHY_EXT_CALI_CTRL_3			(SERDES_SS_BASE + 0x98U)
-#define SS_PHY_EXT_CALI_CTRL_4			(SERDES_SS_BASE + 0x9cU)
-#define SS_PHY_EXT_TX_EQ_CTRL_1			(SERDES_SS_BASE + 0xb0U)
-#define SS_PHY_EXT_TX_EQ_CTRL_2			(SERDES_SS_BASE + 0xb4U)
-#define SS_PHY_EXT_TX_EQ_CTRL_3			(SERDES_SS_BASE + 0xb8U)
-#define SS_PHY_XPCS0_RX_OVRD_CTRL		(SERDES_SS_BASE + 0xc0U)
-
-/* Subsystem Read Only Registers 0-3 */
-#define SS_SS_RO_REG_0				(SERDES_SS_BASE + 0xe0U)
-#define SS_SS_RO_REG_1				(SERDES_SS_BASE + 0xe4U)
-#define SS_SS_RO_REG_2				(SERDES_SS_BASE + 0xe5U)
-#define SS_SS_RO_REG_3				(SERDES_SS_BASE + 0xecU)
-
-/* Subsystem Read Write Registers 0-5 */
-#define SS_SS_RW_REG_1				(SERDES_SS_BASE + 0xf4U)
-#define SS_SS_RW_REG_2				(SERDES_SS_BASE + 0xf8U)
-#define SS_SS_RW_REG_3				(SERDES_SS_BASE + 0xfcU)
-#define SS_SS_RW_REG_4				(SERDES_SS_BASE + 0x100U)
-#define SS_SS_RW_REG_5				(SERDES_SS_BASE + 0x104U)
-
-#define SS_PCIE_SUBSYSTEM_VERSION		(SERDES_SS_BASE + 0x1000U)
-#define SS_LINK_INT_CTRL_STS			(SERDES_SS_BASE + 0x1040U)
-
-/* PCIe Controller 0 General Control 1-4 */
-#define SS_PE0_GEN_CTRL_1			(SERDES_SS_BASE + 0x1050U)
-#define SS_PE0_GEN_CTRL_2			(SERDES_SS_BASE + 0x1054U)
-#define SS_PE0_GEN_CTRL_3			(SERDES_SS_BASE + 0x1058U)
-#define SS_PE0_GEN_CTRL_4			(SERDES_SS_BASE + 0x105cU)
-
-#define SS_PE0_PM_CTRL				(SERDES_SS_BASE + 0x1060U)
-#define SS_PE0_PM_STS				(SERDES_SS_BASE + 0x1064U)
-#define SS_PE0_TX_MSG_HDR_1			(SERDES_SS_BASE + 0x1070U)
-#define SS_PE0_TX_MSG_HDR_2			(SERDES_SS_BASE + 0x1074U)
-#define SS_PE0_TX_MSG_HDR_3			(SERDES_SS_BASE + 0x1078U)
-#define SS_PE0_TX_MSG_HDR_4			(SERDES_SS_BASE + 0x107cU)
-#define SS_PE0_TX_MSG_REQ			(SERDES_SS_BASE + 0x1080U)
-#define SS_PE0_RX_MSG_HDR_1			(SERDES_SS_BASE + 0x1090U)
-#define SS_PE0_RX_MSG_HDR_2			(SERDES_SS_BASE + 0x1094U)
-#define SS_PE0_RX_MSG_HDR_3			(SERDES_SS_BASE + 0x1098U)
-#define SS_PE0_RX_MSG_HDR_4			(SERDES_SS_BASE + 0x109cU)
-#define SS_PE0_RX_MSG_STS			(SERDES_SS_BASE + 0x10a0U)
-#define SS_PE0_RX_MSG_CAP_CTRL			(SERDES_SS_BASE + 0x10a4U)
-#define SS_PE0_RX_MSG_INT_CTRL			(SERDES_SS_BASE + 0x10a8U)
-
-/* PCIe Controller 0 Link Debug 1 */
-#define SS_PE0_LINK_DBG_1			(SERDES_SS_BASE + 0x10b0U)
-/* PCIe Controller 0 Link Debug 2 */
-#define SS_PE0_LINK_DBG_2			(SERDES_SS_BASE + 0x10b4U)
-
-#define SS_PE0_AXI_MSTR_DBG_1			(SERDES_SS_BASE + 0x10c0U)
-#define SS_PE0_AXI_MSTR_DBG_2			(SERDES_SS_BASE + 0x10c4U)
-#define SS_PE0_AXI_SLV_DBG_1			(SERDES_SS_BASE + 0x10d0U)
-#define SS_PE0_AXI_SLV_DBG_2			(SERDES_SS_BASE + 0x10d4U)
-#define SS_PE0_ERR_STS				(SERDES_SS_BASE + 0x10e0U)
-#define SS_PE0_ERR_INT_CTRL			(SERDES_SS_BASE + 0x10e4U)
-#define SS_PE0_INT_STS				(SERDES_SS_BASE + 0x10e8U)
-#define SS_PE0_MSI_GEN_CTRL			(SERDES_SS_BASE + 0x10ecU)
-#define SS_PE0_FSM_TRACK_1			(SERDES_SS_BASE + 0x10f0U)
-#define SS_PE0_FSM_TRACK_2			(SERDES_SS_BASE + 0x10f4U)
-#define SS_APB_BRIDGE_TO_CTRL			(SERDES_SS_BASE + 0x3000U)
-
-/* RESET CONTROL Register */
-#define SS_RST_CTRL				(SERDES_SS_BASE + 0x3010U)
-
-/* Field definitions for SS_RST_CTRL */
-#define COLD_RST				BIT(1)
-
-/* Field definitions for PHY_EXT_MPLLA/B Registers */
-
-#define MPLLA_DIV8_CLK_EN			(1U << 8)
-#define MPLLA_DIV10_CLK_EN			(1U << 9)
-#define MPLLA_DIV_CLK_EN			(1U << 10)
-#define MPLLA_TX_CLK_DIV(x)			(((x) & 0x7U) << 11)
-#define MPLLA_CAL_DISABLE			(1U << 15)
-
-#define MPPLB_CAL_DISABLE			(1U << 15)
-#define MPLLB_MULTIPLIER(n)			(((n) & 0xffU) << 0)
-
-#define MPLLB_CTRL2_MPLLB_DIV_MULT(n)		(((n) & 0xffU) << 0)
-#define MPLLB_CTRL2_MPLLB_DIV8_CLK_EN		(1U << 8)
-#define MPLLB_DIV10_CLK_EN			BIT(9)
-#define MPLLB_CTRL2_MPLLB_DIV_CLK_EN		(1U << 10)
-#define MPLLB_TX_CLK_DIV(n)		(((n) & 0x7U) << 11)
-
-#define MPLLA_STATE_BIT        (31)
-#define MPLLA_STATE            BIT(MPLLA_STATE_BIT)
-
-/* Field definitions for PCIE_PHY_MPLLB_CTRL */
-
-#define MPLLB_FORCE_EN_BIT      (0)
-#define MPLLB_FORCE_EN          BIT(MPLLB_FORCE_EN_BIT)
-
-#define MPLLB_STATE_BIT        (31)
-#define MPLLB_STATE            BIT(MPLLB_STATE_BIT)
-
-/* Field definitions for PE0_GEN_CTRL_1 */
-
-#define DEVICE_TYPE_OVERRIDE       0x10
-#define DEVICE_TYPE_EP             0x0
-#define DEVICE_TYPE_RC             0x4
-
-#define DEVICE_TYPE_LSB            (0)
-#define DEVICE_TYPE_MASK           (0x0000000F)
-#define DEVICE_TYPE                ((DEVICE_TYPE_MASK) << \
-		(DEVICE_TYPE_LSB))
-
-/* Field definitions for PE0_LINK_DBG_2 */
-
-#define SMLH_LTSSM_STATE_LSB       (0)
-#define SMLH_LTSSM_STATE_MASK      (0x0000003F)
-#define SMLH_LTSSM_STATE           ((SMLH_LTSSM_STATE_MASK) << \
-		(SMLH_LTSSM_STATE_LSB))
-
-#define SMLH_LINK_UP_BIT           (6)
-#define SMLH_LINK_UP               BIT(SMLH_LINK_UP_BIT)
-
-#define RDLH_LINK_UP_BIT           (7)
-#define RDLH_LINK_UP               BIT(RDLH_LINK_UP_BIT)
-
-#define RATE_LSB           (8)
-#define RATE_MASK          (0x00000003)
-#define RATE               ((RATE_MASK) << (RATE_LSB))
-
-#endif
-
diff --git a/arch/arm/include/asm/arch-s32/s32-cc/serdes_xpcs_regs.h b/arch/arm/include/asm/arch-s32/s32-cc/serdes_xpcs_regs.h
deleted file mode 100644
index 1604dc27f5..0000000000
--- a/arch/arm/include/asm/arch-s32/s32-cc/serdes_xpcs_regs.h
+++ /dev/null
@@ -1,219 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright 2019-2022 NXP
- *
- * The SerDes module header file.
- */
-
-#ifndef SERDES_XPCS_REGS_H
-#define SERDES_XPCS_REGS_H
-
-#include <common.h>
-#include "linux/errno.h"
-#include "linux/types.h"
-
-#define EXIT_FAILURE 1
-
-/*
- *		XPCS registers
- */
-#define SERDES_XPCS_0_BASE			0x82000U
-#define SERDES_XPCS_0_ADDR1			0x823fcU
-#define SERDES_XPCS_0_ADDR2			0x82000U
-
-#define SERDES_XPCS_1_BASE			0x82800U
-#define SERDES_XPCS_1_ADDR1			0x82bfcU
-#define SERDES_XPCS_1_ADDR2			0x82800U
-
-#define VR_MII_DIG_CTRL1			0x1f8000U
-#define VR_MII_AN_CTRL				0x1f8001U
-#define VR_MII_AN_INTR_STS			0x1f8002U
-#define VR_MII_DBG_CTRL				0x1f8005U
-#define VR_MII_LINK_TIMER_CTRL			0x1f800aU
-#define VR_MII_DIG_STS				0x1f8010U
-#define VR_MII_GEN5_12G_16G_TX_POWER_STATE_CTRL 0x1f8035U
-#define VR_MII_GEN5_12G_16G_RX_POWER_STATE_CTRL 0x1F8055U
-#define VR_MII_GEN5_12G_16G_TX_EQ_CTRL0		0x1F8036U
-#define VR_MII_GEN5_12G_16G_TX_EQ_CTRL1		0x1F8037U
-#define VR_MII_CONSUMER_10G_TX_TERM_CTRL	0x1F803CU
-#define VR_MII_GEN5_12G_16G_RX_GENCTRL1		0x1F8051U
-#define VR_MII_GEN5_12G_16G_TX_GENCTRL1		0x1F8031U
-#define VR_MII_GEN5_12G_16G_TX_GENCTRL2		0x1F8032U
-#define VR_MII_GEN5_12G_16G_RX_GENCTRL2		0x1F8052U
-#define VR_MII_GEN5_12G_16G_MPLL_CMN_CTRL	0x1f8070U
-#define VR_MII_GEN5_12G_16G_MPLLA_CTRL0		0x1f8071U
-#define VR_MII_GEN5_12G_MPLLA_CTRL1		0x1f8072U
-#define VR_MII_GEN5_12G_16G_MPLLA_CTRL2		0x1f8073U
-#define VR_MII_GEN5_12G_16G_MPLLB_CTRL0		0x1f8074U
-#define VR_MII_GEN5_12G_MPLLB_CTRL1		0x1f8075U
-#define VR_MII_GEN5_12G_16G_MPLLB_CTRL2		0x1f8076U
-#define VR_MII_GEN5_12G_MPLLA_CTRL3		0x1f8077U
-#define VR_MII_GEN5_12G_MPLLB_CTRL3		0x1f8078U
-#define VR_MII_GEN5_12G_VCO_CAL_REF0		0x1f8096U
-#define VR_MII_GEN5_12G_16G_TX_RATE_CTRL	0x1f8034U
-#define VR_MII_GEN5_12G_16G_RX_RATE_CTRL	0x1f8054U
-#define VR_MII_GEN5_12G_16G_CDR_CTRL		0x1f8056U
-#define VR_MII_Gen5_12G_16G_MISC_CTRL0		0x1F8090U
-#define VR_MII_GEN5_12G_16G_VCO_CAL_LD0		0x1f8092U
-#define VR_MII_GEN5_12G_16G_REF_CLK_CTRL	0x1f8091U
-#define SR_MII_CTRL				0x1f0000U
-#define SR_MII_STS				0x1f0001U
-#define SR_MII_DEV_ID1				0x1f0002U
-#define SR_MII_DEV_ID2				0x1f0003U
-
-/* VR_MII_Gen5_12G_16G_RX_GENCTRL1 */
-#define RX_RST_0				BIT(4U)
-
-/* VR_MII_Gen5_12G_16G_TX_GENCTRL1 */
-#define TX_CLK_RDY_0				BIT(12)
-#define VBOOST_EN_0				BIT(4)
-
-/* VR_MII_Gen5_12G_16G_TX_GENCTRL2 */
-#define TX_REQ_0				BIT(0)
-#define TX0_WIDTH(x)				(((x) & 0x3) << 8)
-
-/* VR_MII_Gen5_12G_16G_RX_GENCTRL2 */
-#define RX_REQ_0				BIT(0)
-#define RX0_WIDTH(x)				(((x) & 0x3) << 8)
-
-/* VR_MII_Gen5_12G_16G_RX_POWER_STATE_CTRL */
-#define RX_DISABLE_0				BIT(8)
-
-/* VR_MII_Gen5_12G_16G_TX_POWER_STATE_CTRL */
-#define TX_DISABLE_0				BIT(8)
-
-/* VR_MII_Gen5_12G_16G_RX_CDR_CTRL */
-#define VCO_LOW_FREQ_0				BIT(8)
-#define CDR_SSC_EN_0				BIT(4)
-
-#define PCS_MODE_1000_BASE_X			0U
-#define PCS_MODE_SGMII				2U
-#define MII_AN_CTRL_PCS_MODE(x)			(((x) & 0x3U) << 1)
-#define MII_AN_CTRL_MII_CTRL			BIT(8)
-#define MII_AN_CTRL_TX_CONFIG			BIT(3)
-#define MII_AN_INTR_STS_CL37_ANCMPLT_INTR	BIT(0)
-
-/* SR_MII_CTRL */
-#define LBE					BIT(14)
-#define MII_CTRL_SS6				BIT(6)
-#define MII_CTRL_DUPLEX_MODE			BIT(8)
-#define MII_CTRL_RESTART_AN			BIT(9)
-#define MII_CTRL_AN_ENABLE			BIT(12)
-#define MII_CTRL_SS13				BIT(13)
-
-#define MII_STS_LINK_STS			BIT(2)
-
-#define MPLL_EN_0				BIT(0)
-#define MPLLB_SEL_0				BIT(4)
-
-#define MPLLA_MULTIPLIER_VALUE(x)		(((x) & 0xffU) << 0)
-
-#define MII_DBG_CTRL_SUPPRESS_LOS_DET		BIT(4)
-#define MII_DBG_CTRL_RX_DT_EN_CTL		BIT(6)
-
-/* Field definitions for VR MII MMD Digital Control1 Register */
-
-#define BYP_PWRUP				BIT(1)
-#define EN_2_5G_MODE				BIT(2)
-#define CL37_TMR_OVR_RIDE			BIT(3)
-#define INIT					BIT(8)
-#define MAC_AUTO_SW				BIT(9)
-#define CS_EN					BIT(10)
-#define PWRSV					BIT(11)
-#define EN_VSMMD1				BIT(13)
-#define R2TLBE					BIT(14)
-#define VR_RST					BIT(15)
-
-/* Field definitions for VR_MII_Gen5_12G_16G_REF_CLK_CTRL Register */
-#define REF_CLK_EN				BIT(0)
-#define REF_USE_PAD				BIT(1)
-#define REF_CLK_DIV2				BIT(2)
-#define REF_RANGE(x)				(((x) & 0x7U) << 3)
-#define REF_MPLLA_DIV2				BIT(6)
-#define REF_MPLLB_DIV2				BIT(7)
-#define REF_RPT_CLK_EN				BIT(8)
-
-#define CDR_CTRL_VCO_LOW_FREQ_0			BIT(8)
-
-#define MII_AN_CTRL_TX_CONFIG			BIT(3)
-#define MII_AN_INTR_EN				BIT(0)
-#define CL37_ANSGM_STS_GET_SPEED(x)		BIT(((x) & 0xc) >> 2)
-#define CL37_ANSGM_STS_SPEED_10M		0U
-#define CL37_ANSGM_STS_SPEED_100M		1U
-#define CL37_ANSGM_STS_SPEED_1000M		2U
-#define CL37_ANSGM_STS_LINK			BIT(4)
-#define CL37_ANSGM_STS_FD			BIT(1)
-
-/* VR_MII_Gen5_12G_16G_MISC_CTRL0 */
-#define PLL_CTRL				BIT(15)
-#define SUPPRESS_LOS_DET			BIT(4)
-#define RX_DT_EN_CTL				BIT(6)
-
-#define PLLA_CAL_EN		BIT(0)
-#define PLLA_CAL_DIS		BIT(1)
-
-#define PLLB_CAL_EN		BIT(2)
-#define PLLB_CAL_DIS		BIT(3)
-
-#define XPCS0_1000M		BIT(8)
-#define XPCS0_2500M		BIT(9)
-#define XPCS0_DIS		BIT(10)
-#define XPCS0_OWNED		(XPCS0_1000M | XPCS0_2500M | XPCS0_DIS)
-
-#define XPCS1_1000M		BIT(16)
-#define XPCS1_2500M		BIT(17)
-#define XPCS1_DIS		BIT(18)
-#define XPCS1_OWNED		(XPCS1_1000M | XPCS1_2500M | XPCS1_DIS)
-
-#define PHY_CLK_INT		BIT(20)
-#define PHY_CTRL_XPCS0_OWNED	BIT(21)
-#define PHY_CTRL_XPCS1_OWNED	BIT(22)
-#define PHY_CTRL_XPCS_OWNED	(PHY_CTRL_XPCS0_OWNED | PHY_CTRL_XPCS1_OWNED)
-
-/* Init */
-void serdes_pcs_pma_init_gen2(void __iomem *xpcs0, void __iomem *xpcs1,
-			      unsigned long fhmz,
-			      u32 init_flags);
-void serdes_pcs_issue_vreset(void __iomem *base);
-int serdes_pcs_wait_for_vreset(void __iomem *base);
-int serdes_pcs_reset_seqence(void *serdes_base, u32 xpcs0_base, u32 xpcs1_base);
-int serdes_pcs_wait_for_power_good(void __iomem *base);
-
-/* Bifurcation PMA control */
-int serdes_bifurcation_pll_transit_to_3125mhz(void __iomem *base,
-					      unsigned long fhmz);
-int serdes_bifurcation_pll_transit_to_1250mhz(void __iomem *base,
-					      unsigned long fhmz);
-void serdes_testing_stage1(void __iomem *base);
-
-/* PMA control */
-void serdes_pma_lane_disable(void __iomem *base);
-void serdes_pma_lane_enable(void __iomem *base);
-void serdes_pma_issue_rx_reset(void __iomem *base);
-void serdes_pma_loopback_enable(void __iomem *base);
-void serdes_pma_loopback_disable(void __iomem *base);
-int  serdes_pma_wait_link(void __iomem *base, u8 sec);
-
-/* PCS control */
-int  serdes_pcs_speed_select(void __iomem *base, u32 div);
-void serdes_pcs_mii_bus_control_disable(void __iomem *base);
-void serdes_pcs_mii_bus_control_enable(void __iomem *base);
-void serdes_pcs_an_enable(void __iomem *base);
-void serdes_pcs_an_disable(void __iomem *base);
-void serdes_pcs_an_restart(void __iomem *base);
-void serdes_pcs_an_auto_sw_enable(void __iomem *base);
-void serdes_pcs_an_auto_sw_disable(void __iomem *base);
-void serdes_pcs_an_set_link_timer(void __iomem *base, u16 link_timer);
-int  serdes_pcs_an_decode(void __iomem *base, bool *link, bool *fduplex,
-			  u16 *speed);
-void serdes_pcs_set_fd(void __iomem *base);
-void serdes_pcs_set_hd(void __iomem *base);
-void serdes_pcs_loopback_enable(void __iomem *base);
-void serdes_pcs_loopback_disable(void __iomem *base);
-
-void serdes_pcs_dump_reg(void __iomem *base);
-
-enum serdes_xpcs_mode_gen2 s32_get_xpcs_mode(int serd, int xpcs);
-int s32_sgmii_wait_link(int serdes, int xpcs);
-#endif
-
diff --git a/arch/arm/include/asm/arch-s32/s32-cc/sgmii.h b/arch/arm/include/asm/arch-s32/s32-cc/sgmii.h
deleted file mode 100644
index e1477299a4..0000000000
--- a/arch/arm/include/asm/arch-s32/s32-cc/sgmii.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright 2022 NXP
- *
- * The SerDes XPCS config function definitions
- */
-
-#ifndef SERDES_SGMII_H
-#define SERDES_SGMII_H
-
-enum serdes_xpcs_mode;
-enum serdes_xpcs_mode_gen2;
-
-void serdes_pma_mode5(void __iomem *base);
-void serdes_pcs_mode5(void __iomem *base);
-
-int s32_eth_xpcs_init(void __iomem *xpcs0, void __iomem *xpcs1,
-		      int platform_serdes_id, u32 ss_mode,
-		      enum serdes_xpcs_mode xpcs_mode,
-		      bool ext_clk,
-		      unsigned long fmhz,
-		      enum serdes_xpcs_mode_gen2 xpcs[2]);
-
-#endif  /* SERDES_SGMII_H */
diff --git a/arch/arm/mach-s32/s32-cc/Makefile b/arch/arm/mach-s32/s32-cc/Makefile
index 53745095a3..e84d1b3c01 100644
--- a/arch/arm/mach-s32/s32-cc/Makefile
+++ b/arch/arm/mach-s32/s32-cc/Makefile
@@ -3,7 +3,6 @@
 # (C) Copyright 2013-2016 Freescale Semiconductor, Inc.
 # (C) Copyright 2016-2018, 2020-2022 NXP
 #
-ccflags-y += -I./arch/arm/mach-s32/s32-cc/
 ccflags-y += -I./board/nxp/common/
 ccflags-y += -I./board/nxp/s32-cc/include/
 ccflags-y += -I./drivers/net/s32/
@@ -21,14 +20,9 @@ ccflags-y			+= -Idrivers/misc
 ccflags-y			+= -Iboard/nxp/s32-cc
 
 obj-$(CONFIG_HSE_SECBOOT)	+= hse_adv_secboot.o
-ifdef CONFIG_NXP_S32CC
-ccflags-$(CONFIG_NETDEVICES)	+= -I./drivers/pci
-obj-$(CONFIG_NETDEVICES)	+= sgmii/sgmii.o sgmii/serdes_xpcs.o
-endif
 obj-y				+= start_m7.o
 ccflags-y			+= -I./board/nxp/s32-cc/
 ccflags-y			+= -I./arch/arm/mach-s32/s32-cc/include
-ccflags-y			+= -I./arch/arm/include/asm/arch-s32/s32-cc/
 ccflags-y			+= -I./drivers/misc/
 
 obj-$(CONFIG_NETDEVICES)	+= eth.o
diff --git a/arch/arm/mach-s32/s32-cc/hwconfig_fixups.c b/arch/arm/mach-s32/s32-cc/hwconfig_fixups.c
index d7c79cdde8..7276a42102 100644
--- a/arch/arm/mach-s32/s32-cc/hwconfig_fixups.c
+++ b/arch/arm/mach-s32/s32-cc/hwconfig_fixups.c
@@ -4,7 +4,6 @@
  */
 #include <common.h>
 #include <malloc.h>
-#include <asm/arch-s32/s32-cc/serdes_regs.h>
 #include <dm/device.h>
 #include <dm/of_access.h>
 #include <dm/ofnode.h>
diff --git a/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c b/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c
index a91ad70fba..831c5178f2 100644
--- a/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c
+++ b/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c
@@ -4,7 +4,6 @@
  */
 #include <common.h>
 #include <hwconfig.h>
-#include <asm/arch/s32-cc/serdes_regs.h>
 #include <dm/device.h>
 #include <dm/of_access.h>
 #include <dm/ofnode.h>
@@ -12,6 +11,11 @@
 #include <linux/ethtool.h>
 #include <s32-cc/serdes_hwconfig.h>
 
+/* use a mask to fix DEVICE_TYPE for EP */
+#define SERDES_MODE(mode) ((mode) & 0xe)
+#define IS_SERDES_PCIE(mode) ((mode) & (PCIE_EP | PCIE_RC))
+#define IS_SERDES_SGMII(mode) ((mode) & (SGMII))
+
 #define SERDES_RC_MODE_STR "RootComplex"
 #define SERDES_EP_MODE_STR "EndPoint"
 #define SERDES_SGMII_MODE_STR "SGMII"
diff --git a/arch/arm/mach-s32/s32-cc/sgmii/serdes_xpcs.c b/arch/arm/mach-s32/s32-cc/sgmii/serdes_xpcs.c
deleted file mode 100644
index 96c6fdcc5c..0000000000
--- a/arch/arm/mach-s32/s32-cc/sgmii/serdes_xpcs.c
+++ /dev/null
@@ -1,779 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright 2019-2022 NXP
- *
- * The SerDes module source file.
- */
-
-#include <serdes_regs.h>
-#include <serdes_xpcs_regs.h>
-#include <stdio.h>
-#include <asm/io.h>
-#include <linux/delay.h>
-#include <linux/ethtool.h>
-#include <linux/printk.h>
-
-#include <serdes_s32gen1_io.h>
-#include <sgmii.h>
-
-#define VPTR(a)		((void *)(uintptr_t)(a))
-
-static struct {
-	u32 start;
-	u32 end;
-} regs[] = {
-	{0x1F0000, 0x1F0006},
-	{0x1F000F, 0x1F000F},
-	{0x1F0708, 0x1F070F},
-	{0x1F0710, 0x1F0710},
-	{0x1F0710, 0x1F0710},
-	{0x1F8000, 0x1F8003},
-	{0x1F8005, 0x1F8005},
-	{0x1F800A, 0x1F800A},
-	{0x1F8010, 0x1F8012},
-	{0x1F8015, 0x1F8015},
-	{0x1F8018, 0x1F8018},
-	{0x1F8020, 0x1F8020},
-	{0x1F8030, 0x1F8037},
-	{0x1F803C, 0x1F803C},
-	{0x1F8040, 0x1F8040},
-	{0x1F8050, 0x1F8058},
-	{0x1F805C, 0x1F805E},
-	{0x1F8060, 0x1F8060},
-	{0x1F8064, 0x1F8064},
-	{0x1F806B, 0x1F806B},
-	{0x1F8070, 0x1F8078},
-	{0x1F8091, 0x1F8092},
-	{0x1F8096, 0x1F8096},
-	{0x1F8098, 0x1F8099},
-	{0x1F80A0, 0x1F80A2},
-	{0x1F80E1, 0x1F80E1},
-};
-
-static u16 serdes_xpcs_read_gen2(void __iomem *base, u32 reg)
-{
-	u32 ofsleft = (reg >> 8) & 0xffffU;
-	u32 ofsright = (reg & 0xffU);
-
-	writel(ofsleft, VPTR(base + 0x3fc));
-	return readl(VPTR(base + 4 * ofsright)) & 0xffffU;
-}
-
-static void serdes_xpcs_write_gen2(void __iomem *base, u32 reg, u16 val)
-{
-	u32 ofsleft = (reg >> 8) & 0xffffU;
-	u32 ofsright = (reg & 0xffU);
-
-	writel(ofsleft, VPTR(base + 0x3fc));
-	writel(val, VPTR(base + 4 * ofsright));
-}
-
-static void serdes_xpcs_clr_setb_gen2(void __iomem *base, u32 reg,
-				      u16 clr_mask, u16 mask)
-{
-	u16 tmp_rd =  0;
-
-	if (!base)
-		return;
-
-	if (mask || clr_mask)
-		tmp_rd = serdes_xpcs_read_gen2(base, reg);
-
-	serdes_xpcs_write_gen2(base, reg, (tmp_rd & ~clr_mask) | mask);
-}
-
-#define PCSW16(xpcs_base, reg, val) ({\
-	serdes_xpcs_write_gen2(xpcs_base, reg, val);\
-})
-
-#define PCSR16(xpcs_base, reg) ({\
-	serdes_xpcs_read_gen2(xpcs_base, reg);\
-})
-
-#define PCSBCLR(xpcs_base, reg, mask) \
-	serdes_xpcs_clr_setb_gen2(xpcs_base, reg, mask, 0)
-
-#define PCSBSET(xpcs_base, reg, mask) \
-	serdes_xpcs_clr_setb_gen2(xpcs_base, reg, 0, mask)
-
-#define PCSBCLRSET(xpcs_base, reg, clr_mask, mask) \
-	serdes_xpcs_clr_setb_gen2(xpcs_base, reg, clr_mask, mask)
-
-void serdes_pcs_dump_reg(void __iomem *base)
-{
-	u32 regidx;
-
-	for (regidx = 0; regidx < ARRAY_SIZE(regs); regidx++) {
-		u32 regcurr = regs[regidx].start;
-		u32 regend = regs[regidx].end;
-
-		do {
-			printf("0x%08x => 0x%04x\n",
-			       regcurr, PCSR16(base, regcurr));
-			regcurr++;
-		} while (regcurr <= regend);
-	}
-}
-
-static int serdes_pcs_wait_bits(void __iomem *base, u32 reg, u16 mask,
-				u16 val, u16 us, u16 cnt)
-{
-	u32 tmp = cnt; /* Take care so this is not optimized out */
-
-	while ((((serdes_xpcs_read_gen2(base, reg) & mask) != val) &&
-		(tmp > 0))) {
-		udelay(us);
-		tmp--;
-	}
-
-	return ((tmp > 0)) ? (0) : (-ETIMEDOUT);
-}
-
-static void serdes_pma_high_freq_recovery(void __iomem *base)
-{
-	/* PCS signal protection, PLL railout recovery */
-	PCSBSET(base, VR_MII_DBG_CTRL, SUPPRESS_LOS_DET | RX_DT_EN_CTL);
-	PCSBSET(base, VR_MII_Gen5_12G_16G_MISC_CTRL0, PLL_CTRL);
-}
-
-void serdes_pcs_loopback_enable(void __iomem *base)
-{
-	PCSBSET(base, VR_MII_DIG_CTRL1, R2TLBE);
-}
-
-void serdes_pcs_loopback_disable(void __iomem *base)
-{
-	PCSBCLR(base, VR_MII_DIG_CTRL1, R2TLBE);
-}
-
-int serdes_pcs_wait_for_power_good(void __iomem *base)
-{
-	return serdes_pcs_wait_bits(base, VR_MII_DIG_STS,
-				    0x7U << 2, 0x4U << 2, 1000U, 1000U);
-}
-
-void serdes_pcs_issue_vreset(void __iomem *base)
-{
-	PCSBSET(base, VR_MII_DIG_CTRL1, VR_RST);
-}
-
-int serdes_pcs_wait_for_vreset(void __iomem *base)
-{
-	return serdes_pcs_wait_bits(base, VR_MII_DIG_CTRL1,
-				    VR_RST, 0, 1000U, 1000U);
-}
-
-static void serdes_pcs_set_2500M_mode(void __iomem *base)
-{
-	PCSBSET(base, VR_MII_DIG_CTRL1, EN_2_5G_MODE);
-}
-
-static void serdes_pcs_set_1000M_mode(void __iomem *base)
-{
-	PCSBCLR(base, VR_MII_DIG_CTRL1, EN_2_5G_MODE);
-}
-
-int serdes_pcs_speed_select(void __iomem *base, u32 div)
-{
-	u16 reg16 = 0;
-
-	switch (div) {
-	case 100:
-		break;
-
-	case 10:
-		reg16 |= MII_CTRL_SS13;
-		break;
-
-	case 1:
-		reg16 |= MII_CTRL_SS6;
-		break;
-
-	default:
-		/*	Unsupported value */
-		return -EINVAL;
-	}
-
-	PCSBCLRSET(base, SR_MII_CTRL,
-		   MII_CTRL_SS13 | MII_CTRL_SS6,
-		   reg16);
-
-	return 0;
-}
-
-void serdes_pcs_set_fd(void __iomem *base)
-{
-	PCSBSET(base, SR_MII_CTRL, MII_CTRL_DUPLEX_MODE);
-}
-
-void serdes_pcs_set_hd(void __iomem *base)
-{
-	PCSBCLR(base, SR_MII_CTRL, MII_CTRL_DUPLEX_MODE);
-}
-
-/* Call in case MII bus is in all speeds 8bit */
-void serdes_pcs_mii_bus_control_disable(void __iomem *base)
-{
-	PCSBSET(base, VR_MII_AN_CTRL, MII_AN_CTRL_MII_CTRL);
-}
-
-/* Call in case MII bus is in 1G 8bit and other speeds 4bit */
-void serdes_pcs_mii_bus_control_enable(void __iomem *base)
-{
-	PCSBCLR(base, VR_MII_AN_CTRL, MII_AN_CTRL_MII_CTRL);
-}
-
-void serdes_pcs_an_enable(void __iomem *base)
-{
-	/* Select SGMII type AN, enable interrupt */
-	PCSBCLRSET(base, VR_MII_AN_CTRL,
-		   MII_AN_CTRL_PCS_MODE(0x3),
-		   MII_AN_CTRL_PCS_MODE(PCS_MODE_SGMII) |
-		   MII_AN_INTR_EN);
-	/* Enable SGMII AN */
-	PCSBSET(base, SR_MII_CTRL, MII_CTRL_AN_ENABLE);
-}
-
-void serdes_pcs_an_disable(void __iomem *base)
-{
-	PCSBCLR(base, SR_MII_CTRL, MII_CTRL_AN_ENABLE);
-	/* Disable interrupt */
-	PCSBCLR(base, VR_MII_AN_CTRL, MII_AN_INTR_EN);
-}
-
-void serdes_pcs_an_restart(void __iomem *base)
-{
-	PCSBSET(base, SR_MII_CTRL, MII_CTRL_RESTART_AN);
-}
-
-void serdes_pcs_an_auto_sw_enable(void __iomem *base)
-{
-	PCSBSET(base, VR_MII_DIG_CTRL1, MAC_AUTO_SW);
-}
-
-void serdes_pcs_an_auto_sw_disable(void __iomem *base)
-{
-	PCSBCLR(base, VR_MII_DIG_CTRL1, MAC_AUTO_SW);
-}
-
-void serdes_pcs_an_set_link_timer(void __iomem *base, u16 link_timer)
-{
-	PCSW16(base, VR_MII_LINK_TIMER_CTRL, link_timer);
-	PCSBCLR(base, VR_MII_DIG_CTRL1, CL37_TMR_OVR_RIDE);
-	PCSBSET(base, VR_MII_DIG_CTRL1, CL37_TMR_OVR_RIDE);
-}
-
-/* This is intended to be called from AN interrupt to resolve the AN result */
-int serdes_pcs_an_decode(void __iomem *base, bool *link,
-			 bool *fduplex, u16 *speed)
-{
-	u16 reg16 = PCSR16(base, VR_MII_AN_INTR_STS);
-
-	if (reg16 & CL37_ANSGM_STS_LINK) {
-		*link = true;
-	} else {
-		*link = false;
-		/* Remote link is down Auto-negotiation didn't work*/
-		pr_warn("Auto-negotiation wasn't successful\n");
-		return -EINVAL;
-	}
-	*fduplex = false;
-	if (reg16 & CL37_ANSGM_STS_FD)
-		*fduplex = true;
-
-	switch (CL37_ANSGM_STS_GET_SPEED(reg16)) {
-	case CL37_ANSGM_STS_SPEED_10M:
-		*speed = 10;
-		break;
-	case CL37_ANSGM_STS_SPEED_100M:
-		*speed = 100;
-		break;
-	case CL37_ANSGM_STS_SPEED_1000M:
-		*speed = 1000;
-		break;
-	default:
-		*speed = 0;
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-int serdes_pma_wait_link(void __iomem *base, u8 sec)
-{
-	return serdes_pcs_wait_bits(base, SR_MII_STS,
-				    MII_STS_LINK_STS, MII_STS_LINK_STS,
-				    1000U, 1000U * sec);
-}
-
-void serdes_pma_issue_rx_reset(void __iomem *base)
-{
-	PCSBSET(base, VR_MII_GEN5_12G_16G_RX_GENCTRL1, RX_RST_0);
-	PCSBCLR(base, VR_MII_GEN5_12G_16G_RX_GENCTRL1, RX_RST_0);
-}
-
-void serdes_pma_lane_disable(void __iomem *base)
-{
-	PCSBSET(base, VR_MII_GEN5_12G_16G_TX_POWER_STATE_CTRL,
-		TX_DISABLE_0);
-	PCSBSET(base, VR_MII_GEN5_12G_16G_RX_POWER_STATE_CTRL,
-		RX_DISABLE_0);
-}
-
-void serdes_pma_lane_enable(void __iomem *base)
-{
-	PCSBCLR(base, VR_MII_GEN5_12G_16G_TX_POWER_STATE_CTRL,
-		TX_DISABLE_0);
-	PCSBCLR(base, VR_MII_GEN5_12G_16G_RX_POWER_STATE_CTRL,
-		RX_DISABLE_0);
-}
-
-void serdes_pma_loopback_enable(void __iomem *base)
-{
-	PCSBSET(base, SR_MII_CTRL, LBE);
-}
-
-void serdes_pma_loopback_disable(void __iomem *base)
-{
-	PCSBCLR(base, SR_MII_CTRL, LBE);
-}
-
-static void serdes_pma_configure_tx_eq_post(void __iomem *base)
-{
-	PCSBSET(base, VR_MII_GEN5_12G_16G_TX_EQ_CTRL1, 1u << 6U);
-}
-
-static void serdes_pma_configure_tx_ctr(void __iomem *base)
-{
-	PCSBCLRSET(base, VR_MII_GEN5_12G_16G_TX_EQ_CTRL0,
-		   0x3fU << 8U,
-		   0xCU << 8U);
-	PCSBCLRSET(base, VR_MII_CONSUMER_10G_TX_TERM_CTRL,
-		   0x7U,
-		   0x4U);
-}
-
-static void serdes_pma_1250Mhz_prepare(void __iomem *base,
-				       unsigned long fmhz)
-{
-	u16 vco_cal_ld, vco_cal_ref;
-
-	if (fmhz == MHZ_100) {
-		vco_cal_ld = 1350U;
-		vco_cal_ref = 27U;
-	} else {
-		vco_cal_ld = 1360U;
-		vco_cal_ref = 17U;
-	}
-	/* RX VCO calibration value */
-	PCSBCLRSET(base, VR_MII_GEN5_12G_16G_VCO_CAL_LD0,
-		   0x1fff,
-		   vco_cal_ld);
-
-	/* VCO calibration reference */
-	PCSBCLRSET(base, VR_MII_GEN5_12G_VCO_CAL_REF0,
-		   0x3f,
-		   vco_cal_ref);
-
-	/* TX rate baud/4 (baud 1250Mhz) */
-	PCSBCLRSET(base, VR_MII_GEN5_12G_16G_TX_RATE_CTRL,
-		   0x7,
-		   0x2U); /* b010 */
-
-	/* Rx rate baud/8 (baud 1250Mhz) */
-	PCSBCLRSET(base, VR_MII_GEN5_12G_16G_RX_RATE_CTRL,
-		   0x3U,
-		   0x3U); /* b11 */
-
-	/* Clear low-frequency operating band */
-	PCSBCLR(base, VR_MII_GEN5_12G_16G_CDR_CTRL, VCO_LOW_FREQ_0);
-}
-
-/* Call only with 125mhz ref clk */
-static void serdes_pma_3125Mhz_prepare(void __iomem *base,
-				       unsigned long fmhz)
-{
-	u16 vco_cal_ld, vco_cal_ref;
-
-	if (fmhz == MHZ_100) {
-		vco_cal_ld = 1344U;
-		vco_cal_ref = 43U;
-	} else {
-		vco_cal_ld = 1350U;
-		vco_cal_ref = 27U;
-	}
-	/* RX VCO calibration value */
-	PCSBCLRSET(base, VR_MII_GEN5_12G_16G_VCO_CAL_LD0,
-		   0x1fff,
-		   vco_cal_ld);
-
-	/* VCO calibration reference */
-	PCSBCLRSET(base, VR_MII_GEN5_12G_VCO_CAL_REF0,
-		   0x3f,
-		   vco_cal_ref);
-
-	/* TX rate baud  */
-	PCSBCLRSET(base, VR_MII_GEN5_12G_16G_TX_RATE_CTRL,
-		   0x7,
-		   0x0U);
-
-	/* Rx rate baud/2 */
-	PCSBCLRSET(base, VR_MII_GEN5_12G_16G_RX_RATE_CTRL,
-		   0x3U,
-		   0x1U);
-
-	/* Set low-frequency operating band */
-	PCSBSET(base, VR_MII_GEN5_12G_16G_CDR_CTRL, VCO_LOW_FREQ_0);
-}
-
-static void serdes_pma_mplla_start_cal(void __iomem *base,
-				       unsigned long fmhz)
-{
-	if (fmhz == MHZ_100) {
-		PCSBCLRSET(base, VR_MII_GEN5_12G_16G_REF_CLK_CTRL,
-			   REF_RANGE(0x7U) | REF_CLK_DIV2 | REF_MPLLA_DIV2,
-			   REF_RANGE(0x3U) | REF_CLK_EN);
-
-		/* Clear multiplier and set it to 25 and enable PPL cal */
-		PCSBCLRSET(base, VR_MII_GEN5_12G_16G_MPLLA_CTRL0,
-			   MPLLA_MULTIPLIER_VALUE(0xff) |
-			   MPLLA_CAL_DISABLE,
-			   MPLLA_MULTIPLIER_VALUE(25U));
-
-	} else {
-		PCSBCLRSET(base, VR_MII_GEN5_12G_16G_REF_CLK_CTRL,
-			   REF_RANGE(0x7U),
-			   REF_RANGE(0x2U) | REF_CLK_DIV2 |
-			   REF_MPLLA_DIV2 | REF_CLK_EN);
-
-		/* Clear multiplier and set it to 80 and enable PPL cal */
-		PCSBCLRSET(base, VR_MII_GEN5_12G_16G_MPLLA_CTRL0,
-			   MPLLA_MULTIPLIER_VALUE(0xff) | MPLLA_CAL_DISABLE,
-			   MPLLA_MULTIPLIER_VALUE(80U));
-	}
-
-	PCSBCLR(base, VR_MII_GEN5_12G_MPLLA_CTRL1, 0xffe0U);
-
-	PCSBCLRSET(base, VR_MII_GEN5_12G_16G_MPLLA_CTRL2,
-		   MPLLA_TX_CLK_DIV(0x7U),
-		   MPLLA_TX_CLK_DIV(1U) | MPLLA_DIV10_CLK_EN);
-
-	if (fmhz == MHZ_100)
-		PCSW16(base, VR_MII_GEN5_12G_MPLLA_CTRL3, 357U);
-	else
-		PCSW16(base, VR_MII_GEN5_12G_MPLLA_CTRL3, 43U);
-}
-
-/* Configure PLLB and start calibration
- * Note: Enable this only with 125Mhz ref !!
- */
-static void serdes_pma_mpllb_start_cal(void __iomem *base,
-				       unsigned long fmhz)
-{
-	if (fmhz == MHZ_100) {
-		PCSBCLRSET(base, VR_MII_GEN5_12G_16G_REF_CLK_CTRL,
-			   REF_RANGE(0x7U) | REF_CLK_DIV2 | REF_MPLLB_DIV2,
-			   REF_RANGE(0x3U) | REF_CLK_EN);
-
-		/* Clear multiplier and set it to 25 and enable PPL cal */
-		PCSBCLRSET(base, VR_MII_GEN5_12G_16G_MPLLB_CTRL0,
-			   MPLLB_MULTIPLIER(0xffU) | MPPLB_CAL_DISABLE,
-			   MPLLB_MULTIPLIER(0x27U));
-
-	} else {
-		PCSBCLRSET(base, VR_MII_GEN5_12G_16G_REF_CLK_CTRL,
-			   REF_RANGE(0x7U),
-			   REF_RANGE(0x2U) | REF_MPLLB_DIV2 |
-			   REF_CLK_DIV2 | REF_CLK_EN);
-
-		/* Clear multiplier and set it to 125 and enable PPL cal */
-		PCSBCLRSET(base, VR_MII_GEN5_12G_16G_MPLLB_CTRL0,
-			   MPLLB_MULTIPLIER(0xffU) | MPPLB_CAL_DISABLE,
-			   MPLLB_MULTIPLIER(125U));
-	}
-
-	/* Clear the fraction divider */
-	PCSBCLR(base, VR_MII_GEN5_12G_MPLLB_CTRL1, 0xffe0U);
-
-	PCSBCLRSET(base, VR_MII_GEN5_12G_16G_MPLLB_CTRL2,
-		   MPLLB_TX_CLK_DIV(0x7U),
-		   MPLLB_TX_CLK_DIV(0x5U) | MPLLB_DIV10_CLK_EN);
-
-	if (fmhz == MHZ_100) {
-		/* Set fraction divider */
-		PCSBSET(base, VR_MII_GEN5_12G_MPLLB_CTRL1, 0x414U << 5U);
-
-		/* PLL bandwidth */
-		PCSW16(base, VR_MII_GEN5_12G_MPLLB_CTRL3, 0x66U);
-	} else {
-		/* PLL bandwidth */
-		PCSW16(base, VR_MII_GEN5_12G_MPLLB_CTRL3, 68U);
-	}
-}
-
-static void serdes_pma_mplla_stop_cal(void __iomem *base)
-{
-	/* Disable PLLB calibration */
-	PCSBSET(base, VR_MII_GEN5_12G_16G_MPLLA_CTRL0, MPLLA_CAL_DISABLE);
-}
-
-static void serdes_pma_mpllb_stop_cal(void __iomem *base)
-{
-	/* Disable PLLB calibration */
-	PCSBSET(base, VR_MII_GEN5_12G_16G_MPLLB_CTRL0, MPPLB_CAL_DISABLE);
-}
-
-static void serdes_pma_select_plla_ref(void __iomem *base)
-{
-	/* Select PLLA */
-	PCSBCLR(base, VR_MII_GEN5_12G_16G_MPLL_CMN_CTRL, MPLLB_SEL_0);
-	/* Enable PLL */
-	PCSBSET(base, VR_MII_GEN5_12G_16G_MPLL_CMN_CTRL, MPLL_EN_0);
-}
-
-static void serdes_pma_select_pllb_ref(void __iomem *base)
-{
-	/* Select PLLB */
-	PCSBSET(base, VR_MII_GEN5_12G_16G_MPLL_CMN_CTRL, MPLLB_SEL_0);
-	/* Enable PLL */
-	PCSBSET(base, VR_MII_GEN5_12G_16G_MPLL_CMN_CTRL, MPLL_EN_0);
-}
-
-static int serdes_bifurcation_pll_transit(void __iomem *base, bool plla)
-{
-	int ret = 0;
-
-	/* Signal that clock are not available */
-	PCSBCLR(base, VR_MII_GEN5_12G_16G_TX_GENCTRL1, TX_CLK_RDY_0);
-
-	if (plla) {
-		/* Request PLLA */
-		serdes_pma_select_plla_ref(base);
-	} else {
-		/* Request PLLB */
-		serdes_pma_select_pllb_ref(base);
-	}
-
-	/* Initiate transmitter TX reconfiguration request */
-	PCSBSET(base, VR_MII_GEN5_12G_16G_TX_GENCTRL2, TX_REQ_0);
-
-	/* Wait for transmitter to reconfigure */
-	ret = serdes_pcs_wait_bits(base, VR_MII_GEN5_12G_16G_TX_GENCTRL2,
-				   TX_REQ_0, 0,
-				   100U, 100U);
-	if (ret)
-		pr_err("TX_REQ_0 failed\n");
-
-	/* Initiate transmitter RX reconfiguration request */
-	PCSBSET(base, VR_MII_GEN5_12G_16G_RX_GENCTRL2, RX_REQ_0);
-
-	/* Wait for transmitter to reconfigure */
-	ret = serdes_pcs_wait_bits(base, VR_MII_GEN5_12G_16G_RX_GENCTRL2,
-				   RX_REQ_0, 0,
-				   100U, 100U);
-	if (ret)
-		pr_err("RX_REQ_0 failed\n");
-
-	/* Signal that clock are available */
-	PCSBSET(base, VR_MII_GEN5_12G_16G_TX_GENCTRL1, TX_CLK_RDY_0);
-
-	/* Flush internal logic */
-	PCSBSET(base, VR_MII_DIG_CTRL1, INIT);
-
-	/* Wait for init */
-	ret = serdes_pcs_wait_bits(base, VR_MII_DIG_CTRL1,
-				   INIT, 0,
-				   100U, 100U);
-	if (ret)
-		pr_err("INIT failed\n");
-
-	return ret;
-}
-
-/* Transit to PLLB */
-int serdes_bifurcation_pll_transit_to_3125mhz(void __iomem *base,
-					      unsigned long fmhz)
-{
-	/* Switch PCS logic to 2.5G */
-	serdes_pcs_set_2500M_mode(base);
-
-	/* Switch PMA logic to 3.125Ghz */
-	serdes_pma_3125Mhz_prepare(base, fmhz);
-
-	/* Do the transit to PLLB */
-	return serdes_bifurcation_pll_transit(base, false);
-}
-
-/* Transit to PLLA */
-int serdes_bifurcation_pll_transit_to_1250mhz(void __iomem *base,
-					      unsigned long fmhz)
-{
-	/* Switch PCS logic to 1G */
-	serdes_pcs_set_1000M_mode(base);
-
-	/* Switch PMA logic to 1.250Ghz */
-	serdes_pma_1250Mhz_prepare(base, fmhz);
-
-	/* Do the transit PLLA */
-	return serdes_bifurcation_pll_transit(base, true);
-}
-
-void serdes_pma_mode5(void __iomem *base)
-{
-	if (serdes_pcs_wait_for_power_good(base))
-		pr_err("XPCS (%p) power-up failed\n", base);
-	/* Configure equlaization */
-	serdes_pma_configure_tx_eq_post(base);
-	/* Configure transmit eq and termination */
-	serdes_pma_configure_tx_ctr(base);
-	/* Reconfigure PCS to 2.5Gbps */
-	serdes_pcs_set_2500M_mode(base);
-	/* Enable receiver recover */
-	serdes_pma_high_freq_recovery(base);
-}
-
-void serdes_pcs_mode5(void __iomem *base)
-{
-	/* Enable volatge boost */
-	PCSBSET(base, VR_MII_GEN5_12G_16G_TX_GENCTRL1, VBOOST_EN_0);
-
-	/* TX rate baud  */
-	PCSBCLRSET(base, VR_MII_GEN5_12G_16G_TX_RATE_CTRL,
-		   0x7,
-		   0x0U);
-
-	/* Rx rate baud/2 */
-	PCSBCLRSET(base, VR_MII_GEN5_12G_16G_RX_RATE_CTRL,
-		   0x3U,
-		   0x1U);
-
-	/* Set low-frequency operating band */
-	PCSBCLRSET(base, VR_MII_GEN5_12G_16G_CDR_CTRL,
-		   CDR_SSC_EN_0, VCO_LOW_FREQ_0);
-
-	/* Reconfigure PHY */
-	serdes_bifurcation_pll_transit(base, false);
-
-	/* Now do cold reset */
-	/* Issue PCIe cold reset to restart PHY and
-	 * commit new parameters to PHY
-	 */
-	BSET32(UPTR(base) + SS_RST_CTRL, COLD_RST);
-	udelay(1000U);
-	BCLR32(UPTR(base) + SS_RST_CTRL, COLD_RST);
-
-	/* Wait for vendor specific reset */
-	serdes_pcs_wait_for_vreset(base);
-}
-
-void serdes_pcs_pma_init_gen2(void __iomem *xpcs0, void __iomem *xpcs1,
-			      unsigned long fmhz,
-			      u32 init_flags)
-{
-	void __iomem *selected_xpcs = xpcs0;
-
-	if ((init_flags & PHY_CTRL_XPCS_OWNED) != 0) {
-		if ((init_flags & PHY_CTRL_XPCS0_OWNED) != 0)
-			selected_xpcs = xpcs0;
-		else if ((init_flags & PHY_CTRL_XPCS1_OWNED) != 0)
-			selected_xpcs = xpcs1;
-	}
-
-	/* Set bypass flag in case of internal clocks */
-	if (((init_flags & PHY_CLK_INT) != 0) &&
-	    ((init_flags & (XPCS0_OWNED)) != 0)) {
-		PCSBSET(xpcs0, VR_MII_DIG_CTRL1, EN_VSMMD1 | BYP_PWRUP);
-	} else if ((init_flags & (XPCS0_OWNED)) != 0) {
-		PCSBCLRSET(xpcs0, VR_MII_DIG_CTRL1, BYP_PWRUP, EN_VSMMD1);
-	}
-
-	if (((init_flags & PHY_CLK_INT) != 0) &&
-	    ((init_flags & (XPCS1_OWNED)) != 0)) {
-		PCSBSET(xpcs1, VR_MII_DIG_CTRL1, EN_VSMMD1 | BYP_PWRUP);
-	} else if ((init_flags & (XPCS1_OWNED)) != 0) {
-		PCSBCLRSET(xpcs1, VR_MII_DIG_CTRL1, BYP_PWRUP, EN_VSMMD1);
-	}
-
-	if ((init_flags & XPCS0_2500M) != 0) {
-		serdes_pma_configure_tx_ctr(xpcs0);
-		serdes_pcs_set_2500M_mode(xpcs0);
-		serdes_pma_select_pllb_ref(xpcs0);
-	} else if ((init_flags & XPCS0_1000M) != 0) {
-		serdes_pma_configure_tx_ctr(xpcs0);
-		serdes_pcs_set_1000M_mode(xpcs0);
-		serdes_pma_select_plla_ref(xpcs0);
-	}
-
-	if ((init_flags & XPCS1_2500M) != 0) {
-		serdes_pma_configure_tx_ctr(xpcs1);
-		serdes_pcs_set_2500M_mode(xpcs1);
-		serdes_pma_select_pllb_ref(xpcs1);
-	} else if ((init_flags & XPCS1_1000M) != 0) {
-		serdes_pma_configure_tx_ctr(xpcs1);
-		serdes_pcs_set_1000M_mode(xpcs1);
-		serdes_pma_select_plla_ref(xpcs1);
-	}
-
-	/* Using external clock reference */
-	if (((init_flags & PHY_CTRL_XPCS_OWNED) != 0) &&
-	    (init_flags & PHY_CLK_INT) == 0)
-		PCSBSET(selected_xpcs, VR_MII_GEN5_12G_16G_REF_CLK_CTRL,
-			REF_USE_PAD);
-	else if ((init_flags & PHY_CTRL_XPCS_OWNED) != 0)
-		PCSBCLR(selected_xpcs, VR_MII_GEN5_12G_16G_REF_CLK_CTRL,
-			REF_USE_PAD);
-
-	/* Start PLLA cal */
-	if (((init_flags & PHY_CTRL_XPCS_OWNED) != 0) &&
-	    (init_flags & PLLA_CAL_EN) != 0) {
-		/* Configure PLLA and start calibration */
-		serdes_pma_mplla_start_cal(selected_xpcs, fmhz);
-	}
-
-	/* Start PLLB cal */
-	if (((init_flags & PHY_CTRL_XPCS_OWNED) != 0) &&
-	    (init_flags & PLLB_CAL_EN) != 0) {
-		serdes_pma_mpllb_start_cal(selected_xpcs, fmhz);
-	}
-
-	/* Disable PLLA, if requested */
-	if (((init_flags & PHY_CTRL_XPCS_OWNED) != 0) &&
-	    (init_flags & PLLA_CAL_DIS) != 0) {
-		serdes_pma_mplla_stop_cal(selected_xpcs);
-	}
-
-	/* Disable PLLB, if requested */
-	if (((init_flags & PHY_CTRL_XPCS_OWNED) != 0) &&
-	    (init_flags & PLLB_CAL_DIS) != 0) {
-		serdes_pma_mpllb_stop_cal(selected_xpcs);
-	}
-
-	if ((init_flags & XPCS0_2500M) != 0)
-		serdes_pma_3125Mhz_prepare(xpcs0, fmhz);
-	else if ((init_flags & XPCS0_1000M) != 0)
-		serdes_pma_1250Mhz_prepare(xpcs0, fmhz);
-
-	if ((init_flags & XPCS1_2500M) != 0)
-		serdes_pma_3125Mhz_prepare(xpcs1, fmhz);
-	else if ((init_flags & XPCS1_1000M) != 0)
-		serdes_pma_1250Mhz_prepare(xpcs1, fmhz);
-
-	if ((init_flags & XPCS0_DIS) != 0)
-		serdes_pma_lane_disable(xpcs0);
-
-	if ((init_flags & XPCS1_DIS) != 0)
-		serdes_pma_lane_disable(xpcs1);
-
-	/* Clear bypass flag in case of internal clocks */
-	if (((init_flags & PHY_CLK_INT) != 0U) &&
-	    ((init_flags & (XPCS0_OWNED)) != 0U) &&
-	    ((init_flags & XPCS0_DIS) == 0U)) {
-		PCSBCLR(xpcs0, VR_MII_DIG_CTRL1, BYP_PWRUP);
-	}
-
-	if (((init_flags & PHY_CLK_INT) != 0U) &&
-	    ((init_flags & (XPCS1_OWNED)) != 0U) &&
-	    ((init_flags & XPCS1_DIS) == 0U)) {
-		PCSBCLR(xpcs1, VR_MII_DIG_CTRL1, BYP_PWRUP);
-	}
-}
diff --git a/arch/arm/mach-s32/s32-cc/sgmii/sgmii.c b/arch/arm/mach-s32/s32-cc/sgmii/sgmii.c
deleted file mode 100644
index b1ee2ac287..0000000000
--- a/arch/arm/mach-s32/s32-cc/sgmii/sgmii.c
+++ /dev/null
@@ -1,373 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright 2019-2022 NXP
- *
- * The SerDes config code
- */
-
-#include <common.h>
-#include <dm.h>
-#include <log.h>
-#include <stdio.h>
-#include <linux/delay.h>
-#include <linux/errno.h>
-#include <linux/ethtool.h>
-#include <linux/printk.h>
-
-#include <serdes_regs.h>
-#include <serdes_xpcs_regs.h>
-#include <sgmii.h>
-
-#define S32G_SERDES_COUNT			2
-#define S32G_SERDES_XPCS_COUNT			2
-
-#define VPTR(a)		((void *)(uintptr_t)(a))
-
-/*
- *
- * Only limited number of configurations were tested (Only on SerDes1).
- * You should take care and check, if everything works in your configuration.
- *
- * Tested configurations (of hwconfig):
- * Board s32g274ardb:
- *	-Default - MAC0 2.5G to sja1110 switch
- *		pcie1:mode=sgmii,clock=ext,fmhz=125,xpcs_mode=2G5
- *	-MAC0 1G to the sja1110 switch/PCIeX1 on lane 0
- *		pcie1:mode=rc&sgmii,clock=int,fmhz=100,xpcs_mode=0
- *	-MAC1 1G to the sja1110 switch/PCIeX1 on lane 0
- *		pcie1:mode=rc&sgmii,clock=int,fmhz=100,xpcs_mode=1
- *
- * Board s32g2xxaevb:
- *	-Default - MAC0 1G to Aqauntia (CPU board)
- *		pcie1:mode=sgmii,clock=ext,fmhz=125,xpcs_mode=0 or
- *		pcie1:mode=sgmii,clock=ext,fmhz=100,xpcs_mode=0 or
- *		pcie1:mode=sgmii,clock=int,fmhz=100,xpcs_mode=0
- *
- */
-
-struct s32_xpcs_cfg {
-	void __iomem *xpcs0, *xpcs1;
-	enum serdes_xpcs_mode xpcs_mode;
-	enum serdes_xpcs_mode_gen2 mode[2];
-	enum serdes_mode ss_mode;
-	unsigned long fmhz;
-	bool ext_clk;
-	bool is_init;
-};
-
-static struct s32_xpcs_cfg serdes_cfg[S32G_SERDES_COUNT] = { {.is_init = false},
-							   {.is_init = false} };
-
-static struct s32_xpcs_cfg *s32_get_serdes_priv(int platform_serdes_id)
-{
-	if (platform_serdes_id < S32G_SERDES_COUNT)
-		return &serdes_cfg[platform_serdes_id];
-	else
-		return NULL;
-}
-
-int s32_sgmii_wait_link(int serdes_id, int xpcs)
-{
-	void __iomem *xpcs_base;
-	struct s32_xpcs_cfg *serdes = s32_get_serdes_priv(serdes_id);
-	int ret;
-
-	if (!serdes || xpcs >= S32G_SERDES_XPCS_COUNT)
-		return -EINVAL;
-
-	if (xpcs == 1)
-		xpcs_base = serdes->xpcs1;
-	else
-		xpcs_base = serdes->xpcs0;
-
-	debug("Waiting for link (SerDes%d XPCS%i)...\n", serdes_id, xpcs);
-	ret = serdes_pma_wait_link(xpcs_base, 1U);
-
-	if (ret)
-		printf("SerDes%d XPCS%i link timed-out\n", serdes_id, xpcs);
-	else
-		debug("SerDes%d XPCS%i link is up\n", serdes_id, xpcs);
-
-	return ret;
-}
-
-/* Function used to probe the SerDes in case the PCIe is disabled */
-#if	!CONFIG_IS_ENABLED(PCI) && CONFIG_IS_ENABLED(PHY_S32CC_SERDES)
-static void s32_serdes_no_pcie_init(void)
-{
-	struct udevice *bus;
-
-	debug("%s\n", __func__);
-
-	/*
-	 * Enumerate all known UCLASS_PCI_GENERIC devices. This will
-	 * also probe them, so the SerDes devices will be enumerated too.
-	 */
-	for (uclass_first_device(UCLASS_PCI_GENERIC, &bus);
-	     bus;
-	     uclass_next_device(&bus)) {
-		;
-	}
-}
-#endif
-
-enum serdes_xpcs_mode_gen2 s32_get_xpcs_mode(int serd, int xpcs)
-{
-	struct s32_xpcs_cfg *serdes = s32_get_serdes_priv(serd);
-
-	if (!serdes || xpcs >= S32G_SERDES_XPCS_COUNT)
-		return SGMII_XPCS_PCIE;
-
-/* In case PCIe is disabled probe serdes drivers */
-#if	!CONFIG_IS_ENABLED(PCI) && CONFIG_IS_ENABLED(PHY_S32CC_SERDES)
-	if (!serdes->is_init)
-		s32_serdes_no_pcie_init();
-#elif !CONFIG_IS_ENABLED(PHY_S32CC_SERDES)
-	printf("SGMII is not supported in this configuration");
-#endif
-
-	if (!serdes->is_init || serdes->xpcs_mode == SGMII_INAVALID) {
-		printf("SerDes %d was not initialized\n", serd);
-		return SGMII_XPCS_PCIE;
-	}
-
-	return serdes->mode[xpcs];
-}
-
-static void s32_serdes_issue_reset(struct s32_xpcs_cfg *serdes)
-{
-	switch (serdes->ss_mode) {
-	case SERDES_MODE_PCIE_SGMII0:
-		serdes_pcs_issue_vreset(serdes->xpcs0);
-		break;
-	case SERDES_MODE_PCIE_SGMII1:
-		serdes_pcs_issue_vreset(serdes->xpcs1);
-		break;
-	case SERDES_MODE_SGMII_SGMII:
-		serdes_pcs_issue_vreset(serdes->xpcs1);
-		serdes_pcs_issue_vreset(serdes->xpcs0);
-		break;
-	case SERDES_MODE_SGMII_SGMII_ALT:
-		serdes_pcs_issue_vreset(serdes->xpcs0);
-		serdes_pcs_issue_vreset(serdes->xpcs1);
-		break;
-	default:
-		break;
-	}
-}
-
-static void s32_serdes_init_flags(struct s32_xpcs_cfg *serdes,
-				  enum serdes_xpcs_mode_gen2 xpcs_mode,
-				  u32 *init_flags, u32 f1g, u32 f25g, u32 fdis)
-{
-	if (xpcs_mode == SGMII_XPCS_2G5_OP)
-		*init_flags |= PLLA_CAL_EN | PLLB_CAL_EN | f25g;
-
-	if (xpcs_mode == SGMII_XPCS_1G_OP)
-		*init_flags |= PLLA_CAL_EN | f1g;
-
-	if (xpcs_mode == SGMII_XPCS_1G_OP)
-		*init_flags |= PLLA_CAL_EN | f1g;
-
-	if (xpcs_mode == SGMII_XPCS_DISABLED)
-		*init_flags |= fdis;
-
-	switch (serdes->ss_mode) {
-	case SERDES_MODE_SGMII_SGMII:
-		*init_flags |= PHY_CTRL_XPCS0_OWNED;
-		break;
-	case SERDES_MODE_SGMII_SGMII_ALT:
-		*init_flags |= PHY_CTRL_XPCS1_OWNED;
-		break;
-	default:
-		break;
-	}
-}
-
-static void s32_serdes_post_init(struct s32_xpcs_cfg *serdes, u32 xpcs)
-{
-	void __iomem *xpcs_base = NULL;
-
-	if (xpcs == 1)
-		xpcs_base = serdes->xpcs1;
-	else
-		xpcs_base = serdes->xpcs0;
-
-	if (serdes_pcs_wait_for_vreset(xpcs_base))
-		pr_err("XPCS%d pre power-up soft reset failed\n", xpcs);
-
-	if (serdes_pcs_wait_for_power_good(xpcs_base))
-		pr_err("XPCS%d power-up failed\n", xpcs);
-
-	serdes_pma_issue_rx_reset(xpcs_base);
-
-	/* Disable automatic MII width change */
-	serdes_pcs_mii_bus_control_disable(xpcs_base);
-	/* Disable AN */
-	serdes_pcs_an_disable(xpcs_base);
-	/* Full duplex */
-	serdes_pcs_set_fd(xpcs_base);
-	/* Speed select */
-	serdes_pcs_speed_select(xpcs_base, 1);
-}
-
-static enum serdes_mode u32_to_serdes_mode(u32 ss_mode)
-{
-	switch (ss_mode) {
-	case 0:
-		return SERDES_MODE_PCIE_PCIE;
-	case 1:
-		return SERDES_MODE_PCIE_SGMII0;
-	case 2:
-		return SERDES_MODE_PCIE_SGMII1;
-	case 3:
-		return SERDES_MODE_SGMII_SGMII;
-	case 4:
-		return SERDES_MODE_SGMII_SGMII_ALT;
-	default:
-		return SERDES_MODE_INVAL;
-	}
-}
-
-int s32_eth_xpcs_init(void __iomem *xpcs0, void __iomem *xpcs1,
-		      int platform_serdes_id, u32 ss_mode,
-		      enum serdes_xpcs_mode xpcs_mode,
-		      bool ext_clk,
-		      unsigned long fmhz,
-		      enum serdes_xpcs_mode_gen2 xpcs[2])
-{
-	struct s32_xpcs_cfg *serdes = s32_get_serdes_priv(platform_serdes_id);
-	int ret = 0;
-	u32 init_flags = 0;
-	bool shared = false;
-
-	if (!serdes) {
-		printf("Invalid Serdes ID %d\n", platform_serdes_id);
-		return -EINVAL;
-	}
-
-	serdes->xpcs0 = xpcs0;
-	serdes->xpcs1 = xpcs1;
-	serdes->xpcs_mode = SGMII_INAVALID;
-	serdes->ext_clk = ext_clk;
-	serdes->ss_mode = u32_to_serdes_mode(ss_mode);
-	serdes->fmhz = fmhz;
-
-	if (serdes->ss_mode == SERDES_MODE_PCIE_SGMII0 ||
-	    serdes->ss_mode == SERDES_MODE_PCIE_SGMII1) {
-		shared = true;
-
-		/* Mode 5 demo */
-		if (xpcs[0] == SGMII_XPCS_PCIE &&
-		    xpcs[1] == SGMII_XPCS_2G5_OP) {
-			serdes->mode[0] = xpcs[0];
-			serdes->mode[1] = xpcs[1];
-			init_flags = XPCS1_OWNED;
-			goto mode5;
-		}
-	}
-
-	/* Note: this is temporary until upper layers are reworked */
-	switch (xpcs_mode) {
-	case SGMII_XPCS0_2G5:
-		serdes->mode[0] = SGMII_XPCS_2G5_OP;
-		serdes->mode[1] = SGMII_XPCS_1G_OP;
-		break;
-	case SGMII_XPCS0_XPCS1:
-		serdes->mode[0] = SGMII_XPCS_1G_OP;
-		serdes->mode[1] = SGMII_XPCS_1G_OP;
-		break;
-	case SGMII_XPCS0:
-		serdes->mode[0] = SGMII_XPCS_1G_OP;
-		if (shared)
-			serdes->mode[1] = SGMII_XPCS_PCIE;
-		else
-			serdes->mode[1] = SGMII_XPCS_DISABLED;
-		break;
-	case SGMII_XPCS1:
-		serdes->mode[1] = SGMII_XPCS_1G_OP;
-		if (shared)
-			serdes->mode[0] = SGMII_XPCS_PCIE;
-		else
-			serdes->mode[0] = SGMII_XPCS_DISABLED;
-		break;
-	default:
-		serdes->mode[0] = SGMII_XPCS_PCIE;
-		serdes->mode[1] = SGMII_XPCS_PCIE;
-	}
-
-	if (serdes->mode[0] != SGMII_XPCS_PCIE) {
-		/* Bypass power up in case of pcie combo or internal clock*/
-		if (serdes->ext_clk && !shared) {
-			ret = serdes_pcs_wait_for_power_good(xpcs0);
-			if (!ret)
-				pr_info("XPCS0 power-up good success\n");
-			else
-				pr_err("XPCS0 power-up good failed\n");
-		}
-
-		s32_serdes_init_flags(serdes, serdes->mode[0], &init_flags,
-				      XPCS0_1000M, XPCS0_2500M, XPCS0_DIS);
-	}
-
-	if (serdes->mode[1] != SGMII_XPCS_PCIE) {
-		/* Bypass power up in case of pcie combo or internal clock*/
-		if (serdes->ext_clk && !shared) {
-			ret = serdes_pcs_wait_for_power_good(xpcs1);
-			if (!ret)
-				pr_info("XPCS1 power-up good success\n");
-			else
-				pr_err("XPCS1 power-up good failed\n");
-		}
-
-		s32_serdes_init_flags(serdes, serdes->mode[1], &init_flags,
-				      XPCS1_1000M, XPCS1_2500M, XPCS1_DIS);
-	}
-
-	/* Check, if we should init something */
-	if (!init_flags)
-		return 0;
-
-	if (!serdes->ext_clk)
-		init_flags |= PHY_CLK_INT;
-
-	serdes_pcs_pma_init_gen2(serdes->xpcs0, serdes->xpcs1, fmhz,
-				 init_flags);
-
-	/* Issue ss mode dependent reset */
-	s32_serdes_issue_reset(serdes);
-
-	/* Wait reset + Post init */
-	if (((init_flags & (XPCS0_OWNED)) != 0))
-		s32_serdes_post_init(serdes, 0);
-
-mode5:
-	if (((init_flags & (XPCS1_OWNED)) != 0))
-		s32_serdes_post_init(serdes, 1);
-
-	serdes->xpcs_mode = xpcs_mode;
-	serdes->is_init = true;
-
-	return 0;
-}
-
-enum xpcs_cmd {
-	S32_XPCS_INVALID,
-	S32_XPCS_TRANSIT_TO_1000M,
-	S32_XPCS_TRANSIT_TO_2500M,
-	S32_XPCS_AN_AUTO_SW_ENABLE,
-	S32_XPCS_AN_ENABLE,
-	S32_XPCS_AN_DISABLE,
-	S32_XPCS_LO_ENABLE,
-	S32_XPCS_LO_DISABLE,
-	S32_XPCS_DUMP,
-};
-
-/* Provide UCLASS DRV so SerDes driver can bind to it*/
-#if	!CONFIG_IS_ENABLED(PCI) && CONFIG_IS_ENABLED(PHY_S32CC_SERDES)
-UCLASS_DRIVER(pci_uc_gen) = {
-	.id		= UCLASS_PCI_GENERIC,
-	.name		= "sgmii_s32gen1",
-};
-#endif
-
diff --git a/board/nxp/s32-cc/Makefile b/board/nxp/s32-cc/Makefile
index 02d2d52403..386cdb4779 100644
--- a/board/nxp/s32-cc/Makefile
+++ b/board/nxp/s32-cc/Makefile
@@ -6,5 +6,4 @@
 
 obj-y += board_common.o
 
-ccflags-y += -Iarch/arm/mach-s32/s32-cc/
 ccflags-y += -Iboard/nxp/s32-cc/include/
diff --git a/board/nxp/s32g274abluebox3/s32g274abluebox3.c b/board/nxp/s32g274abluebox3/s32g274abluebox3.c
index 8efe9f384e..841c69b880 100644
--- a/board/nxp/s32g274abluebox3/s32g274abluebox3.c
+++ b/board/nxp/s32g274abluebox3/s32g274abluebox3.c
@@ -2,12 +2,10 @@
 /*
  * Copyright 2018-2022 NXP
  */
-#include <board_common.h>
 #include <common.h>
+#include <i2c.h>
 #include <miiphy.h>
 #include <phy.h>
-#include <i2c.h>
-#include <asm/arch-s32/s32-cc/serdes_regs.h>
 
 #define BLUEBOX3_S32G_PHY_ADDR_5	0x05
 #define BLUEBOX3_S32G_PHY_ADDR_6	0x06
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index d9cfd9fdc0..9f3119a6d3 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -3,7 +3,6 @@
 # (C) Copyright 2006
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 
-ccflags-$(CONFIG_DWC_ETH_QOS_S32CC) += -Iarch/arm/include/asm/arch-s32/s32-cc
 ccflags-$(CONFIG_DWC_ETH_QOS_S32CC) += -Iarch/arm/mach-s32/s32-cc/include
 ccflags-$(CONFIG_DWC_ETH_QOS_S32CC) += -Iboard/nxp/s32-cc/include
 ccflags-$(CONFIG_DWC_ETH_QOS_S32CC) += -Idrivers/net/s32
diff --git a/drivers/net/pfeng/Makefile b/drivers/net/pfeng/Makefile
index e3397e1e9b..9d58df1e16 100644
--- a/drivers/net/pfeng/Makefile
+++ b/drivers/net/pfeng/Makefile
@@ -28,5 +28,4 @@ ccflags-y += -DPFE_CFG_IP_VERSION=PFE_CFG_IP_VERSION_NPU_7_14
 ccflags-y += -Idrivers/net/pfeng/regmap
 ccflags-y += -Idrivers/net/pfeng/hw_abi
 ccflags-y += -Wno-date-time
-ccflags-y += -I./arch/arm/include/asm/arch-s32/s32-cc
 ccflags-y += -I./drivers/net/s32
diff --git a/drivers/net/s32/Makefile b/drivers/net/s32/Makefile
index 6db530b1e4..b27ae930e2 100644
--- a/drivers/net/s32/Makefile
+++ b/drivers/net/s32/Makefile
@@ -4,5 +4,4 @@
 #
 obj-y += clk_utils.o
 
-ccflags-y += -Iarch/arm/include/asm/arch-s32/s32-cc
 ccflags-y += -Idrivers/net/s32
diff --git a/drivers/pci/Makefile b/drivers/pci/Makefile
index 759473b711..d49f22e73b 100644
--- a/drivers/pci/Makefile
+++ b/drivers/pci/Makefile
@@ -3,7 +3,6 @@
 # (C) Copyright 2000-2007
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 
-ccflags-$(CONFIG_PCIE_S32GEN1) += -Iarch/$(ARCH)/include/asm/arch-s32/s32-cc
 ccflags-$(CONFIG_PCIE_S32GEN1) += -Idrivers/misc
 
 ifneq ($(CONFIG_DM_PCI),)
diff --git a/drivers/pci/pcie_s32gen1.c b/drivers/pci/pcie_s32gen1.c
index 3116b39bb8..b18e45f64c 100644
--- a/drivers/pci/pcie_s32gen1.c
+++ b/drivers/pci/pcie_s32gen1.c
@@ -14,7 +14,6 @@
 #include <pci.h>
 #include <asm/io.h>
 #include <asm/arch/clock.h>
-#include <asm/arch/s32-cc/serdes_regs.h>
 #include <dm/device-internal.h>
 #include <dm/device_compat.h>
 #include <dm/uclass.h>
@@ -25,10 +24,10 @@
 #include <s32-cc/nvmem.h>
 #include <s32-cc/pcie.h>
 #include <s32-cc/serdes_hwconfig.h>
+#include <s32-cc/serdes_hwconfig.h>
 #include <dt-bindings/nvmem/s32cc-siul2-nvmem.h>
 #include <dt-bindings/phy/phy.h>
 
-#include "serdes_s32gen1_io.h"
 #include "ss_pcie_regs.h"
 
 /* CFG1 is used in linux when finding devices on the bus.
diff --git a/drivers/pci/pcie_s32gen1.h b/drivers/pci/pcie_s32gen1.h
index 4d2fc7a460..bbd0a4f9dd 100644
--- a/drivers/pci/pcie_s32gen1.h
+++ b/drivers/pci/pcie_s32gen1.h
@@ -12,6 +12,123 @@
 #include <asm/io.h>
 #include <linux/ioport.h>
 
+#ifdef CONFIG_PCIE_DEBUG_WRITES
+#define debug_wr debug
+#else
+#define debug_wr(...)
+#endif
+
+#define UPTR(a)		((uintptr_t)(a))
+
+#define s32_dbi_readb(addr) \
+	readb_relaxed((addr))
+
+#define s32_dbi_readw(addr) \
+	readw_relaxed((addr))
+
+#define s32_dbi_readl(addr) \
+	readl_relaxed((addr))
+
+#define s32_dbi_writeb(addr, val) \
+	writeb_relaxed((val), (addr))
+
+#define s32_dbi_writew(addr, val) \
+	writew_relaxed((val), (addr))
+
+#define s32_dbi_writel(addr, val) \
+	writel_relaxed((val), (addr))
+
+#define W16(address, write_data) \
+do { \
+	debug_wr("%s: W16(0x%llx, 0x%x) ... ", __func__, (u64)(address), \
+		(uint32_t)(write_data)); \
+	s32_dbi_writew((address), (write_data)); \
+	debug_wr("done\n"); \
+} while (0)
+
+#define W32(address, write_data) \
+do { \
+	debug_wr("%s: W32(0x%llx, 0x%x) ... ", __func__, (u64)(address), \
+		(uint32_t)(write_data)); \
+	s32_dbi_writel((address), (write_data)); \
+	debug_wr("done\n"); \
+} while (0)
+
+/* BCLR32 - SPARSE compliant version of `clrbits_le32`, with debug support. */
+#define BCLR32(address, mask_clear) \
+do { \
+	uintptr_t bclr_address = (address); \
+	u32 bclr_mask_clear = (mask_clear); \
+	debug_wr("%s: BCLR32(0x%lx, 0x%x) ... ", __func__, \
+		bclr_address, bclr_mask_clear); \
+	s32_dbi_writel(bclr_address, \
+		       s32_dbi_readl(bclr_address) & ~(bclr_mask_clear)); \
+	debug_wr("done\n"); \
+} while (0)
+
+/* BSET32 - SPARSE compliant version of `setbits_le32`, with debug support. */
+#define BSET32(address, mask_set) \
+do { \
+	uintptr_t bset_address = (address); \
+	u32 bset_mask_set = (mask_set); \
+	debug_wr("%s: BSET32(0x%lx, 0x%x) ... ", __func__, \
+		bset_address, bset_mask_set); \
+	s32_dbi_writel(bset_address, \
+		       s32_dbi_readl(bset_address) | (bset_mask_set)); \
+	debug_wr("done\n"); \
+} while (0)
+
+/* RMW32 - SPARSE compliant version of `clrsetbits_le32`, with debug support.
+ * Please pay attention to the arguments order.
+ */
+#define RMW32(address, mask_set, mask_clear) \
+do { \
+	uintptr_t rmw_address = (address); \
+	u32 rmw_mask_set = (mask_set), rmw_mask_clear = (mask_clear); \
+	debug_wr("%s: RMW32(0x%lx, set 0x%x, clear 0x%x) ... ", __func__, \
+		rmw_address, rmw_mask_set, rmw_mask_clear); \
+	s32_dbi_writel(rmw_address, \
+		       (s32_dbi_readl(rmw_address) & ~(rmw_mask_clear)) | \
+		       (rmw_mask_set)); \
+	debug_wr("done\n"); \
+} while (0)
+
+#define SERDES_SS_BASE		0x80000
+
+/* PCIe Controller 0 General Control 1-4 */
+#define SS_PE0_GEN_CTRL_1	(SERDES_SS_BASE + 0x1050U)
+#define SS_PE0_GEN_CTRL_2	(SERDES_SS_BASE + 0x1054U)
+#define SS_PE0_GEN_CTRL_3	(SERDES_SS_BASE + 0x1058U)
+#define SS_PE0_GEN_CTRL_4	(SERDES_SS_BASE + 0x105cU)
+
+/* PCIe Controller 0 Link Debug 2 */
+#define SS_PE0_LINK_DBG_2	(SERDES_SS_BASE + 0x10b4U)
+
+/* PCIe Controller 0 Link Debug 1 */
+#define SS_PE0_LINK_DBG_1	(SERDES_SS_BASE + 0x10b0U)
+
+/* Field definitions for PE0_GEN_CTRL_1 */
+#define DEVICE_TYPE_OVERRIDE	0x10
+#define DEVICE_TYPE_EP		0x0
+#define DEVICE_TYPE_RC		0x4
+
+#define DEVICE_TYPE_LSB		(0)
+#define DEVICE_TYPE_MASK	(0x0000000F)
+#define DEVICE_TYPE		((DEVICE_TYPE_MASK) << \
+				 (DEVICE_TYPE_LSB))
+
+/* Field definitions for PE0_LINK_DBG_2 */
+#define SMLH_LTSSM_STATE_LSB	(0)
+#define SMLH_LTSSM_STATE_MASK	(0x0000003F)
+#define SMLH_LTSSM_STATE	((SMLH_LTSSM_STATE_MASK) << \
+				 (SMLH_LTSSM_STATE_LSB))
+
+#define SMLH_LINK_UP_BIT	(6)
+#define SMLH_LINK_UP		BIT(SMLH_LINK_UP_BIT)
+
+#define RDLH_LINK_UP_BIT	(7)
+#define RDLH_LINK_UP		BIT(RDLH_LINK_UP_BIT)
+
 #define SERDES_LINKUP_MASK	(SMLH_LINK_UP | RDLH_LINK_UP | \
 		SMLH_LTSSM_STATE)
 #define SERDES_LINKUP_EXPECT	(SMLH_LINK_UP | RDLH_LINK_UP | \
diff --git a/drivers/pci/serdes_s32gen1_io.h b/drivers/pci/serdes_s32gen1_io.h
deleted file mode 100644
index 886d209b4e..0000000000
--- a/drivers/pci/serdes_s32gen1_io.h
+++ /dev/null
@@ -1,92 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Copyright 2020,2022 NXP
- * S32Gen1 SerDes I/O macros
- */
-
-#ifndef SERDES_S32GEN1_IO_H
-#define SERDES_S32GEN1_IO_H
-#include <asm/io.h>
-
-#ifdef CONFIG_PCIE_DEBUG_WRITES
-#define debug_wr debug
-#else
-#define debug_wr(...)
-#endif
-
-#define UPTR(a)		((uintptr_t)(a))
-
-#define s32_dbi_readb(addr) \
-	readb_relaxed((addr))
-
-#define s32_dbi_readw(addr) \
-	readw_relaxed((addr))
-
-#define s32_dbi_readl(addr) \
-	readl_relaxed((addr))
-
-#define s32_dbi_writeb(addr, val) \
-	writeb_relaxed((val), (addr))
-
-#define s32_dbi_writew(addr, val) \
-	writew_relaxed((val), (addr))
-
-#define s32_dbi_writel(addr, val) \
-	writel_relaxed((val), (addr))
-
-#define W16(address, write_data) \
-do { \
-	debug_wr("%s: W16(0x%llx, 0x%x) ... ", __func__, (u64)(address), \
-		(uint32_t)(write_data)); \
-	s32_dbi_writew((address), (write_data)); \
-	debug_wr("done\n"); \
-} while (0)
-
-#define W32(address, write_data) \
-do { \
-	debug_wr("%s: W32(0x%llx, 0x%x) ... ", __func__, (u64)(address), \
-		(uint32_t)(write_data)); \
-	s32_dbi_writel((address), (write_data)); \
-	debug_wr("done\n"); \
-} while (0)
-
-/* BCLR32 - SPARSE compliant version of `clrbits_le32`, with debug support. */
-#define BCLR32(address, mask_clear) \
-do { \
-	uintptr_t bclr_address = (address); \
-	u32 bclr_mask_clear = (mask_clear); \
-	debug_wr("%s: BCLR32(0x%lx, 0x%x) ... ", __func__, \
-		bclr_address, bclr_mask_clear); \
-	s32_dbi_writel(bclr_address, \
-		       s32_dbi_readl(bclr_address) & ~(bclr_mask_clear)); \
-	debug_wr("done\n"); \
-} while (0)
-
-/* BSET32 - SPARSE compliant version of `setbits_le32`, with debug support. */
-#define BSET32(address, mask_set) \
-do { \
-	uintptr_t bset_address = (address); \
-	u32 bset_mask_set = (mask_set); \
-	debug_wr("%s: BSET32(0x%lx, 0x%x) ... ", __func__, \
-		bset_address, bset_mask_set); \
-	s32_dbi_writel(bset_address, \
-		       s32_dbi_readl(bset_address) | (bset_mask_set)); \
-	debug_wr("done\n"); \
-} while (0)
-
-/* RMW32 - SPARSE compliant version of `clrsetbits_le32`, with debug support.
- * Please pay attention to the arguments order.
- */
-#define RMW32(address, mask_set, mask_clear) \
-do { \
-	uintptr_t rmw_address = (address); \
-	u32 rmw_mask_set = (mask_set), rmw_mask_clear = (mask_clear); \
-	debug_wr("%s: RMW32(0x%lx, set 0x%x, clear 0x%x) ... ", __func__, \
-		rmw_address, rmw_mask_set, rmw_mask_clear); \
-	s32_dbi_writel(rmw_address, \
-		       (s32_dbi_readl(rmw_address) & ~(rmw_mask_clear)) | \
-		       (rmw_mask_set)); \
-	debug_wr("done\n"); \
-} while (0)
-
-#endif /* SERDES_S32GEN1_IO_H */
diff --git a/arch/arm/include/asm/arch-s32/s32-cc/ss_pcie_regs.h b/drivers/pci/ss_pcie_regs.h
similarity index 100%
rename from arch/arm/include/asm/arch-s32/s32-cc/ss_pcie_regs.h
rename to drivers/pci/ss_pcie_regs.h
diff --git a/drivers/phy/Makefile b/drivers/phy/Makefile
index 2ca4d3c5b2..de142e30e0 100644
--- a/drivers/phy/Makefile
+++ b/drivers/phy/Makefile
@@ -26,4 +26,3 @@ obj-$(CONFIG_PHY_DA8XX_USB) += phy-da8xx-usb.o
 obj-$(CONFIG_PHY_MTK_TPHY) += phy-mtk-tphy.o
 obj-$(CONFIG_SAF1508BET_USB_PHY) += nxp_usb_saf1508.o
 obj-$(CONFIG_PHY_S32CC_SERDES) += nxp/s32cc-serdes.o
-ccflags-$(CONFIG_PHY_S32CC_SERDES) += -Iarch/$(ARCH)/include/asm/arch-s32/s32-cc -Idrivers/pci
diff --git a/drivers/phy/nxp/s32cc-serdes.c b/drivers/phy/nxp/s32cc-serdes.c
index 8bcad5f1b6..962871bd4a 100644
--- a/drivers/phy/nxp/s32cc-serdes.c
+++ b/drivers/phy/nxp/s32cc-serdes.c
@@ -23,13 +23,11 @@
 #include <linux/ioport.h>
 #include <linux/sizes.h>
 #include <linux/time.h>
+#include <s32-cc/serdes_hwconfig.h>
 #include <s32-cc/xpcs.h>
 #include <dt-bindings/phy/phy.h>
 
-#include "serdes_regs.h"
-#include "serdes_s32gen1_io.h"
-#include "sgmii.h"
-
+#define UPTR(X)			((uintptr_t)(X))
 #define SERDES_MAX_LANES 2U
 #define SERDES_MAX_INSTANCES 2U
 
@@ -82,6 +80,7 @@
 #define  EXT_MPLLB_BANDWIDTH(x)	(((x) & 0xffffU) << 0)
 #define PCIE_PHY_EXT_MPLLB_CTRL_2	(0x44U)
 #define  EXT_MPLLB_FRACN_CTRL(x)	(((x) & 0x7ffU) << 12)
+#define  MPLLB_MULTIPLIER(n)		(((n) & 0xffU) << 0)
 #define PCIE_PHY_EXT_MPLLB_CTRL_3	(0x48U)
 #define  EXT_MPLLB_WORD_DIV2_EN		BIT(31)
 #define  EXT_MPLLB_TX_CLK_DIV(x)	(((x) & 0x7U) << 28)
-- 
2.17.1

