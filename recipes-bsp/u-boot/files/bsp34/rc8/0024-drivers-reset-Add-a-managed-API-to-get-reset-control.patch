From 10ae07f04c07e6f894476fb8b6faaebdfd8ee41d Mon Sep 17 00:00:00 2001
From: Jean-Jacques Hiblot <jjhiblot@ti.com>
Date: Wed, 9 Sep 2020 15:37:03 +0530
Subject: [PATCH 024/102] drivers: reset: Add a managed API to get reset
 controllers from the DT

Add managed functions to get a reset_ctl from the device-tree, based on a
name or an index.
Also add a managed functions to get a reset_ctl_bulk (array of reset_ctl)
from the device-tree.

When the device is unbound, the reset controllers are automatically
released and the data structure is freed.

This is a cherry-pick of:
commit 139e4a1cbe60 ("drivers: reset: Add a managed API to get reset
		     controllers from the DT")

Upstream-Status: Pending 

Signed-off-by: Jean-Jacques Hiblot <jjhiblot@ti.com>
Reviewed-by: Simon Glass <sjg@chromium.org>
Signed-off-by: Pratyush Yadav <p.yadav@ti.com>

Issue: ALB-8357
Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/reset/reset-uclass.c | 118 ++++++++++++++++++++++++++++--
 include/reset.h              | 135 ++++++++++++++++++++++++++++++++++-
 2 files changed, 248 insertions(+), 5 deletions(-)

diff --git a/drivers/reset/reset-uclass.c b/drivers/reset/reset-uclass.c
index 8ec8e462e6..7ca987dbd2 100644
--- a/drivers/reset/reset-uclass.c
+++ b/drivers/reset/reset-uclass.c
@@ -10,6 +10,7 @@
 #include <reset.h>
 #include <reset-uclass.h>
 #include <dm/devres.h>
+#include <dm/lists.h>
 
 static inline struct reset_ops *reset_dev_ops(struct udevice *dev)
 {
@@ -99,13 +100,14 @@ int reset_get_by_index_nodev(ofnode node, int index,
 				       index > 0, reset_ctl);
 }
 
-int reset_get_bulk(struct udevice *dev, struct reset_ctl_bulk *bulk)
+static int __reset_get_bulk(struct udevice *dev, ofnode node,
+			    struct reset_ctl_bulk *bulk)
 {
 	int i, ret, err, count;
-	
+
 	bulk->count = 0;
 
-	count = dev_count_phandle_with_args(dev, "resets", "#reset-cells");
+	count = ofnode_count_phandle_with_args(node, "resets", "#reset-cells");
 	if (count < 1)
 		return count;
 
@@ -115,7 +117,7 @@ int reset_get_bulk(struct udevice *dev, struct reset_ctl_bulk *bulk)
 		return -ENOMEM;
 
 	for (i = 0; i < count; i++) {
-		ret = reset_get_by_index(dev, i, &bulk->resets[i]);
+		ret = reset_get_by_index_nodev(node, i, &bulk->resets[i]);
 		if (ret < 0)
 			goto bulk_get_err;
 
@@ -133,6 +135,11 @@ bulk_get_err:
 	return ret;
 }
 
+int reset_get_bulk(struct udevice *dev, struct reset_ctl_bulk *bulk)
+{
+	return __reset_get_bulk(dev, dev_ofnode(dev), bulk);
+}
+
 int reset_get_by_name(struct udevice *dev, const char *name,
 		     struct reset_ctl *reset_ctl)
 {
@@ -245,6 +252,109 @@ int reset_release_all(struct reset_ctl *reset_ctl, int count)
 	return 0;
 }
 
+static void devm_reset_release(struct udevice *dev, void *res)
+{
+	reset_free(res);
+}
+
+struct reset_ctl *devm_reset_control_get_by_index(struct udevice *dev,
+						  int index)
+{
+	int rc;
+	struct reset_ctl *reset_ctl;
+
+	reset_ctl = devres_alloc(devm_reset_release, sizeof(struct reset_ctl),
+				 __GFP_ZERO);
+	if (unlikely(!reset_ctl))
+		return ERR_PTR(-ENOMEM);
+
+	rc = reset_get_by_index(dev, index, reset_ctl);
+	if (rc)
+		return ERR_PTR(rc);
+
+	devres_add(dev, reset_ctl);
+	return reset_ctl;
+}
+
+struct reset_ctl *devm_reset_control_get(struct udevice *dev, const char *id)
+{
+	int rc;
+	struct reset_ctl *reset_ctl;
+
+	reset_ctl = devres_alloc(devm_reset_release, sizeof(struct reset_ctl),
+				 __GFP_ZERO);
+	if (unlikely(!reset_ctl))
+		return ERR_PTR(-ENOMEM);
+
+	rc = reset_get_by_name(dev, id, reset_ctl);
+	if (rc)
+		return ERR_PTR(rc);
+
+	devres_add(dev, reset_ctl);
+	return reset_ctl;
+}
+
+struct reset_ctl *devm_reset_control_get_optional(struct udevice *dev,
+						  const char *id)
+{
+	struct reset_ctl *r = devm_reset_control_get(dev, id);
+
+	if (IS_ERR(r))
+		return NULL;
+
+	return r;
+}
+
+static void devm_reset_bulk_release(struct udevice *dev, void *res)
+{
+	struct reset_ctl_bulk *bulk = res;
+
+	reset_release_all(bulk->resets, bulk->count);
+}
+
+struct reset_ctl_bulk *devm_reset_bulk_get_by_node(struct udevice *dev,
+						   ofnode node)
+{
+	int rc;
+	struct reset_ctl_bulk *bulk;
+
+	bulk = devres_alloc(devm_reset_bulk_release,
+			    sizeof(struct reset_ctl_bulk),
+			    __GFP_ZERO);
+	if (unlikely(!bulk))
+		return ERR_PTR(-ENOMEM);
+
+	rc = __reset_get_bulk(dev, node, bulk);
+	if (rc)
+		return ERR_PTR(rc);
+
+	devres_add(dev, bulk);
+	return bulk;
+}
+
+struct reset_ctl_bulk *devm_reset_bulk_get_optional_by_node(struct udevice *dev,
+							    ofnode node)
+{
+	struct reset_ctl_bulk *bulk;
+
+	bulk = devm_reset_bulk_get_by_node(dev, node);
+
+	if (IS_ERR(bulk))
+		return NULL;
+
+	return bulk;
+}
+
+struct reset_ctl_bulk *devm_reset_bulk_get(struct udevice *dev)
+{
+	return devm_reset_bulk_get_by_node(dev, dev_ofnode(dev));
+}
+
+struct reset_ctl_bulk *devm_reset_bulk_get_optional(struct udevice *dev)
+{
+	return devm_reset_bulk_get_optional_by_node(dev, dev_ofnode(dev));
+}
+
 UCLASS_DRIVER(reset) = {
 	.id		= UCLASS_RESET,
 	.name		= "reset",
diff --git a/include/reset.h b/include/reset.h
index 4fac4e6a20..cde2c4b4a8 100644
--- a/include/reset.h
+++ b/include/reset.h
@@ -7,7 +7,7 @@
 #define _RESET_H
 
 #include <dm/ofnode.h>
-#include <linux/errno.h>
+#include <linux/err.h>
 
 /**
  * A reset is a hardware signal indicating that a HW module (or IP block, or
@@ -84,6 +84,98 @@ struct reset_ctl_bulk {
 };
 
 #if CONFIG_IS_ENABLED(DM_RESET)
+
+/**
+ * devm_reset_control_get - resource managed reset_get_by_name()
+ * @dev: device to be reset by the controller
+ * @id: reset line name
+ *
+ * Managed reset_get_by_name(). For reset controllers returned
+ * from this function, reset_free() is called automatically on driver
+ * detach.
+ *
+ * Returns a struct reset_ctl or IS_ERR() condition containing errno.
+ */
+struct reset_ctl *devm_reset_control_get(struct udevice *dev, const char *id);
+
+/**
+ * devm_reset_control_get_optional - resource managed reset_get_by_name() that
+ *                                   can fail
+ * @dev:	The client device.
+ * @id:		reset line name
+ *
+ * Managed reset_get_by_name(). For reset controllers returned
+ * from this function, reset_free() is called automatically on driver
+ * detach.
+ *
+ * Returns a struct reset_ctl or a dummy reset controller if it failed.
+ */
+struct reset_ctl *devm_reset_control_get_optional(struct udevice *dev,
+						  const char *id);
+
+/**
+ * devm_reset_control_get - resource managed reset_get_by_index()
+ * @dev:	The client device.
+ * @index:	The index of the reset signal to request, within the client's
+ *		list of reset signals.
+ *
+ * Managed reset_get_by_index(). For reset controllers returned
+ * from this function, reset_free() is called automatically on driver
+ * detach.
+ *
+ * Returns a struct reset_ctl or IS_ERR() condition containing errno.
+ */
+struct reset_ctl *devm_reset_control_get_by_index(struct udevice *dev,
+						  int index);
+
+/**
+ * devm_reset_bulk_get - resource managed reset_get_bulk()
+ * @dev: device to be reset by the controller
+ *
+ * Managed reset_get_bulk(). For reset controllers returned
+ * from this function, reset_free() is called automatically on driver
+ * detach.
+ *
+ * Returns a struct reset_ctl or IS_ERR() condition containing errno.
+ */
+struct reset_ctl_bulk *devm_reset_bulk_get(struct udevice *dev);
+
+/**
+ * devm_reset_bulk_get_optional - resource managed reset_get_bulk() that
+ *                                can fail
+ * @dev:	The client device.
+ *
+ * Managed reset_get_bulk(). For reset controllers returned
+ * from this function, reset_free() is called automatically on driver
+ * detach.
+ *
+ * Returns a struct reset_ctl or NULL if it failed.
+ */
+struct reset_ctl_bulk *devm_reset_bulk_get_optional(struct udevice *dev);
+
+/**
+ * devm_reset_bulk_get_by_node - resource managed reset_get_bulk()
+ * @dev: device to be reset by the controller
+ * @node: ofnode where the "resets" property is. Usually a sub-node of
+ *        the dev's node.
+ *
+ * see devm_reset_bulk_get()
+ */
+struct reset_ctl_bulk *devm_reset_bulk_get_by_node(struct udevice *dev,
+						   ofnode node);
+
+/**
+ * devm_reset_bulk_get_optional_by_node - resource managed reset_get_bulk()
+ *                                        that can fail
+ * @dev: device to be reset by the controller
+ * @node: ofnode where the "resets" property is. Usually a sub-node of
+ *        the dev's node.
+ *
+ * see devm_reset_bulk_get_optional()
+ */
+struct reset_ctl_bulk *devm_reset_bulk_get_optional_by_node(struct udevice *dev,
+							    ofnode node);
+
 /**
  * reset_get_by_index - Get/request a reset signal by integer index.
  *
@@ -265,7 +357,48 @@ static inline int reset_release_bulk(struct reset_ctl_bulk *bulk)
 {
 	return reset_release_all(bulk->resets, bulk->count);
 }
+
 #else
+static inline struct reset_ctl *devm_reset_control_get(struct udevice *dev,
+						       const char *id)
+{
+	return ERR_PTR(-ENOTSUPP);
+}
+
+static inline struct reset_ctl *devm_reset_control_get_optional(struct udevice *dev,
+								const char *id)
+{
+	return NULL;
+}
+
+static inline struct reset_ctl *devm_reset_control_get_by_index(struct udevice *dev,
+								int index)
+{
+	return ERR_PTR(-ENOTSUPP);
+}
+
+static inline struct reset_ctl_bulk *devm_reset_bulk_get(struct udevice *dev)
+{
+	return ERR_PTR(-ENOTSUPP);
+}
+
+static inline struct reset_ctl_bulk *devm_reset_bulk_get_optional(struct udevice *dev)
+{
+	return NULL;
+}
+
+static inline struct reset_ctl_bulk *devm_reset_bulk_get_by_node(struct udevice *dev,
+								 ofnode node)
+{
+	return ERR_PTR(-ENOTSUPP);
+}
+
+static inline struct reset_ctl_bulk *devm_reset_bulk_get_optional_by_node(struct udevice *dev,
+									  ofnode node)
+{
+	return NULL;
+}
+
 static inline int reset_get_by_index(struct udevice *dev, int index,
 				     struct reset_ctl *reset_ctl)
 {
-- 
2.17.1

