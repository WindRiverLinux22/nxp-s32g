From 666aa21e0cf9b79ae817875e3a25caa15ac8fff1 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Mon, 25 Jul 2022 16:57:17 +0300
Subject: [PATCH 062/102] pci: Initialize PCIE phy through generic PHY API

Issue: ALB-8357
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/pci/pcie_s32gen1.c     | 142 +++++++++++---
 drivers/pci/pcie_s32gen1.h     |   4 +
 drivers/phy/nxp/s32cc-serdes.c | 329 +++++++++++++++++++--------------
 3 files changed, 308 insertions(+), 167 deletions(-)

diff --git a/drivers/pci/pcie_s32gen1.c b/drivers/pci/pcie_s32gen1.c
index 7623b3ccea..3116b39bb8 100644
--- a/drivers/pci/pcie_s32gen1.c
+++ b/drivers/pci/pcie_s32gen1.c
@@ -7,6 +7,7 @@
 #include <common.h>
 #include <dm.h>
 #include <errno.h>
+#include <generic-phy.h>
 #include <hwconfig.h>
 #include <malloc.h>
 #include <misc.h>
@@ -15,6 +16,7 @@
 #include <asm/arch/clock.h>
 #include <asm/arch/s32-cc/serdes_regs.h>
 #include <dm/device-internal.h>
+#include <dm/device_compat.h>
 #include <dm/uclass.h>
 #include <linux/io.h>
 #include <linux/iopoll.h>
@@ -24,6 +26,7 @@
 #include <s32-cc/pcie.h>
 #include <s32-cc/serdes_hwconfig.h>
 #include <dt-bindings/nvmem/s32cc-siul2-nvmem.h>
+#include <dt-bindings/phy/phy.h>
 
 #include "serdes_s32gen1_io.h"
 #include "ss_pcie_regs.h"
@@ -58,6 +61,11 @@
 #define PCI_DEVICE_ID_S32GEN1	0x4002
 #define LINK_UP_TIMEOUT		(50 * USEC_PER_MSEC)
 
+enum pcie_device_mode {
+	PCIE_RC_TYPE,
+	PCIE_EP_TYPE
+};
+
 LIST_HEAD(s32_pcie_list);
 
 static inline void s32_pcie_enable_dbi_rw(void __iomem *dbi)
@@ -596,16 +604,9 @@ static bool s32_pcie_set_link_width(void __iomem *dbi, int id,
 	return true;
 }
 
-static int s32_pcie_check_phy_mode(int id, const char *mode)
-{
-	char pcie_name[10];
-
-	sprintf(pcie_name, "pcie%d", id);
-	return hwconfig_subarg_cmp(pcie_name, "phy_mode", mode);
-}
-
 static bool s32_pcie_init(void __iomem *dbi, int id, bool rc_mode,
-			  enum pcie_link_width linkwidth)
+			  enum pcie_link_width linkwidth,
+			  enum pcie_phy_mode phy_mode)
 {
 	printf("Configuring PCIe%d as %s\n", id, PCIE_EP_RC_MODE(!rc_mode));
 
@@ -617,7 +618,7 @@ static bool s32_pcie_init(void __iomem *dbi, int id, bool rc_mode,
 		W32(UPTR(dbi) + SS_PE0_GEN_CTRL_1,
 		    BUILD_MASK_VALUE(DEVICE_TYPE, PCIE_EP));
 
-	if (s32_pcie_check_phy_mode(id, "sris"))
+	if (phy_mode == SRIS)
 		BSET32(UPTR(dbi) + SS_PE0_GEN_CTRL_1, PCIE_SRIS_MODE_MASK);
 
 	/* Enable writing dbi registers */
@@ -719,12 +720,34 @@ static int s32_pcie_get_hw_mode_ep(struct s32_pcie *pcie)
 static int s32_pcie_get_config_from_device_tree(struct s32_pcie *pcie)
 {
 	struct udevice *dev = pcie->bus;
-	struct resource res;
+	struct resource res = {};
+	const char *pcie_phy_mode;
 	int ret = 0;
 	u32 val;
 
 	debug("%s: dt node: %s\n", __func__, dev_read_name(dev));
 
+	ret = generic_phy_get_by_name(dev, "serdes_lane0", &pcie->phy0);
+	if (ret) {
+		printf("Failed to get 'serdes_lane0' PHY\n");
+		return ret;
+	}
+
+	pcie_phy_mode = dev_read_string(dev, "nxp,phy-mode");
+	if (!pcie_phy_mode) {
+		dev_info(dev, "Missing 'nxp,phy-mode' property, using default CRNS\n");
+		pcie->phy_mode = CRNS;
+	} else if (!strcmp(pcie_phy_mode, "crns")) {
+		pcie->phy_mode = CRNS;
+	} else if (!strcmp(pcie_phy_mode, "crss")) {
+		pcie->phy_mode = CRSS;
+	} else if (!strcmp(pcie_phy_mode, "sris")) {
+		pcie->phy_mode = SRIS;
+	} else {
+		dev_info(dev, "Unsupported 'nxp,phy-mode' specified, using default CRNS\n");
+		pcie->phy_mode = CRNS;
+	}
+
 	ret = dev_read_alias_seq(dev, &pcie->id);
 	if (ret < 0) {
 		printf("Failed to get PCIe device id\n");
@@ -974,19 +997,94 @@ static int s32gen1_check_serdes(struct udevice *dev)
 	return 0;
 }
 
+static int init_pcie_phy(struct s32_pcie *pcie)
+{
+	struct udevice *dev = pcie->bus;
+	int ret;
+
+	ret = generic_phy_init(&pcie->phy0);
+	if (ret) {
+		dev_err(dev, "Failed to init 'serdes_lane0' PHY\n");
+		return ret;
+	}
+
+	ret = generic_phy_set_mode_ext(&pcie->phy0, PHY_TYPE_PCIE,
+				       pcie->phy_mode);
+	if (ret) {
+		dev_err(dev, "Failed to set mode on 'serdes_lane0' PHY\n");
+		return ret;
+	}
+
+	ret = generic_phy_power_on(&pcie->phy0);
+	if (ret) {
+		dev_err(dev, "Failed to power on 'serdes_lane0' PHY\n");
+		return ret;
+	}
+
+	ret = generic_phy_get_by_name(dev, "serdes_lane1", &pcie->phy1);
+	if (ret)
+		pcie->has_phy1 = 0;
+	else
+		pcie->has_phy1 = 1;
+
+	if (!pcie->has_phy1)
+		return 0;
+
+	ret = generic_phy_init(&pcie->phy1);
+	if (ret) {
+		dev_err(dev, "Failed to init 'serdes_lane1' PHY\n");
+		return ret;
+	}
+
+	ret = generic_phy_set_mode_ext(&pcie->phy1, PHY_TYPE_PCIE,
+				       pcie->phy_mode);
+	if (ret) {
+		dev_err(dev, "Failed to set mode on 'serdes_lane1' PHY\n");
+		return ret;
+	}
+
+	ret = generic_phy_power_on(&pcie->phy1);
+	if (ret) {
+		dev_err(dev, "Failed to power on 'serdes_lane1' PHY\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int init_controller(struct s32_pcie *pcie)
+{
+	int ret;
+
+	s32_pcie_disable_ltssm(pcie->dbi);
+
+	ret = init_pcie_phy(pcie);
+	if (ret)
+		return ret;
+
+	if (!s32_pcie_init(pcie->dbi, pcie->id, !pcie->ep_mode,
+			   pcie->linkwidth, pcie->phy_mode))
+		return -EINVAL;
+
+	s32_pcie_enable_ltssm(pcie->dbi);
+
+	return ret;
+}
+
 static int s32_pcie_probe(struct udevice *dev)
 {
+	enum pcie_device_mode pcie_mode;
 	struct s32_pcie *pcie = dev_get_priv(dev);
 	struct uclass *uc = dev->uclass;
 	int ret = 0;
 	bool ltssm_en = false;
-	enum serdes_dev_type devtype;
 	u32 variant_bits, pcie_dev_id;
 
 	if (!pcie)
 		return -EINVAL;
 
 	pcie->enabled = false;
+	pcie_mode = (enum pcie_device_mode)dev_get_driver_data(dev);
 
 	ret = s32gen1_check_serdes(dev);
 	if (ret)
@@ -1006,23 +1104,15 @@ static int s32_pcie_probe(struct udevice *dev)
 	if (ret)
 		return ret;
 
-	devtype = s32_serdes_get_mode_from_hwconfig(pcie->id);
-	if (IS_SERDES_PCIE(devtype)) {
-		if (IS_SERDES_SGMII(devtype))
-			pcie->linkwidth = X1;
-
-		if (!s32_pcie_init(pcie->dbi, pcie->id, devtype & PCIE_RC,
-				   pcie->linkwidth))
-			return ret;
-
-		s32_pcie_enable_ltssm(pcie->dbi);
-	}
+	ret = init_controller(pcie);
+	if (ret)
+		return ret;
 
 	/*
 	 * it makes sense to link up only as RC, as the EP
 	 * may boot earlier
 	 */
-	if (devtype & PCIE_RC) {
+	if (pcie_mode == PCIE_RC_TYPE) {
 		if (s32_pcie_wait_link_up(pcie->dbi)) {
 			debug("SerDes%d: link is up (X%d)\n", pcie->id,
 			      pcie->linkwidth);
@@ -1177,8 +1267,8 @@ static const struct dm_pci_ops s32_pcie_ops = {
 };
 
 static const struct udevice_id s32_pcie_ids[] = {
-	{ .compatible = "nxp,s32cc-pcie", .data = PCIE_RC },
-	{ .compatible = "nxp,s32cc-pcie-ep", .data = PCIE_EP },
+	{ .compatible = "nxp,s32cc-pcie", .data = PCIE_RC_TYPE },
+	{ .compatible = "nxp,s32cc-pcie-ep", .data = PCIE_EP_TYPE },
 	{ }
 };
 
diff --git a/drivers/pci/pcie_s32gen1.h b/drivers/pci/pcie_s32gen1.h
index 916df345df..4d2fc7a460 100644
--- a/drivers/pci/pcie_s32gen1.h
+++ b/drivers/pci/pcie_s32gen1.h
@@ -7,6 +7,7 @@
 #ifndef PCIE_S32GEN1_H
 #define PCIE_S32GEN1_H
 #include <dm.h>
+#include <generic-phy.h>
 #include <pci.h>
 #include <asm/io.h>
 #include <linux/ioport.h>
@@ -138,6 +139,7 @@ enum pcie_link_width {
 
 struct s32_pcie {
 	struct list_head list;
+	struct phy phy0, phy1;
 	struct udevice *bus;
 	struct resource cfg_res;
 	void __iomem *dbi;
@@ -148,8 +150,10 @@ struct s32_pcie {
 	int id;
 	bool enabled;
 	bool ep_mode;
+	u8 has_phy1;
 	enum pcie_link_width linkwidth;
 	enum pcie_link_speed linkspeed;
+	enum pcie_phy_mode phy_mode;
 	int atu_out_num;
 	int atu_in_num;
 };
diff --git a/drivers/phy/nxp/s32cc-serdes.c b/drivers/phy/nxp/s32cc-serdes.c
index 04e69dd4c5..6a9b32f95a 100644
--- a/drivers/phy/nxp/s32cc-serdes.c
+++ b/drivers/phy/nxp/s32cc-serdes.c
@@ -8,6 +8,7 @@
 #include <clk.h>
 #include <dm.h>
 #include <errno.h>
+#include <generic-phy.h>
 #include <hwconfig.h>
 #include <malloc.h>
 #include <pci.h>
@@ -121,8 +122,6 @@ struct serdes {
 	struct udevice *dev;
 
 	int id;
-	enum serdes_dev_type devtype;
-	enum serdes_xpcs_mode xpcs_mode;
 };
 
 static const char * const serdes_clk_names[] = {
@@ -257,7 +256,188 @@ static int pcie_phy_power_on(struct serdes *serdes, int id)
 	return 0;
 }
 
-static int s32_serdes_assert_reset(struct serdes *serdes)
+static void s32_serdes_xpcs1_pma_config(struct serdes *serdes)
+{
+	/* Configure TX_VBOOST_LVL and TX_TERM_CTRL */
+	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MISC_CTRL_2,
+	      EXT_TX_VBOOST_LVL(0x3) | EXT_TX_TERM_CTRL(0x4),
+	      EXT_TX_VBOOST_LVL(0x7) | EXT_TX_TERM_CTRL(0x7));
+	/* Enable phy external control */
+	BSET32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_CTRL_SEL,
+	       EXT_PHY_CTRL_SEL);
+	/* Configure ref range, disable PLLB/ref div2 */
+	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_REF_CLK_CTRL,
+	      EXT_REF_RANGE(0x3),
+	      REF_CLK_DIV2_EN | REF_CLK_MPLLB_DIV2_EN | EXT_REF_RANGE(0x7));
+	/* Configure multiplier */
+	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MPLLB_CTRL_2,
+	      MPLLB_MULTIPLIER(0x27U) | EXT_MPLLB_FRACN_CTRL(0x414),
+	      MPLLB_MULTIPLIER(0xffU) | EXT_MPLLB_FRACN_CTRL(0x7ff) |
+	      1 << 24U | 1 << 28U);
+
+	BCLR32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_MPLLB_CTRL,
+	       MPLLB_SSC_EN_MASK);
+
+	/* Configure tx lane division, disable word clock div2*/
+	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MPLLB_CTRL_3,
+	      EXT_MPLLB_TX_CLK_DIV(0x5),
+	      EXT_MPLLB_WORD_DIV2_EN | EXT_MPLLB_TX_CLK_DIV(0x7));
+
+	/* Configure configure bandwidth for filtering and div10*/
+	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MPLLB_CTRL_1,
+	      EXT_MPLLB_BANDWIDTH(0x5f) | EXT_MPLLB_DIV10_CLK_EN,
+	      EXT_MPLLB_BANDWIDTH(0xffff) | EXT_MPLLB_DIV_CLK_EN |
+	      EXT_MPLLB_DIV8_CLK_EN | EXT_MPLLB_DIV_MULTIPLIER(0xff));
+
+	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MPLLA_CTRL_1,
+	      EXT_MPLLA_BANDWIDTH(0xc5), EXT_MPLLA_BANDWIDTH(0xffff));
+
+	/* Configure VCO */
+	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_XPCS1_RX_OVRD_CTRL,
+	      XPCS1_RX_VCO_LD_VAL(0x540U) | XPCS1_RX_REF_LD_VAL(0x2bU),
+	      XPCS1_RX_VCO_LD_VAL(0x1fffU) | XPCS1_RX_REF_LD_VAL(0x3fU));
+
+	/* Boundary scan control */
+	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_BS_CTRL,
+	      EXT_BS_RX_LEVEL(0xb) | EXT_BS_RX_BIGSWING,
+	      EXT_BS_RX_LEVEL(0x1f) | EXT_BS_TX_LOWSWING);
+
+	/* Rx loss threshold */
+	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MISC_CTRL_1,
+	      EXT_RX_LOS_THRESHOLD(0x3U) | EXT_RX_VREF_CTRL(0x11U),
+	      EXT_RX_LOS_THRESHOLD(0x3fU) | EXT_RX_VREF_CTRL(0x1fU));
+}
+
+static void s32_serdes_start_mode5(struct serdes *serdes,
+				   enum serdes_xpcs_mode_gen2 xpcs[2])
+{
+	if (!s32_serdes_has_mode5_enabled(serdes->id))
+		return;
+
+	printf("SerDes%d: Enabling serdes mode5\n", serdes->id);
+	/* Initialize PMA */
+	serdes_pma_mode5(serdes->xpcs.base1);
+	/* Initialize PHY */
+	s32_serdes_xpcs1_pma_config(serdes);
+	/* Initialize PCS */
+	serdes_pcs_mode5(serdes->xpcs.base1);
+	/* mode5 representation */
+	xpcs[0] = SGMII_XPCS_PCIE;
+	xpcs[1] = SGMII_XPCS_2G5_OP;
+}
+
+static int xpcs_init_clks(struct serdes *serdes)
+{
+	/* Get XPCS configuration */
+	enum serdes_xpcs_mode xpcs_mode;
+	enum serdes_xpcs_mode_gen2 xpcs[2] = {SGMII_XPCS_PCIE};
+	unsigned long rate;
+	int ret;
+
+	xpcs_mode = s32_serdes_get_xpcs_cfg_from_hwconfig(serdes->id);
+
+	/* Nothing to do if PCIE only */
+	if (!serdes->ctrl.ss_mode)
+		return 0;
+
+	/* Nothing to do if XPCS options are invalid */
+	if (xpcs_mode == SGMII_INAVALID)
+		return 0;
+
+	ret = get_clk_rate(serdes, &rate);
+	if (ret)
+		return -EINVAL;
+
+	/* Check, if mode5 demo is requested */
+	s32_serdes_start_mode5(serdes, xpcs);
+
+	ret = s32_eth_xpcs_init(serdes->xpcs.base0, serdes->xpcs.base1,
+				serdes->id,
+				serdes->ctrl.ss_mode,
+				xpcs_mode,
+				serdes->ctrl.ext_clk,
+				rate,
+				xpcs);
+	if (ret) {
+		printf("Error during configuration of SGMII on");
+		printf(" PCIe%d\n", serdes->id);
+	}
+
+	return ret;
+}
+
+static int serdes_phy_init(struct phy *p)
+{
+	/* Nothing to do for PCIE phys */
+	return 0;
+}
+
+static int serdes_phy_set_mode_ext(struct phy *p, int mode, int submode)
+{
+	struct serdes *serdes = dev_get_priv(p->dev);
+	int id = p->id;
+
+	if (!serdes)
+		return -EINVAL;
+
+	/* Check if same PCIE PHY mode is set on both lanes */
+	if (id == 1)
+		if (submode != serdes->ctrl.phy_mode)
+			return -EINVAL;
+
+	/* Do not configure SRIS or CRSS PHY MODE in conjunction
+	 * with any SGMII mode on the same SerDes subsystem
+	 */
+	if (submode == CRSS || submode == SRIS) {
+		if (serdes->ctrl.ss_mode != 0)
+			return -EINVAL;
+	}
+
+	/* CRSS or SRIS PCIE PHY mode cannot be used
+	 * with internal clock
+	 */
+	if (!serdes->ctrl.ext_clk)
+		if (submode == CRSS || submode == SRIS)
+			return -EINVAL;
+
+	serdes->ctrl.phy_mode = (enum pcie_phy_mode)submode;
+
+	return 0;
+}
+
+static int serdes_phy_power_on(struct phy *p)
+{
+	struct serdes *serdes = dev_get_priv(p->dev);
+	int ret;
+
+	if (!serdes)
+		return -EINVAL;
+
+	ret = pcie_phy_power_on(serdes, p->id);
+	if (ret)
+		return ret;
+
+	return ret;
+}
+
+static int serdes_phy_xlate(struct phy *phy, struct ofnode_phandle_args *args)
+{
+	if (args->args_count < 3)
+		return -EINVAL;
+
+	phy->id = args->args[2];
+
+	return 0;
+}
+
+static const struct phy_ops serdes_ops = {
+	.of_xlate	= serdes_phy_xlate,
+	.init		= serdes_phy_init,
+	.set_mode	= serdes_phy_set_mode_ext,
+	.power_on	= serdes_phy_power_on,
+};
+
+static int assert_reset(struct serdes *serdes)
 {
 	__maybe_unused struct udevice *dev = serdes->dev;
 	int ret;
@@ -329,77 +509,11 @@ static int init_serdes(struct serdes *serdes)
 	dev_info(serdes->dev, "Using mode %d for SerDes subsystem\n",
 		 ctrl->ss_mode);
 
-	return 0;
-}
-
-static void s32_serdes_xpcs1_pma_config(struct serdes *serdes)
-{
-	/* Configure TX_VBOOST_LVL and TX_TERM_CTRL */
-	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MISC_CTRL_2,
-	      EXT_TX_VBOOST_LVL(0x3) | EXT_TX_TERM_CTRL(0x4),
-	      EXT_TX_VBOOST_LVL(0x7) | EXT_TX_TERM_CTRL(0x7));
-	/* Enable phy external control */
-	BSET32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_CTRL_SEL,
-	       EXT_PHY_CTRL_SEL);
-	/* Configure ref range, disable PLLB/ref div2 */
-	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_REF_CLK_CTRL,
-	      EXT_REF_RANGE(0x3),
-	      REF_CLK_DIV2_EN | REF_CLK_MPLLB_DIV2_EN | EXT_REF_RANGE(0x7));
-	/* Configure multiplier */
-	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MPLLB_CTRL_2,
-	      MPLLB_MULTIPLIER(0x27U) | EXT_MPLLB_FRACN_CTRL(0x414),
-	      MPLLB_MULTIPLIER(0xffU) | EXT_MPLLB_FRACN_CTRL(0x7ff) |
-	      1 << 24U | 1 << 28U);
-
-	BCLR32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_MPLLB_CTRL,
-	       MPLLB_SSC_EN_MASK);
-
-	/* Configure tx lane division, disable word clock div2*/
-	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MPLLB_CTRL_3,
-	      EXT_MPLLB_TX_CLK_DIV(0x5),
-	      EXT_MPLLB_WORD_DIV2_EN | EXT_MPLLB_TX_CLK_DIV(0x7));
-
-	/* Configure configure bandwidth for filtering and div10*/
-	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MPLLB_CTRL_1,
-	      EXT_MPLLB_BANDWIDTH(0x5f) | EXT_MPLLB_DIV10_CLK_EN,
-	      EXT_MPLLB_BANDWIDTH(0xffff) | EXT_MPLLB_DIV_CLK_EN |
-	      EXT_MPLLB_DIV8_CLK_EN | EXT_MPLLB_DIV_MULTIPLIER(0xff));
-
-	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MPLLA_CTRL_1,
-	      EXT_MPLLA_BANDWIDTH(0xc5), EXT_MPLLA_BANDWIDTH(0xffff));
-
-	/* Configure VCO */
-	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_XPCS1_RX_OVRD_CTRL,
-	      XPCS1_RX_VCO_LD_VAL(0x540U) | XPCS1_RX_REF_LD_VAL(0x2bU),
-	      XPCS1_RX_VCO_LD_VAL(0x1fffU) | XPCS1_RX_REF_LD_VAL(0x3fU));
-
-	/* Boundary scan control */
-	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_BS_CTRL,
-	      EXT_BS_RX_LEVEL(0xb) | EXT_BS_RX_BIGSWING,
-	      EXT_BS_RX_LEVEL(0x1f) | EXT_BS_TX_LOWSWING);
-
-	/* Rx loss threshold */
-	RMW32(UPTR(serdes->ctrl.ss_base) + PCIE_PHY_EXT_MISC_CTRL_1,
-	      EXT_RX_LOS_THRESHOLD(0x3U) | EXT_RX_VREF_CTRL(0x11U),
-	      EXT_RX_LOS_THRESHOLD(0x3fU) | EXT_RX_VREF_CTRL(0x1fU));
-}
-
-static void s32_serdes_start_mode5(struct serdes *serdes,
-				   enum serdes_xpcs_mode_gen2 xpcs[2])
-{
-	if (!s32_serdes_has_mode5_enabled(serdes->id))
-		return;
+	ret = xpcs_init_clks(serdes);
+	if (ret)
+		dev_err(serdes->dev, "XPCS init failed\n");
 
-	printf("SerDes%d: Enabling serdes mode5\n", serdes->id);
-	/* Initialize PMA */
-	serdes_pma_mode5(serdes->xpcs.base1);
-	/* Initialize PHY */
-	s32_serdes_xpcs1_pma_config(serdes);
-	/* Initialize PCS */
-	serdes_pcs_mode5(serdes->xpcs.base1);
-	/* mode5 representation */
-	xpcs[0] = SGMII_XPCS_PCIE;
-	xpcs[1] = SGMII_XPCS_2G5_OP;
+	return ret;
 }
 
 __weak int s32_eth_xpcs_init(void __iomem *xpcs0, void __iomem *xpcs1,
@@ -414,17 +528,6 @@ __weak int s32_eth_xpcs_init(void __iomem *xpcs0, void __iomem *xpcs1,
 	return -ENODEV;
 }
 
-static const char *s32_serdes_get_pcie_phy_mode(struct serdes *serdes)
-{
-	if (serdes->ctrl.phy_mode == CRSS)
-		return "CRSS";
-	else if (serdes->ctrl.phy_mode == SRIS)
-		return "SRIS";
-
-	/* Default PCIE PHY mode */
-	return "CRNS";
-}
-
 static int get_serdes_alias_id(struct udevice *dev, int *devnump)
 {
 	ofnode node = dev_ofnode(dev);
@@ -585,8 +688,6 @@ static int disable_serdes_clocks(struct serdes *serdes)
 static int serdes_probe(struct udevice *dev)
 {
 	struct serdes *serdes = dev_get_priv(dev);
-	unsigned long rate;
-	const char *pcie_phy_mode;
 	int ret = 0;
 
 	debug("%s: probing %s\n", __func__, dev->name);
@@ -601,10 +702,6 @@ static int serdes_probe(struct udevice *dev)
 	if (ret)
 		return ret;
 
-	ret = get_clk_rate(serdes, &rate);
-	if (ret)
-		goto disable_clks;
-
 	ret = pcie_dt_init(dev, serdes);
 	if (ret)
 		goto disable_clks;
@@ -613,61 +710,10 @@ static int serdes_probe(struct udevice *dev)
 	if (ret)
 		goto disable_clks;
 
-	serdes->devtype = s32_serdes_get_mode_from_hwconfig(serdes->id);
-	/* Get XPCS configuration */
-	serdes->xpcs_mode = s32_serdes_get_xpcs_cfg_from_hwconfig(serdes->id);
-
-	serdes->ctrl.phy_mode = s32_serdes_get_phy_mode_from_hwconfig(serdes->id);
-
-	pcie_phy_mode = s32_serdes_get_pcie_phy_mode(serdes);
-	printf("Using %s clock for PCIe%d, %s\n",
-	       SERDES_CLK_MODE(serdes->ctrl.ext_clk),
-	       serdes->id, pcie_phy_mode);
-	if (IS_SERDES_SGMII(serdes->devtype) &&
-	    serdes->xpcs_mode != SGMII_INAVALID)
-		printf("Frequency %s configured for PCIe%d\n",
-		       SERDES_CLK_FMHZ(rate),
-		       serdes->id);
-
 	ret = init_serdes(serdes);
 	if (ret)
 		goto disable_clks;
 
-	if (IS_SERDES_PCIE(serdes->devtype)) {
-		ret = pcie_phy_power_on(serdes, 0);
-		if (ret) {
-			dev_err(dev, "Failed to initialize PCIe line 0\n");
-			goto disable_clks;
-		}
-		if (serdes->ctrl.ss_mode == 0) {
-			ret = pcie_phy_power_on(serdes, 1);
-			if (ret) {
-				dev_err(dev, "Failed to initialize PCIe line 1\n");
-				goto disable_clks;
-			}
-		}
-	}
-
-	if (IS_SERDES_SGMII(serdes->devtype) &&
-	    serdes->xpcs_mode != SGMII_INAVALID) {
-		enum serdes_xpcs_mode_gen2 xpcs[2] = {SGMII_XPCS_PCIE};
-
-		/* Check, if mode5 demo is requested */
-		s32_serdes_start_mode5(serdes, xpcs);
-
-		ret = s32_eth_xpcs_init(serdes->xpcs.base0, serdes->xpcs.base1,
-					serdes->id,
-					serdes->ctrl.ss_mode,
-					serdes->xpcs_mode,
-					serdes->ctrl.ext_clk,
-					rate,
-					xpcs);
-		if (ret) {
-			printf("Error during configuration of SGMII on");
-			printf(" PCIe%d\n", serdes->id);
-		}
-	}
-
 disable_clks:
 	if (ret)
 		disable_serdes_clocks(serdes);
@@ -684,6 +730,7 @@ U_BOOT_DRIVER(s32cc_serdes) = {
 	.name = "s32cc_serdes_phy",
 	.id = UCLASS_PHY,
 	.of_match = serdes_match,
+	.ops	= &serdes_ops,
 	.probe	= serdes_probe,
 	.priv_auto_alloc_size = sizeof(struct serdes),
 };
-- 
2.17.1

