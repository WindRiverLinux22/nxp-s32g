From 989f7e25204e18aaa706cdd9009d06ca2e662e9f Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Wed, 13 Jul 2022 14:16:59 +0300
Subject: [PATCH 026/102] pci: serdes: Use reset controller instead of
 accessing RGM

Issue: ALB-8357
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 arch/arm/mach-s32/Kconfig    |   2 +
 drivers/pci/serdes_s32gen1.c | 146 ++++++++++++-----------------------
 drivers/pci/serdes_s32gen1.h |  18 +----
 3 files changed, 51 insertions(+), 115 deletions(-)

diff --git a/arch/arm/mach-s32/Kconfig b/arch/arm/mach-s32/Kconfig
index 921dbd219b..e143aaac2c 100644
--- a/arch/arm/mach-s32/Kconfig
+++ b/arch/arm/mach-s32/Kconfig
@@ -55,6 +55,7 @@ config NXP_S32CC
 	select DM_GPIO
 	select DM_MMC
 	select DM_MTD
+	select DM_RESET
 	select DM_SERIAL
 	select FSL_LINFLEXUART
 	select FSL_USDHC
@@ -71,6 +72,7 @@ config NXP_S32CC
 	select PINCTRL
 	select PINCTRL_FULL
 	select PINCTRL_S32CC
+	select RESET_SCMI
 	select S32CC_GPIO
 	select SCMI_FIRMWARE
 	select SPI_FLASH_MTD
diff --git a/drivers/pci/serdes_s32gen1.c b/drivers/pci/serdes_s32gen1.c
index e852e9ed58..b19cd0142d 100644
--- a/drivers/pci/serdes_s32gen1.c
+++ b/drivers/pci/serdes_s32gen1.c
@@ -11,6 +11,7 @@
 #include <hwconfig.h>
 #include <malloc.h>
 #include <pci.h>
+#include <reset.h>
 #include <asm/io.h>
 #include <asm/arch/clock.h>
 #include <dm/device-internal.h>
@@ -106,111 +107,42 @@ void s32_serdes_enable_ltssm(void __iomem *dbi)
 	BSET32(UPTR(dbi) + SS_PE0_GEN_CTRL_3, LTSSM_EN);
 }
 
-/**
- * @brief	SERDES Peripheral reset.
- * See Reference Manual for peripheral indices used below.
- */
-static int rgm_get_regs(u32 id, phys_addr_t *prst, phys_addr_t *pstat)
-{
-	if (id <= 17U) {
-		*prst = RGM_PRST(MC_RGM_BASE_ADDR, 0);
-		*pstat = RGM_PSTAT(MC_RGM_BASE_ADDR, 0);
-	} else if ((id >= 64U) && (id <= 68U)) {
-		*prst = RGM_PRST(MC_RGM_BASE_ADDR, 1);
-		*pstat = RGM_PSTAT(MC_RGM_BASE_ADDR, 1);
-	} else if ((id >= 128U) && (id <= 130)) {
-		*prst = RGM_PRST(MC_RGM_BASE_ADDR, 2);
-		*pstat = RGM_PSTAT(MC_RGM_BASE_ADDR, 2);
-	} else if ((id >= 192U) && (id <= 194U)) {
-		*prst = RGM_PRST(MC_RGM_BASE_ADDR, 3);
-		*pstat = RGM_PSTAT(MC_RGM_BASE_ADDR, 3);
-	} else {
-		printf("error: Reset of unknown peripheral");
-		printf(" or domain requested (%d)\n", id);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-/**
- * @brief	Issue peripheral/domain reset
- * @param[in]	pid Peripheral/domain index. See RM.
- */
-int rgm_issue_reset(u32 pid)
+static int s32_serdes_assert_reset(struct s32_serdes *serdes)
 {
-	phys_addr_t prst, pstat;
-	u32 regval = RGM_PERIPH_RST(pid % 32);
-	int retval;
-
-	retval = rgm_get_regs(pid, &prst, &pstat);
-	if (retval)
-		return retval;
-
-	BSET32(prst, regval);
-
-	return wait_read32((void __iomem *)(pstat), regval, regval,
-		PCIE_RESET_COUNT);
-}
-
-/**
- * @brief	Release peripheral/domain reset
- * @param[in]	pid Peripheral/domain index. See RM.
- */
-int rgm_release_reset(u32 pid)
-{
-	phys_addr_t prst, pstat;
-	u32 regval = RGM_PERIPH_RST(pid % 32);
-	int retval;
+	__maybe_unused struct udevice *dev = serdes->bus;
+	int ret;
 
-	retval = rgm_get_regs(pid, &prst, &pstat);
-	if (retval)
-		return retval;
+	ret = reset_assert(serdes->pcie_rst);
+	if (ret) {
+		dev_err(dev, "Failed to assert SerDes reset: %d\n", ret);
+		return ret;
+	}
 
-	BCLR32(prst, regval);
+	ret = reset_assert(serdes->serdes_rst);
+	if (ret) {
+		dev_err(dev, "Failed to assert SerDes reset: %d\n", ret);
+		return ret;
+	}
 
-	return wait_read32((void __iomem *)(pstat), 0, regval,
-		PCIE_RESET_COUNT);
+	return 0;
 }
 
-static int s32_deassert_serdes_reset(struct s32_serdes *pcie)
+static int s32_serdes_deassert_reset(struct s32_serdes *serdes)
 {
-	debug("%s: SerDes%d\n", __func__, pcie->id);
-
-	/* Deassert SerDes reset */
-	if (pcie->id == 0)
-		if (rgm_release_reset(PRST_PCIE_0_SERDES) ||
-				rgm_release_reset(PRST_PCIE_0_FUNC)) {
-			printf("PCIe%d reset failed\n", pcie->id);
-			return -ENODEV;
-		}
-	if (pcie->id == 1)
-		if (rgm_release_reset(PRST_PCIE_1_SERDES) ||
-				rgm_release_reset(PRST_PCIE_1_FUNC)) {
-			printf("PCIe%d reset failed\n", pcie->id);
-			return -ENODEV;
-		}
+	__maybe_unused struct udevice *dev = serdes->bus;
+	int ret;
 
-	return 0;
-}
+	ret = reset_deassert(serdes->pcie_rst);
+	if (ret) {
+		dev_err(dev, "Failed to deassert SerDes reset: %d\n", ret);
+		return ret;
+	}
 
-static bool s32_assert_serdes_reset(struct s32_serdes *pcie)
-{
-	debug("%s: SerDes%d\n", __func__, pcie->id);
-
-	/* Assert SerDes reset */
-	if (pcie->id == 0)
-		if (rgm_issue_reset(PRST_PCIE_0_SERDES) ||
-		    rgm_issue_reset(PRST_PCIE_0_FUNC)) {
-			printf("PCIe%d reset failed\n", pcie->id);
-			return -ENODEV;
-		}
-	if (pcie->id == 1)
-		if (rgm_issue_reset(PRST_PCIE_1_FUNC) ||
-		    rgm_issue_reset(PRST_PCIE_1_SERDES)) {
-			printf("PCIe%d reset failed\n", pcie->id);
-			return -ENODEV;
-		}
+	ret = reset_deassert(serdes->serdes_rst);
+	if (ret) {
+		dev_err(dev, "Failed to deassert SerDes reset: %d\n", ret);
+		return ret;
+	}
 
 	return 0;
 }
@@ -341,6 +273,8 @@ static void s32_serdes_start_mode5(struct s32_serdes *pcie,
 
 static bool s32_serdes_init(struct s32_serdes *pcie)
 {
+	int ret;
+
 	pcie->ss_mode = s32_serdes_get_op_mode_from_hwconfig(pcie->id);
 	if (pcie->ss_mode == SERDES_MODE_INVAL) {
 		printf("ERROR: Invalid opmode config on PCIe%d\n",  pcie->id);
@@ -348,7 +282,9 @@ static bool s32_serdes_init(struct s32_serdes *pcie)
 	}
 
 	/* Reset the Serdes module */
-	s32_assert_serdes_reset(pcie);
+	ret = s32_serdes_assert_reset(pcie);
+	if (ret)
+		return false;
 
 	if (pcie->ss_mode == SERDES_MODE_SGMII_SGMII) {
 		/*	Set pipeP_pclk */
@@ -372,7 +308,9 @@ static bool s32_serdes_init(struct s32_serdes *pcie)
 	}
 
 	/* Deassert SerDes reset */
-	s32_deassert_serdes_reset(pcie);
+	ret = s32_serdes_deassert_reset(pcie);
+	if (ret)
+		return false;
 
 	/* Enable PHY's SRIS mode in PCIe mode*/
 	if (pcie->phy_mode == SRIS)
@@ -485,6 +423,18 @@ static int s32_serdes_get_config_from_device_tree(struct s32_serdes *pcie)
 		return -ENOMEM;
 	}
 
+	pcie->pcie_rst = devm_reset_control_get(dev, "pcie");
+	if (IS_ERR(pcie->pcie_rst)) {
+		dev_err(dev, "Failed to get 'pcie' reset control\n");
+		return PTR_ERR(pcie->pcie_rst);
+	}
+
+	pcie->serdes_rst = devm_reset_control_get(dev, "serdes");
+	if (IS_ERR(pcie->serdes_rst)) {
+		dev_err(dev, "Failed to get 'serdes' reset control\n");
+		return PTR_ERR(pcie->serdes_rst);
+	}
+
 	debug("%s: dbi: 0x%lx (0x%p)\n", __func__, (uintptr_t)res.start,
 	      pcie->dbi);
 
diff --git a/drivers/pci/serdes_s32gen1.h b/drivers/pci/serdes_s32gen1.h
index 514b3e9a97..bd3bce878d 100644
--- a/drivers/pci/serdes_s32gen1.h
+++ b/drivers/pci/serdes_s32gen1.h
@@ -40,20 +40,6 @@
 #define CLKEN_MASK	0x1
 #define CLKEN_OFF	23
 
-/* RGM peripheral reset registers */
-#define RGM_PRST(MC_RGM, per)		(UPTR(MC_RGM) + 0x40 + \
-					((per) * 0x8))
-#define RGM_PSTAT(rgm, per)		(UPTR(rgm) + 0x140 + \
-					 ((per) * 0x8))
-#define RGM_PERIPH_RST(num)		BIT(num)
-
-#define PRST_PCIE_0_SERDES		4
-#define PRST_PCIE_0_FUNC		5
-#define PRST_PCIE_1_SERDES		16
-#define PRST_PCIE_1_FUNC		17
-
-#define MC_RGM_BASE_ADDR		(0x40078000)
-
 enum serdes_link_width {
 	X1 = 0x1,
 	X2 = 0x2
@@ -63,6 +49,7 @@ struct s32_serdes {
 	struct list_head list;
 	struct udevice *bus;
 	void __iomem *dbi;
+	struct reset_ctl *pcie_rst, *serdes_rst;
 	enum serdes_mode ss_mode;
 
 	int id;
@@ -77,9 +64,6 @@ struct s32_serdes {
 int s32_serdes_set_mode(void __iomem *dbi, int id, enum serdes_mode mode);
 enum serdes_mode s32_get_serdes_mode_from_target(void __iomem *dbi, int id);
 
-int rgm_issue_reset(u32 pid);
-int rgm_release_reset(u32 pid);
-
 void s32_serdes_disable_ltssm(void __iomem *dbi);
 void s32_serdes_enable_ltssm(void __iomem *dbi);
 bool s32_pcie_wait_link_up(void __iomem *dbi);
-- 
2.17.1

