From 63c43306367e34daa5b1d87152309c9b3d228080 Mon Sep 17 00:00:00 2001
From: Vladimir Oltean <vladimir.oltean@nxp.com>
Date: Sun, 14 Mar 2021 20:14:48 +0800
Subject: [PATCH 075/102] net: phy: fixed: Be compatible with live OF tree

upstream commit f27bc8afd5536f9("net: phy: fixed: Be compatible with
live OF tree")

On systems that use CONFIG_OF_LIVE, the "ofnode" type is defined
as const struct device_node *np, while on the flat DT systems it
is defined as a long of_offset into gd->fdt_blob.

It is desirable that the fixed PHY driver uses the higher-level
ofnode abstraction instead of parsing gd->fdt_blob directly,
because that enables it to work on live OF systems.

The fixed PHY driver has used a nasty hack since its introduction in
commit db40c1aa1c10 ("drivers/net/phy: add fixed-phy /
fixed-link support"),
which is to pass the long gd->fdt_blob offset inside int phydev->addr
(a value that normally holds the MDIO bus address at which the PHY
responds). Even ignoring the fact that the types were already
mismatched leading to a potential truncation (flat OF offset was
supposed to be a long and not an int), we really cannot extend this
hack any longer, because there's no way an int will hold the other
representation of ofnode, the struct device_node *np.

So we unfortunately need to do the right thing, which is to use the
framework introduced by Grygorii Strashko in
commit eef0b8a930d1 ("net: phy: add ofnode node to struct phy_device").
This will populate phydev->node for the fixed PHY.

Note that phydev->node will not be valid in the probe function, since
that is called synchronously from phy_device_create and we really have
no way of passing the ofnode directly through the phy_device_create API.
So we do what other drivers do too: we move the OF parsing logic from
the .probe to the .config method of the PHY driver. The new function
will be called at phy_config() time.

I do believe I've converted all the possible call paths for creating
a PHY with PHY_FIXED_ID, so there is really no reason to maintain
compatibility with the old logic of retrieving a flat OF tree offset
from phydev->addr. We just pass 0 to phydev->addr now.

Issue: ALB-8357 ALB-9010

Upstream-Status: Pending 

Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
Reviewed-by: Bin Meng <bmeng.cn@gmail.com>
Tested-by: Bin Meng <bmeng.cn@gmail.com>
Message-Id: <20210216224804.3355044-2-olteanv@gmail.com>
[bmeng: keep fixedphy_probe(); update mdio-uclass.c to handle fixed phy]
Signed-off-by: Bin Meng <bmeng.cn@gmail.com>
Reviewed-by: Vladimir Oltean <vladimir.oltean@nxp.com>
Reviewed-by: Priyanka Jain <priyanka.jain@nxp.com>
Signed-off-by: Radu Pirea <radu-nicolae.pirea@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/net/phy/fixed.c | 26 +++++++++++------
 drivers/net/phy/phy.c   | 62 +++++++++++++++++++++++++++++++----------
 net/mdio-uclass.c       |  8 ++++++
 3 files changed, 72 insertions(+), 24 deletions(-)

diff --git a/drivers/net/phy/fixed.c b/drivers/net/phy/fixed.c
index 9d9f746e1d..8d1d1af2c4 100644
--- a/drivers/net/phy/fixed.c
+++ b/drivers/net/phy/fixed.c
@@ -16,13 +16,23 @@ DECLARE_GLOBAL_DATA_PTR;
 
 int fixedphy_probe(struct phy_device *phydev)
 {
+	/* fixed-link phy must not be reset by core phy code */
+	phydev->flags |= PHY_FLAG_BROKEN_RESET;
+
+	return 0;
+}
+
+int fixedphy_config(struct phy_device *phydev)
+{
+	ofnode node = phy_get_ofnode(phydev);
 	struct fixed_link *priv;
-	int ofnode = phydev->addr;
 	u32 val;
 
+	if (!ofnode_valid(node))
+		return -EINVAL;
+
 	/* check for mandatory properties within fixed-link node */
-	val = fdt_getprop_u32_default_node(gd->fdt_blob,
-					   ofnode, 0, "speed", 0);
+	val = ofnode_read_u32_default(node, "speed", 0);
 	if (val != SPEED_10 && val != SPEED_100 && val != SPEED_1000) {
 		printf("ERROR: no/invalid speed given in fixed-link node!");
 		return -EINVAL;
@@ -36,12 +46,9 @@ int fixedphy_probe(struct phy_device *phydev)
 	phydev->priv = priv;
 
 	priv->link_speed = val;
-	priv->duplex = fdtdec_get_bool(gd->fdt_blob, ofnode, "full-duplex");
-	priv->pause = fdtdec_get_bool(gd->fdt_blob, ofnode, "pause");
-	priv->asym_pause = fdtdec_get_bool(gd->fdt_blob, ofnode, "asym-pause");
-
-	/* fixed-link phy must not be reset by core phy code */
-	phydev->flags |= PHY_FLAG_BROKEN_RESET;
+	priv->duplex = ofnode_read_bool(node, "full-duplex");
+	priv->pause = ofnode_read_bool(node, "pause");
+	priv->asym_pause = ofnode_read_bool(node, "asym-pause");
 
 	return 0;
 }
@@ -70,6 +77,7 @@ static struct phy_driver fixedphy_driver = {
 	.name		= "Fixed PHY",
 	.features	= PHY_GBIT_FEATURES | SUPPORTED_MII,
 	.probe		= fixedphy_probe,
+	.config		= fixedphy_config,
 	.startup	= fixedphy_startup,
 	.shutdown	= fixedphy_shutdown,
 };
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index 1f74ad3ce0..5990fb9164 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -668,7 +668,7 @@ static struct phy_device *phy_device_create(struct mii_dev *bus, int addr,
 	dev = malloc(sizeof(*dev));
 	if (!dev) {
 		printf("Failed to allocate PHY device for %s:%d\n",
-		       bus->name, addr);
+		       bus ? bus->name : "NULL MDIO Bus", addr);
 		return NULL;
 	}
 
@@ -696,7 +696,7 @@ static struct phy_device *phy_device_create(struct mii_dev *bus, int addr,
 		return NULL;
 	}
 
-	if (addr >= 0 && addr < PHY_MAX_ADDR)
+	if (bus && addr >= 0 && addr < PHY_MAX_ADDR)
 		bus->phymap[addr] = dev;
 
 	return dev;
@@ -969,6 +969,42 @@ static struct phy_device *phy_connect_gmii2rgmii(struct mii_dev *bus,
 #endif
 
 #ifdef CONFIG_PHY_FIXED
+
+/**
+ * fixed_phy_create() - create an unconnected fixed-link pseudo-PHY device
+ * @node: OF node for the container of the fixed-link node
+ *
+ * Description: Creates a struct phy_device based on a fixed-link of_node
+ * description. Can be used without phy_connect by drivers which do not expose
+ * a UCLASS_ETH udevice.
+ */
+struct phy_device *fixed_phy_create(ofnode node)
+{
+	phy_interface_t interface = PHY_INTERFACE_MODE_NONE;
+	struct phy_device *phydev;
+	const char *if_str;
+	ofnode subnode;
+
+	if_str = ofnode_read_string(node, "phy-mode");
+	if (!if_str) {
+		if_str = ofnode_read_string(node, "phy-interface-type");
+	}
+	if (if_str) {
+		interface = phy_get_interface_by_name(if_str);
+	}
+
+	subnode = ofnode_find_subnode(node, "fixed-link");
+	if (!ofnode_valid(subnode)) {
+		return NULL;
+	}
+
+	phydev = phy_device_create(NULL, 0, PHY_FIXED_ID, false, interface);
+	if (phydev)
+		phydev->node = subnode;
+
+	return phydev;
+}
+
 #ifdef CONFIG_DM_ETH
 static struct phy_device *phy_connect_fixed(struct mii_dev *bus,
 					    struct udevice *dev,
@@ -979,20 +1015,16 @@ static struct phy_device *phy_connect_fixed(struct mii_dev *bus,
 					    phy_interface_t interface)
 #endif
 {
-	struct phy_device *phydev = NULL;
-	int sn;
-	const char *name;
+	ofnode node = dev_ofnode(dev), subnode;
+	struct phy_device *phydev;
 
-	sn = fdt_first_subnode(gd->fdt_blob, dev_of_offset(dev));
-	while (sn > 0) {
-		name = fdt_get_name(gd->fdt_blob, sn, NULL);
-		if (name && strcmp(name, "fixed-link") == 0) {
-			phydev = phy_device_create(bus, sn, PHY_FIXED_ID, false,
-						   interface);
-			break;
-		}
-		sn = fdt_next_subnode(gd->fdt_blob, sn);
-	}
+	subnode = ofnode_find_subnode(node, "fixed-link");
+	if (!ofnode_valid(subnode))
+		return NULL;
+
+	phydev = phy_device_create(bus, 0, PHY_FIXED_ID, false, interface);
+	if (phydev)
+		phydev->node = subnode;
 
 	return phydev;
 }
diff --git a/net/mdio-uclass.c b/net/mdio-uclass.c
index 8e7872155a..e279f74bd7 100644
--- a/net/mdio-uclass.c
+++ b/net/mdio-uclass.c
@@ -136,8 +136,16 @@ static struct phy_device *dm_eth_connect_phy_handle(struct udevice *ethdev,
 	struct udevice *mdiodev;
 	struct phy_device *phy;
 	struct ofnode_phandle_args phandle = {.node = ofnode_null()};
+	ofnode phynode;
 	int i;
 
+	if (CONFIG_IS_ENABLED(PHY_FIXED) &&
+	    ofnode_phy_is_fixed_link(dev_ofnode(ethdev), &phynode)) {
+		phy = phy_connect(NULL, 0, ethdev, interface);
+		phandle.node = phynode;
+		goto out;
+	}
+
 	for (i = 0; i < PHY_HANDLE_STR_CNT; i++)
 		if (!dev_read_phandle_with_args(ethdev, phy_handle_str[i], NULL,
 						0, 0, &phandle))
-- 
2.17.1

