From 6882ab87e1f74af1d33aca07233171755acb6500 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Thu, 30 Jun 2022 07:17:18 +0300
Subject: [PATCH 005/102] s32cc: Update SerDes and PCIe nodes based on hwconfig

This applies the same mechanism of updating the device tree nodes
based on 'hwconfig' for Linux and U-Boot internal device tree.

In case of Linux fixups it will operate using fdtdec API and on
U-Boot case it will use ofnode.

Issue: ALB-8357
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 arch/arm/mach-s32/Kconfig                     |   2 +
 arch/arm/mach-s32/include/s32-cc/pcie.h       |  11 +
 .../mach-s32/include/s32-cc/serdes_hwconfig.h |   2 +
 arch/arm/mach-s32/s32-cc/Makefile             |   1 +
 arch/arm/mach-s32/s32-cc/fdt.c                | 415 +---------
 arch/arm/mach-s32/s32-cc/hwconfig_fixups.c    | 715 ++++++++++++++++++
 arch/arm/mach-s32/s32-cc/soc.c                |  15 +-
 board/nxp/s32-cc/board_common.c               |   2 -
 drivers/pci/pcie_s32gen1.c                    |   1 +
 drivers/pci/serdes_s32gen1.h                  |   2 -
 10 files changed, 752 insertions(+), 414 deletions(-)
 create mode 100644 arch/arm/mach-s32/include/s32-cc/pcie.h
 create mode 100644 arch/arm/mach-s32/s32-cc/hwconfig_fixups.c

diff --git a/arch/arm/mach-s32/Kconfig b/arch/arm/mach-s32/Kconfig
index 18e1401513..338db238ee 100644
--- a/arch/arm/mach-s32/Kconfig
+++ b/arch/arm/mach-s32/Kconfig
@@ -51,6 +51,7 @@ config NXP_S32CC
 	select CLK
 	select CLK_SCMI
 	select CPU
+	select DM_DEVICE_REMOVE
 	select DM_GPIO
 	select DM_MMC
 	select DM_MTD
@@ -63,6 +64,7 @@ config NXP_S32CC
 	select MMC_HS400_SUPPORT
 	select MTD
 	select OF_CONTROL
+	select OF_LIVE
 	select OF_SEPARATE
 	select OF_SYSTEM_SETUP
 	select PINCTRL
diff --git a/arch/arm/mach-s32/include/s32-cc/pcie.h b/arch/arm/mach-s32/include/s32-cc/pcie.h
new file mode 100644
index 0000000000..2b2012f9f7
--- /dev/null
+++ b/arch/arm/mach-s32/include/s32-cc/pcie.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2022 NXP
+ */
+#ifndef S32CC_PCIE_H
+#define S32CC_PCIE_H
+
+void show_pcie_devices(void);
+int initr_pci(void);
+
+#endif
diff --git a/arch/arm/mach-s32/include/s32-cc/serdes_hwconfig.h b/arch/arm/mach-s32/include/s32-cc/serdes_hwconfig.h
index e4ea66450b..0e366024db 100644
--- a/arch/arm/mach-s32/include/s32-cc/serdes_hwconfig.h
+++ b/arch/arm/mach-s32/include/s32-cc/serdes_hwconfig.h
@@ -120,5 +120,7 @@ enum serdes_xpcs_mode s32_serdes_get_xpcs_cfg_from_hwconfig(int id);
 enum serdes_mode s32_serdes_get_op_mode_from_hwconfig(int id);
 enum serdes_phy_mode s32_serdes_get_phy_mode_from_hwconfig(int id);
 bool is_pcie_enabled_in_hwconfig(int id);
+int apply_dm_hwconfig_fixups(void);
+int apply_fdt_hwconfig_fixups(void *blob);
 
 #endif
diff --git a/arch/arm/mach-s32/s32-cc/Makefile b/arch/arm/mach-s32/s32-cc/Makefile
index 586c3c830b..e7f8ad2115 100644
--- a/arch/arm/mach-s32/s32-cc/Makefile
+++ b/arch/arm/mach-s32/s32-cc/Makefile
@@ -8,6 +8,7 @@ ccflags-y += -I./board/nxp/common/
 ccflags-y += -I./board/nxp/s32-cc/include/
 ccflags-y += -I./drivers/net/s32/
 
+obj-y				+= hwconfig_fixups.o
 obj-y				+= nvmem.o
 obj-y				+= scmi_clk_dump.o
 obj-y				+= scmi_reset_agent.o
diff --git a/arch/arm/mach-s32/s32-cc/fdt.c b/arch/arm/mach-s32/s32-cc/fdt.c
index 1d9b29bb10..20dcc655f8 100644
--- a/arch/arm/mach-s32/s32-cc/fdt.c
+++ b/arch/arm/mach-s32/s32-cc/fdt.c
@@ -21,23 +21,6 @@
 #include <dt-bindings/nvmem/s32cc-siul2-nvmem.h>
 #include <dt-bindings/phy/phy.h>
 
-#define PCIE_ALIAS_FMT		"pcie%d"
-#define PCIE_ALIAS_SIZE		sizeof(PCIE_ALIAS_FMT)
-
-#define SERDES_ALIAS_FMT	"serdes%d"
-#define SERDES_ALIAS_SIZE	sizeof(SERDES_ALIAS_FMT)
-
-#define SERDES_EXT_PATH_FMT		"/clocks/serdes_%d_ext"
-#define SERDES_EXT_PATH_FMT_SIZE	sizeof(SERDES_EXT_PATH_FMT)
-/* Add some space for SerDes ID */
-#define SERDES_EXT_PATH_SIZE		(SERDES_EXT_PATH_FMT_SIZE + 2)
-
-#define SERDES_EXT_CLK			"ext"
-#define SERDES_EXT_SIZE			sizeof(SERDES_EXT_CLK)
-
-#define SERDES_LINE_NAME_FMT	"serdes_lane%d"
-#define SERDES_LINE_NAME_LEN	sizeof(SERDES_LINE_NAME_FMT)
-
 #define S32_DDR_LIMIT_VAR "ddr_limitX"
 
 static int get_core_id(u32 core_mpidr, u32 max_cores_per_cluster)
@@ -302,407 +285,17 @@ static int ft_fixup_atf(void *new_blob)
 	return ret;
 }
 
-#ifdef CONFIG_PCIE_S32GEN1
-static int fdt_alias2node(void *blob, const char *alias_fmt, int alias_id)
-{
-	const char *alias_path;
-	char alias_name[strlen(alias_fmt) + 1];
-	int nodeoff;
-
-	sprintf(alias_name, alias_fmt, alias_id);
-
-	alias_path = fdt_get_alias(blob, alias_name);
-	if (!alias_path) {
-		pr_err("Failed to get '%s' alias\n", alias_name);
-		return -EINVAL;
-	}
-
-	nodeoff = fdt_path_offset(blob, alias_path);
-	if (nodeoff < 0)
-		pr_err("Failed to get offset of '%s' node\n", alias_path);
-
-	return nodeoff;
-}
-
-static int set_pcie_mode(void *blob, int nodeoff, int id)
+int ft_system_setup(void *blob, bd_t *bd)
 {
 	int ret;
-	const char *compatible;
-	enum serdes_dev_type pcie_mode;
-
-	pcie_mode = s32_serdes_get_mode_from_hwconfig(id);
-	if (pcie_mode & PCIE_EP)
-		compatible = "nxp,s32cc-pcie-ep";
-	else
-		compatible = "nxp,s32cc-pcie";
-
-	ret = fdt_setprop(blob, nodeoff, "compatible", compatible,
-			  strlen(compatible) + 1);
-	if (ret) {
-		pr_err("Failed to set PCIE compatible: %s\n",
-		       fdt_strerror(ret));
-		return ret;
-	}
-
-	return 0;
-}
-
-static int set_pcie_phy_mode(void *blob, int nodeoff, int id)
-{
-	int ret = 0;
-	char mode[10] = "crns";
-	enum serdes_phy_mode phy_mode;
-
-	phy_mode = s32_serdes_get_phy_mode_from_hwconfig(id);
-	if (phy_mode == PHY_MODE_INVALID) {
-		pr_err("Invalid PCIe%d PHY mode", id);
-		return -EINVAL;
-	}
-
-	switch (phy_mode) {
-	case CRNS:
-		break;
-	case CRSS:
-		strcpy(mode, "crss");
-		break;
-	case SRIS:
-		strcpy(mode, "sris");
-		break;
-	default:
-		pr_err("PCIe PHY mode not supported\n");
-		return -EINVAL;
-	}
-
-	ret = fdt_setprop_string(blob, nodeoff, "nxp,phy-mode", mode);
-	if (ret)
-		pr_err("Failed to set 'nxp,phy-mode'\n");
-
-	return ret;
-}
-
-static int add_serdes_lines(void *blob, int id, int lanes, uint32_t phandle)
-{
-	char serdes_lane[SERDES_LINE_NAME_LEN];
-	int i, ret, nodeoff;
-
-	nodeoff = fdt_alias2node(blob, PCIE_ALIAS_FMT, id);
-	if (nodeoff < 0)
-		return nodeoff;
-
-	ret = fdt_setprop_u32(blob, nodeoff, "num-lanes", lanes);
-	if (ret)
-		pr_err("Failed to set 'num-lanes'\n");
-
-	for (i = 0; i < lanes; i++) {
-		sprintf(serdes_lane, SERDES_LINE_NAME_FMT, i);
-		ret = fdt_appendprop_string(blob, nodeoff, "phy-names",
-					    serdes_lane);
-		if (ret) {
-			pr_err("Failed to append serdes lane to 'phy-names': %s\n",
-			       fdt_strerror(ret));
-			return ret;
-		}
-
-		ret = fdt_appendprop_u32(blob, nodeoff, "phys", phandle);
-		if (ret) {
-			pr_err("Failed to append serdes phandle to 'phys': %s\n",
-			       fdt_strerror(ret));
-			return ret;
-		}
-
-		ret = fdt_appendprop_u32(blob, nodeoff, "phys", PHY_TYPE_PCIE);
-		if (ret) {
-			pr_err("Failed to append PHY type to 'phys': %s\n",
-			       fdt_strerror(ret));
-			return ret;
-		}
-
-		ret = fdt_appendprop_u32(blob, nodeoff, "phys", id);
-		if (ret) {
-			pr_err("Failed to append PCIE instance to 'phys': %s\n",
-			       fdt_strerror(ret));
-			return ret;
-		}
-
-		ret = fdt_appendprop_u32(blob, nodeoff, "phys", i);
-		if (ret) {
-			pr_err("Failed to append SerDes line to 'phys': %s\n",
-			       fdt_strerror(ret));
-			return ret;
-		}
-	}
-
-	return 0;
-}
-
-static int set_serdes_lines(void *blob, int id)
-{
-	enum serdes_mode mode;
-	u32 phandle;
-	int serdes_off, ret, lanes = 0;
-
-	mode = s32_serdes_get_op_mode_from_hwconfig(id);
-	if (mode == SERDES_MODE_PCIE_PCIE)
-		lanes = 2;
-
-	if (mode == SERDES_MODE_PCIE_SGMII0 || mode == SERDES_MODE_PCIE_SGMII1)
-		lanes = 1;
-
-	if (!lanes) {
-		pr_err("Invalid PCIe%d lanes config\n", id);
-		return -EINVAL;
-	}
-
-	serdes_off = fdt_alias2node(blob, SERDES_ALIAS_FMT, id);
-	if (serdes_off < 0)
-		return serdes_off;
-
-	phandle = fdt_get_phandle(blob, serdes_off);
-	if (!phandle) {
-		ret = fdt_generate_phandle(blob, &phandle);
-		if (ret < 0) {
-			pr_err("Failed to generate a new phandle for %s%d\n",
-			       SERDES_ALIAS_FMT, id);
-			return ret;
-		}
-
-		ret = fdtdec_set_phandle(blob, serdes_off, phandle);
-		if (ret < 0) {
-			pr_err("Failed to set phandle for node: %s%d\n",
-			       SERDES_ALIAS_FMT, id);
-			return ret;
-		}
-	}
-
-	ret = add_serdes_lines(blob, id, lanes, phandle);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static int prepare_pcie_node(void *blob, int id)
-{
-	int ret, nodeoff;
-
-	nodeoff = fdt_alias2node(blob, PCIE_ALIAS_FMT, id);
-	if (nodeoff < 0)
-		return nodeoff;
-
-	if (is_pcie_enabled_in_hwconfig(id)) {
-		ret = fdt_status_okay(blob, nodeoff);
-		if (ret) {
-			pr_err("Failed to enable PCIe%d\n", id);
-			return ret;
-		}
-	} else {
-		ret = fdt_status_disabled(blob, nodeoff);
-		if (ret) {
-			pr_err("Failed to disable PCIe%d\n", id);
-			return ret;
-		}
-
-		/* Skip rest of the configuration if not enabled */
-		return 0;
-	}
-
-	ret = set_pcie_mode(blob, nodeoff, id);
-	if (ret)
-		return ret;
-
-	ret = set_pcie_phy_mode(blob, nodeoff, id);
-	if (ret)
-		return ret;
-
-	ret = set_serdes_lines(blob, id);
-	if (ret)
-		return ret;
-
-	return ret;
-}
-
-static int rename_ext_clk(void *blob, int nodeoff, int prop_pos)
-{
-	int i, ret, length, str_pos;
-	const char *list;
-	char *propval;
-
-	list = fdt_getprop(blob, nodeoff, "clock-names", &length);
-	if (!list)
-		return -EINVAL;
-
-	propval = malloc(length);
-	memcpy(propval, list, length);
-
-	/* Jump over elements before 'ext' clock */
-	for (str_pos = 0, i = 0; i < prop_pos; i++)
-		str_pos += strlen(&propval[str_pos]) + 1;
-
-	propval[str_pos] = toupper(propval[str_pos]);
-
-	ret = fdt_setprop(blob, nodeoff, "clock-names", propval,
-			  length);
-	if (ret) {
-		pr_err("Failed to rename 'ext' SerDes clock: %s\n",
-		       fdt_strerror(ret));
-		return ret;
-	}
-
-	free(propval);
-
-	return 0;
-}
-
-static int get_ext_clk_phandle(void *blob, int id, uint32_t *phandle)
-{
-	enum serdes_clock_fmhz mhz;
-	char ext_clk_path[SERDES_EXT_PATH_SIZE];
-	int clk_mhz, ext_off, ret;
-
-	mhz = s32_serdes_get_clock_fmhz_from_hwconfig(id);
-	if (mhz == CLK_100MHZ)
-		clk_mhz = 100;
-	else
-		clk_mhz = 125;
-
-	sprintf(ext_clk_path, SERDES_EXT_PATH_FMT, clk_mhz);
-
-	ext_off = fdt_path_offset(blob, ext_clk_path);
-	if (ext_off < 0) {
-		pr_err("Failed to get offset of '%s' node\n", ext_clk_path);
-		return ext_off;
-	}
-
-	*phandle = fdt_get_phandle(blob, ext_off);
-	if (!*phandle) {
-		ret = fdt_generate_phandle(blob, phandle);
-		if (ret < 0) {
-			pr_err("Failed to generate a new phandle for %s\n",
-			       ext_clk_path);
-			return ret;
-		}
-
-		ret = fdtdec_set_phandle(blob, ext_off, *phandle);
-		if (ret < 0) {
-			pr_err("Failed to set phandle for node: %s\n",
-			       ext_clk_path);
-			return ret;
-		}
-	}
-
-	return 0;
-}
-
-static int add_ext_clk(void *blob, int id)
-{
-	u32 phandle;
-	int ret, nodeoff;
-
-	ret = get_ext_clk_phandle(blob, id, &phandle);
-	if (ret)
-		return ret;
-
-	nodeoff = fdt_alias2node(blob, SERDES_ALIAS_FMT, id);
-	if (nodeoff < 0)
-		return nodeoff;
-
-	ret = fdt_appendprop_string(blob, nodeoff, "clock-names",
-				    SERDES_EXT_CLK);
-	if (ret) {
-		pr_err("Failed to append ext clock to 'clock-names'\n");
-		return ret;
-	}
-
-	ret = fdt_appendprop_u32(blob, nodeoff, "clocks", phandle);
-	if (ret) {
-		pr_err("Failed to append ext clock to 'clock-names'\n");
-		return ret;
-	}
-
-	return ret;
-}
-
-static int set_serdes_clk(void *blob, int id)
-{
-	enum serdes_clock clk = s32_serdes_get_clock_from_hwconfig(id);
-	int nodeoff, prop_pos;
-
-	nodeoff = fdt_alias2node(blob, SERDES_ALIAS_FMT, id);
-	if (nodeoff < 0)
-		return nodeoff;
-
-	prop_pos = fdt_stringlist_search(blob, nodeoff, "clock-names",
-					 SERDES_EXT_CLK);
-
-	if (clk == CLK_INT && prop_pos >= 0)
-		return rename_ext_clk(blob, nodeoff, prop_pos);
-
-	if (clk == CLK_EXT && prop_pos <= 0)
-		return add_ext_clk(blob, id);
-
-	return 0;
-}
-
-static int set_serdes_mode(void *blob, int id)
-{
-	int nodeoff, ret;
-	enum serdes_mode mode;
-
-	mode = s32_serdes_get_op_mode_from_hwconfig(id);
-	if (mode == SERDES_MODE_INVAL) {
-		pr_err("Invalid SerDes%d mode\n", id);
-		return -EINVAL;
-	}
-
-	nodeoff = fdt_alias2node(blob, SERDES_ALIAS_FMT, id);
-	if (nodeoff < 0)
-		return nodeoff;
-
-	ret = fdt_setprop_u32(blob, nodeoff, "fsl,sys-mode", mode);
-	if (ret)
-		pr_err("Failed to set 'fsl,sys-mode'\n");
-
-	return ret;
-}
-
-static void ft_fixup_serdes(void *blob)
-{
-	int ret, id;
 
 	/* Add some space for the following changes */
 	ret = fdt_increase_size(blob, 512);
 	if (ret < 0) {
 		pr_err("Could not increase size of device tree: %s\n",
 		       fdt_strerror(ret));
-		return;
-	}
-
-	for (id = 0; id <= 1; id++) {
-		ret = prepare_pcie_node(blob, id);
-		if (ret)
-			pr_err("Failed to set mode for PCIe%d\n", id);
-
-		ret = set_serdes_clk(blob, id);
-		if (ret)
-			pr_err("Failed to set the clock for SerDes%d\n", id);
-
-		ret = set_serdes_mode(blob, id);
-		if (ret)
-			pr_err("Failed to set mode for SerDes%d\n", id);
+		return ret;
 	}
-}
-#endif
-
-void ft_cpu_setup(void *blob, bd_t *bd)
-{
-#ifdef CONFIG_PCIE_S32GEN1
-	ft_fixup_serdes(blob);
-#endif
-}
-
-int ft_system_setup(void *blob, bd_t *bd)
-{
-	int ret;
 
 	/*
 	 * Skip these fixups when reusing U-Boot dtb for Linux
@@ -725,6 +318,10 @@ int ft_system_setup(void *blob, bd_t *bd)
 		goto exit;
 
 	ret = ft_fixup_atf(blob);
+	if (ret)
+		goto exit;
+
+	ret = apply_fdt_hwconfig_fixups(blob);
 
 exit:
 	return ret;
diff --git a/arch/arm/mach-s32/s32-cc/hwconfig_fixups.c b/arch/arm/mach-s32/s32-cc/hwconfig_fixups.c
new file mode 100644
index 0000000000..cf57ff47ef
--- /dev/null
+++ b/arch/arm/mach-s32/s32-cc/hwconfig_fixups.c
@@ -0,0 +1,715 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2022 NXP
+ */
+#include <common.h>
+#include <malloc.h>
+#include <dm/device.h>
+#include <dm/of_access.h>
+#include <dm/ofnode.h>
+#include <linux/ctype.h>
+#include <s32-cc/serdes_hwconfig.h>
+#include <dt-bindings/phy/phy.h>
+
+#define PCIE_ALIAS_FMT			"pci%d"
+#define PCIE_ALIAS_SIZE			sizeof(PCIE_ALIAS_FMT)
+
+#define SERDES_ALIAS_FMT		"serdes%d"
+#define SERDES_ALIAS_SIZE		sizeof(SERDES_ALIAS_FMT)
+
+#define SERDES_EXT_PATH_FMT		"/clocks/serdes_%d_ext"
+#define SERDES_EXT_PATH_FMT_SIZE	sizeof(SERDES_EXT_PATH_FMT)
+/* Add some space for SerDes ID */
+#define SERDES_EXT_PATH_SIZE		(SERDES_EXT_PATH_FMT_SIZE + 2)
+
+#define SERDES_EXT_CLK			"ext"
+#define SERDES_EXT_SIZE			sizeof(SERDES_EXT_CLK)
+
+#define SERDES_LINE_NAME_FMT		"serdes_lane%d"
+#define SERDES_LINE_NAME_LEN		sizeof(SERDES_LINE_NAME_FMT)
+
+#define MAX_PATH_SIZE			100
+
+struct dts_node {
+	union {
+		struct {
+			void *blob;
+			int off;
+		};
+		ofnode node;
+	};
+	/* Selects between external device tree and internal ofnode */
+	bool fdt;
+};
+
+static int fdt_alias2node(void *blob, const char *alias_fmt, int alias_id)
+{
+	const char *alias_path;
+	char alias_name[MAX_PATH_SIZE];
+	int nodeoff;
+
+	sprintf(alias_name, alias_fmt, alias_id);
+
+	alias_path = fdt_get_alias(blob, alias_name);
+	if (!alias_path) {
+		pr_err("Failed to get '%s' alias\n", alias_name);
+		return -EINVAL;
+	}
+
+	nodeoff = fdt_path_offset(blob, alias_path);
+	if (nodeoff < 0)
+		pr_err("Failed to get offset of '%s' node\n", alias_path);
+
+	return nodeoff;
+}
+
+static ofnode ofnode_by_alias(const char *alias_fmt, u32 alias_id)
+{
+	char alias_name[MAX_PATH_SIZE];
+
+	sprintf(alias_name, alias_fmt, alias_id);
+
+	return ofnode_path(alias_name);
+}
+
+static unsigned int get_max_phandle(void)
+{
+	struct device_node *np;
+	unsigned int phandle = 0;
+
+	for_each_of_allnodes(np) {
+		phandle = max(np->phandle, phandle);
+	}
+
+	return phandle;
+}
+
+static int ofnode_write_prop_u32(ofnode node, const char *prop, u32 val)
+{
+	__be32 *prop_val = malloc(sizeof(*prop_val));
+
+	if (!prop_val)
+		return -ENOMEM;
+
+	*prop_val = cpu_to_be32p(&val);
+	return ofnode_write_prop(node, prop, sizeof(*prop_val), prop_val);
+}
+
+static int ofnode_append_prop(ofnode node, const char *prop,
+			      int len, const void *val)
+{
+	const void *old_val;
+	void *new_val;
+	int old_len;
+
+	old_val = ofnode_get_property(node, prop, &old_len);
+	/* New property */
+	if (!old_val) {
+		new_val = malloc(len);
+		if (!new_val)
+			return -ENOMEM;
+
+		memcpy(new_val, val, len);
+		return ofnode_write_prop(node, prop, len, new_val);
+	}
+
+	new_val = malloc(old_len + len);
+	if (!new_val)
+		return -ENOMEM;
+
+	memcpy(new_val, old_val, old_len);
+	memcpy(new_val + old_len, val, len);
+
+	return ofnode_write_prop(node, prop, old_len + len, new_val);
+}
+
+static int ofnode_append_prop_u32(ofnode node, const char *prop,
+				  u32 val)
+{
+	__be32 be32val = cpu_to_be32p(&val);
+
+	return ofnode_append_prop(node, prop, sizeof(be32val), &be32val);
+}
+
+static int ofnode_append_prop_str(ofnode node, const char *prop,
+				  const char *val)
+{
+	return ofnode_append_prop(node, prop, strlen(val) + 1, val);
+}
+
+static unsigned int ofnode_create_phandle(ofnode node)
+{
+	struct device_node *dn = (struct device_node *)ofnode_to_np(node);
+	u32 phandle;
+	int ret;
+
+	if (!dn)
+		return 0;
+
+	phandle = dn->phandle;
+	if (!phandle) {
+		phandle = get_max_phandle();
+		phandle++;
+
+		ret = ofnode_write_prop_u32(node, "phandle", phandle);
+		if (ret)
+			return 0;
+
+		dn->phandle = phandle;
+	}
+
+	return phandle;
+}
+
+static int enable_ofnode_device(ofnode node)
+{
+	int ret;
+	char buf[MAX_PATH_SIZE];
+
+	ret = ofnode_get_path(node, &buf[0], ARRAY_SIZE(buf));
+	if (ret) {
+		pr_err("Failed to get the path of the node '%s'\n",
+		       ofnode_get_name(node));
+		return ret;
+	}
+
+	/*
+	 * Unbind to make sure the new compatible (if the case) has effect.
+	 * Otherwise the driver will be probed using the original settings
+	 * instead of using the updated version.
+	 *
+	 * Unbinding might fail if the node is already disabled
+	 */
+	dev_disable_by_path(buf);
+
+	ret = dev_enable_by_path(buf);
+	if (ret) {
+		pr_err("Failed to disable '%s'\n", buf);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int disable_ofnode_device(ofnode node)
+{
+	int ret;
+	char buf[MAX_PATH_SIZE];
+
+	ret = ofnode_get_path(node, &buf[0], ARRAY_SIZE(buf));
+	if (ret) {
+		pr_err("Failed to get the path of the node '%s'\n",
+		       ofnode_get_name(node));
+		return ret;
+	}
+
+	/* Unbinding might fail if the node is already disabled */
+	dev_disable_by_path(buf);
+
+	return 0;
+}
+
+static int node_by_alias(struct dts_node *root, struct dts_node *node,
+			 const char *alias_fmt, u32 alias_id)
+{
+	*node = *root;
+
+	if (root->fdt) {
+		node->blob = root->blob;
+		node->off = fdt_alias2node(node->blob, alias_fmt,
+					   alias_id);
+		if (node->off < 0)
+			return node->off;
+
+		return 0;
+	}
+
+	node->node = ofnode_by_alias(alias_fmt, alias_id);
+	if (!ofnode_valid(node->node))
+		return -ENOMEM;
+
+	return 0;
+}
+
+static int enable_node(struct dts_node *node)
+{
+	if (node->fdt)
+		return fdt_status_okay(node->blob, node->off);
+
+	return enable_ofnode_device(node->node);
+}
+
+static int disable_node(struct dts_node *node)
+{
+	if (node->fdt)
+		return fdt_status_disabled(node->blob, node->off);
+
+	return disable_ofnode_device(node->node);
+}
+
+static int node_set_prop(struct dts_node *node, const char *prop, void *val,
+			 int len)
+{
+	if (node->fdt)
+		return fdt_setprop(node->blob, node->off, prop, val, len);
+
+	return ofnode_write_prop(node->node, prop, len, val);
+}
+
+static int node_set_prop_str(struct dts_node *node, const char *prop,
+			     const char *val)
+{
+	if (node->fdt)
+		return fdt_setprop_string(node->blob, node->off, prop, val);
+
+	return ofnode_write_string(node->node, prop, val);
+}
+
+static int node_set_prop_u32(struct dts_node *node, const char *prop,
+			     u32 val)
+{
+	if (node->fdt)
+		return fdt_setprop_u32(node->blob, node->off, prop, val);
+
+	return ofnode_write_prop_u32(node->node, prop, val);
+}
+
+static int node_append_prop_str(struct dts_node *node, const char *prop,
+				const char *val)
+{
+	if (node->fdt)
+		return fdt_appendprop_string(node->blob, node->off, prop, val);
+
+	return ofnode_append_prop_str(node->node, prop, val);
+}
+
+static int node_append_prop_u32(struct dts_node *node, const char *prop,
+				u32 val)
+{
+	if (node->fdt)
+		return fdt_appendprop_u32(node->blob, node->off, prop, val);
+
+	return ofnode_append_prop_u32(node->node, prop, val);
+}
+
+static unsigned int node_create_phandle(struct dts_node *node)
+{
+	if (node->fdt)
+		return fdt_create_phandle(node->blob, node->off);
+
+	return ofnode_create_phandle(node->node);
+}
+
+static int node_stringlist_search(struct dts_node *node,
+				  const char *property, const char *string)
+{
+	if (node->fdt)
+		return fdt_stringlist_search(node->blob, node->off, property,
+					     string);
+
+	return ofnode_stringlist_search(node->node, property, string);
+}
+
+static const void *node_get_prop(struct dts_node *node, const char *prop,
+				 int *len)
+{
+	if (node->fdt)
+		return fdt_getprop(node->blob, node->off, prop, len);
+
+	return ofnode_get_property(node->node, prop, len);
+}
+
+static int node_by_path(struct dts_node *root, struct dts_node *node,
+			const char *path)
+{
+	*node = *root;
+
+	if (node->fdt) {
+		node->off = fdt_path_offset(root->blob, path);
+		if (node->off < 0)
+			return node->off;
+		return 0;
+	}
+
+	node->node = ofnode_path(path);
+	if (!ofnode_valid(node->node))
+		return -EINVAL;
+
+	return 0;
+}
+
+static int set_pcie_mode(struct dts_node *node, int id)
+{
+	int ret;
+	char *compatible;
+	enum serdes_dev_type pcie_mode;
+
+	pcie_mode = s32_serdes_get_mode_from_hwconfig(id);
+	if (pcie_mode & PCIE_EP)
+		compatible = "nxp,s32cc-pcie-ep";
+	else
+		compatible = "nxp,s32cc-pcie";
+
+	ret = node_set_prop_str(node, "compatible", compatible);
+	if (ret) {
+		pr_err("Failed to set PCIE compatible: %s\n",
+		       fdt_strerror(ret));
+		return ret;
+	}
+
+	return 0;
+}
+
+static int set_pcie_phy_mode(struct dts_node *node, int id)
+{
+	int ret = 0;
+	const char *mode;
+	enum serdes_phy_mode phy_mode;
+
+	phy_mode = s32_serdes_get_phy_mode_from_hwconfig(id);
+	if (phy_mode == PHY_MODE_INVALID) {
+		pr_err("Invalid PCIe%d PHY mode", id);
+		return -EINVAL;
+	}
+
+	switch (phy_mode) {
+	case CRNS:
+		mode = "crns";
+		break;
+	case CRSS:
+		mode = "crss";
+		break;
+	case SRIS:
+		mode = "sris";
+		break;
+	default:
+		pr_err("PCIe PHY mode not supported\n");
+		return -EINVAL;
+	}
+
+	ret = node_set_prop_str(node, "nxp,phy-mode", mode);
+	if (ret)
+		pr_err("Failed to set 'nxp,phy-mode'\n");
+
+	return ret;
+}
+
+static int add_serdes_lines(struct dts_node *root, int id, int lanes,
+			    u32 phandle)
+{
+	char serdes_lane[SERDES_LINE_NAME_LEN];
+	struct dts_node node;
+	int i, ret;
+
+	ret = node_by_alias(root, &node, PCIE_ALIAS_FMT, id);
+	if (ret)
+		return ret;
+
+	ret = node_set_prop_u32(&node, "num-lanes", lanes);
+	if (ret) {
+		pr_err("Failed to set 'num-lanes'\n");
+		return ret;
+	}
+
+	for (i = 0; i < lanes; i++) {
+		sprintf(serdes_lane, SERDES_LINE_NAME_FMT, i);
+		ret = node_append_prop_str(&node, "phy-names", serdes_lane);
+		if (ret) {
+			pr_err("Failed to append serdes lane to 'phy-names': %s\n",
+			       fdt_strerror(ret));
+			return ret;
+		}
+
+		ret = node_append_prop_u32(&node, "phys", phandle);
+		if (ret) {
+			pr_err("Failed to append serdes phandle to 'phys': %s\n",
+			       fdt_strerror(ret));
+			return ret;
+		}
+
+		ret = node_append_prop_u32(&node, "phys", PHY_TYPE_PCIE);
+		if (ret) {
+			pr_err("Failed to append PHY type to 'phys': %s\n",
+			       fdt_strerror(ret));
+			return ret;
+		}
+
+		ret = node_append_prop_u32(&node, "phys", id);
+		if (ret) {
+			pr_err("Failed to append PCIE instance to 'phys': %s\n",
+			       fdt_strerror(ret));
+			return ret;
+		}
+
+		ret = node_append_prop_u32(&node, "phys", i);
+		if (ret) {
+			pr_err("Failed to append SerDes line to 'phys': %s\n",
+			       fdt_strerror(ret));
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int set_serdes_lines(struct dts_node *node, int id)
+{
+	enum serdes_mode mode;
+	u32 phandle;
+	int ret, lanes = 0;
+	struct dts_node serdes, root = *node;
+
+	mode = s32_serdes_get_op_mode_from_hwconfig(id);
+	if (mode == SERDES_MODE_PCIE_PCIE)
+		lanes = 2;
+
+	if (mode == SERDES_MODE_PCIE_SGMII0 || mode == SERDES_MODE_PCIE_SGMII1)
+		lanes = 1;
+
+	if (!lanes) {
+		pr_err("Invalid PCIe%d lanes config\n", id);
+		return -EINVAL;
+	}
+
+	ret = node_by_alias(&root, &serdes, SERDES_ALIAS_FMT, id);
+	if (ret) {
+		pr_err("Failed to get 'serdes%u' alias\n", id);
+		return ret;
+	}
+
+	phandle = node_create_phandle(&serdes);
+	if (!phandle) {
+		pr_err("Failed to create phandle for %s%d\n",
+		       SERDES_ALIAS_FMT, id);
+		return ret;
+	}
+
+	ret = add_serdes_lines(&root, id, lanes, phandle);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int prepare_pcie_node(struct dts_node *root, int id)
+{
+	int ret;
+	struct dts_node node;
+
+	ret = node_by_alias(root, &node, PCIE_ALIAS_FMT, id);
+	if (ret) {
+		pr_err("Failed to get 'pcie%u' alias\n", id);
+		return ret;
+	}
+
+	if (!is_pcie_enabled_in_hwconfig(id)) {
+		ret = disable_node(&node);
+		if (ret) {
+			pr_err("Failed to disable PCIe%d\n", id);
+			return ret;
+		}
+
+		/* Skip rest of the configuration if not enabled */
+		return 0;
+	}
+
+	ret = set_pcie_mode(&node, id);
+	if (ret)
+		return ret;
+
+	ret = set_pcie_phy_mode(&node, id);
+	if (ret)
+		return ret;
+
+	ret = set_serdes_lines(&node, id);
+	if (ret)
+		return ret;
+
+	ret = enable_node(&node);
+	if (ret) {
+		pr_err("Failed to enable PCIe%d\n", id);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int rename_ext_clk(struct dts_node *node, int prop_pos)
+{
+	int i, ret, length, str_pos;
+	const char *list;
+	char *propval;
+
+	list = node_get_prop(node, "clock-names", &length);
+	if (!list)
+		return -EINVAL;
+
+	propval = malloc(length);
+	if (!propval)
+		return -ENOMEM;
+
+	memcpy(propval, list, length);
+
+	/* Jump over elements before 'ext' clock */
+	for (str_pos = 0, i = 0; i < prop_pos; i++)
+		str_pos += strlen(&propval[str_pos]) + 1;
+
+	propval[str_pos] = toupper(propval[str_pos]);
+
+	ret = node_set_prop(node, "clock-names", propval, length);
+	if (ret) {
+		pr_err("Failed to rename 'ext' SerDes clock: %s\n",
+		       fdt_strerror(ret));
+		return ret;
+	}
+
+	return 0;
+}
+
+static int get_ext_clk_phandle(struct dts_node *root, int id, uint32_t *phandle)
+{
+	enum serdes_clock_fmhz mhz;
+	char ext_clk_path[SERDES_EXT_PATH_SIZE];
+	int clk_mhz, ret;
+	struct dts_node node;
+
+	mhz = s32_serdes_get_clock_fmhz_from_hwconfig(id);
+	if (mhz == CLK_100MHZ)
+		clk_mhz = 100;
+	else
+		clk_mhz = 125;
+
+	sprintf(ext_clk_path, SERDES_EXT_PATH_FMT, clk_mhz);
+
+	ret = node_by_path(root, &node, ext_clk_path);
+	if (ret) {
+		pr_err("Failed to get offset of '%s' node\n", ext_clk_path);
+		return ret;
+	}
+
+	*phandle = node_create_phandle(&node);
+	if (!*phandle) {
+		pr_err("Failed to create new phandle for %s\n",
+		       ext_clk_path);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int add_ext_clk(struct dts_node *node, int id)
+{
+	struct dts_node root = *node;
+	u32 phandle;
+	int ret;
+
+	ret = get_ext_clk_phandle(&root, id, &phandle);
+	if (ret)
+		return ret;
+
+	ret = node_by_alias(&root, node, SERDES_ALIAS_FMT, id);
+	if (ret) {
+		pr_err("Failed to get 'serdes%u' alias\n", id);
+		return ret;
+	}
+
+	ret = node_append_prop_str(node, "clock-names", SERDES_EXT_CLK);
+	if (ret) {
+		pr_err("Failed to append ext clock to 'clock-names'\n");
+		return ret;
+	}
+
+	ret = node_append_prop_u32(node, "clocks", phandle);
+	if (ret) {
+		pr_err("Failed to append ext clock to 'clock-names'\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+static int set_serdes_clk(struct dts_node *root, int id)
+{
+	enum serdes_clock clk = s32_serdes_get_clock_from_hwconfig(id);
+	int prop_pos, ret;
+	struct dts_node node;
+
+	ret = node_by_alias(root, &node, SERDES_ALIAS_FMT, id);
+	if (ret) {
+		pr_err("Failed to get 'serdes%u' alias\n", id);
+		return ret;
+	}
+
+	prop_pos = node_stringlist_search(&node, "clock-names", SERDES_EXT_CLK);
+
+	if (clk == CLK_INT && prop_pos >= 0)
+		return rename_ext_clk(&node, prop_pos);
+
+	if (clk == CLK_EXT && prop_pos <= 0)
+		return add_ext_clk(&node, id);
+
+	return 0;
+}
+
+static int set_serdes_mode(struct dts_node *root, int id)
+{
+	int ret;
+	enum serdes_mode mode;
+	struct dts_node node;
+
+	mode = s32_serdes_get_op_mode_from_hwconfig(id);
+	if (mode == SERDES_MODE_INVAL) {
+		pr_err("Invalid SerDes%d mode\n", id);
+		return -EINVAL;
+	}
+
+	ret = node_by_alias(root, &node, SERDES_ALIAS_FMT, id);
+	if (ret) {
+		pr_err("Failed to get 'serdes%u' alias\n", id);
+		return ret;
+	}
+
+	ret = node_set_prop_u32(&node, "fsl,sys-mode", mode);
+	if (ret)
+		pr_err("Failed to set 'fsl,sys-mode'\n");
+
+	return ret;
+}
+
+static int apply_hwconfig_fixups(bool fdt, void *blob)
+{
+	int ret;
+	unsigned int id;
+	struct dts_node root = {
+		.fdt = fdt,
+		.blob = blob,
+	};
+
+	for (id = 0; id <= 1; id++) {
+		ret = prepare_pcie_node(&root, id);
+		if (ret) {
+			pr_err("Failed to PCIe ofnode%d\n", id);
+			return ret;
+		}
+
+		ret = set_serdes_clk(&root, id);
+		if (ret)
+			pr_err("Failed to set the clock for SerDes%d\n", id);
+
+		ret = set_serdes_mode(&root, id);
+		if (ret)
+			pr_err("Failed to set mode for SerDes%d\n", id);
+	}
+
+	return 0;
+}
+
+int apply_dm_hwconfig_fixups(void)
+{
+	return apply_hwconfig_fixups(false, NULL);
+}
+
+int apply_fdt_hwconfig_fixups(void *blob)
+{
+	return apply_hwconfig_fixups(true, blob);
+}
diff --git a/arch/arm/mach-s32/s32-cc/soc.c b/arch/arm/mach-s32/s32-cc/soc.c
index 6cb195542e..3bbcb13444 100644
--- a/arch/arm/mach-s32/s32-cc/soc.c
+++ b/arch/arm/mach-s32/s32-cc/soc.c
@@ -10,6 +10,8 @@
 #include <asm/armv8/mmu.h>
 #include <dm/ofnode.h>
 #include <dm/uclass.h>
+#include <s32-cc/pcie.h>
+#include <s32-cc/serdes_hwconfig.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -116,7 +118,7 @@ int arch_cpu_init(void)
 
 static void serdes_init(void)
 {
-	struct udevice *bus;
+	struct udevice *bus = NULL;
 
 	/*
 	 * Enumerate all known UCLASS_PCI_GENERIC devices. This will
@@ -137,8 +139,18 @@ __weak void show_pcie_devices(void)
 
 int initr_pci(void)
 {
+	int ret;
+
 	debug("%s\n", __func__);
 
+	if (IS_ENABLED(CONFIG_OF_LIVE)) {
+		ret = apply_dm_hwconfig_fixups();
+		if (ret) {
+			pr_err("Failed to apply HWCONFIG fixups\n");
+			return ret;
+		}
+	}
+
 	serdes_init();
 	/*
 	 * Enumerate all known PCIe controller devices. Enumeration has
@@ -146,6 +158,7 @@ int initr_pci(void)
 	 * enumerated too.
 	 * This is inspired from commands `pci` and `dm tree`.
 	 */
+
 	pci_init();
 
 	/* now show the devices */
diff --git a/board/nxp/s32-cc/board_common.c b/board/nxp/s32-cc/board_common.c
index 0c822ffddc..a1307cc670 100644
--- a/board/nxp/s32-cc/board_common.c
+++ b/board/nxp/s32-cc/board_common.c
@@ -74,8 +74,6 @@ int ft_board_setup(void *blob, bd_t *bd)
 		return 0;
 	}
 
-	ft_cpu_setup(blob, bd);
-
 	if (IS_ENABLED(CONFIG_NETDEVICES))
 		ft_enet_fixup(blob);
 
diff --git a/drivers/pci/pcie_s32gen1.c b/drivers/pci/pcie_s32gen1.c
index 2d6a38a220..8a687f2bb8 100644
--- a/drivers/pci/pcie_s32gen1.c
+++ b/drivers/pci/pcie_s32gen1.c
@@ -18,6 +18,7 @@
 #include <linux/io.h>
 #include <linux/sizes.h>
 #include <s32-cc/nvmem.h>
+#include <s32-cc/pcie.h>
 #include <dt-bindings/nvmem/s32cc-siul2-nvmem.h>
 
 /* CFG1 is used in linux when finding devices on the bus.
diff --git a/drivers/pci/serdes_s32gen1.h b/drivers/pci/serdes_s32gen1.h
index 38ff4e23f6..514b3e9a97 100644
--- a/drivers/pci/serdes_s32gen1.h
+++ b/drivers/pci/serdes_s32gen1.h
@@ -87,7 +87,5 @@ bool s32_pcie_set_link_width(void __iomem *dbi,
 		int id, enum serdes_link_width linkwidth);
 bool s32_pcie_init(void __iomem *dbi, int id, bool rc_mode,
 		enum serdes_link_width linkwidth);
-void show_pcie_devices(void);
-int initr_pci(void);
 
 #endif /* PCIE_S32GEN1_H */
-- 
2.17.1

