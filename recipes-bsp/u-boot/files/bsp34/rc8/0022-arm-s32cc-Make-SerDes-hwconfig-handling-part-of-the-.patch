From 28735c641ca04a9027eed2533a343c81d5d8f080 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Tue, 12 Jul 2022 14:46:21 +0300
Subject: [PATCH 022/102] arm: s32cc: Make SerDes hwconfig handling part of the
 platform code

These accessories shouldn't be part of the SerDes driver as they
manage SoC parameters. The driver should receive all needed parameters
through a device tree node.

Issue: ALB-8357
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 .../mach-s32/include/s32-cc/serdes_hwconfig.h |   4 +
 arch/arm/mach-s32/s32-cc/Makefile             |   1 +
 arch/arm/mach-s32/s32-cc/serdes_hwconfig.c    | 292 +++++++++++++++++
 drivers/pci/serdes_s32gen1.c                  | 309 +-----------------
 4 files changed, 304 insertions(+), 302 deletions(-)
 create mode 100644 arch/arm/mach-s32/s32-cc/serdes_hwconfig.c

diff --git a/arch/arm/mach-s32/include/s32-cc/serdes_hwconfig.h b/arch/arm/mach-s32/include/s32-cc/serdes_hwconfig.h
index 0e366024db..0fa83e97bc 100644
--- a/arch/arm/mach-s32/include/s32-cc/serdes_hwconfig.h
+++ b/arch/arm/mach-s32/include/s32-cc/serdes_hwconfig.h
@@ -119,6 +119,10 @@ enum serdes_clock_fmhz s32_serdes_get_clock_fmhz_from_hwconfig(int id);
 enum serdes_xpcs_mode s32_serdes_get_xpcs_cfg_from_hwconfig(int id);
 enum serdes_mode s32_serdes_get_op_mode_from_hwconfig(int id);
 enum serdes_phy_mode s32_serdes_get_phy_mode_from_hwconfig(int id);
+bool s32_serdes_is_xpcs_cfg_valid(int id, enum serdes_clock_fmhz freq);
+int s32_serdes_get_mode_str(enum serdes_dev_type mode,
+			    enum serdes_xpcs_mode xpcs_mode,
+			    char *buf);
 bool is_pcie_enabled_in_hwconfig(int id);
 int apply_dm_hwconfig_fixups(void);
 int apply_fdt_hwconfig_fixups(void *blob);
diff --git a/arch/arm/mach-s32/s32-cc/Makefile b/arch/arm/mach-s32/s32-cc/Makefile
index e7f8ad2115..53745095a3 100644
--- a/arch/arm/mach-s32/s32-cc/Makefile
+++ b/arch/arm/mach-s32/s32-cc/Makefile
@@ -12,6 +12,7 @@ obj-y				+= hwconfig_fixups.o
 obj-y				+= nvmem.o
 obj-y				+= scmi_clk_dump.o
 obj-y				+= scmi_reset_agent.o
+obj-y				+= serdes_hwconfig.o
 obj-y				+= soc.o
 obj-$(CONFIG_GICSUPPORT)	+= gicsupport.o
 obj-$(CONFIG_MP)		+= mp.o
diff --git a/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c b/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c
new file mode 100644
index 0000000000..8a272b5cf7
--- /dev/null
+++ b/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c
@@ -0,0 +1,292 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2022 NXP
+ */
+#include <common.h>
+#include <hwconfig.h>
+#include <asm/arch/s32-cc/serdes_regs.h>
+#include <s32-cc/serdes_hwconfig.h>
+
+#define PCIE_DEFAULT_INTERNAL_CLK	CLK_INT
+#define PCIE_DEFAULT_INTERNAL_CLK_FMHZ	CLK_100MHZ
+#define PCIE_DEFAULT_PHY_MODE		CRNS
+
+#define SERDES_RC_MODE_STR "RootComplex"
+#define SERDES_EP_MODE_STR "EndPoint"
+#define SERDES_SGMII_MODE_STR "SGMII"
+#define SERDES_SGMII_MODE_NONE_STR "None"
+#define SERDES_NAME_SIZE 32
+
+static const char xpcs_str[][64] = {
+	"[INVALID XPCS CFG]",
+	"[XPCS0 1G, XPCS1 OFF(PCIex1)]",
+	"[XPCS0 OFF(PCIex1), XPCS1 1G]",
+	"[XPCS0 1G, XPCS1 1G]",
+	"[XPCS0 2.5G, XPCS1 OFF]",
+};
+
+static inline
+const char *s32_serdes_get_xpcs_str(enum serdes_xpcs_mode mode)
+{
+	if (mode > SGMII_INAVALID && mode <= SGMII_XPCS_LAST)
+		return xpcs_str[mode];
+
+	return xpcs_str[SGMII_INAVALID];
+}
+
+int s32_serdes_get_mode_str(enum serdes_dev_type mode,
+			    enum serdes_xpcs_mode xpcs_mode,
+			    char *buf)
+{
+	char *start = buf;
+
+	if (mode & PCIE_RC)
+		start += sprintf(start, SERDES_RC_MODE_STR);
+	if (mode & PCIE_EP)
+		start += sprintf(start, SERDES_EP_MODE_STR);
+	if (mode & SGMII) {
+		if (xpcs_mode == SGMII_XPCS0 || xpcs_mode == SGMII_XPCS1) {
+			if (start != buf)
+				start += sprintf(start, "(x1)&");
+			start += sprintf(start, SERDES_SGMII_MODE_STR);
+		} else if (xpcs_mode != SGMII_INAVALID) {
+			start += sprintf(start, SERDES_SGMII_MODE_STR "(x2)");
+		}
+
+		start += sprintf(start, " %s",
+				s32_serdes_get_xpcs_str(xpcs_mode));
+	} else if (start != buf) {
+		start += sprintf(start, "(x2)");
+	} else {
+		start += sprintf(start, "Not configured");
+	}
+
+	return start - buf;
+}
+
+bool is_pcie_enabled_in_hwconfig(int id)
+{
+	enum serdes_dev_type pcie_mode;
+
+	pcie_mode = s32_serdes_get_mode_from_hwconfig(id);
+	if ((pcie_mode & PCIE_EP) || (pcie_mode & PCIE_RC))
+		return true;
+
+	return false;
+}
+
+static inline
+char *s32_serdes_get_hwconfig_subarg(int id,
+				     const char *subarg,
+				     size_t *subarg_len)
+{
+	char serdes_name[SERDES_NAME_SIZE];
+	char *subarg_str = NULL;
+
+	if (!subarg || !subarg_len)
+		return NULL;
+
+	/*
+	 * The SerDes mode is set by using option `serdesx`, where
+	 * `x` is the ID.
+	 */
+	snprintf(serdes_name, SERDES_NAME_SIZE, "serdes%d", id);
+	debug("%s: testing hwconfig for '%s'\n", __func__,
+	      serdes_name);
+
+	subarg_str = (char *)hwconfig_subarg(serdes_name, subarg, subarg_len);
+
+	if (!subarg_str || !subarg_len) {
+		/* Backwards compatibility:
+		 * Initially the SerDes mode was set by using option `pciex`.
+		 */
+		sprintf(serdes_name, "pcie%d", id);
+		debug("%s: testing hwconfig for '%s'\n", __func__,
+		      serdes_name);
+		subarg_str = (char *)hwconfig_subarg(serdes_name, subarg,
+			subarg_len);
+
+		if (!subarg_str || !subarg_len) {
+			debug("'serdes%d' option '%s' not found in hwconfig\n",
+			      id, subarg);
+			return NULL;
+		}
+	}
+
+	debug("found 'serdes%d' argument '%s=%s\n'", id, subarg, subarg_str);
+	return subarg_str;
+}
+
+enum serdes_dev_type s32_serdes_get_mode_from_hwconfig(int id)
+{
+	enum serdes_dev_type devtype = SERDES_INVALID;
+	size_t subarg_len = 0;
+	char *option_str = s32_serdes_get_hwconfig_subarg(id, "mode",
+		&subarg_len);
+
+	if (!option_str || !subarg_len)
+		return SERDES_INVALID;
+
+	/* 'mode' option */
+	if (!strncmp(option_str, "rc", subarg_len))
+		devtype = PCIE_RC;
+	else if (!strncmp(option_str, "ep", subarg_len))
+		devtype = PCIE_EP;
+	else if (!strncmp(option_str, "sgmii", subarg_len))
+		devtype = SGMII;
+	else if (!strncmp(option_str, "rc&sgmii", subarg_len))
+		devtype = (enum serdes_dev_type)((u32)PCIE_RC | (u32)SGMII);
+	else if (!strncmp(option_str, "ep&sgmii", subarg_len))
+		devtype = (enum serdes_dev_type)((u32)PCIE_EP | (u32)SGMII);
+
+	/* 'skip' option */
+	option_str = s32_serdes_get_hwconfig_subarg(id, "skip", &subarg_len);
+	if (option_str && devtype != SERDES_INVALID &&
+	    (!strncmp(option_str, "true", subarg_len) ||
+	    !strncmp(option_str, "1", subarg_len)))
+		devtype |= SERDES_SKIP;
+
+	return devtype;
+}
+
+enum serdes_xpcs_mode s32_serdes_get_xpcs_cfg_from_hwconfig(int id)
+{
+	/* Set default mode to invalid to force configuration */
+	enum serdes_xpcs_mode xpcs_mode = SGMII_INAVALID;
+	size_t subarg_len = 0;
+	char *option_str = s32_serdes_get_hwconfig_subarg(id, "xpcs_mode",
+		&subarg_len);
+
+	if (!option_str || !subarg_len)
+		return xpcs_mode;
+
+	if (!strncmp(option_str, "0", subarg_len))
+		xpcs_mode = SGMII_XPCS0;
+	else if (!strncmp(option_str, "1", subarg_len))
+		xpcs_mode = SGMII_XPCS1;
+	else if (!strncmp(option_str, "both", subarg_len))
+		xpcs_mode = SGMII_XPCS0_XPCS1;
+	else if (!strncmp(option_str, "2G5", subarg_len))
+		xpcs_mode = SGMII_XPCS0_2G5;
+
+	return xpcs_mode;
+}
+
+enum serdes_clock s32_serdes_get_clock_from_hwconfig(int id)
+{
+	enum serdes_clock clk = PCIE_DEFAULT_INTERNAL_CLK;
+	size_t subarg_len = 0;
+	char *option_str = s32_serdes_get_hwconfig_subarg(id, "clock",
+		&subarg_len);
+
+	if (!option_str || !subarg_len)
+		return clk;
+
+	if (!strncmp(option_str, "ext", subarg_len))
+		clk = CLK_EXT;
+	else if (!strncmp(option_str, "int", subarg_len))
+		clk = CLK_INT;
+
+	return clk;
+}
+
+enum serdes_clock_fmhz s32_serdes_get_clock_fmhz_from_hwconfig(int id)
+{
+	enum serdes_clock_fmhz clk = PCIE_DEFAULT_INTERNAL_CLK_FMHZ;
+	size_t subarg_len = 0;
+	char *option_str = s32_serdes_get_hwconfig_subarg(id, "fmhz",
+		&subarg_len);
+
+	if (!option_str || !subarg_len)
+		return clk;
+
+	if (!strncmp(option_str, "100", subarg_len))
+		clk = CLK_100MHZ;
+	else if (!strncmp(option_str, "125", subarg_len))
+		clk = CLK_125MHZ;
+
+	return clk;
+}
+
+enum serdes_phy_mode s32_serdes_get_phy_mode_from_hwconfig(int id)
+{
+	enum serdes_phy_mode phy_mode = PCIE_DEFAULT_PHY_MODE;
+	size_t subarg_len = 0;
+	char *option_str = s32_serdes_get_hwconfig_subarg(id, "phy_mode",
+		&subarg_len);
+
+	if (!option_str || !subarg_len)
+		return phy_mode;
+
+	if (!strncmp(option_str, "crss", subarg_len))
+		phy_mode = CRSS;
+	else if (!strncmp(option_str, "sris", subarg_len))
+		phy_mode = SRIS;
+
+	return phy_mode;
+}
+
+enum serdes_mode s32_serdes_get_op_mode_from_hwconfig(int id)
+{
+	enum serdes_dev_type mode;
+	enum serdes_xpcs_mode xpcs_mode;
+	enum serdes_phy_mode ss_mode;
+
+	mode = s32_serdes_get_mode_from_hwconfig(id);
+	ss_mode = s32_serdes_get_phy_mode_from_hwconfig(id);
+	xpcs_mode = s32_serdes_get_xpcs_cfg_from_hwconfig(id);
+
+	/* Do not configure SRIS or CRSS PHY MODE in conjunction
+	 * with any SGMII mode on the same SerDes subsystem
+	 */
+	if (ss_mode == CRSS || ss_mode == SRIS) {
+		if (IS_SERDES_PCIE(mode) && !IS_SERDES_SGMII(mode))
+			return SERDES_MODE_PCIE_PCIE;
+
+		return SERDES_MODE_INVAL;
+	}
+
+	if (IS_SERDES_PCIE(mode) && !IS_SERDES_SGMII(mode))
+		return SERDES_MODE_PCIE_PCIE;
+
+	if (IS_SERDES_PCIE(mode) && IS_SERDES_SGMII(mode)) {
+		/* Configure SS mode based on XPCS: modes 1 & 2 */
+		if (xpcs_mode == SGMII_XPCS0)
+			return SERDES_MODE_PCIE_SGMII0;
+
+		if (xpcs_mode == SGMII_XPCS1)
+			return SERDES_MODE_PCIE_SGMII1;
+
+		return SERDES_MODE_INVAL;
+	}
+
+	/* Mode 3 */
+	if (!IS_SERDES_PCIE(mode) && IS_SERDES_SGMII(mode))
+		return SERDES_MODE_SGMII_SGMII;
+
+	return SERDES_MODE_INVAL;
+}
+
+bool s32_serdes_is_xpcs_cfg_valid(int id, enum serdes_clock_fmhz freq)
+{
+	enum serdes_dev_type devtype;
+	enum serdes_xpcs_mode xpcs_mode;
+
+	devtype = s32_serdes_get_mode_from_hwconfig(id);
+	xpcs_mode = s32_serdes_get_xpcs_cfg_from_hwconfig(id);
+
+	if (IS_SERDES_PCIE(devtype) && freq == CLK_125MHZ) {
+		printf("Invalid \"hwconfig\": In PCIe/SGMII combo");
+		printf(" reference clock has to be 100Mhz\n");
+		/* SGMII configuration fail */
+		return false;
+	}
+
+	if (xpcs_mode == SGMII_INAVALID) {
+		printf("Invalid \"hwconfig\": \"xpcs_mode\" is missing\n");
+		/* SGMII configuration fail */
+		return false;
+	}
+
+	return true;
+}
diff --git a/drivers/pci/serdes_s32gen1.c b/drivers/pci/serdes_s32gen1.c
index 914ed0c1ed..e852e9ed58 100644
--- a/drivers/pci/serdes_s32gen1.c
+++ b/drivers/pci/serdes_s32gen1.c
@@ -25,17 +25,7 @@
 #include "serdes_xpcs_regs.h"
 #include "sgmii.h"
 
-#define PCIE_DEFAULT_INTERNAL_CLK	CLK_INT
-#define PCIE_DEFAULT_INTERNAL_CLK_FMHZ	CLK_100MHZ
-#define PCIE_DEFAULT_PHY_MODE		CRNS
-
-#define SERDES_RC_MODE_STR "RootComplex"
-#define SERDES_EP_MODE_STR "EndPoint"
-#define SERDES_SGMII_MODE_STR "SGMII"
-#define SERDES_SGMII_MODE_NONE_STR "None"
 #define SERDES_MODE_SIZE 64
-#define SERDES_NAME_SIZE 32
-
 #define SERDES_CLK_MODE(clk_type) \
 			((clk_type == CLK_INT) ? "internal" : "external")
 #define SERDES_CLK_FMHZ(clk_type) \
@@ -43,52 +33,6 @@
 
 static LIST_HEAD(s32_serdes_list);
 
-static char xpcs_str[][64] = {	"[INVALID XPCS CFG]",
-			"[XPCS0 1G, XPCS1 OFF(PCIex1)]",
-			"[XPCS0 OFF(PCIex1), XPCS1 1G]",
-			"[XPCS0 1G, XPCS1 1G]",
-			"[XPCS0 2.5G, XPCS1 OFF]",
-};
-
-static inline
-const char *s32_serdes_get_xpcs_str(enum serdes_xpcs_mode mode)
-{
-	if (mode > SGMII_INAVALID && mode <= SGMII_XPCS_LAST)
-		return xpcs_str[mode];
-
-	return xpcs_str[SGMII_INAVALID];
-}
-
-static inline
-int s32_serdes_get_mode_str(enum serdes_dev_type mode,
-			    enum serdes_xpcs_mode xpcs_mode,
-			    char *buf)
-{
-	char *start = buf;
-
-	if (mode & PCIE_RC)
-		start += sprintf(start, SERDES_RC_MODE_STR);
-	if (mode & PCIE_EP)
-		start += sprintf(start, SERDES_EP_MODE_STR);
-	if (mode & SGMII) {
-		if (xpcs_mode == SGMII_XPCS0 || xpcs_mode == SGMII_XPCS1) {
-			if (start != buf)
-				start += sprintf(start, "(x1)&");
-			start += sprintf(start, SERDES_SGMII_MODE_STR);
-		} else if (xpcs_mode != SGMII_INAVALID)
-			start += sprintf(start, SERDES_SGMII_MODE_STR "(x2)");
-
-		start += sprintf(start, " %s",
-				s32_serdes_get_xpcs_str(xpcs_mode));
-	} else if (start != buf) {
-		start += sprintf(start, "(x2)");
-	} else {
-		start += sprintf(start, "Not configured");
-	}
-
-	return start - buf;
-}
-
 static int wait_read32(void __iomem *address, u32 expected,
 		       u32 mask, int read_attempts)
 {
@@ -397,43 +341,18 @@ static void s32_serdes_start_mode5(struct s32_serdes *pcie,
 
 static bool s32_serdes_init(struct s32_serdes *pcie)
 {
-	/* Fall back to mode compatible with PCIe */
-	pcie->ss_mode = SERDES_MODE_PCIE_SGMII0;
+	pcie->ss_mode = s32_serdes_get_op_mode_from_hwconfig(pcie->id);
+	if (pcie->ss_mode == SERDES_MODE_INVAL) {
+		printf("ERROR: Invalid opmode config on PCIe%d\n",  pcie->id);
+		return false;
+	}
 
 	/* Reset the Serdes module */
 	s32_assert_serdes_reset(pcie);
 
-	/* Do not configure SRIS or CRSS PHY MODE in conjunction
-	 * with any SGMII mode on the same SerDes subsystem
-	 */
-	if (pcie->phy_mode == CRSS || pcie->phy_mode == SRIS) {
-		if (IS_SERDES_PCIE(pcie->devtype) &&
-		    !IS_SERDES_SGMII(pcie->devtype))
-			pcie->ss_mode = SERDES_MODE_PCIE_PCIE;
-		else
-			return false;
-	} else if (IS_SERDES_PCIE(pcie->devtype) &&
-			!IS_SERDES_SGMII(pcie->devtype)) {
-		pcie->ss_mode = SERDES_MODE_PCIE_PCIE;
-	} else if (IS_SERDES_PCIE(pcie->devtype) &&
-		   IS_SERDES_SGMII(pcie->devtype)) {
-		if (pcie->xpcs_mode != SGMII_XPCS0 &&
-		    pcie->xpcs_mode != SGMII_XPCS1) {
-			printf("ERROR: Invalid XPCS config on PCIe%d\n",
-			       pcie->id);
-		}
-
-		/* Configure SS mode based on XPCS */
-		if (pcie->xpcs_mode == SGMII_XPCS0)
-			pcie->ss_mode = SERDES_MODE_PCIE_SGMII0;
-		if (pcie->xpcs_mode == SGMII_XPCS1)
-			pcie->ss_mode = SERDES_MODE_PCIE_SGMII1;
-
-	} else if (!IS_SERDES_PCIE(pcie->devtype) &&
-		    IS_SERDES_SGMII(pcie->devtype)) {
+	if (pcie->ss_mode == SERDES_MODE_SGMII_SGMII) {
 		/*	Set pipeP_pclk */
 		W32(UPTR(pcie->dbi) + SS_PHY_GEN_CTRL, EXT_PCLK_REQ);
-		pcie->ss_mode = SERDES_MODE_SGMII_SGMII;
 	}
 
 	if (s32_serdes_set_mode(pcie->dbi, pcie->id, pcie->ss_mode))
@@ -510,200 +429,6 @@ __weak int s32_eth_xpcs_init(void __iomem *dbi, int id,
 	return -ENODEV;
 }
 
-bool is_pcie_enabled_in_hwconfig(int id)
-{
-	enum serdes_dev_type pcie_mode;
-
-	pcie_mode = s32_serdes_get_mode_from_hwconfig(id);
-	if ((pcie_mode & PCIE_EP) || (pcie_mode & PCIE_RC))
-		return true;
-
-	return false;
-}
-
-static inline
-char *s32_serdes_get_hwconfig_subarg(int id,
-				     const char *subarg,
-				     size_t *subarg_len)
-{
-	char serdes_name[SERDES_NAME_SIZE];
-	char *subarg_str = NULL;
-
-	if (!subarg || !subarg_len)
-		return NULL;
-
-	/*
-	 * The SerDes mode is set by using option `serdesx`, where
-	 * `x` is the ID.
-	 */
-	snprintf(serdes_name, SERDES_NAME_SIZE, "serdes%d", id);
-	debug("%s: testing hwconfig for '%s'\n", __func__,
-	      serdes_name);
-
-	subarg_str = (char *)hwconfig_subarg(serdes_name, subarg, subarg_len);
-
-	if (!subarg_str || !subarg_len) {
-		/* Backwards compatibility:
-		 * Initially the SerDes mode was set by using option `pciex`.
-		 */
-		sprintf(serdes_name, "pcie%d", id);
-		debug("%s: testing hwconfig for '%s'\n", __func__,
-		      serdes_name);
-		subarg_str = (char *)hwconfig_subarg(serdes_name, subarg,
-			subarg_len);
-
-		if (!subarg_str || !subarg_len) {
-			debug("'serdes%d' option '%s' not found in hwconfig\n",
-			      id, subarg);
-			return NULL;
-		}
-	}
-
-	debug("found 'serdes%d' argument '%s=%s\n'", id, subarg, subarg_str);
-	return subarg_str;
-}
-
-enum serdes_dev_type s32_serdes_get_mode_from_hwconfig(int id)
-{
-	enum serdes_dev_type devtype = SERDES_INVALID;
-	size_t subarg_len = 0;
-	char *option_str = s32_serdes_get_hwconfig_subarg(id, "mode",
-		&subarg_len);
-
-	if (!option_str || !subarg_len)
-		return SERDES_INVALID;
-
-	/* 'mode' option */
-	if (!strncmp(option_str, "rc", subarg_len))
-		devtype = PCIE_RC;
-	else if (!strncmp(option_str, "ep", subarg_len))
-		devtype = PCIE_EP;
-	else if (!strncmp(option_str, "sgmii", subarg_len))
-		devtype = SGMII;
-	else if (!strncmp(option_str, "rc&sgmii", subarg_len))
-		devtype = PCIE_RC | SGMII;
-	else if (!strncmp(option_str, "ep&sgmii", subarg_len))
-		devtype = PCIE_EP | SGMII;
-
-	/* 'skip' option */
-	option_str = s32_serdes_get_hwconfig_subarg(id, "skip", &subarg_len);
-	if (option_str && devtype != SERDES_INVALID &&
-	    (!strncmp(option_str, "true", subarg_len) ||
-	    !strncmp(option_str, "1", subarg_len)))
-		devtype |= SERDES_SKIP;
-
-	return devtype;
-}
-
-enum serdes_xpcs_mode s32_serdes_get_xpcs_cfg_from_hwconfig(int id)
-{
-	/* Set default mode to invalid to force configuration */
-	enum serdes_xpcs_mode xpcs_mode = SGMII_INAVALID;
-	size_t subarg_len = 0;
-	char *option_str = s32_serdes_get_hwconfig_subarg(id, "xpcs_mode",
-		&subarg_len);
-
-	if (!option_str || !subarg_len)
-		return xpcs_mode;
-
-	if (!strncmp(option_str, "0", subarg_len))
-		xpcs_mode = SGMII_XPCS0;
-	else if (!strncmp(option_str, "1", subarg_len))
-		xpcs_mode = SGMII_XPCS1;
-	else if (!strncmp(option_str, "both", subarg_len))
-		xpcs_mode = SGMII_XPCS0_XPCS1;
-	else if (!strncmp(option_str, "2G5", subarg_len))
-		xpcs_mode = SGMII_XPCS0_2G5;
-
-	return xpcs_mode;
-}
-
-enum serdes_clock s32_serdes_get_clock_from_hwconfig(int id)
-{
-	enum serdes_clock clk = PCIE_DEFAULT_INTERNAL_CLK;
-	size_t subarg_len = 0;
-	char *option_str = s32_serdes_get_hwconfig_subarg(id, "clock",
-		&subarg_len);
-
-	if (!option_str || !subarg_len)
-		return clk;
-
-	if (!strncmp(option_str, "ext", subarg_len))
-		clk = CLK_EXT;
-	else if (!strncmp(option_str, "int", subarg_len))
-		clk = CLK_INT;
-
-	return clk;
-}
-
-enum serdes_clock_fmhz s32_serdes_get_clock_fmhz_from_hwconfig(int id)
-{
-	enum serdes_clock_fmhz clk = PCIE_DEFAULT_INTERNAL_CLK_FMHZ;
-	size_t subarg_len = 0;
-	char *option_str = s32_serdes_get_hwconfig_subarg(id, "fmhz",
-		&subarg_len);
-
-	if (!option_str || !subarg_len)
-		return clk;
-
-	if (!strncmp(option_str, "100", subarg_len))
-		clk = CLK_100MHZ;
-	else if (!strncmp(option_str, "125", subarg_len))
-		clk = CLK_125MHZ;
-
-	return clk;
-}
-
-enum serdes_phy_mode s32_serdes_get_phy_mode_from_hwconfig(int id)
-{
-	enum serdes_phy_mode phy_mode = PCIE_DEFAULT_PHY_MODE;
-	size_t subarg_len = 0;
-	char *option_str = s32_serdes_get_hwconfig_subarg(id, "phy_mode",
-		&subarg_len);
-
-	if (!option_str || !subarg_len)
-		return phy_mode;
-
-	if (!strncmp(option_str, "crss", subarg_len))
-		phy_mode = CRSS;
-	else if (!strncmp(option_str, "sris", subarg_len))
-		phy_mode = SRIS;
-
-	return phy_mode;
-}
-
-enum serdes_mode s32_serdes_get_op_mode_from_hwconfig(int id)
-{
-	enum serdes_dev_type mod;
-	enum serdes_xpcs_mode xpcs_mode;
-
-	mod = s32_serdes_get_mode_from_hwconfig(id);
-
-	/* Skip the 'skip' flag */
-	mod &= ~(uint32_t)(SERDES_SKIP);
-
-	/* Mode 3 */
-	if (mod == SGMII)
-		return SERDES_MODE_SGMII_SGMII;
-
-	/* Mode 0 */
-	if (mod == PCIE_EP || mod == PCIE_RC)
-		return SERDES_MODE_PCIE_PCIE;
-
-	/* Not mode 1 || 2 */
-	if ((mod != (PCIE_EP | SGMII)) && (mod != (PCIE_RC | SGMII)))
-		return SERDES_MODE_INVAL;
-
-	xpcs_mode = s32_serdes_get_xpcs_cfg_from_hwconfig(id);
-	if (xpcs_mode == SGMII_XPCS0)
-		return SERDES_MODE_PCIE_SGMII0;
-
-	if (xpcs_mode == SGMII_XPCS1)
-		return SERDES_MODE_PCIE_SGMII1;
-
-	return SERDES_MODE_INVAL;
-}
-
 static const char *s32_serdes_get_pcie_phy_mode(struct s32_serdes *pcie)
 {
 	if (pcie->phy_mode == CRSS)
@@ -715,26 +440,6 @@ static const char *s32_serdes_get_pcie_phy_mode(struct s32_serdes *pcie)
 	return "CRNS";
 }
 
-static bool s32_serdes_is_xpcs_cfg_valid(struct s32_serdes *pcie)
-{
-	bool ret = true;
-
-	if (IS_SERDES_PCIE(pcie->devtype) && pcie->fmhz == CLK_125MHZ) {
-		printf("Invalid \"hwconfig\": In PCIe/SGMII combo");
-		printf(" reference clock has to be 100Mhz\n");
-		/* SGMII configuration fail */
-		ret = false;
-	}
-
-	if (pcie->xpcs_mode == SGMII_INAVALID) {
-		printf("Invalid \"hwconfig\": \"xpcs_mode\" is missing\n");
-		/* SGMII configuration fail */
-		ret = false;
-	}
-
-	return ret;
-}
-
 static int get_serdes_alias_id(struct udevice *dev, int *devnump)
 {
 	ofnode node = dev_ofnode(dev);
@@ -867,7 +572,7 @@ static int s32_serdes_probe(struct udevice *dev)
 
 	/* In case of sgmii mode check xpcs configuration */
 	if (IS_SERDES_SGMII(pcie->devtype) &&
-	    !s32_serdes_is_xpcs_cfg_valid(pcie))
+	    !s32_serdes_is_xpcs_cfg_valid(pcie->id, pcie->fmhz))
 		pcie->xpcs_mode = SGMII_INAVALID;
 
 	pcie_phy_mode = s32_serdes_get_pcie_phy_mode(pcie);
-- 
2.17.1

