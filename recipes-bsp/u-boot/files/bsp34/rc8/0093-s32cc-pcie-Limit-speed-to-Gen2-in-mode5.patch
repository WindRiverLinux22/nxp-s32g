From 228db1c853f503f18cd5953fd66455f7c45ad0ab Mon Sep 17 00:00:00 2001
From: Ionut Vicovan <Ionut.Vicovan@nxp.com>
Date: Tue, 9 Aug 2022 21:54:27 +0300
Subject: [PATCH 093/102] s32cc:pcie: Limit speed to Gen2 in mode5

Issue: ALB-9065

Upstream-Status: Pending 

Signed-off-by: Ionut Vicovan <Ionut.Vicovan@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 .../mach-s32/include/s32-cc/serdes_hwconfig.h |  1 +
 arch/arm/mach-s32/s32-cc/serdes_hwconfig.c    |  8 ++
 drivers/pci/pcie_s32gen1.c                    | 98 ++++++++++++++++---
 drivers/pci/pcie_s32gen1.h                    |  7 +-
 4 files changed, 102 insertions(+), 12 deletions(-)

diff --git a/arch/arm/mach-s32/include/s32-cc/serdes_hwconfig.h b/arch/arm/mach-s32/include/s32-cc/serdes_hwconfig.h
index 2547bd038d..eb14f0c0e9 100644
--- a/arch/arm/mach-s32/include/s32-cc/serdes_hwconfig.h
+++ b/arch/arm/mach-s32/include/s32-cc/serdes_hwconfig.h
@@ -111,6 +111,7 @@ enum serdes_mode s32_serdes_get_op_mode_from_hwconfig(int id);
 enum pcie_phy_mode s32_serdes_get_phy_mode_from_hwconfig(int id);
 bool s32_serdes_is_cfg_valid(int id);
 bool s32_serdes_is_pcie_enabled_in_hwconfig(int id);
+bool s32_serdes_is_combo_mode_enabled_in_hwconfig(int id);
 bool s32_serdes_is_mode5_enabled_in_hwconfig(int id);
 int apply_dm_hwconfig_fixups(void);
 int apply_fdt_hwconfig_fixups(void *blob);
diff --git a/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c b/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c
index fc9fa8c6d0..e42e372074 100644
--- a/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c
+++ b/arch/arm/mach-s32/s32-cc/serdes_hwconfig.c
@@ -30,7 +30,15 @@ bool s32_serdes_is_pcie_enabled_in_hwconfig(int id)
 
 	ss_mode = s32_serdes_get_mode_from_hwconfig(id);
 	return IS_SERDES_PCIE(ss_mode);
+}
 
+bool s32_serdes_is_combo_mode_enabled_in_hwconfig(int id)
+{
+	enum serdes_dev_type ss_mode;
+
+	ss_mode = s32_serdes_get_mode_from_hwconfig(id);
+	return IS_SERDES_PCIE(ss_mode) &&
+			IS_SERDES_SGMII(ss_mode);
 }
 
 static inline
diff --git a/drivers/pci/pcie_s32gen1.c b/drivers/pci/pcie_s32gen1.c
index 2540b69054..1db0ac0d48 100644
--- a/drivers/pci/pcie_s32gen1.c
+++ b/drivers/pci/pcie_s32gen1.c
@@ -613,8 +613,75 @@ static bool s32_pcie_set_max_link_width(void __iomem *dbi, int id,
 	return true;
 }
 
+/* Set max link speed */
+static bool s32_pcie_set_max_link_speed(void __iomem *dbi,
+					int id,
+					enum pcie_link_speed linkspeed)
+{
+	u16 link_cap = s32_dbi_readw(UPTR(dbi) +
+				     PCIE_CAP_LINK_CAPABILITIES_REG);
+	enum pcie_link_speed crt_speed =
+		(enum pcie_link_speed)PCIE_BIT_VALUE(link_cap,
+						     PCIE_MAX_LINK_SPEED);
+
+	/* Change speed if different than existing settings */
+	if (linkspeed == crt_speed)
+		return true;
+
+	s32_pcie_enable_dbi_rw(dbi);
+
+	debug("Replacing max speed Gen%d with Gen%d\n", crt_speed, linkspeed);
+
+	/* Set link speed capabilities.
+	 *
+	 * PCIE_CAP_LINK_CAPABILITIES2_REG register contains the supported link
+	 * widths and speeds.
+	 * For the field PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR,
+	 * The bit definitions within this field are:
+	 * Bit 0: 1 - 2.5 GT/s (Gen1)
+	 * Bit 1: 1 - 5.0 GT/s (Gen2)
+	 * Bit 2: 1 - 8.0 GT/s (Gen3)
+	 * Bits 3-6: 0 for S32G2/3 and S32R
+	 *
+	 * This field is Read-Only.
+	 *
+	 * PCIE_CAP_LINK_CAPABILITIES_REG however permits to set the maximum
+	 * speed, by writing to the field PCIE_CAP_MAX_LINK_SPEED.
+	 * The bit definitions within this field are a reference to a bit in
+	 * PCIE_CAP_LINK_CAPABILITIES2_REG:PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR:
+	 * 0001b - Supported Link Speeds Vector field bit 0
+	 * 0010b - Supported Link Speeds Vector field bit 1
+	 * 0011b - Supported Link Speeds Vector field bit 2
+	 * etc.
+	 */
+	RMW32(UPTR(dbi) + PCIE_CAP_LINK_CAPABILITIES_REG,
+	      BUILD_MASK_VALUE(PCIE_MAX_LINK_SPEED, linkspeed),
+	      PCIE_MAX_LINK_SPEED);
+
+	/* Limit speed to `linkspeed` */
+	if (linkspeed < GEN3)
+		RMW32(UPTR(dbi) +
+		      PCIE_CAP_LINK_CONTROL2_LINK_STATUS2_REG,
+		      BUILD_MASK_VALUE(PCIE_CAP_TARGET_LINK_SPEED,
+				       linkspeed),
+		      PCIE_CAP_TARGET_LINK_SPEED);
+
+#ifdef DEBUG
+	link_cap = s32_dbi_readw(UPTR(dbi) +
+				 PCIE_CAP_LINK_CAPABILITIES_REG);
+
+	debug("Max speed set to Gen%d\n",
+	      PCIE_BIT_VALUE(link_cap, PCIE_MAX_LINK_SPEED));
+#endif
+
+	s32_pcie_disable_dbi_rw(dbi);
+
+	return true;
+}
+
 static bool s32_pcie_init(void __iomem *dbi, int id, bool rc_mode,
 			  enum pcie_link_width linkwidth,
+			  enum pcie_link_speed linkspeed,
 			  enum pcie_phy_mode phy_mode)
 {
 	printf("Configuring PCIe%d as %s\n", id, PCIE_EP_RC_MODE(!rc_mode));
@@ -648,6 +715,8 @@ static bool s32_pcie_init(void __iomem *dbi, int id, bool rc_mode,
 
 	if (!s32_pcie_set_max_link_width(dbi, id, linkwidth))
 		return false;
+	if (!s32_pcie_set_max_link_speed(dbi, id, linkspeed))
+		return false;
 
 	/* Enable writing dbi registers */
 	s32_pcie_enable_dbi_rw(dbi);
@@ -795,7 +864,11 @@ static int s32_pcie_get_config_from_device_tree(struct s32_pcie *pcie)
 #endif
 
 	/* get supported speed (Gen1/Gen2/Gen3) from device tree */
-	val = dev_read_u32_default(dev, "link-speed", GEN1);
+	val = dev_read_u32_default(dev, "max-link-speed", GEN1);
+	if (val > GEN_MAX) {
+		printf("PCIe%d: Invalid speed\n", pcie->id);
+		val = GEN1;
+	}
 	pcie->linkspeed = (enum pcie_link_speed)val;
 	/* get supported width (X1/X2) from device tree */
 	val = dev_read_u32_default(dev, "num-lanes", X1);
@@ -821,10 +894,7 @@ static void s32_get_link_status(struct s32_pcie *pcie,
 	 * Bit 0: 2.5 GT/s (Gen1)
 	 * Bit 1: 5.0 GT/s (Gen2)
 	 * Bit 2: 8.0 GT/s (Gen3)
-	 * Bit 3: 16.0 GT/s (Gen4)
-	 * Bit 4: 32.0 GT/s (Gen5)
-	 * Bit 5-6: Reserved -- for S32G3
-	 * Bits 3-6: Reserved -- for S32G2 and S32R
+	 * Bits 3-6: Reserved for S32G2/3 and S32R
 	 */
 	if (verbose) {
 		u16 link_cap = s32_dbi_readw(UPTR(pcie->dbi) +
@@ -842,11 +912,9 @@ static void s32_get_link_status(struct s32_pcie *pcie,
 	/* For link speed, LINK_SPEED value specifies a bit location in
 	 * LINK_CAPABILITIES_2[SUPPORT_LINK_SPEED_VECTOR] that corresponds
 	 * to the current link speed.
-	 * 0001b - SUPPORT_LINK_SPEED_VECTOR bit 0 (Gen1)
-	 * 0010b - SUPPORT_LINK_SPEED_VECTOR bit 1 (Gen2)
-	 * 0011b - SUPPORT_LINK_SPEED_VECTOR bit 2 (Gen3)
-	 * 0100b - SUPPORT_LINK_SPEED_VECTOR bit 3 (Gen4) -- for S32G3
-	 * 0101b - SUPPORT_LINK_SPEED_VECTOR bit 4 (Gen5) -- for S32G3
+	 * 0001b - PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR bit 0 (Gen1)
+	 * 0010b - PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR bit 1 (Gen2)
+	 * 0011b - PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR bit 2 (Gen3)
 	 */
 	*speed = PCIE_BIT_VALUE(link_sta, PCIE_LINK_CRT_SPEED);
 	if (verbose)
@@ -1077,8 +1145,16 @@ static int init_controller(struct s32_pcie *pcie)
 	if (ret)
 		return ret;
 
+	if (s32_serdes_is_combo_mode_enabled_in_hwconfig(pcie->id)) {
+		pcie->linkwidth = X1;
+
+		if (s32_serdes_is_mode5_enabled_in_hwconfig(pcie->id))
+			pcie->linkspeed = GEN2;
+	}
+
 	if (!s32_pcie_init(pcie->dbi, pcie->id, !pcie->ep_mode,
-			   pcie->linkwidth, pcie->phy_mode))
+			   pcie->linkwidth, pcie->linkspeed,
+			   pcie->phy_mode))
 		return -EINVAL;
 
 	s32_pcie_enable_ltssm(pcie->dbi);
diff --git a/drivers/pci/pcie_s32gen1.h b/drivers/pci/pcie_s32gen1.h
index f65640b108..de58f982ca 100644
--- a/drivers/pci/pcie_s32gen1.h
+++ b/drivers/pci/pcie_s32gen1.h
@@ -243,10 +243,15 @@ do { \
 #define CLKEN_MASK	0x1
 #define CLKEN_LSB	23
 
+/* Supported link speeds for PCIe on S32Gen1
+ * Maximum supported value is in sync with field
+ * PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR of register LINK_CAPABILITIES2_REG
+ */
 enum pcie_link_speed {
 	GEN1 = 0x1,
 	GEN2 = 0x2,
-	GEN3 = 0x3
+	GEN3 = 0x3,
+	GEN_MAX = GEN3
 };
 
 /* Supported link widths for PCIe on S32Gen1 */
-- 
2.17.1

