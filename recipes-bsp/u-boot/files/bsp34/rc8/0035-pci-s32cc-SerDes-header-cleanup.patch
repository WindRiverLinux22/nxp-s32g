From 5aa26c2d1459b93c744840196a2fd0ec11594a86 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Fri, 15 Jul 2022 12:11:54 +0300
Subject: [PATCH 035/102] pci: s32cc: SerDes header cleanup

Split most of the items contained by serdes_s32gen1.h header
between SerDes and PCIe driver.

Issue: ALB-8357
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/pci/pcie_s32gen1.c   | 13 +++++++--
 drivers/pci/pcie_s32gen1.h   | 10 +++++--
 drivers/pci/serdes_s32gen1.c | 43 +++++++++++++++++++--------
 drivers/pci/serdes_s32gen1.h | 56 ++----------------------------------
 4 files changed, 51 insertions(+), 71 deletions(-)

diff --git a/drivers/pci/pcie_s32gen1.c b/drivers/pci/pcie_s32gen1.c
index e6866ccc9f..5f4c1e9d44 100644
--- a/drivers/pci/pcie_s32gen1.c
+++ b/drivers/pci/pcie_s32gen1.c
@@ -13,14 +13,19 @@
 #include <pci.h>
 #include <asm/io.h>
 #include <asm/arch/clock.h>
+#include <asm/arch/s32-cc/serdes_regs.h>
 #include <dm/device-internal.h>
 #include <dm/uclass.h>
 #include <linux/io.h>
 #include <linux/sizes.h>
 #include <s32-cc/nvmem.h>
 #include <s32-cc/pcie.h>
+#include <s32-cc/serdes_hwconfig.h>
 #include <dt-bindings/nvmem/s32cc-siul2-nvmem.h>
 
+#include "serdes_s32gen1_io.h"
+#include "ss_pcie_regs.h"
+
 /* CFG1 is used in linux when finding devices on the bus.
  * It is actually the upper half of the config space
  * (defined as "config" in device tree).
@@ -50,6 +55,8 @@
 
 #define PCI_DEVICE_ID_S32GEN1	0x4002
 
+#define PCIE_LINK_UP_COUNT 100
+
 LIST_HEAD(s32_pcie_list);
 
 static inline void s32_pcie_enable_dbi_rw(void __iomem *dbi)
@@ -562,7 +569,7 @@ static int s32_pcie_setup_ep(struct s32_pcie *pcie)
 }
 
 static bool s32_pcie_set_link_width(void __iomem *dbi, int id,
-				    enum serdes_link_width linkwidth)
+				    enum pcie_link_width linkwidth)
 {
 	s32_pcie_enable_dbi_rw(dbi);
 
@@ -597,7 +604,7 @@ static int s32_pcie_check_phy_mode(int id, const char *mode)
 }
 
 static bool s32_pcie_init(void __iomem *dbi, int id, bool rc_mode,
-			  enum serdes_link_width linkwidth)
+			  enum pcie_link_width linkwidth)
 {
 	printf("Configuring PCIe%d as %s\n", id, PCIE_EP_RC_MODE(!rc_mode));
 
@@ -758,7 +765,7 @@ static int s32_pcie_get_config_from_device_tree(struct s32_pcie *pcie)
 	pcie->linkspeed = (enum pcie_link_speed)val;
 	/* get supported width (X1/X2) from device tree */
 	val = dev_read_u32_default(dev, "num-lanes", X1);
-	pcie->linkwidth = (enum serdes_link_width)val;
+	pcie->linkwidth = (enum pcie_link_width)val;
 
 	return ret;
 }
diff --git a/drivers/pci/pcie_s32gen1.h b/drivers/pci/pcie_s32gen1.h
index d920e8c589..e6fc732b2a 100644
--- a/drivers/pci/pcie_s32gen1.h
+++ b/drivers/pci/pcie_s32gen1.h
@@ -121,10 +121,9 @@
 #define CRS_EN					0x2
 /* LTSSM Enable. Active high. Set it low to hold the LTSSM in Detect state. */
 #define LTSSM_EN				0x1
-
+#define LTSSM_STATE_L0		0x11 /* L0 state */
 
 /* Register SS_RW_REG_0 */
-
 #define CLKEN_MASK	0x1
 #define CLKEN_OFF	23
 
@@ -134,6 +133,11 @@ enum pcie_link_speed {
 	GEN3 = 0x3
 };
 
+enum pcie_link_width {
+	X1 = 0x1,
+	X2 = 0x2
+};
+
 struct s32_pcie {
 	struct list_head list;
 	struct udevice *bus;
@@ -146,7 +150,7 @@ struct s32_pcie {
 	int id;
 	bool enabled;
 	bool ep_mode;
-	enum serdes_link_width linkwidth;
+	enum pcie_link_width linkwidth;
 	enum pcie_link_speed linkspeed;
 	int atu_out_num;
 	int atu_in_num;
diff --git a/drivers/pci/serdes_s32gen1.c b/drivers/pci/serdes_s32gen1.c
index f03aec9f02..a6da8b3c3a 100644
--- a/drivers/pci/serdes_s32gen1.c
+++ b/drivers/pci/serdes_s32gen1.c
@@ -23,14 +23,33 @@
 
 #include "serdes_regs.h"
 #include "serdes_s32gen1.h"
+#include "serdes_s32gen1_io.h"
 #include "serdes_xpcs_regs.h"
 #include "sgmii.h"
+#include "ss_pcie_regs.h"
+
+#define PCIE_MPLL_LOCK_COUNT 10
+#define DELAY_QUANTUM 1000
 
 #define SERDES_CLK_MODE(clk_type) \
 			((clk_type == CLK_INT) ? "internal" : "external")
 #define SERDES_CLK_FMHZ(clk_type) \
 			((clk_type == CLK_100MHZ) ? "100Mhz" : "125Mhz")
 
+struct serdes {
+	struct udevice *bus;
+	void __iomem *dbi;
+	struct reset_ctl *pcie_rst, *serdes_rst;
+	enum serdes_mode ss_mode;
+
+	int id;
+	enum serdes_dev_type devtype;
+	enum serdes_xpcs_mode xpcs_mode;
+	enum serdes_clock clktype;
+	enum serdes_clock_fmhz fmhz;
+	enum serdes_phy_mode phy_mode;
+};
+
 int wait_read32(void __iomem *address, u32 expected,
 		u32 mask, int read_attempts)
 {
@@ -59,7 +78,7 @@ static int s32_serdes_set_mode(void __iomem *dbi, enum serdes_mode mode)
 	return 0;
 }
 
-static int s32_serdes_assert_reset(struct s32_serdes *serdes)
+static int s32_serdes_assert_reset(struct serdes *serdes)
 {
 	__maybe_unused struct udevice *dev = serdes->bus;
 	int ret;
@@ -79,7 +98,7 @@ static int s32_serdes_assert_reset(struct s32_serdes *serdes)
 	return 0;
 }
 
-static int s32_serdes_deassert_reset(struct s32_serdes *serdes)
+static int s32_serdes_deassert_reset(struct serdes *serdes)
 {
 	__maybe_unused struct udevice *dev = serdes->bus;
 	int ret;
@@ -104,7 +123,7 @@ static int s32_serdes_deassert_reset(struct s32_serdes *serdes)
  * @param[in]	addr	Indirect PHY address (16bit).
  * @param[in]	wdata	Indirect PHY data to be written (16 bit).
  */
-static void s32_serdes_phy_reg_write(struct s32_serdes *pcie, u16 addr,
+static void s32_serdes_phy_reg_write(struct serdes *pcie, u16 addr,
 				     u16 wdata, u16 wmask)
 {
 	u32 temp_data = wdata & wmask;
@@ -120,7 +139,7 @@ static void s32_serdes_phy_reg_write(struct s32_serdes *pcie, u16 addr,
 	udelay(100);
 }
 
-static void s32_serdes_phy_init(struct s32_serdes *pcie)
+static void s32_serdes_phy_init(struct serdes *pcie)
 {
 	/* Select the CR parallel interface */
 	BSET32(UPTR(pcie->dbi) + SS_SS_RW_REG_0, PHY0_CR_PARA_SEL);
@@ -145,7 +164,7 @@ static void s32_serdes_phy_init(struct s32_serdes *pcie)
 				 0x13, 0xff);
 }
 
-static void s32_serdes_xpcs1_pma_config(struct s32_serdes *pcie)
+static void s32_serdes_xpcs1_pma_config(struct serdes *pcie)
 {
 	/* Configure TX_VBOOST_LVL and TX_TERM_CTRL */
 	RMW32(UPTR(pcie->dbi) + SS_PHY_EXT_MISC_CTRL_2,
@@ -195,7 +214,7 @@ static void s32_serdes_xpcs1_pma_config(struct s32_serdes *pcie)
 	      EXT_RX_LOS_THRESHOLD(0x3fU) | EXT_RX_VREF_CTRL(0x1fU));
 }
 
-static void s32_serdes_start_mode5(struct s32_serdes *pcie,
+static void s32_serdes_start_mode5(struct serdes *pcie,
 				   enum serdes_xpcs_mode_gen2 xpcs[2])
 {
 	if (!s32_serdes_has_mode5_enabled(pcie->id))
@@ -213,7 +232,7 @@ static void s32_serdes_start_mode5(struct s32_serdes *pcie,
 	xpcs[1] = SGMII_XPCS_2G5_OP;
 }
 
-static bool s32_serdes_init(struct s32_serdes *pcie)
+static bool s32_serdes_init(struct serdes *pcie)
 {
 	int ret;
 
@@ -290,7 +309,7 @@ __weak int s32_eth_xpcs_init(void __iomem *dbi, int id,
 	return -ENODEV;
 }
 
-static const char *s32_serdes_get_pcie_phy_mode(struct s32_serdes *pcie)
+static const char *s32_serdes_get_pcie_phy_mode(struct serdes *pcie)
 {
 	if (pcie->phy_mode == CRSS)
 		return "CRSS";
@@ -321,7 +340,7 @@ static int get_serdes_alias_id(struct udevice *dev, int *devnump)
 	return ret;
 }
 
-static int s32_serdes_get_config_from_device_tree(struct s32_serdes *pcie)
+static int ss_dt_init(struct serdes *pcie)
 {
 	struct resource res;
 	struct udevice *dev = pcie->bus;
@@ -384,7 +403,7 @@ static int enable_serdes_clocks(struct udevice *dev)
 
 static int s32_serdes_probe(struct udevice *dev)
 {
-	struct s32_serdes *pcie = dev_get_priv(dev);
+	struct serdes *pcie = dev_get_priv(dev);
 	const char *pcie_phy_mode;
 	int ret = 0;
 
@@ -396,7 +415,7 @@ static int s32_serdes_probe(struct udevice *dev)
 
 	pcie->bus = dev;
 
-	ret = s32_serdes_get_config_from_device_tree(pcie);
+	ret = ss_dt_init(pcie);
 	if (ret)
 		return ret;
 
@@ -460,5 +479,5 @@ U_BOOT_DRIVER(serdes_s32gen1) = {
 	.id = UCLASS_PCI_GENERIC,
 	.of_match = s32_serdes_ids,
 	.probe	= s32_serdes_probe,
-	.priv_auto_alloc_size = sizeof(struct s32_serdes),
+	.priv_auto_alloc_size = sizeof(struct serdes),
 };
diff --git a/drivers/pci/serdes_s32gen1.h b/drivers/pci/serdes_s32gen1.h
index 2d52180b0c..33eafb7b98 100644
--- a/drivers/pci/serdes_s32gen1.h
+++ b/drivers/pci/serdes_s32gen1.h
@@ -1,65 +1,15 @@
 /* SPDX-License-Identifier: GPL-2.0+ */
 /*
  * Copyright 2019-2022 NXP
- * S32Gen1 PCIe driver
+ * S32Gen1 SerDes driver
  */
 
 #ifndef SERDES_S32GEN1_H
 #define SERDES_S32GEN1_H
 
-#include <dm.h>
-#include <pci.h>
-#include <asm/io.h>
-
-#include "serdes_regs.h"
-#include "serdes_s32gen1_io.h"
-#include "sgmii.h"
-#include "ss_pcie_regs.h"
-
-#define PCIE_LINK_UP_COUNT 100
-#define PCIE_MPLL_LOCK_COUNT 10
-#define PCIE_RESET_COUNT 50
-#define DELAY_QUANTUM 1000
-
-#define LTSSM_STATE_L0		0x11 /* L0 state */
-
-#define SERDES_LINKUP_MASK	(SMLH_LINK_UP | RDLH_LINK_UP | \
-		SMLH_LTSSM_STATE)
-#define SERDES_LINKUP_EXPECT	(SMLH_LINK_UP | RDLH_LINK_UP | \
-		BUILD_MASK_VALUE(SMLH_LTSSM_STATE, LTSSM_STATE_L0))
-
-/* Configuration Request Retry Status (CRS) Enable. Active high. */
-/* Defer incoming configuration requests. */
-#define CRS_EN					0x2
-/* LTSSM Enable. Active high. Set it low to hold the LTSSM in Detect state. */
-#define LTSSM_EN				0x1
-
-
-/* Register SS_RW_REG_0 */
-
-#define CLKEN_MASK	0x1
-#define CLKEN_OFF	23
-
-enum serdes_link_width {
-	X1 = 0x1,
-	X2 = 0x2
-};
-
-struct s32_serdes {
-	struct udevice *bus;
-	void __iomem *dbi;
-	struct reset_ctl *pcie_rst, *serdes_rst;
-	enum serdes_mode ss_mode;
-
-	int id;
-	enum serdes_dev_type devtype;
-	enum serdes_xpcs_mode xpcs_mode;
-	enum serdes_clock clktype;
-	enum serdes_clock_fmhz fmhz;
-	enum serdes_phy_mode phy_mode;
-};
+#include <compiler.h>
 
 int wait_read32(void __iomem *address, u32 expected,
 		u32 mask, int read_attempts);
 
-#endif /* PCIE_S32GEN1_H */
+#endif /* SERDES_S32GEN1_H */
-- 
2.17.1

