From bf751f1e29b6f825059b140545e786050f5b20e5 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Mon, 27 Jun 2022 13:56:56 +0300
Subject: [PATCH 21/33] arm: s32cc: Replace fdtdec calls with ofnode API

Issue: ALB-9010
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 arch/arm/mach-s32/s32-cc/fdt.c | 43 ++++++++++++++--------------------
 arch/arm/mach-s32/s32-cc/mp.c  | 29 ++++++++++-------------
 arch/arm/mach-s32/s32-cc/soc.c | 13 ++++------
 3 files changed, 35 insertions(+), 50 deletions(-)

diff --git a/arch/arm/mach-s32/s32-cc/fdt.c b/arch/arm/mach-s32/s32-cc/fdt.c
index 8f3885eee9..f7b5eeee97 100644
--- a/arch/arm/mach-s32/s32-cc/fdt.c
+++ b/arch/arm/mach-s32/s32-cc/fdt.c
@@ -13,6 +13,7 @@
 #include <asm/arch-s32/s32-cc/serdes_hwconfig.h>
 #include <dm/uclass.h>
 #include <linux/ctype.h>
+#include <linux/ioport.h>
 #include <linux/sizes.h>
 #include <s32-cc/a53_gpr.h>
 #include <s32-cc/fdt_wrapper.h>
@@ -20,8 +21,6 @@
 #include <dt-bindings/nvmem/s32cc-siul2-nvmem.h>
 #include <dt-bindings/phy/phy.h>
 
-DECLARE_GLOBAL_DATA_PTR;
-
 #define PCIE_ALIAS_FMT		"pcie%d"
 #define PCIE_ALIAS_SIZE		sizeof(PCIE_ALIAS_FMT)
 
@@ -107,19 +106,19 @@ static int get_cores_info(u32 *max_cores_per_cluster,
 
 static bool is_lockstep_enabled(void)
 {
-	int ret, off;
+	int ret;
 	u32 lockstep_enabled = 0;
 	struct udevice *s32cc_a53_gpr = NULL;
 	const char *a53_compat = "nxp,s32cc-a53-gpr";
+	ofnode node;
 
-	off = fdt_node_offset_by_compatible(gd->fdt_blob, -1, a53_compat);
-	if (off < 0) {
-		printf("%s: Couldn't find \"%s\" node: %s\n", __func__,
-		       a53_compat, fdt_strerror(off));
+	node = ofnode_by_compatible(ofnode_null(), a53_compat);
+	if (!ofnode_valid(node)) {
+		printf("%s: Couldn't find \"%s\" node\n", __func__, a53_compat);
 		return false;
 	}
 
-	ret = uclass_get_device_by_of_offset(UCLASS_MISC, off, &s32cc_a53_gpr);
+	ret = uclass_get_device_by_ofnode(UCLASS_MISC, node, &s32cc_a53_gpr);
 	if (ret) {
 		printf("%s: No A53 GPR (err = %d)\n", __func__, ret);
 		return false;
@@ -247,17 +246,12 @@ static int ft_fixup_memory(void *blob, bd_t *bd)
 	return apply_memory_fixups(blob, bd);
 }
 
-static int add_atf_reserved_memory(const void *old_blob, void *new_blob)
+static int add_atf_reserved_memory(void *new_blob)
 {
-	int ret, off;
+	int ret;
 	struct fdt_memory carveout;
-	struct fdt_resource reg;
-
-	/* Check FDT Headers */
-	if (fdt_check_header(old_blob)) {
-		pr_err("Invalid FDT Header for U-Boot DT Blob\n");
-		return -EINVAL;
-	}
+	struct resource reg;
+	ofnode node;
 
 	if (fdt_check_header(new_blob)) {
 		pr_err("Invalid FDT Header for Linux DT Blob\n");
@@ -265,14 +259,13 @@ static int add_atf_reserved_memory(const void *old_blob, void *new_blob)
 	}
 
 	/* Get atf reserved-memory node offset */
-	off = fdt_path_offset(old_blob, "/reserved-memory/atf");
-	if (off < 0) {
+	node = ofnode_path("/reserved-memory/atf");
+	if (!ofnode_valid(node)) {
 		pr_err("Couldn't find 'atf' reserved-memory node\n");
-		return off;
+		return -EINVAL;
 	}
 
-	/* Get value of 'reg' prop */
-	ret = fdt_get_resource(old_blob, off, "reg", 0, &reg);
+	ret = ofnode_read_resource(node, 0, &reg);
 	if (ret) {
 		pr_err("Unable to get value of 'reg' prop of 'atf' node\n");
 		return ret;
@@ -299,9 +292,9 @@ static int add_atf_reserved_memory(const void *old_blob, void *new_blob)
 	return 0;
 }
 
-static int ft_fixup_atf(const void *old_blob, void *new_blob)
+static int ft_fixup_atf(void *new_blob)
 {
-	int ret = add_atf_reserved_memory(old_blob, new_blob);
+	int ret = add_atf_reserved_memory(new_blob);
 
 	if (ret)
 		pr_err("Copying 'atf' node from U-Boot DT to Linux DT failed!\n");
@@ -731,7 +724,7 @@ int ft_system_setup(void *blob, bd_t *bd)
 	if (ret)
 		goto exit;
 
-	ret = ft_fixup_atf(gd->fdt_blob, blob);
+	ret = ft_fixup_atf(blob);
 
 exit:
 	return ret;
diff --git a/arch/arm/mach-s32/s32-cc/mp.c b/arch/arm/mach-s32/s32-cc/mp.c
index 4b741c864d..fde2c11979 100644
--- a/arch/arm/mach-s32/s32-cc/mp.c
+++ b/arch/arm/mach-s32/s32-cc/mp.c
@@ -18,8 +18,6 @@ struct cpu_desc {
 	bool on;
 };
 
-DECLARE_GLOBAL_DATA_PTR;
-
 static struct cpu_desc *cpus;
 static u32 n_cpus;
 
@@ -79,36 +77,33 @@ static int add_cpu(u32 psci_id)
 static int initialize_cpus_data(void)
 {
 	static bool initialized;
-	int off, ret = -1, addr_cells = 0;
-	fdt32_t *reg;
-	u64 core_id;
+	int ret = -1;
+	fdt_addr_t reg;
+	ofnode node;
 
 	if (initialized)
 		return 0;
 
-	off = fdt_path_offset(gd->fdt_blob, "/cpus");
-	if (off < 0) {
+	node = ofnode_path("/cpus");
+	if (!ofnode_valid(node)) {
 		printf("Couldn't find /cpus node\n");
 		return -EINVAL;
 	}
 
-	fdt_support_default_count_cells(gd->fdt_blob, off, &addr_cells, NULL);
-	off = get_next_cpu(gd->fdt_blob, off);
+	for (;;) {
+		node = ofnode_by_prop_value(node, "device_type", "cpu", 4);
+		if (!ofnode_valid(node))
+			break;
 
-	while (off != -FDT_ERR_NOTFOUND) {
-		reg = (fdt32_t *)fdt_getprop(gd->fdt_blob, off, "reg", 0);
-		if (!reg) {
+		reg = ofnode_get_addr_size_index_notrans(node, 0, NULL);
+		if (reg == FDT_ADDR_T_NONE) {
 			ret = -EINVAL;
 			break;
 		}
 
-		core_id = fdt_read_number(reg, addr_cells);
-
-		ret = add_cpu(core_id);
+		ret = add_cpu(reg);
 		if (ret)
 			break;
-
-		off = get_next_cpu(gd->fdt_blob, off);
 	}
 
 	if (ret) {
diff --git a/arch/arm/mach-s32/s32-cc/soc.c b/arch/arm/mach-s32/s32-cc/soc.c
index b744b47fbc..5bf7df0f8e 100644
--- a/arch/arm/mach-s32/s32-cc/soc.c
+++ b/arch/arm/mach-s32/s32-cc/soc.c
@@ -3,12 +3,12 @@
  * Copyright 2014-2016 Freescale Semiconductor, Inc.
  * Copyright 2017-2022 NXP
  */
-
 #include <common.h>
 #include <debug_uart.h>
 #include <asm/global_data.h>
 #include <asm/sections.h>
 #include <asm/armv8/mmu.h>
+#include <dm/ofnode.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -76,15 +76,12 @@ struct mm_region *mem_map = s32_mem_map;
 static void disable_qspi_mmu_entry(void)
 {
 	struct mm_region *region;
-	int offset;
+	ofnode node;
 	size_t i;
 
-	offset = fdt_node_offset_by_compatible(gd->fdt_blob, -1,
-					       "nxp,s32cc-qspi");
-	if (offset > 0) {
-		if (fdtdec_get_is_enabled(gd->fdt_blob, offset))
-			return;
-	}
+	node = ofnode_by_compatible(ofnode_null(), "nxp,s32cc-qspi");
+	if (ofnode_valid(node) && ofnode_is_available(node))
+		return;
 
 	/* Skip AHB mapping by setting its size to 0 */
 	for (i = 0; i < ARRAY_SIZE(s32_mem_map); i++) {
-- 
2.17.1

